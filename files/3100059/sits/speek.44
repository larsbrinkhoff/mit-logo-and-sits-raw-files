.TITLE SPEEK
.SBTTL DATA

	.BLKW 100
PDL:
	.BLKW 15
PDL1:
	.BLKW 15
PDL2:
	.BLKW 15
PDL3:

.INSRT GLD;UTILIT >

SYMNUM=	14.
SNAMES:	.RAD50 /NITEMS/	;NAMES OF SITS SYMBOLS
	.RAD50 /FIRSTQ/
	.RAD50 /NTTYS/
	.RAD50 /TTYITM/
	.RAD50 /ITMFRE/
	.RAD50 /PFREEQ/
	.RAD50 /ITMAFR/
	.RAD50 /LCKFRE/
	.RAD50 /ACTFRE/
	.RAD50 /DMRPNT/
	.RAD50 /PBFREL/
	.RAD50 /FPBFRE/
	.RAD50 /FUPTFR/
	.RAD50 /FNBFRE/
SVALUS:			;SITS ADDRESSES OF ABOVE SYMBOLS
NITEMS:	.WORD 0
FIRSTQ:	.WORD 0
NTTYS:	.WORD 0
TTYITM:	.WORD 0
FREPTS:
ITMFRE:	.WORD 0
PFREEQ:	.WORD 0
ITMAFR:	.WORD 0
LCKFRE:	.WORD 0
ACTFRE:	.WORD 0
DMRPNT:	.WORD 0
PBFREL:	.WORD 0
FPBFRE:	.WORD 0
FUPTFR:	.WORD 0
FNBFRE:	.WORD 0
OVERNO:	.WORD 0		;LAST KNOWN VERS. NO. OF SITS
VERNO:	.BLKW 10	;SITS VERS. NO. & OTHER STATUS INFO

ITMCF:	.WORD 0		;CORRECTION FACTOR OF ITMTAB
FRSTQ:	.WORD 0		;PTR TO FIRSTQ
DATTAB:	.BLKW 1024.

ITMTPG=	27
QUEPAG=	26
ITEMPG=	25
AXITPG=	24

FILCAP:	.WORD 0
FILXCP:	.WORD 0
CRCAP=	0		;CAP NO OF CREATE CAPABILITY
OWNSPC=	1		;CAP NO TO ONE'S OWN SPHERE
TTYCAP=	2		;CAP NO OF TTY
DK0CAP=	10

OUTDEV:	.WORD TTYCAP	;INITIAL OUTPUT DEVICE IS TTY CONSOLE
QUECAP:	.WORD 0
MOREQ:	.WORD 0
BREAKQ:	.WORD 0
BREAKF:	.WORD 0

COMND:	.BYTE 'S*2	;START IN NORMAL MODE (S FOR NOW)
CMDPDG:	.BYTE 'S*2		;PENDING COMMAND MODE
BRKLNK:	.WORD 0

FLUFLG:	.WORD 0		;FLAG FOR FLUSHING MORE OUTPUT
UPDATS:	.WORD 0
FLGUPD:	.WORD 0
UPDTIM:	60.*60.
LINBUF:	.BLKW 100

CMNDIS:	.BLKW 200	;TABLE FOR DISPATCH ON ASCII CMNDS
.MACRO	DISP NUM,RTN
	.=2*NUM+CMNDIS
	RTN
.ENDM
	DISP 'D,MDEVIC
	DISP 'F,MFREE
	DISP 'I,MITEMS
	DISP 'L,MLINPT
	DISP 'N,MSPHRS
	DISP 'Q,QUIT
	DISP 'S,MSPHRS
	DISP 'T,MTYPES
	DISP 'U,MUSERS
	DISP 'X,MUPDSP
	DISP 15,MUPDAT
	DISP 40,MNOOP
	DISP '?,MINFO
	.=CMNDIS+400
.SBTTL MACROS.PRINTOUT

.MACRO	OUTPUT BEGM
	SAVE B
	MOV BEGM,B
	JSR PC,SOTPUT
	REST B
.ENDM
SOTPUT:	SAVE A
	CMP OUTDEV,#TTYCAP
	BNE 21$
23$::	MOVB (B)+,-(P)
	BEQ OUTPTE
	CLRB 1(P)
	SAVE #<TTYCAP+.TTMBK>
	$BYTO
	BR 23$
21$::	CLR A
24$::	CMPB (B),#11
	BNE 25$
26$::	BIC #177770,A
	SAVE #40
	SAVE OUTDEV
	$BYTO
	SOB A,26$
	TSTB (B)+
	BR 24$
25$::	DEC A
	MOVB (B)+,-(P)
	BEQ OUTPTE
	CLRB 1(P)
	SAVE OUTDEV
	$BYTO
	BR 24$
OUTPTE:	REST
	REST A
	RTS PC
	.MACRO	HEADER NAMES
	.BYTE 15
	.IRP X,<NAMES>
	.ASCII /X/
	.BYTE 11
	.ENDM
	.BYTE 15,12,0
.ENDM
.MACRO BUF CHAR
	MOVB CHAR,(B)+
.ENDM
.MACRO TOPPAG
	SAVE #14
	SAVE OUTDEV
	$BYTO
.ENDM
.MACRO BUFE
	CLRB (B)+
.ENDM
.MACRO	TABLE DATA
	.IRP X,<DATA>
	MOV X,(F)+
	.ENDM
.ENDM
.MACRO	PRINIT LOOP,HEAD,NUM
	SAVE <A,B>
	.IIF NB HEAD,OUTPUT #HEAD
	.IF NB NUM
	MOV NUM,E
	MOV #DATTAB,F
	.ENDC
LOOP:	MOV #LINBUF,B
.ENDM
.MACRO	XFER1 ARG
	MOVB ARG,(B)+
.ENDM
.MACRO	XFER N,REG
	MOV #N,C
1$::	.IIF B REG,TSTB (F)
	.IELSE TSTB ('REG')
	BNE 2$
	BUF #40
	INC F
	BR 3$
2$::	.IIF B REG,BUF (F)+
	.IELSE BUF ('REG')+
3$::	SOB C,1$
	BUF #11
.ENDM
.MACRO	OWD N,SRC
	.REPT N
	.IIF B SRC,MOV (F)+,A
	.IELSE MOV SRC,A
	JSR PC,CNVOWD
	BUF #11
	.ENDR
.ENDM
.MACRO	OBYT N,SRC
	.REPT N
	.IIF B SRC,MOVB (F)+,A
	.IELSE MOVB SRC,A
	JSR PC,CNVOBT
	BUF #11
	.ENDR
.ENDM
.MACRO	ITM N,SRC
	.REPT N
	.IIF B SRC,MOVB (F)+,A
	.IELSE MOVB SRC,A
	JSR PC,CNVITM
	BUF #11
	.ENDR
.ENDM
.MACRO	LINEND
	BUF #15
	BUFE
	TST FLUFLG		;PROCEED OR FLUSH?
	BEQ 44$
	TYPE #TTYCAP,#FLUSH		;INFORM OF FLUSH
	CLR FLUFLG
	REST <B,A>
	RTS PC
44$:	OUTPUT #LINBUF
	QUNLK MOREQ
.ENDM
.MACRO	PREND LOOP,CTN
	LINEND
	.IF NB CTN
CTN:
	.ENDC
;	SOB E,LOOP
	DEC E
	BEQ .+6
	JMP LOOP
	REST <B,A>
.ENDM
FLUSH:	.ASCIZ /--FLUSHED/
	.EVEN
.MACRO	PRCLUP
	REST <B,A>
.ENDM
.MACRO	SKIPB
	INC F
.ENDM
.SBTTL MACROS.MISC
.MACRO	CLEAR N,ADDR
	.IIF B ADDR,MOV #DATTAB,F
	.IELSE MOV ADDR,F
	MOV N,E
	CLR (F)+
	SOB E,.-2
.ENDM
.SBTTL MAIN ROUTINES

GO:
SPEEK:	MOV #PDL,P
	JSR PC,SYMBS
	CREATE .QUCAP,#1		;CREEATE A QUE
	IFERR QUIT
	REST QUECAP		;PUT CAP. NO. IN QUECAP
	CREATE .QUCAP,#1		;ANOTHER ONE
	IFERR QUIT
	REST MOREQ
	CREATE .QUCAP,#0		;AND ANOTHER
	IFERR QUIT
	REST BREAKQ
				;WE'RE GOING TO MAP IN THE ITEM
	MOV ITMFRE,B		; TABLE,ALONG WITH ITMFRE(PRECDG WD)
	MOV #ITMTPG,F		;MAP INTO ITM TBL PG(I=D P7)
	JSR PC,ABSMAP		;PUTS ITMTAB C.F.IN B,PTR TO
	MOV B,ITMCF		; ITMFRE IN C
	MOV C,A
	ADD #2,A		;A HOLDS POINTER TO ITMTAB
	MOV FIRSTQ,B		;PROCESS TABLE GETS MAPPED IN NEXT
	MOV #QUEPAG,F		;I=D P6
	JSR PC,ABSMAP		;THIS PUTS PRCTAB C.F.IN B
	MOV C,FRSTQ		; AND POINTER TO FIRSTQ IN C

	INVOK #TTYCAP,#.TTMOV*400,#.TMORM+.TICVM+.TICTM	;SET TTY MODE
	FORK #TTYINT		;START PROCESS TO GET COMMANDS
	FORK #UPDATE		;START PROCESS TO DO UPDATES
	FORK #MORBRK		;  "      "    "  DO MORE BREAKS

				;MAIN LOOP--COMMAND DIPATCH
CMNDIN:	QULK QUECAP		;WAIT FOR COMMAND
	SAVE <A,B>		;A,B PRESERVED FOR ALL MODES
	MOVB COMND,F		;ASCII COMMAND
	BIC #177400,F
	JSR PC,@CMNDIS(F)	;HEAR AND OBEY
	REST <B,A>
	BR CMNDIN

TTYINT:	MOV #PDL1,P
	BYTI #TTYCAP		;READ TTY COMMAND CHAR
	MOV (P),A		;PUT IT IN A
	SAVE #TTYCAP
	$BYTO			;ECHO
	BIC #200,A		;JUST IN CASE
	ASL A			;=>WORDS
	TST CMNDIS(A)			;VALID?
	BNE 1$
	TYPE #TTYCAP,#HUH		;NOPE
	BR TTYINT
1$::	MOVB A,COMND		;YES,PUT IN COMND
	MOVB A,BRKLNK		;MORBRK WILL WANT THIS
	SUB #<40*2>,BRKLNK		;ZERO IF SPACE
	TST BREAKF		;MORE BREAK PENDING?
	BEQ 2$			;IF NOT,PROCEED
	QUNLK BREAKQ		;IF SO,RELEASE MORBRK
	CLR BREAKF		;ONE-SHOT ONLY
2$::	QUNLK QUECAP		;UNLOCK QUE,UNHANGING CMNDIN
	BR TTYINT		;KEEP GOING
HUH:	.BYTE '?,0
	.EVEN

UPDATE:	MOV #PDL2,P
	SLEEP #0,UPDTIM		;WAIT A MINUTE
	TST UPDATS		;SHOULD WE OR SHOULDN'T WE?
	BNE UPDATE		;NO
	QUNLK QUECAP		;YES,UNHANG CMNDIN LOOP
	BR UPDATE

MORBRK:	MOV #PDL3,P
	INVOK #TTYCAP,#<.TTBRKA*400>,#0,#.TTMBK	;BREAK ON "MORE"
	IFERR QUIT
	DEC BREAKF		;FLAG BREAK IN PROGRESS
	REST
	TYPE #TTYCAP,#MOOR		;ASK IF WANT MORE
	QULK BREAKQ		;MUST HANG HERE,WAIT FOR TTYINT
	MOVB BRKLNK,FLUFLG	;SET/CLR THE FLUSH FLAG
	INVOK #TTYCAP,#<.TTBIC*400>,#.TMORF,#0	;UNHANG OUTPUT
	BR MORBRK
MOOR:	.ASCIZ /...MORE.../
	.BYTE 15,0
	.EVEN
.SBTTL SITS SYMBOLS UPDATE

SYMBS:	SSTAT #VERNO	;GET VERSION # OF SITS
	INVOK #DK0CAP,#.CPYCP,#0,#-1	;COPY CAP TO 0;
	REST FILXCP
	INVOK. FILXCP,#.FAMU,#SPKMUT,#0	;GET CAP TO AUX FILE
	BNE SYMBS1	;DID THAT WORK?
	MOV FILXCP,(P)	;NO,ADD THE FILE
	BIS #.FAAD,(P)
	$INVOK
	BR SYMUPD	;AND UPDATE
SYMBS1:	BLKI. FILXCP,#-<SYMNUM+1>*2,#SVALUS	;READ OVERNO,SVALUS
	BNE SYMBS2	;DID THAT WORK?
	ADD #6,P	;NO,POP LOSING ARGS
	BR SYMUPD	;AND UPDATE
SYMBS2:	CMP VERNO,OVERNO	;SAME AS BEFORE?
	BEQ SYMDON	;IF SO,ALL DONE
SYMUPD:	MOV VERNO,OVERNO	;OLD IS NEW
	INVOK #DK0CAP,#.CPYCP,#0,#-1	;COPY CAP TO 0;
	REST FILCAP
	INVOK FILCAP,#.FAMU,#SYMFIL,#0	;MUTATE TO SYMS

	MOV #4,A	;COUNTER
	MOV #24,B	;DEST PG NO
	CLR C		;SRC PG NO
SYMAPL:	MAP #OWNSPC,#.CRRD,FILCAP,B,C,#0,#-1	;MAP IN FILE PG
	INC B
	INC C
	SOB A,SYMAPL

	MOV #SNAMES,A	;PTR TO NAMES
	MOV #SVALUS,B	;PTR TO VALUS
	MOV #SYMNUM,SCOUNT	;COUNTER

SYMBL:	MOV #100110,D	;SET FIL PTR TO BEG
	MOV #436,E	;# BLOCKS IN FILE

SYMBL1:	MOV #16.,C	;16 WDS/BLOCK

SYMBL2:	CMP (D)+,(A)+	;SYMBOLS THE SAME SO FAR?
	BEQ SOKSOF	;IF SO,SEE IF REST OF SYMB IS OK
	SUB #2,A	;IF NOT,GO BACK TO SYM NAM BEG
	ADD #4,D	;AND GO TO NEXT SYM IN FILE
	BR SYMNXT
SOKSOF:	CMP (D)+,(A)+	;DOES THE REST OF THE SYMBOL MATCH?
	BEQ SYMWIN	;IF SO,WE'VE GOT THE RIGHT ONE
	SUB #4,A	;IF NOT,RETURN TO SYM NAM BEG
	ADD #2,D	; AND SKIP PAST VALUE WORD
SYMNXT:	SOB C,SYMBL2	;GO ON TO NEXT SYMBOL IN FILE
	ADD #4,D	;SKIP PAST FLAG WDS AT END OF BLOCK
	SOB E,SYMBL1
	BPT

SYMWIN:	MOV (D)+,(B)+	;STORE VALUE
	DEC SCOUNT	;1 MORE SYMBOL FOUND
	BGT SYMBL	;ANY MORE TO GO?

	INVOK FILXCP,#.FADL	;DELETE SPKAUX FILE
	INVOK #DK0CAP,#.CPYCP,#0,#-1	;COPY ROOT CAP
	REST FILXCP
	INVOK FILXCP,#.FAMU,#SPKDOT	;MUTATE TO 0; .
	INVOK FILXCP,#.FAAD,#SPKAUX	;ADD NEW SPKAUX
	BLKO FILXCP,#-<SYMNUM+1>*2,#SVALUS	;WRITE NEW VERNO,SYMVALS
	INVOK FILCAP,#.DELCP	;DELETE FILE CAP.S
SYMDON:	INVOK FILXCP,#.DELCP
	RTS PC

SCOUNT:	.WORD 0
SPKDOT:	.ASCIZ /./
SPKMUT:	.ASCII /. /
SPKAUX:	.ASCIZ /SPKAUX/
SYMFIL:	.ASCIZ /SYMS/
	.EVEN
.SBTTL MAPPING ROUTINES

;CALL WITH ABS ADDR IN B,SPEEK PG NO TO MAP INTO IN F.
;ABSMAP MAPS IN AN ABSOLUTE PAGE FROM SITS STARTING AT
;THE BLOCK BOUNDARY BEFORE THE ABS ADDR IN B.
;ABSMAP RETURNS WITH PTR TO THE ABS ADDR IN C,CORRECTION
;FACTOR IN B.
ABSMAP:	MOV B,C
	ASH #-10.,B	;BIG BLOCK NO.OF ADDR

	MAP #OWNSPC,#.CRRD,#-2,F,B,#0,#7	;MAP IT IN

	ASH #10.,B	;SPEEK BIG BLOCK BASE
	NEG B
	ASH #13.,F	;PAGE ADDR
	ADD F,B		;B IS C.F.
	ADD B,C		;C IS PTR
	RTS PC

;ITEMAP MAPS AN ITEM FROM SITS.
;CALL WITH ITEM INDEX IN D, SPEEK PG NO TO MAP INTO IN E.
;RETURNS WITH PTR TO ITEM IN E.
ITEMAP:	SAVE D
	MOVB E,PAGENO	;ESTABLISH PAGE # FOR MAP.
	ASH #13.,E	;CONVERT TO ADDRESS OF PG BASE
	MOV E,ITMPAD	; AND STORE
	ADD A,D		;D POINTS TO ITMTAB ENTRY
	MOV (D),E	;E IS SITS PTR TO ITM/64.(+HI GARB BITS)
	MOV E,D
	ASH #-4,D	;BIG BLOCK NO.OF ITEM
	BIC #177400,D	;MINUS GARBAGE BITS

	MAP #OWNSPC,#.CRRD,#-2,PAGENO,D,#0,#7

	ASH #10.,D	;SITS BIG BLOCK BASE OF NEW PG
	NEG D
	ADD ITMPAD,D	;D IS C.F.
	ASH #6,E	;E IS SITS PTR TO ITEM
	ADD D,E		;E POINTS TO ITEM
	REST D
	RTS PC
ITMPAD:	.WORD 0
PAGENO:	.WORD 0
.SBTTL MODE ROUTINES.QUICKIES

MLINPT:	MOVB CMDPDG,COMND	;RESTORE PREV COMMAND MODE
	CMP OUTDEV,#TTYCAP	;ARE WE OUTPUTTING TO TTY?
	BEQ 1$			;IF SO,SWITCH TO LINEPRINTER
	INVOK #.DELCP,OUTDEV,#0,#0	;IF NOT,DELETE LINEPTR CAP
	IFERR QUIT
	MOV #TTYCAP,OUTDEV	; AND SWITCH TO TTY
	TYPE #TTYCAP,#TTYS		;INFORM USER
	MOV FLGUPD,UPDATS	;RESTORE UPDATE STATUS
	RTS PC
1$::	CREATE .LPCAP,#0		;CREATE A LP CAP
	BEQ SORRY
	REST OUTDEV		;USE FOR FUTURE OUTPUT
	TYPE #TTYCAP,#LNPTS		;INFORM USER
	DEC UPDATS		;NO LINEPTR UPDATES
	RTS PC
SORRY:	REST
	REST
	REST
	TYPE #TTYCAP,#LOSE		;INFORM USER OF CREATE FAILURE
	MOVB CMDPDG,COMND	;RESTORE PREV COMMAND
	RTS PC
LOSE:	.ASCII /LINEPRINTER UNAVAILABLE/
	.BYTE 15,0
LNPTS:	.ASCII /...SWITCHING OUTPUT TO LINEPRINTER.../
	.BYTE 15,0
LNPTSE:
TTYS:	.ASCII /...SWITCHING OUTPUT BACK TO THIS CONSOLE.../
	.BYTE 15,0
	.EVEN

MUPDSP:	MOVB CMDPDG,COMND	;RESTORE PREV COMND MODE
	TST FLGUPD		;ARE WE IN UPDATE MODE?
	BEQ 1$			;IF SO,SWITCH
	CLR FLGUPD		;IF NOT,SWITCH
	CLR UPDATS		;FREE TO GO
	TYPE #TTYCAP,#UPDMSG		;INFORM USER
	RTS PC
1$::	DEC FLGUPD		;LEAVING UPDATE MODE
	DEC UPDATS		;DONE!
	TYPE #TTYCAP,#XUPMSG		;SAY SO
	RTS PC
UPDMSG:	.ASCII /...UPDATE EVERY MINUTE.../
	.BYTE 15,0
XUPMSG:	.ASCII /...AUTOMATIC UPDATES SUPRESSED.../
	.BYTE 15,0
	.EVEN

MUPDAT:	MOVB CMDPDG,COMND	;RESTORE PREV MODE
	MOVB COMND,F		;AND DO IT!
	BIC #177400,F
	JMP @CMNDIS(F)
		
QUIT:	BPT
	RTS PC

MNOOP:	RTS PC
.SBTTL MODE ROUTINES.MDEVIC
;FOR EACH DEVICE IN USE, PRINT: DEVICE NAME, USER NAME
MDEVIC:	SAVE B
	MOVB #'D*2,CMDPDG	;NOTE PENDING COMMAND MODE
	MOV #DATTAB,C
	MOV NTTYS,B
	ADD#3,B
	MUL #5,B
MDCLR:	CLR (C)+	;CLEAR PORTION OF DATTAB
	SOB B,MDCLR

	MOV TTYITM,B	;SITS PTR TO TTYITM TABLE
	MOV #ITEMPG,F
	JSR PC,ABSMAP	;MAP IN TTYITM,PTR IN C
	MOV #DATTAB,B	;INIT DATTAB PTR
	MOV NTTYS,F	;# OF TTYITM ENTRIES
MDL1:	JSR PC,MDWORK	;IF ITEM EXISTS, PUT USER NAME IN DATTAB
			;ELSE SKIP OVER DATTAB ENTRY
	SOB F,MDL1
			;NOW, LOOK FOR LPT,PTP,PTR ITEMS
	MOV #4,D	;INDEX OF 1ST ITEM
	MOV NITEMS,F	;COUNTER
MDITMS:	MOV #ITEMPG,E
	JSR PC,ITEMAP	;MAP ITEM IN
	CMP (E),#ITMMAX	;ITEM # IN PROPER RANGE?
	BHI MDITM2	;IF NOT, SKIP IT
MDITM1:	MOV (E),C	;GET ITEM #
	ASL C
	JSR PC,@MDDISP(C)	;AND DISPATCH OFF IT
MDITM2:	ADD #4,D	;ADVANCE TO NEXT ITEM,
	SOB F,MDITMS	;IF ANY
	REST B
	JMP MDOUTP	;PRINT DATA

MDWORK:	MOV (C)+,D	;GET ITEM #
	BEQ MDWSKP	;IF ZERO,SKIP
	MOV #AXITPG,E	;MAP IN TTY ITEM
	JSR PC,ITEMAP
	MOV 10(E),D	;GET USER #
	BNE MDW1	;IF ANY
	MOVB 'X,(B)	;IF NOT,MYSTERY USER
	BR MDWSKP
MDW1:	ADD 2(P),D	;PTR INTO USER ENTRY
	MOV 4(D),D	;GET USER ITEM #
	MOV #AXITPG,E	;MAP IN USER ITEM
	JSR PC,ITEMAP
	ADD #16,E	;POINT TO USER NAME
	MOV #5,D
MDW2:	MOV (E)+,(B)+	;STASH UNAME IN DATTAB
	SOB D,MDW2
	RTS PC
MDWSKP:	ADD #10.,B	;SKIP BY DATTAB ENTRY
	RTS PC

MDDISP:	.REPT 9
	.WORD MDNOOP
	.ENDR
	.WORD MDYSOP
	.WORD MDYSOP
	.WORD MDYSOP
MDNOOP:	RTS PC

MDYSOP:	MOV MDINDX(C),B	;GET PTR TO DATTAB ENTRY
	ADD NTTYS,B
	MUL #10.,B
	ADD #DATTAB,B
	MOVB #'?,(B)	;***TEMP USER NAME***
	RTS PC

MDINDX=	.-<9*2>
	.WORD 0
	.WORD 1
	.WORD 2
MDOUTP:	BYTO OUTDEV,#14	;TOP OF PAGE
	OUTPUT #MDEVHD	;PRINT HEADER

	MOV #DATTAB,A	;INIT DATTAB PTR
	MOV #MDEVNM,B	;AND DEVICE NAME POINTER
	MOV NTTYS,C	;AND DEVICE COUNTER
	ADD #3,C	;(FOR LPTR,TAPE PUNCH, TAPE RDR)
MDO1:	MOV #LINBUF,D	;INIT LINBUF PTR
	TST (A)		;ANYTHING THERE?
	BNE MDO2
	ADD #10.,A	;IF NOT,SKIP ENTRY
	ADD #10.,B
	BR MDOSOB

MDO2:	MOV #10.,E
MDO3:	MOVB (B)+,(D)+	;DEVICE NAME
	BNE MDO3A	;0'S GET REPLACED BY SPACES
	MOVB #40,-1(D)
MDO3A:	SOB E,MDO3
	MOVB #11,(D)+	;TAB
	MOV #10.,E
MDO4:	MOVB (A)+,(D)+	;USER NAME
	BNE MDO4A
	MOVB #40,-1(D)	;SPACE OUT ZEROS
MDO4A:	SOB E,MDO4
	MOVB #15,(D)+	;CR
	CLRB (D)+	;FENCE
	OUTPUT #LINBUF	;PRINT LINE
MDOSOB:	SOB C,MDO1	;AND GO ON TO NEXT
	RTS PC
MDEVHD:	HEADER <DEVICE    ,USER>
MDEVNM:	.ASCII /SYSTEM CNS/
	.ASCII /T01       /
	.ASCII /T02       /
	.ASCII /T03       /
	.ASCII /T04       /
	.ASCII /T05       /
	.ASCII /T06       /
	.ASCII /T07       /
	.ASCII /VOTRAX T08/
	.ASCII /T09       /
	.ASCII /T10       /
	.ASCII /T11       /
	.ASCII /T12       /
	.ASCII /PDP10  T13/
	.ASCII /T14       /
	.ASCII /T15       /
	.ASCII /T16       /
	.ASCII /THORTON BX/
	.IRP X,<0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31>
	.ASCII /TV/
	.WORD "X
	.ASCII /      /
	.ENDM
	.ASCII /NULL0     /
	.ASCII /NULL1     /
	.ASCII /NULL2     /
	.ASCII /NULL3     /
	.ASCII /TAPE READR/
	.ASCII /TAPE PUNCH/
	.ASCII /LINEPRINTR/
.SBTTL MODE ROUTINES.MSPHRS
;
;
;
MSPHRS:	CLEAR #1024.		;CLEAR THE DATTAB
	MOVB #'S*2,CMDPDG		;NOTE PENDING COMMAND MODE
	MOV FRSTQ,C		;C POINTS TO FIRSTQ
	ADD #52,C		;C POINTS TO SPHRQ
	CLR SPHCNT		;INITIALIZE SPHERE COUNT
	MOV #DATTAB+1024.,F		;INITIALIZE TABLE PTR

MSPNX1:	MOV (C),C		;SITS PTR TO NEXT SPHRQ NODE
	BEQ SPHRGO		;END OF LIST?
	ADD B,C			;ADD C.F. GIVING PTR TO NODE

	MOV 4(C),D		;ITEM NO OF SPHR ITEM
	MOV #ITEMPG,E		;PG NO TO MAP INTO
	JSR PC,ITEMAP		;MAP IN THE ITEM,PTR TO IT RETRNING IN E
			;EACH ITMTAB SPHERE ENTRY IS TO HAVE A
			;CORRESPONDING DATTAB ENTRY WITH THE SAME
			;INDEX. BYTE 0 OF EACH ENTRY POINTS (INDEX/4) TO
			;INFERIOR SPHERE (IF ANY, 0 ELSE). BYTE 1 POINTS
			;TO A SIBLING SPHERE, IF ANY. THE 2ND WORD POINTS
			;TO ADDITIONAL DATA ABOUT THE SPHERE.
	SAVE F
	MOV F,DATTAB+2(D)	;POINTER TO DATA AREA
	MOV 34(E),F		;INDEX OF MASTER SPHERE
	BPL 1$			;WAS THERE REALLY AN INDEX?
	MOV D,SYSSPR		;IF NOT,THIS IS THE SYSSPR
	BR 2$
1$::	MOVB DATTAB(F),DATTAB+1(D)	;CONS NEW INF SPH ONTO SIBLING LST
	ASH #-2,D		;SQUEEZE INDEX INTO BYTE
	MOVB D,DATTAB(F)	;MAKE MSTR SPH POINT TO NEW INF SPH
2$::	REST F			;RESTORE DATA AREA PTR
	SAVE E
	MOV 6(C),D		;SITS PTR TO USERQ ENTRY
	ADD B,D			;PTR TO USERQ ENTRY
	MOV 4(D),D		;ITEM # OF USER
	MOV #AXITPG,E		;MAP INTO AUX ITEM PG
	JSR PC,ITEMAP		;BRING IN THE USER ITEM
	TABLE <16(E),20(E),22(E),24(E),26(E)>	;RECORD USER NAME

	MOV (P),E		;RESTORE PTR TO SPHR ITEM
	MOV 220+<3*12>+2(E),D	;TTY ITEM# FROM SHPR CAP#3
	BNE 3$			; IF THERE IS ONE
	TABLE #0		;IF NOT,OH WELL
	BR 4$
3$::	MOV #AXITPG,E		;MAP INTO AUX ITEM PG
	JSR PC,ITEMAP		;GO GET IT
	TABLE 6(E)		;RECORD LOG. TTY NO.
4$::	REST E			;SPHERE PTR AGAIN
	TABLE <26(E),30(E)>	;RECORD #PROCESSES,#ACTIVE
	INC SPHCNT
				;SHOULD MAKE SURE DATTAB ISN'T EXCEEDED
	BR MSPNX1
				;SPHRGO ON NEXT PAGE
SPHCNT:	.WORD 0
SYSSPR:	.WORD 0
.SBTTL MODE ROUTINES.MSPHRS.OUTPUT

SPHRGO:	MOVB SYSSPR,E		;INDEX OF SYSSPR
	CLR SPDPTH		;TOP LEVEL SPHERE
	TOPPAG
	PRINIT MSPNX2,MSPHD
	MOV DATTAB+2(E),F	;F POINTS TO SPHERE DATA
	MOV SPDPTH,D
	BEQ 10$
11$::	XFER1 #74		;SHOW SUBORDINATION
	SOB D,11$
10$::	XFER1 #11		;TAB
	OBYT 1,E		;PRINT ITEM #
	XFER 10.		;PRINT USER NAME
	OWD 3			;PRINT TTY#,#PROCS,#ACTIV
	LINEND

	TSTB DATTAB(E)		;INFERIOR SPHERES?
	BEQ 12$
	SAVE E			;IF SO,SAVE THIS TREE NODE
	INC SPDPTH		; AND GO ONE LEVEL DEEPER
	MOVB DATTAB(E),E	;GET INDEX/4 OF INFERIOR SPH
	BIC #177400,E		;SIGH
	ASH #2,E		;INDEX OF INF SPH
	JMP MSPNX2		;ANOTHER SPHERE,ANOTHER LOOP

12$::	MOVB DATTAB+1(E),E	;SIBLING SPHERE?
	BEQ 13$
	BIC #177400,E		;IF SO,PROCESS IT
	ASH #2,E
	JMP MSPNX2
13$::	REST E			;IF NOT,FALL BACK TO MSTR SPH,
	DEC SPDPTH		; ONE LEVEL HIGHER
	BGT 12$			;(IF THERE IS ONE LEVEL HIGHER)

	PRCLUP			;ALL DONE. CLEAN UP
	RTS PC			; AND GO HOME.

MSPHD:	HEADER <DEPTH,SPHR#,USER NAME,TTY#,#PROCS,#ACTIV>
	.EVEN
SPDPTH:	.WORD 0
.SBTTL MODE ROUTINES.MUSERS
;
;
;
MUSERS:	MOVB #'U*2,CMDPDG		;NOTE PENDING COMMAND MODE

1$::	MOV FRSTQ,C		;C POINTS TO FIRSTQ
	ADD #44,C		;C POINTS TO USERQ
	CLR USRCNT
	MOV #DATTAB,F		;MUSTAB PTR

MUSNX1:	MOV (C),C		;SITS PTR TO NEXT USERQ NODE
	BEQ MUSEGO		;END OF LIST?
	ADD B,C			;ADD C.F. GIVING PTR TO NODE

	MOV 4(C),D		;ITEM NO OF USER ITEM
	MOV #ITEMPG,E		;NEW PG NO
	JSR PC,ITEMAP		;MAP IN THE ITM,PTR TO IT RETURNING IN E

	TABLE <16(E),20(E),22(E),24(E),26(E)>	;RECORD USER NAME
	TABLE <D,6(C),10(C),12(C)>	;RECORD ITEM#,
				;PROCESS PTR,JMTU,PRIORITY,
	TABLE <10(E),12(E)>	;AND TIME USED

	INC USRCNT
	BR MUSNX1

MUSEGO:	TOPPAG
	PRINIT MUSNX2,MUSHD,USRCNT	;PRINT HEADER AND SET UP
				;LINE PRINT LOOP
	XFER 10.		;ALREADY-ASCII BYTES INTO LINBUF
	OWD 6			;=>OCATAL ASCII
	PREND MUSNX2		;PRINT LINE,LOOP BACK,FALL THRU
	RTS PC
MUSHD:	HEADER <USER NAME,ITEM#,PRC PT,JTMU,PRIOR,TIME USED>
	.EVEN
USRCNT:	.WORD 0
.SBTTL MODE ROUTINES.MFREE

;
;
;
FREPTN=10.
MFREE:	MOVB #'F*2,CMDPDG	;NOTE CURRENT COMMAND MODE
	SAVE B
	CLEAR #<FREPTN/2+<FREPTN&1>>,#FRENMS
	MOV #FREPTN,E		;COUNTER
	MOV #FREPTS,D		;PTR TO LIST PTRS
MFLOOP:	MOV (D)+,B		;ADDRESS OF LIST BEG
	MOV #ITEMPG,F		;PAGE TO MAP INTO
	JSR PC,ABSMAP		;BRING IN THE LIST
MFLNXN:	MOV (C),C		;SITS PTR TO NEXT NODE,
	BEQ MFREGO		; IF ANY
	ADD B,C			;PTR TO NEXT NODE
	INCB FRENMS-1(E)	;AND PROCEED TO NEXT NODE
	BR MFLNXN

MFREGO:	SOB E,MFLOOP		;UNTIL EXHAUSTED
	REST B

	MOV #FREASC,D
	TOPPAG
	PRINIT MFRELP,MFREHD,#FREPTN
	XFER 7,D
	OBYT 1,FRENMS-1(E)
	PREND MFRELP		;LOOP,CLEAN UP
	RTS PC
MFREHD:	HEADER <FREPTR,COUNT>
	.EVEN
FRENMS:	.BLKB 10.
	.EVEN
FREASC:	.ASCII /ITMFRE:/
	.ASCII /PFREEQ:/
	.ASCII /ITMAFR:/
	.ASCII /LCKFRE:/
	.ASCII /ACTFRE:/
	.ASCII /DMRPNT:/
	.ASCII /PBFREL:/
	.ASCII /FPBFRE:/
	.ASCII /FUPTFR:/
	.ASCII /FNBFRE:/
	.EVEN

.SBTTL MODE ROUTINES.MITEMS/MTYPES

;FOR EACH ITEM,PRINT: ITEM NO.,TYPE,LENGTH,REF CNT.
;FIRST,FOLLOW THE FREE LIST,MARKING (IN DATTAB) THE FREE ITMTAB
;ENTRIES. THEN,EXTRACT INFO FROM REMAINING ITMTAB ENTRIES.

MTYPES:	MOVB #'T*2,CMDPDG		;NOTE PENDING CMND MODE
	CLR ITMFLG
	BR MTE
MITEMS:	MOVB #'I*2,CMDPDG
	MOV #-1,ITMFLG
MTE:	CLEAR #255.*2
	CLEAR #<<ITMMAX/2>+<ITMMAX&1>+1>,#ITMTYP

	MOV A,C			;PTR TO ITMTAB
	SUB #2,C		;PTR TO ITMFRE
MITNX1:	MOV (C),C		;SITS PTR TO NEXT FREE ITEM
	BEQ MITEGO		;END OF LIST?
	ADD ITMCF,C		;PTR TO NEXT FREE ITEM
	MOV C,D
	SUB A,D			;ITMTAB/DATTAB INDEX OF FREE ITM
	DEC DATTAB-4(D)		;-1
	BR MITNX1

MITEGO:	SAVE B
	MOV #4,D		;ITMTAB OFFSET,SKIPPING 0
	MOV #DATTAB,F		;POINTER TO DATA GOING IN
	MOV NITEMS,C		;ITEM COUNTER
	CLR ITMCNT
MITNX2:	TST DATTAB-4(D)		;FREE ENTRY?
	BPL 3$
	ADD #4,F		;IF SO,PASS BY
	BR MITSKP
3$::	INC ITMCNT		;IF NOT,WE'VE GOT ANOTHER ONE
	MOV #ITEMPG,E		;PAGE NO TO MAP INTO
	JSR PC,ITEMAP		;MAP IN THIS ENTRY'S ITEM

	MOVB (E),B
	CMPB B,#ITMMAX		;VALID TYPE #?
	BLOS 1$
	INCB XTYPE		;NOPE
	TST ITMFLG		;ITEM MODE DETAIL WANTED?
	BEQ MITSKP		;IF NOT,SKIP
	MOVB #ITMMAX+1,(F)+	;RECORD STANDRDZD INVLID ITEM TYPE
	BR 2$
1$::	INCB ITMTYP(B)
	TST ITMFLG		;DETAILS?
	BEQ MITSKP
	MOVB B,(F)+		;RECORD ITEM TYPE
2$::	ADD A,D			;POINT D TO ITMTAB ENTRY
	MOVB 3(D),(F)		;RECORD ITEM LENGTH
	SUB A,D			;BACK TO NORMAL
	INCB (F)+		;0=1
	MOV 2(E),(F)+		;RECORD ITEM REF COUNT

MITSKP:	ADD #4,D		;NEXT ITMTAB INDEX
	SOB C,MITNX2
	REST B			;FALL THRU TO NXT PG

.SBTTL MODE ROUTINES.MITEMS/MTYPES.OUTPUT

	TOPPAG
	PRINIT MITPL1,ITH,#ITMMAX+2	;SETUP FOR OUTPUT LOOP
	OBYT 1,ITMTYP-1(E)	;PRINT # OF ITEMS OF THIS TYPE
	DEC E			;ADJUST
	ITM 1,E			;TRANSLATE
	INC E			;ADJUST BACK
	PREND MITPL1		;CLEAN UP

	TST ITMFLG		;PRINT ITEM TABULATION?
	BNE .+4
	RTS PC
		;FOR EACH TYPE,GO THRU TABLE & PRINT ITEMS
	MOV #ITMMAX+2,D		;COUNTER,CURRENT TYPE#+1
	OUTPUT #ITEHD		;PRINT HEADER LINE
MITX:	PRINIT MITPL2,,NITEMS	;SETUP FOR OUTPUT LOOP
	DEC D			;ADJUST
	CMPB D,(F)		;CURRENT TYPE?
	BNE MITSK2		;IF NOT,IGNORE FOR NOW
	INC D			;READJUST
	ITM 1			;PRINT ITEM TYPE
	MOV F,C
	SUB #DATTAB-3,C
	OWD 1,C			;AND ITEM NUMBER
	OBYT 1			;AND ITEM LENGTH
	OWD 1			;AND REF COUNT
	BR MITCTN
MITSK2:	INC D			;READJUST
	ADD #4,F		;NEXT ENTRY(IF THIS ONE SKIPPED)
	BR MITSK3		;NO WRITE,JUST SOB IN THE PREND
MITCTN:	PREND MITPL2,MITSK3
;	SOB D,MITX
	DEC D
	BEQ .+6
	JMP MITX
	RTS PC
ITMMAX=	11.
ITEHD:	HEADER <TYPE,ITEM#,LENGTH,REF CNT>
ITH:	HEADER < #,TYPE>
	.EVEN
ITMCNT:	.WORD 0
ITMTYP:	.BLKB ITMMAX+1
XTYPE:	.BYTE 0
	.EVEN
ITMFLG:	.WORD 0
.SBTTL MODE ROUTINES.MITEMS/MTYPES.ASCII

;CONVERT ITEM # IN "A" TO 6-CHAR ASCII STRING IN BUFFER POINTED TO BY
;B. B GETS UPDATED TO POINT TO BYTE AFTER LAST CHAR.
CNVITM:	SAVE <A,C>
	CMPB A,#ITMMAX		;TOO BIG FOR ITEM TYPE?
	BLOS 1$
	MOV #ITMXX,A		;ITMDIS OFFSET FOR ERROR STRING
	BR 4$
1$:	TST A
	BPL 3$
	MOV #ITMXX,A
	BR 4$
3$:	ASH #3,A		;ITMDIS OFFSET FOR ITEM TYPE STRING
	ADD #ITYPTB,A
4$:	MOV #6,C		;COUNTER
2$:	MOVB (A)+,(B)+		;MOVE CHAR TO BUFFER
	SOB C,2$		;ETC
	REST <C,A>
	RTS PC

ITYPTB:	.ASCIZ /FUNNY /
	.BYTE 0
	.ASCIZ /ITPROC/
	.BYTE 0
	.ASCIZ /ITUSER/
	.BYTE 0
	.ASCIZ /ITSPHR/
	.BYTE 0
	.ASCIZ /ITTTY /
	.BYTE 0
	.ASCIZ /ITQUE /
	.BYTE 0
	.ASCIZ /ITMF  /
	.BYTE 0
	.ASCIZ /ITCL  /
	.BYTE 0
	.ASCIZ /ITFNT /
	.BYTE 0
	.ASCIZ /ITPTR /
	.BYTE 0
	.ASCIZ /ITPTP /
	.BYTE 0
	.ASCIZ /ITLPT /
ITMXX:	.ASCIZ /XXXXXX/
	.EVEN

.SBTTL MODE ROUTINES.MINFO

MINFO:	MOVB CMDPDG,COMND	;RESTORE PREVIOUS PENDING MODE
	TYPE #TTYCAP,#MINFM
	RTS PC

MINFM:	.BYTE 15
.ASCII /	THESE ARE THE CURRENT SPEEK COMMANDS:/
	.BYTE 15
.ASCII /D	DEVICE MODE. PRINT DEVICES IN USE WITH ASSOCIATED/
	.BYTE 15
.ASCII /USER NAMES./
	.BYTE 15,12
.ASCII /F	FREE MODE. PRINT THE NUMBER OF FREE NODES FOR/
	.BYTE 15
.ASCII /EACH OF SEVERAL SITS LISTS./
	.BYTE 15,12
.ASCII /I	ITEMS MODE. PRINT TYPE,ITEM #,LENGTH, AND REF COUNT/
	.BYTE 15
.ASCII /OF EACH ITEM./
	.BYTE 15,12
.ASCII /L	LINEPRINT MODE. ALTERNATELY SWITCHES SUBSEQUENT/
	.BYTE 15
.ASCII /OUTPUT TO LINEPRINTER,BACK TO TTY CONSOLE./
	.BYTE 15,12
.ASCII /N	NORMAL MODE. SAME AS SPHRES MODE/
	.BYTE 15,12
.ASCII /Q	QUIT. RETURN TO SUPERIOR SPHERE./
	.BYTE 15,12
.ASCII /T	TYPES MODE. PRINT THE NUMBER OF EXISTING ITEMS/
	.BYTE 15
.ASCII /OF EACH ITEM TYPE./
	.BYTE 15,12
.ASCII /U	USERS MODE. FOR EACH USER,PRINT NAME AND OTHER/
	.BYTE 15
.ASCII /INFORMATION./
	.BYTE 15,12
.ASCII /S	SPHERES MODE. PRINT TREE STRUCTURE OF EXISTING/
	.BYTE 15
.ASCII /SPHERES/
	.BYTE 15,12
.ASCII /X	ALTERNATELY SUPRESS,REINSTATE AUTOMATIC UPDATE./
	.BYTE 15,12
.ASCII /<CR>	REPEAT PREVIOUS MODE COMMAND./
	.BYTE 15,12
.ASCII /?	PRINT LIST OF CURRENT COMMANDS./
	.BYTE 15,12,0
	.EVEN
.SBTTL ASCII ROUTINES

;CONVERT THE (UNSIGNED) WORD IN "A" TO A 6-PLACE OCTAL STRING IN
;BUFER POINTED TO BY B. RETURNS WITH B POINTING TO BYTE AFTER LAST BYTE
;OF THE STRING. OTHER REGISTERS UNCHANGED.
CNVOWD:	SAVE <C,E,F>
	CLR E
	MOV A,F
	ASHC #1,E		;GET TOP BIT IN E
	ADD #60,E		;=> ASCII
	MOVB E,(B)+		;PUT CHAR IN BUFFER
				;SIGNED CONVERSION RTN ENTERS HERE
CNVS:	MOV #5,C		;LOOP COUNTER--5 OCT DIGITS TO GO
CNVLP:	CLR E			;BYTE CONVERSION RTN ENTERS HERE
	ASHC #3,E		;GET NEXT OCTAL DIGIT
	ADD #60,E		;=> ASCII
	MOVB E,(B)+		;CHAR IN BUF
	SOB C,CNVLP
	REST <F,E,C>		;ETC
	RTS PC

CNVOWS:	SAVE <C,E,F>
	TST A			;LIKE CNVOWD BUT TREATS (A) AS
	BMI 1$			;SIGNED.MAKES SIGN CHAR,5 OCT CHARS
	MOVB #40,(B)+	;BLANK SIGN CHAR
	BR CNVS			;BOTTOM HALF OF CNVOWD DOES THE REST
1$:	NEG A
	MOVB #'-,(B)+	;MINUS SIGN
	BR CNVS		;ETC

CNVOBT:	SAVE <C,E,F>		;LIKE CNVOWD BUT FOR A BYTE. MAKES
	MOV A,F
	ASHC #12,E		;TOP 2 BITS
	BIC #177774,E		;ALONE
	ADD #60,E
	MOVB E,(B)+	;CHAR IN BUF
	MOV #2,C		;TWICE MORE
	BR CNVLP

PATCH:	.BLKW 100
PAT:	.BLKW 100
END:
.END SPEEK
