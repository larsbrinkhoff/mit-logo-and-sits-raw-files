				;CREATE CAPABILITY. CURRENTLY CAN ONLY CREATE ROOT FA CAPS
CCFACP:	JSR PC,GETCPS		;GET A CAP SLOT TO PUT IT INTO
	MOV @2(E),C		;GET DISK NUMBER
	BIC #177400,C
	TST LSDMNT(C)		;IS DISK ALREADY MOUNTED?
	LSERRC NE,BAD	
	JSR PC,GETITM		;GET A MFI, RETURN INDEX IN D
	MOV D,B			;COPY POINTER
	JSR PC,LSFCIN		;INC REF COUNT, CLEAR CAP
	MOV #46,LSCRN1(F)	;BLOCK 46 IS THE ROOT
	MOV #46,MFBLKN(D)	;NEED THAT HERE TOO
	CLR MFFLNO(D)		;THE SELF ENTRY IS THE ZEROTH
	MOV PC,MFDIRF(D)	;THIS IS DEFINITELY A DIR
	MOV C,MFDKNO(D)		;SET IN DISK NUMBER
	MOV PC,LSDMNT(C)	;MOUNTED NOW
	MOV #1,MFDKRF(C)	;EXACTLY ONE REFERENCE
.IIF Z RXDISK,	MOV #-1,LSDEN(C)	;SET DENSITY TO UNKNOWN
.IIF NZ RXDISK,	MOV #0,LSDEN(C)		;RX DISK IS ALWAYS SINGLE DENSITY
	ASR C			;WAS MULTIPLE OF 2
	BISB LSBMT(C),LSDKLT	;SET INTO LIGHT REGISTER
.IIF NZ SMSDSK,	MOV LSDKLT,SMSLGT	;TURN ON LIGHT
	JSR PC,DSKBGT		;READ IN THE ROOT DIR
	TST TRNERR		;ERROR?
	BNE 1$
	JSR PC,ENTMFC		;COPY ENTRY INTO MFI
	JSR PC,ENTFRS		;SET FREE BYTE COUNT
	MOV #.FACAP,LSCPTB(F)	;NOW IT'S OFFICIAL
	ADD #4,E		;FLUSH EXTRA ARGS
	RTS PC			;AND RETURN
1$:	JSR PC,FADEL1		;DELETE THE CAP
	LSERR DSKE		;DISK ERROR

				;UNMOUNT A MOUNTED DISK
DKUNMT:	JSR PC,LSFLSB		;MAKE DOUBLE SURE
	MOV #-1,BLOKNO		;MAKE SURE NO ONE EVER BELIEVES THE BUFFER AGAIN
	TST MFBITP(A)		;DID IT HAVE A BIT TABLE ASSSINGED?
	BEQ 1$
	JSR PC,WRTBIT
	MOV LSBTBS,@MFBITP(A)	;GOING TO FREE
	MOV MFBITP(A),LSBTBS	;THE BIT TABLE
1$:	CLR LSDMNT(A)
	ASR A
	BICB LSBMT(A),LSDKLT
.IIF NZ SMSDSK,	MOV LSDKLT,SMSLGT
	RTS PC



				;COPY ENTRY POINTED TO BY B INTO MFI POINTED TO BY D
ENTMFC:	SAVE <A,D,B>
	TST (B)			;DOES IT HAVE EOF WORDS?
	BGE 2$			;NOPE
	MOV 4(B),A		;HIGH ORDER PART
	MOV 6(B),B		;LOW ORDER
	ASH #3,B		;MOVE UP
	ASHC #-3,A		;AND BACK
	BIC #160000,A
	MOV A,MFEOFH(D)
	MOV B,MFEOFL(D)	
	MOV (P),B
2$:	MOV (B),A
	INC A
	BIC #177401,A
	ASR A
	ADD #MFENTY,D
1$:	MOV (B)+,(D)+
	SOB A,1$
	REST <B,D,A>
	RTS PC
				;GET THE REAL BLOCK NUMBER FOR THE CURRENT ACCESS POINTER
				;CALL WITH THE CAP POINTER IN F 
LSGETB:	SAVE A
	MOV LSCRN2(F),A		;HIGH BITS
	MOV LSCRN3(F),B		;LOW BITS
	ASHC #-10.,A		;NOW B HAS BLOCK # IN FILE
	MOV LSCIPN(F),A		;ITEM POINTER
	JSR PC,GTBLK
	REST A
	RTS PC

				;GET BLOCK NUMBER FOR FILE BLOCK NUMBER IN B, ITEM POINTER IN A
GTBLK:	JSR F,LSACSV
	ADD #MFENTY,A		;POINTER TO ENTYR IN ITEM
	MOV (A),C		;HEADER WORD
	BIC #177400,C		;CLEAR CRAP
	ADD A,C			;POINT TO END OF ENTRY
	MOV C,ENTRYE		;SAVE THAT
	MOV (A),C		;HEADER AGAIN
	ADD #4,A		;POINT PAST HEADER AND VERSION #
	BIT #MFEOFB,C		;DOES IT HAVE EOF?
	BEQ 1$			;NOPE
	ADD #10,A		;SKIP EOF, TIME+DATE
1$:	BIT #MFACCB,C		;ACCESS CODES?
	BEQ 3$			;NOPE
2$:	ADD #2,A
	TSTB (A)+
	BLT 2$
3$:	TSTB (A)+
	BGE 3$
	MOV #-1,E		;E IS THE CURRENT REAL BLOCK #
	MOV #ADDSKP,ENTLST	;IF NO VALID BYTES, SKP IS THE TYPE
GETLOP:	MOV E,ENTLSB
	INC E			;EVERY NEW BYTE ADDS ONE TO E
	CMP A,ENTRYE		;AT THE END?
	BLO 1$			;NOPE
	MOV #-1,E		;JUST RETURN -1
	BR GTGOT
1$:	MOV A,ENTLSP
	MOVB (A)+,C		;NEXT BYTE 
	MOV C,D			;COPY
	BIC #177700,D		;GET DATA PART
	BIC #177477,C		;GET CODE PART
	ASH #-5,C		;CONVERT CODE TO DISPATCH
	JMP @2$(C)		;DISPATCH
2$:	GTSKIP
	GTGET
	GTSET
	GTSKG

GTSKIP:	MOV #ADDSKP,ENTLST
	ADD D,E			;SKIP N AND GRAB ONE
	CLR F			;GRAB ONE
	BR GTGRBN

GTGET:	MOV #ADDGET,ENTLST
	MOV D,F			;GET N
GTGRBN:	DEC B			;GOT ENOUGH?
	BLT GTGOT		;YUP
	DEC F			;ANY MORE TO GET?
	BLT GETLOP		;NOPE
	INC E			;GET NEXT ONE THEN
	BR GTGRBN

GTSET:	MOV #ADDSET,ENTLST
	MOV D,F			;SET ADDRESS AND GET N
	MOVB (A)+,E		;LOW BYTE
	SWAB E			;SAVE IN HIGH BYTE
	BIC #377,E		;FLUSH CRAP
	BISB (A)+,E		;GET HIGH BYTE
	SWAB E			;MAKE THINGS LIKE GOD INTENDED THEM TO BE
	BR GTGRBN		;AND DO A REGULAR GRAB

GTSKG:	MOV #ADDSKG,ENTLST
	MOV D,F			;SKIP AND GRAB, COPY DATA
	ASH #-3,D		;GET SKIP PART
	ADD D,E			;SKIP
	BIC #70,F		;GET GRAB PART
	BR GTGRBN		;AND DO REGULAR GRAB

GTGOT:	MOV E,2(P)		;THE GOODIE TO RETURN
	JSR F,LSACRT
	RTS PC



				;ADD BLOCK NUMBER IN B TO ENTRY OF ITEM IN D
				;ENTLSB,T,P HAVE BEEN SET UP BY LSGETB RUNNING TO END OF DESC
ADDBLK:	JSR F,LSACSV
	CMP #3,MFRSFR(D)	;HAVE WE GOT ENOUGH RESERVED?
	BLE 2$
	MOV #6,C		;RESERVE PLENTY
	JSR PC,DIRCMT
	LSERRC EQ,DRF
2$:	MOV PC,MFMODF(D)	;WE WILL MODIFY ENTRY
	MOV ENTRYE,F		;PLACE TO PLACE NEW BYTE(S)
	MOV ENTLSB,E		;LAST ALLOCATED BLOCK
	INC E			;NORMAL NEXT BLOCK
	SUB B,E			;DIFFERENCE
	NEG E
	BNE ADDNEW		;NOT ZERO=>SPECIAL BYTE
	JMP @ENTLST		;MAYBE CAN ADD TO LAST BYTE

ADDNEW:	JSR PC,ADDBYT		;INC ENTRY AND DEC RESERVED
	CMP #7,E		;SKIP-GET POSSIBLE?
	BHIS ADDNSG		;ADD ONE
	CMP #77,E		;SKIP?
	BHIS ADDNSK		;ADD IT
	MOVB #200,(F)+		;ADD SET ADDRESS
	MOVB B,(F)+
	SWAB B
	MOVB B,(F)+
	JSR PC,ADD2BY		;ADD TWO BYTES
ADDRET:	JSR F,LSACRT
	RTS PC

ADDNSG:	ASH #3,E		;MOVE SKIP FIELD
	BIS #300,E
ADDNSK:	MOVB E,(F)+
	BR ADDRET

ADDSET:	MOV #77,C		;THESE TWO ACT THE SAME (ALMOST)
	BR ADDGT1
ADDGET:	MOV #37,C
ADDGT1:	MOVB @ENTLSP,A		;GET OLD GET COUNT BYTE
	INC A			;ADD ANOTHER TO IT
	BIT C,A			;DID IT OVERFLOW?
	BEQ ADDNGT		;YES, MUST ADD A GET
ADDOLD:	MOVB A,@ENTLSP		;PUT BYTE BACK
	BR ADDRET

ADDSKP:
ADDNGT:	JSR PC,ADDBYT
	MOVB #100,(F)+
	BR ADDRET

ADDSKG:	MOVB @ENTLSP,A
	INC A			;TRY ADDING A BLOCK
	BIT #7,A		;OVERFLOW?
	BEQ ADDNGT		;YUP, ADD A GET
	BR ADDOLD		;NOPE, PUT IT BACK

ADD2BY:	JSR PC,(PC)
ADDBYT:	INC MFENTY(D)		;ONE MORE BYTE INTHE ENTRY
	DEC MFRSFR(D)		;ONE LESS RESERVED
	RTS PC

				;FIND A FREE BLOCK ON THE DISK
FNDBLK:	JSR F,LSACSV
	MOV MFDKNO(D),A
	TST MFFREE(A)		;ANY FREE
	LSERRC EQ,DFL
	DEC MFFREE(A)
	MOV PC,MFBITM(A)	;MODIFIED BIT TABLE
	MOV MFBITP(A),B		;GET POINTER TO BIT TABLE
	TST (B)+		;PASS THE COUNT
	MOV B,C			;COPY
1$:	CMPB #377,(C)+		;ANY FREE HERE?
	BEQ 1$
	DEC C
	CLR E
2$:	BITB LSBMT(E),(C)	;FREE?
	BEQ 3$
	INC E
	BR 2$
3$:	BISB LSBMT(E),(C)
	SUB B,C			;RELATIVE
	ASH #3,C		;EACH BYTE=8 BLOCKS
	ADD E,C
	MOV C,2(P)		;RETURN IN B
	MOV A,D			;SAVE DISK INDEX
	MOV MFBITP(A),A		;GET POINTER TO BIT TABLE
	JSR PC,BITCNT		;COUNT UP THE BITS
	CMP A,MFFREE(D)		;IS THIS RIGHT?
	BEQ 4$
	HALT			;NOPE, SOMEBODY CLOBBERED THE BIT TABLE
4$:	JSR F,LSACRT
	RTS PC



				;FILE BYTE INPUT
LSFBYI:	MOV #1,A		;NUMBER OF BYTES WE WANT
	JSR PC,LSGTBY		;GO GET BYTES
	LSERRC EQ,RPEF,SV	;READ PAST EOF
	MOVB (B),(E)
	CLRB 1(E)
	RTS PC


				;FILE WORD INPUT
LSFWDI:	MOV #1,A
	JSR PC,LSGTBY		;GO GET 1 BYTE
	LSERRC EQ,RPEF,SV
	MOVB (B),(E)
	MOV #1,A
	JSR PC,LSGTBY		;GO GET 1 BYTE
	LSERRC EQ,RPEF,SV
	MOVB (B),1(E)
	RTS PC

				;FILE BLOCK INPUT
LSFBLI:	MOV 2(E),A
	BEQ 1$
	NEG A
	JSR PC,LSGTBY
	LSERRC EQ,RPEF,SV
	ADD A,2(E)
	MOV 4(E),C		;POINTER TO USERS DATA AREA
	ADD A,4(E)		;UPDATE THAT TOO
2$:	MOVB (B)+,(C)+
	SOB A,2$
	BR LSFBLI		;TRY AGAIN
1$:	ADD #6,E
	RTS PC




				;GET BYTES FOR INPUT. CALL WITH NUMBER OF BYTES DESIRED IN A
				;CAP IN F
				;THIS ROUTINE CLOBBERS D TO BE THE ITEM
				;RETURN WITH NUMBER OF BYTES GOTTEN IN A, POINTER TO THEM IN B
LSGTBY:	SAVE A			;SAVE NUMBER OF BYTES HE WANTS
	MOV LSCIPN(F),D		;GET ITEM POINTER
	CMP LSCRN2(F),MFEOFH(D)	;CHECK HIGH WORDS
	LSERRC HI,APEF		;ACCESS PAST END OF FILE
	BLO 8$			;NOT EVEN IN LAST 65K BYTES
	MOV MFEOFL(D),A		;GET THE EOF WORD
	SUB LSCRN3(F),A		;GET NUMBER OF BYTES LEFT ON THIS PAGE
	LSERRC LO,APEF		;ACCESS PAST END OF FILE
	BEQ 9$			;AT END OF FILE
	CMP #2000,A		;MORE THAN A BLOCK?
	BHI 9$			;NOPE, CAN USE WHOLE THING
8$:	MOV #2000,A		;AT LEAST ONE BLOCK BEFORE EOF
9$:	SAVE A			;THSI IS HOW MUCH BEFORE EOF
	MOV LSCRN3(F),A		;NOW WE WNAT HOW MUCH IS LEFT ON BLOCK
	BIC #176000,A
	BNE 2$			;WE ARE NOT ON BLOCK BOUNDARY
	MOV #-1,LSCRN1(F)	;CLOBBER CURRENT BLOCK IF THERE IS ONE
2$:	SUB #2000,A		;COMPUTE HOW MUCH
	NEG A			;IS LEFT IN THIS BLOCK
				;NOW WE WANT TO RETURN MIN(A,(P),2(P))
	CMP A,(P)
	BLT 3$			;A IS LESS
	MOV (P),A
3$:	CMP A,2(P)
	BLT 4$
	MOV 2(P),A
4$:	CMP (P)+,(P)+		;FLUSH EXTRA STUFF
	TST A
	BEQ LSGTB1		;NO BYTES, DON'T TRY TO GET BLOCK
LSGTBL:	JSR PC,DSKBGC		;GET A POINTER IN B TO THE RIGHT BLOCK
	SAVE B
	MOV LSCRN3(F),B
	BIC #176000,B
	ADD (P)+,B
	ADD A,LSCRN3(F)		;ADD NUMBER OF BYTES GOTTEN TO ACCESS POINTER
	ADC LSCRN2(F)		;OVERFLOW TO HIGH WORD
	TST A
LSGTB1:	RTS PC

				;GET ROOM FOR OUTPUT BYTES
				;CALL WITH NUMBER OF BYTES DESIRED IN A, CAP IN F
				;D GETS CLOBBERED TO BE ITEM POINTER, B POINTS TO WHERE TO
				;PUT THE BYTES AND A RETURNS NUMBER OF BYTES ACTUALLY GOTTEN
LSGTBO:	SAVE A			;SAVE NUMBER DESIRED
	JSR PC,LSGTBY		;FIRST SEE IF THERE ARE ANY BEFORE THE EOF	
	BNE LSGTO1		;YUP, USE THEM UP FIRST
				;SINCE WE GOT HERE WE ARE AT THE EOF
	MOV PC,MFMODF(D)	;SO WE WILL BE CHANGING THE EOF
	MOV LSCRN3(F),A		;GET EOF POINTER
	BIC #176000,A		;CLEAR EXTRA BITS
	BEQ LSGTO2		;WE ARE AT BEGGINING OR PAST END OF LAST BLOCK
	SUB #2000,A		;NEGATIVE OF AMOUNT LEFT ON THIS BLOCK
	NEG A			;REAL AMOUNT
LSGTO3:	CMP A,(P)		;IS AMOUNT AVAILABLE MORE THAN WE WANT?
	BLT 1$			;NO, LESS
	MOV (P),A		;GIVE HIM ONLY WHAT HE WANTS
1$:	ADD A,MFEOFL(D)		;WE ARE PUSHING THE EOF BY THIS MUCH
	ADC MFEOFH(D)
	BIT #1777,MFEOFL(D)	;AT THE END OF THE BLOCK
	BNE 2$
	BIC #MFLSTB,MFENTY(D)	;THEN LAST BLOCK NO LONGER EXISTS
2$:	JSR PC,LSGTBL		;GET THE BLOCK WE ARE ON
LSGTO1:	MOV PC,BLOKMD
	TST (P)+
	TST A
	RTS PC

LSGTO2:	BIT #MFLSTB,MFENTY(D)	;IS THE LAST BLOCK ALREADY THERE?
	BEQ 1$			;NOPE
3$:	MOV #2000,A		;YUP, HAVE A WHOLE BLOCK
	BR LSGTO3
1$:	JSR PC,LSGETB		;PROCESS TO LAST BLOCK IN FILE
	CMP #-1,B		;BETTER NOT EXIST
	BEQ 2$
	BPT
2$:	JSR PC,FNDBLK		;FIND A FREE BLOCK
	JSR PC,ADDBLK		;ADD IT TO DESC
	BIS #MFLSTB,MFENTY(D)
	BR 3$












				;FILE BYTE OUTPUT
LSFBYO:	TST (E)+		;FLUSH CAP
	MOV #1,A		;NUMBER OF BYTES WE WANT
	JSR PC,LSGTBO		;GO GET BYTES
	MOVB (E),(B)
	TST (E)+
	RTS PC


				;FILE WORD OUPUT
LSFWDO:	TST (E)+		;FLUSH CAP
	MOV #1,A
	JSR PC,LSGTBO		;GO GET 1 BYTE
	MOVB (E),(B)
	MOV #1,A
	JSR PC,LSGTBO		;GO GET 1 BYTE
	MOVB 1(E),(B)
	TST (E)+
	RTS PC

				;FILE BLOCK OUTPUT
LSFBLO:	MOV 2(E),A
	BEQ 1$
	NEG A
	JSR PC,LSGTBO
	ADD A,2(E)
	MOV 4(E),C		;POINTER TO USERS DATA AREA
	ADD A,4(E)		;UPDATE THAT TOO
2$:	MOVB (C)+,(B)+
	SOB A,2$
	BR LSFBLO		;TRY AGAIN
1$:	ADD #6,E
	RTS PC

				;RETURN A BLOCK OF DATA ABOUT THE FILE THIS IS A CAPABILITY TO
				;C= POINTS TO DESTINATION OF DATA
				;D= NEGATIVE OF THE MAXIMUM NUMBER OF BYTES TO GIVE USER

LSFARI:	MOV C,F			;PUT CAP POINTER INTO USUAL PLACE
	MOV 2(E),D		;BYTE COUNT
	MOV 4(E),C		;USER'S POINTER
	TST D			;IS IT NEGATIVE
	BPL 1$
	NEG D			;MAKE IT POSITIVE
1$:	BNE MFARI9
	MOV #400,D		;GIVE HIM ALL THERE IS
MFARI9:	SUB #5,D		;MINIMUM
	ASL D
	LSERRC LE,BAD
	MOV LSCPTB(F),(C)	;CAP. FLAGS
				;GIVE USER FLAGS
	MOV LSCIPN(F),A		;ITEM POINTER
	CLR B
	TST MFDIRF(A)
	BEQ 2$			;FILE
	MOV #.FADIR,B		;DIR
2$:	BIS B,(C)+
	MOV B,(C)+
	MOV MFEOFL(A),B
	MOV MFEOFH(A),A
	ASHC #-10.,A
	MOV LSCIPN(F),A
	INC B
	BIT #MFLSTB,MFENTY(A)
	BNE 1$
	DEC B
1$:	MOV B,(C)+
	MOV 10(A),(C)+		;DATE
	MOV 12(A),(C)+
	MOV LSCIPN(F),A
	ADD #MFENTY,A
	JSR PC,MFNDNM		;MAKE A POINT TO NAME
MFARI1:	MOVB (A)+,(C)+
	BLT 9$
	SOB D,MFARI1
	BR MFARI6		;NO MORE ROOM, EXIT
9$:	BICB #200,-1(C)

	MOV LSCIPN(F),A		;POINTER TO MFI
	ADD #MFENTY,A
	MOV 2(A),B		;VERSION NUMBER
	BLT 6$			;NONE, DONE
	MOVB #'#,(C)+
	DEC D
	BLE MFARI6
	SAVE #-1
7$:	CLR A
	DIV #10.,A
	SAVE B
	MOV A,B
	BNE 7$
5$:	REST B
	BLT 6$
	ADD #60,B
	MOVB B,(C)+
	SOB D,5$
4$:	TST (P)+
	BGE 4$
	BR MFARI6
6$:	CLRB (C)+
MFARIX:	ADD #6,E
	RTS PC

MFARI6:	BIS #1,LSPS		;SET CARRY BIT
	BR MFARIX

MFNDNM:	SAVE B		;(A)= POINTER TO ENTRY
	MOV (A)+,B		;HEADER WORD
	TST (A)+		;SKIP VERSION NUMBER
	BIT #MFEOFB,B		;TIEM DATE, EOF ETC?
	BEQ 1$			;NOPE
	ADD #10,A		;SKIP EOF DATE AND TIME
1$:	BIT #MFACCB,B		;ACCESS CODES?
	BEQ MFND.2
MFND.1:	ADD #2,A		;SKIP ACCESS CODES
	TSTB (A)+
	BLT MFND.1		;MORE ACCESS CODES?
MFND.2:	REST B
	RTS PC			;DONE

LSFASP:	MOV 2(E),LSCRN2(C)
	MOV 4(E),LSCRN3(C)
	MOV #-1,LSCRN1(C)
	ADD #6,E
	RTS PC


LSFARP:	ADD #6,E
	MOV LSCRN3(C),-(E)
	MOV LSCRN2(C),-(E)
	RTS PC

LSFARE:	ADD #6,E
	MOV LSCIPN(C),A
	MOV MFEOFL(A),-(E)
	MOV MFEOFH(A),-(E)
	RTS PC


				;RETURN INFO ABOUT THE DISK A FILE IS ON
LSFADI:	ADD #6,E
	MOV LSCIPN(C),A
	MOV MFDKNO(A),B
	ASR B
	MOV B,-(E)		
	ASL B
	MOV MFFREE(B),-(E)
	RTS PC


				;SEARCH THE DIRECTORY FOR THE FILE POINTED
				;TO BY THE FIXED "FILE NAME BLOCK"
				;F POINTS TO THE CAP TO THE DIR TO SEARCH
				;RETURN IN B A POINTER TO THE "EXACT" MATCH IF ONE WAS FOUND.
				;IF THE FNB HAS NO VERSION NUMBER OR A SPECIFIC VERSION NUMBER,
				;THEN THE DIRECTORY ENTRY MUST HAVE THE SAME FOR AN EXACT MATCH
				;IF THE FNB HAS < FOR A VERSION NUMBER, THE FIRST FILE
				;WITH A VERSION NUMBER IS AN EXACT MATCH. IF THE FNB HAS
				;> AS A VERSION NUMBER, THEN THE LAST FILE WITH THE RIGHT
				;NAME AND A VERSION NUMBER IS AN EXACT MATCH. NOTE THAT
				;> AND < NEVER EXACT MATCH TO A FILE WITH NO VERSION NUMBER,
				;AND A FILE WITH NO VERSION NUMBER NEVER EXACT MATCHES A FILE
				;WITH ONE
				;THE VERSION NUMBER OF THE EXACT MATCH IS RETURNED IN C
				;AND Z IS SET IF NO EXACT MATHC IS FOUND
				;CRETURNS WITH POINTER TO ENTRY IN B, IF FOUND
DIRSER:	JSR F,LSACSV
	CLR 2(P)		;RETURNED B
	MOV #1,FNBFNO		;FIRST FILE (WE SKIP THE SELF ENTRY)
	MOV 12(P),F		;RECOVER F
	MOV LSCIPN(F),A		;GET ITEM POINTER
	TST MFDIRF(A)		;IS IT A DIR?	
	LSERRC EQ,BAD
	JSR PC,CLRCAP
	JSR PC,DSKBGC		;GET POINTER TO THE DIR
	MOV B,A
	MOV 6(A),E		;EOF POINTER
	ADD A,E			;REAL END POINTER NOW
	MOV (A),B		;FIRST WORD OF SELF ENTRY
	INC B			;ROUND OFF BYTE COUNT
	BIC #177401,B		;BYTE COUNT
	ADD B,A			;SKIP SELF
				;AND THEN SKIP THE PARENT ENTRY TOO
DIRSE1:	INC FNBFNO		;NEXT FILE
	MOV (A),B		;GET FIRST WORD OF ENTRY
	INC B			;ROUND OFF BYTE COUNT
	BIC #177401,B		;GET BYTE COUNT
	ADD B,A			;GO TO NEXT ENTRY
	MOV A,(P)		;SAVE FOR CALLER
	CMP A,E			;ARE WE AT OR PAST THE END?
	BHIS DIRSE2		;YUP, RETURN TO CALLER
	JSR PC,NAMCMP		;COMPARE THE FILE NAMES
	BGT DIRSE1		;HAVEN'T GONE FAR ENOUGH YET
	BLT DIRSE2		;WE'VE GONE TOO FAR
	MOV FNBVER,D		;MATCHED FILE NAMES, GET VERSION FROM FNB
	INC D			;WAS IT NO VERSION?
	BGE DIRSE4		;YES, OR POSITIVE VERSION
	CMP #-1,C		;NO VERSION ON THE DIR ENTRY?
	BEQ DIRSE1		;THEN IT CAN'T MATCH < OR >
	MOV A,2(P)		;THIS A REAL MATCH FOR <, AND A POSSIBLE FOR >
	MOV C,4(P)		;SO SAVE IT
	INC D			;WAS IT >?
	BEQ DIRSE1		;SEE IF WE CAN FIND A BIGGER ONE
DIRSE2:	CMP #-2,FNBVER		;IS IT >?
	BNE 1$			;NOPE
	DEC FNBFNO		;CORRECT FILE NUMBER
1$:	JSR F,LSACRT		;RESTORE THE CLOBBERED RESGISTERS
	TST B			;SET Z IF NO EXACT MATCH
	RTS PC
DIRSE4:	DEC D			;COMPENSATE FOR TEST
	CMP D,C			;BOTH HAVE VERSIONS OR NO VERSION
	BGT DIRSE1		;FNB VERSION > FOUND VERSION, KEEP TRYING	
	BLT DIRSE2		;FNB VERSION < FOUND, GIVE UP
	MOV A,2(P)		;EXACT MATCH
	MOV C,4(P)		;PREPARE TO RETURN
	BR DIRSE2
				;COMPARE THE NAME IN A FNB WITH THE NAME IN A DIRECTORY AN DECIDE
				;IF THEY ARE GREATER, EQUAL OR LESS
				;POINTER TO FNB IS IN E, POINTER TO DIR IS IN A
NAMCMP:	SAVE <#0,A,B,E>
	MOV A,B			;COPY DIRECTORY POINTER
	MOV #FNBFN,E		;POINT TO FILE NAME IN FILE NAME BLOCK
	MOV 2(A),C		;GET VERSION NUMBER TO RETURN TO CALLER
	ADD #4,A		;POINT TO POTENTIAL NAME
	BIT #MFEOFB,(B)		;ARE THERE TIEM DATE ETC?
	BEQ 1$			;NOPE
	ADD #10,A		;SKIP STUFF
1$:	BIT #MFACCB,(B)		;ACCESS CODES?
	BEQ NAMCM2		;NOPE
NAMCM1:	ADD #3,A		;SKIP ONE SET OF CODES
	TSTB -1(A)		;LAST?
	BLT NAMCM1		;KEEP GOING
NAMCM2:	CMPB (A)+,(E)+		;COMPARE CHARACTERS
	BNE NAMCM3		;NOT EQUAL, GO FINISH UP
	TSTB -1(A)		;DID THEY BOTH END?
	BGE NAMCM2		;NOPE
NAMCM4:	REST <E,B,A>
	TST (P)+		;SET CONDITION CODES
	RTS PC
NAMCM3:	MOVB -(A),A		;GET LAST CHAR FROM DIRECTORY
	MOV A,B			;COPY IT
	MOVB -(E),E		;GET LAST FROM FNB
	BIC #177600,A		;FLUSH CRAP
	BIC #177600,E		;LIKEWISE
	DEC 6(P)		;ASSUME FNB IS LESS
	CMP E,A			;WHICH IS GREATER?
	BLT NAMCM4		;ASSUMED RIGHT	
	BGT NAMCM5		;DIRETORY IS LESS
	TST B			;TEST SIGN EXTENDED DIRECTORY CHARACTER
	BGE NAMCM4		;DIRETORY ENDED FIRST, FNB IS BIGGER
NAMCM5:	MOV #1,6(P)		;DIRECTORY ENTRY IS SMALLER THAN FNB
	BR NAMCM4

LSFAMU:	MOV C,F			;PUT CAP INDEX IN ITS PLACE
LSFAM1:	MOV 2(E),D		;POINTER TO THE NAME STRING
	JSR PC,MFFNG		;GO GOBBLE DOWN THE FILE NAME
	BNE 1$
	ADD #6,E
	RTS PC
1$:	JSR PC,DIRSER		;SEARCH FOR FILE
	LSERRC EQ,FNF		;FILE NOT FOUND
	SAVE B			;SAVE POINTER
	MOV LSCIPN(F),A		;POINTER TO DIR MFI
	MOV #MFOPNF,B		;OPEN FILES
2$:	MOV (B),B		;NEXT!
	BEQ 3$
	CMP FNBFNO,MFFLNO(B)	;SAME FILE NUMBER?
	BNE 2$			;NOPE
	CMP A,MFBACK(B)		;SAME DIR?
	BNE 2$			;NOPE
	DEC MFRFCN(A)		;REFERENCE GOING AWAY WITHOUT NEW ONE TAKING ITS PLACE
	BNE 6$
	BPT
6$:	JSR PC,LSFCIN		;INIT THE CAP
	TST (P)+		;FLUSH SAVED B
4$:	MOV D,2(E)
	BR LSFAM1		;NEXT NAME
3$:	REST B
	SAVE D
	JSR PC,GETITM
	MOV MFDKNO(A),MFDKNO(D)
	MOV FNBFNO,MFFLNO(D)	;PUT IN FILE NUMBER
	JSR PC,ENTMFC
	MOV D,B
	MOV MFDKNO(B),D
	INC MFDKRF(D)
	REST D
	MOV LSCIPN(F),MFBACK(B)	;OLD CAP POINTED AT NEW'S PARENT
	JSR PC,LSFCIN		;INIT CAP
	MOV MFENTY(B),A		;GET HEADER WORD
	BIC #170777,A		;CLKEAR ALL BUT TYPE
	CMP #MFDIRE,A		;IS IT A DIR?
	BNE 4$			;NO, WE ARE DONE THEN
	MOV PC,MFDIRF(B)
	SAVE D
	MOV B,D			;SAVED ITEM POINTER
	JSR PC,DSKBGC		;GET THE BLOCK THEN
	JSR PC,ENTMFC		;COPY THE SELF ENTRY
	JSR PC,ENTFRS		;SET FREE BYTES
	MOV BLOKNO,MFBLKN(D)	;SAVE BLOCK NUMBER OF DIR
	REST D
	BR 4$			;DONE!

ENTFRS:	MOV MFEOFL(D),B		;GET EOF POINTER
	SUB #2000,B		;GET NEG OF BYTES LEFT IN DIR
	NEG B
	MOV B,MFRSFR(D)		;SAVE AS NUMBER OF FREE BYTES
	RTS PC

LSFCIN:	INC MFRFCN(B)		;THIS IS A GOODIE
	MOV B,LSCIPN(F)		;POINT CAP AT IT
	JSR PC,CLRCAP
	RTS PC

				;PROCESS USER NAME STRING INTO THE "FILE NAME BLOCK"
MFFNG:	SAVE <A,B,C>
	MOV #-1,B		;VERSION #
2$:	MOVB (D)+,A		;GET A CHAR
	BEQ 1$			;WE ARE AT END
	CMP #40,A		;SPACE?
	BEQ 2$			;IGNORE LEADING SPACE
	MOV #FNBFN,C
3$:	MOVB A,(C)+
	MOVB (D)+,A		;NEXT CHAR
	BEQ MFFNDN		;DONE
	CMP #' ,A
	BEQ MFFNDN		;LIKEWISE
	CMPB #'#,A
	BEQ MFFNGN		;GET A NUMBER
	CMPB #'>,A
	BEQ MFFNGT		;GREATER THAN
	CMPB #'<,A
	BEQ MFFNLT		;LESS THAN
	CMPB #'",A
	BNE 3$			;JUST PUT IT IN
	MOVB (D)+,A		;GET THE QUOTED CHAR
	BR 3$			;PUT IT INTO STRING AND GET NEXT

1$:	REST <C,B,A>
	SEZ
	RTS PC





MFFNDN:	MOV B,FNBVER
	BISB #200,-(C)		;SET END MARKER
MFFND1:	DEC D			;POINT AT TERMINATOR
	REST <C,B,A>
	CLZ
	RTS PC

MFFNGT:	MOV #-2,B		;SET VERSION
	BR MFFNL1

MFFNLT:	MOV #-3,B
MFFNL1:	TSTB (D)+		;SHOUDL BE TERMINATOR
	BEQ MFFNDN		;IS
	CMPB #' ,-1(D)
	BEQ MFFNDN		;CLOSE ENOGUH
	LSERR BFN

MFFNGN:	CLR B
1$:	MOVB (D)+,A		;NEXT
	BEQ MFFNDN		;DONE
	CMPB #' ,A
	BEQ MFFNDN
	SUB #60,A
	LSERRC LT,BFN
	CMP #9.,A
	LSERRC LT,BFN
	MUL #10.,B
	ADD A,B
	BR 1$

				;SET UP BIT TABLE FOR THE DISK THE BIT TABLE FILE IS ON
LSFAMB:	MOV C,F			;MOVE CAP POINTER TO STANDARD PLACE
	MOV LSCIPN(F),A		;GET ITEM POINTER
	MOV MFDKNO(A),D		;GET DISK NUMBER
	JSR PC,CLRCAP		;SET POINTER TO ZERO
	JSR PC,DSKBGC		;GET BITS BLOCK
				;THE BIT TABLE HAD BETTER BE LESS THAN ONE BLOCK
	MOV B,A			;COPY POINTER TO BLOCK
				;HERE COPY BLOCK INTO INTERNAL BLOCK
	CMP (A),#<LSBTLN-4>*8.	;WILL THERE BE ROOM FOR THE WHOLE THING?
	LSERRC HIS,NIS		;NOPE
	MOV LSBTBS,C		;GET A BIT TABLE
	LSERRC EQ,NIS		;NO SPACE
	MOV (C),LSBTBS		;LINK IT OUT
	MOV C,MFBITP(D)		;SAVE BIT TABLE POINTER FOR DISK
	SAVE F
	MOV (A),F		;NUMBER OF BLOCKS
	ASH #-4,F		;16 BLOCKS PER WORD
	ADD #2,F		;FOR GOOD MEASURE
1$:	MOV (B)+,(C)+	
	SOB F,1$
	REST F
	MOV BLOKNO,MFBITB(D)	;SAVE BLOCK NUMBER OF BIT TABLE
	JSR PC,BITCNT		;COUNT UP THE FREE BLOCKS
	MOV A,MFFREE(D)		;NUMBER OF FREE BLOCKS
	ADD #6,E
	RTS PC

;COUNT NUMBER OF FREE BITS IN BIT TABLE POINTED TO BY A
;RETURN RESULT IN A
;CLOBBERS EVERYTHING BUT E AND D
BITCNT:	SAVE E
	MOV A,E			;COPY THE POINTER
	CLR A			;SAVE THE COUNT HERE
	MOV (E)+,B		;NUMBER OF BLOCKS ON EMPTY DISK
1$:	MOV #16.,C		;NUMBER OF BITS/WORD
	MOV (E)+,F		;GET A WORD OF BITS
2$:	ROR F			;GET A BIT TO TEST
	BCS 4$			;NOT FREE
	INC A
4$:	DEC B			;PAST TOTAL BLOCKS?
	BEQ 3$			;YUP
	SOB C,2$		;DO WHOLE WORD
	BR 1$			;DO NEXT WORD
3$:	REST E
	RTS PC

				;COMMON BEGINNING FOR DELETE AND SUPER DELETE
MFACDL:	MOV C,F			;MOVE CAP POINTER TO USUAL PLACE
	MOV LSCIPN(F),D		;GET POINTER TO ITEM
	TST MFDELF(D)		;ALREADY SORT OF GONE?
	LSERRC NE,FNF		;WELL, NOT IN DIRECTORY ANYWAY
	RTS PC

				;SUPER DELETE, DELETE A DIR EVEN IF IT ISN'T EMPTY
LSFSDL:	JSR PC,MFACDL		;DO COMMON STUFF
	TST MFDIRF(D)		;IS IT A DIR?
	LSERRC EQ,BAD		;SUPER DELETE ISN'T NEEDED, SLAP HIS WRIST
	CMP #1,MFRFCN(D)	;IS THERE A FILE OPEN IN THIS DIR?
	LSERRC NE,CDD		;DANGEROUS TO DELETE IF MORE THAN ONE CAP
	BR MFADL2		;GO DELETE IT, WHATEVER IT IS

				;REGULAR DELETE
LSFADL:	JSR PC,MFACDL		;DO COMMON START
	TST MFDIRF(D)		;IS IT A DIR?	
	BEQ MFADL2		;IF A FILE, DON'T NEED EXTRA CHECKING

				;CHECK THAT DIR IS EMPTY
	JSR PC,CLRCAP
	JSR PC,DSKBGC
	SAVE B
	MOV #2,C		;DO TWICE
MFADL1:	MOV (B),A		;GET HEADER WORD
	INC A			;IN CASE COUNT IS ODD
	BIC #177401,A		;EVEN IT
	ADD A,B
	SOB C,MFADL1
	SUB (P)+,B		;UNRELATIVE IT
	CMP B,MFEOFL(D)
	LSERRC NE,CDD		;CAN'T DELETE DIRECTORY THAT ISN'T EMPTY
				;FALLS THROUGH
				;FALLS IN
MFADL2:	MOV PC,MFDELF(D)	;DELETE BLOCKS OF FILE WHEN LAST CAP FLUSHED
	MOV #-1,F		;ONE LESS FILE IN DIR
	JSR PC,MFIUND		;ADJUST ANY ACTIVE MFIS ABOVE THIS FILE
	JSR PC,MFGTDR		;GET POINTER TO THE DIR
	SAVE B
	MOV MFFLNO(D),C		;FILE NUMBER BEFORE GETTING HACKED
	INC C			;MFIUND DECED US TOO
MFADL3:	MOV (B),A		;GET HEADER WORD OF ENTRY
	INC A			;IN CASE ODD
	BIC #177401,A		;EVEN IT OUT
	ADD A,B			;POINT TO NEXT ENTRY
	SOB C,MFADL3		;TILL WE GET TO THE ONE WE'RE INTERESTED IN
	MOV (B),F		;GET HEADER WORD
	INC F			;IN CASE ODD
	BIC #177401,F		;MAKE EVEN
	MOV B,C
	REST B
	SUB F,6(B)		;ADJUST EOF POINTER IN DIR
	MOV C,A			;COPY POINTER TO ENTRY BEING FLUSHED
	ADD F,C			;POINT TO BEG OF NEXT ENTRY
	ADD 6(B),B		;POINT TO NEW END
MFADL4:	CMP B,A			;ARE WE ABOUT TO COPY PAST THE END?
	BEQ MFADL5		;YUP
	MOV (C)+,(A)+		;COPY NE WORD
	BR MFADL4
MFADL5:	MOV PC,BLOKMD		;INDICATE BLOCK MODIFIED
	MOV MFBACK(D),B		;POINT TO MFI OF PARENT
	SUB F,MFEOFL(B)		;ADJUST EOF
	ADD F,MFRSFR(B)		;AND FREE BYTES
	JSR PC,LSFLSB		;FLUSH BUFFERS
	ADD #6,E
	RTS PC

MFGTDR:	MOV MFBACK(D),B		;POINTER TO PARENT
	MOV MFBLKN(B),A		;THE BLOCK NUMBER
	MOV MFDKNO(B),B		;THE DISK NUMBER
	JSR PC,DSKRD		;READ IT IN
	RTS PC

				;DELETE THE BLOCKS BELONGING TO THE FILE WHOSE MFI IS IN D
MFIBFL:	JSR F,LSACSV
	BIT #MFSHRB,MFENTY(D)	;SHARED BLOCKS?
	BNE MFIBF3
	MOV MFDKNO(D),A		;GET THE RIGHT BIT TABLE
	MOV MFBITP(A),C		;GET AGAIN
	MOV PC,MFBITM(A)	;INDICATE MODIFIED
	SAVE A			;SAVE DISK NUMBER FOR LATER USE
	MOV MFEOFH(D),E		;EOF BYTE POINTER
	MOV MFEOFL(D),F
	ASHC #-10.,E		;MAKE INTO BLOCK COUNT
	INC F			;JUST FOR GOOD MEASURE
MFIBF1:	MOV D,A			;ITEM POINTER
	MOV F,B			;BLOCK NUMBER IN FILE
	JSR PC,GTBLK		;GET REAL BLOCK NUMBER
	CMP #-1,B		;REALLY THER?
	BEQ MFIBF2		;NO, IGNORE THIS ONE
	CMP B,(C)		;BIGGER THAN BIGGEST?
	BLO 1$
	BPT
1$:	MOV B,E			;COPY BLOCK NUMBER
	BIC #177770,E		;GET BIT NUMBER
	ASH #-3,B		;AND BYTE NUMBER
	ADD C,B			;BYTE POINTER
	BICB LSBMT(E),2(B)	;TABLE IS OFFSET BY 2
	MOV (P),B		;DISK NUMBER
	INC MFFREE(B)		;ONE MORE BLOCK FREE
MFIBF2:	DEC F
	BGE MFIBF1
	REST A			;GET DISK NUBMER AGAIN
	JSR PC,WRTBIT		;WRITE OUT THIS DISKS BIT TABLE
MFIBF3:	JSR F,LSACRT
	RTS PC

				;FIX UP ANY MFI'S THAT ARE ABOVE A ENTRY BEING CREATED OR DELETED
				;CALL WITH: NUMBER OF AFFECTED FILE IN C
				;ITEM # OF DIRECTORY MFI IN D
				;AMOUNT TO ADJUST BY IN F (I.E. 1 OR -1)
MFIUND:	JSR F,LSACSV
	MOV MFBACK(D),E		;DIR MFI
	MOV MFFLNO(D),C		;FILE BEING ADDED OR DELETED
	MOV MFOPNF,A
MFINU4:	CMP E,MFBACK(A)		;IS THIS MFI IN THE RIGHT DIR?
	BNE MFINU2		;NOPE
	CMP C,MFFLNO(A)		;SAME OR ABOVE BEING HACKED ENTRY?
	BGT MFINU2		;NO
	ADD 12(P),MFFLNO(A)	;ADJUST THIS ONE
MFINU2:	MOV (A),A		;GET NEXT IN LINE
	BNE MFINU4		;NO MORE
	JSR F,LSACRT
	RTS PC

				;ADD A FILE TO A DIR, AND MUTATE TO THAT FILE
LSFAAD:	MOV C,F			;PUT CAP INDEX IN ITS PLACE
	MOV 2(E),D		;POINTER TO THE NAME STRING
	JSR PC,MFFNG		;GO GOBBLE DOWN THE FILE NAME
	LSERRC EQ,BFN		;NO FILE NAME???
	CMP #-3,FNBVER		;FOO< ?
	LSERRC EQ,BFN		;CAN'T CREATE THAT
	JSR PC,DIRSER		;LOOK FOR FILE IN DIR
	BEQ MFAAD2		;NOT THERE, THAT'S FINE
	CMP #-2,FNBVER		;ARE WE ADDING >?
	LSERRC NE,EAE		;NO, FILE ALREADY EXISTS
	INC C			;NEXT VERSION NUMBER
	INC FNBFNO		;GO TO NEXT SPOT IN DIR
	BR MFAAD3		;ADD THAT ONE
MFAAD2:	MOV FNBVER,C		;SPECIFIED VERSION NUMBER
	CMP #-2,C		;ARE WE ADDING >?
	BNE MFAAD3	
	INC FNBFNO		;GO TO NEXT SPOT
	MOV #1,C		;VERSION NUMBER 1
MFAAD3:	MOV C,FNBVER
	MOV LSCIPN(F),D		;GET ITEM POINTER
	TST MFDELF(D)
	LSERRC NE,BCT		;WELL, SORT OF
	JSR PC,GETITM		;GET AN ITEM FOR THE NEW THING
	INC MFRFCN(D)		;REFERENCED ONCE
	MOV LSCIPN(F),C		;POINTER TO THING ABOUT TO BE A PARENT
	MOV MFDKNO(C),MFDKNO(D)	;SAME DISK NUMBER
	MOV FNBFNO,MFFLNO(D)	;AND FILE NUMBER
	MOV C,MFBACK(D)		;THIS WHILE BE THE PARENT
	MOV PC,MFADDF(D)	;THIS IS A NEW FILE
	MOV MFDKNO(D),C		;DISK NUMBER
	INC MFDKRF(C)		;ONE MORE REFERENCE
	MOV D,C
	ADD #MFENTY+14,C	;GET POINTER TO PLACE FOR ENTRY NAME
	MOV #FNBFN,A		;POINTER TO FILE NAME
1$:	MOVB (A)+,(C)+
	BGE 1$			;COPY NAME
	SUB #2,C		;BACK OFF
	MOV D,A			;POINTER TO ITEM AGAIN
	MOV C,MFENDP(A)
	SUB D,C
	SUB #MFENTY-2,C		;NOW THE LENGTH
	JSR PC,DIRCMT		;COMMIT THAT MANY BYTES INTHE DIRECTORY
	BEQ 2$			;COULDN'T GET BYTES, BACK OFF
	BIS #MFFILE!MFEOFB,C
	ADD #MFENTY,A		;POINT TO ENTRY
	MOV C,(A)+		;HEADER WORD
	MOV FNBVER,(A)+		;VERSION NUMBER
	CLR (A)+		;EOF POINTER
	CLR (A)+
	JSR PC,CMDATE		;GO COMPUTE DATE AND TIME
	MOV FDATE,(A)+		;DATE
	MOV FTIME,(A)+		;TIME
	SAVE F
	MOV #1,F		;ADDING A FILE
	JSR PC,MFIUND		;ADJUST OTHER FILES IN THE DIR
	DEC MFFLNO(D)		;DON'T WANT JUST ADDED ENTRY ADJUSTED
	JSR PC,MFIINS		;PUT IT INTO DIR
	REST F
	MOV D,LSCIPN(F)		;MUTATE CAP
	JSR PC,CLRCAP
	ADD #6,E
	RTS PC

				;COME HERE TO FLUSH ITEM, NOT ENOUGH ROOM IN DIR
2$:	JSR PC,DELITM
	LSERR DRF

;COMPUTE THE DATE AND TIME WORDS FOR A FILE
CMDATE:	JSR F,LSACSV
	MOV #LSYEAR,C	;POINTER TO UPDATED DATE+TIME
	TST (C)+	;HAS YEAR BEEN SET?
	BLT CMDAT2	;NO, LEAVE FILE DATES -1
	MOV #TSHIFT,D	;TABLE OF SHIFT COUNTS
	MOV #5,E	;NUMBER OF PARTS
	CLR B		;CLEAR LOW ORDER PATE OF 2 WORDS
	MTPS #340
CMDAT1:	BIS -(C),B	;SET THIS PART IN
	ASHC (D)+,A	;SHIFT UP
	SOB E,CMDAT1	
	MOV -(C),E	;SECONDS
	ASR E
	BIS E,B		;SECONDS GET DIVIDED BY 2
	MTPS #0
	MOV A,FDATE	;THE DATE
	MOV B,FTIME	;AND TIME
CMDAT2:	JSR F,LSACRT
	RTS PC
				;COMMIT SPACE IN A DIR
DIRCMT:	SAVE <A,C>
	MOV MFBACK(D),A
	INC C			;ALWAYS ALLOCATE
	BIC #1,C		;AN EVEN NUMBER OF BYTES
	CMP C,MFRSFR(A)		;DO THAT MANY UNCOMMITED FREE BYTES EXIST?
	BHIS 1$			;LOST
	SUB C,MFRSFR(A)		;COMMIT THAT MANY
	ADD C,MFRSFR(D)		;WE HAVE THAT MANY COMMITTED NOW
	REST <C,A>
	CLZ
	RTS PC
1$:	REST <C,A>
	SEZ
	RTS PC

				;INSERT MFI IN D INTO ITS DIRECTORY
MFIINS:	JSR F,LSACSV
	JSR PC,MFGTDR		;GET THE DIR
	MOV PC,BLOKMD		;WE WILL MODIFY IT
	TST MFDIRF(D)		;IF IT'S A DIR WE ARE DOING A FAMD
	BNE 9$			;DON'T PUT IN EOF WORDS
	MOV MFEOFL(D),F		;GET LOW PART OF EOF
	MOV F,A
	MOV MFEOFH(D),E		;HIGH BITS
	ASHC #3,E		;GOBBLE HIGH BITS
	MOV E,MFENTY+4(D)	;PUT HIGH BITS INTO ENTRY
	BIC #160000,A
	MOV A,MFENTY+6(D)	;PUT IN LOW BITS
9$:	MOV MFBACK(D),F		;POINTER TO ITEM FOR DIR
	MOV B,C			;COPY DIR POINTER
	MOV MFFLNO(D),A		;GET FILE NUMBER
1$:	MOV (C),E		;HEADER WORD
	INC E
	BIC #177401,E
	ADD E,C
	SOB A,1$
	MOV (C),E		;HEADER OF THE OLD ENTRY
	INC E
	BIC #177401,E		;OLD BYTE COUNT
	TST MFADDF(D)		;BEING ADDED?
	BEQ 2$			;NOPE, OLD ENTRY
	CLR E			;OLD ENTYR HAD ZERO BYTES
2$:	CLR MFADDF(D)
	SAVE D			;SAVE FOR LATER
	ADD #MFENTY,D		;POINT AT ENTRY
	MOV (D),A		;HEADER WORD
	INC A
	BIC #177401,A		;NEW BYTE COUNT
	SAVE <C,A>
	SUB A,E			;GET DIFF OLD-NEW	
				;IF ZERO THEY ARE THE SAME LENGTH
				;IF POSITIVE, NEW IS SHORTER
				;IF NEGATIVE NEW IS LONGER
	ADD MFRSFR-MFENTY(D),MFRSFR(F)	;FREE ALL COMMITTED BYTES
	CLR MFRSFR-MFENTY(D)
	ADD E,MFRSFR(F)		;AND GRAB THOSE ACTUALLY USED
	SUB E,6(B)		;ADJUST DIR EOF
	SUB E,MFEOFL(F)		;ADJUST EOF POINTER IN PARENT
	TST E			;CHECK SIGN OF DIFF
	BLT MFIIN2		;NEW ONE IS BIGGER THAN OLD
	BEQ MFIIN3		;NEW ONE IS SAME SIZE AS OL
				;FALL THROUGH IF NEW IS SMALLER THAN OLD

	ADD A,C
	ADD C,E
	ADD MFEOFL(F),B		;POINT TO NEW EOF
MFIIN4:	CMP B,C			;AT NEW EOF?
	BEQ MFIIN3		;YUP
	MOV (E)+,(C)+
	BR MFIIN4

MFIIN2:	ADD MFEOFL(F),B		;GET NEW EOF
	SUB B,E			;NEGATIVE OF NEW END-DIFFER
	NEG E
MFIIN5:	CMP B,C			;AT END?
	BEQ MFIIN3		;YUP
	MOV -(B),-(E)		;COPY A WORD
	BR MFIIN5

MFIIN3:	REST <B,C,E>		;B=BYTE COUNT, C=DIR POINTER, E=MFI POINTER
	MOV E,A			;COPY MFI POINTER
	ADD #MFENTY,E		;POINT AT ENTRY IN MFI
1$:	MOVB (E)+,(C)+		;COPY NEW ENTRY INTO DIR
	SOB B,1$
	JSR PC,LSFLDR		;WRITE OUT CHANGED BLOCK
	MOV MFDKNO(A),A		;GET DISK NUMBER
	JSR PC,WRTBIT		;WRITE OUT CHANGED BIT TABLE (IF CHANGED)
	JSR F,LSACRT
	RTS PC




				;CHANGE A FILE INTO A DIRECTORY
LSFAMD:	MOV C,F			;MOVE CAP TO USUAL PLACE
	MOV LSCIPN(F),D		;AND ITEM POINTER
	TST MFDIRF(D)		;IS IT ALREADY A DIR?
	LSERRC NE,BAD		;YES!
	TST MFEOFH(D)		;IS IT > 8 BLOCKS?
	LSERRC NE,BAD		;YES, THAT'S A NO-NO
	CMP #2000,MFEOFL(D)	;IS IT > 1 BLOCK?
	LSERRC LT,BAD		;SO IS THAT
	TST MFEOFL(D)		;BUT IS THERE SOMETHING THERE?
	LSERRC EQ,BAD		;NOPE!
	JSR PC,CLRCAP
	JSR PC,DSKBGC		;GET DESIRED BLOCK
	SAVE <D,MFBACK(D),F,#0>
	MOV BLOKNO,MFBLKN(D)	;SAVE BLOCK NUMBER OF DIR
	MOV #MFSLFE,F		;FOR THE SELF ENTRY
	JSR PC,MFAMDC		;COPY ENTRY INTO DIR
	MOV 4(P),D		;POINTER TO PARENT
	MOV B,4(P)		;SAVE POINTER INTO DIR
	MOV #MFPARE,F		;PARENT ENTRY
	JSR PC,MFAMDC		;COPY PARENT INTO DIR	
	MOV 4(P),B		;GET BACK POINTER TO WHAT WILL BECOME PARENT ENTRY
	BIC #100000,(B)		;FLUSH THE EOF BIT
	SUB #10,(B)		;FLUSH THE BYTES WE WILL FLUSH
	MOV (B)+,C		;THE HEADER WORD
	INC C
	BIC #177401,C		;SAVE JUST COUNT
	ASR C			;WORD COUNT
	SUB #2,C		;HEADER+VERSION NUMBER
	SUB #10,(P)		;ON THE STACK TOO
	TST (B)+		;PAST VERSION NUMBER
1$:	MOV 10(B),(B)+
	SOB C,1$
	SUB (P),B		;GULP, DOES THIS WORK?
	CLR 4(B)		;NUMBER OF REAL PAGES
	MOV (P),6(B)		;NUMBER OF USED BYTES
	MOV 2(P),F		;RECOVER CAP POINTER
	MOV LSCIPN(F),A		;ITEM POINTER
	ADD #MFENTY,A		;POINT TO ENTYR IN MFI
	MOV (A),B		;GET HEADER WORD
	INC B
	BIC #177401,B		;GET A BYTE COUNT
	ASR B			;WORD
	SUB #6,B		;LESS EOF+TIEM+DATE+HEADER+VERN
	SAVE <A,B>
	BIC #117000,(A)		;FLUSH TYPE AND EOF BIT
	BIS #MFDIRE,(A)		;IT IS A DIR
	SUB #10,(A)+		;FLUSH 8. BYTES
	TST (A)+		;DON'T TOUCH VERN

MFAMD3:	MOV 10(A),(A)+	
	SOB B,MFAMD3
	MOV LSCIPN(F),D		;GET ITEM POINTER AGAIN
	MOV PC,MFDIRF(D)
	JSR PC,MFIINS		;INSERT THIS INTO THE PARENT
	CLR MFMODF(D)		;DON'T WANT IT INSERTED AGAIN
	REST <B,A>
	ADD #10,(A)
	BIS #100000,(A)+
	TST (A)+		;SKIP VERN
	ADD B,A
	ADD B,A			;GET TO THE END OF THE GOOD STUFF
MFAMD2:	MOV -(A),10(A)		;COPY UP
	SOB B,MFAMD2
	REST <B,F,,D>
	CLR MFEOFH(D)
	MOV B,MFEOFL(D)
	MOV PC,MFDIRF(D)	;SAY THIS IS A DIR
	NEG B
	ADD #2000,B		;GET NUMBER OF FREE BYTES
	MOV B,MFRSFR(D)		;THAT MANY FREE BYTES IN DIR
	JSR PC,LSFLDR
	ADD #6,E
	RTS PC

MFAMDC:	ADD #MFENTY,D		;POINT TO ENTRY ITSELF
	MOV (D),C		;GET HEARER WORD
	INC C			;ROUND UP
	BIC #177401,C		;CLEAR CRAP
	ADD C,2(P)		;SAVE LENGTH IN BYTES
	ASR C			;FOR THE SOB
	MOV (D)+,(B)		;COPY THIS INTO DIR
	BIC #17000,(B)		;CLEAR OLD TYPE
	BIS F,(B)+		;CHANGE TO A SELF ENTRY
	DEC C
MFAMD1:	MOV (D)+,(B)+		;A WORD AT A TIME
	SOB C,MFAMD1
	RTS PC
SMSBRK:	RTT		;NO INTERUPTS YET

WRTBIT:	TST MFBITM(A)		;MODIFIED?
	BEQ 1$
	CLR MFBITM(A)
	SAVE <B,BLOKNO,WCHDSK>
	MOV MFBITP(A),B
	MOV MFBITB(A),BLOKNO
	MOV A,WCHDSK
	JSR PC,DSKWRT
	REST <WCHDSK,BLOKNO,B>
	JSR PC,LSERBD		;IF ERROR, VERY BAD
1$:	RTS PC

DSKBGC:	JSR PC,DSKBGT		;READ BLOCK
	TST TRNERR
	LSERRC NE,DSKE
	RTS PC

LSFLDR:	JSR PC,LSFLSB
LSERBD:	TST TRNERR
	LSERRC NE,DVBE		;VERY BAD DISK ERRROR
	RTS PC

LSFLSB:	TST BLOKMD		;MODIFIED?
	BEQ 1$
	CLR BLOKMD
	SAVE B
.IF NDF LSNDB
	MOV #LSDBUF,B		;IF WE ALLOCATE
.IFF
	JSR PC,LSGDBA		;IF SOMEONE ELSE DOES
.ENDC
	JSR PC,DSKWRT
	REST B
1$:	RTS PC

DSKRED:	MOV #DISKRD,DISKIO
	BR DSKBLK

DSKWRT:	MOV #DISKWR,DISKIO
	BR DSKBLK


.IF NZ RKDSK
RKCS=177404
RKWC=177406
RKCA=177410
RKDA=177412

DSKBLK:	JSR F,LSACSV
.IF NZ METERS
	MOV #MTDISK,METERP
	TST MTFLAG
	BNE 1$
	INC MTDSKC		;ONE MORE BLOCK XFERED
1$:
.ENDC
	CLR TRNERR		;NO ERROR
	MOV #NRETRY,RETRYS	;SET RETRYS FOR THIS SECTOR
2$:	MOV TRNSLE,RKWC
	MOV B,RKCA
	MOV BLOKNO,D
	CLR C
	ASL D
	DIV #12.,C
	ASH #4,C		;MUL QUOTIENT BY 16
	BIS C,D
	MOV WCHDSK,C
	ASH #12.,C
	BIS C,D
	MOV D,RKDA
	CMP #DISKWR,DISKIO	;WRITE?
	BEQ 3$			;YUP
	MOV #5,RKCS		;READ
	BR 4$
3$:	MOV #3,RKCS
4$:	TSTB RKCS
	BGE 4$
	TST RKCS
	BGT 5$			;NO ERROR, DONE
	MOV #1,RKCS		;RESET CONTROLLER
6$:	TSTB RKCS
	BGE 6$
	BIT #3,RETRYS
	BNE 7$
	MOV #15,RKCS		;RESET DRIVE
7$:	TSTB RKCS
	BGE 7$
	DEC RETRYS
	BGT 2$
	INC TRNERR
5$:
.IIF NZ METERS,	MOV #MTLSIT,METERP
	JSR F,LSACRT
	RTS PC

.ENDC
.IF NZ SMSDSK!RXDISK
				;DISK ROUTINES FOR THE FLOPPY DISK
DSKBLK:	JSR F,LSACSV
.IF NZ METERS
	MOV #MTDISK,METERP
	TST MTFLAG
	BNE 1$
	INC MTDSKC		;ONE MORE BLOCK XFERED
1$:
.ENDC
.IIF Z RXDISK,	JSR PC,DISKON		;MAKE SURE DISK IS ON
	CLR TRNERR
	MOV TRNSLE,FLOPWC
	MOV BLOKNO,F		;THE BLOCK NUMBER
	MOV WCHDSK,A
	CLR E
	TST LSDEN(A)		;SINGLE OR DOUBLE?
	BNE 2$			;DOUBLE
	ASHC #3,E		;8 SECTORS/BLOCK
	DIV #26.,E		;26 SECTORS/TRACK
	MOV #128.,SECSIZ
	MOV #27.,SECLIM
	BR 3$
2$:	ASHC #1,E		;2 SECTORS/BLOCK
	DIV #16.,E		;16 SECTORS/TRACK
	MOV #512.,SECSIZ
	MOV #17.,SECLIM
3$:	INC E
	MOV E,FLOPTR		;TRACK
	INC F			;SECTORS ARE NUMBERED FUNNY
	MOV F,FLOPSC		;SECTOR
DSKBLS:	MOV B,FLOPCA		;SAVE STARTING CORE ADDRESS
.IFZ RXDISK
	MOV #SMSCSR,F		;THE CONTROL REGISTER
	MOV #SMSDBF,E		;THE DATA BUFFER
.ENDC ;Z RXDISK
	MOV WCHDSK,A
.IIF Z RXDISK,	JSR PC,FLPSE1		;FORCE AN INITIAL SEEK

DSKBL1:	TST FLOPWC		;ANY WORDS LEFT TO XFER?
	BNE 1$			;YUP
.IIF NZ METERS,	MOV #MTLSIT,METERP
	JSR F,LSACRT
	RTS PC
1$:


	MOV #NRETRY,RETRYS	;SET RETRYS FOR THIS SECTOR
DSKBL2:
.IFZ RXDISK
	JSR PC,FLPSEK
	BEQ FLPERR
.ENDC ;Z RXDISK
	JSR PC,SECMUN
	CMP #DISKWR,DISKIO	;WRITE?
	BEQ FLOPWR
.IFZ 105			;WRITE CHECK NOT USED
	CMP #DISKWC,DISKIO	;WRITE CHECK?
	BEQ FLOPCM
.ENDC
	CMP #DISKRD,DISKIO	;READ?
	BEQ FLOPRD
2$:	BPT
	BR 2$

FLOPWR:
.IFZ RXDISK
	MOV #SMSWRT!SMSHTB,A	;TRANSFER BLOCK TO BUFFER
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
1$:	MOVB (A)+,(E)
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	MOV #SMSWRT!SMSBTD,A	;TRANFER BUFFER TO THE DISK
	JSR PC,DCMD
	MOV FLOPSS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	BR FLPSEC		;DONE WITH THIS SECTOR	
.IFF
	MOV #RXFLBF,RXCSR	;GIVE FILL BUFFER CMND
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
2$:	BIT #RXTR,RXCSR		;WAIT FOR XFER RQST
	BEQ 2$
	MOVB (A)+,RXDBR
	SOB B,2$
3$:	BIT #RXDONE,RXCSR	;WAIT UNTIL DONE
	BEQ 3$
	MOV #RXWRTS,A		;WRITE SECTOR COMMAND
	JSR PC,RXRDWR		;COMMON READ-WRITE HANDSHAKE CODE
	BR FLPSEC		;DONE WITH THIS SECTOR	

RXRDWR:	JSR PC,RXCMND		;INSERT DRIVE SELECT BIT AND ISSUE COMMAND
4$:	BIT #RXTR,RXCSR
	BEQ 4$
	MOV FLOPSS,RXDBR	;FIRST GIVE IT SECTOR ADDR
5$:	BIT #RXTR,RXCSR
	BEQ 5$
	MOV FLOPTR,RXDBR	;THEN GIVE IT THE TRACK ADDR
6$:	BIT #RXDONE,RXCSR	;WAIT TIL DONE
	BEQ 6$
	BIT #RXERR,RXCSR	;DID IT WORK?
	BNE FLPERR		;NOPE
	RTS PC

RXCMND:	TST WCHDSK		;WHICH DISK ARE WE USING
	BEQ 1$			;JUMP IF DISK 0, COMMAND ALL SET
	BIS #RXDSK1,A		;DISK 1, SET THE BIT
1$:	BIT #RXDONE,RXCSR
	BEQ 1$			;WAIT UNTIL DISK IS READY
	MOV A,RXCSR		;ISSUE THE COMMAND
	RTS PC

.ENDC ;RXDISK

FLPERR:	JMP FLPERX

FLOPRD:
.IFZ RXDISK
	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPSS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
1$:	MOVB (E),(A)+
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC		;DONE WITH THIS SECTOR	
.IFF
	MOV #RXREDS,A		;READ SECTOR COMMAND
	JSR PC,RXRDWR		;COMMON CODE WITH WRITE
	MOV #RXMTBF,RXCSR	;NOW GIVE EMPTY BUFFER CMD
	MOV FLOPCA,A		;BUFFER ADDR
	MOV SECSIZ,B		;SECTOR SIZE
1$:	BIT #RXTR,RXCSR		;WAIT FOR XFER REQ
	BEQ 1$
	MOVB RXDBR,(A)+		;THE ACTUAL MOVE
	SOB B,1$
	BR FLPSEC		;CAN'T FAIL AT THIS POINT (IT SEZ HERE)
.ENDC ;RXDISK

.IFZ 105			;WRITE CHECK NOT USED
FLOPCM:	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPSS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
1$:	CMPB (E),(A)+
	BNE FLPERC
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC
.ENDC
.IFZ RXDISK
FLPERC:	DEC B			;ONE LESS BYTE
	BEQ 2$			;ERROR ON LAST BYTE
1$:	MOV (E),A		;TO EMPRY BUFFER
	SOB B,1$
2$:	JSR PC,GETST
	BR FLPERR		;NOW DO THE ERROR
.ENDC ;Z RXDISK

FLPSEC:	MOV SECSIZ,A
	ADD A,FLOPCA
	ASR A
	ADD A,FLOPWC		;TRANSFERED 64. WORDS
	BEQ 1$			;DONE TRANSFER
	INC FLOPSC		;OR ONE SECTOR
	CMP SECLIM,FLOPSC		;OVER TRACK BOUNDARY?
	BGT 1$
	MOV #1,FLOPSC		;TO START ON NEXT TRACK
	INC FLOPTR
1$:	JMP DSKBL1		;GO CONTINUE THE TRANSFER


SECMUN:	SAVE <A,B>
	MOV WCHDSK,A
	TST LSDEN(A)		;DOUBLE OR SINGLE?
	BNE 1$			;DOUBLE
	MOV FLOPTR,B		;NEW IS HARDER
	DEC B
	MUL #3,B		;SECTORS ARE OFFSET BY 6 FOR EACH TRACK
	CLR A
	ADD FLOPSC,B
	DEC B
	DIV #13.,A
	ASL B
	INC B
	CMP #13.,FLOPSC
	ADC B
	BR 2$
1$:	MOVB FLOPSC,B
	MOVB DBLSCM(B),B	
2$:	MOV B,FLOPSS
	REST <B,A>
	RTS PC




.IF Z RXDISK
FLPSEK:	MOV WCHDSK,A
	CMP FLOPTR,FLOPRT(A)	;ON THE TRACK?
	BEQ FLPSE2
FLPSE1:	TST FLOPRT(A)		;IS THIS DRIVE INITED?
	BGE 2$			;YES
	SAVE <A,FLOPTR>
	CLR FLOPTR
	JSR PC,2$
	REST <FLOPTR,A>
2$:	MOV FLOPTR,FLOPRT(A)
	TST FLOPRT(A)
	MOV #SMSSEK,A		;REENTER HERE ON ERROR
	JSR PC,DCMD
	MOV FLOPTR,A
	JSR PC,CMD2		;SEEK TO TRACK	
	JSR PC,GETST		;GET STATUS OF THE SEEK
	RTS PC
FLPSE2:	CLZ
	RTS PC
.ENDC ;Z RXDISK 

FLPERX:	DEC RETRYS		;TIME TO GIVE UP?
	BGE 1$
2$:	INC TRNERR		;SAY THERE WAS AN ERROR ON THIS XFER
	BR FLPSEC		;AND CONTINUE
1$:
.IFZ RXDISK
	MOV FERRST,A
	ASL A
	JMP @.+4(A)
	DSKBL2			;STRANGE, ERROR DISAPPEARED???
	BADER			;COMMAND ERROR IS BAD
	DRERR			;DRIVE ERROR
	OPRERR			;OPERATION ERROR

DRERR:
BADER:	INC TRNERR		;GIVE UP
	BR FLPSEC

OPRERR:	BIT #SMSHPE,ERRDAT	;SEEK ERROR?
	BEQ OPRER1		;NOPE
RECAL:	MOV WCHDSK,A
	MOV #-1,FLOPRT(A)
OPRER1:	JMP DSKBL2		;TRY AGAIN
.IFF
	JMP DSKBL2		;FOR RXDISK, ALWAYS TRY AGAIN
.ENDC ;RXDISK

.IFZ RXDISK
				;ROUTINES TO INTRACT WITH THE DISK ON A LOW LEVEL

				;GET THE STATUS OF THE SELECTED DISK
REQST:	MOV #SMSSTS,A		;GET STATUS
	JSR PC,DCMD		;ISSUE REQUEST FOR STATUS
	JSR PC,CMD2		;SECOND BYTE IGNORED
	JMP GETST		;GET THE STATUS
				;IF WE GET BACK WITHOUT ERROR IT WILL BE DISK STATUS

				;ISSUE THE FIRST COMMAND BYTE (IN A), ORING IN THE DISK NUMBER
DCMD:	SAVE A
	MOV WCHDSK,A
	ASH #2,A		;DISK # ALREADY SHIFTED BY 1
	BIS (P)+,A
	MOV A,SMSCMD		;GIVE COMMAND
	RTS PC

				;ISSUE THE SECOND BYTE OF A COMMAND
CMD2:	BIT #SMSCMW,(F)		;WAITING?
	BEQ CMD2		;NOT YET
	MOV A,SMSCMD	
	RTS PC

GETST:	BIT #SMSST1!SMSST0,(F)	;STATUS AVAILABLE?
	BEQ GETST
	BIT #SMSERR,(F)		;ERROR?
	BNE 3$			;YUP
4$:	MOV SMSDBF,A		;GOBBLE STATUS
	CLZ
	RTS PC

3$:	JSR PC,ERRGBL		;GOBBLE ERROR STATUS
	SEZ
	RTS PC

ERRGBL:	BIT #SMSST1!SMSST0,(F)	;ANYTHING THERE?
	BEQ ERRGB1		;NOPE, KEEP OLD ERROR
	MOVB 1(F),A		;GET NEW ERROR TYPE
	BIC #177774,A		;FLUSH EXTRA STUFF
	MOV A,FERRST
	MOV SMSDBF,ERRDAT
ERRGB1:	RTS PC


DISKON:	MTPS #340		;TO PREVENT CLOCK FROM TURNING IT OFF AS WE TURN IT ON
	TST LSDKOF
	BNE 3$
	MOV #30.*60.,LSDKOF
	MTPS #0
	SAVE <A,B,F>
	BIS #SMSRSB!SMSPWR,SMSCSR	;RESET CONTROLLER AND POWER DRIVES ON
	CLR A			;FOR TIMER
	MOV #30.,B		;ALSO
1$:	BIT #SMSFDO,SMSCSR	;IS IT RESET YET?
	BEQ 2$
	SOB A,1$		;WAIT
	SOB B,1$		;A LONG TIME

2$:	MOV #10000.,B
	MOV #SMSCSR,F
4$:	MOV #SMSSTS,A
	JSR PC,DCMD
	JSR PC,CMD2
	JSR PC,GETST
	BIT #SMSDNR,A		;READY?
	BEQ 5$
	SOB B,4$

5$:	MOV #LSMXDK,A
	MOV #FLOPRT,B
6$:	MOV #-1,(B)+
	SOB A,6$
	REST <F,B,A>
3$:	MOV #30.*60.,LSDKOF	;TIME FOR DISK TO STAY ON
	MTPS #0
	JSR PC,SETDEN		;GET THE DENSITY RIGHT
	RTS PC

DSKOFF:	CLR LSDKOF
	BIS #SMSRSB,SMSCSR
	BIC #SMSPWR,SMSCSR
1$:	RTS PC

SETDEN:	SAVE <A,F>
	MOV #SMSCSR,F	
	MOV WCHDSK,A		;DISK WE WANT TO HACK
	TST SMSSNG		;IS IT A DOUBLE DENSITY CONTROLLER?
	BNE SETSNG		;NO, JUST SET TO SINGLE
	TST LSDEN(A)		;DO WE KNOW THE DENSITY?
	BGE SETDE1		;YUP
	CLR LSDEN(A)		;TRY SINGLE DENSITY
	JSR PC,GETDE1
	BNE SETDE2		;OK, SINGLE DENSITY
	MOV WCHDSK,A
	MOV #SMSDBL!SMS512,LSDEN(A)	;TRY DOUBLE
	JSR PC,GETDE1
SETDE2:	REST <F,A>
	RTS PC

SETDE1:	JSR PC,SETDNH		;SET THE HARDWARE DENSITY
	BR SETDE2

SETSNG:	CLR LSDEN(A)		;SET TO SINGLE
	BR SETDE2

GETDE1:	JSR PC,SETDNH
	MOV #SMSRID,A		;TRY TO READ THE ID
	JSR PC,DCMD
	JSR PC,CMD2
1$:	BIT #SMSXFW,SMSCSR
	BEQ 1$
	TST SMSCSR		;ERROR?
	BLT 2$			;YES, TRY FOR DOUBLE DENSITY
3$:	JSR PC,GETBYT
	JSR PC,GETBYT
	MOV #30.,A
4$:	BIT #SMSXFW,SMSCSR	;READY TO XFR?
	BNE 5$			;YUP
	SOB A,4$		;WAIT
	MOV #1,SMSSNG		;WE HAVE A SINGLE DENSITY CONTROLLER
	BR 6$
5$:	JSR PC,GETBYT
6$:	CLZ
	RTS PC
2$:	JSR PC,GETBYT		;GET THE ERROR BYTE
	SEZ
	RTS PC

GETBYT:	BIT #SMSXFW,SMSCSR
	BEQ GETBYT
	MOV SMSDBF,A
	RTS PC

SETDNH:	MOV #SMSRST!SMSINI,A
	JSR PC,DCMD
	MOV WCHDSK,A
	MOV LSDEN(A),A
	JSR PC,CMD2
1$:	BIT #SMSFDO,SMSCSR
	BNE 1$
	RTS PC
.ENDC ;Z RXDISK
.IFNZ RXDISK
.INSRT MARG;RXDUMP >
.ENDC ;RXDISK
.ENDC ;SMSDSK
