.TITLE MEMORY MAP TESTER
R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
SP=%6
PC=%7

PS=177776

TKS=177560
TKB=177562
TPS=177564
TPB=177566

MAPCSR=0	;CONTROL AND STATUS
 MAPON=200	;THIS BIT TURNS ON THE MAPPING
 MAPLOC=77	;THESE BITS SET THE LOCATION THE MAP WINDOW SEES
		;THAT IS, THE 6 HIGH BITS OF THE VIRTUAL ADDRESS
MAPWIN=2	;ONE WORD WINDOW INTO THE MAP
 MAPWRD=777	;THE 9 LOW ORDER BITS ARE THE HIGH PHYSICAL MEMORY BITS
PARCSR=4	;THE PARITY ERROR CONTROL REGISTER
 PAROK=200	;THIS BIT IS CLEAR IF A PARITY ERROR HAPPENED
 PARINE=100	;ENABLE INTERRUPT ON BAD PARITY
 PARHBD=40	;HIGH ORDER PARITY BIT IS BAD
 PARLBD=20	;LOW ORDER PARITY BAD
 PARERS=1	;PARITY ERROR RESET BIT, WRITE ONLY
PARBLC=6	;PARITY BAD LOCATION: VIRTUAL ADDRESS OF THE FIRST BAD PARITY LOC

;TRAP VECTORS
HLT=3		; "HALT" IS A BREAKPOINT
.=0
	HLT
	HLT
BEBRV:	.+2
	HLT
ILLBRV:	.+2
	HLT
BPTBRV:	BPTTRP
	HLT
IOTBRV:	.+2
	HLT

.=300
	JMP GO

;RANDOM STORAGE
.=600
PDL:
REGLOC:	177600	;THE MAP'S LOCATION
VECLOC:	114	;THE VECTOR LOCATION
MEMTOP:	0	;LAST RESPONDING LOCATION WITH MAP TURNED OFF
TOP5K:	0	;TOP OF MEMORY WITH MAP TURNED ON, IN .5K'S
IBITS:	MAPLOC
	MAPWRD
	PARINE
	0
DIESW:	0	;IF ZERO, DIE DIES
RESID:	0	;IF NON-ZERO THERE IS RESIDENT 4K MEMORY TO WORRY ABOUT
.=1000


GO:	RESET
	MOV #PDL,SP
	CLR DIESW
	MOV #IOTBRV+4,R0
	MOV #60-5,R1	;NUMBER OF TRAP VECTORS TO INIT
	MOV #IOTBRV+6,R2
TRPINT:	MOV R2,(R0)+	;PUT .+2 INTO PC WORD OF TRAP
	MOV #4,(R0)+	;PUT IOT INSTRUCTION IN PS PART
	CMP (R2)+,(R2)+	;ADD 4 TO R2
	DEC R1		;COUNT DOWN
	BNE TRPINT
	CLR BEBRV+2
	MOV #MEMTST,BEBRV	;TO FIND TOP OF MEMORY
	CLR R0
1$:	TST (R0)+
	BR 1$
MEMTST:	CMP (SP)+,(SP)+
	TST -(R0)
	MOV R0,MEMTOP
	MOV #NONEX,BEBRV
	MOV R0,-(SP)
	JSR R5,TYPE	
	.ASCIZ /Last memory location is /
	.EVEN
	JSR PC,OTYPE
	JSR PC,CRLF
	MOV #170000,R0	;FIRST I/O LOCATION
MBFIND:	CLR REGLOC
	CLR VECLOC
	MOV R0,R1	;THE PLACE TO LOOK
	MOV #4,R2	;NUMBER OF REGISTERS TO LOOK FOR
FINDLP:	TST (R1)+	;NON-EX WILL TRAP OUT HERE
	DEC R2
	BNE FINDLP
	MTPS #340
	MOV R0,R1	;LETS TAKE ANOTHER LOOK AT THAT
	CLR R2
	MOV #77,MAPCSR(R1)	;TRY TO SET SOME BITS
	CMP #77,MAPCSR(R1)	;SET?
	BNE 1$			;NOT A GOOD SIGN
	ADD #2,R2		;A VERY GOOD SIGN
1$:	BIS #177400,MAPCSR(R1)	;TRY TO SET HIGH BITS
	BIT #177400,MAPCSR(R1)	;SET?
	BNE 2$			;A BAD SIGN
	INC R2
2$:	CLR MAPCSR(R1)
	MOV #777,MAPWIN(R1)	;TRY TO SET IN MEMORY
	CMP #777,MAPWIN(R1)	;SET?
	BNE 3$			;NOPE
	ADD #2,R2
3$:	BIS #177000,MAPWIN(R1)
	BIT #177000,MAPWIN(R1)
	BNE 4$
	INC R2
4$:	CLR MAPWIN(R1)
	BIT #260,PARCSR(R1)	;ONE OF THESE SHOULD BE SET
	BEQ 5$
	INC R2
5$:	MOV PARBLC(R1),R3	;THERE SHOULD BE A LOCATION HERE
	BNE 6$
	INC R2
	CLR PARBLC(R1)		;IT SHOULDN'T CHANGE
	CMP PARBLC(R1),R3
	BNE 6$
	INC R2
6$:	CMP #6,R2		;OUT OF 8 POSSIBLE POINTS, MUST SCORE 6
	BGT NOTHER	;NOPE, CAN'T BE AN MAP
	MOV #INTCHK,IOTBRV
	MOV BPTBRV,-(SP)
	MOV BPTBRV+2,-(SP)
	MOV #BPTBRV+2,BPTBRV
	MOV #4,BPTBRV+2
	MTPS #0			;MAKE SURE WE CAN INTERUPT
	BIS #PARINE,PARCSR(R0)	;THIS SHOULD CAUSE INTERRUPT IF THERE WERE ANY BAD LOCS
INTHER:	240		;GIVE IT A CHANCE
	240
TOHER:	MOV (SP)+,BPTBRV+2	;IT DIDN'T!
	MOV (SP)+,BPTBRV
	JSR R5,TYPE
	.ASCIZ /No locations with parity errors in low memory, assuming vector 114/
	.EVEN
	JSR PC,CRLF
	MOV #114,R4
	BR GOTIT
NOTHER:	ADD #10,R0	;THIS ISN'T ONE, GO TO NEXT PLACE
	BEQ 1$
	JMP MBFIND	;UNLESS PAST ALL I/O REGSITERS
1$:	JSR R5,TYPE
	.ASCIZ /Can't find a map!/
	.EVEN
	JSR PC,CRLF
	HALT

NONEX:	CMP (SP)+,(SP)+	;GOT A BUS ERROR LOOKING FOR MB11
	BR NOTHER	;SO NONE HERE!

INTCHK:	MOV (SP)+,R4	;SAVE THE PLACE WE TRAPPED TO
	TST (SP)+	;FLUSH PS WE TRAPED WITH
	SUB #4,R4	;GET REAL VECTOR ADDRESS
	MOV (SP),2(SP)	;FLUSH THE PS WITH THE PC
	TST (SP)+
	CMP #INTHER,(SP)	;SEE IF INT CAME FROM THE RIGHT PLACE
	BHI BADINT	;BEFORE INTHER IS A BAD PLACE
	CMP #TOHER,(SP)	;SO IS AFTER TOHER
	BLO BADINT
	TST (SP)+	;FLUSH THE PC
GOTIT:	MOV (SP)+,BPTBRV+2	;IT DIDN'T!
	MOV (SP)+,BPTBRV
	MOV R0,REGLOC	;HERE IS THE MAP
	MOV R4,VECLOC	;AND VECTOR ADDRESS
	JMP TESTIT

BADINT:	JSR R5,TYPE
	.ASCIZ /BAD INTERUPT FROM /
	.EVEN
	JSR PC,OTYPE	;ADDRESS TRAPED FROM IS ON TOP OF STACK	
	JSR R5,TYPE
	.ASCIZ / THROUGH VECTOR /
	.EVEN
	MOV R4,-(SP)	;SAVE BAD VECTOR
	JSR PC,OTYPE
	JSR PC,CRLF
	HLT
	RTS PC		;ATTEMPT TO 

BPTTRP:	JSR R5,TYPE
	.ASCIZ /Breakpoint (halt) trap from /
	.EVEN
	JSR PC,OTYPE
	HALT

DIE:	TST DIESW	;SHOUDL WE DIE?
	BNE 1$		;NOPE
	INC DIESW	;DON'T DIE IF PROCEEDED
	JSR R5,TYPE
	.ASCIZ /Fix that problem then maybe I'll tell you about the rest./
	.EVEN
	JSR PC,CRLF
	HALT
1$:	RTS PC



;TEST ALL THAT WE KNOW ABOUT
TESTIT:	RESET
	MOV #PDL,SP
	MOV REGLOC,R0
	JSR R5,TYPE
	.ASCIZ /Testing map @ /
	.EVEN
	MOV R0,-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / vector /
	.EVEN
	MOV VECLOC,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,VECCLR	;MAKE VECTOR GO AWAY


;TEST SETTING OF INDEPENDENT BITS
	MOV #IBITS,R2
	MOV R0,R1
	MOV #3,R3
	MTPS #340	;PREVENT INTERRUPTS
SLOOP:	JSR PC,SETLOP	;GO TEST IT
	CMP (R2)+,(R1)+	;NEXT BITS AND REGISTER
	DEC R3
	BNE SLOOP	;TRY THAT ONE

;AT THIS POINT WE HAVE TESTED THE LOW LOCATION SELECT BITS
;AND ONE RANDOM LOCATION OF THE MAP MEMORY, AS WELL AS THE DATA PATHS
;TO/FROM SAME. WE HAVE ALSO TESTED THE PARITY INTERRUPT ENABLE
;BIT FOR DATA STORAGE. WE HAVE NOT YET TESTED THE MAPON BIT
;INTERRUPTS ARE STILL TURNED OFF
	BIS #PARINE,PARCSR(R0)	;SET INTERRUPT ENABLE
	RESET			;THIS SHOULD TURN IT OFF
	BIT #PARINE,PARCSR(R0)	;DID IT?
	BEQ 1$
	JSR R5,TYPE
	.ASCIZ /Reset didn't clear the parity error interrupt enable./
	.EVEN
	JSR PC,CRLF
	JSR PC,DIE
1$:	JMP TSTMPM	;GO TEST THE MAP MEMORY

SETLOP:	MOV #1,R4
	MOV (R2),(R1)	;TRY TO SET ALL THE BITS
	MOV (R1),R5	;GET THE RESULT
	COM R5
	BIT (R2),R5	;HAVING COMPLEMENTED, ALL SET BITS SHOULD BE CLEAR
	BEQ SETLO4	;YUP
	JSR R5,TYPE
	.ASCIZ /Bits /
	.EVEN
	MOV (R2),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / don't set in /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,SPACE
	MOV (R1),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,DIE
SETLO4:	CLR (R1)
	JSR PC,SETLO1
SETLO2:	ROL R4		;NEXT BIT
	BNE SETLO1
	RTS PC

SETLO1:	BIT R4,(R2)	;IS THIS AN INDEPENDENTLY SETABLE BIT?
	BEQ SETLO5	;NO, IGNORE
	BIS R4,(R1)	;TRY TO SET IT
	BIT R4,(R1)	;SET?
	BNE SETLO3	;YUP
	JSR R5,TYPE
	.ASCIZ /Can't set /
	.EVEN
	JSR PC,BITTYP
SETLO3:	BIC R4,(R1)	;TRY TO CLEAR IT
	BIT R4,(R1)	;CLEAR?
	BEQ SETLO5	;WIN
	JSR R5,TYPE
	.ASCIZ /Can't clear /
	.EVEN
	JSR PC,BITTYP
SETLO5:	RTS PC


BITTYP:	MOV R4,-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / in /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,DIE
	RTS PC


;TEST THE MAP MEMORY
;FIRST, SEE THAT ALL LOCATIONS ARE INDEPENDANT
TSTMPM:	CLR MAPCSR(R0)	;START AT LOCATION ZERO
	CLR R1
1$:	MOV MAPCSR(R0),MAPWIN(R0)
	INC R1
	INC MAPCSR(R0)	;NEXT LOCATION
	TST MAPCSR(R0)	;ARE WE BACK TO THE START?
	BNE 1$
	CMP #100,R1
	BEQ 2$
	JSR R5,TYPE
	.ASCIZ /Map control status register doesn't count right./
	.EVEN
	JSR PC,CRLF
	JSR PC,DIE
2$:	CMP MAPCSR(R0),MAPWIN(R0)	;ARE THEY THE SAME?
	BEQ 3$				;YUP
	JSR R5,TYPE
	.ASCIZ /Bad map contents. Location: /
	.EVEN
	MOV MAPCSR(R0),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / Contents: /
	.EVEN
	MOV MAPWIN(R0),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,DIE
3$:	INC MAPCSR(R0)
	TST MAPCSR(R0)
	BNE 2$
;NOW, TEST THAT ALL VALUES CAN BE ASSUMED BY ALL LOCATIONS
MEMINC:	CLR MAPCSR(R0)
1$:	CLR R1
2$:	MOV R1,MAPWIN(R0)
	CMP R1,MAPWIN(R0)
	BEQ 3$
	JSR R5,TYPE
	.ASCIZ /Bad map contents: location /
	.EVEN
	MOV MAPCSR(R0),-(SP)
	JSR PC,OTYPE
	JSR R5,OTYPE
	.ASCIZ / should be /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / is /
	.EVEN
	MOV MAPWIN(R0),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,DIE
3$:	INC R1
	CMP #100,R1
	BNE 2$
	INC MAPCSR(R0)
	TST MAPCSR(R0)
	BNE 1$

	JSR R5,TYPE
	.ASCIZ /Done testing map memory for data retention. /
	.EVEN
	JSR PC,CRLF

MAPGO:	CLR R1
	MOV #20000,R2
2$:	MOV (R1)+,(R2)+	;COPY OURSELVES INTO THE NEXT HIGHER 4K OF MEMORY
	CMP #20000,R1
	BNE 2$
;NOW THE PROGRAM IS DUPLICATED EITHER THE 1ST OR 2ND 4K OF THE SGTL MEMORY,
;DEPENDING ON WETHER OR NOT THERE IS RESIDENT MEMORY. HOPEFULLY, DOUBLE
;MEMORY RESPONSE WON'T SCREW US WHEN WE TURN ON THE MAP.
	CLR MAPCSR(R0)	;START AT ZERO
	MOV #10,R1	;8 .5K PAGES=4K
1$:	MOV MAPCSR(R0),MAPWIN(R0)
	INC MAPCSR(R0)
	DEC R1
	BNE 1$
	MOV #70,R1	;THE REMAINDER OF THE MAP
3$:	MOV #777,MAPWIN(R0)	;HAD BETTER BE NON-EXISTANT
	INC MAPCSR(R0)
	DEC R1
	BNE 3$
	JSR R5,TYPE
	.ASCIZ /Turning on the map!/
	.EVEN
	JSR PC,CRLF
	MOV #-1,R1
	CLR 37776		;THIS WILL STAY ZERO UNLESS WE HAVE DUAL ADDRESSING
	MOV #MAPON,MAPCSR(R0)
	MOV R1,17776		;SET THE FLAG
	CLR MAPCSR(R0)		;DON'T WANT TO RUN LONG IN POTENTIAL DUAL-ADDRESSING
	MOV 37776,RESID		;DUAL OR NOT?
	BEQ NORES
	JSR R5,TYPE
	.ASCIZ /Made it back alive, there is resident memory./
	.EVEN
	JSR PC,CRLF
	MOV #7,R1
4$:	MOV R1,MAPCSR(R0)
	MOV #777,MAPWIN(R0)	;NEVER DARKEN MY DOOR AGAIN!
	DEC R1
	BGE 4$
;NOW THE BOTTOM 4K IS PERMANENTLY MAPPED OUT
	BR TSTMEM
NORES:	JSR R5,TYPE
	.ASCIZ /Made it back alive, no resident memory./
	.EVEN
	JSR PC,CRLF
;NOW THE BOTTOM 4K IS PERMANENTLY MAPPED IN
	BR TSTMEM

;HERE WE NEVER TOUCH THE BOTTOM 8 MAP LOCATIONS, THEY HAVE BEEN SET UP ALREADY
TSTMEM:	BIS #MAPON,MAPCSR(R0)	;TURN IT ON AGAIN
	RESET			;THIS SHOULD TURN IT OFF
	BIT #MAPON,MAPCSR(R0)	;ON OR OFF?
	BEQ 1$			;OK
	JSR R5,TYPE
	.ASCIZ /Reset doesn't turn off the map./
	.EVEN
	JSR PC,CRLF
	JSR PC,DIE
1$:	MOV BEBRV,-(SP)
	MOV #MAPON!10,MAPCSR(R0)	;TURN ON MAP, AIM AT PAGE 8
	MOV #10,MAPWIN(R0)		;ASSUME THE BOTTOM 4K IS WORKING
	MOV #20000,R2		;POINTER TO BOTTOM OF SELECTED PAGE
TSTLOP:	MOV #1,R3
1$:	MOV #ENDMEM,BEBRV	;IN CASE WE HIT THE END OF MEMORY
	MOV R3,(R2)		;SET ONE BIT
	MOV (SP),BEBRV		;SAFE NOW
	CMP R3,(R2)		;IS IT OK?
	BEQ 3$			;YUP
	JSR R5,TYPE
	.ASCIZ /Bad memory location found. .5K location: /
	.EVEN
	MOV MAPWIN(R0),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ ! / !
	.EVEN
	MOV (R2),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / should be: /
	.EVEN
	MOV R3,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,DIE
2$:	TST R3
	BEQ 3$
	ASL R3
	BR 1$
3$:	MOV #20000,R3
	MOV MAPWIN(R0),R4
4$:	MOV R4,(R3)+
	INC R4
	CMP #22000,R3	;FILLED .5K WORDS?
	BNE 4$
	INC MAPWIN(R0)
	JMP TSTLOP	
	
ENDMEM:	CMP (SP)+,(SP)+		;FLUSH TRAP INFO
	MOV (SP)+,BEBRV		;RESTORE BUSS ERROR TRAP
	MOV MAPWIN(R0),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / .5K blocks of memory exist./
	.EVEN
	JSR PC,CRLF
	MOV MAPWIN(R0),TOP5K

;NOW LOOK BACK AT WHAT WE LEFT BEHIND
	MOV #10,MAPWIN(R0)
1$:	MOV MAPWIN(R0),R4
	MOV #20000,R3
2$:	CMP R4,(R3)+
	BEQ 3$
	JSR R5,TYPE
	.ASCIZ /Bad memory location at .5K loc /
	.EVEN
	MOV MAPWIN(R0),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / loc in page /
	.EVEN
	MOV R3,-(SP)
	SUB #20002,(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR R5,TYPE
	.ASCIZ !Contents: !
	.EVEN
	MOV -2(R3),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / should be /
	.EVEN
	MOV R4,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,DIE	
3$:	INC MAPWIN(R0)
	CMP MAPWIN(R0),TOP5K
	BNE 1$

PARTST:	BIT #200,PARCSR(R0)	;PARITY ERROR
	BEQ 1$			;OK, I HAVE GOT A PARITY ERROR
	JSR R5,TYPE
	.ASCIZ /Either all of memory has no parity errors or parity errors aren't working./
	.EVEN
	JSR PC,CRLF
	JMP NOPAR
1$:	MTPS #0			;MAKE SURE INTERRUPTS ARE ON
	MOV @VECLOC,-(SP)
	MOV #PARINT,@VECLOC	;SET UP VECTOR
	BIS #PARINE,PARCSR(R0)	;SET ENABLE
	240
	JSR R5,TYPE
	.ASCIZ /Parity error interrupts don't work./
	.EVEN
	JSR PC,CRLF
	JSR PC,DIE
	HALT
	BR .-2

PARINT:	CMP (SP)+,(SP)+
	MTPS #0
	MOV PARBLC(R0),R3
	COM R3
	BIT #170000,R3		;SHOULD ALL BE ZERO
	BEQ 4$
	COM R3
	JSR R5,TYPE
	.ASCIZ /The contents of the bad location register look bad: /
	.EVEN
	MOV R3,-(SP)
	JSR PC,OTYPE
4$:	BIS #PARERS,PARCSR(R0)	;TRY TO RESET ERROR
	BIT #200,PARCSR(R0)
	BNE 1$
	JSR R5,TYPE
	.ASCIZ /Either the memory I am running in has parity errors, or error reset doesn't work./
	.EVEN
	JSR PC,CRLF
	JSR PC,DIE
1$:	MOV R0,R4
	ADD #PARBLC,R4		;COMPUTE ADDRESS OF PARITY BAD REGISTER
	MOV (R4),R3
	CMP R3,R4		;SINCE NO PARITY ERROR, SHOULD MATCH
	BEQ 2$			;YUP
	JSR PC,TYPE
	.ASCIZ /The contents of the bad location register are wrong. /
	.EVEN
	MOV R3,-(SP)
	JSR PC,OTYPE
	JSR PC,TYPE
	.ASCIZ / should be /
	.EVEN
	MOV R4,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,DIE
2$:
NOPAR:

;THINGS LEFT TO TEST:
;	VIRTUAL SPACE OTHER THAN 4 TO 4.5K
;	PARITY ERROR LOCATION REGISTER
;	RESETABLITY OF PARITY ERROR
;	HIGH/LOW PARITY ERRORS (DONE WITH PARITY CHIPS OUT!)
TSTDNE:	JSR R5,TYPE
	.ASCIZ /Well, all that memory and mapping stuff seems to work./
	.even
	JSR PC,CRLF
	JSR R5,TYPE
	.ASCIZ /I should check the parity bits too, but what do you expect from a poor stupid program?/
	.EVEN
	JSR PC,CRLF
	JSR PC,VECCLR
	HALT

VECCLR:	MOV R1,-(SP)
	MOV R2,-(SP)
	MOV VECLOC,R1		;GET VECTOR ADDRESS OF THIS ONE
	MOV R1,R2
	TST (R2)+
	MOV R2,(R1)+
	MOV #4,(R1)		;CATCH INTERUPTS WE DON'T EXPECT
	MOV (SP)+,R2
	MOV (SP)+,R1
	RTS PC


TYPE:	MOV R4,-(SP)	;SAVE R4
TYPE1:	MOVB (R5)+,R4	;GET A CHAR
	BEQ TYPE2	;ZERO IS END
	JSR PC,TYO	;TYPE IT
	BR TYPE1
TYPE2:	MOV (SP)+,R4
	INC R5
	BIC #1,R5	;MAKE IT EVEN
	RTS R5

CRLF:	MOV R4,-(SP)	;SAVE R4
	MOV #15,R4	;CR
	JSR PC,TYO
	MOV #12,R4	;LF
	JSR PC,TYO
	CLR R4		;NULL
	JSR PC,TYO
	JSR PC,TYO
CRLF1:	JSR PC,TYO
	MOV (SP)+,R4
	RTS PC

SPACE:	MOV R4,-(SP)
	MOV #40,R4
	BR CRLF1

OTYPE:	MOV R4,-(SP)	;SAVE R4
	MOV R3,-(SP)	;AND R3
	MOV R2,-(SP)	;AND R2
	MOV 10(SP),R3	;GET NUMBER TO TYPE OUT
	MOV #6,R2
	ROL R3
	ROL R3
	MOV R3,R4
	ROR R3
	BIC #177776,R4
	BR OTYPE2

OTYPE1:	ROL R3		;ROTATE 4 BITS
	ROL R3
	ROL R3
	ROL R3
	MOV R3,R4	;COPY THING TO TYPE OUT
	ROR R3		;RECOVER BIT FROM CARRY
	BIC #177770,R4	;FLUSH EXTRA BITS
OTYPE2:	ADD #60,R4	;MAKE IT ASCII
	JSR PC,TYO
	DEC R2
	BNE OTYPE1
	MOV (SP)+,R2	;RESTORE R2
	MOV (SP)+,R3	;AND R3
	MOV 2(SP),R4	;GET RETURN ADDRESS
	MOV (SP),4(SP)	;MOVE SAVED VALUE OF R4 OVER NUMBER TO TYPE OUT
	CMP (SP)+,(SP)+	;FLUSH ONE COPY OF R4 AND RETURN ADDRESS
	RTS R4

TYO:	TSTB TPS
	BPL TYO
	MOVB R4,TPB
	RTS PC
.IIF GT .-20000, .ERROR BARF THIS CAN'T BE LONGER THAN 4K!!!

.END GO
