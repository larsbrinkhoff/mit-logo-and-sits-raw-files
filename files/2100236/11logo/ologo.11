	.TITLE PDP11 LOGO
	.ABS
	%COMPAT==0
	VERN==%FNAM2
	FOO==VERNF
	FOO==ASWFOO
	.STITL CONFIGURATION PARAMETERS
.IF1
DRIBF==0
SITSD==1
LPF==0
SWAPF==1
NINT==0
SYSP==1
DPHK==0
NTUR==2
WADESW==1
CJR==0
HALFLG==0
JRDF==0
NTVS=0
NTVCHN==0
;	.PRINT /TVS=/
;.TTYMAC FLAG
;.IFNZ FLAG
;NTVS==4
;NTVCHN==8.
;.ENDC
;.ENDM

	.PRINT /0=>REGULAR 1=> GUY 2=>QUERY 3=> NO DISK CHECKING 4=> GUY+SITSD
ASSSW=/
	.TTYMAC FLAG
	ASSSW==FLAG
	.ENDM
ASWFOO==ASSSW
NATG==0
DSKCHK==1
RAF==0
.IFZ ASSSW-4
ASSSW==1
.ENDC
.IFZ ASSSW-3
	DSKCHK==0
	ASSSW==0
.ENDC
	NPLOT==1
	MVONLY==0
	FXONLY==0
TM==1
	DHON==1
	DDF==1
	FPPF==1

GUY==0
AI==0
	.IFZ ASSSW
	DRIBF==0
	MVONLY==1
	LPF==1
	ENG==1
	FR==0
	AI==1
	MNUSRS==15+NTVS
	MNSLTS==6
	.ENDC

	.IFZ ASSSW-1
	ENG==1
	FR==1
	LPF==1
	MVONLY==1
	GUY==1
	NTUR==2
	MNUSRS==13
	MNSLTS==4
	.ENDC

	.IFZ ASSSW-2
		.MACR SETFLG FLG
		.PRINT /FLG=/
		.TTYMAC FLAG
		FLG==FLAG
		.ENDM
		.ENDM
	
		SETFLG DEBUG
		SETFLG MVONLY
		SETFLG MNUSRS
		SETFLG MNSLTS
		SETFLG FPPF
		SETFLG DDF
		SETFLG FR
		SETFLG ENG
		SETFLG NPLOT
	.ENDC

.ENDC

	.MACR FOR FLG
	.XLIST
	.IFNZ FLG
	.LIST
	.ENDM

	.MACR ENDC FLG
	.IFZ FLG
	.LIST
	.ENDC
	.ENDM
	.STITL SYSTEM PARAMETERS
.INSRT 11LOGO;ERRORS SYMS

A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
U=%5
P=%6
SP=%6
PC=%7

FA==%0
FB==%1
FC==%2
FD==%3
FE==%4
FF==%5

EOFCHR==3

ERROR==TRAP

SKPRET==EMT

.BUG.==ERROR+BUG

.XCREF FOO,A,B,C,D,E,F,U,P,SP,PC,S
.XCREF OBADD1,OBADD2,OBSTRT,OBX0,OBX1,OBX2
.XCREF ERMNO,NNUMF
.XCREF TEXT,SPOP,SPUSH,POP,PUSH,OLE,BEGER,ERMM
.XCREF Z,ZED,ZPLUS,ZEPT
	.STITL MACROS

	.MACR PUSH AA
	MOV AA,-(P)
	JSR PC,PPUSHT
	.ENDM

	.MACR POP AA
	MOV (P)+,AA
	JSR PC,PPOPT
	.ENDM

	.MACR PUSHS AA
	JSR PC,SPUSHT
	MOV AA,@S
	.ENDM

	.MACR POPS AA
	MOV @S,AA
	JSR PC,SPOPT
	.ENDM

	.MACR SPUSH AA
	MOV AA,-(P)
	.ENDM

	.MACR SPOP AA
	MOV (P)+,AA
	.ENDM

	.MACR SPUSHS AA
	SUB #2,S
	MOV AA,@S
	.ENDM

	.MACR SPOPS AA
	MOV @S,AA
	ADD #2,S
	.ENDM

.MACR	TEXT AA
	.ASCII ÁA‰;DON'T TRY TO INCLUDE RUBOUTS IN TEXT
	.BYTE 0		;('CAUSE DELIMITERS ARE RUBOUTS)
	.EVEN
.ENDM

.MACR	.PRTXT AA
	JSR A,ERTAS
	AA
.ENDM

.MACR	PRTXT AA
	.PRTXT ^ÔEXT ^&AA&‰;RUBOUTS AROUND .PRTXT ARG
.ENDM

.MACR	CPRTXT	AA
	.PRTXT ^®BYTE	15
	TEXT ^&AA&‰;RUBOUTS!
.ENDM

.MACR	BPRTXT X
	.PRTXT ^®BYTE	7,7,15
	TEXT	^&X&‰;RUBOUTS!
.ENDM

.MACR	PRTXTC	AA
	.PRTXT ^®ASCII	&AA&
	.BYTE	15,0
	.EVEN‰	;RUBOUTS!
.ENDM

.MACR PAD A,B
	.PRINT &A B
&
.ENDM

.MACR PRCR
	JSR PC,.CRLF
.ENDM

.MACR SPACE
	JSR PC,.SPACE
.ENDM

.MACR SPREND
	JSR A,SPEND
.ENDM
LGNSYM==0
.MACRO LANGC EN,F
.IFNZ <ENG&FR>
	BIT #PFRFLG,LANG
	CONS BNE ,LS,\LGNSYM
.ENDC
.IF NZ ENG
EN
.ENDC
.IF NZ <FR&ENG>
CONS BR ,LS,\LGNSYM+1
CONS LS,\LGNSYM,::
.ENDC
.IF NZ FR
F
.ENDC
.IF NZ <FR&ENG>
CONS LS,\LGNSYM+1,::
LGNSYM==LGNSYM+2
.ENDC
.ENDM

.MACR REPT1 A,B
	.REPT A
	B
	.ENDR
.ENDM

.MACR REPT2 A,B,C
	.REPT A
	B
	C
	.ENDR
.ENDM

.MACR SDPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
.ENDC
.ENDM

.MACR SDPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
.ENDC
.ENDM

.MACR VERR
.IFLE .-.VERR-127.
	BVS	.VERR
.ENDC
.IFG .-.VERR-127.
	BVC	.+4
	.VERR==.
	ERROR+RTB
.ENDC
.ENDM

.MACR DPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPCLR HIGH,LOW
	CLR	HIGH
	CLR	LOW
.ENDM

.MACR DPINC HIGH,LOW
	DPADD ,#1,HIGH,LOW
.ENDM

.MACR DPDEC HIGH,LOW
	DPSUB ,#1,HIGH,LOW
.ENDM

.MACR DPNEG HIGH,LOW
	NEG LOW
	ADC HIGH
	NEG HIGH
.ENDM

.MACR NOP NUM
	.IFG NUM
	BR .+<NUM*2>
	NOP <NUM-1>
	.ENDC
.ENDM

.MACR EXCH LOC1,LOC2
	MOV	LOC1,EXCH1
	MOV	LOC2,LOC1
	MOV	EXCH1,LOC2
.ENDM

.MACR	ZED
	Z==0
.ENDM

.MACR	ZPLUS
	Z==Z+1
.ENDM

.MACR	ZEPT A,B
	ZED
	.REPT	A
	B
	ZPLUS
	.ENDR
.ENDM

.MACR	CONS	A,B,C
	A'B'C
.ENDM

.MACR CONC6 A,B,C,D,E,F
	A'B'C'D'E'F
.ENDM

.MACR	DINFO DEV,NUM,DTLST
	CONS N,DEV,<==NUM>
	TY==0
	TB==0
	SPC==0
	ZED
	.IRP	A,DTLST
	CONC6	DEV,\Z,<DT==>,A
	ZPLUS
		.IFZ	<A-TYDT>*<A-MODT>
		TY==TY+1
		.ENDC
		.IFZ	<A-TBDT>*<A-TBMDT>
		TB==TB+1
		.ENDC
		.IFZ	A-SPDT
		SPC==SPC+1
		.ENDC
	.ENDM
	CONS N,DEV,TY==TY
	CONS N,DEV,TB==TB
	CONS N,DEV,SPEC==SPC
.ENDM

.MACR	TBINFO NUM,DEV,LDLST
	CONS DEV,TBN==NFTBOX+<2*NUM>
	CONC6 TB,NUM,SND=,DEV,SND
	CONC6 TB,NUM,TB==,DEV,TB
	ZED
	.IRP	A,LDLST
		CONC6 A,SND=TB,NUM,SND
		CONS A,<TBN==DEV>,TBN
	ZPLUS
	.ENDM
	.MACR TB'NUM'LTB
		.IRP A,LDLST
		A
		.ENDM
	.ENDM
	CONS NTB,NUM,LD==Z
.ENDM

TYDT==1	;TTY
TBDT==2	;THORTON BOX
SPDT==3	;SPECIAL
MODT==4	;TTY MODEM
TBMDT==5	;THORTON BOX MODEM
.STITL	DEVICE CONFIGURATION

.IFNZ	AI		;AI DEVICES
	NDISP==4	;CHECK DLENGT IN SYS VARS IF THIS IS CHANGED
.IFF
	NDISP==0
.IFTF
	CLKFRQ==60.
	NTBOX==1
	NMBX==1
	NTY==1
	DINFO	DC,2,<<TBDT,MODT>>
		.MACR DCITB
		.WORD 111,113,100,103
		.ENDM
	DINFO	KL,0
	NDM==1
		NDMTY==MNUSRS-1
		NDMTB==0
		NDMSP==0
	DINFO	DP,0,
	DINFO	DN,0,
.IFT
	TBINFO	0,DC0,<<MB0,TU0,TU1,PL0>>
.IFF
	TBINFO 0,DC0,<<MB0,TU0,TU1,TU2>>
.ENDC

	NLDEV==NTUR+NMBX+NPLOT
	ZEPT NTUR,<
	CONS TU,\Z,==NFTUR+<2*Z>
>
	ZEPT NMBX,<
	CONS MB,\Z,==NFMBX+<2*Z>
>
	ZEPT NPLOT,<
	CONS PL,\Z,==NFPLOT+<2*Z>
>

	NFTY==0
	NFDCTY==2*NTY
	NFKLTY==2*<NTY+NDCTY>
	NFDPTY==2*<NTY+NKLTY+NDCTY>
	NFDMTY==2*<NTY+NKLTY+NDCTY+NDPTY>
	NFTV==2*<NTY+NKLTY+NDCTY+NDPTY+NDMTY>
	NTTY==NTY+NKLTY+NDCTY+NDPTY+NDMTY+NTVS
	NFTBOX==2*NTTY
	NFTUR==2*<NTTY+NTBOX>
	NFLDEV==NFTUR
	NFMBX==2*<NTTY+NTBOX+NTUR>
	NFPLOT==2*<NTTY+NTBOX+NTUR+NMBX>
	NTYDV==NTTY+NTBOX+NLDEV

	NPTBOX==2	;NUMBER OF PRIVATE TBOX
	MBDN==NFMBX	;NGKLUGE

;CONSOLE SWITCHES
SWB=177570	;CONSOLE SWITCH DATA
;CONSOLE TELETYPE
;BREAK LEVEL 4
TKBRV=60	;CONSOLE KEYBOARD BREAK VECTOR
TKS=177560	;CONSOLE KEYBOARD STATUS
TKB=177562	;CONSOLE KEYBOARD DATA
TPBRV=64	;CONSOLE PRINTER BREAK VECTOR
TPS=177564	;CONSOLE PRINTER STATUS
TPB=177566	;CONSOLE PRINTER DATA
;PROGRAMMABLE CLOCK
;BREAK LEVEL 6
PCBRV=104	;PROGRAMMABLE CLOCK BREAK VECTOR
PCS=172540	;PROGRAMMABLE CLOCK STATUS
PCSTBF=172542	;PROGRAMMABLE CLOCK SET BUFFER
PCCNT=172544	;PROGRAMMABLE CLOCK COUNTER
;RK05 DISK
;BREAK LEVEL 5
RKBRV=220
RKDS=177400
RKER=177402
RKCS=177404
RKWC=177406
RKBA=177410
RKDA=177412
;RF11/RS11 DISK
;BREAK LEVEL 5
DSKBRV=204	;DISK BREAK VECTOR
.IIF Z MVONLY, DSKS=177460	;DISK STATUS REGISTER
.IIF NZ MVONLY, DSKS=RKCS
DSKDBR=177472	;DISK DATA REGISTER
DSKWC=177462	;DISK WORD COUNT
DSKCA=177464	;DISK CURRENT ADDRESS
DSKA=177466	;DISK ADDRESS
DSKAE=177470	;DISK EXTENDED ADDRESS
;PAPER TAPE PUNCH
;BREAK LEVEL 4
PPBRV=74
PPB=177556
PPS=177554
;PAPER TAPE READER
;BREAK LEVEL 4
PRBRV=70
PRB=177552
PRS=177550
.IFNZ AI
;DR11 INTERFACE
;BREAK LEVEL 5
DRBRV=110	;INTERUPT A
DRBRVB=114	;INTERUPT B
DRS=177520
DROB=177522
DRIB=177524
;RJL A/D KLUDGE
ATODB=160104
DIGO=160102
DIGI=160100
.ENDC
;LINE CLOCK
;BREAK LEVEL 6
LKBRV=100
LKS=177546
;TK DISPLAY
NGCSR=164040	;DISPLAY CONTROL AND STATUS REGISTER
NGREL=164042	;DISPLAY RELOCATION REGISTER
;PARITY OPTION
PARCSR=172100	;FIRST STATUS REGISTER
PARBRV=114

;POWER FAIL
PFBRV=24
;BUS ERRORS
BEBRV=4
BPT=3
;TRAPS
TRPBRV=34
EMTBRV=30
IOTBRV=20
BPTBRV=14
PWFBRV=24

SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
KIAR=172340
KIDR=172300
KDAR=172360
KDDR=172320

;PROCESSOR STATUS
PS=177776

;LINE PRINTER
LPBRV==200
LPCSR==177514
LPDBAR==177506
TVINCR=164140	;THE INCREMENT REGISTER FOR THE TV'S
TVINC==77	;THE MASK FOR THE INCREMENT
TVRSET==100000	;THE RESET BIT
TVCLRW==400	;THE COLOR WRITE BIT

TVSEL=164142	;THE CONSOLE SELECT REGISTER
TVRCNS==77	;THE CONSOLE NUMBER MASK
TVRWMD==300	;THE REGULAR WRITE MODE MASK
TVNSH==0	;NO SHIFT WRITE MODE
TVIOR==100	;THE INCLUSIVE OR MODE
TVXOR==200	;THE XOR MODE
TVMOV==300	;THE MOVE FUNCTION
TVDCNS==TVRCNS*400	;THE DISK CONSOLE NUMBER (SAME, BUT IN TOP BYTE)
TVDWMD==TVRWMD*400	;THE DISK WRITE MODE MASK

TVRADR=164144	;THE REGULAR ADDRESS REGISTER

TVWC=164146	;THE WORD COUNT FOR THE BLOCK WRITE

TVDADR=164150	;THE DISK TRANSFER ADDRESS REGISTER

TVSHR=164152	;THE SHIFT REGISTER
TVSHCN==17	;THE SHIFT COUNT
TVMAP==17400	;THE START OF THE 16K PAGE (IN 4K BLOCKS)
TVAMAP==20000	;THE ACTIVATE TVMAP BIT

TVMSK=164154	;THE MASK REGISTER

TVDWIN=164156	;THE WINDOW FOR DISK TRANSFERS

TVRWIN=164160	;THE WINDOW FOR REGULAR TRANSFERS

TVCNSL=164162	;THE CONSOLE REGISTER FOR THE MEMORY
TVCLR==160000	;THE COLOR NUMBER

LKBB==164100	;LEBEL KEYBOARD INTERFACE

VIDSW=164104	;VIDEO SWITCH
TVDOIT==11
	.STITL ALLOCATION PARAMETERS

SYPDLL==240
DSECLN==400
PPDLL==1000
SPDLL==1000
PDSLOP==140
PDSWOP==374
MAXARG==32.
.IF1
.IFG MAXARG-<SPDLL-PDSWOP>/4
.ERROR \CHANGE MAXARG OR SPDLL SIZE
\
.ENDC
.ENDC
DBUFL==2000
	.IIF NZ AI, FDSCSZ==20
	.IIF NZ GUY, FDSCSZ==40
	.IIF NZ MVONLY, FDSCSZ==400
	FDSCMS==FDSCSZ-1	;SECTOR MASK

DTIBFL==2000
DEDBFL==2000

DWRTEC==103
DREADC==105
DWRTCC==107

FRTRCF==1
SWTRCF==2
SPTRCF==4
GCTRCF==10

FRBKBT==200	;200 BIT MEANS NEVER RUN
FRSCED==1	;FLUSHED DUE TO SCHEDULEING
FRDSKW==3	;HANGING ON DISK
FRTYIW==4	;HANGING ON TYI OF CHAR
FRTYOW==5	;HANGING ON FULL TYO BUFFER
FRRAND==6	;HANGING FOR "UNKNOWN" REASON
FRNEWU==7	;HANGING BECAUSE HAVE NOT YET BEEN INITIALIZED
FRTYIH==210	;HANGING ON LINE INPUT
FRLINW==FRTYIH
FREDW==11	;HANGING ON EDIT TYO
FRTURW==12	;HARE (SEE AESOP)
FRTYIC==13	;HANGING ON INIT TYI OF CHAR
.IIF NZ NINT,	FRNIU==211	;HANGING ON NON-INITIALIZED USER
	;NODE TYPES
SFUN==000000
INFIX==10000
UFUN==20000
UVAR==30000
IDLE==40000
BUKTEL==60000	;NODE IN BUCKET OF OBLIST (INVALID TOKEN TYPE)
;THE FOLLOWING TYPES ARE NEEDED IN THIS ORDER BY THE CONVERT ROUTINES
SSTR==70000	;NOT VALID TOKEN TYPE
SNP==100000
ATOM==110000
SNUM==120000	;NOT A VALID TOKEN TYPE
LNUM==130000
INUM==LNUM	;INTEGER NUMBER
LSTR==140000
FNUM==150000
LIST==170000
SENT==LIST
;END OF ORDER

	;BINDING TYPES
FBIND==20000
VBIND==30000
;DON'T USE 40000, IT IS "IDLE" (UGH)
ABIND==50000
SVBIND==130000	;SWAPPED OUT  VARIABLE BINDING


	;SOE FLAGS SEE OLE MACRO STUFF
VNAF==2000

	;READ FLAGS SEE DTBL:
DOTF==400	;IN LEFT HALF
	;EVAL FLAGS - PUSHED BY PEVAL
PTLPF==1	;PREVIOUS TOKEN WAS LEFT PAREN
RTF==2	;REPEAT TOKEN
CRF==4	;CURRENT TOKEN IS CR
EDITF==10	;EDIT FLAG
DORF==20	;SET IF THIS FRAME IS A DO OR A READ
;	TOF==20	;TO FLAG
;	IFF==40	;IF FLAG
TSTFLG==100	;TEST FLAG FOR TEST, IFTRUE AND IFFALSE
SPDF==200	;SKIP PROC DEF. FLAG
TPTF==400	;THIS PROCEDURE TRACED FLAG	;MUST BE IN LEFT HALF
EDTIF==1000	;EDIT TITLE FLAG
BRKF==2000	;BREAK MODE FLAG
ERRF==4000	;ERROR FLAG
EDTIF2==10000	;BECOMES EDTIF ON LEAVING EVAL
TPSF==20000	;THIS PROCEDURE STEPPED FLAG	;MUST BE IN LEFT HALF
TPBF==40000	;THIS PROCEDURE BURIED FLAG	; "   "  "   "    "
EVIFS==PTLPF+RTF+CRF	;FLAGS CLEARED BY EVLINE

	;EVAL FLAGS2 - NOT PUSHED
CPTBF==1	;CHANGE % TO BLANK
TRACEF==2
PQF==4		;PRINT QUOTE FLAG - FOR PRSTR
DPQF==10	;DONT " " "
MMF==20	;MULTIPLE MAKE FLAG
SSF==40	;SPECIAL STATUS FLAG
PADERF==100	;PRINT ADDRESS OF ERROR
MGCF==200	;MANY G. C.'S FLAG
PNNLF==400	;PRINT NO. NODES LEFT
DSAMFL==1000	;DISK ALMOST FULL
PPNAIF==2000	;P PDL NOT ALL THE WAY IN
SPNAIF==4000	;S PDL NOT ALL THE WAY IN
HERRF==10000	;HARD ERROR
CHEKUF==20000	;TURNS ON VARIOUS USER CHECKING THINGS
DRIBBF==40000	;DRIBBLE OUTPUT
	;TEMP FLAGS IN TFLAGS
TF6==1
RBRKF==2	;BREAK FLAG - FOR ROUTINE THAT CALLS RDSTR
TF7==4
TF1==100	
TF2==200
TF3==400
TF4==10000
TF5==20000

	;FLAGS IN LEFT HALF OF 1ST NODE OF SWAPPED PROC LIST
; TPTF==400	DEFINED ABOVE- SET BY "TRACE FOO" CLEARED BY "ERASE TRACE FOO"
; TPSF==20000	DEFINED ABOVE- SET BY "STEP FOO" CLEARED BY "ERASE STEP FOO"
; TPBF==40000	DEFINED ABOVE- SET BY "BURY FOO" CLEARED BY "ERASE BURY FOO"

NBN==40	;# BUFFER NODES - IF FREE NODES < THIS, == NO STG LEFT


	.IFNZ NDISP
;DISPLAY COMMANDS
ADDX==150000
ADDY==144000
ADDXY==ADDX!ADDY
DPUSHJ==100000
DPOP==140200
DPOPJ==140100
DSTOP==140400
DRSTXY==143000	;RESET X AND Y TO 0
DINC==40000

TURSIZ==6	;THE SIZE OF THE TURTLE

TKRUN==4000
TKGO==10000
TKSTOP==20000
.ENDC


;FLAGS USED FOR DFLAGS
PENUF==1
HIDETF==4
TURTF==10
TEMF==20
DISPF==40
WRAPF==100
PLOTF==200
.STITL TRAP VECTORS


;TRAP VECTORS
;UNUSED VECTORS
.=0
	BPT	;DIE ON JUMP TO ZERO
GUNU==.
	-1	;USER TO GUN DOWN

	REPT2 77,.+2,IOT	;GO TO 2ND WORD OF VECTOR AND DIE

	.=BEBRV
	BEBRK
	340

	.=TRPBRV
	ERRBK	;TRAP IS USED FOR ERRORS
	0

	.=TKBRV
	TKBRK	;CONSOLE TTY KEYBOARD
	200	;IS ON BR4

	.=TPBRV
	TPBRK	;CONSOLE TTY PRINTER
	200	;IS ON BR4

	.=LKBRV
	CLKBRK
	300

	.=PCBRV
	CLKBRK	;PROGRAMMABLE CLOCK
	300	;IS ON BR6

	.=DSKBRV
	DSKBRK	;FIXED HEAD DISK
	300	;IS ON BR5, INT ROUTINE RUNS ON LEVEL 6

	.=RKBRV
	RKBRK
	300

	.=IOTBRV
	IOTBRK
	340

	.=EMTBRV
	EMTBK
	340

	.=PRBRV
	PRBRK
	200

	.=PPBRV
	PPBRK
	200

	.=PFBRV
	PWRDWB
	340

	.=40
	LOGON
LVERNF:	VERNF
TIME:	0
	0

	.=PARBRV
	PARBRK
	340

.IFNZ LPF
	.=LPBRV
	LPBRK
	240
.ENDC
	.STITL	FLOATING TRAP VECTORS & DEVICE INFO

	.=300	;START OF FLOATING VECTORS
;DC11 (BR5)
ZEPT	NDC,<
	CONS DC,\Z,<RS=174000+<Z*10>>	;RCV STATUS REG
	CONS DC,\Z,<RB=174002+<Z*10>>	;RCV BUFFER
	CONS DC,\Z,<TS=174004+<Z*10>>	;TRANSMIT STATUS
	CONS DC,\Z,<TB=174006+<Z*10>>	;TRANS BUF

	CONS DC,\Z,RV=.	;RCV VECTOR
	CONS DC,\Z,TV=.+4	;TRANS VECTOR
	CONS DC,\Z,RK
	240
	CONS DC,\Z,TK
	240
>
;KL11  (BR4)
ZEPT	NKL,<
	CONS KL,\Z,<RS=176500+<Z*10>>	;RCV STATUS REG
	CONS KL,\Z,<RB=176502+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TS=176504+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TB=176506+<Z*10>>	;TRANS BUF

	CONS KL,\Z,RV=.	;RCV VECTOR
	CONS KL,\Z,TV=.+4	;TRANS VECTOR
	CONS KL,\Z,RK
	200
	CONS KL,\Z,TK
	200
>
;DP11  (BR5)
ZEPT	NDP,<
	CONS DP,\Z,<RS=174770-<Z*10>>	;RCV STATUS REG
	CONS DP,\Z,<RB=174772-<Z*10>>	;RCV BUFFER
	CONS DP,\Z,<SR=174773-<Z*10>>	;SYNCH REGISTER
	CONS DP,\Z,<TS=174774-<Z*10>>	;TRANSMIT STATUS
	CONS DP,\Z,<TB=174776-<Z*10>>	;TRANS BUF
	CONS DP,\Z,<ESR=174777-<Z*10>>	;EXTENDED SYNCH REGISTER

	CONS DP,\Z,RV=.	;RCV VECTOR
	CONS DP,\Z,TV=.+4	;TRANS VECTOR
	CONS DP,\Z,RK
	240
	CONS DP,\Z,TK
	240
>
.IFZ DHON
;DM11 (BR5)
ZEPT	NDM,<
	CONS DM,\Z,<CSR=175000+<Z*10>>	;CONTROL STATUS REG
	CONS DM,\Z,<BAR=175002+<Z*10>>	;BUFFER ACTIVE REGISTER
	CONS DM,\Z,<BCR=175004+<Z*10>>	;BREAK CONTROL REGISTER
	CONS DM,\Z,<TBR=175006+<Z*10>>	;TABLE BASE REGISTER

	CONS DM,\Z,RV=.	;RCV VECTOR
	CONS DM,\Z,TV=.+4	;TRANS VECTOR
	CONS DM,\Z,RK
	240
	CONS DM,\Z,TK
	240
>
.IFF
;DH11 (BR5)
ZEPT	NDM,<
	CONS DH,\Z,<SCR=160020+<Z*20>>	;SYSTEM CONTROL REGISTER
	CONS DH,\Z,<NRC=160022+<Z*20>>	;NEXT RECIEVED CHARACTER
	CONS DH,\Z,<LPR=160024+<Z*20>>	;LINE PARAMTER REGISTER
	CONS DH,\Z,<CAR=160026+<Z*20>>	;CORE ADDRESS REGISTER
	CONS DH,\Z,<BCR=160030+<Z*20>>	;BYTE COUNT REGISTER
	CONS DH,\Z,<BAR=160032+<Z*20>>	;BUFFER ACTIVE REGISTER
	CONS DH,\Z,<BRC=160034+<Z*20>>	;BREAK CONTROL REGISTER
	CONS DH,\Z,<SSR=160036+<Z*20>>	;SILO STATUS REGISTER
;CROCK
.=340
	CONS DH,\Z,RV=.
	CONS DH,\Z,TV=.+4
	CONS DM,\Z,RK
	240
	CONS DM,\Z,TK
	240
>
.ENDC
	.STITL SYSTEM VARIABLES(ONE COPY)


	.=400
	BR .+6
	JMP @#PWRUPB
	JMP @#START
	.=.+SYPDLL	;SYSTEM PDL
SJPDLP:SPDLP:	.	;SYSTEM PDL POINTER
	.=.+60
PFPDL:	0
PAT:
PATCH:	.=.+400	;PATCH AREA
PATEND=1400
LOGON:	.ASCIZ /LOGO/
.EVEN
.IFZ DHON
.IFNZ	NDMTY
.=1400
	DMCA=.-NFDMTY
	.=.+40	;DM11 CURRENT ADDRESS
	DMWC=.-NFDMTY
	.=.+40	;DM11 -BYTE COUNT
	.=.+40	;DM11 BIT ASSEMBLY TABLE
;DM0RK:	.=.+40	;UNUSED -- RCV INT HALT
	.=.+40
DMTT:	.=.+200	;DM11 TUMBLE TABLE
.ENDC
.ENDC
	ZEPT NDC,<
	CONC6 <
	.IFZ DC>,\Z,<DT-SPDT
CONS DC,\Z,RK:
	0
CONS DC,\Z,TK:
	0
	.ENDC
>>
	ZEPT NKL,<
	CONC6 <
	.IFZ KL>,\Z,<DT-SPDT
CONS KL,\Z,RK:
	0
CONS KL,\Z,TK:
	0
	.ENDC
>>
	.STITL SYSTEM OBLIST

VARIABLE==4	;FOR VARIABLE NUMBER OF ARGUMENTS
YINFIX==20	;"YES INFIX" FLAG FOR OLE

;SOE FIELDS		1.==RIGHT BYTE (EVEN ADDR) 2.==LEFT BYTE
	;		1.1==RIGHT BIT  2.8==LEFT BIT
ABRFLG==1
FRFLG==2
ENGFLG==4
PFRFLG==10
	;1.4-1.8 UNUSED
	;2.1-2.2 "STANDARD" NO. OF INPUT ARGS
	;2.3 VNAF 1==CAN TAKE "ANY" NO. OF ARGS
	;2.5 INFIX 1==THIS IS AN INFIX PROCEDURE
	;2.6-2.8 PRECEDENCE

	.MACR NGPTWO A
	NGP2=NGP2*2
	FOO==A
	.IFLE NGP2-FOO
	NGPTWO A
	.ENDC
	.ENDM

;****************************************************
;MACRO TO DEFINE SYSTEM OBLIST ELEMENTS
;THE PARAMETERS ARE:
;1)	THE PRINT NAME
;2)	PRINT NAME OF ABBREVIATION
;3)	THE NAME OF THE POINTER TO THE OBLIST ELEMENT.
;4)	THE ADDRESS OF THE PROGRAM
;5)	THE PRECEDENCE.  A NUMBER FROM 0-7
;6)	THE NUMBER OF ARGUMENTS, AND THE SYMBOL "VARIABLE"
;		IF IT CAN ALSO TAKE A VARIABLE NUMBER OF ARGUMENTS
;7)	THE SYMBOL "YINFIX" IF THIS IS AN INFIX OPERATOR
	;8)	IF 0, DONT ASSEMBLE THIS PRIMITIVE



;VERSION FOR OBLIST ELEMENTS THAT ARE BOTH FRENCH AND ENGLISH
.MACR OLB PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG!FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG!FRFLG
.ENDC
.ENDC
.ENDM
;VERSION FOR ENGLISH ONLY
.MACR OLE PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.ENDC
.ENDM
;VERSION FOR FRENCH ONLY
.MACR OLF PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
.MACR CDM A
A==<.-SOBLSU>/2
.ENDM

.MACR ABRV PN,OB,FLGS
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
OBLSTL==OBLSTL+4+OBL
.ENDC
.IF2
OBADD2-SOBLST
OBADD1=.
.=OBADD2
ABRFLG!FLGS
OB
TEXT ^\PN\
OBADD2=.
.=OBADD1
.ENDC
.ENDM
.MACR OLT PN,ABR,FPN,FAB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@FPN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@FPN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB FAB
ABRV FAB,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
;THE SYSTEM OBLIST
	;ADD ITEMS (EXCEPT FOR SPECIAL CHAR ITEMS) ALPHABETICALLY.

	.IF1
	NUMOBS==0
	.=.+4	;RESERVE SPACE FOR THE TWO WORDS ON PASS TWO
	.ENDC
	.IF2
SOBLSU=SOBLST+<NUMNSCOBS*2>-2
SOOMX=.
	2+SOBLSU	;2 > THAN HIGHEST ADDR USED IN SYS OBLIST
	NGP2==1
	NGPTWO SOBLSU-SOBLST+2
SOBP2=.
	NGP2	;( SMALLEST POWER OF 2 >= NUMOBS )*2
OBADD1=.
OBADD2=.+<2*NUMOBS>
OBSTRT=OBADD2	;WHERE THE SYSTEM OBLIST ELEMENTS START
	.ENDC

		;PRIORITIES
	PARPRI==1	; (  )
	BAKPRI==2	; _ __ IF TEST NOT BOTH EITHER
	RELPRI==3	; < = >
	PREPRI==4	;PRIORITY FOR MOST PREFIX PRIMITIVES
	PMPRI==5	; + -
	MDPRI==6	; * / \
	HIPRI==7	; : ! # -- ++
SOBLST:	OLB 0
	OLB .CASESW,,CASESW,CASESW,,1
	OLB .CGCF,,CGCF,CGCF
	OLB .CLOSE,,CLOSE,CLOSE,,1
	OLB .CLOSEF,,,.CLOSF
	OLB .CPNF,,CPNF,CPNF
	OLB .CTF,,CTF,CLRSTF
	OLB .CTYI,,CTYI,CTYI
	OLB .CTYO,,CTYO,CTYO,,1
	OLB .DEPOSIT,,DEPOSIT,DEPOSIT,,1
	OLB .ECHOSW,,ECHOSW,ECHOSW,,1
	OLB .ERPOP
	OLB .EXAMINE,,EXAMINE,EXAMINE,,1
	OLB .FILEO
	OLB .FILEP,,,,,1
	OLB .FILER
	OLB .GCOLL
	OLT .GUN,,.POW,,GUN,,1
	OLB .HALT
	OLB .NODES,,NODES,NODES
	OLB .OPENA,,,,,1
	OLB .OPENR,,,,,1
	OLB .OPENW,,,,,1
	OLB .PWRCLR,,PWRCLR,PWRCLR
	OLB .RUG,,RUG,RUNRUG
	OLB .SETTV,,SETTV,SETTV,,2
	OLB .SGCF,,SGCF,SGCF
	OLB .SPNF,,SPNF,SPNF
	OLB .STATUS,,,STATUS
	OLB .STF,,,SETSTF
	OLB .TOP,,,,,1
	OLB .TTYP,,,,,1
	OLB .TYI,,TYI,UGTYI,,1
	OLB .TYO,,TYO,UGTYO,,2
	OLB .USRTIME,,USRTIME,USRTIME
	OLB .VALUE,,VALUE,VALUE
	OLB .VERSION,,VERSION,VERSN
	OLB .XOR,,,,,1,,AI
	OLE ALL,,,NOTPRO
	OLT ALSO,,AUSSI,,,,,,DDF
	OLB ANGLAIS,,,,,,,<ENG&FR>
	OLF ARBRE,,,NOTPRO
	OLB ARCTAN,ATAN,,ATAN,,1,,FPPF
	OLE ARRAY,,,NOTPRO
	OLE ARRAYS,,ARAYS,NOTPRO
	OLT ASIZE,,DIMMAT,,ASIZEX,,1
	OLB ATOD,,,,,1,,AI
	OLT BACK,BK,RECULE,RE,,,1
	OLT BELL,,DING
	OLB BITOUT,,,,,1,,AI
	OLT BOTH,,LESDEUX,,,BAKPRI,2
	OLB BOXIN,,,,,1,,AI
	OLT BTOUCH,,TOUCHEAR
	OLE BURY
	OLT BUTFIRST,BF,SAUFPREMIER,SP,,,1
	OLT BUTLAST,BL,SAUFDERNIER,SD,,,1
	OLB CHAR,,,,,1
	OLT CLEARSCREEN,CS,VIDEECRAN,VE,,,,,NDISP
	OLT CLOCK,,SECONDES
	OLB CNTRL,,,,,,,DDF
	OLT CONTENTS,,CONTENU
	OLB CONTINUE,CO
	OLB COS,,,COSF,,1,,FPPF
	OLT COUNT,,COMPTE,,,,1
	OLB CRINDEX,,,.CRIND,,1
	OLB CTYOWAIT,,,,,1
	OLB DATE,,,UDATEG
	OLB DEBUG,,,DEBUGL
	OLT DEFINEARRAY,DEFAR,DEFMATRICE,DEFMAT,DEFAR,,3+VARIABLE
	OLT DELETE,,FRDELETE,,.DELET,,1
	OLT DELETEINDEX,,FRDLI,,.DELI,,1
	OLB DIFFERENCE,,,DIFF,,2
	OLE DISPLAY,,,,,1,,NDISP
	OLE DRIBBLE,,,,,1,,DRIBF
	OLB ED,,,EDIT
	OLT EDIT,,EDITE
	OLB EDL,,,EDLINE
	OLB EDT,,,EDTITL
	OLT EITHER,,UNDE,,,BAKPRI,2
	OLE ELSE
	OLT EMPTYP,,VIDE,,EMPTYP,,1
	OLT END,,FIN
	OLE NODRIBBLE,,,,,,,DRIBF
	OLF ENFOUIS,,,BURY
	OLB ENGLISH,,,,,,,<ENG&FR>
	OLT EQUAL,IS,EGAL,,EQUAL,,2
	OLT ERASE,ER,EFFACE,EF
	OLT ERASEFILE,ERF,DETRUIS,,.DELET,,1
	OLT ERASEINDEX,ERI,DETRUISINDEX,,.DELI,,1
	OLB ERBRK,,ERRBREAK,ERRBREAK
	OLB ERCLR,,ERRCLEAR,ERRCLEAR
	OLT ERL,,EFL
	OLB ERLIN,,ERRLINE,ERRLINE
	OLB ERLOC,,ERRLOCATION,ERRLOCATION
	OLB ERNAM,,,ERRNAM
	OLB ERNUM,,ERRNUMBER,ERRNUMBER
	OLB ERPRO,,ERRPROCEDURE,ERRPROCEDURE
	OLB ERRET,,RETURN,RETURN,,1
	OLB ERSET,,ERRSET,ERRSET
	OLB ERTOK,,ERRTOKEN,ERRTOKEN
	OLF EXECUTE,,,DO,,1
	OLE EYETURTLE,,,EYE,,1,,AI
	OLF FICHIER,,,NOTPRO
	OLE FILE,,,NOTPRO
	OLT FIRST,F,PREMIER,PREM,,,1
	OLT FORWARD,FD,AVANCE,AV,,,1
	OLT FPRINT,,ECRISC,,,,1+VARIABLE
	OLT FPUT,,INCLUSD,,,,2+VARIABLE
	OLB FRANCAIS,,,,,,,<ENG&FR>
	OLB FRANGLAIS,,,,,,,<ENG&FR>
	OLB FRENCH,,,,,,,<ENG&FR>
	OLT FTOUCH,,TOUCHEAV
	OLT GET,,SORT,,,,2+VARIABLE
	OLT GO,,VA,,,,1
	OLT GOODBYE,,SALUT
	OLT GREATER,,PLUSGRAND,,GREATR,,2
	OLB HALHACK,,,,,1,,HALFLG
	OLT HEADING,,CAP,,,,,,<NDISP!NPLOT>
	OLT HELLO,,ALLO
	OLT HERE,,ICI,,,,,,<NDISP!NPLOT>
	OLT HIDETURTLE,HT,CACHETORTUE,CTT,,,,,NDISP
	OLT HISSPEED,,SAVITESSE,,,,2,,DHON
	OLT HOME,,ORIGINE,,,,,,<NDISP!NPLOT>
	OLE IF,,,,BAKPRI,1
	OLT IFFALSE,IFF,SIFAUX,SIF
	OLT IFTRUE,IFT,SIVRAI,SIV
	OLB ILINE
	OLB INDEX,,,NOTPRO
	OLB INTEGER,INT,,,,1,,FPPF
	OLT LAMPOFF,,ETEINT
	OLT LAMPON,,ALLUME
	OLT LAST,L,DERNIER,DER,,,1
	OLT LEFT,LT,GAUCHE,GA,,,1
	OLT LESS,,PLUSPETIT,,LESSP,,2
	OLT LEVEL,,NIVEAU,,FLEV
	OLT LIGHT,,LUMIERE
	OLF LIGNE,,,NOTPRO
	OLE LINE,,,NOTPRO
	OLT LINEPRINT,LP,IMPRIMANTE,IMP,LPRINT,,1,,<LPF&AI>
	OLT LINEPRINT,LPT,IMPRIMANTE,IMP,LPRINT,,1,,<LPF&GUY>
	OLT LIST,,LISTE,,LIST.P,,2+VARIABLE
	OLT LISTP,,LISTEP,,LISTP,,1
	OLB LOCAL,,,,,1
	OLT LOGIN,,CEST,,,,1
	OLT LPUT,,INCLUSF,,,,2+VARIABLE
	OLT LTOUCH,,TOUCHEG
	OLT MAIL,,MALLE,,,,1
	OLT MAKE,,RELIE,,,,2
	OLF MATRICE,,,NOTPRO
	OLF MATRICES,,MATRS,NOTPRO
	OLB MCLEAR
	OLT MLEN,,LONGM
	OLF MONTRE,,,DISPLAY,,1,,NDISP
	OLB MUCTRL,,,,,1
	OLB MUTYO,MUT,,,,2+VARIABLE
	OLB MUWAIT,,,,,1
	OLT MYSPEED,,MAVITESSE,,,,1,,DHON
	OLE NAME,,,NOTPRO
	OLE NAMES,,,NOTPRO
	OLT NEWSNAP,,NOUVPHOTO,,,,,,NDISP
	OLT NODISPLAY,,LIBECRAN,,KILLDISPLAY,,,,NDISP
	OLF NOM,,,NOTPRO
	OLF NOMS,,,NOTPRO
	OLT NOMUSIC,,LIBMUSIQUE
	OLT NOPLOTTER,,LIBTRACEUR,,KILLPL,,,,NPLOT
	OLT NOT,,NON,,,BAKPRI,1
	OLE NOTBOX,,,,,,,1
	OLB NOTE,,,SING,,2+VARIABLE
	OLT NOTURTLE,,LIBTORTUE,,KILLTURTLE
	OLT NOWRAP,,DEBORDEPAS,,,,,,NDISP
	OLT NUMBERP,,NOMBREP,,NUMBP,,1
	OLT NVOICES,,NPISTES,,,,1
	OLB OUTPUT,OP,,,,1
	OLF PASAPAS,,,STEP
	OLB PAUSE
	OLB PEEK
	OLB PEEKD,,,PEEKDV
	OLT PENDOWN,PD,DESCENDPLUME,DP
	OLT PENP,,PLUMEP,,,,,,1
	OLT PENUP,PU,LEVEPLUME,LP
	OLE PLOTTER,,,STRTPL,,,,NPLOT
	OLT PM,,JM
	OLT POF,,IMF,,.POF,,1
	OLT POI,,IMI,,.POI
	OLT POL,,IML
	OLT POT,,IMT
	OLT POTS,,IMTS
	OLT PRINT,PR,ECRIS,EC,,,1+VARIABLE
	OLT PRINTOUT,PO,IMPRIME,IM,SHOW
	OLB PROCEDURES,,,NOTPRO
	OLT PRODUCT,,PRODUIT,,PROD,,2+VARIABLE
	OLB QUOTIENT,,,DIVDE,,2
	OLT RANDOM,,HASARD
	OLT READ,,RAMENE,,.READ,,1
	OLT READPTR,PTR,DECODE
	OLT RELAY,RELAIE,,,,,2,,AI
	OLT REMAINDER,MOD,RESTE,,MOD,,2
	OLT REQUEST,RQ,REPONSE,,RQUEST
	OLT RIGHT,RT,DROITE,DR,,,1
	OLT RTOUCH,,TOUCHED
	OLE RUN,,DO,DO,,1
	OLT SEND,,MESSAGE,,,,2,,SYSP
	OLT SENTENCE,SE,PHRASE,PH,,,2+VARIABLE
	OLT SETASIZE,,FIXEDIMMAT,,SETASZ,,1
	OLT SETHEADING,,METSLECAP,,,,1,,<NDISP!NPLOT>
	OLT SETINDEX,SETI,FIXEINDEX,FIXEI,.DIRSE,,1
	OLT SETTURTLE,SETT,PLACETORTUE,,,,1,,<NDISP!NPLOT>
	OLT SETX,,FIXEX,,,,1,,<NDISP!NPLOT>
	OLT SETXY,,FIXEXY,,,,2,,<NDISP!NPLOT>
	OLT SETY,,FIXEY,,,,1,,<NDISP!NPLOT>
	OLT SHOWTURTLE,ST,TORTUEPOINTEE,TIP,,,,,NDISP
	OLF SI,,,IF,BAKPRI,1
	OLB SIN,,,SINEF,,1,,FPPF
	OLF SINON,,,ELSE
	OLT SNAP,,PHOTO,,,,,,NDISP
	OLT SQRT,,RCAR,,,,1,,FPPF
	OLT STARTDISPLAY,SD,ECRAN,,,,1,,NDISP
	OLE STEP,,.STEP
	OLB STOP
	OLB STORE,,,,,3+VARIABLE
	OLT SUM,,SOMME,,,,2+VARIABLE
	OLB SWITCH,,,,,2,,AI
	OLT SYSPR,,ATOUS,,,,1,,SYSP
	OLE TBOX,,,,,,,1
	OLT TEST,,TESTE,,,BAKPRI,1
	OLT TEXT,,TEXTE,,TEXTT,,1
	OLT THEN,,ALORS
	OLT THING,,CHOSE,,DOTS,,1
	OLT THINGP,,CHOSEP,,,,1
	OLT TIME,,HEURE,,UTIMEG
	OLE TITLE,,,NOTPRO
	OLE TITLES,,TITLS,NOTPRO
	OLF TITRE,,,NOTPRO
	OLF TITRES,,TITRS,NOTPRO
	OLT TO,,POUR
	OLT TOOT,,BEEP,,,,1
	OLT TOPLEVEL,,NIVEAUSUP,,EXIT
	OLF TORTUE,,,STARTT,,1
	OLF TOUT,,,NOTPRO
	OLB TRACE
	OLF TRACEUR,,TRAC,STRTPL,,,,NPLOT
	OLE TREE,,,NOTPRO
	OLB TTYP
	OLE TURTLE,,STTUR,STARTT,,1
	OLE TVHACK,,,TVWHK,,2,,JRDF
	OLB TYOWAIT,,,,,2
	OLT TYPE,,TAPE,,,,1+VARIABLE
	OLT TYPEIN,,PREPONSE
	OLB UNTIL,,,,,1
	OLT USE,,REFERE,,.USE,,1
	OLT VLEN,,LONGP
	OLT VOICE,,PISTE,,,,1
	OLT WAIT,,ATTENDS,,UWAIT,,1
	OLT WHERE,,OU
	OLT WIPE,,DEGAGE,,,,1,,NDISP
	OLT WIPECLEAN,WC,BALAYE,,,,,,NDISP
	OLT WORD,,MOT,,,,2+VARIABLE
	OLT WORDP,,MOTP,,WORDP,,1
	OLT WRAP,,DEBORDE,,,,,,NDISP
	OLT WRITE,,ENVOIE,,.WRITE,,1
	OLT WRITEPTP,PTP,PERFORE
	OLB XCOR,,,,,,,<NDISP!NPLOT>
	OLB YCOR,,,,,,,<NDISP!NPLOT>
	.IF1
NUMNSC==NUMOBS	;NUMBER OF NON-SPECIAL CHARACTER OBLIST ELEMENTS

	.ENDC
	OLB ^\!(\,,LLPAR,LLPAR,PARPRI,1
	CDM EXCL$
	OLB ^\!\,,COMT,COMT,HIPRI
	CDM HASH$
	OLB ^\#\,,PROC,PROC,HIPRI,1
	CDM LP$
	OLB ^\(\,,LPAR,LPAR,PARPRI,1
	CDM RP$
	OLB ^\)\,,RPAR,RPAR,PARPRI
	CDM PRD$
	OLB ^\*\,,STAR,PROD,MDPRI,2+VARIABLE,YINFIX
	CDM PLU$
	OLB ^\+\,,PLUS,SUM,PMPRI,2+VARIABLE,YINFIX
	OLB ^\++\,,UPLUS,UPLUS,HIPRI,1
	CDM MIN$
	OLB ^\-\,,MINUS,DIFF,PMPRI,2,YINFIX
	OLB ^\--\,,UMINS,UMINS,HIPRI,1
	CDM DIV$
	OLB ^\/\,,SLSH,DIVDE,MDPRI,2,YINFIX
	CDM DOTS$
	OLB ^\:\,,DOTS,DOTS,HIPRI,1
	CDM LSS$
	OLB ^\<\,,LESS,LESS,RELPRI,2,YINFIX
	CDM EQL$
	OLB ^\=\,,EQUAL,EQUAL,RELPRI,2,YINFIX
	CDM GTR$
	OLB ^\>\,,GRTR,GREATR,RELPRI,2,YINFIX
	CDM BKSL$
	OLB ^/\/,,BKSL,MOD,MDPRI,2,YINFIX
	CDM BKAR$
	OLB ^/_/,,BKAR,MAKE,BAKPRI,2,YINFIX
	OLB ^/__/,,TBKAR,MMAKE,BAKPRI,2,YINFIX

	.IF1
.=.+<NUMOBS*6>
	.ENDC
	.IF2
.=OBADD2
	.ENDC
.STITL SYSTEM VARIABLES (ONE COPY PER SYSTEM)

DEBSW:	0	;DEBUG SWITCH, NON-ZERO IF BEING DEBUGGED
ERBASE:	0	;PLACE ON DISK WHERE ERRORS ARE STORED
	0
NOADDR:	1	;ZERO MEANS PRINT ADDRESS OF ERRORS
USER:	-1
.IIF NZ AI,	XORF:	0	;XOR USERS ON SWAP OUT
ULAST:	0	;LAST USER WHO WAS RUN
QUANT:	6	;UQUANT SET FRCM THIS
UQUANT:	0	;TIME IN 1/100THS USER SHOULD RUN
UTIME:	0
TUTIME:	0	;TOTAL USED TIME
	0
NRABLU:	0	;NUMBER OF USERS WITH FLSADR=0
NSWPU:	0	;NUMBER OF USERS ASSIGNED TO SLOTS BUT NOT YET IN
NINU:	0	;   "    "    "      "      "   "   AND ALREADY IN
PUSPSL:	-1	;PREFERED USER SLOT TO SWAP
PUSRSP:	0	;PREFERED USER TO SWAP OUT
SWPLEP:	SWPLST	;PLACE TOO PUT NEXT REQ
SWPLST:	.=.+<MNSLTS*2>+2	;LIST OF SWAP REQUESTS
MSWPOR:	.=.+<16*MNSLTS*2>	;MOBY SWAP IN AND OUT BLOCKS
SYSWPR:	.=.+<16*MNUSRS>	;10 DISK REQUEST BLOCKS FOR GENERAL USE
DSKCRB:	0	;CURRENT DISK REQUEST
DSKRUN:	DSKS	;THE DISK WHICH IS RUNNING
.IIF Z FXONLY,	MVDEAD:	0	;NOT 0 = MOVING HEAD DISK DECLARED DOWN
SLOTST:	REPT1 MNSLTS,-1
SLOTU:	REPT1 MNSLTS,-1
SLOTCA:	.BLKW MNSLTS
FOO==0
	.MACR MSWF
	MSWPOR+FOO
FOO==FOO+34
	.ENDM
SLOTRB:	REPT1 MNSLTS,MSWF
SLOTHA:	.BLKW MNSLTS
SLOTAR:	.BLKW MNSLTS
SLOTDR:	77406
	77406
	77406
ASDIS:	REPT1 NDISP,-1
DISAR:	.BLKW NDISP
DISDR:	.BLKW NDISP
DISMAL==40
DISBIG==100
DLENGT:	REPT1 NDISP-1,DISMAL	;5+1 MUST = NDISP (3 NOW FIT BEFORE RUG,
	REPT1 1,DISBIG	;		 (2 SMALL & 1 BIG AFTER)
PARREG:	.BLKW 21	;INITIALIZE TO ADDRESSES OF EXTANT PARITY REGISTERS
LOSSCT:	-4
WRTELC:	-1	;DISK WRITE LOCK SWITCH (ONE USER AT A TIME!)
NRKERS:	0	;NUMBER OF RK ERRORS
NRFERS:	0	;NUMBER OF RF ERRORS
DKRTYS:	0	;# OF DISK RETRYS
DKNRTY:	-10.
DKPWFR:	0
NDISPS:	NDISP
.IIF Z AI,NUSERS:	MNUSRS	;NUMBER OF USERS
.IIF NZ AI,NUSERS:	MNUSRS-3	;FOR DANNY
NSLOTS:	.IFNZ AI
	6
.IFF
	2
.ENDC
	;NUMBER OF IN CORE SLOTS
ASIZE:	0	;SIZE OF ARRAY SPACE (SHOULD BE ZERO)
ENDWLD:	0	;END OF THE WORLD (DON'T FALL OFF)
NUSER2:	2
USWCNT:	0	;NEGATIVE LENGTH OF USER SLOT
USLENT:	0	;LENGHT OF SLOT IN BYTES
USNSEC:	0	;NUMBER OF SECTORS FOR A SLOT
NDBLKS:	0
DBGRBD:	0	;GRABBED DISK BLOCK
DCLRUS:	0	;ADDRESS OF CLEAR USER IMAGE
	0
DSKRND:	0	;START OF RANDOM USER STORAGE
	0
TTYUGO:	-1
PWFPDL:	0
FOO==.
LOCKUS:	-1	;INDEX OF USER LOCKED IN CORE
NLOCKS==.-FOO/2
PBUF:	.=.+40
PBUFE:
PGRAB:	-1
PBFPTI:	0
PBFPTM:	0
NPCHRS:	0
	FOR NDISP
;DISPLAY SYSTEM VARIABLES
DPDLL==60	;LENGTH OF EACH DISPLAY PDL (IN BYTES)
TLEN==20	;LENGTH OF EACH TURTLE LIST (IN BYTES)
DSTAT:	REPT1	NDISP,-1	;CONTAINS -1 IF DISPLAY INACTIVE
;	OTHERWISE CONSOLE NUMBER SHIFTED OVER TO MUNG NGCSR
DCONS:		;USER DISPLAY CONSOLE TABLE
		;USER 1 GETS DISPLAY 0, USER 2 DISPLAY 1,ETC.
	.BYTE 377,377,0,2,4,377,377,6
	REPT1	<<MNUSRS-4>-NDISP>,.BYTE -1	;USERS WITHOUT DISLAYS
	.EVEN

DSIZES:		;WHAT SIZES THE ARGUMENTS TO STARTDISPLAY REFER TO
			;(IN BLOCKS)
	.BYTE	DISMAL
	.BYTE	DISBIG
	.EVEN
	.ENDC
	ENDC NDISP
TUT:	0	;TURTLE TOP.  POINTS TO TOP OF TURTLE DISPLAY LIST
SNPTEM:	0	;USED BY GARBAGE COLLECTOR

	ZEPT NPTBOX,<
	CONS PTBOX,\Z,:	-1
	.BLKW 4>

	CONSO==20
	PLOTT==40
	PMBOX==100
	INITF==1000	;MUSIC BOX INITIALIZED
	TURT==200
	TBMASK==177417

TEM0:	0
TEM1:	0
ANSWER:	.WORD	0,0	;USED BY DOUBLE PRECISION ROUTINES
SHFCNT:	0		;USED BY DOUBLE PRECISION ROUTINES
EXCH1:	0

.IFNZ NATG
;DAZZLE DART VARIABLES
.INSRT NATG;DAZVAR >
.ENDC



.VERR==-128.
.VRTS==-128.
GCMKL:	TOPS
	TOPS1
	TOPS2
	GCP1
	GCP2
	GCPREV
	MVOC
	MVOC+2
	MVOC+4
	MVOC+6
	ILINEL	;PTR TO TYPED INPUT LINE
	ERPROC	;PTR TO ERRSET PROC
	.IIF NZ NDISP, SNLIST
	0
.IIF NZ MVONLY,FIXFAK:	0
DSKFOO:	.=.+<2*FDSCSZ>
DBLDO:	0
DBLDWC:	0
DBLDCA:	0
DBLDDA:	0
DBLDDE:	0
	0
DBLDCM:	0
DBLPRO:	0
DBLPWC:	0
DBLPCA:	0
DBLPDA:	0
DBLPDE:	0
	0
DBLPCM:	0
DBLASV:	0
DBLFAK:	0

DKSDA:	0	;STORAGE OF WHAT DISK REGISTERS SHOULD BE
DKSCA:	1
DKSAE:	0
DKSCS:	0
DKEPR:	DSKS
	DKSCS
.IFZ MVONLY
	DSKWC
.IFF
	RKWC
.IFTF
	DKZERO
.IFT
	DSKCA
.IFF
	RKBA
.IFTF
	DKSCA
.IFT
	DSKA
.IFF
	RKDA
.IFTF
	DKSDA
.IFT
	DSKAE
	DKSAE
.ENDC
DKZERO:	0

DKWLST:	DSKS		;LOCS PRINTED ON HARD ERROR
	DSKAE
	DSKA
	0
RKWLST:	RKDS
	RKER
	RKCS
	RKDA
	0


PSWPWR:	PSWPAD
	DBGRBD
	DWRTEC

PSWPRD:	PSWPAD
	DBGRBD
	DREADC

SSWPWR:	SSWPAD
	DBGRBD
	DWRTEC

SSWPRD:	SSWPAD
	DBGRBD
	DREADC

SSAVWR:	SSWPAD
	SSAVEA
	DWRTEC

SSAVRD:	SSWPAD
	SSAVEA
	DREADC


SECRET:	TEXT ^/SECRET/

ISSIM:	0		;TO TRY SYSTEM ON SIMULATOR, SET TO -1

CLKQT:	CLKINF
CLKINF:	-1
	0
	CLKINE
N50THS:	CLKFRQ

DISTIM:	.BYTE	1
SECLIM:	.BYTE 60.
MINLIM:	.BYTE 60.
HORLIM:	.BYTE 24.
DAYLIM:	.BYTE 0
MONLIM:	.BYTE 12.
YERLIM:	.BYTE 177
RSEC:	.BYTE 0
RMIN:	.BYTE 0
RHOUR:	.BYTE 0
RDAY:	.BYTE 0
RMONTH:	.BYTE 0
RYEAR:	.BYTE 0
DMON:	.BYTE 30.,27.,30.,29.,30.,29.,30.,30.,29.,30.,29.,30.
	.EVEN

ITYI:	STYI
ITYO:	STYO	;THESE GET CLOBBERED TO JTYI, JTYO IN TINIT

SLASHX:	0	;SAVED CHAR FROM D WHEN ENTERING OR LEAVING
		;RUBOUT STRING
	.STITL GARBAGE COLLECTOR MARK-NODE TABLES

BMT:	.BYTE 1,2,4,10,20,40,100,200
LMT:	MARKV2	;SYSTEM FUNCTION
	MARKV2	;INFIX (SYSTEM FUNCTION)
	MKATOM	;USER FUNCTION
	MKATOM	;VARIABLE BINDING
	GCDIE	;IDLE NODE
	GCDIE	;UNUSED
	GCDIE	;BUCKET ELEMENT
	MARKV2	;SHORT STRING
	.IFNZ NDISP
	MKSNAP	;SNAP
	.ENDC
	.IFZ NDISP
	GCDIE
	.ENDC
	MKATOM	;ATOM
	MARKV2	;SHORT NUMBER
	MKINUM	;INTEGER NUMBEB
	MKLIST	;LONG STRING
.IFZ FPPF
	GCDIE	;TBA
.IFF
	MKINUM
.ENDC
	GCDIE	;UNUSED (WAS "SENTENCE" ONCE)
	MKLIST	;LIST
	.STITL NEW FILE TABLES
NBTTL==160.
.IIF NZ GUY,NDISKS==2
.IIF Z GUY,.IIF NZ SITSD,NDISKS==4
FDBITI:	-NDISKS
FDBITS:	.BLKW NBTTL*NDISKS
FDBITP:	REPT1 NDISKS,<2*.RPCNT*NBTTL+FDBITS>
FDDSKN:	REPT1 NDISKS,<20000*.RPCNT>
FDNAMP:	REPT1 NDISKS,<2*10.*.RPCNT+FDNAMS>
FDNAMS:	.BLKW NDISKS*10.
DDIRIA:	.BLKW NDISKS
FDUSEA:	.BLKW NDISKS
WDIRSW:	-1
NBLKFR:	.BLKW NDISKS
.IF Z SITSD
POTTAB:	POTHED
	POILNK
	POIFLE
	POTDIR
POITAB:	POIHED
	POILNK
	POIFLE
	POIDIR
.IFF
POTTAB:	POIPAR
	POTDIR
	POIFLE
	POILNK
	POTHED
	POILNK
	POILNK
	POILNK
POITAB:	POIPAR
	POIDIR
	POIFLE
	POILNK
	POIHED
	POILNK
	POILNK
	POILNK
.ENDC
GNBTAB:	GNBSKP
	GNBCNT
	GNBADR
	GNBSCN
DBITAD:	.BLKW NDISKS	;BLOCK NO. OF BIT TABLE
USRFIL:	.WORD "US,"ER,'S+200
BITS:	.BYTE 'B,'I,'T,200+'S
DIRID:	.BYTE 'D,'I,'R,'I,200+'D
.EVEN
	.STITL ERROR MACROS

	.MACRO ERMM AA
.IF2
	.IFG FOO-AA'.E
	.ERROR ERROR AA IN WRONG ORDER
	.ENDC
FOO==AA'.E
	AA'.E
.IFF
	0
.ENDC
AA==ERMNO
ERMNO==ERMNO+1
	.ENDM

	.MACRO JROT A
A'.R==A
	.ENDM

	.MACRO ERRM A
.=ROTTAB+<<A'.N-200>*2>
	A'.R
.ENDM

ERRNO==200
ERMNO==0
	.STITL ERROR TABLES

ROTTAB:	PNAB.R==PNODAB
	ERRM PNAB
	JROT PRLO
	ERRM PRLO
	JROT TYO
	ERRM TYO
	JROT PRCO
	ERRM PRCO
	JROT PRS1
	ERRM PRS1
	JROT PRCT
	ERRM PRCT
GDBY.R==GOODBY
	ERRM GDBY
	ERRM CTIT
	ERRM HNM
	ERRM LDE1
	ERRM PAE
PRAB.R=PROAB
	ERRM PRAB
	ERRM PNH1
	ERRM TMAP
	ERRM TDE
	ERRM BUG
	ERRM BRK
	ERRM WTA
	ERRM WTAA
	ERRM WTAB
	ERRM WTIB
.=ROTTAB+<MAXROT*2>
ERTAB:	FOO==BADD.E
	ERMM BADD	;BAD DIRECTORY
	ERMM BADE	;BAD ENTRY
	ERMM BAT	;BAD ARRAY TYPE
	ERMM BDD	;BAD DISK
	ERMM BRK	;BREAK!!
	ERMM BUG	;SYSTEM BUG!!
	ERMM CDE	;CAN'T DELETE ENTRY
	ERMM CDF	;CAN NOT DELETE THAT FILE
	ERMM COP	;CHAR (D) OUT OF PALCE
	ERMM CRE	;CAN'T READ THAT ENTRY
	ERMM CTIT	;CANT "TO" IN "TO"
	ERMM DFU	;DISC FULL
	ERMM DIU	;DEVIVE IN USE
	ERMM DNA	;INVALID DEVICE NAME
	ERMM DNR	;DEVICE NOT READY
	ERMM DOR	;DURATION OUT OF RANGE
	ERMM DRF	;DIRECTORY FULL
	ERMM EAES	;ENTRY ALREADY EXISTS
	ERMM ELW	;EDIT LINE WHAT?
	ERMM ENDR	;ENTRY NOT DIRECTORY
	ERMM ERP	;EXTRA RIGHT PAREN
	ERMM ERW	;ERASE WHAT??
	ERMM FAE	;FILE ALREADY EXISTS
	ERMM FAO	;FILE ALREADY OPEN
	ERMM FBUG	;FATAL SYSTEM BUG
	ERMM FNF	;FILE NOT FOUND
	ERMM HARD	;HARDWARE ERROR
	ERMM HNM	;.(B). HAS NO MEANING
	ERMM HNM1	;..CT.. HAS NO MEANING
	ERMM HNV	;.(CT). HAS NO VALUE
	ERMM IDN	;INVALID DISPLAY NUMBER (UGH!)
	ERMM IFN	;A,,B IS INVALID FILE NAME
	ERMM INF1	;INFIX IN THE WRONG PLACE
	ERMM INVN	;INVALID NODE
	ERMM ITN	;INVALID TURTLE NUMBER
	ERMM IUN	;INVALID USER NAME
	ERMM IVV	;INVALID VOICE NUMBER
	ERMM LCE	;LINE ... CHANGED BY EDIT
	ERMM LDE	;LINE ..(B).. DOESN'T EXIST
	ERMM LNTB	;LINE # TOO BIG
	ERMM LNTS	;LINE # TOO SMALL
	ERMM NAS	;NO ARRAY STORAGE
	ERMM NDU	;NOT A DISPLAY USER
	ERMM NDV	;NO DISPLAY AVAILABLE
	ERMM NEC	;NOT AN EDITING COMMAND
	ERMM NED	;NON EXISTENT DIRECTORY
	ERMM NFO	;NO FILE OPEN
	ERMM NIP	;NOTHING INSIDE PARENS
	ERMM NOG	;NOTE OUT OF RANGE
	ERMM NOU	;NO OUTPUT
	ERMM NSL	;NO STORAGE LEFT
	ERMM NTB	;NO THORTON BOX SLOTS AVAILABLE
	ERMM NTF	;(S) NOT "TRUE" OR "FALSE"
	ERMM OIP	;ONLY IN PROCEDURE
	ERMM OOB	;OUT OF BOUNDS
	ERMM OOP	;(CO) OUT OF PLACE
	ERMM OOT	;OUT OF TOKENS
	ERMM PAE	;PROCEDURE (TEMP) ALREADY EXIXTS
	ERMM PBE	;PROCEDURE IS BEING EDITED
	ERMM PNH	;PROCEDURE .(CT). NOT HERE
	ERMM PNH1	;PROCEDURE .(CPP). NOT HERE
	ERMM ROB	;INDEX REFERENCE OUT OF BOUNDS
	ERMM RTB	;RESULT TOO BIG
	ERMM SHW	;SHOW WHAT??
	ERMM STD	;SNAP TOO DEEP
	ERMM TDE	;TTY ..(E/2).. DOESN'T  EXIST
	ERMM TGDZ	;TURTLE GETTING DIZZY
	ERMM TIP	;TOO MUCH INSIDE PARENS
	ERMM TMAC	;TOO MANY ARGS (CURRENT PROC)
	ERMM TMAP	;TOO MANY ARGS (PROC BEING TO'ED)
	ERMM TML	;TOO MANY LINES
	ERMM TNR	;TURTLE NOT RESPONDING
	ERMM UBL	;USED BY LOGO
	ERMM UDA	;UNDEFINED ARRAY
	ERMM UEL	;UNEXPECTED END OF LINE
	ERMM UELX	;...(CO) NEEDS ARGS
	ERMM VTD	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE OR A DISPLAY
	ERMM VTU	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE
	ERMM WDIM	;BAD DIMENSIONS
	ERMM WDW	;YOU DON'T SAY WHAT TO DO WITH...
	ERMM WIT	;(CT) IS WRONG INPUT TO "TO"
	ERMM WNA	;WRONG NUMBER OF ARGUMENTS TO ..(CO)
	ERMM WTA	;..(CO)..DOESN'T LIKE..(CT)..AS INPUT
	ERMM WTAA	;..(CO)..DOESN'T LIKE..(A)...AS INPUT
	ERMM WTAB	;..(CO)..DOESN'T LIKE..(B)...AS INPUT
	ERMM WTIB	;..(CO)..DOESN'T LIKE..NUMBER IN B...AS INPUT
ERTEND:	ERREND
	.STITL OTHER TABLES

;THE DISPATCH TABLE FOR CONVERT

CNVTBL:
	.BYTE CNVNOP	;SNAP TO SNAP
REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE 0	;ATOM TO SNUM
	.BYTE 0	;ATOM TO INUM
	.BYTE CA2LS	;ATOM TO LSTR
REPT1 3,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SNUM TO SNUM
	.BYTE CSN2IN	;SNUM TO INUM
	.BYTE CSN2LS	;SNUM TO LSTR
.IIF NZ FPPF,	.BYTE CSN2FN	;SNUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CIN2SN	;INUM TO SNUM
	.BYTE CNVNOP	;INUM TO INUM
	.BYTE CIN2LS	;INUM TO LSTR
.IIF NZ FPPF,	.BYTE CIN2FN	;INUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CLS2SN	;LSTR TO SNUM
	.BYTE CLS2IN	;LSTR TO INUM
	.BYTE CNVNOP	;LSTR TO LSTR
.IIF NZ FPPF,	.BYTE CLS2FN	;LSTR TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

.IFNZ FPPF

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME (RNUM TO ANYTHING)
	.BYTE CFN2SN	;FNUM TO SNUM
	.BYTE CFN2IN	;FNUM TO INUM
	.BYTE CFN2LS	;FNUM TO LSTR
	.BYTE CNVNOP	;FNUM TO FNUM
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME


.IFF

REPT1 8.,^\.BYTE 0\


.ENDC

REPT1 6,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SENT TO SENT
REPT1 1,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;LIST TO LIST

.IIF NZ .-CNVTBL-100,.PRINT /CONVERT TAB SCREWED UP!/
	.EVEN

;THE LIST OF VALID TYPES

CKLIST:	.IIF NZ FPPF,FNUM
	.IIF NZ NDISP,SNAP ;CRACKLE,POP
	LSTR
	LNUM
	LIST
	ATOM
.IIF NZ FPPF,	FNUM
	0
		;MUSIC BOX CHARACTERS

	MBTRAP==43	;TRAP CHARACTER
	MBFCH==100	;SHUT-UP CHARACTER
	MBREST==40	;REST CHARACTER FOR MUSIC BOX
	MBPERC==42	;HIGHEST CODED PERCUSSION EFFECT

MBVCH:	.BYTE	123,42,61,60	;CTL CHARACTERS FOR NUMBER OF VOICES
MBSCH:	.BYTE	103,102,101,100	;LIKE MBVCH, EXCEPT SPECIFIES SILENCE


STURF:	.BYTE 101.,34.,68.,19.	;TURTLE FUDGE FACTORS FOR LEFT AND RIGHT
;	MULTIPLY BY EVEN BYTE AND DIVIDE BY ODD BYTE
.IFZ FPPF

;BEAUTIFUL SINE TABLE IN WHOOPIE FORMAT


SIN:

	0	;0 DEGREES
	2167	;2 DEGREES
	4355	;4 DEGREES
	6541	;6 DEGREES
	10720	;8 DEGREES
	13072	;10 DEGREES
	15234	;12 DEGREES
	17367	;14 DEGREES
	21510	;16 DEGREES
	23615	;18 DEGREES
	25707	;20 DEGREES
	27763	;22 DEGREES
	32017	;24 DEGREES
	34034	;26 DEGREES
	36027	;28 DEGREES
	40000	;30 DEGREES
	41724	;32 DEGREES
	43623	;34 DEGREES
	45474	;36 DEGREES
	47315	;38 DEGREES
	51106	;40 DEGREES
	52646	;42 DEGREES
	54352	;44 DEGREES
	56023	;46 DEGREES
	57437	;48 DEGREES
	61015	;50 DEGREES
	62335	;52 DEGREES
	63615	;54 DEGREES
	65035	;56 DEGREES
	66214	;58 DEGREES
	67331	;60 DEGREES
	70404	;62 DEGREES
	71413	;64 DEGREES
	72357	;66 DEGREES
	73255	;68 DEGREES
	74107	;70 DEGREES
	74674	;72 DEGREES
	75412	;74 DEGREES
	76062	;76 DEGREES
	76463	;78 DEGREES
	77016	;80 DEGREES
	77301	;82 DEGREES
	77514	;84 DEGREES
	77660	;86 DEGREES
	77754	;88 DEGREES
	77777	;90 DEGREES
.ENDC

;PRINTOUT DISPATCH TABLE
.MACRO DT A,B
$'A
B
.ENDM
PODISP:	DT INDEX,.POI
	DT PROCED,SHALPR
.IFNZ ENG
	DT ALL,SHOWAL
	DT FILE,.POFILE
	DT TITLE,POT
	DT LINE,POL
	DT ARRAY,PO1AR
	DT ARAYS,POARR
	DT NAMES,SHALNA
	DT TREE,.POTREE
.ENDC
.IFNZ FR
	DT TOUT,SHOWAL
	DT FICHIER,.POFILE
	DT TITRE,POT
	DT TITRS,POTS
	DT LIGNE,POL
	DT MATRICE,PO1AR
	DT MATRS,POARR
	DT NOMS,SHALNA
	DT ARBRE,.POTREE
.ENDC
	0

;ERASE DISPATCH TABLE
ERSDISP:	DT TRACE,ETRACE
	DT INDEX,ERINDX
	DT PROCE,ERALPR
.IFNZ ENG
	DT ALL,ERALL
	DT .STEP,ESTEP
	DT BURY,EBURY
	DT FILE,ERFI
	DT LINE,ERLINE
	DT NAMES,ERALNA
	DT NAME,ERNAME
	DT ARRAY,ERARAY
	DT ARAYS,ERARAS
.ENDC
.IFNZ FR
	DT TOUT,ERALL
	DT PASAPAS,ESTEP
	DT ENFOUI,EBURY
	DT FICHIER,ERFI
	DT LIGNE,ERLINE
	DT NOMS,ERALNA
	DT NOM,ERNAME
	DT MATRICE,ERARAY
	DT MATRS,ERARAS
.ENDC
	0
;DISPLAY DIRECTION CODES

DREC:	.BYTE 10
	.BYTE 0
	.BYTE 20
	.BYTE 30
	.BYTE 60
	.BYTE 70
	.BYTE 50
	.BYTE 40
	.EVEN
	.STITL SYSTEM VARIABLES (ONE COPY PER USER)

UBLK=.
UNAME:	.BLKW 5
TIMUSD:	0	
LSTIM:	0	;LAST TIME USER RAN
	0
JMTU:	0
SLOTAS:	0	;INDEX OF ASSIGNED SLOT OR -1
DISAS:	0
FLSRES:	0	;REASON USER NOT RUNNING
FLSADR:	0	;ADDRESS TO START AT AFTER FLUSH
GUNSW:	0
UACA:	0
UACB:	0
UACC:	0
UACD:	0
UACE:	0
.IIF NZ AI,	XORUSR:	0
UPC:	0	;PROGRAM COUNTER
UTTY:	0
BRAKE:	0
;DO NOT CHANGE THE ORDER BELOW
USWPAD:	.=.+4	;BEGINNING OF SWAP AREA
UDBFSV:	.=.+4	;PALCE TO SAVE THE DISK BUFFERS DURING GC
UDSKAD:	0	;RANDOM DISK STORAGE AREA
UASIZE:	0	;USER ARRAY SIZE

LUBLK==.-UBLK
L==LUBLK

	.=.+<MNUSRS*LUBLK>
SYSIDX==MNUSRS*LUBLK
	.STITL SYSTEM DISPATCH TABLE (BYTE ONE)

;FLAG DEFINITIONS
FSF==200	;SPECIAL INPUT
FOF==100	;SPECIAL OUTPUT
FQF==20		;QUOTING
SEPF==4		;SEPARATOR
WSF==2		;WORD SEPARATOR
NNUMF==40	;NOT A NUMBER
OPERF==10	;OPERATOR

DTBL:
.BYTE	NNUMF,FOF!NNUMF		;^@	;^A ECHOES AS CR
.BYTE	FSF!NNUMF,FSF!NNUMF	;^B IS CONVERTED TO %
				;^C COPIES NEXT CHARACTER
.BYTE	FSF!NNUMF,NNUMF		;^D DELETES NEXT CHARACTER	;^E
.BYTE	NNUMF,FSF!FOF!NNUMF	;^F	;^G BREAK
.BYTE	FOF!NNUMF,FOF!SEPF!WSF!NNUMF	;^H BACKSPACE	;^I TABULATE
.BYTE	FOF!SEPF!WSF!NNUMF,FOF!SEPF!WSF!NNUMF	;^J LINE FEED
				;^K
.BYTE	FOF!SEPF!WSF!NNUMF,FSF!FOF!SEPF!WSF!NNUMF	;^L FORM FEED
				;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	FSF!NNUMF,NNUMF		;^N GET NEXT WORD	;^O
.BYTE	NNUMF,FSF!NNUMF		;^P	;^Q SUPER-QUOTE
.BYTE	FSF!NNUMF,FSF!NNUMF	;^R COPY REST OF LINE
				;^S SKIP NEXT WORD
.BYTE	NNUMF,NNUMF		;^T	;^U
.BYTE	NNUMF,FSF!NNUMF		;^V	;^W ERASE LAST WORD
.BYTE	FSF!NNUMF,FSF!NNUMF	;^X CLARIFY INPUT
				;^Y EDIT PREVIOUS LINE
.BYTE	FSF!NNUMF,NNUMF		;^Z DESTROY INPUT BUFFER
				;^[ MAYBE ALTMODE
.BYTE	NNUMF,NNUMF		;^\	;^]
.BYTE	NNUMF,NNUMF		;^^	;^_ ANY BETTER IDEAS FOR THEM?
.BYTE	SEPF!WSF!NNUMF,NNUMF!SEPF!OPERF	;SP	;! COMMENT?
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;"	;# ACTION OF
.BYTE	NNUMF,NNUMF		;$	;% PRINTS AS SPACE IN STRINGS
.BYTE	NNUMF,NNUMF!OPERF	;&	;' (MAYBE LE)
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;( ARITHMETIC GROUPING
				;) DITTO
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;* MULTIPLY	;+ ADD
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;,	;- SUBTRACT
.IIF NZ FPPF, .BYTE	0,SEPF!NNUMF!OPERF
.IIF Z FPPF, .BYTE	NNUMF,SEPF!NNUMF!OPERF	;.	;/ DIVIDE
.BYTE	0,0	;0	;1
.BYTE	0,0	;2	;3
.BYTE	0,0	;4	;5
.BYTE	0,0	;6	;7
.BYTE	0,0	;8.	;9.
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF	;: THING OF	;; 
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;<	;=
.BYTE	SEPF!NNUMF!OPERF,NNUMF	;>	;?
.BYTE	NNUMF,NNUMF		;@	;A
.BYTE	NNUMF,NNUMF		;B	;C
.IIF NZ FPPF,	.BYTE	NNUMF,0
.IIF Z FPPF, .BYTE	NNUMF,NNUMF		;D	;E
.BYTE	NNUMF,NNUMF		;F	;G
.BYTE	NNUMF,NNUMF		;H	;I
.BYTE	NNUMF,NNUMF		;J	;K
.BYTE	NNUMF,NNUMF		;L	;M
.IIF NZ FPPF,	.BYTE	0,NNUMF
.IIF Z FPPF,	.BYTE	NNUMF,NNUMF		;N	;O
.BYTE	NNUMF,NNUMF		;P	;Q
.BYTE	NNUMF,NNUMF		;R	;S
.BYTE	NNUMF,NNUMF		;T	;U
.BYTE	NNUMF,NNUMF		;V	;W
.BYTE	NNUMF,NNUMF		;X	;Y
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF	;Z	;[
.BYTE	SEPF!NNUMF!OPERF,FSF!FQF!SEPF!WSF!NNUMF	;\ MODULO	;]
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;^	
				;_ MAKE
.BYTE	NNUMF,NNUMF		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	NNUMF,NNUMF		;b LOWER CASE	;c LOWER CASE
.BYTE	NNUMF,NNUMF		;d LOWER CASE	;e LOWER CASE
.BYTE	NNUMF,NNUMF		;f LOWER CASE	;g LOWER CASE
.BYTE	NNUMF,NNUMF		;h LOWER CASE	;i LOWER CASE
.BYTE	NNUMF,NNUMF		;j LOWER CASE	;k LOWER CASE
.BYTE	NNUMF,NNUMF		;l LOWER CASE	;m LOWER CASE
.BYTE	NNUMF,NNUMF		;n LOWER CASE	;o LOWER CASE
.BYTE	NNUMF,NNUMF		;p LOWER CASE	;q LOWER CASE
.BYTE	NNUMF,NNUMF		;r LOWER CASE	;s LOWER CASE
.BYTE	NNUMF,NNUMF		;t LOWER CASE	;u LOWER CASE
.BYTE	NNUMF,NNUMF		;v LOWER CASE	;w LOWER CASE
.BYTE	NNUMF,NNUMF		;x LOWER CASE	;y LOWER CASE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;Z LOWER CASE	;LEFT BRACE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;VERTICAL BAR	;RIGHT BRACE
.BYTE	NNUMF,FSF!NNUMF		;TILDE	;RUBOUT
	.STITLE SYSTEM DISPATCH TABLE (BYTE TWO)
;NUMBERS POINT TO OTHER TABLES
;$ POINTS TO SYSTEM OBLIST

DTBL2:
.BYTE	0,0		;^@ 			;^A
.BYTE	36,0		;^B BECOMES %, PRINTS AS SPACE IN STRINGS
			;^C COPY NEXT CHARACTER
.BYTE 2,0		;^D DELETES NEXT CHAR	;^E
.BYTE	0,4		;^F 			;^G BREAK
.BYTE	2,10		;^H BACKSPACE		;^I TABULATE
.BYTE	12,14		;^J LINE FEED		;^K 
.BYTE	16,6		;^L FORM FEED
			;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	10,0		;^N GET NEXT WORD		;^O
.BYTE	0,12		;^P 			;^Q SUPER-QUOTE
.BYTE	14,16		;^R 			;^S SKIP NEXT WORD
.BYTE	0,0		;^T	;^U
.BYTE	0,20		;^V	;^W ERASE LAST WORD
.BYTE	22,24		;^X CLARIFY INPUT	;^Y
.BYTE	26,0		;^Z DESTROY INPUT BUFFER
			;^[ MAYBE ALTMODE
.BYTE	0,0		;^\	;^]
.BYTE	0,0		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	0,EXCL$		;SP	;! COMMENT?
.BYTE	0,HASH$		;"	;# ACTION OF
.BYTE	0,0		;$	;% PRINTS AS SPACE IN STRINGS
.BYTE	0,0		;&	;' (MAYBE LE)
.BYTE	LP$,RP$		;( ARITHMETIC GROUPING	;) DITTO
.BYTE	PRD$,PLU$	;* MULTIPLY	;+ ADD
.BYTE	0,MIN$		;,	;- SUBTRACT
.BYTE	0,DIV$		;.	;/ DIVIDE
.BYTE	0,0		;0	;1
.BYTE	0,0		;2	;3
.BYTE	0,0		;4	;5
.BYTE	0,0		;6	;7
.BYTE	0,0		;8.	;9.
.BYTE	DOTS$,0		;: THING OF	;; 
.BYTE	LSS$,EQL$	;<	;=
.BYTE	GTR$,0		;>	;?
.BYTE	0,0		;@	;A
.BYTE	0,0		;B	;C
.BYTE	0,0		;D	;E
.BYTE	0,0		;F	;G
.BYTE	0,0		;H	;I
.BYTE	0,0		;J	;K
.BYTE	0,0		;L	;M
.BYTE	0,0		;N	;O
.BYTE	0,0		;P	;Q
.BYTE	0,0		;R	;S
.BYTE	0,0		;T	;U
.BYTE	0,0		;V	;W
.BYTE	0,0		;X	;Y
.BYTE	0,32		;Z	;[
.BYTE	BKSL$,34	;\ MODULO	;]
.BYTE	0,BKAR$		;^ 		;_ MAKE
.BYTE	0,0		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	0,0		;b LOWER CASE	;c LOWER CASE
.BYTE	0,0		;d LOWER CASE	;e LOWER CASE
.BYTE	0,0		;f LOWER CASE	;g LOWER CASE
.BYTE	0,0		;h LOWER CASE	;i LOWER CASE
.BYTE	0,0		;j LOWER CASE	;k LOWER CASE
.BYTE	0,0		;l LOWER CASE	;m LOWER CASE
.BYTE	0,0		;n LOWER CASE	;o LOWER CASE
.BYTE	0,0		;p LOWER CASE	;q LOWER CASE
.BYTE	0,0		;r LOWER CASE	;s LOWER CASE
.BYTE	0,0		;t LOWER CASE	;u LOWER CASE
.BYTE	0,0		;v LOWER CASE	;w LOWER CASE
.BYTE	0,0		;x LOWER CASE	;y LOWER CASE
.BYTE	0,32		;z LOWER CASE	;{ OPEN BRACE
.BYTE	0,34		;| VERTICAL BAR
			;} CLOSE BRACE
.BYTE	0,30		;~ TILDE	;RBO	RUBOUT

.IFNZ LPF
LPBUF1:	.BLKW 512.
LPBUF2:	.BLKW 512.
MNLPB==40.
BKTBL:	.BLKW MNLPB
LPFLG:	0
FLGTH:	0
LSTBKL:	0
BKSTGO:	0
LPBUFF:	0
PUTLPB:	0
NOWLPR:	0
LPIUFG==4
LPB1FG==1
LPB2FG==2
LPB1MX==0
LPB2MX==0
.ENDC
.STITL TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI

;TO DO:
;FIX INTERRUPT MACROS
;HARDWARE INITIALIZATION
;MODEM AND ERROR CODE
;SYSTEM CODE
;MULTIPLE DM
;PGEN1
;DING

	VERN==VERN+%FNAM2

NMODEM==1
.STITL TELETYPE MACROS

.MACR TBK
	.BLKW	NLTY
.ENDM
.STITL TELETYPE DISPATCH TABLES--DATA SPACE

;ALL FOLLOWING CODE CAN BE IN DATA SPACE ONLY!!!!!!!!!!


;DISPATCH TABLE FOR SPECIAL INPUT CHARS WITH EFFECT ON TYPEOUT LEVEL
TIICTB:	TOICC	;^C COPY NXT CHAR FROM EDIT TO TYI BUFFER
	TOICD	;^D DELETE NEXT CHAR FROM EDIT BUFFER
	TICG
	TOICM	;^M POSSIBLE END OF LINE
	TOICN	;^N COPY NEXT WD FROM EDIT TO TYI BUFFER
	TOICQ	;^Q JUST ECHO
	TOICR	;^R COPY REST OF EDIT BUFFER TO TYI BUF
	TOICS	;^S SKIP NXT WD IN ED. BUF.
	TOICW	;^W RUB OUT UP TO PREVIOUS WD SEPERATOR
	TOICX	;^X CLARIFY INPUT
	TOICY	;^Y RECOVER PREVIOUS LINE
	TICZ
	TOIRB	;RUBOUT
	TOIOB	;[ INCREMENT LIST COUNT
	TOICB	;] DECREMENT LIST COUNT
	TICB


;DISPATCH TABLE FOR CHARS SPECIAL ON OUTPUT
;(HAVE FOF ON IN DTBL(CHARACTER)
TOOCTB:	TOOCA	;^A PRINTS AS C.R.
	TOOCH	;^H BACKSPACE, DECREMENTS CHARNO
	TOTYOC	;^G PRINTS AS SELF
	TOOCM	;^M PRINTS AS CR, LF
	TOOCI	;^I (TAB) SPACES TO NEXT TAB STOP
	TOTYOC	;^J (LINEFEED) PRINTS AS SELF
	TOTYOC	;^K (VERTICAL TAB) PRINTS AS SELF
	TOTYOC	;^L (FORMFEED) PRINTS AS SELF
.IFNZ NTVS
LKBTAB:
.BYTE 0,'+,4,'(
.BYTE '),0,0,0
.BYTE 0,33,11,14
.BYTE 0,15,0,0
.BYTE '-,0,0,0
.BYTE 0,0,0,'/
.BYTE '*,177,0,'_
.BYTE 7,0,0,0
.BYTE 40,'1,';,'3
.BYTE '4,'5,'7,':
.BYTE '9,'0,'8,'<
.BYTE ',,'=,'.,'?
.BYTE '0,'1,'2,'3
.BYTE '4,'5,'6,'7
.BYTE '8,'9,'','"
.BYTE ',,'<,'.,'!
.BYTE '2,'A,'B,'C
.BYTE 'D,'E,'F,'G
.BYTE 'H,'I,'J,'K
.BYTE 'L,'M,'N,'O
.BYTE 'P,'Q,'R,'S
.BYTE 'T,'U,'V,'W
.BYTE 'X,'Y,'Z,'[
.BYTE '],'[,'6,'=
.BYTE '>,'a,'b,'c
.BYTE 'd,'e,'f,'g
.BYTE 'h,'i,'j,'k
.BYTE 'l,'m,'n,'o
.BYTE 'p,'q,'r,'s
.BYTE 't,'u,'v,'w
.BYTE 'x,'y,'z,'%
.BYTE '],'$,'>,0
.ENDC
.STITL TELETYPE VARIABLES

NLTY==NTTY+<5*NTBOX>	;TBOX +4 DEVICES
NMXTY==NTBOX
NPORTS==NLTY+<20*NDM>-NDMTY	;DON'T DUPLICATE DM11 TTYS

;STANDARD DEVICE REGISTER BITS
%ER==1_15	;ERROR
%RDY==1_7	;READY
%INT==1_6	;INTERRUPT ENABLE
%CRDT==1_2	;CARRIER DETECT
%ENB==1		;ENABLE
%DTRDY==1	;DATA TERMINAL READY

TBKCH:	7	;^G BREAK TO LEVEL 0
TBKCHL:	32	;^Z BREAK TO LEVEL N
LINEL:	ZEPT NLTY,70.	;LINE LENGTH

OMXRES=.-NFTBOX
	OMXNUL==OMXRES+1	;RH--RESET CHAR, LH--NULL CHAR
	.BYTE 21,0	;TBOX (DC0)
	.BYTE 0,40	;TURT 1
	.BYTE 0,40	;TU 2
	0	;MBX
	.BYTE 0,21	;DUMMY

TUDN:	ZEPT NTUR,NFTUR+<2*.RPCNT>

	.IFNZ NPLOT
.IIF NZ AI,	PLTDVN=NFTUR+2	;THIS HACK UNTIL WE HOOK 2 CONTROLLERS TO THE SYSTEM
.IIF NZ GUY,	PLTDVN=NFTUR+6	;THIS HACK UNTIL WE HOOK 2 CONTROLLERS TO THE SYSTEM

	.ENDC
.IFNZ NTVS
TVSCJT:	.WORD 0,0,0,0,0,0,0,0
	.WORD 0,0,TVLF,TVSPDN,0,TVCR,0,0
	.WORD 0,0,0,0,0,0,0,0
	.WORD TVSPF,TVSPB,TVSPU,0,0,0,TVCEOL,TVSPBE
UBR:	0	;IF YOU WANT THE UBR RESTORED YOU BETTER PUT IT HERE
TVKBS:	ZEPT NTVCHN,-1
TVUSE:	ZEPT NTVS,-1
TVLOGO:	ZEPT NTVCHN,3*60.
TVCJTB:	.IRPC X,<01234567>
	CHAR'X
	.ENDM
FONTAR:	0
FONTDR:	77406
TVCRM1:	176000
	1760
	17
	37400
	374
	3
	7700
	77
TVCRM2:	0
	0
	140000
	0
	0
	170000
	0
	0
TVEOLM:	-1
	1777
	17
	37777
	377
	3
	7777
	77
TVSPFK:	2
	0
	0
	2
	0
	2
	0
	0

.ENDC

;USE TELETYPE TABLE--LOGICAL TTY FOR EACH USER
UTYTB:	ZEPT NTY,NFTY
	ZEPT NTVS,NFTV+<2*.RPCNT>
	ZEPT MNUSRS-NTVS-NTY,NFDMTY+<2*.RPCNT>

.IFZ CJR

TYRS:	;RECEIVE VECTORS FOR EACH TTY
	TKS	;CONSOLE TTY
	DC1RS	;DC1
.IIF Z DHON,	ZEPT 20,DM0CSR	;DM11 TTYS
.IIF NZ DHON,	ZEPT 20,DH0SCR
	ZEPT NTVS,0
 	DC0RS	;DC0
	ZEPT 4*NMXTY,-1	;PSEUDO TTYS

TYPTYP:		;PHYSCIAL TTY TYPE
	TPMODM==100000	;MODEM
	TPMPX==40000	;MULTIPLEXOR
	TPPTY==20000	;PSEUDO TTY OR MULTIPLEXEE
	TPDM==10000	;DM11 TTY
	TPTV==4000	;TV TTY
		;RH=CPS/10.
.IIF NZ AI,	3		;CONSOLE TTY
.IIF NZ GUY,	1
	3		;DC1, MODEM
	ZEPT 20,TPDM!3	;DM11S
	ZEPT NTVS,TPTV	;TVS KEYBOARDS
	TPMPX!12	;DC0, THORTON BOX
	TPPTY!3		;TURTLE 1
	TPPTY!3		;TURTLE 2
	TPPTY!3		;MUSIC BOX
	TPPTY!3		;DUMMY

TILTTY:		;RH--LOGICAL TTY # OF EACH PHYSICAL TTY
		;-1 IF ILLOGICAL
		;LH--MPXR #, -1 IF NOT MPXED
	ZEPT NTY+NKLTY+NDCTY+NDPTY+NDMTY,<
	.BYTE 2*.RPCNT,-1		;CONS, DCS, KLS AND DM11 TTYS
	>
	ZEPT 20-NDMTY,-1	;REST OF DMS
	ZEPT NTVS,<
	.BYTE NFTV+<2*.RPCNT>,-1
>
	ZEPT NTBOX,<		;THORTON BOXES
	.BYTE NFTBOX+<2*.RPCNT>,-1
	>
	ZEPT 4*NTBOX,<			;LOGICAL DEVICES
	.BYTE NFTUR+<2*.RPCNT>,NFTBOX+<2*<.RPCNT_-2>>
	>

.IFF

PDMAP:	;LOGICAL TTY # OR MPXR OF EACH PHYSICAL DEVICE
	;-1 IF UNASSIGNED

	0	;CONSOLE
	2	;DC
	0	;DC--MPXR 0
	ZEPT NDMTY,4+<2*.RPCNT>	;DM'S
	ZEPT <20*NDM>-NDMTY,-1	;UNUSED DM'S

LDMAP:	;PHYSICAL TTY OR MPXR OF EACH LOGICAL DEVICE OR MPXR

	0	;CONSOLE
	2	;DC
	ZEPT NLTY-2,6+<2*.RPCNT>
	ZEPT 4,NFTBOX	;MPXR 0
	4	;MPXR PHYSICAL DEVICE

PDWORD:	;FOR EACH PHYSICAL TTY

	TPMPX==100000	;MPXR
	TPCON==40000	;CONSOLE
	TPDC==20000î	;DC
	TPKL==10000	;KL
	TPDM==4000	;DM

	TPCON
	TPDC
	TPMPX!TPDC
	ZEPT <20*NDM>,TPDM	;DM'S

LDWORD:
MPWORD:	;FOR EACH LOGICAL DEVICE OR MPXR
	;TPMPX SET UP ABOVE

	TPPTY==40000	;MULTIPLEXEE
	ZEPT NTTY,TPPTY
	ZEPT NTUR,TPPTY
	ZEPT NMBX,TPPTY
	ZEPT NPLOT,TPPTY
	;MULTIPLEXORS
	ZEPT NTBOX,TPMPX

PDRS:	;ADDRESS OF RECEIVE STATUS REGISTER FOR PHYS DEV

	TKS	;CONSOLE
	DC1RS
	DC0RS
.IIF Z DHON,	ZEPT 20,DM0CSR	;DM
.IIF NZ DHON,	ZEPT 20,DH0SCR

.ENDC

TYCKBP:	ZEPT NLTY,TYCKBK+<.RPCNT*10>	;PNTRS TO CLOCK BLOCK
TYCKBK:	ZEPT NLTY,<
	.BLKW 3	;CLOCK BLOCK	(3 WDS FOR EACH MODEM)
	2*.RPCNT	;TTY INDEX (FOR CLOCK LEVEL STUFF)
>


;LOGICAL DEVICE NAME ARRAY
;YOU CAN CALL TYO WITH ONE OF THESE  NAMES
LDEVAR:
	$$TTY
	-1
	$$MUSIC
	MBDN
	$$TUR1
	NFTUR
	$$TUR2
.IFZ GUY
	1	;HOWEVER, WE HAVE A PLOTTER PLUGGED IN NOW
.IFF
	NFTUR+2
.IFT
	$$LIGHT
	NFTUR+6
.ENDC
	$$PLOT
	PLTDVN
	0

;POINTED TO BY LOGICAL DEVICE NAME ARRAY
$$TTY:	TEXT ^/TTY/
$$MUSIC:	TEXT ^/MUSIC/
$$TUR1:	TEXT ^/TUR1/
$$TUR2:	TEXT ^/TUR2/
$$LIGHT:	TEXT ^/LIGHT/
$$PLOT:	TEXT ^/PLOTTER/

TTYU:	TURUSE==.+NFTUR
	ZEPT NLTY,-1	;USER FOR EACH TTY
TIPTTY:	TBK	;FROM TILTTY
MXNUM==TIPTTY+1	;MXPR NUM LH, -1 IF NOT MPXED
TTYTP:	TBK	;TTY TYPE
OTTYST:	.BLKW NLTY
TTYST:	ZEPT NLTY,TIMAGE!TIMAGI	;TTY STATUS
	TICLKQ==100000	;ENTRY ON CLKQ
	TILIPM==40000	;LINE INPUT MODE
	TICVM==20000	;CONVERT CASE MODE
	TIECM==10000	;ECHO MODE (INPUT)
	TIEDM==4000	;EDIT MODE
	TIRBM==2000	;RUBOUT MODE
	TIMAGE==1000	;IMAGE MODE (OUTPUT)
	TIMAGI==400	;INPUT IMAGE MODE
	TOTRAN==200	;CURRENTLY TRANSMITTING
	TIQF==100	;QUOTE NEXT CHAR
	TIBR==40	;BREAK TYPED BUT NOT PROCESSED BY USER
	TIRST==20	;RESET INPUT ON INTERRUPT LEVEL
	PTBF==4
.IIF NZ DPHK,	DPF==10

TIRCV:	ZEPT NLTY,TYRCV	;ADDRESS TO JSR TO WITH RECEIVED CHARACTER

.IIF NZ AI,	TIQSZ==400.
.IIF NZ GUY,	TIQSZ==400.

	;INPUT BUFFER POINTERS
TIBSZ==10.
TIBN:	TBK
TIBI:	ZEPT NLTY,TIBB
TIBO:	ZEPT NLTY,TIBB

	;INPUT Q POINTERS
TTYAR:	TBK
TIQI:	ZEPT NLTY,TIQM	;PNTR TO WHERE NEXT CHAR GOES IN
TIQO:	ZEPT NLTY,TIQM	;PNTR TO WHERE NEXT CHAR COMES OUT
TIQTO:	ZEPT NLTY,TIQM	;PNTR TO WHERE TYO IS PROCESSING
TTYBBL==<<<TIQSZ+TOQSZ+TIBSZ>!77>+1>_-6
TTYDR==<<TTYBBL-1>_8>!6


TITQN:	TBK
TITQ==TIQM+TIQSZ-1

TIEQTN:	TBK
TIQTON:	TBK	;# OF CHARS FOR TYO TO PROCESS
TIQN:	TBK	;# OF CHARS IN INPUT Q
TIBC:	TBK	;# OF UNMATCHED ['S IN TYI BUFFER
MXNCH==TIQN	;DOUBLES AS IMX DEVICE Q

	;EDIT Q PNTRS
TIEQN:	TBK	;# OF CHARS IN EDIT Q
TIEBC:	TBK	;# OF UNMATCHED ['S FROM EDIT BUFFER

TIEQTO:	ZEPT NLTY,TITQ
TIEQO:	ZEPT NLTY,TITQ
TOTSR:	TBK	;ADDR OF TRANSMIT STATUS REGISTER
TOGOC:	ZEPT NLTY,TYGOC	;ADDR OF ROUTINE TO GET OUTPUT CHARS(MXGOC OR TYGOC)
	TOQSZ==100
	;OUTPUT QUEUE POINTERS
TOQI:	ZEPT NLTY,TOQM	;PNTR TO WHERE NEXT CHAR GOES IN
TOQO:	ZEPT NLTY,TOQM	;PNTR TO WHERE NEXT CHAR COMES OUT
TOQN:	TBK	;# OF CHARS IN Q
TOTN==TOQN

CHARNO:	TBK	;# OF CHARS FROM LEFT SIDE OF PAGE
TOPAD:	TBK	;# OF CHARS TO PAD

TOIPC:	TBK	;SAVED PC (FOR ECHO)
TOISVA:	TBK	;SAVED A

TOPC:	TBK	;SAVED PC (FOR OUTPUT)
TOSVC:	TBK	;SAVED C
TOSVD:	TBK	;SAVED D

DMMAX==3	;MAXIMUM # CHARS TO SEND TO EACH DM11 TELETYPE
DMBIT==.-NFDMTY
	ZEPT 20,1_.RPCNT
DMBUF==.-NFDMTY
	ZEPT 20,DMOBUF+<DMMAX*.RPCNT>	;PNTR TO DMOBUF
DHNUMBR==.-NFDMTY
	ZEPT 20,.RPCNT
TVLINE=.-NFTV
	ZEPT NTVS,0
TVHIGH=.-NFTV
	ZEPT NTVS,38.
TVBLNK==.-NFTV
	ZEPT NTVS,-1	;0=> NO CURSOR, POS=> CURSOR ON, NEG=> CURSOR OFF
TVCRPS=.-NFTV
	ZEPT NTVS,0
TVCRLN=.-NFTV
	ZEPT NTVS,0
TVLNNO==.-NFTV
	ZEPT NTVS,0
TVSCRL==.-NFTV
	ZEPT NTVS,0

DMOBUF:	.BLKB DMMAX*16.*NDM	;WHERE DM11 SENDS CHARS FROM
TTP:	0

MXICH==.-MXICMN	;DEVICE FOR EACH IDENTIFIER CHAR
	.BYTE 24,26,30,32
TBCCHR:	.WORD 117,112,105,40

TIANTM:	500.	;TIME TO WAIT FOR CARRIER BEFORE HANGING UP
;TIHGTM:	250.	;TIME TO HANG UP FOR
PURE==<.!17777>+1
.IIF LE PURE-20000,PURE=40000
PUREAR=KDAR+<PURE/10000>
PUREDR=KDDR+<PURE/10000>
	DISPAR=PUREAR+6
	DISPDR=PUREDR+6
	DISPPG==PURE+60000
	DISPAR=PUREAR+6
	DSLOT=DISPPG
	TEMPAR=DISPAR
	TEMPDR=DISPDR
	TEMPPG==DISPPG
	SMLFNT==PURE+40000
	BIGFNT==SMLFNT+400
TIQM==TEMPPG
TOQM==TIQM+TIQSZ
TIBB==TOQM+TOQSZ
TIQLM==TIQM+TIQSZ
TOQLM==TOQM+TOQSZ
TIBT==TIBB+TIBSZ
	.STITL TELETYPE CODE USER LEVEL
.TTYP:	JSR PC,UGTTYG
	BR TTYP1

TTYP:	MOV USER,U
	MOV UTTY(U),E
TTYP1:	TST TIBN(E)	;ANY CHARACTERS YET?
	BNE .+6		;YES RETURN TRUE
	JMP RTFALS
	JMP RTTRUE

;CTYI--OUTPUTS (TO LOGO USER) CHAR FROM USERS TTY
CTYI:	MOV	USER,U
	MOV	UTTY(U),E
	BR	UGTYI2

UGTTYG:	POPS	E	;DEVICE SPEC (NAME OR NUMBER)
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
	JSR	PC,OPEN1
	RTS PC

;UGTYI-- TYI N OUTPUTS A CHAR FROM TTY N
UGTYI:	JSR PC,UGTTYG
	MOV	USER,U
	CMP	UTTY(U),E
	BNE	UGTYI1	;BR IF NOT USER'S CONSOLE
UGTYI2:	BIS	#TIMAGI,TTYST(E)	;IMAGE INPUT AND OUTPUT
	BIC	#TILIPM,TTYST(E)	;CHAR INPUT MODE
UGTYI1:	JSR	PC,GTYI	;GET CHAR IN D
	MOV	D,B
	JMP	R1NARG

;CTYO--PRINTS CHAR ON USERS TTY
CTYO:	JSR	PC,G1NARG	;B _ CHAR
	MOV	USER,U
	MOV	UTTY(U),E
	BR	TYO1

;UGTYO-- TYO N M SENDS CHAR M TO TTY N. N MAY BE NAME OR NUMBER.
UGTYO:	JSR	PC,G1NARG	;B _ CHAR
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
TYO1:	JSR	PC,OPEN1	;MAKE SURE TTY OK
	MOV	B,D	;CHAR
	BIT	#TIMAGE,TTYST(E)	;IS TTY IN IMAGE MODE?
	BNE	TYO2	;BR IF YES
	BIS	#200,D	;ELSE SPECIFICALLY IMAGE MODE THIS CHAR
TYO2:	JSR	PC,GTYO	;SEND IT
RTSPC:	SEZ
	RTS	PC

;MUTYO -- LIKE TYO, EXCEPT TO MUSIC BOX SPECIFICALLY
;ALSO TAKES VARIABLE ARGS, AND CONVERTS ARGS TO MUSIC BOX NOTES, ETC.
MUTYO:
	EXCH	(P),2(P)
	JSR	PC,REVS
	MOV	#MBDN,E
	JSR	PC,OPEN1
;LOOP,  PLACING EACH CHAR IN TYO BUFFER
	SPOP	C	;NUMBER OF ARGS
	BEQ	RTSPC	;0 ARGS (OH WELL)
MUTLP:	JSR	PC,G1NARG	;B _ CHAR
	MOV	B,A
	JSR	PC,SINGNO	;NORMALIZES MIDDLE C TO 0. CHECKS NOTE IN RANGE.
	MOV	A,D
	JSR	PC,GTYO
	SOB	C,MUTLP
	SEZ
	RTS	PC


;MUCTRL -- SENDS CONTROL TYPE INFO TO MUSIC BOX
MUCTRL:
	MOV	#MBDN,E
	JSR	PC,OPEN1
	JSR	PC,G1NARG	;B _ WHICH CONTROL FUNCTION
	MOV	B,D
	BLT	MUCERR	;NUMBER MUST BE BETWEEN 0,33
	CMP	D,#33.
	BLE	MUC1
MUCERR:	ERROR+WTIB	;INVALID MUSIC BOX CONTROL FUNCTION
;ARG IS DECODED AS FOLLOWS:
;	TOP DIGIT IS SILENCE CONTROL
;	BOTTOM DIGIT IS LOADING CONTROL
;	(NOTE -- BOTH DIGITS SHOULD BE BETWEEN 0,3)
MUC1:	CLR	C
	DIV	#10.,C	;C _ TENS, D _ ONES
	ASH	#4,C	;SHIFT INTO BITS 6,5
	BIC	#177774,D	;LEAVE ONLY BOTTOM 2 BITS
	BIS	C,D
	BIT	#40,D	;BIT 6 MUST NOT EQUAL BIT 7 (GROAN)
	BNE	MUC2	;BR IF BIT 6 = 1
	BIS	#100,D	;ELSE MAKE BIT 7 = 1
MUC2:	MOV	D,MUCWRD	;KEEP CONTROL WORD CURRENT
	JSR	PC,MUCTYO	;SENDS OUT TRAP CHAR, ETC. TOO
	SEZ
	RTS	PC

;CALL WITH CONTROL CHARACTER IN D.
;FIRST TYOS THE MUSIC BOX TRAP CHAR,
;THEN TYOS THE CHAR IN D
;	(NOTE THAT THIS ISN'T A PRIMITIVE)
MUCTYO:	SPUSH	D
	MOV	#MBTRAP,D	;HARDWARE CATCHES THIS
	SPUSH C
	MOV #PMBOX,C
	JSR PC,TBTYO
	SPOP C
	SPOP	D
	JSR	PC,GTYO
	RTS	PC

TBINIT:	SPUSH A
	SPUSH B
	SPUSH D
	SPUSH E
	SPUSH U
	MOV #NPTBOX,A
	MOV #PTBOX0,B
	TST C
	SXT U
	BPL TBINT1
	NEG C
TBINT1:	CMP USER,(B)+
	BEQ TBINT2
	ADD #4*2,B
	SOB A,TBINT1
	BR TBINSZ
TBINT2:	MOV #4,A
	SPUSH B
TBINT3:	CMPB C,(B)
	BEQ TBINT4
	TST (B)+
	SOB A,TBINT3
	SPOP B
TBINSZ:	SPOP U
	SPOP E
	SPOP D
	SPOP B
	SPOP A
	SEZ
	RTS PC
TBINT4:	TST U
	BMI TBINT5
	TST (B)
	BPL TBINT5
	SPOP B
	MOV USER,U
	MOV UTTY(U),E
TBINCZ:	SPOP U
	SPOP D
	SPOP D
	SPOP B
	SPOP A
	CLZ
	RTS PC
TBINT5:	MOV USER,U
	MOV UTTY(U),E
	SPUSH B
	MOV #21,B
	JSR PC,TYO1
	MOV (P),B
	SUB 2(P),B
	MOV TBCCHR(B),B
	JSR PC,TYO1
	SPOP B
	BIS #100000,(B)
	MOV (B),C
	BIC #TBMASK,C
	CMP C,#CONSO
	BNE TBINT6
	MOV OTTYST(E),TTYST(E)
	BIS #TIRST,TTYST(E)
	BR TBINT7	;DESTROY OLD USER
TBINT6:	BIS #TIMAGE,TTYST(E)
TBINT7:	SPOP C
	MOV #4,D
TBINT8:	TST (C)
	BGE TBINT9
	CMP C,B
	BEQ TBINT9	;DONT CLEAR THE ONE WE JUST SET
	BIC #100000,(C)
TBINT9:	TST (C)+
	SOB D,TBINT8
	BR TBINCZ



;UTYCK RETURNS IF VALID TTY, LOOSE OTHERWISE
UTYCK:	CMP	E,#2*NLTY
	BGE	UTYCL	;TOO HIGH TTY #
	BIT	#100001,E
	BNE	UTYCL	;BR IF TTY NEG OR ODD
	TST	TTYU(E)
	BLT	UTYCK1	;NOT IN USE
	CMP	TTYU(E),USER
	BNE	UTYCL1	;BR IF IN USE BY SOMEONE ELSE
UTYCK1:	RTS	PC

UTYCL:	ERROR+TDE	;NOT A VALID TTY #
UTYCL1:	ERROR+DIU	;DEVICE IN USE

MYSPEE:	MOV USER,U
	MOV UTTY(U),E
MYSPE1:	JSR PC,G1NARG
	BIT #TPDM,TYPTYP(E)
	BEQ UTYCL
	CMP #16,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASH #6,B
	MOV B,C
	ASH #4,B
	BIS B,C
	BIS #3,C
	SPL 7
	BIC #17,DH0SCR
	BIS DHNUMB(E),DH0SCR
	MOV C,DH0LPR
	SPL 0
	SEZ
	RTS PC
HISSPE:	JSR PC,CKSST
	JSR PC,G1NARG
	CMP #NLTY,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASL B
	MOV B,E
	BR MYSPE1
;DEVICE NUMBER FROM SPEC
;	CALL WITH POINTER TO EITHER NUMBER OR NAME IN E
;	RETURNS WITH TTY NUMBER IN E , OR ERROR+DNA IF INVALID NAME
DEVNUM:
	PUSH	A
	SPUSH	B
	MOV	#SNUM,A	;IS ARG A NUMBER?
	MOV	E,B
	JSR	PC,CONVERT
	BEQ	DNUM1	;BR IF NOT NUMBER
	MOV	B,E
	ASL	E
	BR	DNUM9

;NOT A NUMBER.  HOPEFULLY THE ARG IS A STRING
DNUM1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BEQ	DNUM8	;BR IF NOT STRING, EITHER
	MOV	B,E
	JSR	PC,DEVNAM
	BEQ	DNUM8	;BR IF NOT VALID NAME
DNUM9:	JMP	RETB	;POP A,B AND RETURN
DNUM8:	PUSHS	E	;POINTER TO THE INVALID NAME
	ERROR+DNA	;INVALID DEVICE NAME


;CALL WITH POINTER TO DEVICE NAME IN E
;RETURNS WITH DEVICE NUMBER IN E IF VALID, AND CLZ'S
DEVNAM:	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	SPUSH	#LDEVAR	;LOGICAL DEVICE NAME ARRAY
DNAM1:	MOV	@(P),C	;POINTER TO NEXT TEXT STRING
	BEQ	DNAM9	;BR IF NO MORE STRINGS
	MOV	4(P),B	;POINTER TO ARG
	JSR	PC,EQ.TXT
	BNE	DNAMEQ	;BR IF ARG = CURRENT TEXT STRING
	ADD	#4,(P)	;POINT TO NEXT STRING POINTER
	BR	DNAM1
DNAMEQ:	ADD	#2,(P)	;POINT TO TTY NUMBER FOR THIS DEVICE
	MOV	@(P)+,E
	BGE	DNAM2	;-1 IS FLAG FOR "TTY".  BR IF NOT "TTY"
	MOV	USER,E
	MOV	UTTY(E),E
DNAM2:	BIT	#1,E	;ODD MEANS THE DEVICE ISN'T ATTACHED
	BNE	DNAM9	;BR IF NOT ATTACHED
	SPOP	F	;RESTORE F
	TST	(P)+	;DON'T RESTORE E !!
	JMP	SRETD	;CLZ RETURN
;NO MORE STRINGS LEFT. IE ARG ISN'T VALID DEVICE NAME
DNAM9:	TST	(P)+	;POP OFF LDEVAR
	JMP	RETF	;RESTORE ALL AC'S AND SEZ RETURN



;OPEN--ASSIGNS TTY TO USER IF VALID TTY #
OPEN:	JSR	PC,G1NARG
	ASL B
	MOV	B,E
OPEN1:	JSR	PC,UTYCK	;RETURN IF VALID TTY
	MOV	USER,TTYU(E)	;ASSIGN TTY TO CURRENT USER
	RTS	PC


;CLOSE--CLOSES TTY IF USER HAS IT OPEN
CLOSE:	POPS	E
	JSR	PC,DEVNUM
	JSR	PC,UTYCK
CLOSE1:	MOV	USER,U
	CMP	E,UTTY(U)
	BEQ	.+10	;BR IF USER'S CONSOLE
CLOSE3:	MOV	#-1,TTYU(E)
	SEZ
CLOSE4:	RTS	PC

;LIKE CLOSE1, EXCEPT ONLY CLOSE IF THIS USER ALREADY HAS IT OPEN
CLOSE2:	CMP	USER,TTYU(E)
	BNE	CLOSE4
	BR	CLOSE3

;SLAM--CLOSES ALL USER TTYS BUT CONSOLE
SLAM:	MOV	#NLTY,A
	CLR	E
SLAM1:	CMP	TTYU(E),USER
	BNE	.+6	;BR IF USER DOESN'T OWN THIS TTY
	JSR	PC,CLOSE1
	TST	(E)+
	SOB	A,SLAM1
	RTS	PC

WHERE:	MOV USER,U
	MOV UTTY(U),B
	MOV CHARNO(B),B
	JMP R1NARG

;TURN CASE CONVERSION ON AND OFF
CASESW:	JSR	PC,G1NARG
	TST	B
	BEQ	CASES1	;BR IF ARG=0
	JSR	PC,TICASE	;CONVERT LOWER TO UPPER CASE ON INPUT
	BR	CASES2
CASES1:	JSR	PC,TINCAS	;DON'T CONVERT CASE
CASES2:	SEZ
	RTS	PC

;TURN ECHOING ON AND OFF
ECHOSW:	JSR	PC,G1NARG
	TST	B
	BEQ	ECHOS1	;BR IF ARG=0
	JSR	PC,TIECH	;ECHO
	BR	CASES2
ECHOS1:	JSR	PC,TINECH	;TURN ECHO OFF
	BR	CASES2


			;I SPACE USER MODE
;GET A CHAR IN D FOR USER'S TTY
TTYI:	JSR	A,TYEUSV	;GET USER & TTY
	JSR	PC,TYIGC	;GET A CHARACTER
	TST	TIQN(E)
	BGT	.+10
	MOV #TIQM,TIQO(E)
	JSR	A,TYEURS	;RESTORE E&U
	RTS	PC

;GET A CHAR FOR TNM IN E
GTYI:	JSR	A,TYUSV	;GET USER IN U
	JSR	PC,TYIGC	;GET A CHAR
	JSR	A,TYURS	;RESTORE U
	RTS	PC

;GET A CHAR FOR TTY, DO RIGHT THING IF NONE AVAILABLE
TYIGC1:	BIT	#TILIPM,TTYST(E)
	BEQ	TYIGC2	;BR IF IN CHAR INPUT MODE
	MOV	TBKCHL,D	;RETURN BREAK CHARACTER
	RTS	PC
TYIGC2:	MOV	#FRTYIC,FLSRES(U)
	JSR	PC,FLUSH	;FLUSH USER WITH FLUSH REASON CHAR TYI WAIT
	TST	BRAKE(U)
	BNE	TYIGC3	;BR IF USER TRYING TO BREAK
	TST TIBN(E)
	BLE	TYIGC2
	JSR	PC,RUNME	;FLUSH REASON CLEARED BY INTERRUPT CODE?
TYIGC:	JSR	PC,TIOQ	;TRY TO GET CHAR FROM INPUT Q
	BEQ	TYIGC1	;BR IF NONE AVAILBLE
	RTS	PC

TYIGC3:	JSR	PC,RUNME
	RTS	PC


;SLINE
;START LINE INPUT
SLINE:	JSR	A,TYEUSV
	BIC	#TIMAGI!TIMAGE!TIRBM!TIQF,TTYST(E)	;CLR MISC FLAGS
	BIS	#TILIPM!TIRST,TTYST(E)	;LINE INPUT MODE, INPUT RESET
	JSR	A,TYEURS
	RTS	PC
			;I SPACE USER MODE

;PUT CHAR IN D INTO USER'S TTY'S OUTPUT BUFFER
TTYO:
.IFNZ DRIBF
	BIT #DRIBBF,FLAGS2	;DRIBBLE THE OUTPUT?
	BEQ TTYO3		;NO
	JSR PC,.WRTEC		;OUTPUT THE CHARACTER
.ENDC
TTYO3:	JSR	A,TYEUSV	;GET USER & TTY
	BIT #PTBF,TTYST(E)
	BNE TTYO1
	JSR	PC,GTYO	;SEND CHAR
TTYO2:	JSR	A,TYEURS
	RTS	PC

TTYO1:	SPUSH C
	MOV #CONSO,C
	JSR PC,TBTYO
	SPOP C
	BR TTYO2


;PUT CHAR IN D INTO TTY IN E'S BUFFER
TBTYO:
	JSR PC,TBINIT
GTYO:	JSR	A,TYUSV	;GET USER IN U
	TST	TOPC(E)
	BEQ	GTYO3	;BR IF OUTPUT BUFFER NOT FULL
GTYO2:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH	;KEEP FLUSHING TILL ROOM IN OUTPUT Q
	TST	BRAKE(U)	;USER TRYING TO BREAK?
	BNE	GTYO5
	TST	TOPC(E)
	BNE	GTYO2
	JSR	PC,RUNME
GTYO3:	PUSH	C
	JSR	PC,TOTYO	;PUT CHARACTER IN Q
	POP	C
	JSR	PC,TOCINT	;CAUSE OUTPUT INTERRUPT IF NONE PENDING
GTYO4:	JSR	A,TYURS	;RESTORE U
	RTS	PC

GTYO5:	JSR	PC,RUNME
	BR	GTYO4

;SEND CHAR TO MULTIPLEXEE AND WAIT UNTILL IT SENDS CHAR BACK
;RETURN THAT CHAR IN D
MXWT: TBTW:	PUSH	A
	SPUSH	D
	SPUSH	U
	MOV #TIQSZ,A
	MOV	USER,U
MXWT1:	TST	BRAKE(U)
	BNE	MXWT5
	JSR	PC,TIOQ	;EMPTY TURTLE'S INPUT Q (CLOBBERS D)
	BEQ	MXWT2	;Q EMPTY
	SOB	A,MXWT1
	ERROR+HARD	;JUST GOT 200 CHARS OUT OF Q!! RUNNING OPEN?
MXWT2:	MOV	E,D
	MOVB	MXNUM(D),E	;GET MULTIPLEXOR NUMBER
	JSR	PC,MXQLAD	;ADD THIS TTY TO END OF MULTIPLEXOR'S QUEUE
	BEQ	MXWT6	;Q FULL
		;MAKE SURE HE CAN'T BREAK FROM TYO NOW THAT MPXR EXPECTS CHAR
	MOV	D,E
	TST	TOPC(E)
	BEQ	MXWT4
MXWT3:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH
	TST	TOPC(E)
	BNE	MXWT3	;OUTPUT Q STILL FULL
	JSR	PC,RUNME
MXWT4:	POP	U
	SPOP	D
	SPOP	A
	JSR	PC,GTYO	;SEND CHAR
	JSR	PC,GTYI	;GET CHAR BACK
MXWT5:	RTS	PC

MXWT6:	ERROR+TGDZ
			;I SPACE USER MODE

;START SENDING CHARACTERS TO EDIT BUFFER
EDITA:	JSR	A,TYEUSV
	JSR	PC,TYERT	;RESET EDIT BUFFER
	BR	ETYO1

;END SENDING CHARS TO EDIT BUFFER
EDITE:	JSR A,TYEUSV
	JSR PC,FIXBUF
	BIS	#TIEDM,TTYST(E)
	BR	ETYO1

;PUT CHARACTER IN EDIT BUFFER

ETYO:	JSR A,TYEUSV
	CMP TITQN(E),#TIQSZ
	BGE ETYO1
	JSR F,TTYMPI
	MOVB D,@TIQI(E)
	JSR F,TTYMPO
	INC TIEQN(E)
	INC TIQI(E)
	INC TITQN(E)
ETYO1:	JSR A,TYEURS
	RTS PC

FIXBUF:	JSR F,TTYMPI
	MOV TIEQN(E),C
	MOV TIQI(E),A
	MOV #TITQ,B
FXLOOP:	MOVB -(A),-(B)
	DEC TIQI(E)
	DEC TIEQO(E)
	SOB C,FXLOOP
	JSR F,TTYMPO
	RTS PC

				;I SPACE USER MODE

;TURN ON ECHO MODE
TIECH:	JSR	A,TYEUSV
	BIS	#TIECM,TTYST(E)
TIECH1:	JSR	A,TYEURS
	RTS	PC
;TURN OFF ECHO MODE
TINECH:	JSR	A,TYEUSV
	BIC	#TIECM,TTYST(E)
	BR	TIECH1

;TURN ON CASE SWITCH
TICASE:	JSR	A,TYEUSV
	BIS	#TICVM,TTYST(E)
	BR	TIECH1
;TURN OFF CASE SWITCH
TINCAS:	JSR	A,TYEUSV
	BIC	#TICVM,TTYST(E)
	BR	TIECH1


;BREAK HAS BEEN PROCESSED ON USER LEVEL,
;OK TO ACCEPT CHARS AGAIN
BRAKR:	JSR	A,TYEUSV
	JSR	PC,TTYRT
;	BIS	#TIRST,TTYST(E)	;TELL INT ROUTINES TO RESET BUFFERS
;	JSR	PC,TOCINT	;CAUSE INTERRUPT
	BIC	#TIBR,TTYST(E)
	BR	TIECH1

;INTIALIZE USER CONSOLE
UCINIT:	SPUSH	A
	MOV	TYCKBP(E),A
	JSR	PC,CLKQDL	;DELETE ANY CLOCK QUEUE ENTRY
	BIC	#TICLKQ!TIMAGE!TIMAGI,TTYST(E)	;PUT INTO ASCII MODE
	BIS	#TILIPM!TIECM!TICVM,TTYST(E)	;LINE INPUT, CONVERT CASE, ECHO
	SPOP	A
	RTS	PC
			;I SPACE USER MODE
;SAVE U, GET USER INTO U, CALL WITH JSR A
TYUSV:	SPUSH	U
	MOV	USER,U
	JMP	(A)
;RESTORE U
TYURS:	TST	(P)+	;THIS POPS A SAVED WITH JSR A CALL
	POP	U
	RTS	A	;RESTORING A SAVED BY CALL TO TYUSV

;GET USER IN U, HIS TTY IN E, SAVE BOTH
TYEUSV:	SPUSH	U
	SPUSH	E
	MOV	USER,U
	MOV	UTTY(U),E
	JMP	(A)
;RESTORE
TYEURS:	TST	(P)+
	POP	E
	SPOP	U
	RTS	A
.STITL TELETYPE INPUT INTERRUPT ROUTINES

;BREAK VECTORS POINT TO THESE RECEIVE INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TKBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENRBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,RK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENRBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,RK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;	.ENDC
;>>
;.ENDM

DC0RK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENRBK
DC1RK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENRBK

.IFNZ	NTY+NKLTY+NDCTY+NDPTY
;GENRBK--
;GENERAL RECEIVE BREAK FOR TTYS, TBOXS, ETC.
;CALLED WITH	SPUSH A
;		MOV #TTY INDEX,A
;		JMP GENBRK

GENRBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;TTY
	MOV	TYRS(A),U	;RG ADR
	MOV	(U),D	;RG CONTENTS
	BIT	#%ER,D
	BNE	TGENER	;BR IF ERROR BIT ON
	TST	E
	BMI	GENRB1	;BR IF NOT LOGICAL TTY
	MOV	2(U),D	;CHARACTER
	BIC	#177600,D	;ONLY 7 BITS
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS PHYSICAL DEV.
GENRB1:	JSR	U,ACRES
	SPOP	A
	RTT

TGENER:	JSR	PC,GENER
	BR	GENRB1

;A PNTS TO BLK
;D REG CONTENTS
;U BUF ADDR
GENER:
.IFG	NMODEM
	TST	E
	BMI	GENER5
	BIT	#TPMODM,TTYTP(E)
	BNE	GENER2	;BR IF MODEM
GENER5:
.ENDC
	JSR	PC,DEVER	;PRINT ERROR MESSAGE
	BR	GENER4
.IFG	NMODEM
GENER2:	MOV	TYCKBP(E),A
	BIT	#TICLKQ,TTYST(E)
	BEQ	GENER1
	JSR	PC,CLKQDL	;DELETE ANY PRESENT CLKQ ENTRY
	BIC	#TICLKQ,TTYST(E)
GENER1:	BIS	#%DTRDY,(U)
	BIT	#%CRDT,D
	BNE	GENER4
	JSR	PC,TISANS	;TRY TO HANG UP
.ENDC
GENER4:	CMP	(U)+,(U)
	RTS	PC

;;!!! CHANGE SYS CONSOLE PRINOUT HACK
DEVER:	JSR	A,SPRINT
	BPRTXT	^\DEV ERR \
	JSR	PC,PGEN1
	SPREND
	RTS	PC

PGEN1:	MOV	U,A
	JSR	PC,PRON		;REGISTER ADDR
	PRTXT	^\/  \
	MOV	D,A
	JSR	PC,PRON		;REG CONTENTS
	PRCR
	RTS	PC

.IFG NMODEM
;TISHNG:	;ASSERT DATA TERM RDY IN TIHGTM TICKS
;	MOV	#TIHGTM,(A)
;	MOV	#TIUNHG,4(A)
;	BR	TICKLA

TISANS:	MOV	#TIANTM,(A)	;IF NO CARRIER IN TIANTM TICKS, HANG UP
	MOV	#TIANS,4(A)

TICLKA:	JSR	PC,CLKQAD
	BIS	#TICLKQ,TTYST(E)
	RTS	PC

TIANS:	JSR	B,TICKS
	BIT	#%CRDT,@U
	BNE	TIANS1
	BIC	#%DTRDY,@U
;	JSR	PC,TISHNG
TIANS1:	SPOP	U
	SPOP	E
	SPOP	B
	RTS	PC


;---FOLLOWING RUN AT CLOCK BREAK LEVEL---

TICKS:	SPUSH	E	;TICLKQ START
	SPUSH	U
	MOV	6(A),E		;TTY
	BIT	#TICLKQ,TTYST(E)
	BEQ	TICKS1
	BIC	#TICLKQ,TTYST(E)
	JMP	(B)

TICKS1:	BPT	;HOW DID THIS GET ON CLOCK Q?
	BR	TIANS1

;TIUNHG:	JSR	B,TICKS
;	BIS	#%DTRDY,@U	;TURN DATA TERM RDY ON
;	BR	TIANS1

;	TIANTM AND ;TIHGTM HAVE BEEN MOVED
;	TO THE START OF TYI WITH THE BUFFERS

.ENDC
.ENDC
.IFZ DHON
.IFG NDMTY
DM0RK:	BIC	#200,DM0CSR	;CLEAR DONE BIT
	JSR U,ACSAV	;SAVE ACS
	MOV #DMTT+200,B	;BOTTOM OF TUMBLE TABLE
	MOV #TTP,C	;TUMBLE TABLE POINTER
	;BR DMRK

;DM11 RECEIVE INTERRUPT
DMRK:	BR	DMRK3

DMRK1:	BIC	#120200,@(C)	;CLR CHAR RCVD, PARITY, AND UNUSED BITS
	BIT	#40000,@(C)
	BNE	DMRK2	;BR IF NO STOP RECEIVED
	MOV	(C),E
	MOVB	1(E),E	;GET LINE #
	ADD	#NFDMTY,E	;GET PHYSICAL TTY NUMBER
	MOVB	TILTTY(E),E	;GET LOGICAL NUMBER
	BMI	DMRK2	;BR IF ILLOGICAL
	MOVB	@(C),D	;CHARACTER
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS TTY
DMRK2:	ADD	#2,(C)	;INCREMENT POINTER
	CMP	@C,B
	BLO	DMRK3	;BR IF NOT PAST END OF TABLE
	MOV	B,@C	;RESET POINTER
	SUB	#200,@C
DMRK3:	TST	@(C)
	BMI	DMRK1	;BR IF MORE CHARACTERS
	JSR	U,ACRES	;RESTORE AC'S
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0RK:	JSR U,ACSAV
DM0RK2:	MOV DH0NRC,C	;GET THE CHARACTER
	BGE DM0RK3	;NO CHARACTER
	BIC #110200,C	;CLEAR SILLY BITS
	BIT #60000,C	;IS IT A BREAK?
	BEQ DM0RK1	;NOPE
	BIC #60377,C	;CLEAR CHARACTER AND BREAK BITS
	ADD #7,C	;BREAK
DM0RK1:	MOV C,E		;COPY IT
	SWAB E		;GET LINE NUMBER
	BIC #177760,E	;FLUSH CRAP
	ASL E
	MOVB TILTTY+NFDMTY(E),E	;GET LOGICAL NUMBER
	BMI DM0RK2	;ILLOGICAL
	MOV C,D		;COPY AGAIN
	BIC #177600,D	;JUST THE CHARACTER
	BIT #TIRST,TTYST(E)	;RESET INPUT?
	BEQ .+6
	JSR PC,TYIRT1	;GO RESET IT
	JSR PC,@TIRCV(E)	;GOBBLE CHARACTER INTO BUFFER
	BR DM0RK2		;ANY MORE?
DM0RK3:	JSR U,ACRES
	RTT
.ENDC
.ENDC
.IFNZ NTVS
;TV CLOCK TICK ROUTINE
TVTICK:	JSR U,ACSAV
	JSR PC,LKBBRK	;GO COLLECT KEYBOARD CHARACTERS
	JSR PC,TVOUT	;GO EMPTY TV OUTPUT BUFFERS
	MOV #NTVCHN*400-400+17,A
	MOV #TVLOGO,B
TVTIC1:	TST (B)+
	BLT TVTIC4	;HE SHOULDN'T BE DISTURBED
	BEQ TVTIC3	;HE'S ALL DONE THIS TIME
TVTIC2:	DEC -2(B)	;HE GETS IT AT LEAST 1/60TH MORE
TVTIC4:	SUB #400,A
	BGE TVTIC1
	JSR U,ACRES
	RTS PC
TVTIC3:	MOV A,VIDSW	;HE DOESN'T GET IT ANY MORE
	BR TVTIC2

LKBBRK:LKBBR1:	MOV LKBB,C	;GET ANY CHARACTER THAT MIGHT BE THERE
	BEQ LKBBR2	;NONE
	BIC #160200,C	;CLEAR THE GARBAGE
	MOV C,E		;COPY
	SWAB E		;TO GET KEYBOARD NUMBER
	BIC #177740,E
	ASL E
	MOV TVKBS(E),E	;GET THE "REAL" TTY NUMBER (LOGICAL, I HOPE)
	BGE LKBBR3	;BRANCH IF THERE IS SOMEONE THERE ALREADY
	CMPB #TVDOIT,C	;DID HE TYPE "DO IT"?
	BNE LKBBR1	;IF NOT, DON'T DO IT
	CLR E		;NOW SEE IF WE CAN FIND A FREE CONSOLE FOR THIS GUY
LKBBR4:	TST TVUSE(E)	;IS THIS ONE FREE?
	BLT LKBBR5	;YES, GO GOBBLE IT
	TST (E)+	;MOVE ON
	CMP #NTVS*2,E	;AT THE END?
	BNE LKBBR4	;NO, KEEP TRYING
	BIC #160377,C	;HE LOSES
	BIS #16,C	;BUT, AS A CONSOLATION PRIZE
	MOV C,VIDSW	;TELL HIM THAT THE SYS IS ALIVE
	SWAB C
	ASL C
	BIC #177701,C
	MOV #3*60.,TVLOGO(C)	;BUT ONLY FOR 3 SECONDS
	BR LKBBR1	;MAYBE SOMEONE ELSE?
LKBBR5:	MOV PC,TVUSE(E)	;NO LONGER FREE
	MOV E,A		;COPY WHICH TV WE GOT
	BIC #160377,C	;CLOBBER ALL BUT WHICH KEYBOARD
	MOV C,D		;AND COPY THAT
	ASR C
	BIS E,C		;SWITCH HIM IN
	MOV C,VIDSW
	ADD #NFTV,A	;THE LOGICAL NUMBER
	SWAB D		;WHO WAS THAT MASKED MAN?
	ASL D
	MOV #-1,TVLOGO(D)
	MOV A,TVKBS(D)
	BR LKBBR1
LKBBR3:	MOVB C,D
	MOVB LKBTAB(D),D	;TRANSLATE TO REAL CHARACTERS
	BEQ LKBBR1	;IMAGINARY CHARACTER TYPED
	BIT #TIRST,TTYST(E)	;RESET?
	BEQ .+6		;NO
	JSR PC,TYIRT1
	JSR PC,@TIRCV(E)
	BR LKBBR1
LKBBR2:	RTS PC
.ENDC

;MULTIPLEXOR RECIEVE INTERRUPT
MXRCV:	SPUSH	E
	CMP	D,#'_
	BGT	MXRCV3	;BR IF LOWER CASE
	JSR	PC,MXGTY	;GET INDEX OF LOG DEV THIS CHAR BELONGS TO
	BEQ	MXRCV1	;FAIL, THIS CHAR DOESN'T BELONG TO ANYONE
	JSR PC,TYRCV1
	BR MXRCV1

MXICMN==140
MXICMX==137
MXRCV3:	;CHAR IS LOWER CASE, IDENTIFIES WHERE NEXT CHAR COMES FROM
	CMP	D,#MXICMN	;SMALLEST LEGAL IDENTIFIER
	BLT	MXRCV1
	CMP	D,#MXICMX	;LARGEST LEGAL IDENTIFIER
	BGT	MXRCV1
	MOVB	MXICH(D),E	;GET INDEX OF DEVICE
	JSR	PC,MXQTAD	;ADD TO TOP OF QUEUE
MXRCV1:	SPOP E
MXRCV2:	SEZ
	RTS PC


MXGTY:	;GETS TTY # OF NEXT LOG. DEV. IN MX Q, UPDATES Q,
	;FAILS IF NOTHING IN QUEUE
	TST	MXNCH(E)
	BLE	MXRCV2	;Q EMPTY, FAIL
	SPUSH	D
	JSR F,TTYMPI
	MOV #TIQM,D
	MOVB	(D)+,-(P)	;PUSH INDEX OF FIRST DEV ON Q
MXGTY1:	MOVB	(D)+,-2(D)	;MOVE REST OF Q UP ONE BYTE
	CMP D,#TIQLM
	BLO	MXGTY1
	DEC	MXNCH(E)
	MOVB	(P)+,E		;POP DESIRED INDEX
	JSR F,TTYMPO
	SPOP	D
	CLZ
	RTS PC


;ADD CHAR IN D TO TOP OF MX INPUT Q
MXQTAD:
	CMP TIQN(E),#TIQSZ
	BGE	MXRCV2
	SPUSH	A
	JSR F,TTYMPI
	MOV	MXNCH(E),A
	ADD #TIQLM,A
MXQTA1:	MOVB	(A)+,(A)	;MOVE ENTIRE Q DOWN ONE
	SUB	#2,A
	CMP A,#TIQLM
	BHIS	MXQTA1
	INC	MXNCH(E)
	MOVB D,@TIQI(E)
	JSR F,TTYMPI
	SPOP	A
	CLZ
	RTS PC

;ADD CHAR IN D TO BOTTOM OF MX Q
MXQLAD:
	CMP TIQN(E),#TIQSZ
	BGE	MXRCV2
	SPUSH	A
	MOV #TIQM,A
	JSR F,TTYMPI
	ADD	MXNCH(E),A
	MOVB	D,(A)
	INC	MXNCH(E)
	JSR F,TTYMPO
	SPOP	A
	CLZ
	RTS PC
.STITL TYPEIN--INTERRUPT LEVEL
;TELETYPE RECIEVE
;PROCESS CHAR IN D FOR TTY IN E
;CAN CLOBBER A,U

TYRCV:	BIT #TILIPM,TTYST(E)
	BEQ TYRCV1
	MOV TTYU(E),U
	BLT TYRCV1
	CMP D,#7
	BEQ TYRCV2
	CMP D,#32
	BEQ TYRCV3
TYRCV1:	CMP #TIBSZ,TIBN(E)
	BEQ TYRET
	JSR F,TTYMPI
	MOVB D,@TIBI(E)
	JSR F,TTYMPO
	INC TIBN(E)
	INC TIBI(E)
	CMP #TIBT,TIBI(E)
	BHI TYRET
	MOV #TIBB,TIBI(E)
TYRET:	RTS PC
TYRCV2:	JMP TICG
TYRCV3:	JMP TICZ

TICP:	SPUSH B
	BIT #TIRST,TTYST(E)
	BEQ .+6
	JSR PC,TYIRT1
	JSR F,TTYMPI
	MOV TTYU(E),U
	CMP #FRLINW,FLSRES(U)
	BNE TICP5
TICPLT:	CMP #TIBT,TIBO(E)
	BHI TICP7
	MOV #TIBB,TIBO(E)
TICP7:	MOVB @TIBO(E),D
	INC TIBO(E)
	DEC TIBN(E)
	BIT #TIQF,TTYST(E)
	BEQ TICP4
	BIC #TIQF,TTYST(E)
	BIS #200,D
	BR TICP3
TICP4:	BITB #FSF,DTBL(D)
	BEQ TICP3
	MOVB DTBL2(D),C
	JSR PC,@TIICTB(C)
	BEQ TICPLB
TICP3:	JSR PC,TYINQ
	BEQ TICPRT
TICPLB:	TST TIBN(E)
	BNE TICPLT
TICPRT:	JSR PC,TOCINT
TICP5:	JSR F,TTYMPO
	SPOP B
	RTS PC


;PUT CHAR IN D INTO CONSOLE IN E'S INPUT BUFFER
TYINQ:	BIT	#TICVM,TTYST(E)
	BEQ	TIINQ	;BR IF NOT CONVERTING LOWER TO UPPER CASE
	JSR	PC,TICVLU	;CONVERT
;PUT CHAR IN D INTO TTY IN E'S INPUT BUFFER
TIINQ:
	CMP TIQN(E),#TIQSZ
	BGE	TIINQ1	;BR IF BUFFER FULL
	JSR F,TTYMPI
	MOVB	D,@TIQI(E)	;PUT CHAR IN
	JSR F,TTYMPO
	INC	TIQI(E)	;INC POINTER
	INC	TIQN(E)	;INC COUNTER
	INC	TIQTON(E)	;INC OUTPUT LEVEL COUNTER
	INC TITQN(E)
	CLZ
	RTS PC

TIINQ1:	SEZ
	RTS	PC

;*****TIOQ RUNS AT USER LEVEL ALSO******
;GET A CHAR FROM INPUT QUEUE

TIOQ:	BIT #TILIPM,TTYST(E)
	BNE TIOQ1
	TST TIBN(E)
	BLE TIINQ1
	CMP #TIBT,TIBO(E)
	BHI TIBORT
	MOV #TIBB,TIBO(E)
TIBORT:	JSR F,TTYMPI
	MOVB @TIBO(E),D
	JSR F,TTYMPO
	BIC #177400,D
	INC TIBO(E)
	DEC TIBN(E)
	BIT #TIECM,TTYST(E)
	BEQ TIBRET
	JSR PC,TOTYO
	JSR PC,TOCINT
TIBRET:	CLZ
	RTS PC

TIOQ1:	TST TIEQTN(E)
	BLE TIINQ1
	JSR F,TTYMPI
	MOVB @TIEQTO(E),D
	BIC #177400,D
	JSR F,TTYMPO
	INC TIEQTO(E)
	DEC TIEQTN(E)
	CLZ
	RTS PC



;IF CHAR IN D IS LOWER CASE, CONVERT TO UPPER
TICVLU:	TSTB	D
	BMI	TICVL1	;BR IF QUOTED
	CMP	D,#'_
	BLE	TICVL1	;BR IF UPPER CASE
	CMP	D,#177
	BEQ	TICVL1	;DON'T CASE RUBOUT
	SUB	#40,D
TICVL1:	RTS	PC


;QUOTE NEXT CHAR
TICQ:	BIT	#TIQF,TTYST(E)
	BNE	TICQ1	;BR IF ^Q WAS PREVIOUS CHAR
	BIS	#TIQF,TTYST(E)
	RTS	PC
TICQ1:	BIC	#TIQF,TTYST(E)
	RTS	PC

;RESET TTY
TTYRT:TBREST:	JSR	PC,TYORT	;RESET TYO STUFF
	JSR	PC,TYIRT	;RESET TYI STUFF
	JSR PC,TYBRT
	RTS	PC

;RESET TYPEOUT PNTRS
TYORT:	SPUSH F
	MOVB MXNUM(E),F
	BMI TYORT1
	SUB TOQN(E),TOQN(F)
TYORT1:	SPOP F
	CLR	TOQN(E)
	MOV #TOQM,TOQI(E)
	MOV #TOQM,TOQO(E)
	CLR	TOPC(E)
	CLR	TOIPC(E)
	BIT #PTBF,TTYST(E)
	BNE .+4
	RTS PC
	SPUSH C
	MOV #-CONSO,C
	SPUSH PS
	SPL 7
	JSR PC,TBINIT
	SPOP PS
	SPOP C
	RTS	PC

;*** TYIRT RUNS AT USER LEVEL ALSO ***
;RESET INPUT PNTRS
TYIRT:	BIC	#TIEDM!TIQF!TIRBM,TTYST(E)	;CLR MISC FLAGS
TYIRT1:	BIC	#TIRST,TTYST(E)	;RESET FLAG
	CLR	TIQTON(E)
	CLR	TIQN(E)
	MOV #TIQM,TIQI(E)
	MOV #TIQM,TIQO(E)
	MOV #TIQM,TIQTO(E)
	MOV TIEQN(E),TITQN(E)
	CLR	TIBC(E)
	RTS	PC

;RESET EDIT PNTRS
TYERT:	CLR	TIEQN(E)
	MOV #TITQ,TIEQO(E)
	MOV TIQN(E),TITQN(E)
	RTS	PC

TYBRT:	CLR TIBN(E)
	MOV #TIBB,TIBO(E)
	MOV #TIBB,TIBI(E)
	RTS PC

;BREAK TO LEVEL 0
TICG:	MOV	#1,BRAKE(U)	;SET USER BREAK FLAG
	BR	TIBRK
;BREAK TO LEVEL N
TICZ:	MOV	#-1,BRAKE(U)

;BREAK TO LEVEL 0 OR N
;CALL WITH CONTENTS OF BRAKE IN (P)
TIBRK:	BIS	#TIBR,TTYST(E)
	JSR	PC,TTYRT	;RESET INPUT
	CMP	#FRLINW,FLSRES(U)
	BEQ	TIBRK1	;BR IF FLUSHED WAITING FOR LINE
	BIT	#FRBKBT,FLSRES(U)	;SHOULD I UNHANG HIM ANYHOW?
	BEQ	TIBRK2	;BR IF NO
TIBRK1:	CLR	FLSRES(U)	;UNFLUSH
TIBRK2:	RTS	PC

;INTERRUPT LEVEL BREAKPOINT
;CLOBBER ATICZ/  TIIBPT
TIIBPT:	TST	(P)+
	BPT	
	RTS	PC

;REPLACE ^B WITH %
TICB:	MOV #'%,D
	RTS PC


;*** USER AND INTERRUPT LEVEL ***

;IF NOT TRANSMITTING, CAUSE OUTPUT INTERRUPT
TOCINT:	SPUSH	E
TOCIN4:	BIT	#TPPTY,TTYTP(E)
	BNE	TOCIN3
	BIT	#TOTRAN,TTYST(E)
	BNE	TOCIN2	;BR IF TRANSMITTING
.IFNZ NTVS
	BIT #TPTV,TTYTP(E)
	BNE TOCIN2
.ENDC
.IFG NDMTY
	BIT	#TPDM,TTYTP(E)
	BEQ	TOCIN1	;BR IF NOT A DM11 TTY
	BIS	#100000,@TOTSR(E)	;SET TRANS INT BIT
	BR	TOCIN2
TOCIN1:
.ENDC
	BIC	#100,@TOTSR(E)	;CLEAR AND SET INTERRUPT ENABLE
	BIS	#100,@TOTSR(E)
TOCIN2:	SPOP	E
	RTS	PC

TOCIN3:	MOVB	MXNUM(E),E
	BR	TOCIN4

.STITL TYPE OUT--INTERRUPT LEVEL

;BREAK VECTORS POINT TO THESE TRANSMIT INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TPBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENTBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,TK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENTBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,TK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;		JMP GENTBK
;	.ENDC
;>>
;.ENDM

DC0TK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENTBK
DC1TK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENTBK

.IFZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DM0CSR,U	;STATUS REGISTER
	MOV #NFDMTY,A	;# OF FIRST TTY
	BR DMTK

;DM11 TRANSMIT BREAK
DMTK:	MOV	(U),D	;REGISTER CONTENTS
	BIT	#60000,D
	BEQ	.+6	;BR IF NO ERRORS
	JSR	PC,DEVER	;PRINT ERRORS ON SYSTEM CONSOLE
	BIC	#160000,(U)	;CLEAR ERROR &TRANS INTERRUPT BITS
	MOV	U,B
	ADD	#2,B	;ADDR OF BUFFER ACTIVE REGISTER
	MOV	A,U	;# OF FIRST TTY
	MOV	#1,A	;BIT FOR LINE BUFFER ACTIVE REGISTER
DMTK2:	BIT	A,(B)
	BNE	DMTK3	;BR IF THIS LINE TRANSMITTING
	MOVB	TILTTY(U),E	;LOGICAL TTY #
	BMI	DMTK3	;BR IF ILLOGICAL
	SPUSH	A
	JSR	PC,TYXMT	;TRANSMIT
	SPOP	A
DMTK3:	TST	(U)+	;INC TTY
	ASL	A	;SHIFT BAR BIT
	BNE	DMTK2	;BR IF MORE TTYS TO CHECK
	JSR	U,ACRES
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DH0SCR,U
	MOV #NFDMTY,A
	MOV (U),D	;GET STATUS OF DH11
	BIT #42000,D	;ANYTHING BAD?
	BEQ .+6		;NOPE
	JSR PC,DEVER	;TELL THE WORLD
	INCB 1(U)	;RESET NXM
	BIC #100000,(U)	;RESET DONE
	MOV U,B
	ADD #12,B	;GET BAR ADDRESS
	MOV A,U
	MOV #1,A
DMTK2:	BIT A,(B)	;THAT LINE TRANSMITING?
	BNE DMTK3	;YES
	MOVB TILTTY(U),E	;GET LOGICAL NUMBER
	BMI DMTK3	;ILLOGICAL
	SPUSH A
	JSR PC,TYXMT	;SEND ANYTHING YOU GOT
	SPOP A
DMTK3:	TST (U)+	;NEXT LINE
	ASL A		;NEXT BAR BIT
	BNE DMTK2	;OUT OF LINES?
	JSR U,ACRES
	RTT
.ENDC
.ENDC

;GENERAL TRANSMIT BREAK
GENTBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;GET LOGICAL TTY #
	BMI	GENTB2	;BR IF ILLOGICAL
	MOV	TOTSR(E),B
	MOV	@B,D	;STATUS REG CONTENTS
	BIT	#%RDY,D
	BEQ	GENTB2	;BR IF NOT RDY, SPURIOUS INTERRUPT
GENTB1:	JSR	PC,TYXMT	;TRANSMIT INT ROUTINE
GENTB2:	JSR	U,ACRES
	SPOP	A
	RTT

;GET NEXT MULTIPLEXOR OUTPUT CHARACTER
;SKIP ONE WORD IF SUCESSFULL
MXGOC:	TST	TOQN(E)
	BLE	MXGOC4	;BR IF NO CHARS TO SEND
	CMP TOQO(E),#TOQM+4
	BLO	.+10	;BR IF OUTPUT PNTR NOT PAST END OF QUEUE
	MOV #TOQM,TOQO(E)
	SPUSH	E
	JSR F,TTYMPI
	MOVB	@TOQO(E),E	;GET NEXT TTY TO SEND STUFF FOR
	JSR F,TTYMPO
	JSR	PC,TOSOP	;START OUTPUT
	BR	.+2	;OUTPUT Q FULL
	JSR	PC,@TOGOC(E)	;GET OUTPUT CHAR
	BR	MXGOC3	;NO CHARS
	SPOP	E
	DEC	TOQN(E)	;DECREMENT MPXRS CHAR COUNT
	BR	.+4
MXGOC1:	SPOP	E
	INC	TOQO(E)	;INC MULTIPLEXOR'S POINTER
MXGOC5:	ADD	#2,@P	;SKIP RETURN
MXGOC2:	RTS	PC

;MULTIPLEXOR HAS CHARS TO SEND, BUT CURRENT MULTIPLEXEE DOESN'T
MXGOC3:	MOVB	OMXNUL(E),D	;RETURN NULL CHAR FOR MULTIPLEXEE
	BR	MXGOC1


;NO CHARACTERS FOR MULTIPLEXOR
MXGOC4:
	CMP TOQO(E),#TOQM
	BEQ MXGOC2
	MOV #TOQM,TOQO(E)
	MOVB	OMXRES(E),D	;SEND MULTIPLEXOR RESET CHARACTER
	BR	MXGOC5

;GET NEXT TTY OUTPUT CHARACTER
;SKIP ONE WD IF SUCCESSFUL
TYGOC:	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC1	;BR IF IN IMAGE MODE (DON'T PAD)
	TSTB	TOPAD(E)
	BGE	TYGOC4	;BR IF SOME PADDING LEFT
TYGOC1:	JSR	PC,TOOQ	;GET CHAR FROM OUTPUT BUFFER
	BR	TYGOC3	;BR IF BUFFER EMPTY
	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC2	;BR IF IN IMAGE MODE
	CMP	D,#15
	BNE	TYGOC2
	MOVB	TTYTP(E),TOPAD(E)	;IF CR, SET UP PADDING
TYGOC2:	ADD	#2,@P	;SKIP RETURN
TYGOC3:	RTS	PC
;SEND PADDING CHAR INSTEAD OF NEXT CHAR FROM QUEUE
TYGOC4:	CLR	D
	DECB	TOPAD(E)	;DEC # OF PADS
	BR	TYGOC2


;REMOVE CHAR FROM CIRCULAR OUTPUT QUEUE AND RETURN IT IN D
;SKIP ONE WORD IF SUCCESSFUL
TOOQ:	TST	TOQN(E)
	BLE	TOOQ2	;BR IF NOTHING IN Q
	JSR F,TTYMPI
	CMP TOQO(E),#TOQLM
	BLO TOOQ1
	MOV #TOQM,TOQO(E)
TOOQ1:	MOVB	@TOQO(E),D	;GET CHAR
	JSR F,TTYMPO
	INC	TOQO(E)	;INC PNTR
	DEC	TOQN(E)	;DEC CHARACTER COUNT
	ADD	#2,@P	;SKIP RETURN
TOOQ2:	RTS	PC

;TTY TRANSMIT INTERRUPT
;FIRST SEND CHARS IN OUTPUT Q
;THEN PROCESS CHARS IN INPUT Q
;CAN CLOBBER A&C
TYXMT:	BIC	#TOTRAN,TTYST(E)	;CLEAR XMT INT PENDING BIT
	BIT	#TIBR,TTYST(E)
	BNE	TYXMT4	;BR IF BREAKING
	JSR	PC,TOSOP	;START OUTPUT
	BR	TYXMT3	;OUTPUT BUFFER FILLED AGAIN
TYXMT1:	JSR	PC,TOPIC	;PROCESS CHARS FROM INPUT BUFFER
TYXMT3:		;ACTUALLY SEND CHARACTERS!!!
.IFG	NDMTY
	BIT	#TPDM,TTYTP(E)
	BNE	TYXMT5	;BR IF DM11 TTY
.ENDC
.IFG NTVS
	BIT #TPTV,TTYTP(E)
	BNE TYXMT6
.ENDC
	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHAR
	BR	TYXMT4	;NONE
	MOV	D,2(B)	;PUT CHAR IN DEVICES OUTPUT BUFFER
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
TYXMT4:	RTS PC
.IFG NTVS
TYXMT6:	JSR PC,TVSND
	RTS PC
.ENDC

;START OUTPUT
;SKIP RETURN IF OUTPUT BUFFER NOT FULL
TOSOP:
	CMP TOQN(E),#TOQSZ
	BGE	TOSOP2	;BR IF Q FULL
	TST	TOPC(E)	;DID WE EXIT FROM MIDDLE OF PROCESSING CHAR TO OUTPUT Q
	BEQ	TOSOP1	;BR IF NO
	MOV	TOSVC(E),C	;RESTORE MISC AC'S
	MOV	TOSVD(E),D
	SPUSH	TOPC(E)	;LOCATION TO JSR TO
	CLR	TOPC(E)
	JSR	PC,@(P)+	;CALL AS COROUTINE
	BR	TOSOP2	;OUTPUT Q FILLED AGAIN
TOSOP1:	ADD	#2,@P	;SKIP RETURN
TOSOP2:	RTS	PC


.IFG NDMTY
TYXMT5:	JSR	PC,DMSND	;TRANSMIT CHARS TO DM TTY
	RTS	PC

;TRANSMIT CHARS TO DM11 TTY
DMSND:	JSR	F,ACSAV
	CLR	A	;-WD CNT
	MOVB	TILTTY(E),U	;PHYSICAL TTY #
	MOV	DMBUF(U),B	;WHERE CHARS ACTUALLY SENT FROM
.IFZ DHON
	MOV	B,DMCA(U)
.IFF
	BIC #17,DH0SCR
	BIS DHNUMB(U),DH0SCR	;SET LINE NUMBER
	MOV B,DH0CAR	;SET THE ADDRESS
.ENDC
	MOV	#DMMAX,C	;MAX NUM OF CHARS TO SEND
DMSND1:	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHARACTER
	BR	DMSND2	;RETURN HERE IF NO CHARS
	MOVB	D,(B)+	;PUT CHAR IN BUFFER
	DEC	A	;-WD CNT
	DEC	C	;MAX NUM OF CHARS TO SEND
	BGT	DMSND1
DMSND2:	TST	A
	BGE	DMSND3	;BR IF NOTHING TO SEND
.IFZ DHON
	MOV	A,DMWC(U)
	BIS	DMBIT(U),DM0BAR	;TRANSMIT
.IFF
	MOV A,DH0BCR	;SET BYTE COUNT
	BIS DMBIT(U),DH0BAR	;START LINE UP
.ENDC
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
DMSND3:	JSR	F,ACRES
	RTS	PC
.ENDC
.IFNZ NTVS
;CHARACTER GENERATION MACRO
;ASSUMES INCREMENT SET TO 44
;SPECIAL INCREMENT OVERFLOW SET
;ADDRESS TO PUT CHAR IN B
;#TVRWIN IN C
;WRITE MODE SET TO IOR
;NUMBER OF CHARS LEFT ON LINE IN D
;NUMBER OF CHARACTERS IN BUFFER IN E
;CLOBBERS A
.MACRO TVCHAR SHIFT,MASK
	MOV B,TVRADR	;ADDRESS KEPT IN B
	.IFNB SHIFT
	.IFZ SHIFT
	CLR TVSHR
	.IFF
	MOV #SHIFT,TVSHR
	.ENDC
	.ENDC
	MOV #MASK,TVMSK
	.REPT 10.
	MOVB (A)+,(C)
	.ENDR
.ENDM

;ACTUAL CHARACTER GENERATOR, OPEN CODED FOR 8 CHARACTERS
CHAR0:	TVCHAR 10.,1777
	RTS PC
CHAR1:	TVCHAR 4.,176017
	RTS PC
CHAR2:	TVCHAR 14.,177760
	ADD #2,B
	SUB #12,A
	TVCHAR ,37777
	RTS PC
CHAR3:	TVCHAR 8.,140377
	RTS PC
CHAR4:	TVCHAR 2.,177403
	RTS PC
CHAR5:	TVCHAR 12.,177774
	ADD #2, B
	SUB #12,A
	TVCHAR ,7777
	RTS PC
CHAR6:	TVCHAR 6.,170077
	RTS PC
CHAR7:	TVCHAR 0.,177700
	ADD #2,B
	RTS PC
TVOUT:	JSR F,TVSAVE
	SPUSH PS
	SPL 7	;BECAUSE WE USE ONE OF THE SLOT PAGES
	SPUSH PUREAR+4
	SPUSH PUREDR+4
	MOV FONTAR,PUREAR+4
	MOV FONTDR,PUREDR+4
;SINCE THIS ROUTINE GETS CALLED EVERY TICK, WE WILL BLINK THE
;CURSORS HERE, SINCE THE WORLD IS SAVED
	MOV #NTVS,A
	MOV #NFTV,E
	MOV #44,TVINCR
BLNKLP:	TST TVBLNK(E)
	BEQ BLNKL1
	BLT BLNKL2
	DEC TVBLNK(E)
	BNE BLNKL1	;BLINKER IS ON AND IS STAYING ON
	MOV #-15.,TVBLNK(E)	;IT STAYS OFF FOR 1/4 SEC
BLNKL3:	JSR PC,BLINK	;TURN IT OFF
BLNKL1:	TST (E)+
	SOB A,BLNKLP
	BR BLNKL5
BLNKL2:	INC TVBLNK(E)	;BLINKER IS OFF
	BNE BLNKL1	;AND IT IS STAYING OFF
	MOV #15.,TVBLNK(E)
	BR BLNKL3	;TIME TO TURN IT ON
BLINK:	MOV E,C
	SUB #NFTV,C
	ASR C
	MOVB C,TVSEL	;SELECT CORECT CONSOLE
	BISB #TVXOR,TVSEL
	MOV #TVRWIN,C
	MOV TVCRLN(E),TVRADR
	MOV TVCRPS(E),F
	ASL F
	BIC #177761,F
	MOV TVCRM1(F),TVRWIN
	MOV #-8.,TVWC
	TST TVCRM2(F)
	BNE .+4
	RTS PC
	TST TVWC
	BNE .-4
	MOV TVCRLN(E),TVRADR
	ADD #2,TVRADR
	MOV TVCRM2(F),TVRWIN
	MOV #-8.,TVWC
	RTS PC

BLNKL5:	MOV #NFTV,U
TVOUT1:	MOV U,E
	JSR PC,TYXMT
	TST (U)+
	CMP #NFTV+<2*NTVS>,U
	BNE TVOUT1
	SPOP PUREDR+4
	SPOP PUREAR+4
	SPOP PS
	JSR F,TVREST
	RTS PC
TVSAVE:	TST (P)+
	TST TVWC
	BNE .-4
	SPUSH TVMSK
	SPUSH TVRADR
	SPUSH TVSEL
	SPUSH TVINCR
	SPUSH TVSHR
	SPUSH UBR
	JMP (F)

TVREST:	TST (P)+
	TST TVWC
	BNE .-4
	SPOP UBR
	SPOP TVSHR
	SPOP TVINCR
	SPOP TVSEL
	MOV #-1,TVMSK	;SO THAT WE CAN LOAD THE UBR
	MOV UBR,TVRWIN	;IF THE GUY KNOWS, HE WILL SET THIS
	SPOP TVRADR
	SPOP TVMSK
	JMP (F)
TVSND:	JSR F,ACSAV
TVSND1:	MOV #1044,TVINCR
	MOV E,A
	SUB #NFTV,A
	ASR A
	BIS #TVIOR,A
	MOVB A,TVSEL
TVSND3:	JSR PC,@TOGOC(E)
	BR TVSND4
	BIC #177600,D
	TST TVBLNK(E)
	BLE TVSND7	;BLINKER IS ALREADY OFF
	JSR PC,BLINK
	MOV #-15.,TVBLNK(E)
TVSND7:	MOV D,C
	ASL C
	MOV SMLFNT(C),A
	BEQ TVSND2	;SPECIAL CHARACTER
	ADD #SMLFNT,A
	MOV TVCRLN(E),B	;WHERE TO WRITE THE CHARACTER
	MOV #TVRWIN,C
	MOV TVCRPS(E),D	;ACTUALL CHARACTER NUMBER ON LINE
	ASL D
	BIC #177761,D
	JSR PC,@TVCJTB(D)
	MOV B,TVCRLN(E)
	INC TVCRPS(E)
	BR TVSND3
TVSND2:	CMP #40,D
	BLT TVSND3
	MOV TVSCJT(C),A
	BEQ TVSND3
	JSR PC,(A)
	BR TVSND1
TVSND4:	JSR F,ACRES
	RTS PC
TVNLSC==7
TVLF:	ADD #110*12.,TVCRLN(E)
	CMP #77660,TVCRLN(E)
	BHI .+10
	SUB #77660,TVCRLN(E)
	INC TVLINE(E)
	CMP TVLINE(E),TVHIGH(E)
	BLT TVLF1
	ADD #TVNLSC*11*12.,TVSCRL(E)
	CMP #7766,TVSCRL(E)
	BGT .+10
	SUB #7766,TVSCRL(E)
	MOV TVSCRL(E),F
	BIS #10000,F
	MOV F,TVCNSL
	SUB #TVNLSC,TVLINE(E)
	MOV #TVNLSC-1,F
	SPUSH TVCRLN(E)
TVLF2:	JSR PC,TVCEOL
	ADD #110*12.,TVCRLN(E)
	CMP #77660,TVCRLN(E)
	BHI .+10
	SUB #77660,TVCRLN(E)
	SOB F,TVLF2
	SUB #110*2,TVCRLN(E)
	BGE .+10
	ADD #77660,TVCRLN(E)
	JSR PC,TVCEOL
	SPOP TVCRLN(E)
TVLF1:	RTS PC
TVSPF:	INC TVCRPS(E)
	MOV TVCRPS(E),A
	ASL A
	BIC #177761,A
	ADD TVSPFK(A),TVCRLN(E)
TVSPF1:	RTS PC
TVSPB:	TST TVCRPS(E)
	BEQ TVSPF1
	MOV TVCRPS(E),A
	ASL A
	BIC #177761,A
	SUB TVSPFK(A),TVCRLN(E)
	DEC TVCRPS(E)
	RTS PC
TVSPBE:	JSR PC,TVSPB
	TST (A)+
	BIC #20,A
	BIC #300,TVSEL
	MOV TVCRLN(E),TVRADR
	MOV TVCRM1(A),TVMSK
	CLR UBR
	CLR TVRWIN
	MOV #-8.,TVWC
	TST TVCRM2(A)
	BNE .+4
	RTS PC
	TST TVWC
	BNE .-4
	MOV TVCRM2(A),TVMSK
	MOV #-9.,TVWC
	TST TVWC
	BNE .-4
	RTS PC
TVSPU:	SUB #110*12.,TVCRLN(E)
	BGE .+10
	ADD #77660,TVCRLN(E)
	RTS PC
TVSPDN:	ADD #110*12.,TVCRLN(E)
	CMP #77660,TVCRLN(E)
	BHI .+10
	SUB #77660,TVCRLN(E)
	RTS PC
TVCR:	CLR TVCRPS(E)
	MOV TVCRLN(E),B
	CLR A
	DIV #110,A
	MUL #110,A
	MOV B,TVCRLN(E)
	RTS PC
TVCEOL:	BIC #300,TVSEL
	CLR TVMSK
	MOV TVCRLN(E),B
	CLR A
	DIV #110,A
	TST B
	BNE TVCEO1
	MOV TVCRLN(E),TVRADR
	MOV #1001,TVINCR
	CLR UBR
	CLR TVRWIN
	MOV #-12.*36.-1,TVWC
	TST TVWC
	BNE .-4
	RTS PC
TVCEO1:	MOV B,A
	BIC #177761,B
	MOV TVEOLM(B),B
	MOV #12.,C
	MOV TVCRLN(E),TVRADR
	MOV #1044,TVINCR
	BIC B,TVRWIN
	SOB C,.-4
	SUB #106,A
	BEQ TVCEO2
	CLR TVINCR
	MOV TVCRLN(E),B
	ADD #2,B
	MOV B,TVRADR
	MOV #12.,C
	ASR A
	CLR UBR
	CLR TVRWIN
	MOV #1001,TVINCR
TVCEO3:	MOV A,TVWC
	ADD #110,B
	TST TVWC
	BNE .-4
	MOV B,TVRADR
	SOB C,TVCEO3
TVCEO2:	RTS PC

.ENDC

;PROCESS CHARS IN INPUT BUFFER
TOPIC1:	INC	TIQTO(E)	;INC CHAR PNTR
	DEC	TIQTON(E)	;DEC CHAR COUNT
	JSR	PC,TOIEC	;ECHO CHAR
TOPIC:	TST	TOPC(E)
	BNE	TOICM4	;IF OUTPUT BUFFER FULL, GO AWAY
	TST	TIQTON(E)
	BLE	TOICM4	;NO CHARS LEFT
	JSR F,TTYMPI
	MOVB	@TIQTO(E),D	;GET NXT CHAR
	JSR F,TTYMPO
	BR TOPIC1

;^M POSSIBLE END OF LINE
TOICM:	BIT	#TILIPM,TTYST(E)
	BEQ	TOICM3	;BR IF NOT IN LINE INPUT MODE
	TST	TIBC(E)
	BGT	TOICM3	;BR IF INSIDE BRACKETS
	INC	TIQTO(E)
	DEC	TIQTON(E)
	JSR	PC,TOIEC	;ECHO CHAR
	JSR PC,TYINQ
	SPUSH	A
	SPUSH	B
	SPUSH	C
	JSR F,TTYMPI
	MOV TIQI(E),A
	MOV #TITQ,B
	INC B
	MOV TIQN(E),C
	MOV C,TIEQN(E)
	MOVB -(A),-(B)
	SOB C,.-2
	JSR F,TTYMPO
	MOV B,TIEQO(E)
	SPOP	C
	SPOP	B
	SPOP	A
	JSR	PC,TYIRT	;RESET INPUT BUFFER
	MOV TIEQN(E),TIEQTN(E)
	MOV TIEQO(E),TIEQTO(E)
	SPUSH	U
	MOV	TTYU(E),U
	CLR	FLSRES(U)	;RUN THE GUY
	SPOP	U
	MOV #TICP5,(P)
	JSR PC,TOCINT
	SEZ
TOICM4:	RTS	PC
TOICM3:	CLZ	;NOT REALLY SPECIAL
	RTS PC

;^Y EDIT PREVIOUS LINE
TOICY:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^Y?
	JSR	PC,TOIECS	;IF NO, JMP HERE, ECHO ^Y
	MOV	#15,D
	JSR	PC,TOIECS	;ECHO CR
	MOV	#'_,D
	JSR	PC,TOIEC	;ECHO _
	BIS	#TIEDM,TTYST(E)	;PUT TTY IN EDIT MODE
	SEZ
	RTS	PC

;^X CLARIFY INPUT
;TYPE CR, REST OF EDIT BUFFER, CR, INPUT BUFFER
TOICX:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^X?
	MOV	#15,D	;NO
	BIT	#TIEDM,TTYST(E)
	BEQ	TOICX2	;BR IF NOT EDITING
	TST	TIEQN(E)
	BLE	TOICX2	;BR IF NOTHING IN EDIT BUFFER
	MOV	TIEQO(E),B
TOICX1:	JSR	PC,TOIECS	;ECHO CHAR IN D (SKIPS LEVEL IF Q FULL)
	JSR F,TTYMPI
	MOVB	(B)+,D	;GET NEXT EDIT CHAR
	JSR F,TTYMPO
	CMP B,#TITQ
	BLO	TOICX1	;BR IF STILL CHARS TO PRINT
	BHI	TOICX5	;BR IF JUST PRINTED LAST CHAR
	CMP	D,#15
	BNE	TOICX1	;LAST CHAR NOT CR, PRINT IT, THEN PRINT CR.
TOICX5:	MOV	#15,D
TOICX2:	TST	TIQN(E)
	BLE	TOICX4
	MOV #TIQM,B
TOICX3:	JSR	PC,TOIECS
	JSR F,TTYMPI
	MOVB	(B)+,D
	JSR F,TTYMPO
	CMP	B,TIQTO(E)
	BLOS	TOICX3	;BR IF MORE INPUT CHARS TO PRINT
TOICX4:	SEZ
	RTS PC


;ECHO CHAR FROM SPECIAL INPUT CHAR SUBR
TOIECS:	SPUSH	A
	JSR	PC,TOIEC	;ECHO
TOIES1:	SPOP	A
	TST	TOPC(E)
	BEQ	TOIECR
	MOV	(P)+,TOIPC(E)	;WHERE TO RETURN TO
	MOV	A,TOISVA(E)	;SAVE AC A
TOIECR:	RTS	PC

;ECHO RUBBED OUT CHAR
TOIRCS:	SPUSH	A
	JSR	PC,TOPRB
	BR	TOIES1

;ENTER SUBR THAT TOIECS EXITED
TOIENT:	TST	TOIPC(E)
	BEQ	TOIEN1
	MOV	TOIPC(E),@P	;RETURN HERE INSTEAD OF CALLING ROUTINE
	CLR	TOIPC(E)
	MOV	TOISVA(E),A
TOIEN1:	RTS	PC

;^C COPIES NEXT CHAR FROM EDIT QUEUE TO TYI QUEUE
TOICC:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
	JSR PC,TOICN4
TOICC1:	SEZ
	RTS PC


;^N COPIES NEXT WORD FROM EDIT TO TYI Q

TOICN:	BIT #TIEDM,TTYST(E)
	BEQ TOICN3
TOICN5:	JSR PC,TOICN4
	BEQ TOICN3
	JSR PC,TOISWS
	BEQ TOICN5
TOICN3:	SEZ
	RTS PC

TOICN4:	JSR PC,TOGED
	BEQ TOICN3
	JSR F,TTYMPI
	MOVB D,@TIQI(E)
	JSR F,TTYMPO
	JSR PC,TIBCK
	INC TIQN(E)
	INC TIQI(E)
	INC TIQTON(E)
	RTS PC

TIBCK:	CMP D,#'[
	BNE .+6
	INC TIBC(E)
	CMP D,#']
	BNE .+6
	DEC TIBC(E)
	CMP D,#'{
	BNE .+6
	INC TIBC(E)
	CMP D,#'}
	BNE .+6
	DEC TIBC(E)
	RTS PC


;^R COPY REST OF EDIT BUFFER TO INPUT BUFFER
TOICR:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
TOICR1:	JSR PC,TOICN4
	BEQ TOICC1
	BR TOICR1



;SKIP IF CHAR IN D IS WD SEPERATOR
TOISWS:	TSTB	D
	BMI	TOISW1	;BR IF QUOTED (HIGH BIT ON)
	BITB	#WSF,DTBL(D)
TOISW1:	RTS PC

;^D DELETES NEXT CHAR FROM EDIT QUEUE
TOICD:	BIT	#TIEDM,TTYST(E)
	BEQ	TOISW1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET NXT EDIT CHAR
	BEQ TOISW1
	JSR PC,TOPRB	;ECHO RUBBED OUT CHAR
TOICD1:	SEZ
	RTS PC


;^S SKIPS NXT WD IN EDIT QUEUE
TOICS:	BIT #TIEDM,TTYST(E)
	BEQ TOICD1
TOICS1:	JSR PC,TOGED
	BEQ TOICD1
	JSR PC,TOPRB
	JSR PC,TOISWS
	BNE TOICD1
	BR TOICS1


;^Q HAD EFFECT ON INPUT, DELETE FROM Q & ECHO
TOICQ:	JSR PC,TICQ
	JSR PC,TOIECS	;ECHO ^Q
	SEZ
	RTS PC
	
;RUBOUT RUBS OUT PREVIOUSLY PROCESSED CHAR
TOIRB:	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
	JSR	PC,TOPRB	;PRINT RUBBED OUT CHAR
	JSR	PC,TOIBCK	;CHECK FOR RUBBED OUT [ OR ]
	JSR PC,TOIOWP	;OVERWRITE RUBBED OUT CHAR
	SEZ
	RTS PC

TOICW2:	BIC	#TIRBM,TTYST(E)	;CLEAR RUB OUT MODE FLAG
	MOV	#15,D	;ECHO A C.R.
	JSR PC,TOIEC
	SEZ
	RTS PC

;^W RUBS OUT PREVIOUS WD
TOICW:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^W?
	JSR	PC,TOIQP	;NO, GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
TOICW1:	JSR	PC,TOIBCK	;CHECK FOR BRACKET
	JSR	PC,TOIRCS	;PRINT CHAR
	JSR	PC,TOIOWP	;BLT OVER CHAR
	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2
	JSR	PC,TOISWS	;SKIP IF WD SEPERATOR
	BEQ	TOICW1
TOICW3:	SEZ
	RTS PC

;[ INCS BRACKET COUNT
TOIOB:	INC TIBC(E)
	BGE	TOICB2
	BPT	;-BRACKETS
	BR TOICB2

;] DECS BRACKET COUNT IF THERE ARE ANY
TOICB:	TST	TIBC(E)
	BLE	TOICW3	;NO BRACKETS, IGNORE
	DEC	TIBC(E)	;DEC COUNT
TOICB2:	CLZ
	RTS PC


;GET PREVIOUS CHARACTER IN INPUT BUFFER AND SKIP
TOIQP:	SPUSH	A
	MOV	TIQTO(E),A	;GET POINTER TO CURRENT CHARACTER
	DEC A
	CMP A,#TIQM
	BLO	TOIQP1	;BR IF NO PREVIOUS CHARACTER
	JSR F,TTYMPI
	MOVB	(A),D
	JSR F,TTYMPO
	SPOP	A
	CLZ
	RTS PC
TOIQP1:
	SPOP	A
	SEZ
	RTS	PC

;CHECK FOR RUBBED OUT [ & ]
TOIBCK:	CMP	D,#'[
	BNE	.+6
	DEC	TIBC(E)	;IF CHAR WAS [, DECREMENT BRACKET COUNT
	CMP	D,#']
	BNE	.+6
	INC	TIBC(E)	;IF RUBBED OUT A ], INC BRACKET COUNT
	CMP D,#'{
	BNE .+6
	DEC TIBC(E)
	CMP D,#'}
	BNE .+6
	INC TIBC(E)
	RTS	PC

;OVERWRITE PREVIOUS CHARACTER
TOIOWP:	DEC TIQTO(E)
	DEC TIQN(E)
	DEC TITQN(E)
	DEC TIQI(E)
	RTS PC

;GET NEXT CHAR FROM EDIT BUFFER INTO D AND SKIP IF SUCCESSFUL
TOGED:	TST	TIEQN(E)
	BLE	TOGED2-2	;BR IF NOTHING LEFT IN EDIT BUFFER
	DEC	TIEQN(E)	;DEC CHAR COUNT
	JSR F,TTYMPI
	MOVB	@TIEQO(E),D	;GET NEXT CHAR
	JSR F,TTYMPO
	INC	TIEQO(E)
	CMP	D,#'[
	BNE	.+6
	INC	TIEBC(E)	;CHAR WAS [
	CMP	D,#']
	BNE	.+6
	DEC	TIEBC(E)	;CHAR WAS ]
	CMP D,#'{
	BNE .+6
	INC TIEBC(E)
	CMP D,#'}
	BNE .+6
	DEC TIEBC(E)
	CMP	D,#15
	BNE	TOGED2	;NOT A CR
	TST	TIEBC(E)	;CR, TEST FOR END OF EDIT LINE
	BGT	TOGED2
	CLR	TIEQN(E)	;EOL, CLR THIS TO BE XTRA CAREFUL
	SEZ
TOGED2:	RTS	PC


;PRINT RUBBED OUT CHAR IN D ON E'S TTY
TOPRB:	BIT	#TIECM,TTYST(E)
	BEQ	TOGED2	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BNE	TOIEC2	;ALREADY IN RUBOUT MODE
	BIS	#TIRBM,TTYST(E)
	BR	TOIEC1	;TYPE OPENING \


;ECHO CHARACTER IN D ON E'S TTY
TOIEC:	BIT	#TIECM,TTYST(E)
	BEQ	TOTYC1	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BEQ	TOIEC2	;ALREADY NOT IN RUBOUT MODE
	BIC	#TIRBM,TTYST(E)
	;PRINT CLOSING \
;PRINT \:
TOIEC1:	MOV	D,C	;SAVE CHAR
	MOV	#'\,D
	JSR	PC,TOCINQ	;PUT \ INTO OUTPUT Q
	JSR	PC,TOEXT	;FILLED UP Q
	MOV	C,D	;RESTORE CHAR
TOIEC2:		;PRINT CHAR IN D

;FALLS THROUGH!!!
;FALLS IN!!!

;PROCESS CHAR IN D INTO TTY IN E'S OUTPUT BUFFER
;IF BUFFER FILLS SAVE ACS C,D,PC AND EXIT
TOTYO:	BIT	#TIMAGE,TTYST(E)
	BEQ	TOTYO1	;BR IF NOT IN IMAGE MODE
TOTYOC:	JSR	PC,TOINQ	;PUT CHAR IN OUTPUT BUFFER
	JSR	PC,TOEXT
	RTS PC

TOTYO1:	MOVB	D,C
	BMI	TOTYOC	;BR IF CHAR HAS IMAGE MODE BIT SET
	BITB	#FOF,DTBL(C)
	BNE	TOTYO3	;BR IF SPECIAL ON OUTPUT
	CMP	D,#40
	BLT	TOTYO4	;BR IF CONTROL CHAR
	JSR	PC,TOCINQ
	JSR	PC,TOEXT
TOTYO2:	JMP	TOCLTO	;CHECK FOR LINE TOO LONG

;SPECIAL ON OUTPUT
TOTYO3:	MOVB	DTBL2(C),C
	JMP	@TOOCTB(C)
;CONTROL CHAR
TOTYO4:	MOV	#'^,D
	JSR	PC,TOCINQ	;PRINT ^
	JSR	PC,TOEXT
	MOV	C,D
	ADD	#100,D
	JSR	PC,TOCINQ	;PRINT CHAR +100
	JSR	PC,TOEXT
	MOV	C,D
	BR	TOTYO2

;OUTPUT BUFFER FULL, SAVE STATE OF WORLD AND RETURN ONE LEVEL UP
TOEXT:	MOV	C,TOSVC(E)
	MOV	D,TOSVD(E)
	MOV	(P)+,TOPC(E)
TOTYC1:	RTS	PC

;^A PRINTS AS CR
TOOCA:	CLR	CHARNO(E)
	MOV	#15,D
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	MOV	#1,D
	RTS	PC

;^H BACKSPACE DECREMENTS CHARNO IF NOT AT BEGINNING OF LINE
TOOCH:	TST	CHARNO(E)
	BLE	TOOCH1
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	DEC CHARNO(E)
TOOCH1:	RTS	PC

;CHECK IF LINE TOO LONG, IF SO PRINT CRLF
TOCLTO:	CMP	CHARNO(E),LINEL(E)
	BLT	TOOCM1	;BR IF NOT TOO LONG
;^M PRINTS AS CR LF
TOOCM:	MOV	D,C	;SAVE D
	CLR	CHARNO(E)	;CLR CHAR COUNT
	MOV	#15,D
	JSR	PC,TOINQ	;PRINT CR
	JSR	PC,TOEXT
	MOV	#12,D
	JSR	PC,TOINQ	;PRINT LINEFEED
	JSR	PC,TOEXT
	MOV	C,D
TOOCM1:	RTS	PC

;^I PRINTS SPACES TILL NEXT TAB STOP
TOOCI:	MOV	D,C
	MOV	#40,D
TOOCI1:	JSR	PC,TOCINQ
	JSR	PC,TOEXT
	BIT	#7,CHARNO(E)
	BNE	TOOCI1
	MOV	C,D
	RTS	PC

;*** INTERRUPT AND USER LEVEL ***

;PUT CHAR IN D INTO TTY IN E'S CIRCULAR OUTPUT QUEUE
;SKIP TWO WORDS IF SUCESSFULL
TOCINQ:	INC	CHARNO(E)
TOINQ:
	CMP TOQN(E),#TOQSZ
	BGE TOINQ2
	CMP TOQI(E),#TOQLM
	BLO TOINQ1
	MOV #TOQM,TOQI(E)
TOINQ1:	JSR F,TTYMPI
	MOVB	D,@TOQI(E)	;PUT CHAR IN BUFFER
	JSR F,TTYMPO
	INC	TOQI(E)
	INC	TOQN(E)	;INC # OF CHARS IN OUTPUT BUFFER
	SPUSH	E
	MOVB	MXNUM(E),E	;GET THIS TTY'S MULTIPLEXOR
	BMI	TOINQ4	;BR IF NOT PSEUDO OR MULTIPLEXED TTY
	INC	TOQN(E)	;INC MULTIPLEXOR'S CHARACTER COUNT
TOINQ4:	SPOP	E
	CMP TOQN(E),#TOQSZ
	BGE	TOINQ3	;BR IF Q FILLED NOW
	ADD	#4,@P	;SKIP RETURN TO SUCESS
TOINQ3:	RTS	PC

TOINQ2:
;	BPT	;TRIED TO PUT CHAR IN OUTPUT Q WHEN ALREADY FULL
	RTS	PC	;RETURN TO FAILURE
.STITL TELETYPE INITIALIZATION CODE
;INITIALIZATION CODE
TINIT:
;DECIDE WHICH PORTS TO USE & SET UP LOGICAL VARIABLES
	MOV	#NPORTS,A
	CLR	B	;INDEX TO PHYS TABLES
TINIT1:	MOVB	TILTTY(B),C	;LOGICAL INDEX
	BMI	TINIT2	;NOT LOGICAL
	MOVB	B,TIPTTY(C)	;PHYS TTY #
	MOVB	TILTTY+1(B),TIPTTY+1(C)	;MPXR #
	MOV	TYPTYP(B),TTYTP(C)
	MOV	TYRS(B),TOTSR(C)	;RCV RG ADDR
	BIT	#TPDM!TPTV,TTYTP(C)
	BNE	.+10	;BR IF DM11
	ADD	#4,TOTSR(C)	;TRANS RG ADDR
	BIT	#TPMPX,TTYTP(C)
	BEQ	TINIT2	;BR IF NOT MPXR
	MOV	#MXRCV,TIRCV(C)	;RCV DISPATCH ADDR
	MOV	#MXGOC,TOGOC(C)	;TRANS DISPATCH ADDR
	SPUSH	A
	SPUSH	B
	MOV	#4,A	;# OF MPXED DEVICES
	MOV #TOQM,D
	MOV C,E
	JSR F,TTYMPI
TINIT4:	TST	(B)+
	MOVB	TILTTY(B),(D)+	;PUT #'S OF MULTIPLEXEES IN OUTPUT Q
	SOB	A,TINIT4
	JSR F,TTYMPO
	SPOP	B
	SPOP	A
TINIT2:	TST	(B)+
	SOB	A,TINIT1

;DECIDE WHICH ARE USER TTYS
	MOV	NUSERS,A
	MOV	#UTYTB,B
	CLR	E
	CLR	U
TINIT3:	MOV	(B)+,E	;INDEX OF NEXT USER TTY
	TST	TTYU(E)
	BMI	.+4
	BPT	;ALREADY BELONGS TO A USER
	MOV	U,TTYU(E)
	MOV	E,UTTY(U)
	JSR	PC,TTYRT	;RESET (INITITALIZE) BUFFERS
	JSR	PC,UCINIT	;INITIALIZE CONSOLE VARIABLES
	ADD	#LUBLK,U
	SOB	A,TINIT3
	MOV	#SYSIDX,TTYU+NFTBOX	;MAKE SYS TBOX USER
	MOV	#TTYI,ITYI	;SET UP NEW USER TYI &TYO ADDRS
	MOV	#TTYO,ITYO
	JSR	PC,TINITH	;INIT HARDWARE
	JMP	NEXTUS
TTYMPI:	SPUSH TEMPAR
	SPUSH TEMPDR
	MOV #TTYDR,TEMPDR
	MOV TTYAR(E),TEMPAR
	SPUSH F
	MOV 4(P),F
	RTS PC

TTYMPO:	TST (P)+
	SPOP TEMPDR
	SPOP TEMPAR
	RTS F

;DON'T FORGET TBOXES
;HARDWARE INITIALIZATION
TINITH:	
.IFNZ NTY
	MOV	#100,TKS	;CONSOLE TTY
	MOV	#100,TPS
.ENDC
.IFNZ AI
	MOV	#111,DC0RS
	MOV	#113,DC0TS
.ENDC
.IFNZ GUY
	MOV #121,DC0RS
	MOV #123,DC0TS
.ENDC
	MOV	OMXRES+DC0TBN,DC0TB	;SLIGHT KLUGE, RESET TBOX
.IFZ DHON
	MOV	#DMCA+NFDMTY,DM0TBR
	MOV	#DMTT,TTP
	MOV	#10101,DM0CSR
.IFF
	MOV #20,A	;SET ALL LINES TO 300 BAUD
	CLR DH0SCR	;START AT ZERO
TINITX:	.IIF NZ AI,	MOV #16722,DH0LPR
.IIF NZ GUY,	MOV #6326,DH0LPR
	INC DH0SCR
	SOB A,TINITX
	CLR DH0SSR	;INTERUPT ON > 0 CHARS
	MOV #30100,DH0SCR
.ENDC
.IFNZ NTVS
	MOV #NTVCHN*400-400+16,A
TINITV:	MOV A,VIDSW
	SUB #400,A
	BGE TINITV
	CLR TVSEL
	MOV #NFTV,A
	MOV #1,TVINCR
TINITC:	MOV #90.,LINEL(A)
	TST (A)+
	SPL 7
	CLR TVRWIN
	CLR TVWC
	SPL 0
	TST TVWC
	BNE .-4
	MOV #10000,TVRWIN+2
	SPL 7
	INC TVSEL
	CMPB #NTVS,TVSEL
	BNE TINITC
	CLR TVSEL
	SPL 0
	.ENDC
	RTS	PC

;CROCKS

DMSQ:TI2Q:	RTS	PC

DC0SND:TB0SND:
	BPT
	RTS	PC

.STITL LOSS CHECKING ROUTINES
	FOO==%FNAM2
	VERN==VERN+%FNAM2


PARBRK:	BPT
	RTT
IOTBRK:	TST USER
	BLT BADTRP
	CMP P,#SPDLP
	BLOS BADTRP
	BIT #340,6(P)
	BNE BADTRP
	CLR PS
	SPUSH A
	CMP -(P),-(P)	;FOOL PRBTRP
	JSR	PC,PRBTRP
	CMP (P)+,(P)+
	SPOP A
	CLR ERPROC
	TST DEBSW
	BEQ IOTBR2
	SPUSH E
	MOV USER,E
	MOV UTTY(E),E
	TST TOTN(E)	;WAIT UNTIL THROUGH PRINTING
	BGT .-4
	SPOP E
	BPT	;BREAK IF DEBUGGING
IOTBR2:	.BUG.
BADTRP:	INC LOSSCT
	BEQ LOSER
	BGT LOST
	JSR	A,SPRINT	;ON SYS CONSOLE
	JSR	PC,PRBTRP	;PRINT MESSAGE
	SPREND
	CMP	(SP)+,(SP)+
	BPT
	RTT

EMTBRK:	BPT
LOSER:	PRTXT ^/I GIVE UP!/
LOST:	BPT
	BR .-2

PRBTRP:	BPRTXT ^/BAD TRAP: VECTOR /
	MOV 10(SP),A
	SUB #4,A	;MAKE IT REAL
	JSR PC,PRON
IOTBR1:	PRTXT ^/ TRAPPED FROM /
	MOV 14(SP),A
	JSR PC,PRON
	PRCR
	RTS	PC

SIMBPT:	HALT	;BPT TRAPS HERE IN SIMULATOR
	RTT
BEBRK:	TST P
	BEQ STKSRW
	SPUSH PS
	SPUSH #10
	BR IOTBRK	;FAKE AN IOT FROM LOC 6
STKSRW:	MOV #PFPDL,P	;HELP, I NEED A STACK!
	TST USER	;WAS IT IN USER CODE?
	BLT SYSSTK	;UGH, NO!
	BIT #340,2	;WAS IT IN AN INTERUPT ROUTINE?
	BNE SYSSTK	;UGH, YES!
	MOV #TYO,PCHR	;JUST THE USER LOSES
	JSR PC,STKCLB	;TELL HIM
	MOV UPDLP,P	;TRY TO RECOVER (UGH!)
	.BUG.
SYSSTK:	JSR PC,SPRINT	;MAKE IT PRINT ON SYS CONSOLE
	PRTXT ^/SYSTEM /
	JSR PC,STKCLB
	SPREND
	BPT
	SPL 0
	MOV #SPDLP,P	;IF THIS EVER WORKS
	JMP NEXTUS	;I'LL BE AMAZED

STKCLB:	PRTXT ^/STACK COLOBBERED AT /
	MOV 0,A
	JSR PC,PRON
	MOV #3,0
	MOV #-1,2
	JMP .CRLF
.HALT:	JSR PC,CKSST
	SPOP A
	SPUSH #0
	SPUSH A

PWRDWB:	JSR F,ACSAV
	JSR F,DEVSAV
	MOV #PWRUPB,PFBRV
	RESET
	HALT

PWRUPB:	JSR F,DEVRES
	JSR F,ACRES
	MOV #BEBRK,BEBRV
	MOV #PWRDWB,PFBRV
PWFNXM:
	RTT
PWRCLR:	JSR F,DEVSAV
	RESET
	RESET
	JSR F,DEVRES
	MOV #BEBRK,BEBRV
	SEZ
	RTS PC

DEVCLR:
	.IFNZ NDISP
	MOV #DISREL,NGREL
	.ENDC
	JSR PC,SEGSET
	MOV #100,LKS
	MOV #1666.,PCSTBF
	MOV #111,PCS
	JSR PC,TINITH
	MOV #100000,DKNRTY
	MOV #30.,DKPWFR
	MOV DSKCRB,A
	BEQ NODISK
	CMP #-1,10(A)
	BEQ RKREST
	JSR PC,DSKSG1
	BR NODISK
RKREST:	JSR PC,RKSG1
NODISK:	RTS PC
DEVSAV:	TST (P)+	;FLUSH SAVED F
	MOV #PWFNXM,BEBRV
	MOV SP,PFPDL
	MOV #PFPDL,SP
	SPUSH PPS
	.IFZ DHON
	.IFNZ NDM
	SPUSH DM0BAR
	.ENDC
	.ENDC
	SPUSH SSR0
	SPUSH PUREAR
	SPUSH PUREAR+2
	SPUSH PUREAR+4
	SPUSH TEMPDR	;THESE ARE THE SAME AS DISPAR+DR IF NEWDIS=1
	SPUSH TEMPAR
	MOV P,PWFPDL
	JMP (F)
DEVRES:	MOV PWFPDL,P
	JSR PC,DEVCLR
	SPOP TEMPAR
	SPOP TEMPDR
	SPOP PUREAR+4
	SPOP PUREAR+2
	SPOP PUREAR
	SPOP SSR0
	.IFZ DHON
	.IFNZ NDM
	SPOP DM0BAR
	.ENDC
	.ENDC
	SPOP PPS
	SPOP SP
	JMP (F)
	.STITL DISK STARTER

DSKSRT:
	MOV #SYSWPR,A	;LOOK FOR MOVING HEAD REQESTS
RKSR1:	BIT #100,14(A)
	BEQ RKSR2
	CMP #-1,10(A)
	BEQ RKSGO
RKSR2:	ADD #16,A
	CMP #16*MNUSRS+SYSWPR,A
	BHI RKSR1
	MOV #SYSWPR,A	;NEXT LOOK AT SYSTEM REQUESTS
DSKSR1:	BIT #100,14(A)
	BNE DSKSGO	;FOUND A REQUEST, GO DO IT
	ADD #16,A	;LOOK AT NEXT BLOCK
	CMP #16*MNUSRS+SYSWPR,A	;LAST BLOCK?
	BHI DSKSR1
	MOV SWPLST,A	;MOOBY SWAP OUT REQS?
	BNE DSKSGO
	RTS PC	;NO DISK REQUESTS EXTANT, BETTER LUCK NEXT TIME

DSKSGO:	MOV DKNRTY,DKRTYS	;SET NUMBER OF POSSIBLE RETRYS
	MOV A,DSKCRB	;ADDRESS OF BLOCK ABOUT TO BE SERVICED
	MOV (A),B
	BEQ DSKSG1	;BRANCH IF NO
	JSR PC,(B)	;RUN START ROUTINE
DSKSG1:	TST (A)+
	BIT #FDSCMS,4(A)
	BEQ .+6
	JMP DBLECH
	MOVB 12(A),B
	BIC #70,B
	CMPB #DREADC,B
	BEQ DSKSG2
	BIT #FDSCMS,(A)
	BNE DBLECH
DSKSG2:	MOV #DSKS,B	;START OF DISK I/O WORDS
	MOV #400,(B)+
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
.IFNZ MVONLY
	MOV C,-(P)
	MOV D,-(P)
	MOV (A)+,D
	MOV (A)+,C
	ASHC #-8.,C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
.IIF Z GUY,.IIF Z SITSD,.IIF Z RAF,ADD #20000,D
.IIF NZ GUY,ADD #20000,D
	MOV D,(B)+
	MOV (P)+,D
	MOV (P)+,C
	MOV PC,FIXFAK
.IFF
	MOV (A)+,(B)+	;LOW ORDER DISK ADDRESS
	MOV (A)+,(B)+	;HIGH "      "     "
.ENDC
	TST (A)+	;GO PAST UNUSED WORD
	MOV #DSKS,DSKRUN
	MOVB (A),B
.IIF NZ DSKCHK,	JSR PC,DSKGNR
	MOV B,DSKS	;SET FUNCTION, ENABLE INTERUPT, GO!!
	RTS PC

RKSGO:	MOV DKNRTY,DKRTYS
	MOV A,DSKCRB
	MOV (A),B
	BEQ RKSG1
	JSR PC,(B)
RKSG1:	CLR FIXFAK
	TST (A)+
	MOV #RKWC,B
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	MOV (A)+,(B)+	;DISK ADDRESS
	CMP (A)+,(A)+	;UNUSED WORDS
	MOV #RKCS,DSKRUN
	MOVB (A),B
.IIF NZ MVONLY,.IIF NZ DSKCHK, JSR PC,DSKGNR
	MOV B,RKCS
	RTS PC

DPROVK:	BIS #100,@DSKRUN
	RTS PC


.IFNZ DSKCHK
.IIF NZ GUY,DAMSK==37
.IIF NZ AI,DAMSK==17
DSKGNR:	JSR F,ACSAV
.IIF Z MVONLY,	MOV DSKWC,F	;THE NUMBER OF WORDS
.IIF NZ MVONLY,	MOV RKWC,F
	NEG F		;MAKE IT POSITIVE
	MOV F,D
.IFZ MVONLY
	MOV DSKAE,E	;THE DISK EXTENTION
	BIC #177740,E	;CLEAR ALL BUT THE TRACK EXT.
	ADD #DAMSK,D
	BIC #DAMSK,D
	ADD DSKA,D	;THE DISK ADDRESS
	BCC .+4
	INC E
	MOV D,DKSDA	;THIS IS WHAT THE DISK ADRESS SHOULD BE WHEN DONE
	MOV E,DKSAE	;THIS IS WHAT THE TRACK EXT. SHOULD BE
	MOV DSKCA,E	;GET THE CORE ADDRESS
.IFF
	ADD #377,D	;ROUND IT UP
	CLR C		;FOR THE DIVIDE
	ASH #-8.,D	;GET THE NUMBER OF SECTORS
	BIC #177400,D	;CLEAR THE TOP BYTE
	DIV #12.,C	;GET THE NUMBER OF TRACKS, AND SECTORS
	ASH #4,C	;PUT THE NUMBER OF TRACKS IN THE CORRECT PLACE
	MOV RKDA,B	;GET THE DISK ADDRESS
	ADD B,C		;GET TOTAL NUMBER OF TRACKS
	BIC #17,C	;CLEAR THE SECTORS IN THE TRACK ADDRESS
	BIC #177760,B	;THE NUMBER OF SECTORS
	ADD B,D		;GET FINAL SECTOR NUMBER
	CMP D,#14	;IS IT TO LARGE
	BLT .+6		;NO
	ADD #4,D	;SUBTRACT 14 AND ADD 20 TO TRACK
	ADD D,C		;GET THE TOTAL FINAL DISK ADDRESS
	MOV C,DKSDA	;THIS IS WHAT THE DISK ADDRESS SHOULD BE
	MOV RKBA,E	;GET THE BUSS ADDRESS
.ENDC
	MOV 2(P),D	;DSKS WITH MEM EX.
	BIC #177717,D	;CLEAR ALL BUT THE MEM EXT.
	ASL F		;TURN IT INTO A BYTE INDEX
	BCC .+6		;BRANCH IF IT DIDN'T OVERFLOW
	ADD #20,D	;INC THE MEM EXT
	ADD F,E		;WHAT THE CORE ADDRESS SHOULD BE
	BCC .+6		;DID IT OVERFLOW AGAIN
	ADD #20,D	;INC THE MEM EXT
	MOV D,DKSCS	;SAVE THE MEM EXT
	MOV E,DKSCA	;SAVE THE CORE ADDRESS
	JSR F,ACRES
	RTS PC		;DONE
.ENDC

;THIS CRETIN ROUTINE TAKES A RANDOM WORD ADDRESSED DISK
;REQUEST AND TRANSFORMS IT INTO SOMETHING THAT A SECTORIZED
;DISK WILL BE HAPPY WITH I.E.
;READING- IF TRANSFER DOES NOT START
;ON A SECTOR BOUNDARY, READ THE NEAREST SECTOR TO THE
;BEGGINING OF THE TRANSFER , THEN COPY THE WORDS NEEDED
;OUT OF A SPECIAL BUFFER, INTO THE USERS BUFFER
;IF THAT DOES NOT FINISH THE TRANSFER, READ THE REST
;OF THE WORDS NORMALLY
;WRITING (BLETCH!) IF TRANSFER DOES NOT START ON SECTOR
;BOUNDARY, READ FIRST SECTOR, COPY WORDS FROM USERS BUFFER
;INTO SPECIAL BUFFER, WRITE OUT THAT SECTOR. IF THAT
;DOESN'T FINISH THE TRANSFER, ROUND THE REQUEST TO
;A WHOLE NUMBER OF SECTORS AND DO A NOORMAL WRITE
;IF THAT DOES NOT FINISH THE TRANSFER, READ IN THE NEXT
;SECTOR, TRANSFER THE WORDS FROM THE USERS BUFFER TO THE
;SPECIAL BUFFER, AND WRITE THE SECTOR BACK OUT.
;THUS, IN THE WORST CASE, A WRITE REQUEST MAY REQUIRE
;2 READS AND 3 WRITES, OR A TOTAL OF 5(COUNT THEM!) TRANSFERS.
DBLECH:	CLR DBLFAK	;INDICATE WE SHOULD NOT FAKE INTERUPT RETURN
	MOV A,DBLASV	;TO MAKE THINGS LOOK RIGHT WHEN WE FINISH
DBLE14:	SPUSH C	;ENTER HERE TO PERFORM PRATIAL SECTOR TRANSFER
	SPUSH D	;AT BEG FOR READ ANN WRITE, AND AT END FOR WRITE(MAYBE)
	MOV #6,D	;FIRST, SAVE AWAY EITHER THE REAL REQUEST
	MOV #DBLPRO+2,B	;OR THE ONE WHICH IS IN PROGRESS
	MOV #DBLDO+2,C
DBLEC1:	MOV (A),(B)+	;THIS IS NOP ON SECOND ENTRY
	MOV (A)+,(C)+
	DEC D
	BNE DBLEC1
	SPOP D
	SPOP C
	BIT #FDSCMS,DBLPDA	;DOES IT BEGIN ON A SECTOR BOUNDARY?
	BNE .+6
	JMP DBLEC2
	BIC #FDSCMS,DBLDDA	;MOVE TO BEG OF SECTOR
DBLE16:	MOV #DSKFOO,DBLDCA	;ENTER HERE IF LESS THAN ONE SECTOR TRANSFER ON WRITE
	MOV #-FDSCSZ,DBLDWC
	MOV #DREADC,DBLDCM	;THIS IS A READ IN ANY CASE
	MOV #DBLDO,A
	MOV #DBLEC3,(A)	;SET UP PLACE TO RETURN
	BR DBLEC9

DBLEC3:	MOV DBLPDA,A	;GET PLACE WE REALLY WANT TO START AT
	BIC #-FDSCSZ,A	;MASK OFF HIGH BITS
	ASL A	;CHANGE TO CORE OFFSET
	ADD #DSKFOO,A	;REAL CORE ADDRESS
	MOV DBLPCA,B	;REAL BUFFER ADDRESS
	SPUSH TEMPAR
	SPUSH TEMPDR
	SPUSH B
	SPUSH A
	MOV DBLPCM,A
	ASH #-4,A
	BIC #177774,A
	ASHC #-6,A
	MOV #77406,TEMPDR
	MOV B,TEMPAR
	SPOP A
	SPOP B
	BIC #177700,B
	ADD #TEMPPG,B
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
	BEQ DBLEC8	;YES
DBLEC5:	MOV (B)+,(A)+	;FROM REAL BUFFER TO SPECIAL
	INC DBLPDA	;INCREMENT THE DISK ADDRESS WE ARE AT
	BIT #FDSCMS,DBLPDA	;ARE WE AT THE END OF A SECTOR?
	BEQ DBLE10	;YES
	INC DBLPWC	;HAVE WE TRANFERED ALL THE WORDS WE NEED?
	BNE DBLEC5	;NO
	DEC DBLPWC
	BR DBLE10
DBLEC6:	MOV #DWRTEC,DBLDCM	;WRITE OUT THIS SECTOR
	MOV #DBLDO,A
	MOV #DBLEC7,(A)	;PALCE TO RETURN WHEN DONE
DBLEC9:	MOV A,DSKCRB	;THIS KLUDGE FAKES OUT THE WORLD
	TST DBLFAK	;SHOUDL WE FAKE INTERUPT RETURN?
	BNE DBLE20	;YES
	INC DBLFAK	;NO, BUT NEXT TIME
	JMP DSKSG1
DBLE20:	JSR PC,DSKSG1	;BY MAKING LIKE THE DISK IS STILL RUNNING
	TST (P)+	;AND EXITS THE INTERUPT ROUTINE
	SPOP B	;WITHOUT RETURNING TO IT
	SPOP A
	RTT

DBLE15:	MOV A,(B)	;COME HERE FOR A WRITE OF LESS THAN A SECTOR
	CMP #-FDSCSZ,A
	BEQ DBLE19
	BR DBLE16	;BEGINNING ON A SECTOR

DBLE11:
	SPOP TEMPDR
	SPOP TEMPAR
	JSR PC,DBLEC4	;CORRECT DSIK ADDRESS AND WORD COUNT
	BR DBLEC7
DBLE10:
	SPOP TEMPDR
	SPOP TEMPAR
	SPUSH #DBLEC6	;FAKE JSR PC,
DBLEC4:
	SUB #TEMPPG,B
	BIC #77,DBLPCA
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
	TST DBLPDA	;DID WE PRODUCE A CARRY
	BNE .+6	;NO
	INC DBLPDE	;YES, INCREMENT EXTENSION
	INC DBLPWC	;DON'T NEGLECT WORD COUNT
	RTS PC

DBLEC8:	MOV (A)+,(B)+	;COME HERE FOR A READ
	INC DBLPDA
	BIT #FDSCMS,DBLPDA	;DONE WITH THIS SECTOR?
	BEQ DBLE11	;YES, GO MAKE CORRECTIONS
	INC DBLPWC
	BNE DBLEC8
	DEC DBLPWC
	BR DBLE11	;GO MAKE CORRECTIONS

DBLEC7:	TST DBLPWC	;ARE WE DONE?
	BNE DBLEC2	;NO, DO MULTI SECTOR TRANSFER
DBLE18:	MOV DBLASV,A	;REMEMBER HIM?
	CLRB 12(A)
	MOV -(A),B	;ADDRESS OF STOP ROUTINE
	BEQ .+4	;IF NO STOP ROUTINE
	JMP (B)	;LET IT DO THE RTS PC
	RTS PC	;OR WE'LL DO IT IF NONE

DBLEC2:	MOV #DBLPWC,B	;REMAINING WORD COUNT
	CLR A	;LEFTOVERS, IF ANYONE ASKS
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
	BEQ DBLE17	;THEN THINGS ARE SIMPLE
	MOV (B),A	;IT IS WRITE, GET THE REAL WORD COUNT
	BIC #FDSCMS,(B)	;MAKE IT INTO A WHOLE NUMBER OF SECTORS
	ADD #FDSCSZ,(B)	;LESS ONE SECTOR
	BEQ DBLE15	;LESS THAN ONE SECTOR TO WRITE
	SUB (B),A	;NUMBER OF WORDS LEFTOVER
	CMP #-FDSCSZ,A	;EXACTLY ONE SECTOR?
	BNE DBLE17	;NO
	ADD A,(B)	;A WHOLE NUMBER OF SECTORS
DBLE19:	CLR A	;WITH NO LEFTOVERS
DBLE17:	MOV A,DBLDWC	;SAVE COUNT OF LEFTOVERS
	MOV #DBLE13,-(B)	;PALCE TO RETURN TO
	MOV B,A	;PLACE WHERE REQUEST IS
	BR DBLEC9

DBLE13:	MOV #DBLPWC,A	;ADDRESS OF LEFTOVER COUNT
	SPUSH B
	MOV (A),B
	NEG B
	ASL B
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
	SPOP B
	SUB (A),DBLPDA	;AND DISK ADDRESS
	BCS .+6	;OPISITE OF ADC
	INC DBLPDE
	MOV DBLDWC,(A)	;SETUP FOR REMAINDER
	BEQ DBLE18	;TRANSFER REMAINDER
	JMP DBLE14	;NO REMAINDER
.STITL DISK REQUEST BLOCK GRABBER

SYDRBG:	SPUSH PS	;SAVE OLD PROSSESOR LEVEL
	MOV #340,PS	;LOCK OUT INTERUPTS
	MOV #SYSWPR,A	;LOOK FOR A FREE SYSTEM DISK REQUEST BLOCK
SDRBG1:	TST 14(A)	;IS IT FREE?
	BEQ SDRBG2
	ADD #16,A	;LOOK AT NEXT ONE
	CMP #16*MNUSRS+SYSWPR,A	;ANY MORE?
	BHI SDRBG1	;YES, SEE IF FREE
	SPOP PS	;NO MORE, WE HAVE LOST BIG
	BPT
	BR SYDRBG	;AND CERTAINLY WON'T UNLESS OUR PRIORITY IS <5
SDRBG2:	MOV #400,14(A)	;LABEL BLOCK AS IN USE, BUT NO REQUEST
	SPOP PS	;YOU CAN INTERUPT NOW.
	RTS PC


;USER ROUTINE TO FLUSH UNTIL DISK REQUEST POINTED TO BY A DONE

DSKWAI:	MOV USER,U
	JSR PC,DPROVK
DSKWA1:	TSTB (A)
	BNE DNDONE
	CLR (A)
	JSR PC,RUNME
	RTS PC
DNDONE:	MOV #FRDSKW,FLSRES(U)
	JSR PC,FLUSH
	BR DSKWA1
;GRABS A DISK BLOCK
;DISK BLOCK ADDR RETURNS IN B AND C
UBLKGR:	BIC #DSAMFL,FLAGS2
	MOV #DBITTB,A
	MOV #1,C
	MOV #-1,D
	CLR E
BLKGR1:	BIT C,(A)
	BNE BLKGR3
	INC D
	BGT BLKGR2
	BIS C,(A)
	MOV E,B
	MOV USER,U
	ADD UDSKAD(U),B
	MOV B,DBGRBD
BLKGR2:	CMP #2,D
	BLE BLKGR4
BLKGR3:	INC E
	ASL C
	BNE BLKGR1
	ROL C
	TST (A)+
	CMP #DBITBE,A
	BGE BLKGR1
	BIS #DSAMFL,FLAGS2
BLKGR4:	TST D
	BLT BLKGR5
	RTS PC
BLKGR5:	.BUG.

;FREES THE DISK BLOCK WHOSE LOW ORDER ADDR IS IN C
;BASE OF THIS DISK SPACE IS IN D
;ADDRESS OF THE APPRPRIATE BIT TABLE IS IN E
UBLKFR:	MOV USER,U
UBLKF1:	BIC #DSAMFL,FLAGS2
	SUB UDSKAD(U),C
	MOV #DBITTB,E
	MOV C,B
	BIC #177770,B
	ASR C
	ASR C
	ASR C
	ADD C,E
	BICB BMT(B),(E)
UBLKF2:	RTS PC

LCGRAB:	MOV USER,U
	CMP U,(D)
	BEQ LCGRA1
LCGRA2:	TST (D)
	BLT LCGRA1
	JSR PC,FLUSH
	BR LCGRA2
LCGRA1:	MOV U,(D)
	JSR PC,RUNME
	RTS PC

LCUGRB:	CMP USER,(D)
	BNE .+6
	MOV #-1,(D)
	SEZ
	RTS PC	.STITL DISK INTERUPT ROUTINE

DSKBRK:	SPUSH A
	SPUSH B
	MOV DSKS,A	;GET STATUS REGISTER
	TST A
	BLT DSKLOS
.IIF NZ DSKCHK,	JSR PC,DSKCK
DSKBR9:	MOV #400,DSKS
DSKBR2:	MOV DSKCRB,A	;POINTER TO FUNCTION WORD
	BEQ DSKBR1
	MOV (A),B
	BEQ .+4	;NO
	JSR PC,(B)	;YES, GO DO IT
	MOV DSKCRB,A
	CLR DSKCRB
	CLRB 14(A)	;REQUEST HAS BEEN SERVICED
DSKBR1:	JSR PC,DSKSRT	;LOOK FOR SOMETHING ELSE TO DO
DSKRET:	SPOP B
	SPOP A
	RTT

DSKLOS:	INC NRFERS
	BIT #40000,A	;IS IT FROZEN?
	BNE DSKLS1	;YES
	BIT #26000,A	;IS IT ONE OF WRITE CHECK, NED OR WRITE LOCKOUT?
	BEQ DSKRTY	;NO, MEANS IT IS ADDRESS PARITY OR
DKLOSE:	MOV #DKWLST,B
	JSR PC,PLOCS	;PRINT CONTENTS OF FOLLOWING ON SYS CONSOLE
			;DSKS
			;DSKAE
			;0
	HALT	;BIT THE BAG
	BR DSKRT1
DSKLS1:	BIT #2000,DSKAE	;NXM?
	BNE DKLOSE	;YES
DSKRTY:	INC DKRTYS	;HAVE WE BEEN THROUGH THIS BEFORE?
	BGE DKLOSE	;YES, TOO MANY TIMES
DSKRT1:	MOV #400,DSKS	;POWER CLEAR THE DISK
	MOV DSKCRB,A	;RETRY THE LAST OPERATION
	JSR PC,DSKSG1
	BR DSKRET

RKBRK:	SPUSH A
	SPUSH B
	MOV RKCS,A
	TST A
	BLT RKLOS
.IIF NZ MVONLY,	JSR PC,DSKCK	;CHECK THE DISKS
	CLR RKCS
	BR DSKBR2
RKLOS:	INC NRKERS
	BIT #66340,RKER	;BAD ERROR?
	BEQ RKSOFT
RKLOST:	MOV #RKWLST,B
	JSR PC,PLOCS	;PRINT FOLLOWING LOCS ON SYS CONSOLE
			;RKDS
			;RKER
			;RKCS
			;0
	HALT
	BR RKRT1
RKSOFT:	INC DKRTYS
	BGE RKLOST
RKRT1:	MOV #1,RKCS
	TSTB RKCS
	BGE .-4
	MOV DSKCRB,A
.IFNZ MVONLY
	TST FIXFAK	;IS IT A FIXED FAKE?
	BEQ RKRT2
	JSR PC,DSKSG1
	BR DSKRET
.ENDC
RKRT2:	JSR PC,RKSG1
	BR DSKRET

.IFNZ DSKCHK
DSKCK:	TST DSKCRB
	BNE .+4
	RTS PC
	SPUSH D
	SPUSH E
	BIT #1,DKSCA	;IS THE CORE ADDRESS CORRECT
	BNE DSKCRT
.IFZ MVONLY
	CMP DSKCA,DKSCA	;IS THE CORE ADDRESS THE SAME
	BNE BADCK	;NO
	CMP DSKA,DKSDA	;IS THE DISK ADDRESS THE SAME
	BNE BADCK	;NO
	MOV DKSAE,D	;THE THE SUPPOSED DISK EXTENSION
	MOV DSKAE,E	;GET THE ACTUAL
	XOR E,D	;CLEAR THE BITS THAT ARE THE SAME
	BIT #37,D	;THE EXTENSION BITS
	BNE BADCK	;SOME BITS WERE DIFFERENT
.IFF
;	CMP DKSCA,RKBA	;IS THE BUSS ADDRESS THE SAME
;	BNE BADCK
	CMP DKSDA,RKDA	;IS THE DISK ADDRESS THE SAME
	BNE BADCK
.ENDC
	MOV DKSCS,D	;GET THE SUPPOSED CORE EXTENSION
	MOV DSKS,E	;GET THE ACTUAL VALUES
	XOR E,D		;CLEAR THE BITS THAT ARE THE SAME
	BIT #60,D	;ARE THE BITS DIFFERENT
	BNE BADCK
DSKCRT:	SPOP E
	SPOP D
	RTS PC
BADCK:	MOV #DSKS,E	;THIS IS A DBUGGING FEATURE
.IIF Z MVONLY,	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	JSR F,ACSAV
	JSR A,SPRINT
	MOV #DKEPR,F
DKEPLP:	MOV (F),A
	BEQ EDKEPR
	JSR PC,PRONL
	PRTXT ^\/ IS \
	MOV @(F)+,A
	JSR PC,PRONL
	PRTXT ^/ SB /
	MOV @(F)+,A
	JSR PC,PRONL
	PRCR
	BR DKEPLP
EDKEPR:	SPREND
	JSR F,ACRES
	TST DEBSW
	BEQ .+4
	240
	ADD #14,P
	SPOP E
	SPOP D
.IIF NZ MVONLY,	JMP RKLOS
.IIF Z MVONLY,	JMP DSKLOS
.ENDC
;	PUSH F
;	SPUSH ADDR
;	JSR PC,LSH7
;CONVERTS SECTOR ADDR IN D TO WORD ADDR IN ADDR AND ADDR+2
;D STAYS INTACT (AS OPPOSED TO PREVIOUS VERSION)
LSH7:	MOV P,F		;POINT F AT PUSHED ADDR
	TST (F)+	;(SKIP PUSHED PC)
	SPUSH D
	SPUSH A
	SPUSH C
	CLR C		;EXTEND SECTOR ADDR
	ASHC #7,C	;SHIFT 7 PLACES
	MOV (F)+,A	;ADDRESS TO PUT RESULT
	MOV D,(A)+	;LOW ORDER
	MOV C,(A)	;HIGH ORDER
	SPOP C
	SPOP A
	SPOP D
	SPOP F		;RETURN ADDRESS TO F
	TST (P)+	;POP ADDR
	RTS F		;RETURN, RESTORING F
;SPUSH #(ADDR OF 3-WORD BLOCK)
;JSR PC,DSKSEC
;	3-WORD BLOCK:
;POINTER TO CORE ADDRESS
;POINTER TO DISK SECTOR ADDRESS
;READ OR WRITE COMMAND
;	USES 4 WORDS ON PDL;
;	IF THIS INCREASES CHECK PPUSHL.
DSKSEC:	SPUSH E
	MOV 4(P),E	;E POINTS TO FIRST WORD OF 3-WD BLOCK
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-200,(A)+	;ALWAYS THIS LONG
	MOV @(E)+,D
	SPUSH B
	SPUSH F
	MOV USER,F
	MOV SLOTAS(F),F
	MOV SLOTHA(F),B
	SUB #PURE,D
	ADD SLOTCA(F),D
	ADC B
	MOV D,(A)+
	ASH #4,B
	BIS B,6(A)
	SPOP F
	SPOP B
	MOV @(E)+,D	;DISK ADDRESS
	BIT #160000,D	;IS IT THE FIXED HEAD DISK?
	BNE DSKSC1	;NO
	SPUSH F
	SPUSH A		;PLACE TO PUT WORDED DISK ADDR
	JSR PC, LSH7
	ADD #4,A
	BR DSKSC3
DSKSC1:	SUB #20000,D	;MAKE IT INTO A REAL MOVING DISK ADDR
	SPUSH D
	BIC #17777,(SP)
	BIC #160000,D
	SPUSH C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	SPOP C
	ADD (SP)+,D
	MOV D,(A)+
	MOV #-1,(A)+	;THIS IS A MOVING HEAD REQUEST
DSKSC3:
	TST (A)+
	BISB (E),(A)	;ENTER REQUEST BYTE
	JSR PC,DSKWAI	;WAIT FOR COMPLETION
	SPOP E
	SPOP (P)
	RTS PC
	.STITL NEW FILING
.IFZ SITSD
FILE==200
DIR==300
TYPMSK==177477
SHRBB==4000
EOFBIT==0
LBEB==0
.IFF
FILE==2000
DIR==1000
TYPMSK==170777
SHRBB==10000
EOFBIT==100000
LBEB==400
.ENDC

;USER PRIMITIVE ROUTINES

;DIRSET TAKES A LIST AND SETS THE CURRENT DIRECTORY

DSET:	JSR PC,SETNM	;GET NAME OF DIRECTORY
	BNE DSET1	;INPUT IS A LIST
SETDEF:	MOV DEFDIR,CURDIR	;SET CURRENT DIRECTORY
	MOV DEFDSK,WCHDSK	;WHICH DISK?
	RTS PC
DSET1:	JSR PC,SETDEF
DIRSET:	JSR PC,GNWRD	;GET A WORD FROM THE LIST
	BNE .+4		;ANY LEFT?
	RTS PC		;NONE LEFT, DONE
	JSR PC,DIRGET	;GET NEXT ITEM FROM LIST
	BR DIRSET	;AND CONTINUE WITH THE NEXT NAME


DIRGET:	MOV #NAME,E	;PLACE TO STORE THE NAME
	JSR PC,NFNGET	;GET A FILE NAME
	MOV #NAME,E
	CMPB #'^+200,(E)	;IS IT ^?
	BNE DIRGT1	;NOPE
	MOV CURDIR,E	;POINTER TO CURRENT DIRECTORY
	JSR PC,DBREAD	;SET DISK FOR READING
.IF Z SITSD
	MOV #DBUF,ENTBEG	;SET ADDRESS OF START OF ENTRY
.IFF
	MOV DBUF,E
	INC E
	BIC #177401,E
	ADD #DBUF,E
	MOV E,ENTBEG
.ENDC
	BR DIRGT9
DIRGT1:	TSTB (E)	;HAVE WE PASSED LAST CHAR OF NAME?
	BLT DIRGT2	;YES
	TSTB (E)+	;NO, FIND IT
	BGE .-2
	CMPB #';+200,-(E)	;IS THIS THE ROOT DIRECTORY?
	BNE UDREAD	;NO, SET UP DISK BLOCK FOR READ
	BISB #200,-(E)	;YES, SET CODE FOR FILE
	MOV #NDISKS,D	;NO. OF DISKS
	CLR A
DIRGT3:	MOV FDNAMP(A),B	;B NOW POINTS TO ADDRESS FOR NAME
	MOV #NAME,E
	TST DBITAD(A)	;BLOCK NO. OF BIT TABLE
	BLT DIRGT4	;NOT HERE- TRY OTHER DISK
DIRGT6:	CMPB (E)+,(B)	;COMPARE CHARACTERS OF NAME
	BNE DIRGT4	;MISMATCH
	TSTB (B)+	;ANY MORE CHARACTERS?
	BGE DIRGT6	;YES
	MOV A,WCHDSK	;SET DISK
	BR DIRGT8
DIRGT4:	TST (A)+	;NEXT DISK
	SOB D,DIRGT3	;TRY AGAIN
	ERROR+BDD	;NO MORE- BAD DIRECTORY
DIRGT2:	CMPB #';+200,(E)	;ROOT DIRECTORY?
	BNE UDREAD	;NO, A USER'S DIRECTORY
DIRGT8:	MOV #46,CURDIR	;YES, SET IT AS CURRENT DIRECTORY
	RTS PC
UDREAD:	MOV #NAME,E
	JSR PC,DIRSER	;LOOK FOR THAT NAME
	BNE .+4		;FIND IT?
	ERROR+NED	;NON EXISTENT DIRECTORY
DRREAD:	MOV @ENTBEG,A	;GET TYPE OF ENTRY FOUND
	BIC #TYPMSK,A	;FLUSH EVERYTING BUT TYPE
	CMP #DIR,A	;IS IT A DIRECTORY?
	BEQ .+4
	ERROR+ENDR	;ENTRY NOT A DIRECTORY
DIRGT9:	JSR PC,DESSET	;SET UP NEW DIRECTORY
	MOV DSKADR,CURDIR	;AND MAKE THIS THE CURRENT DIRECTORY
	RTS PC
.DIRSET:
	BIT #7777,@S	;CHECK NAME OF DIRECTORY ON S-PDL
	BNE .DIRS1
	SPOPS A		;NOTHING TO DO
	SEZ
	RTS PC
.DIRS1:	JSR PC,DSET	;SET THE DIRECTORY
	JSR PC,DIRGET	;SET UP FILES
USEENT:	MOV CURDIR,DEFDIR	;THIS IS NOW DEFAULT DIRECTORY
	MOV WCHDSK,DEFDSK	;THIS IS NOW DEFAULT DISK
	SEZ
	RTS PC
.USE:	MOV WCHDSK,E	;CURRENT DISK
	MOV FDUSEA(E),CURDIR
	JSR PC,SETNM	;GET THE DIRECTORY NAME
	BNE .USE1	;INPUT IS A LIST (MORE TO COME)
.USE3:	MOV #NAME,E	;POINTER TO  NAME
	JSR PC,NFNGET	;GET THE NAME
.USE4:	MOV #NAME,E
	JSR PC,DIRSER	;LOOK FOR THE SUB-DIRECTORY
	BNE .USE2	;FOUND IT
	ERROR+NED	;NON-EXISTENT DIRECTORY
.USE2:	JSR PC,DRREAD	;MAKE SURE THIS IS A LEGIT. DIRECTORY
	BR USEENT	;SET NEW DISK AND DIRECTORY DEFAULTS
.USE1:	JSR PC,DIRSET	;MORE DIRECTORIES?
	BR .USE3	;SAME THING AGAIN
LOGIN:	MOV @S,A	;GET USER NAME OFF S-PDL
	SPUSHS A	;PUSH A COPY OF IT
	BIT #7777,A	;IS IT LEGAL
	BNE .+4
	ERROR+IUN	;INVALID USER NAME
	JSR PC,.USE	;SET DIRECTORY(IES)
	MOV USER,E	;ADDRESS OF USER TABLE
	ADD #UNAME,E	;ADDRESS OF CURRENT USER NAME
	JSR PC,NFNGET	;GET THE NAME
	MOV #NAME+4,E
	MOV #"IT+100000,-(E)	;SET FILE NAME "INIT"
	MOV #"IN,-(E)
	JSR PC,DIRSER	;IS IT THERE?
	BEQ LOGIN2	;NOPE, LOOK FOR MAIL
	JSR PC,GETFI1	;GET THE FILE AND CHECK ITS TYPE
	CMP #FILE,A	;IS IT A CASE OF MISTAKEN IDENTITY?
	BNE LOGIN2	;YES, INDEED
	JSR PC,.REDF4	;READ THE FILE
	JSR PC,.READ1
LOGIN2:	MOV #NAME+4,E	;SET UP NAME OF MAIL ENTRY
	MOV #"IL+100000,-(E)
	MOV #"MA,-(E)
	JSR PC,DIRSER	;IS THERE ANY MAIL?
	BEQ LOGIN1	;NO
	JSR PC,GETFI1	;GET A COPY OF THE NAME AND CHECK IT
	CMP #FILE,A	;ONCE AGAIN, MAKE SURE ITS A FILE
	BNE LOGIN1	;IT'S NOT, WE'RE THROUGH
LANGC	<PRTXT ^/PRINT MAIL?/>,<
	PRTXT ^/COURRIER A IMPRIMER?/>
	JSR PC,QUEST	;GET THE REPLY
	BNE LOGIN1	;DOESN'T WANT IT- WE'RE THROUGH
	JSR PC,.REDF4	;READ THE MAIL FILE (ISN'T THIS A CRIME?)
	JSR PC,.POF1	;PRINT IT
LANGC	<PRTXT ^/DELETE MAIL?/>,<
	PRTXT ^/MESSAGE RECU?/>
	JSR PC,QUEST	;GET THE REPLY
	BNE LOGIN1	;LEAVE THE MAIL
	JSR PC,GCDIR	;GET THE FILE
	JSR PC,.DELT5	;DELETE IT
LOGIN1:	SEZ
	RTS PC		

.DELETE:
	MOV #WDIRSW,D	;LOCK WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB
	JSR PC,GETFIL	;GET THE ENTRY
	CMP #FILE,A	;IS IT A FILE?
	BEQ .+4		;IF YES, OK
	ERROR+CDE	;CAN'T DELETE THAT ENTRY
	CMP #46,CURDIR	;IS IT THE ROOT DIRECTORY?
	BNE .+6		;NO
	JSR PC,CKSST	;CHECK SYSTEM STATUS
.DELT5:	JSR PC,DESSET	;SET THE DESCRIPTOR
	JSR PC,.DELT3	;FREE THE BLOCK
	JSR PC,DELENT	;DELETE THE ENTRY
	JSR PC,WBITS	;WRITE BIT TABLE ONTO DISK
	MOV #WDIRSW,D	;WE'RE DONE, FREE THE WORLD UP
	JMP LCUGRB
WDELBL:	JSR PC,DESINC
.DELBL:	JSR PC,DESST	;SET UP DESCRIPTOR
	CLR FILFLG
.DELT3:	BIT #SHRBB,DESSAV  ;IS THIS A SHARED BLOCK?
	BNE .DELT2	;YES, DON'T DELETE IT
	MOV DSKADR,A	;ADDRESS OF THE BLOCK
	TST DEOFBL	;ARE WE BEYOND THE LAST BLOCK?
	BGT .DELT2	;YES
	MOV WCHDSK,B	;NO, SET THE DISK
	INC NBLKFR(B)	;ADDRESS OF NEXT BLOCK
	JSR PC,BITGET	;GET THE APPROPRIATE BIT
	BICB BMT(B),(C)	;FREE THE BLOCK
	JSR PC,GNBLK	;GET THE NEXT BLOCK ADDRESS
	BR .DELT3
.DELT2:	RTS PC
DELENT:	.IF Z SITSD
	MOV @ENTBEG,A	;GET FIRST WORD
	BIC #177700,A	;LENGTH OF ENTRY IN WORDS
	ASL A		;NOW IN BYTES
	MOV #DBUF+1776,D	;HOPEFULLY, THE NUMBER OF FREE BYTES
	ADD A,(D)	;CORRECT IT
	MOV ENTBEG,B	;BEGINNING OF ENTRY TO FLUSH
	MOV B,C
	ADD A,C		;BEGGINING OF NEXT ENTRY
	SUB (D),D	;END OF USEFUL INFORMATION
.IFF
	MOV @ENTBEG,A
	INC A
	BIC #177401,A	;LENGTH OFABOUT TO BE DELETED ENTRY IN EVEN BYTES
	MOV #DBUF+6,D	;GET POINTER TO THE EOF BYTE COUNT
	SUB A,(D)	;THE BYTES WE ABOUT TO FREE
	MOV ENTBEG,B	;PLACE WHERE THE ENTRY IS NOW
	MOV B,C
	ADD A,C		;FIRST WORD NOT BELONGING TO ENTRY
	MOV (D),D	;NEEW DIRECTORY END
	ADD #DBUF,D
.ENDC
.DELT4:	MOV (C)+,(B)+	;COPY USEFUL STUFF OVER USELESS
	CMP B,D		;DONE?
	BLE .DELT4
	MOV (C)+,(B)+	;MAKE SURE
	MOV CURDIR,E	;WRITE OUT THE DIRECTORY
	JSR PC,DBWRTE
	RTS PC
MAIL:	SPUSH DEFDIR	;SAVE DEFAULT DIRECTORY
	SPUSH DEFDSK	;SAVE DEFAULT DISK
	JSR PC,.USE	;SET DIRECTORY TREE
	SPOP DEFDSK
	SPOP DEFDIR
.IFZ SITSD
	MOV #"MA,NAME	;SET ENTRY NAME TO "MAIL"
	MOV #"IL+100000,NAME+2
.IFF
	MOV #"MA,NAME+10	;SET ENTRY NAME TO "MAIL"
	MOV #"IL+100000,NAME+12
.ENDC
	JSR PC,.OPNA3	;OPEN MAIL FILE
	MOV #.WRTEC,PCHR	;CHARS. IN BUFFER INTO OUTPUT DEVICE
	PRTXTC ^/------/
LANGC	<PRTXT ^/MAIL FROM />,<
	PRTXT ^/EN PROVENANCE DE />
	MOV USER,A
	ADD #UNAME,A	;USER WHO SENT MAIL
	JSR PC,POIHD2	;PRINT THE NAME
	JSR PC,.CRLF	;CARRIAGE RETURN, LINEFEED
	JSR PC,UDATEG	;SET THE DATE
	SPUSH #1
	JSR PC,PRINT	;PRINT THE DATE
	JSR PC,.SPACE
	JSR PC,UTIMEG	;SET THE TIME
	SPUSH #1
	JSR PC,PRINT	;PRINT THE TIME
	SPUSH PRMTCH	;SAVE NORMAL PROMPT CHARACTER
	MOV #'_,PRMTCH	;NEW ONE IS "_"
	MOV #TYO,PCHR
MAIL2:	JSR PC,RDSTR	;READ A STRING
	BEQ MAIL3	;NO CHARACTERS TYPED
	MOV @S,B	;POINTER TO STRING
	JSR PC,.LOADB	;FIRST CHARACTER
	CMP #'.,B	;IS IT A PERIOD?
	BEQ MAIL1	;YES (NO MORE INPUT)
	JSR PC,.FILEP
	BR MAIL2
MAIL1:	SPOP PRMTCH	;GET BACK OLD PRMTCH ("?")
	MOV #.WRTEC,PCHR
	SPOPS A
	PRTXTC ^/------/
	MOV #TYO,PCHR
	JMP .WRTCL
MAIL3:	BIT #RBRKF,TFLAGS
	BEQ MAIL2
	MOV USER,U
	CLR BRAKE(U)
	JSR PC,BRAKR	;ALLOW TYPING
	PRTXTC ^/STOPPED/
	BR MAIL2

.READ:	JSR PC,.READF
.READ1:	MOV #.READCH,GCHR
	MOV PC,REDFLG
	JSR PC,SAVEVL
	.IF NE WADESW
	PUSH #0	;NO. OF ARGS
	JSR PC,SAVPPS
	BIS #DORF,FLAGS
	BIS #1,CPDLP
	.ENDC
RMLOOP:	CMP #TYI,GCHR
	BEQ RMLOO1
	JSR PC,RDSTR
	BEQ RMLOO2
	JSR PC,READ
	BEQ RMLOOP	;NO TOKENS
	JSR PC,EVLINE
	BEQ RMWDW
	POPS A
	BR RMLOOP
RMWDW:	ERROR+WDW
RMLOO1:	TST TOPRNM	;DONE, PROC DEF PENDING?
	BEQ .+6
	JSR PC,END
	MOV #RET,PSTOPR
	.IF NE WADESW
	JSR PC,RESPPS
	POP B
	.ENDC
	JSR PC,RESEVL
	MOV B,FLAGS
	MOV CTP,C
	CLR D
	JMP PSTOP6
RMLOO2:	BIT #RBRKF,TFLAGS
	BEQ .+4
	ERROR+BRK
	CMP #TYI,GCHR
	BEQ RMLOO1
	BR RMLOOP

.WRITE:	JSR PC,.WRTEF
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	BR .+2
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	SEZ
	RTS PC

.READF:.OPENR:	JSR PC,GETFIL	;FIND THE ENTRY
.REDF5:	CMP #FILE,A	;IS IT A FILE?
	BEQ .+4		;YES
	ERROR+CRE	;CAN'T READ THAT ENTRY
.REDF4:	JSR PC,DESSET	;SET THE DESCRIPTOR
	MOV #1,FILFLG	;SET THE OPEN FILE FLAG FOR READ
.REDF1:	MOV #-1,A
	TST DEOFBL	;IS THIS THE LAST BLOCK OF FILE
	BGT .REDF2	;YES
	MOV DSKADR,E	;CURRENT SECTOR FOR THIS FILE
	JSR PC,DBREAD	;SET DISK FOR READING
	MOV #2000,A	;LENGTH OF BLOCK
	TST DEOFBL	;IS THIS THE LAST BLOCK OF FILE?
	BNE .REDF2	;YES, RETURN
.IF Z SITSD
	BITB #40,DESSAV+1	;IS LAST WORD OF BLOCK USED?
	BEQ .REDF3	;YES
	SUB DBUF+1776,A	;NUMBER OF BYTES USED
	BR .REDF2
.REDF3:	BITB #20,DESSAV+1	;IS LAST BYTE OF BLOCK USED?
	BEQ .REDF2	;YES
	DEC A		;NO,ONE LESS BYTE IS USED
.IFF
	MOV FBYTES,A
	BIC #176000,A
.ENDC
.REDF2:	MOV A,DSKNCH	;NUMBER OF CHARACTERS IN DISK BUFFER
	SEZ
	RTS PC

;READ A CHARACTER
.READC:	TST FILFLG	;IS FILE OPEN FOR READING?
	BLE .REDC1	;NO
	TST DEOFBL	;LAST BLOCK OF FILE?
	BGT .REDC1	;YES
	TST DSKNCH	;ARE THERE ANY CHARS?
	BNE .REDC3	;YES
	JSR PC,.REDC3	;GET THE NEXT BLOCK IF IT EXISTS
	BR .READC	;GO CHECK IT OUT
.REDC3:	MOVB @DBUFPT,D	;CHARACTER POINTED TO BY DISK BUFFER POINTER
	INC DBUFPT	;NEXT CHARACTER
	DEC DSKNCH	;ONE LESS CHARACTER IN BUFFER
	BGT .REDC2	;ANY MORE CHARACTERS?
	JSR F,ACSAV	;SAVE REGISTERS
	JSR PC,GNBLK	;GET NEXT BLOCK
	JSR PC,.REDF1	;READ THE FILE
	JSR F,ACRES	;RESTORE REGISTERS
	RTS PC
.REDC1:	CLR FILFLG	;CLEAR FILE FLAG
	CLR REDFLG	;CLEAR READ FLAG
	CLR DSKNCH	;NO MORE CHARACTERS IN BUFFER
	MOV #EOFCHR,D	;D POINTS TO LAST CHARACTER OF FILE
.REDC2:	RTS PC
.OPENA:	JSR PC,DSET	;SETS DIRECTORY
.IIF Z SITSD,	MOV #NAME,E	;NAME OF FILE
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,NFNGET	;SET FILE NAME
.OPNA3:.IIF Z SITSD,	MOV #NAME,E	;NAME OF FILE
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,DIRSER	;FIND THE FILE
	.IFZ <ENG&FR>
	BEQ .WRTF2	;NOT HERE, WRITE A NEW ONE
	.IFF
	BNE .+6
	JMP .WRTF2
	.ENDC
	MOV @ENTBEG,A	;FOUND IT, THIS IS START OF  NTRY
	BIC #TYPMSK,A	;FLUSH ALL BUT TYPE
	CMP #FILE,A	;MAKE SURE IT'S A FILE
	BEQ .+4		;OK
	ERROR+CRE	;NOPE, CAN'T READ THAT ENTRY
	JSR PC,DESSET	;SET THE DESCRIPTOR
	JSR PC,DELENT	;FLUSH THE OLD ENTRY
.OPNA2:	JSR PC,.REDF1	;READ FILE INTO BUFFER
	TST DEOFBL	;ANY MORE BLOCKS LEFT?
	BGE .OPNA1	;NO
	JSR PC,GNBLK	;YES, GET ADDRESS OF  NEXT ONE
	BR .OPNA2	;READ IN NEXT BLOCK
.OPNA1:	MOV DSKADR,LBLKAD	;SAVE LAST BLOCK ADDRESS
	MOV DSKADR,DBGOT	;BACK POINTER TO START OF LAST BLOCK
.IIF Z SITSD,	BIC #TYPMSK,DESSAV
.IIF NZ SITSD,	MOV #EOFBIT!FILE!LBEB,DESSAV
	MOV CURDIR,WRTDIR	;SET CURRENT DIRECTORY TO BE WRITTEN
	MOV #2000,A	;START OF NEW BLOCK
	SUB DSKNCH,A	;GET AMOUNT OF FREE SPACE IN CURRENT BLOCK
	BEQ .WRTF1	;NONE LEFT
.IIF NZ SITSD,	ADD A,FBYTES	;ROUND UP FBYTES
	ADD DSKNCH,DBUFPT	;BUFFER POINTER SET TO FIRST FREE BYTE
	MOV A,DSKNCH	;NEW NUMBER OF CHARACTERS IN BUFFER
	MOV #-1,FILFLG	;SET OPEN FILE FLAG FOR WRITE
	SEZ
	RTS PC
QUEST:	MOV USER,U	;SETS USER
	MOV UTTY(U),E	;USER TELETYPE NUMBER
	BIS #TIMAGI,TTYST(E)	;TTY STATUS TO INPUT IMAGE MODE
	BIC #TILIPM,TTYST(E)	;CLEAR LINE INPUT MODE
	JSR PC,GTYI	;GET THE CHARACTER
	SPUSH D		;SAVE IT
	JSR PC,.CRLF	;PRINT CR AND LINEFEED
	SPOP D		;GET CHARACTER
.IFNZ FR
	CMP #'O,D
	BEQ QUEST1
	CMP #'O+40,D
	BEQ QUEST1
.ENDC
.IFNZ ENG
	CMP #'Y,D	;IS IT "Y"?
	BEQ QUEST1
	CMP #'Y+40,D	;IS IT SMALL Y
.ENDC
QUEST1:	RTS PC

.WRTEF:.OPENW:	JSR PC,DSET	;SET DIRECTORY
.IIF Z SITSD,	MOV #NAME,E	;GET ENTRY NAME
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,NFNGET	;SET IT
.IIF Z SITSD,	MOV #NAME,E	;GET ENTRY NAME
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,DIRSER	;LOOK FOR ENTRY NAME
	BEQ .WRTF2	;NOT HERE
LANGC	<PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/>,<
	PRTXT ^/FICHIER DEJA EXISTANT. A DETRUIRE?/>
	JSR PC,QUEST	;GET REPLY
	BEQ .+4		;OK, DELETE IT
	ERROR+EAES	;ENTRY ALREADY EXISTS
	JSR PC,.DELT5	;DELETE OLD ENTRY
.WRTF2:	MOV #EOFBIT!FILE!LBEB,DESSAV	;SET DESCRIPTOR TO TYPE FILE
	JSR PC,DESWST	;SET DESCRIPTOR MODE FOR DISK HACKING
.WRTF1:	JSR PC,DBGET	;GET THE RIGHT DISK BLOCK
	MOV #2000,DSKNCH	;LENGTH OF BLOCK
	MOV #DBUF,DBUFPT	;PTR TO START OF DISK BUFFER
	MOV #-1,FILFLG		;SET OPEN FILE FLAG FOR WRITE
	MOV CURDIR,WRTDIR	;CURRENT DIRECTORY BEING WRITTEN
	SEZ
	RTS PC

.WRTEC:	DEC DSKNCH	;ONE LESS CHARACTER IN BUFFER
	BLT .WRTC1	;NO MORE LEFT
	MOVB D,@DBUFPT	;CURRENT CHARACTER INTO BUFFER
	INC DBUFPT	;POINTER TO NEXT BYTE
	RTS PC
.WRTC1:	JSR F,ACSAV	;SAVE REGISTERS
	MOV DBGOT,E	;BACK POINTER TO START OF BLOCK
	JSR PC,DBWRTE	;SET DISK BLOCK FOR WRITING
	JSR PC,.WRTF1	;GET THE BLOCK AND SET ALL THE VARIABLES
	JSR F,ACRES	;RESTORE THE REGISTERS
	BR .WRTEC

.WRTCL:	MOV DSKNCH,A	;NO. OF CHARACTERS IN BUFFER
	BEQ .WRCL1	;NO MORE LEFT
.IF Z SITSD
	CMP #1,A	;IS THERE JUST 1 LEFT?
	BEQ .WRCL2	;YES
	MOV A,DBUF+1776	;LAST WORD OF BLOCK HAS NO. OF CHARS USED
	BISB #40,DESSAV+1
.IFF
	SUB DSKNCH,FBYTES
	BGE .WRCL3
	DEC FPAGE
	ADD #20000,FBYTES
.WRCL3:
.ENDC
.WRCL1:	MOV DBGOT,E	;BACK PTR TO START OF BLOCK
	JSR PC,DBWRTE	;SET BLOCK FOR WRITING
	MOV #WDIRSW,D	;LOCK IN WRITE SWITCH
	JSR PC,LCGRAB	;RUN THE DISK REQUEST
	MOV WRTDIR,CURDIR	;CURRENT DIR HAS BEEN WRITTEN
	JSR PC,DESINS	;INSERT DESCRIPTOR
	JSR PC,WBITS	;WRITE BIT TABLE ONTO DISK
	CLR FILFLG	;CLEAR FILE FLAG
	MOV #WDIRSW,D	;LOCK IN WRITE SWITCH
	JMP LCUGRB
.WRCL2:	BISB #20,DESSAV+1
	BR .WRCL1

.DELI:	MOV #WDIRSW,D	;LOCK IN WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB	;RUN THE DISK REQUEST
	JSR PC,GETFIL	;GET THE ENTRY
	CMP #DIR,A	;IS IT AN INDEX?
	BEQ .+4		;YES
.DELI1:	ERROR+CDE	; CAN'T DELETE THAT ENTRY
	JSR PC,DESSET	;SET THE DESCRIPTOR
	MOV DSKADR,E	;CURRENT SECTOR FOR FILE
	JSR PC,DBREAD	;SET THE BLOCK FOR READING
	MOV #DBUF,A	;POINTER TO DISK BUFFER
.IF Z SITSD
	MOV (A),B	;FIRST WORD OF BUFFER
	BIC #177700,B	;LENGTH OF ENTRY IN WORDS
	ASL B		;NOW IN BYTES
	ADD B,A		;SUPPOSED END OF ENTRY
	TST (A)		;IS SOMETHING THERE?
.IFF
	MOV (A),B	;FIRST WORD OF 1ST ENTRY
	INC B
	BIC #177401,B
	ADD B,A		;GET TO SECOND ENTRY
	MOV (A),B	;THIS IS THE SELF ENTRY
	INC B
	BIC #177401,B
	ADD A,B		;GET END OF SECOND ENTRY
	SUB #DBUF,B	;GET LENGTH OF 1ST+2ND ENTRIES IN BYTES
	CMP DBUF+6,B	;COMPARE WITH LENGTH OF DIR
.ENDC
	BNE .DELI1	;OOPS!
	MOV CURDIR,E	;ADRESS OF CURRENT DIRECTORY
	JSR PC,DBREAD	;HACK BLOCK AT THIS ADDRESS FOR READ
	JMP .DELT5

.FILEP:	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .+4		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
	SPUSH PCHR
	MOV #.WRTEC,PCHR
	SPUSH #1
	JSR PC,PRINT	;PRINT THE CHARACTERS
.FILP1:	SPOP PCHR
	SEZ
	RTS PC

.FILER:	TST FILFLG	;IS FILE OPEN FOR READ?
	BGT .+4		;YES
	ERROR+NFO	;NO,INVALID FILE NAME
	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	SPOP GCHR
	CLZ
	RTS PC

.CLOSF:
.IIF NZ DRIBF,	BIC #DRIBBF,FLAGS2
	MOV #TYI,GCHR	;RESET IT FOR TTY INPUT
	CLR REDFLG	;CLEAR READFLAG
	CLR WRTFLG	;CLEAR WRITE FLAG
	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .WRTCL
	CLR FILFLG	;CLEAR FILE FLAG
	RTS PC

GETFIL:	JSR PC,DSET	;SET THE DIRECTORY
	MOV #NAME,E
	JSR PC,NFNGET	;WHAT FILE?
GETFI1:	MOV #NAME,E
	JSR PC,DIRSER	;FIND THE FILE
	BNE .+4		;FOUND IT
	ERROR+FNF	;FILE NOT FOUND
	MOV @ENTBEG,A	;WHAT TYPE OF ENTRY
	BIC #TYPMSK,A	;FLUSH ALL BUT TYPE
	RTS PC

.IFNZ AI
.XOR:	JSR PC,CKSST	;CHECK STATUS
	JSR PC,G1NARG	;GET AN ARGUMENT
	MOV B,XORF	;SET THE XOR FLAG
	SEZ
	RTS PC
.ENDC

.FILEO:	TST FILFLG	;IS A FILE OPEN
	BEQ .+6		;NO
	JMP RTTRUE	;RETURN TRUE
	JMP RTFALS	;RETURN FALSE

.POI:	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO
	CLR DBGOT
	JSR PC,SETDEF	;SET DEFAULT DISK AND DIRECTORY
	JSR PC,GCDIR	;GET THE DIRECTORY
	MOV #DBUF,ENTBEG   ;ENTRY AT START OF DISK BUFFER
.POI1:	.IF NZ SITSD
	MOV ENTBEG,A
	SUB #DBUF,A
	CMP A,DBUF+6
	BHIS .POI3
.ENDC
	MOV @ENTBEG,A	;FIRST WORD OF ENTRY
	BEQ .POI3	;NO MORE ENTRIES BELOW THIS INDEX
	BIC #TYPMSK,A
.IIF NZ SITSD,SWAB A
.IIF Z SITSD,ASH #-5,A	;WHAT TYPE OF ENTRY?
	JSR PC,@POITAB(A)	;SERVICE THAT TYPE
.POI2:	MOV @ENTBEG,A
.IF Z SITSD
	BIC #177700,A	;LENGTH OF ENTRY IN WORDS
	ASL A		;NOW IN BYTES
.IFF
	INC A
	BIC #177401,A
.ENDC
	ADD A,ENTBEG	;START OF NEXT ENTRY
	BR .POI1

POIHED:	JSR PC,POFNM	;PRINT OUT HEADING
	JMP .CRLF	;CARRIAGE RETURN, LINEFEED
POILNK:	.BUG.		;NOT IMPLEMENTED
POIFLE:	SPACE		;INDENT TWO SPACES
	SPACE
	JSR PC,POFNM	;PRINT OUT FILE NAME
	SPACE
	JSR PC,DESSET	;SET DESCRIPTOR
	CLR -(P)	;HOLDS NUMBER OF BLOCKS OF CURRENT FILE
POIFL2:	TST DEOFBL	;LAST BLOCK OF FILE?
	BGT POIFL1	;YES
	INC (P)		;NO, INCREMENT NO. OF BLOCKS USED
	JSR PC,GNBLK	;GET ADDRESS OF NEXT BLOCK
	BR POIFL2	;CHECK AGAIN
POIFL1:	SPOP A		;NO. OF BLOCKS USED
	ADD A,DBGOT	;PTR TO LAST BLOCK OF ENTRY
	JSR PC,PRDN	;PRINT NO. OF BLOCKS USED BY FILE
	JMP .CRLF
POIDIR:	INC DBGOT	;NEXT BLOCK
	MOV #'I,D
	JSR PC,TYO	;PRINT "I" TO INDICATE INDEX
	SPACE
	BR POIHED	;PRINT OUT HEADING
.POI3:	MOV DBGOT,A	;TOTAL NUMBER OF BLOCKS USED
	JSR PC,PRDN
LANGC	<PRTXTC ^/ BLOCKS./>,<
	PRTXTC ^/ BLOCS./>
	MOV WCHDSK,A
	MOV NBLKFR(A),A	 ;NO. OF FREE BLOCKS
	JSR PC,PRDN
LANGC	<PRTXTC ^/ FREE BLOCKS./>,<
	PRTXTC ^/ BLOCS LIBRES./>
	SEZ
	RTS PC
POFNM:	MOV ENTBEG,A
	TST (A)+	;SKIP FIRST WORD OF ENTRY
.IF NZ SITSD
	BGE .+6
	ADD #10,A
	TST (A)+
.ENDC
POIHD2:	MOVB (A)+,D	;CHAR. OF FILE NAME
	BLT POIHD1	;NO MORE CHARACTERS
	JSR PC,@PCHR	;PRINT THE CHARACTER
	BR POIHD2	;LOOK FOR NEXT ONE
POIHD1:	JSR PC,@PCHR	;LAST CHARACTER
POIPAR:	RTS PC
POTHED:	CMP CURDIR,DEFDIR	
	BEQ POIHED	;PRINT OUT CURRENT DIRECTORY NAME
	RTS PC		;RETURN IF NOT THE SAME
.POTREE:
	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO	;FILE ALREADY OPEN
	CLR DBGOT
	JSR PC,SETDEF	;SET DEFAULT DISK AND DIRECTORY
	CLR DSKNSC	;NO CHARACTERS IN BUFFER
.POTR2:	JSR PC,GCDIR	;GET CURRENT DIRECTORY
	MOV #DBUF,ENTBEG   ;ENTRY AT START OF DISK BUFFER
.POTR1:	.IF NZ SITSD
	MOV ENTBEG,A
	SUB #DBUF,A
	CMP A,DBUF+6
	BHIS .POTR3
.ENDC
	MOV @ENTBEG,F	;FIRST WORD OF ENTRY
	BEQ .POTR3
.IF Z SITSD
	BIT #300,F	;IS IT TYPE DIRECTORY?
.IFF
	BIC #TYPMSK,F
	BEQ .POTR4	;IGNORE THE SELF ENTRY
	CMP #4000,F
.ENDC
	BEQ .POTR4	;YES
	MOV DSKNSC,A	;NO. OF SECTORS IN FILE
	BEQ .POTR4	;NO MORE
.POTR6:	JSR PC,.SPACE	;INDENT TWO SPACES
	JSR PC,.SPACE
	SOB A,.POTR6	;IS ENTRY ANOTHER LEVEL DOWN?
	BR .POTR4	;NO, PRINT THE NAME
.POTR3:	DEC DSKNSC	;ONE LESS SECTOR
	BLT .POI3	;DONE- PRINT OUT TOTAL NO. OF BLOCKS USED
	MOV (P),E
	SPOP CURDIR	;GET BACK PREVIOUS DIRECTORY
	POP ENTBEG	;GET BACK START OF OLD ENTRY
	JSR PC,DBREAD	;SET BLOCK FOR READING
	BR .POTR5
.POTR4:	BIC #TYPMSK,F	;FIND TYPE OF ENTRY
.IF Z SITSD
	ASH #-5,F
.IFF
	SWAB F
.ENDC
	JSR PC,@POTTAB(F)	;AND SERVICE APPROPRIATE TYPE
.POTR5:	MOV @ENTBEG,A	;FIRST WORD OF ENTRY
.IF Z SITSD
	BIC #177700,A
	ASL A		;NO. OF BYTES IN ENTRY
.IFF
	INC A
	BIC #177401,A
.ENDC
	ADD A,ENTBEG	;START OF NEXT ENTRY
	BR .POTR1	;GO GET IT

POTDIR:	JSR PC,POIDIR	;PRINT OUT INDEX
	INC DSKNSC	;ONE MORE SECTOR (ONE LEVEL DOWN)
	TST (P)+	;BYPASS TOP OF P-PDL
	PUSH ENTBEG	;SAVE START OF ENTRY
	SPUSH CURDIR	;SAVE CURRENT DIRECTORY
	JSR PC,DRREAD	;SET UP NEW CURRENT DIRECTORY
	BR .POTR2

.CRINDEX:
	JSR PC,DSET	;SET THE DIRECTORY
	MOV #NAME,E	;PTR TO INDEX NAME
	JSR PC,NFNGET	;GET THE NAME
.CRIN1:	JSR PC,GCDIR	;GET THE CURRENT DIRECTORY
	MOV #WDIRSW,D	;LOCK IN WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB	;RUN DISK REQUEST
.IF Z SITSD
	MOV #20300,DESSAV  ;DESCRIPTOR SET TO TYPE DIRECTORY
	JSR PC,DESWST	;DESCRIPTOR WRITE MODE SET TO SKIP
	JSR PC,DBGET	;GET THE DISK BLOCK
	JSR PC,DESINS	;INSERT THE DESCRIPTOR
	BIC #377,DESSAV	;CLEAR LOW-ORDER BYTE OF FIRST WORD
	JSR PC,DESWST
	MOV CURDIR,A
	JSR PC,DBGOTN
	MOV DBGOT,CURDIR	;BLOCK OF CURRENT DIRECTORY
	MOV #2000,DBUF+1776	;LENGTH OF ENTRY (BYTES)
	MOV #DBUF,ENTBEG	;START OF ENTRY
	JSR PC,DESINX
	JSR PC,WBITS	;WRITE BIT TABLE OUT
	MOV #WDIRSW,D
	JMP LCUGRB
.IFF
	MOV #DIR,DESSAV
	JSR PC,DESWST
	MOV #-100,LBLKAD	;GARENTEE A SET ADDRESS TYPE
	JSR PC,DBGET		;GET A BLOCK FOR THE DIRECTORY
	JSR PC,DESINS
	MOV DBUF,C
	INC C
	BIC #177401,C
	ADD #DBUF,C
.CRIN3:	MOV -(C),-(P)
	CMP #DBUF,C
	BNE .CRIN3
	MOV @ENTBEG,B
	INC B
	BIC #177401,B
	ADD ENTBEG,B
.CRIN2:	MOV -(B),-(P)
	CMP B,ENTBEG	
	BNE .CRIN2
	MOV #DBUF,A
	MOV (P)+,C
	BIC #177400,C
	MOV C,(A)
	ADD #10,(A)
	BIS #LBEB!EOFBIT!4000,(A)+
	MOV (P)+,(A)+
	SUB #3,C
	ASR C
	CLR (A)+
	CLR (A)+
	MOV #-1,(A)+
	MOV #-1,(A)+
	MOV (P)+,(A)+
	SOB C,.-2
	MOV (P)+,C
	BIC #177400,C
	SUB #10,C
	MOV C,(A)+
	MOV (P)+,(A)+
	SUB #3,C
	ASR C
	ADD #10,P
	MOV (P)+,(A)+
	SOB C,.-2
	CLR (A)
	SUB #DBUF,A
	MOV A,DBUF+6
	MOV DBGOT,E
	JSR PC,DBWRTE
	JSR PC,WBITS
	MOV #WDIRSW,D
	JMP LCUGRB
.ENDC

.POF:	JSR PC,.READF
.POF1:	JSR PC,.READC
	CMP #EOFCHR,D
	BEQ .POF2
	JSR PC,@PCHR
	BR .POF1
.POF2:	CLR FILFLG
	RTS PC
.PREAD:.PWRIT:	ERROR+OOP
.IFNZ DRIBF
DRIBBLE:
	JSR PC,.OPENA	;OPEN THE FILE FOR APPENDING
	BIS #DRIBBF,FLAGS2	;SAY WE ARE DRIBBLING
	SEZ
	RTS PC

NODRIBBLE:
	JSR PC,.CLOSF	;CLOSER THE FILE
	BIC #DRIBBF,FLAGS2	;NO MORE DRIBBLE
	SEZ 
	RTS PC
.ENDC


GNWRD:	;INPUT	POINTER TO LIST OF WORDS ON S
	;OUTPUT	-IF LIST IS NOT EMPTY,
	;	 POINTER TO  FIRST OF LIST ON TOP OF S
	;	 POINTER TO BF OF LIST NEXT
	;	 Z WILL BE CLEAR
	;	-IF LIST IS EMPTY, POP S AND SET Z
	;IF F LIST ISNT A WORD, WTA ERROR ISSUED
	JSR F,CACSAV
	MOV @S,B
	BIT #7777,B	;IS LIST EMPTY?
	BEQ GNWRD1
	JSR PC,.LOADB	;NO GET 1ST NODE
	MOV A,@S	;SAVE BF ON S
	PUSHS B		;YES - PUSH FIRST ON S
	JSR F,CACRES
	CLZ
	RTS PC
GNWRD1:	POPS A		;EMPTY LIST QUIT
	JSR F,CACRES
	SEZ
	RTS PC
NFNGET:		;INPUT	ADDRESS OF BLOCK IN E
		;	PTR TO LSTR ON S
		;OUTPUT	PUT 1ST 10. CHAR OF LSTR INTO BLOCK
		;	SET 200 BIT IN LAST CHAR, POP S
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,B	;POINTER TO FILE NAME IN B
	MOV #LSTR,A	;DATA TYPE FOR CONVERSION
	JSR PC,CONVER	;MAKE NAME AN LSTR
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME (CONVERSION FAILED)
	MOV B,@S	;POINTER TO NEW DATA ON STACK
	BIC #170000,B	;LEAVE DATA TYPE
	MOV B,GNCN	;"GET NEXT CHARACTER" NODE
	MOV #10.,C	;TAKES ONLY THIS MANY CHARACTERS
NFNG1:	JSR PC,GNC	;GET NEXT CHAR
	CMP #15,D	;UGH! (IS IT A CARRIAGE RETURN?)
	BEQ NFNG2	;YES- NO MORE CHARACTERS
	MOVB D,(E)+	;STORE THE NEXT CHARACTER
	MOV D,TEMP
	SOB C,NFNG1	;KEEP GOING UNTIL WE HIT TEN
NFNG2:	BISB #200,-(E)	;SET 200 BIT IN LAST CHAR AND QUIT
	JSR F,CACRES	;GET BACK THE OLD REGISTERS
	JSR PC,SPOPT
	RTS PC
SETNM:		;INPUT	LIST OR WoRD ON S
		;OUTPUT	IF WORD, OUTPUT WORD AND SET Z
		;	IF LIST, OUTPUT LzST AND BL OF LIST ON S
		;		PUT BL ON TOP AND CLEAR Z
		;	OTHERWISE ERROR
	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO	;FILE ALREADY OPEN
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,C	;GET INPUT
	BIT #7777,C
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME
	MOV C,B		;SEE IF IT'S A LIST
	BIC #7777,C
	CMP C,#LIST
	BEQ SETNM1	;YES, IT IS
SETNM2:	JSR F,CACRES	;OK, SET Z AND QUIT
	SEZ
	RTS PC
SETNM1:	JSR PC,COPYL	;COPY LIST - INPUT IN B
		;OUTPUT IN B;  C POINTS TO LAST NODE IN NEW LIST
		; E POINTS TO 2ND TO LAST NODE
	JSR PC,.LDP2
	MOV A,@S
	MOV E,C
	BEQ SETNM3	;NO BUTLAST
	JSR PC,.LDP1	;FIX UP  LINK
	BIC #7777,A
	JSR PC,.STP1
	BIS #LIST,B
SETNM4:	PUSHS B
	JSR F,CACRES
	CLZ
	RTS PC
SETNM3:	MOV #LSTR,B
	BR SETNM4
;LOWER LEVEL ROUTINES

;GCDIR GET CURRENT DIRECTORY
;READS IN BIT TABLE IF IT IS NOT ALREADY IN

GCDIR:	TST FDBITI	;IS THE BIT TABLE IN?
	BGE GCDIR1	;YES, GO AHEAD
	TST USER	;IS IT USER 0?
	BEQ GCDIR1	;HE IS ALLOWED ALWAYS
GCDIR4:	JSR PC,FLUSH	;EVERYONE ELSE
	TST FDBITI	;HAS TO WAIT FOR INITIALIZE TO FINISH
	BLT GCDIR4
	JSR PC,RUNME
GCDIR1:	MOV CURDIR,E
	JMP DBREAD
IDISKS:	TST FDBITI	;IS IT IN NOW?
	BGE GCDIR5	;NO, IT'S NOW OUR RESPONSIBLITY
	CLR WCHDSK
GCDIR2:	MOV #46,CURDIR	;GET THE ROOT DIRECTORY IN
	MOV #BITS,E	;THE NAME OF THE BIT TABLE
	JSR PC,DIRSER	;TRY TO FIND IT
	BNE IDISK1
	MOV #-1,DBITAD(F)
	BR IDISK2
IDISK1:	JSR PC,DESSET	;SETUP THE DESCRIPTOR
	MOV WCHDSK,F
	MOV DSKADR,DBITAD(F)	;ADDRESS OF THE BIT TABLE
	MOV FDNAMP(F),A
.IF Z SITSD
	MOV #DBUF+2,D
.IFF
	MOV #DBUF+14,D
.ENDC
	MOVB (D)+,(A)+
	BGE .-2
	JSR PC,RBITS
	MOV @FDBITP(F),A
	MOV A,D
	DEC A
GCDIR3:	JSR PC,BITGET
	BITB BMT(B),(C)
	BEQ .+4
	DEC D
	DEC A
	BGE GCDIR3
	MOV WCHDSK,F
	MOV D,NBLKFR(F)
	MOV #-1,FDUSEA(F)
	MOV #USRFIL,E
	JSR PC,DIRSER
	BEQ IDISK2
	JSR PC,DESSET
	MOV WCHDSK,F
	MOV DSKADR,FDUSEA(F)
IDISK2:	ADD #2,WCHDSK
	INC FDBITI
	BNE GCDIR2
GCDIR5:	CLR WCHDSK
.IIF NZ SITSD,MOV #4,WCHDSK	;START ON PSEUDO-FIXED DISK IF SITS FORMAT
	RTS PC


;DIRSER  DIRECTORY SEARCH
;SEARCH CURRENT DIRECTORY FOR SPECIFIED FILE
;ENTER WITH POINTER TO FILE NAME IN E
;Z IS SET IF FOUND, ELSE CLEARED
DIRSER:	SPUSH E
	JSR PC,GCDIR	;GET CURRENT DIRECTORY
	MOV #DBUF,ENTBEG  ;DISK BUFFER ADDRESS IS START OF ENTRY
.IF Z SITSD
DIRSR1:	MOVB @ENTBEG,B	;B CONTAINS NO OF WORDS IN ENTRY
	BIC #177700,B
	ASL B		;LENGTH IN BYTES
	ADD B,ENTBEG
.IFF
	MOV @ENTBEG,B
	INC B
	BIC #177401,B
	ADD B,ENTBEG
DIRSR1:	MOV @ENTBEG,B
	INC B
	BIC #177401,B
	ADD B,ENTBEG
.ENDC
DIRSR4:	MOV (P),E
	MOV ENTBEG,B
	TST (B)+	;SKIP THE FIRT WORD
	BEQ DIRSR3	;FOUND THE END OF THE DIRECTORY
.IF NZ SITSD
	BGE .+6
	ADD #10,B
	TST (B)+
.ENDC
DIRSR2:	CMPB (B)+,(E)+	;COMPARE NAMES BYTE BY BYTE
	BNE DIRSR5	;MISMATCH
	TSTB -1(B)	;END OF NAMES?
	BGE DIRSR2	;NOT YET
	TST (P)+	;YES, FLUSH TEMP ON STACK
	CLZ
	RTS PC
DIRSR3:	TST (SP)+
	SEZ
	RTS PC
DIRSR5:	MOVB -(B),A	;MISMATCHED CHARACTER IN DIRECTORY
	MOVB -(E),E	;SAME THING IN DESIRED NAME
	BIC #177600,A	;GET RID OF CRAP
	BIC #177600,E	;SAME
	CMP A,E		;WHAT IS THE REAL RELATIONSHIP?
	BGT DIRSR3	;DIRECTORY>DESIRED, WE ARE PAST WHAT WE WANT
	BLT DIRSR1	;DESIRED>DIRECTORY, MAYBE IT'S FURTHER ON.
	TSTB (B)	;SAME, IS DIRECTORY SHORTER?
	BLT DIRSR1	;YES, MAYBE FURTHER ON.
	BR DIRSR3


;DESSET SET UP DESCRIPTOR

.IF Z SITSD
DESSET:	CLR DBCNT	;CLEAR DISK BLOCK COUNT
	CLR DSKADR	;CLEAR CURRENT SECTOR
	MOV #-1,DEOFBL
	MOV ENTBEG,A	;START OF NEW ENTRY
	MOV #DESSAV,B	;START OF OLD DESCRIPTOR
	MOV (A),C
	BIC #177700,C	;LENGTH OF NEW ENTRY IN WORDS
	MOV (A)+,(B)+	;WRITE OVER OLD STUFF
	SOB C,.-2
DESST:	MOV #DESSAV,A	;START OF NEW DESCRIPTOR
	MOV (A),D	;LENGTH IN BYTES
	BIC #177700,D
	MOV A,C
	MOV (A),E
	BIC #177477,E	;FLUSH ALL BUT TYPE
	CMP #200,E	;IS IT A FILE
	BNE .+6		;NO, DIRECTORY
	SUB #2,D	;YES, DATE IS NOT PART OF DESCRIPTOR
	ASL D		;NUMBER OF BYTES
	ADD D,C		;END OF DESCRIPTOR
DESST2:	TSTB -(C)	;GET RID OF TRAILING BLANKS
	BEQ .-2
DESST1:	MOV C,DESEPT	;REAL END OF ESCRIPTOR
	CMP #100,E
	BNE .+4
	ERROR+BADE	;BAD ENTRY TYPE
	TST (A)+	;SKIP FIRST WORD
	TSTB (A)+	;FIND END OF NAME
	BGE .-2
	BR GNBLK1
.IFF
DESSET:	CLR DBCNT	;CLEAR DISK BLOCK COUNT
	CLR DSKADR	;CLEAR CURRENT SECTOR
	MOV #-1,DEOFBL
	MOV ENTBEG,A	;START OF NEW ENTRY
	MOV #DESSAV,B	;START OF OLD DESCRIPTOR
	MOV (A),C
	BIC #177400,C
	CMP C,#60.
	BLE .+4
	ERROR+BADD
	MOVB (A)+,(B)+
	SOB C,.-2
DESST:	MOV #DESSAV,A
	MOV (A),D
	BIC #177400,D
	ADD A,D
	DEC D
	MOV D,DESEPT
	BIT #EOFBIT,(A)+
	BEQ .+6
	ADD #10,A
	TST (A)+
	TSTB (A)+
	BGE .-2
	BR GNBLK1
.ENDC

;GNBLK GET THE ADDRESS OF THE NEXT BLOCK INTO DSKADR
GNBLK:	INC DSKADR
	DEC DBCNT
	BLT GNBLK2
GNBLK3:	BNE GNBLK4	;MORE THAN THIS BLOCK LEFT
	CMP DESPNT,DESEPT	;AT END OF DESCRIPTOR?
	BLOS GNBLK4	;NO, HAPPY
	CLR DEOFBL	;READING LAST BLOCK
GNBLK4:	MOV #DBUF,DBUFPT
	RTS PC
GNBLK2:	MOV DESPNT,A	;NO BLOCKS LEFT TO COUNT, LOOK INTO DESCRIPTOR
GNBLK1:	CMP A,DESEPT
	BLOS GNBLK7
	MOV #1,DEOFBL
	RTS PC
GNBLK7:	MOVB (A)+,B
	MOV A,DESPNT	;NEW POINTER
	MOV B,C
	BIC #177477,B	;WHAT KIND OF BYTE?
	BIC #177700,C	;WITH WHAT DATA
	ASH #-5,B
	MOV #DESMOD,F
	JMP @GNBTAB(B)	;SERVICE THAT TYPE

GNBSKP:	TST C	;ZERO IS THE NULL BYTE
	BEQ GNBLK1	;REALLY ONLY FOR THE END OF DESCRIPTOR, BUT...
	ADD C,DSKADR
	MOV #DBGSKP,(F)
	CLR DBCNT
	BR GNBLK3

GNBCNT:	MOV #DBGCNT,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBADR:	MOVB (A)+,DSKADR
	MOVB (A)+,DSKADR+1
	MOV A,DESPNT
	MOV #DBGADR,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBSCN:	MOV C,B
	BIC #177770,B
	BIC #177707,C
	ASH #-3,C
	ADD C,DSKADR
	MOV #DBGSCT,(F)
	MOV B,DBCNT
	BR GNBLK3

DESWST:	MOV #NAME,A
.IF NZ SITSD
	BIT #EOFBIT,DESSAV
	BEQ DESWS1
	CLR FPAGE
	CLR FBYTES
	ADD #10,A
DESWS1:
.ENDC
	TSTB (A)+
	BGE .-2
	CLRB (A)
	MOV A,DESPNT
	MOV #-1,LBLKAD
	MOV #DBGSKP,DESMOD
	RTS PC

DBGET:	MOV WCHDSK,E
	JSR PC,BCHK
	MOV @FDBITP(E),E
	CLR A
DBGET1:	JSR PC,BITGET
	BITB BMT(B),(C)
	BEQ DBGET2
	INC A
	SOB E,DBGET1
	ERROR+DFU
DBGET2:	MOV WCHDSK,F
	DEC NBLKFR(F)
	MOV A,DBGOT
	BISB BMT(B),(C)
DBGOTN:	.IF NZ SITSD
	MOV DESSAV,B
	BIC #TYPMSK,B
	CMP #DIR,B
	BEQ DBGET7
	ADD #2000,FBYTES
	CMP #20000,FBYTES
	BNE DBGET7
	CLR FBYTES
	INC FPAGE
DBGET7:
.ENDC
	MOV A,B
	SUB LBLKAD,B
	MOV A,LBLKAD
	MOV #DESMOD,F
	DEC B
	BEQ DBGET3
	CMP B,#7
	BLE DBGET4
	CMP B,#77
	BLE DBGET5
	MOV DESPNT,B
	MOVB #200,(B)+
	MOVB LBLKAD,(B)+
	MOVB LBLKAD+1,(B)+
	MOV B,DESPNT
	MOV #DBGADR,(F)
	RTS PC
DBGET4:	ASH #3,B
	BIS #300,B
	MOV #DBGSCT,(F)
DBGET6:	MOVB B,@DESPNT
	INC DESPNT
	RTS PC
DBGET5:	MOV #DBGSKP,(F)
	BR DBGET6
DBGET3:	MOV DESPNT,A
	JMP @DESMOD

DBGSK1:	INC A
DBGSKP:	MOVB #100,(A)
	INC DESPNT
	MOV #DBGCNT,(F)
	RTS PC
DBGCNT:	MOVB -(A),B
	BIC #177740,B
	INC B
	BIT #40,B
	BNE DBGSK1
	INCB (A)
	RTS PC
DBGADR:	MOVB -3(A),B
	BIC #177700,B
	INC B
	BIT #100,B
	BNE DBGSKP
	INCB -3(A)
	RTS PC
DBGSCT:	MOVB -(A),B
	BIC #177770,B
	INC B
	BIT #10,B
	BNE DBGSK1
	INCB (A)
	RTS PC
BCHK:	JSR F,ACSAV
	MOV FDBITP(E),C
	MOV NBLKFR(E),A
	MOV (C)+,B
BCHK3:	MOV (C)+,D
	BEQ BCHK1
	CMP #-1,D
	BEQ BCHK2
BCHK6:	MOV #20,E
BCHK5:	ROR D
	BCS .+4
	DEC A
	DEC B
	BEQ BCHK4
	SOB E,BCHK5
	BR BCHK3
BCHK1:	CMP #20,B
	BGE BCHK6
	SUB #20,B
	SUB #20,A
	BR BCHK3
BCHK2:	CMP #20,B
	BGE BCHK6
	SUB #20,B
	BR BCHK3
BCHK4:	TST A
	BEQ .+6
BADBIT:	BPT
	BR .-2
	JSR F,ACRES
	RTS PC

DESINS:	CMP #46,CURDIR	;IS THIS THE ROOT DIRECTORY?
	BNE DESIN5
	BIT #SSF,FLAGS2	;YES, IS STATUS ON?
	BNE DESIN5
	JSR PC,WDELBL
	ERROR+DRF	;DIRECTORY FULL
DESIN5:	MOV #NAME,E
.IFNZ SITSD
	BIT #EOFBIT,DESSAV
	BEQ .+6
	ADD #10,E
.ENDC
	JSR PC,DIRSER
	BEQ DESINX
	JSR PC,WDELBL
	ERROR+EAES
DESINX:	JSR PC,DESINC
	ASL A
.IF Z SITSD
	MOV #DBUF+1776,B
	SUB (B),B
	TST (B)+
	MOV B,C
	ADD A,C
	CMP #DBUF+1770,C
	BGT DESIN4
	JSR PC,.DELBL
	ERROR+DRF
DESIN4:	CLR (C)
DESIN2:	CMP B,ENTBEG
	BEQ DESIN3
	MOV -(B),-(C)
	BR DESIN2
DESIN3:	MOV #DESSAV,C
	SUB A,DBUF+1776
	ASR A
	MOV (C)+,(B)+
	SOB A,.-2
	MOV CURDIR,E
	JMP DBWRTE
.IFF
	MOV #DBUF+6,B
	MOV (B),C
	ADD A,C
	CMP #1770,C
	BGT DESIN4
	JSR PC,.DELBL
	ERROR+DRF
DESIN4:	MOV (B),E
	ADD A,(B)
	ADD #DBUF,E
	ADD #DBUF,C
	CLR (C)
DESIN2:	CMP E,ENTBEG
	BEQ DESIN3
	MOV -(E),-(C)
	BR DESIN2
DESIN3:	MOV #DESSAV,B
	ASR A
	MOV (B)+,(E)+
	SOB A,.-2
	MOV CURDIR,E
	JMP DBWRTE
.IFT
DESINC:	MOV DESPNT,A
	BIT #1,A
	BEQ .+4
	CLRB (A)+
	MOV DESSAV,B
	BIC #177477,B
	CMP #200,B
	BNE DESIN1
	MOV #-1,(A)+
	MOV #-1,(A)+
DESIN1:	SUB #DESSAV,A
	ASR A
	ADD A,DESSAV
	RTS PC
.IFF
DESINC:	MOV DESPNT,A
	SUB #DESSAV,A
	ADD A,DESSAV
	INC A
	ASR A
	MOV #-1,FVERN
	BIT #EOFBIT,DESSAV
	BEQ DESIN1
	MOV #-1,FTIME
	MOV #-1,FDATE
DESIN1:	RTS PC
.ENDC


;ENTER DBREAD AND DBWRTE WITH ADDRESS OF BLOCK TO HACK IN E
DBREAD:	MOV #DREADC,F
	BR .+6
DBWRTE:	MOV #DWRTEC,F
	MOV E,D
	SPUSH A
	SPUSH B
	SPUSH C
	JSR PC,SYDRBG	;GET THE REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-1000,(A)+	;ONE SIZE, ONE PRICE, ONE QUALITY!
	MOV #DBUF,(A)+	;AND ONE PLACE TO PUT IT
	MOV USER,B	;TO FIND THE APPROPRIATE SLOT
	MOV SLOTAS(B),B
	SUB #PURE,-(A)
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	BIS C,6(A)
DBWRT1:	ASL D
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	MOV WCHDSK,C
	ADD FDDSKN(C),D
	MOV D,(A)+
	MOV #-1,(A)+
	TST (A)+
	BISB F,(A)
	JSR PC,DSKWAI
	SPOP C
	SPOP B
	SPOP A
	RTS PC

WBITS:	JSR PC,WBITS1
WCBITS:	MOV #DWRTCC,F
	BR .+6
RBITS:	MOV #DREADC,F
	BR .+6
WBITS1:	MOV #DWRTEC,F
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-NBTTL,(A)+
	MOV WCHDSK,D
	MOV FDBITP(D),(A)+
	SUB #6,P
	MOV DBITAD(D),D
	BIC #60,6(A)
	BR DBWRT1

BITGET:	MOV A,B		;A CONTAINS THE BLOCK NUMBER
	MOV A,C		;B WILL CONTAIN THE BIT NUMBER
	BIC #177770,B	;THERE!
	ASH #-3,C	;AND C GETS THE BYTE NUMBER
	SPUSH B
	MOV WCHDSK,B
	CMP A,FDBITP(B)
	BLO .+4
	BPT
	ADD FDBITP(B),C
	ADD #2,C
	SPOP B
	RTS PC
READPT:	JSR PC,PINIT
	MOV #101,PRS
	MOV #PRGET,GCHR
	SEZ
	RTS PC
PINIT:	TST PGRAB
	BLT .+4
	ERROR+DIU
	MOV USER,PGRAB
	MOV #PBUF,PBFPTI
	MOV #PBUFE-1,PBFPTM
	CLR NPCHRS
	RTS PC
PRGET:	SPUSH U
	MOV USER,U
PRGET2:	TST NPCHRS
	BNE PRGET1
	JSR PC,FLUSH
	BR PRGET2
PRGET1:	JSR PC,RUNME
	SPOP U
	BIC #100,PRS
	DEC NPCHRS
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	MOVB @PBFPTM,D
	CMP #EOFCHR,D
	BNE .+10
	MOV #-1,PGRAB
	BIS #100,PRS
	RTS PC
PRBRK:	SPUSH A
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOV PRB,A
	TST PRS
	BGE PRBRK1
	MOV #EOFCHR,A
PRBRK1:	BIC #200,A
	BEQ PRBRK2
	MOVB A,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	CMP #PBUFE-PBUF,NPCHRS
	BNE .+10
	BIC #100,PRS
PRBRK2:	SPOP A
	INC PRS
	RTT
WRITEP:	JSR PC,PINIT
	JSR PC,FEED
	MOV #PPPUT,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	CLR WRTFLG
	MOV #TYO,PCHR
	MOV #EOFCHR,D
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	SEZ
	RTS PC

FEED:	MOV #100.,A
	CLR D
FEED1:	JSR PC,PPPUT
	DEC A
	BNE FEED1
	RTS PC

PPPUT:	SPUSH U
PPPUT2:	MOV USER,U
	CMP #PBUFE-PBUF,NPCHRS
	BNE PPPUT1
	JSR PC,FLUSH
	BR PPPUT2
PPPUT1:	JSR PC,RUNME
	SPOP U
	TST PPS
	BPL .+4
	ERROR+DNR
	CLR PPS
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOVB D,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	BIS #100,PPS
	RTS PC

PPBRK:	TST NPCHRS
	BEQ PPBRK1
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	DEC NPCHRS
	MOVB @PBFPTM,PPB
	RTT
PPBRK1:	CLR PPS
	RTT
;THE LINE PRINTER/PLOTTER OUTPUT CODE
.IFNZ LPF
LPRINT: BIT #100000,LPCSR  ;ERROR?
	BEQ .+4
	ERROR+DIU
	TST LPFLG  ; IN USE?
	BEQ .+4     ;NO
	ERROR+DIU
	JSR PC,RDBKN
	BIS #LPIUFG,LPFLG  ;LOCK OUT OTHERS
	MOV FLGTH,BKSTGO
	MOV #14,LPCSR+2   ;FORMFEED
	JSR PC,FLPB  ;FILL 1ST BUFFER,ENABLE INTERUPT,GO
        SEZ
	RTS PC


RDBKN:  JSR PC,GETFIL
	CMP #FILE,A
	BEQ .+4
	ERROR+CRE  ;ENTRY ISN'T A FILE
	JSR PC,DESSET
	CLR LSTBKL
	MOV #BKTBL,A
	BR RDBKN4
RDBKN1: SPUSH A
	JSR PC,GNBLK
	SPOP A
RDBKN4:	MOV DSKADR,D   ;CRUNCHES OUT
	ASL D          ;PROPER FORM
	CLR C          ;OF DISK ADDRESS
	DIV #12.,C
        ASH #4,C
	ADD C,D
	MOV WCHDSK,C
	ADD FDDSKN(C),D
	MOV D,(A)+
	TST DEOFBL	;LAST BLOCK
	BEQ RDBKN3		;YES
	CMP A,#BKTBL+<2*MNLPB>  ;AT END OF TABLE?
        BLT RDBKN1       ;NO
        MOV #MNLPB,FLGTH
        MOV #2000,LSTBKL
        RTS PC
RDBKN3:	SUB #BKTBL,A
        ASR A
        MOV A,FLGTH
.IFZ SITSD
        BITB #40,DESSAV+1  ;LAST WORD USED?
        BEQ .+4		;YES
        RTS PC
	MOV #2000,LSTBKL	;HERE EITHER A LAST BYTE OR LAST WORD USED
	BITB #20,DESSAV+1  ;LAST BYTE USED?
	BEQ .+6            ;YES
	DEC LSTBKL
	RTS PC
.IFF
	MOV DESSAV+6,LSTBKL	;THE BYTE COUNT
	BIC #176000,LSTBKL	;THE NUMBER OF BYTES
	RTS PC
.ENDC

FLPB:   TST BKSTGO  ;ANY LEFT?
	BGE .+4     ;YES
	RTS PC
	SPUSH A
	SPUSH B
	JSR PC,SYDRBG
	MOV #LPBDKT,(A)+ ;START ROUTINE
	MOV #-1000,(A)+
	BIT #LPB1FG,LPFLG  ;1ST EMPTY?
	BNE FLPB1          ;NO
	MOV #LPBUF1,(A)+
	MOV #LPB1MX,6(A)
	MOV #LPB1FG,PUTLPB  ;REMEMBER WHICH IS BEING FILLED
	BR FLPB2
FLPB1:  MOV #LPBUF2,(A)+
	MOV #LPB2MX,6(A)
	MOV #LPB2FG,PUTLPB
FLPB2:  MOV FLGTH,B
	SUB BKSTGO,B
	ASL B
	ADD #BKTBL,B    ;ADDRESS OF TABLE ENTRY
	MOV (B),(A)+
	MOV #-1,(A)+
	TST (A)+
	BISB #DREADC,(A)
	SPOP B
	SPOP A
	RTS PC
LPBDKT: MOV #LPADKT,(A)  ;TO RUN AFTER TRANSFER
	RTS PC
LPADKT: BIT #100000,LPCSR  ;ERROR?
	BEQ .+4            ;NO
	RTS PC
	SPUSH A
	SPUSH B
	MOV #2000,B
	CMP #LPB1FG,PUTLPB ;WHICH JUST FILLED?
	BNE LPDKT1
	MOV #LPBUF1,A
	BR LPDKT2
LPDKT1: MOV #LPBUF2,A
LPDKT2: CMPB (A)+,#15  ;CARRIAGE RETURN?
	BNE LPDKT3
	MOVB #12,-1(A) ;YES,REPLACE WITH LINEFEED
LPDKT3: SOB B,LPDKT2
	SPOP B
	SPOP A
	BIS PUTLPB,LPFLG ;TELL WHICH IS FILLED
	DEC BKSTGO
	MOV #100,LPCSR  ;ENABLE INTERRUPT
	RTS PC
LPBRK:  BIT #100000,LPCSR  ;ERROR?
	BEQ LPBRK1  ;NO
	BIC #100,LPCSR
	CLR LPFLG
	JSR PC,DEVER
	RTT
LPBRK1: BIC NOWLPR,LPFLG  ;NOW EMPTIED
	CLR NOWLPR
	BIT #3,LPFLG  ;EITHER BUFFER READY?
	BNE LPBRK2    ;YES
	BIC #100,LPCSR
	TST BKSTGO    ;ANY LEFT?
	BNE LPBRK7
	MOV #4,LPCSR+2 ;SEND AN EOT
	CLR LPFLG  ;ENABLE NEXT JOB
	RTT
LPBRK2: BIT #LPB1FG,LPFLG  ;1ST BUFFER READY?
	BEQ LPBRK3  ;NO
	MOV #1,NOWLPR
	MOV #LPBUF1,LPBUFF ;SAVE ADDRESS
	BR LPBRK4
LPBRK3:	MOV #2,NOWLPR
	MOV #LPBUF2,LPBUFF
LPBRK4: MOV LPBUFF,LPDBAR  ;STARTING ADDRESS FOR DMA
	TST BKSTGO
	BNE LPBRK6
.IFZ SITSD
	TST LSTBKL  ;2000 OR 1777 BYTES USED?
	BNE LPBRK5  ;YES
	ADD #1776,LPBUFF  ;LAST WORD
	MOV #2000,LSTBKL
	SUB @LPBUFF,LSTBKL  ;BYTE COUNT
.ENDC
LPBRK5: MOV LSTBKL,LPDBAR-2  ;STARTS DMA
	RTT
LPBRK6: MOV #2000,LPDBAR-2  ;STARTS DMA
LPBRK7: JSR PC,FLPB   ;FILL OTHER BUFFER
	RTT
.ENDC
	.STITL SCHEDULER


RUNME:	TST USER
	BGE RUNME1
RUNME2:	RTS PC	;SYSTEM CALLED RUNME

RUNME1:	TST FLSADR(U)	;IF HE WANTS TO RUN HE SHOULD JSR HERE
	BEQ RUNME2	;IF FLSADR IS ZERO, JUST KEEP RUNNING HIM
	MOV #-1,USER	;SYSTEM IS NOW USER
	JSR PC,UACSAV	;STORE HIS ACS
	CLR FLSADR(U)	;GUY IS NOW RUNABLE
	CLR FLSRES(U)
	INC NRABLU
	SPOP UPC(U)	;HE SHOULD START AFTER THE JSR PC,RUNME
NEXTU1:	CMP #SYSIDX,U	;IS IT THE SYSTEM JOB?
	BNE NEXTU2
	MOV P,SPDLP	;SET UP SYS JOB PDL
	MOV SJPDLP,P
	JMP RUNUS7

NEXTU2:	MOV SLOTAS(U),A	;IS HE ASSIGNED A SLOT?
	BLT NEXTU3	;NO, SEE IF WE CAN GET ONE
	TST SLOTST(A)	;YES, WHAT IS IT'S STATUS?
	BEQ NEXTUS	;GUY BEING SWAPPED IN
;WE GET HERE IF THE GUY IS IN CORE
	CMP #FRNEWU,FLSRES(U)	;RELOAD USER
	BNE NEXT14	;IN CORE AND NOT BEING GUNNED, RUN HIM
	CLR TIMUSD(U)
	MOV #UGO,FLSADR(U)	;RESTART HIM
NEXT16:	MOV A,SLOTAS(U)
	MOV U,SLOTU(A)
	MOV SLOTRB(A),C	;CORE ADDRESS OF ASSIGNED SLOT
	MOV #16,D
	JMP NEXT11	;GO DO A SPECIAL SWAPIN

NEXT14:	CLR FLSRES(U)
	JMP RUNUSR



;CALL TO GET INDEX OF NEXT USER TO RUN

NEXTUS:	MOV TTYUGO,U	;DID SOMEONE JUST TYPE CR?
	BGE NEXT15
	SUB #LUBLK,ULAST	;COUNT BACKWARDS
	BGE .+10	;DON'T GO NEG
	MOV #MNUSRS*LUBLK,ULAST	;LAST POSSIBLE USER INDEX
	MOV ULAST,U	;SEE IF THIS IS A GOOD GUY TO RUN
NEXT15:	MOV #-1,TTYUGO
	TST FLSADR(U)	;IF FLSADR IS ZERO, RUNABLE(???)
	BEQ NEXTU1	;RUN HIM.
	CMP #-1,FLSADR(U)	;-1 => NON EX USER
	BEQ NEXTUS
	SPUSH B
	MOV GUNU,B
	BLT NEX21B
	MUL #LUBLK,B
	CMP U,B
	BNE NEX21B
	SPOP B
	MOV #-1,GUNU
	MOV U,USER	;USER IS NOW USER
	MOV PC,BRAKE(U)
	JMP GOODBY

NEX21B:	SPOP B
NEXT21:	TSTB	FLSRES(U)
	BMI	NEXTUS
	MOV U,USER	;USER IS NOW USER
	JSR PC,UACRES	;RESTORE HIS ACS
	JMP @FLSADR(U)	;SEE IF HE SHOULD REALLY RUN



NEXTU3:	MOV PUSPSL,A	;SEE IF THERE IS A PREFERED SLOT
	BGE NEXTU6
NEXT20:	CLR A
	MOV NSLOTS,C
NEXTU4:	TST SLOTST(A)
	BLT NEXT16	;AN UNUSED SLOT!
	CMP #1,SLOTST(A)
	BGE NEXTU5	;GUY HASN'T RUN YET, DON'T SWAP HIM OUT
	TST NSWPU	;ARE THERE USERS BEING SWAPED?
	BEQ NEXTU6	;NO, SWAP ONE
	CMP NINU,#1	;IS THERE ONLY ONE USER IN CORE?
	BEQ NEXTUS	;YES, RUN HIM
NEXTU6:	MOV SLOTU(A),B	;USER THAT MAY BE SWAPED OUT
	BLT NEXT20
	CMP #FRTYIW,FLSRES(B)
	BEQ NEXT17
	MOV #LOCKUS,D
	MOV #NLOCKS,E
NEXT18:	CMP B,(D)+
	BNE NEXT19	;LOCKED IN CORE, DO NOT DISTURB
NEXT17:	TST PUSPSL
	BLT NEXTU5
	MOV #-1,PUSPSL
	BR NEXT20
NEXTU5:	TST (A)+
	SOB C,NEXTU4
	BR NEXTUS

NEXT19:	SOB E,NEXT18
	MOV #-1, PUSPSL	;IF THERE WAS A PREFERED SLOT, WE ARE DOING IT
	MOV SLOTU(A),B	;FOUND A GOOD SLOT, USER TO SWAP OUT INTO B
	MOV U,SLOTU(A)	;NEW OCCUPANT OF SLOT
	MOV #-1,SLOTAS(B)
	MOV A,SLOTAS(U)

;FALLS THROUGH

;FALLS IN

	CLR D
	MOV SLOTRB(A),C	;MOBY SWAP OUT BLOCK FOR THIS SLOT
	MOV #SWPOST,(C)+	;SWAP OUT USER START ROUTINE
	MOV USWCNT,(C)+	;WORD COUNT OF A USER SLOT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	MOV USWPAD(B),(C)+	;LOW ORDER SWAP OUT ADDR OF U TO SWAP OUT
	MOV USWPAD+2(B),(C)+	;HIGH OORDER
	MOV B,(C)+	;SAVE USER GOING OUT FOR BRUCE
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	BIS #DWRTEC,(C)+	;DISK WRITE COMMAND
	DEC NINU	;ONE LESS IN CORE
NEXT11:	CLR SLOTST(A)	;NOT IN YET: -1 TO SLOTST+2 OF GUY
	INC NSWPU	;ONE MORE MOVING AROUND
	MOV #SWPIST,(C)+	;SWAP IN USER START ROUTINE
	MOV USWCNT,(C)+	;SLOT WORD COUT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	CMP #FRNEWU,FLSRES(U)
	BNE NEXT12
	MOV DCLRUS,(C)+	;DISK ADDRESS OF CLEAR USER
	MOV DCLRUS+2,(C)
	BIS #100000,(C)+
	CLR FLSRES(U)
	MOV #UGO,FLSADR(U)
	BR NEXT13

NEXT12:	MOV USWPAD(U),(C)+	;  "    "   
	MOV USWPAD+2(U),(C)+	;USER ADDRESS ON DISK
NEXT13:	MOV A,(C)+	;ADDRESS OF PLACE TO ZAP TO 1 WHEN DONE
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	BIS #DREADC,(C)	;READ FROM DISK
	SUB #32,C	;BEGINING OF MOOBY SWAP REQ PAIR
	ADD D,C		;INDEX TO RIGHT ONE OF PAIR
	SPUSH PS
	MOV #340,PS	;NO INTS!
	MOV C,@SWPLEP
	ADD #2,SWPLEP	;GRONK ONTO REQ LIST
	SPOP PS
	JSR PC,DPROVK
	BR NEXT10

NEXTU7:	CMP #1,NUSERS
	BNE .+4
	WAIT
	MOV #-1,USER	;FLUSH ENTERS HERE, SYSTEM NOW USER
	BLT NEXT10
	MOV SLOTAS(U),A
	TST (A)	;IS HE REALLY IN?
	BLE NEXT10	;NO, NOT REALLY
	CMP #FRDSKW,FLSRES(U)	;IF JUST HUNG ON DISK
	BEQ NEXT10	;FORGET HIM
	MOV A,PUSPSL	;HE IS PREFERED OUT
	MOV U,PUSRSP
	BR NEXT10

NEXT10:	JMP NEXTUS
FLUSH:	TST USER
	BGE FLUSH4
	RTS PC

FLUSH4:	CLR 177570	;CLEAR DISPLAY REGISTER
	CLR DISPDR
	JSR PC,UACSAV	;STOP USER; STORE HIS ACS
	MOV FLSADR(U),A
	SPOP FLSADR(U)	;SAVE PC
	TST A	;IS THIS GUY ALREADY STOPED?
	BNE NEXTU7	;GO TRY ANOTHER GUY
	MOV #-1,USER
	MOV UTIME,A
	ADD A,JMTU(U)
	ASH #-5,A
	ADD A,TIMUSD(U)
	ADD A,TUTIME
	ADC TUTIME+2
	MOV #4,A
	MOV #LSTIM,B
	ADD U,B
	MOV #RSEC,C
FLUSH3:	MOVB (C)+,(B)+
	SOB A,FLUSH3
	TST FLSRES(U)
	BNE .+10
	MOV #FRRAND,FLSRES(U)
	DEC NRABLU
	CMP #SYSIDX,U
	BEQ FLUSH7
	CLR 177774
	MOV P,UPDLP	;SAVE USER'S POINTER
	MOV SPDLP,P	;SYSTEM PDL
FLUSH5:	JMP NEXTUS

FLUSH7:	MOV P,SJPDLP
	MOV SPDLP,P
	JMP NEXTUS
;RUNUSR, THE "MAIN LOOP"

RUNUSR:	CMP U,PUSRSP	;AM I THE GUY THEY WANT OUT?
	BNE .+10	;BRANCH IF NO
	MOV #-1,PUSPSL
	INC SLOTST(A)	;INDICATE THAT THIS GUY HAS BEEN RUN
	BVC .+10
	MOV #2,SLOTST(A)
	MOV SLOTAR(A),B
	MOV #PUREAR,C
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)
	CLR DISPDR
	MOV DISAS(U),A
	BLT RUNUS8
	MOV DISAR(A),DISPAR
	MOV DISDR(A),DISPDR
RUNUS8:	MOV #PURE,BASEUS
	MOV P,SPDLP	;SAVE SYSTEM PDL POINTER
	MOV UPDLP,P	;GET USER PDL POINTER
RUNUS7:	MOV U,USER	;NOW HE'S REALLY THE GUY
	SPUSH UPC(U)	;PLACE TO START USER
	MOV QUANT,UQUANT	;RUN FOR 3 1/100TH'S????
	CLR UTIME
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	CLR A		;DISPLAY USER # IN DISPLAY REG
	MOV USER,B
	DIV #L,A	;(71027 000056)
	MOV #1,B
	ASH A,B		;(72100)
	MOV B,177570
	JMP UACRES	;RESTORE USER ACS AND START USER


SCHEDP:	TST UQUANT	;SEE IF IT'S TIME TO FLUSH
	BLE .+4	;NOT YET
	RTS PC
	SPUSH U
	MOV USER,U
	MOV #FRSCED,FLSRES(U)
	JSR PC,FLUSH
	JSR PC,RUNME
	SPOP U
	RTS PC
.STITL CLOCK BREAK ROUTINE

CLKBRK:	SPUSH A
	SPUSH B
	SPUSH	C
	ADD #40,UTIME
	INC TIME+2
	BNE CLKTOV
	INC TIME
CLKTOV:	DEC UQUANT
	DEC N50THS	;HAS THIS BEEN ONE SECOND?
	BLE DATEC	;YES, CHANGE THE SECOND
	;NEXT FIVE LINES ARE FOR TESTING DISPLAY
CLKBR1:
	.IFZ NDISP
	BR CLKB11
	.ENDC
	.IFNZ NDISP
	DECB	DISTIM	;TIME (HO HUM) TO START THE DISPLAYS?
	BGT	CLKB11	;NO
	MOVB	#1,DISTIM
	MOV	#NDISP-1,C
	ASL	C	;TO USE AS INDEX
	CLR	B
CLKDIS:	CMP	B,C	;ALL DISPLAYS CHECKED?
	BGT	CLKB11
	MOV	DSTAT(B),A
	TST	(B)+
	TST	A
	BLT	CLKDIS	;THIS ONE INACTIVE
	MOV	A,NGCSR
	BIT	#TKRUN,NGCSR
	BNE	CLKDIS	;STILL RUNNING
	BIS #TKGO,A
	MOV A,NGCSR
	BR	CLKDIS
	.ENDC

DATEC:	JSR PC,DPROVK
	DEC DKPWFR
	BGT .+10
	MOV #-20.,DKNRTY
	MOV #CLKFRQ,N50THS
	MOV #MNUSRS,A
	CLR B
	SPUSH C
JMTUD2:	MOV JMTU(B),C
	BEQ JMTUD1
	ASR C
	ASR C
	ASR C
	INC C
	SUB C,JMTU(B)
	BGE .+6
	CLR JMTU(B)
JMTUD1:	ADD #LUBLK,B
	DEC A
	BNE JMTUD2
	SPOP C
	MOVB RMONTH,A
	MOVB DMON(A),DAYLIM
	MOV #SECLIM,A
	MOV #RSEC,B
DATEC1:	INCB (B)
	CMPB (A)+,(B)
	BGT CLKBR1
	CLRB (B)+
	BR DATEC1

CLKB11:
.IFNZ NTVS
	JSR PC,TVTICK
.ENDC
CLKBDM:	BIT	#1,TIME+2	;EVERY OTHER BREAK (=1/25 SEC)
	BNE	CLKQBK	;
	JSR U,ACSAV
	CLR E
	MOV #NLTY,B
TIBLP:	BIT #TILIPM,TTYST(E)
	BEQ TIBLPB
	TST TIBN(E)
	BEQ TIBLPB
	JSR PC,TICP
TIBLPB:	INC E
	INC E
	SOB B,TIBLP
	JSR U,ACRES

CLKQBK:	DEC	@CLKQT
CLKQB1:	TST	@CLKQT
	BNE	CLKQB2
	MOV	CLKQT,A
	MOV	2(A),CLKQT	;PUT NXT BLK AT TOP OF Q
	JSR	PC,@4(A)		;DO CURRENT REQUEST
	BR	CLKQB1
CLKQB2:	MOV	#-1,CLKINF
	SPOP	C
	SPOP B
	SPOP A
	RTT

CLKINE:	TST DEBSW
	BNE CLKIN2
	JSR	A,SPRINT
	BPRTXT	^/CLKQBK RAN CLKINE/
	PRCR
	SPREND
CLKIN1:	MOV #CLKINF,CLKQT
	MOV	#-1,CLKINF
	RTS	PC

CLKIN2:	BPT	;CLKQBK RAN OFF END OF CLK QUEUE
	BR CLKIN1
.STITL	CLOCK QUEUE ROUTINES

;CLKQAD --
;CLOCK QUEUE ADD
;WORKS ONLY AT CLK BRK LEVEL OR LOWER 
;ADD BLOCK POINTED TO BY A TO SYSTEM CLOCK QUEUE
;1ST WD # OF TICKS TO WAIT
;2ND WD EMPTY (USED BY SYSTEM)
;3RD WD ADDR TO JSR TO

CLKQAD:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST CLKQ ENTRY
	MOV	(C),D
	BR	CLKQA2

CLKQA1:	MOV	D,C	;PNT C TO NEXT BLK
	MOV	2(D),D	;PNT D TO ONE AFTER
	SUB	(C)+,(A)	;MAKE TIME IN A BLK REL TO C BLK
CLKQA2:	TST	2(D)
	BEQ	CLKQA3	;BR IF NO MORE BLKS LEFT 
	CMP	(A),(D)
	BHI	CLKQA1
CLKQA3:			;INSRT ABLK BETWEEN C BLK AND D BLK
	MOV	D,2(A)	;PNT A BLK TO D BLK
	MOV	A,(C)	;PNT C BLK TO A BLK
	SUB	(A),(D)	;MAKE D TIME REL TO A TIME

CLKQRS:	SPOP	D
	SPOP	PS
	SPOP	C
	RTS	PC

CLKQSV:	SPUSH	PS
	MOV	PCBRV+2,PS	;RUN AT CLK BK LEVEL
	SPUSH	D
	JMP	(C)

;CLKQDL--
;CLOCK QUEUE DELETE
;DELETE BLOCK POINTED TO BY A FROM CLOCK Q

CLKQDL:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST ENTRY
	BR	CLKQD2
CLKQD1:	MOV	(C),C	;GET NEXT ENTRY
	TST	(C)+	;MAKE IT POINT TO NEXT+1 ENTRY
	TST	(C)	
	BEQ	CLKQD3	;BRANCH IF NO MORE ENTRIES
CLKQD2:	CMP	A,(C)	;IS THIS THE ENTRY WE WANT
	BNE	CLKQD1	;NO
	ADD	(A),@2(A)	;INCREASE TIME IN NEXT BLK
	MOV	2(A),(C)	;CORRECT PNTR IN PREV BLOCK
CLKQD3:	JMP	CLKQRS


UTIMEG:	MOV #RHOUR+1,D
	CLR E
	BR UTIME1
UDATEG:	MOV #RYEAR+1,D
	MOV #1,E
UTIME1:	MOV #3,F
UTIME2:	MOVB -(D),B
	ADD E,B
	JSR PC,PSHNUM
	SOB F,UTIME2
	MOV #3,D
	JMP SENT.

PEEK:	CLR -(P)
	CLR E
	PRTXTC ^\USER	%TIM	FLSRES	TIMUSD	LSTIM\
	MOV NUSERS,F
PEEK1:	MOV (P),A
	JSR PC,PRDN
	SPACE
	MOV E,A
	ADD #UNAME,A
	JSR PC,POIHD2
	PRTXT ^\	\
	CLR A
	MOV JMTU(E),B
	DIV #144.,A
	JSR PC,PRDN
	PRTXT ^\	\
	MOV FLSRES(E),A
	JSR PC,PRON
	PRTXT ^\	\

	MOV TIMUSD(E),A
	JSR PC,PRDN
	PRTXT ^\	\
	MOV #LSTIM+3,B
	ADD E,B
	MOVB @B,A
	INC A
	JSR PC,PRDN
	SPACE
	MOV #3,C
	MOV #':,D
	BR .+6
PEEK4:	JSR PC,TYO	;PRINT :
	MOVB -(B),A
	JSR PC,PRDN
	SOB C,PEEK4
	PRCR
	ADD #LUBLK,E
	INC (P)
	DEC F
	BLE .+6
	JMP PEEK1
	MOV NRFERS,A
	BEQ PEEK2
	JSR PC,PRDN
	PRTXT ^\  FIXED HEAD ERRS  \
PEEK2:	MOV NRKERS,A
	BEQ PEEK3
	JSR PC,PRDN
	PRTXT ^\  MOVING HEAD ERRS\
PEEK3:	PRCR
	TST (P)+

;PEEK THORNTON BOX TYPE DEVICES
PEEKDV:
	MOV	#LDEVAR,A
PEEKD1:	CMP	(A)+,(A)+	;POINT TO NEXT NAME POINTER
	TST	(A)	;0 MARKS END OF LDEVAR NAMES
	BNE	PEEKD2
PEEKRT:	SEZ
	RTS	PC
PEEKD2:	MOV	2(A),B	;TELETYPE NUMBER OF DEVICE
	BIT	#100001,B	;NOT REALLY THERE IF NEG OR ODD
	BNE	PEEKD1	;BR IF NOT REALLY THERE
	JSR	PC,PKDEV	;DO THIS DEVICE
	BR	PEEKD1

;DO PEEK FOR ONE DEVICE.
PKDEV:	SPUSH	A
	MOV	(A),A	;NOW A POINTS TO ACTUAL NAME
	JSR	PC,PRAS	;PRINT STRING IN A
	PRTXT	^\: \
	MOV	TTYU(B),B	;USER WHO HAS DEVICE OPEN
	BGE	PKDEV1
	PRTXT	^\UNUSED\
	BR	PKDEV8
PKDEV1:	SPUSH	B	;SAVE USER
	CLR	A
	DIV	#L,A	;A _ USER NUMBER
	JSR	PC,PRDN
	SPACE
	SPOP	A	;USER
	ADD	#UNAME,A
	JSR	PC,POIHD2	;SOMEHOW THIS IS SUPPOSED TO PRINT USER NAME
PKDEV8:	PRCR
	SPOP	A
	RTS	PC

CLOCK:	MOV TIME,A
	MOV TIME+2,B
.IFZ FPPF
CLOCK1:	JMP R1I.N
.IFF
CLOCK1:	JSR PC,GRBAD
	BIS #INUM,C
	JMP ORTC

.ENDC
USRTIM:	MOV TUTIME+2,A
	MOV TUTIME,B
	BR CLOCK1

UWAIT:	JSR PC,G1IARG
	MOV	USER,U
UWAIT0:	SDPADD	TIME,TIME+2,B,C
	JSR	PC,UWAITS
	BEQ	SETRT	;BR IF WAIT DONE
UWAIT1:	JSR PC,FLUSH
UWAIT3:	TST BRAKE(U)
	BNE UWAIT2
	JSR	PC,UWAITS
	BNE	UWAIT1
UWAIT2:	JSR PC,RUNME
	BR SETRT	;SEZ RETURN

UWAITS:
	CMP	TIME,B
	BNE	UWATS1
	CMP	TIME+2,C
UWATS1:	BGE	SETRT	;BR IF TIME IS OVER AND SEZ RETURN
	CLZ	;HAVE TO WAIT SOME MORE
	RTS	PC


SETTV:	JSR PC,G1IARG
	SPUSH C
	BLT SETTV1
	JSR PC,G1IARG
	TST C
	BLT SETTV1
	CMP #6,C
	BLE SETTV1
	CMP #2,C
	BGE .+4
	DEC (P)
	CMPB (P),SECLIM(C)
	BGT SETTV1
	MOVB (P),RSEC(C)
	TST (P)+
SETRT:	SEZ
	RTS	PC
SETTV1:	ERROR+WTA	;WRONG TYPE OF ARGUMENT


;WAITS UNTIL SPECIFIED DEVICE HAS NO CHARACTERS IN OUTPUT Q
TYOWAIT:
	JSR	PC,G1IARG	;B,C _ AM'T OF ADDITIONAL WAIT
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER OR ERROR IF INVALID NAME
	CMP	E,#2*NLTY
	BLT	TWAIT1
	ERROR+TDE	;NOT VALID TTY NUMBER
;WAIT UNTIL USER'S CONSOLE HAS FINISHED OUTPUT
CTYOWAIT:
	MOV	USER,U
	MOV	UTTY(U),E
	BR	TWAIT0
;WAIT UNTIL MUSIC BOX HAS FINISHED OUTPUTTING
MUWAIT:
	MOV	#MBDN,E

TWAIT0:	JSR	PC,G1IARG	;B,C _ AM'T OF ADDITIONAL WAIT
TWAIT1:	MOV	USER,U
	JSR	PC,TWAITS
	BEQ	UWAIT0	;BR IF DEVICE DONE
;OTHERWISE, HAVE TO WAIT
TWAIT2:	JSR	PC,FLUSH	;BYE BYE
	TST	BRAKE(U)
	BNE	UWAIT2	;BREAKING, SO GO RUN HIM
	JSR	PC,TWAITS	;IS TTY DONE?
	BNE	TWAIT2	;BR IF DEVICE NOT DONE
;DEVICE DON. NOW WAIT ARG 60THS OF SECONDS
	SDPADD	TIME,TIME+2,B,C
	BR	UWAIT3

;CALL WITH E = TTY NUMBER
;SEZ RETURN IF TTY DONE
TWAITS:
	TST	TOQN(E)
	BNE	TWATS8	;BR IF OUTPUT Q NOT EMPTY
	TSTB	MXNUM(E)	;NOTHING IN BUFFER, BUT ANY IN HARDWARE BUFFER?
	BGE	SETRT	;BR IF DONE
	BIT	#TOTRAN,TTYST(E)	;IS TTY TRANSMITTING
	BNE	SETRT	;BR IF DONE
TWATS8:	CLZ	;NOT DONE
	RTS	PC
	.STITL	SWAP START+STOP ROUTINES

SWPOST:	CLR (A)
	ADD #16,SWPLST
.IFNZ AI
	TST XORF
	BNE SWPST1
	MOV 12(A),B
	CLR XORUSR(B)
	RTS PC
SWPST1:	JSR F,ACSAV	;SAVE THE AC'S
	MOV 2(A),D	;THE WORD COUNT
	MOV 4(A),F	;THE CORE ADDRESS
	MOV 14(A),E	;THE CONTROL REGISTER
	JSR PC,XORREG	;XOR THE TRANSFER
 	MOV (P),B	;THE OLD POINTER TO THE REQUEST BLOCK
	MOV 12(B),B	;THE USER INDEX
	MOV A,XORUSR(B)	;PUT THE CHECKSUM IN HIS VARIABLES
	JSR F,ACRES	;RESTORE THE REGS
.ENDC
	RTS PC

SWPIST:	MOV #SWPISP,(A)	;SWAP IN START, SET UP STOP
	RTS PC

SWPISP:	MOV 12(A),B
	MOV #1,SLOTST(B)
	SUB #2,SWPLEP
	SPUSH A
	MOV #SWPLST+2,A
	MOV #SWPLST,B
	MOV (A)+,(B)+
	BNE .-2
	INC NINU	;ONE MORE GUY IN
	DEC NSWPU	;ONE LESS GUY MOVING
	SPOP A
.IFNZ AI
	MOV 12(A),B
	MOV SLOTU(B),B
	TST XORF
	BEQ SWPIS2
	TST XORUSR(B)
	BNE .+4
SWPIS2:	RTS PC
	JSR F,ACSAV
	MOV 2(A),D	;THE WORD COUNT
	MOV 4(A),F	;THE CORE ADDRESS
	MOV 14(A),E	;THE CONTROL REGISTER
	JSR PC,XORREG	;XOR THE TRANSFER
 	MOV (P),B	;THE OLD POINTER TO THE REQUEST BLOCK
	BIT #100000,10(B)
	BNE SWPIS1
	MOV 12(B),B	;THE SLOT NUMBER
	MOV SLOTU(B),B	;THE UUSER INDEX
	CMP A,XORUSR(B)	;COMPARE THE CHECKSUMS
	BEQ .+4
	BPT		;THEY WERE DIFFERENT
SWPIS1:	JSR F,ACRES
.IFTF
	RTS PC

.IFT
XORREG:	NEG D		;MAKE THE WORD COUNT POSITIVE
	CLR A		;CHECKSUM COMPUTED IN A
	SPUSH TEMPAR	;GET A PAGE
	SPUSH TEMPDR
	MOV #77406,TEMPDR	;MAKE IT 4096. WORDS LONG
	ASH #-4,E	;GET THE EXTENDED MEMORY BITS
	ASHC #-6,E	;TURN THE CORE ADDRESS INTO 32. WORD BLOCKS
	BIC #170000,F	;CLEAR THE EXTRA BITS
	MOV F,TEMPAR	;SET UP THE BOTTOM OF THE PAGE
XOR1:	MOV #4096.,F	;THERE ARE 4096 WORDS IN A PAGE
	CMP D,F		;ARE THERE AT LEAST THAT MANY IN THE TRANSFER
	BHIS .+4	;YES
	MOV D,F		;CORRECT THE NUMBER OF WORDS
	MOV #TEMPPG,B	;THE START OF THE PAGE IN THE VIRTUAL CORE
XOR2:	MOV (B)+,C	;THE ACTUAL WORDS OF THE TRANSFER
	XOR C,A		;CREATE THE CHECKSUM
	SOB F,XOR2	;DO ALL THE WORDS
	ADD #128.,TEMPAR	;GET THE NEXT 4K. WORDS
	SUB #4096.,D	;CORRECT THE WORD COUNT
	BGT XOR1	;MORE WORDS LEFT
	SPOP TEMPDR
	SPOP TEMPAR
	RTS PC
.ENDC
	.STITL MISC ROUTINES

CACSAV:	JSR PC,PPUSHT	;CAREFUL AC SAVE
ACSAV:	MOV E,-(P)
	MOV D,-(P)
	MOV C,-(P)
	MOV B,-(P)
	MOV A,-(P)
	JMP (F)

CACRES:	JSR PC,PPOPT	;CAREFUL AC RESTORE
ACRES:	TST (P)+
	MOV (P)+,A
	MOV (P)+,B
	MOV (P)+,C
	MOV (P)+,D
	MOV (P)+,E
	RTS F

UACSAV:	MOV A,UACA(U)
	MOV B,UACB(U)
	MOV C,UACC(U)
	MOV D,UACD(U)
	MOV E,UACE(U)
	RTS PC

UACRES:	MOV UACA(U),A
	MOV UACB(U),B
	MOV UACC(U),C
	MOV UACD(U),D
	MOV UACE(U),E
	RTS PC



PPUSHT:	CMP P,#PPUSHL
	BLOS .+4
	RTS PC
	BIT #177000,P	;IS IT THE SYSYTEM PDL?
	BNE .+4
	RTS PC	;YES, IGNORE
	JMP PPSWPO	;PDL REALLY OVERFLOWED

PPOPT:	CMP P,PPOPL
	BHIS .+4
	RTS PC
	JMP PPSWPI

SPUSHT:	SUB #2,S
	CMP S,#SPUSHL
	BLOS .+4
	RTS PC
	JMP SPSWPO

SPOPT:	ADD #2,S
SPOPT1:	CMP S,SPOPL
	BHI .+4
	RTS PC
	JMP SPSWPI

.SPACE:	PRTXT ^\ \
	RTS PC

.CRLF:	.PRTXT <.BYTE 15,0>
	RTS	PC
	.STITL P AND S PDL SWAP OUTERS

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	SPUSH B	;SAVE ADDRESS
	SPUSH #PSWPWR
	JSR PC,DSKSEC	;WRITE OUT P-PDL BLOCK
			;FROM (PSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IP
	BIT #PPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IP,A
	MOV PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PDSWOP,P	;PDL HAS MOVED!
	ADD #PDSWOP,PRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC


SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	SPUSH B	;SAVE ADDRESS
	SPUSH #SSWPWR
	JSR PC,DSKSEC	;WRITE OUT S-PDL BLOCK
			;FROM (SSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IS
	BIT #SPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,SPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IS,A
	MOV SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #PDSWOP,S	;PDL HAS MOVED!
	ADD #PDSWOP,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

	.STITL P AND S PDL SWAPER INERS
PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV PSWPAD,A
	MOV A,B
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PDSWOP,P
	SUB #PDSWOP,PRBAO
	MOV IP,C
	MOV C,DBGRBD
	SPUSH #PSWPRD
	JSR PC,DSKSEC	;READ IN P-PDL BLOCK
			;INTO (PSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IP,D
	TST (D)
	BNE PSWPI2
	BIC #PPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,PPOPL
PSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV SSWPAD,A
	MOV A,B
	MOV (A),(B)
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #PDSWOP,S
	SUB #PDSWOP,SPRBAO
	MOV IS,C
	MOV C,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;READ IN S-PDL BLOCK
			;INTO (SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IS,D
	TST (D)
	BNE SSWPI2
	BIC #SPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,SPOPL
SSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC


	.STITL P AND S PDL POPPERS
PPTA:		;POP PP PDL TO (A) RELATIVE
		;USES A,F
	SPOP F
PPTA1:	CMP A,PRBAO
	BHIS PPTA3
	MOV PPOPL,P
	JSR PC,PPSWPI
	BR PPTA1
PPTA3:	SUB PRBAO,A
	SUB #IP,A
	NEG A
	CMP A,P
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,P
	JSR PC,PPOPT
	JMP @F
PSTA:		;POP S PDL TO (A) RELATIVE
		;USES A
	CMP A,SPRBAO
	BHIS PSTA3
	MOV SPOPL,S
	JSR PC,SPSWPI
	BR PSTA
PSTA3:	SUB SPRBAO,A
	SUB #IS,A
	NEG A
	CMP A,S
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,S
	JMP SPOPT1
.STITL INITIALIZE NODE SPACE
;ON ENTRY B = START OF FREE NODES NODE #
;	C = " " " " NODE ADDRESS
;	D = FIRST WORD AFTER END OF SLOT
INIT:	MOV #PSTP15,ERFRET
	MOV #RET,DOFRET
	MOV USER,B
	MOV UASIZE(B),C	;SAVE USERS ASIZE
	MOV ASIZE,UASIZE(B)
	MOV ENDWLD,D
	MOV D,B
	SUB C,D	;COMPUTE TOP OF NODESP
	SUB #10,D
	MOV D,NODTOP
	MOV D,A
	ADD #4,A
	SUB A,B
	CMP #20,B
	BGE INIT3
	MOV A,AFREE
	MOV A,AROVER
	CLR (A)+
	MOV B,(A)+
	CLR (A)
	MOV B,ASPACE
INIT3:	JSR PC,.GCOLL
	MOV NDBLKS,A
	MOV A,B
	ASH #-4,B
	MOV #DBITTB,C	;SET UP TO INIT DISK BIT TABLE
DALOC5:	DEC B	;20 BLOCKS (=1 WORD IN TABLE)AT A TIME
	BLT DALOC4	;ALL DONE 
	CLR (C)+
	BR DALOC5
DALOC4:	CLR (C)	;ONLY SOME BITS ON IN THIS WORD
	COM (C)
	MOV #1,D
	BIC #177760,A	;# OF WORDS MOD 20
DALOC6:	DEC A
	BLT DALOC7
	BIC D,(C)
	ASL D
	BR DALOC6
DALOC7:	TST (C)+
	CMP C,#DBITBE
	BGT DALOC8
	MOV #-1,(C)
	BR DALOC7
DALOC8:	BIS #100000,DBITBE	;IMPOSSIBLE TO GO OFF TOP
	RTS PC

INIT1:	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
STARTF:	MOV	NUSERS,NUSER2
	ASL	NUSER2
	JSR PC,SEGSET
	JMP	TINIT

SEGSET:	CLR SSR0
	MOV #KIDR,A
	MOV #20,B
	MOV #77406,(A)+
	SOB B,.-4
	MOV #10,C
SEGST1:	MOV B,20(A)
	MOV B,(A)+
	ADD #200,B
	SOB C,SEGST1
	MOV #SLOTDR,A
	MOV #PUREDR,B
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A),(B)
	MOV #7600,KDAR+16
	MOV #4,SSR3
	MOV #1,SSR0


.IFNZ FPPF
	LDFPS #40300
.ENDC

	RTS PC
	.STITL READ-EVAL LOOP DRIVER (THE ONE-USER MAIN LOOP)

UGO:	JSR PC,RUNME
	MOV #TYO,PCHR
	MOV #TYI,GCHR
	MOV USER,A
	BNE UGO2
	JSR PC,IDISKS
.IIF NZ GUY,CLR WCHDSK
.IIF Z GUY,MOV #4,WCHDSK
	MOV USER,A
UGO2:	CLR GUNSW(A)		;NOT BEING GUNNED NOW!
	ADD #UNAME,A
	MOV #'?+200,(A)
	TST DEBSW
	BNE UGO1
LANGC <	CPRTXT ^/WELCOME TO LOGO />,<
	CPRTXT ^/BIENVENUE A LOGO />
	BR UGO3
UGO1:	PRTXT ^/LOGO BEING DEBUGGED!/
UGO3:	PRTXT ^/VERSION # /
	MOV LVERNF,A
	JSR PC,PRDN
	LANGC <PRTXT ^/, YOU ARE USER # />,<
	PRTXT ^/, VOUS ETES L'UTILISATEUR # />
	CLR A
	MOV USER,B
	DIV #LUBLK,A
	JSR PC,PRDN
	PRCR		;PRINT CR
	JSR PC,INIT
	MOV #DESSAV,E
	JSR PC,DIRSER
	BEQ MLOOP
	TST DEBSW
	BNE MLOOP
	JSR PC,.REDF4
	JSR PC,.POF1
MLOOP:	JSR	PC,UCHECK	;CHECK SOME USER VARIABLES
	JSR PC,SCHEDP
	BIC #HERRF,FLAGS2
	MOV	USER,U
	TST BRAKE(U)
	BEQ .+4
	ERROR+BRK
	JSR PC,GETSTR
	JSR PC,MREAD
	BEQ MLOOP	;NO TOKEN LIST
.IFNZ AI
	TST USER
	BNE MLOP1
	CMPB #105,177570
	BEQ MLOP1
	PRTXT <THIS IS NOT A LOGO CONSOLE
>	
MLOP1:
.ENDC
	JSR PC,EVLINE
	BEQ MWDW
	POPS A
	BR MLOOP
MWDW:	ERROR+WDW	;WHAT SHOULD I DOO WITH (S)

RUNRUG:	JSR PC,CKSST
	BPT
	SEZ
	RTS PC

SYSJOB:	JSR PC,FLUSH
	BR SYSJOB


;CHECK SOME USER VARIALBES -- DEBUGGING FEATURE
UCHECK:	TST	NODESP
	BNE	UCHEC1
	TST	NODESP+2
	BEQ	UCHEC2
UCHEC1:	TST	(P)+	;POP STACK SO IT LOOKS LIKE BUG CAME FROM CALLING ROUTINE
	.BUG.	;1ST 2 WORDS OF NODE SPACE NOT ZERO
UCHEC2:	RTS	PC
	.STITL GET A STRING
GSTR4:	PUSHS C
	PUSH GCHR
	SPUSH PCHR
	SPUSH PRMTCH
	CLR PRMTCH
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	JSR PC,.LOADC
	PUSHS B
	JSR PC,PRLN
	POPS B
	JSR PC,RDSTR
	BEQ GSTR5
GSTR7:	POPS A		;IGNORE ANY LINE TYPED IN
GSTR10:	POP PRMTCH
	SPOP PCHR
	SPOP GCHR
	POPS C
	JSR PC,.LOADC
	JSR PC,.LOADB	;PUT THINGS BACK AS THEY WERE
	BR GSTR3

GSTR5:	BIT #RBRKF,TFLAGS
	BEQ GSTR10
	POP PRMTCH
	ERROR+BRK
GETSTR:	TST FUNLEV	;ARE WE IN A PROC
	BEQ GSTR0	;NO
	BIT #BRKF,FLAGS	;ERROR, MAYBE
	BNE GSTR0	;YES
	MOV CLP,B	;NO, GET THIS NODE OF LLP
	BEQ GSTR9
	JSR PC,.LOAD
	BIT #7777,A	;IS IT LAST NODE
	BNE GSTR8
	SPOP A		;POP RETURN ADDR
	JMP PSTOP

GSTR9:	MOV CPLN,B
	JSR PC,GTLINE
	BNE .+4
	ERROR+LDE	;LINE ..(B).. DOESN'T EXIST
	MOV C,A
GSTR8:	CLR CLP
	MOV A,C
	JSR PC,.LOADC
	JSR PC,.LOAD	;OK, GET FIRST NODE OF LINE, = LINE #
	MOV B,CPLN
	BIT #TPSF,FLAGS
	BNE GSTR4
GSTR3:	MOV C,CLP
	MOV A,CTP	;IN CASE THERE IS NO GENERATION #
	MOV A,C
	JSR PC,.LOADC	;GET SECOND NODE
	CLR CLGN	; IF TYPE = SNUM, IT IS GEN #
	MOV A,C
	BIC #7777,C
	CMP #SNUM,C
	BNE GSTR6
	MOV B,CLGN	;IT IS
	MOV A,CTP
GSTR6:	BIS #LIST,CTP
	PUSHS CTP
	BIT #TRACEF,FLAGS2
	BEQ GSTRT
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
	PRCR
GSTRT:	RTS PC


GSTR0:
GSTR1:	JSR PC,RDSTR
	BNE GSTRT
GSTR2:	BIT #RBRKF,TFLAGS
	BEQ GSTR1
	ERROR+BRK
	.STITL MORE READ ROUTINES!!!
MREAD:	TST FUNLEV	;ARE WE IN PROC?
	BEQ MRD1	;NO
	BIT #BRKF,FLAGS	;YES, BUT ERROR?
	BEQ MRD3
MRD1:	CLR ILINEL
	JSR PC,READ	;CONVERT CHAR STRING TO TOKEN LIST
	BEQ MRD4	;NO TOKENS
	MOV @S,ILINEL
MRD3:	CLZ
MRD4:	RTS PC

CKSTG:	;CKECK IF DISC OR NODES ARE ALMOST GONE
	BIT #DSAMFL,FLAGS2
	BNE CKSTG1
	CMP NNIFSL,#NBN
	BHIS MRD4
	JSR PC,.GCOLL
	CMP NNIFSL,#NBN
	BHIS MRD4
CKSTG1:	CLR ERPROC
	ERROR+NSL
	.STITL EVAL 1 LINE

EVLINE:	MOV	USER,U	;EVALUATES 1 LINE ON S
	TST	BRAKE(U)
	BEQ .+4
	ERROR+BRK
	TST TOPRNM
	BNE EVLI4
EVLI6:	BIC #EVIFS,FLAGS
	CLR CO
	CLR CO+2
	CLR NOR
	CLR COF
	CLR LO
	CLR LO+2
	JSR PC,IGNT
EVLI1:	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,EVAL
	BEQ EVLI3	;NO OUTPUT, OK
	JSR PC,CKSTG
	SEZ
	RTS PC
EVLI3:	JSR PC,CKSTG
	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,GNT
	BIS #RTF,FLAGS
	BR EVLI1
EVLI4:	JSR PC,CKSTG
	MOV @S,B
	JSR PC,.LOAD
	MOV A,D
	BIC #7777,A
	CMP #SNUM,A
	BEQ EVLI5	;AN SNUM
	CMP #INUM,A
	BEQ EVLI8	;AN INUM
	CMP #LSTR,A
	BNE EVLI6	;NOT AN SNUM, INUM OR LSTR
	JSR PC,.CLSIN	;CONVERT LSTR TO INUM
	BEQ EVLI6	;NOT NO. OR TOO BIG
EVLI8:	BIT #SPDF,FLAGS	;IS THIS PROC DEF. BEING SKIPPED?
	BNE EVLI2
	JSR PC,.CINSN	;CONVERT INUM TO SNUM
	BEQ EVLI7	;TOO BIG
	TST B	;IS NO. TOO SMALL?
	BGT .+4
	ERROR+LNTS
	MOV D,A
	BIC #170000,A	;MAKE IT INTO AN SNUM
	BIS #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	MOV C,@S
EVLI5:	JSR PC,ADLN
EVLI2:	CLZ
	RTS PC
EVLI7:	ERROR+LNTB	;LINE # TOO BIG
	.STITL GET NEXT TOKEN

GNT:	MOV CT,A
	MOV CT+2,B
	BIT #RTF,FLAGS	;IS REPEAT TOKEN FLAG SET?
	BEQ GNT1
	BIC #RTF,FLAGS	;YES
	CMP #SFUN,A
	BNE GNT6
	TST B
	BNE GNT6
	BIS #CRF,FLAGS
GNT6:	RTS PC
GNT1:	BIC #PTLPF,FLAGS
	CMP #$LLPAR,B	;IS CT "("
	BEQ GNT3
	CMP #$LPAR,B
	BNE GNT3A
GNT3:	BIS #PTLPF,FLAGS	;YES, SET PTLPF
GNT3A:	MOV A,CTP	;GET LINK TO NEXT TOKEN
	BIT #7777,A
	BEQ GNT2	;ANY TOKENS LEFT
	JSR PC,.LOADA	;YES
	INC CTN
GNT3B:	CMP #$COMT,B
	BEQ SKPCOM
GNT4:	MOV A,CT
	MOV B,CT+2
	RTS PC
GNT2:	BIT #CRF,FLAGS
	BNE GNT5
	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR GNT4
GNT5:	ERROR+OOT	;OUT OF TOKENS
SKPCOM:	MOV A,CTP	;SKIP OVER A COMMENT
	BIT #7777,A
	BEQ GNT2	;END ON CR FOUND
	JSR PC,.LOADA
	INC CTN
	CMP #$COMT,B
	BNE SKPCOM	;DON'T STOP TILL CR OR CLOSING "!"
	BR GNT3A	;RETURN TOKEN AFTER CLOSING "!"

IGNT:	MOV @S,B	;INIT "GNT"
	BIT #7777,B
	BEQ IGNT1
	BIC #CRF,FLAGS
	MOV B,CTP
	JSR PC,.LOAD
IGNT2:	MOV A,CT
	MOV B,CT+2
	BIS #RTF,FLAGS
	MOV #1,CTN
	BR GNT3B
IGNT1:	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR IGNT2
	.STITL LOGO TYI/O
UTYI:	WAIT
	TST CHI
	BEQ UTYI
	MOVB CHI,D
	CLR	CHI
	BIC #177600,D
TYO:	JMP @ITYO

TYI:	JMP @ITYI
STYI:	WAIT
	TSTB TKS
	BPL STYI
	MOVB TKB,D
	BIC #177600,D
STYO:
UTYO:	TSTB TPS
	BPL .-4
	MOVB D,TPB
	CMP #15,D
	BNE UTYOR
	MOV #12,D
	JSR PC,STYO
	MOV #15,D
UTYOR:	RTS PC

;SPRINT-- START SYSTEM PRINT.  CALL WITH JSR A,
SPRINT:	SPUSH	USER
	SPUSH PCHR
	MOV	#-1,USER
	MOV #STYO,PCHR
	JMP	(A)
SPEND:	TST (P)+
	SPOP PCHR
	SPOP USER
	RTS A

;PRINT LOCATIONS ON SYSTEM CONSOLE
;CALL WITH
;	MOV #WDLIST,B
;	JSR PC,PLOCS
;WHERE	WDLIST:	LOCS TO BE PRINTED
;		0
PLOCS:	JSR	A,SPRINT	;START SYS PRINT
	BPRTXT	;RING BELL, C.R.
PLOCS1:	JSR	PC,PLOC
	TST	(B)+
	TST	(B)
	BNE	PLOCS1
	SPREND	;END SYSTEM PRINT
	RTS	PC

;PRINT (B)/ @(B)
PLOC:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	(B),U
PLOC1:	MOV	(U),D
	JSR	PC,PGEN1	;PRINT (U)/ (D)
	SPOP	U
	SPOP	D
	SPOP	A
	RTS	PC

;PRINT B/(B)
PLOCB:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	B,U
	BR	PLOC1
	.STITL	GARBAGE COLLECTOR
NNODES==4096.
GCBTL== NNODES/8./2.*2.	;GARBAGE COLLECT BIT TABLE LENGTH

MARKNI:	SPUSH A
	SPUSH B
	BR MARKN4
MARKN:	SPUSH A	;MARK NODE(B)
	SPUSH B
;DEBUGGING FEATURE
	JSR PC,.LOAD	;ARE WE MARKING AN IDLE NODE
	BIC #7777,A
	CMP #IDLE,A
	BNE .+4
	.BUG.
	MOV (P),B
;
MARKN4:	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;ALREADY MARKED?
	BEQ MARKN1	;NO
MARKN3:	SPOP B
	SPOP A
	SEZ
	RTS PC
MARKN1:	BISB B,(A)
MARKN2:	SPOP B
	SPOP A
	CLZ
	RTS PC
MARKDN:	;SKIP IF NODE (B) IS MARKED
	SPUSH A
	SPUSH B
	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;MARKED?
	BEQ MARKN3	;NO
	BR MARKN2	;YES-SKIP

MARKL:	PUSH A	;MARK LIST
	SPUSH B	;NODE ADDS IN B
	SPUSH C
	JSR	PC,MKLIST
	BR MARKV1

MARKV:	PUSH	A	;MARK VARIABLE
	SPUSH	B	;NODE ADDS IN B
	SPUSH	C
	CLR	A
	MOV	B,C
	JSR	PC,MARKF1	;TREAT POINTER AS A FIRST PTR
MARKV1:	SPOP C
	SPOP B
	POP A
MARKV2:	RTS PC

MARKF:	MOV A,C	;MARK FIRST OF A DATUM (NODE) IN A,,B
MARKF1:	BIT #DSAMFL,FLAGS2
	BEQ MARKF2	;DISK NOT ALMOST FULL
	TST FILFLG
	BEQ MARKF3
	MOV #DREADC,E
	JSR PC,GBITGS	;SET DISK BUFFER BACK UP
MARKF3:	TST SSAVEA	;TOP OF SPDL SWAPPED OUT FOR MARKING?
	BEQ MARKF4	;NO
	SPUSH #SSAVRD
	JSR PC,DSKSEC	;YES, SWAP IT BACK IN
			;INTO (SSWPAD)
			;FROM (SSAVEA) WHERE GCOLL PUTS IT
			;DREADC
	MOV SSAVEA,C	;FREE THE REQUEST BLOCK
	CLR SSAVEA	;CLEAR THIS: IT WORKS AS A FLAG
	JSR PC,UBLKFR	;(NOW FREE IT)
MARKF4:	CLR ERPROC
	.IFNZ NDISP
	ADD #2,S	;POP SNLIST OFF S PDL
	.ENDC
	ERROR+NSL
MARKF2:	BIC	#7777,C	;A TELLS WHAT TYPE OF DATUM IT IS
	SWAB	C
	ASR	C
	ASR	C
	ASR	C	;ALL THIS GIVES YOU THE TYPE*2
	JMP	@LMT(C)	;WHICH YOU MIGHT MARK ON

	.IFNZ NDISP
MKSNAP:	JSR	PC,MKDC	;MARK DISPLAY CODE
	.ENDC
MKLIST:	BIT	#7777,B	;IS THIS NODE REALLY HERE?
	BEQ	MARKV2	;NO. RETURN
MKL1:	PUSH	A	;SAVE BUTFIRST OF CURRENT (I.E. PARENT) NODE
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MKL2
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	JSR	PC,MARKBF	;MARK BUTFIRST OF  NEWTHIS NODE
MKL2:	POP A
	RTS PC

MKATOM:		;MARK ATOM CELL BUT NOTHING INSIDE IT
MKINUM:	JMP MARKNI

GCDIE:	ERROR+FBUG

MARKBF:	BIT	#7777,A	;MARK BUTFIRST OF LIST
	BEQ	MARKV2	;AT END OF LIST
MKBF1:	MOV	A,B
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MARKV2	;ALREADY MARKED, QUIT
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	BR	MARKBF	;MARK BUTFIRST OF  NEW NODE

GCOLL:.GCOLL:	JSR F,ACSAV
	PUSH GNCN
	SPUSH GNCN+2
	SPUSH TMPBLK
	MOV USER,U
	TST GUNSW(U)
	BEQ NOGUN
	SPOP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	JSR F,ACRES
	RTS PC
NOGUN:	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
;	TST FILFLG
;	BEQ .GCOL2
;	MOV #DWRTEC,E
;	JSR PC,GBITGS	;SAVE THE BUFFERS
.GCOL2:	MOV #GCBITS,A	;GARBAGE COLLECT
	MOV #GCBTL/2-1,B	;CLEAR BIT TABLE
	MOV #1,(A)+	;ALWAYS PROTECT NODE ZERO
.GCOL1:	CLR (A)+
	DEC B
	BGT .GCOL1
	CLR SSAVEA	;MAKE SURE THIS IS CLEAR
;NOW MARK EVERYTHING POINTED BY OBLIST.  DONT MARK OBLIST NODES YET
	JSR PC,GNOLEI
MKUOBJ:	JSR PC,GNOLE	;GET NEXT UOE PTR
	BEQ MKTPS
	MOV B,C
	JSR PC,.LOADC	;GET THE NODE
	MOV A,C
MKUOE:	BIT #7777,C	;ONE OTHER NODE?
	BEQ MKUOBJ	;NO
	MOV C,B	;YES
	JSR PC,MARKN	;MARK IT
	JSR PC,.LOADC
	MOV A,C
	BIC #7777,A
	CMP #FBIND,A
	BEQ MKFB	;FUNCTION BINDING
	CMP #VBIND,A
	BEQ MKVB	;VARIABLE BINDING
	CMP #ABIND,A
	BEQ MKARR
	CMP #SVBIND,A
	BEQ MKSVB	;SWAPPED VB
	.BUG.		;BUG
MKVB:	JSR PC,MARKV	;MARK VARIABLE
	BR MKUOE
MKFB:	JSR PC,MARKL
	BR MKUOE
MKSVB:	BR MKUOE
MKARR:	TSTB 5(B)	;IS IT A POINTER ARRAY?
	BNE MKUOE
	MOV B,F		;POINT TO BEG OF ARRAY
	MOV 2(B),-(P)	;PUSH COUNT
	SUB #HEADER,(P)
	ASR (P)
	ADD #HEADER,F
MKAR1:	MOV (F)+,B
	JSR PC,MARKV
	DEC (P)
	BNE MKAR1
	TST (P)+
	BR MKUOE

	;MARK FROM GCMKL LIST
MKTPS:	MOV #GCMKL,F
MKRNDM:	MOV (F)+,B	;POINTER TO POINTER
	BEQ MKSPDL	;LAST ONE
	MOV (B),B	;REAL NODE ADDRESS
	BEQ MKRNDM	;NOTHING THERE
	BIT #170000,B	;IS TYPE FIELD BLANK
	BEQ MKRND1	;YES, MAKE IT LIKE LIST
	JSR PC,MARKV	;MARK VARIABLE
	BR MKRNDM
MKRND1:	JSR PC,MKL1
	BR MKRNDM
	;MARK FROM S PDL
MKSPDL:	MOV #IS,E
MKSP1:	MOV -(E),B	;GET A S PDL WORD
	CMP E,S	;END OF S PDL?
	BLO MKSP2	;YES
	JSR PC,MARKV	;MARK S PDL WORD
	BR MKSP1
MKSP2:	TST IS
	BEQ MKSP4
MKSP3:	JSR PC,UBLKGR
	MOV B,SSAVEA
	SPUSH #SSAVWR
	JSR PC,DSKSEC	;SAVE TOP OF S-PDL ON DISK
			;FROM (SSWPAD)
			;OUT TO (SSAVEA)
			;DWRTEC
MKSP8:	TST IS
	BEQ MKSP6	;NO
MKSP5:	MOV IS,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;GET NEXT PIECE OF S-PDL
			;INTO(SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #176,F
	MOV #IS,E
MKSP7:	MOV -(E),B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	DEC F
	BGT MKSP7
	BR MKSP8

MKSP6:	SPUSH #SSAVRD
	JSR PC,DSKSEC	;RESTORE TOP OF S-PDL
			;INTO (SSWPAD)
			;FROM (SSAVEA)
			;DREADC
	MOV SSAVEA,C
	CLR SSAVEA	;SWAPPED BACK IN
	JSR PC,UBLKFR
MKSP4:
;OK, NOW MARK ALL UOE'S THAT POINT TO FUNCION OR VARIABLE BINDING
	JSR PC,GNOLEI
MKOBL:	JSR PC,GNOLE	;GET NEXT UOE PTR IN B
	BEQ MKOBL6	;NONE LEFT
	MOV B,C
	JSR PC,.LOADC	;GET THE PNAME NODE
	MOV B,D
	BIT #7777,A	;DOES IT POINT TO ANYTHING?
	BNE MKOBL2	;YES, MARK IT
	MOV C,B	;NO WAS IT MARKED?
	JSR PC,MARKDN
	BEQ MKOBL3	;NO - LINK IT OUT
	BR MKOBL7	;YES - ALSO MARK PNAME & BUCKET PTR
MKOBL2:	; - MARK THE UOE ETC.
	MOV C,B	;  -THE UOE NODE
	JSR PC,MARKN
MKOBL7:	MOV D,B	;  -THE PNAME LSTR
	JSR PC,MARKL
	MOV GNCN+2,B	;  -THE BUCKET LIST NODE
	JSR PC,MARKN
	BR MKOBL
	;THIS UOE IS NOT MARKED AND POINTS TO NOTHING - LINK IT OUT
MKOBL3:	MOV TMPBLK,C	;GET PTR TO PREDECESSOR NODE
	BNE MKOBL4	;NONE, SO UHCT WAS PRED.
	MOV GNCN,-2(E)	;SO CHANGE IT
	BR MKOBL5
MKOBL4:	MOV GNCN,A	;CHANGE PTR IN PRED NODE
	JSR PC,.STP1
MKOBL5:	MOV C,GNCN+2	;SO GNOLE WILL WORK
	BR MKOBL
MKOBL6:



	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;IF GUY HAS DISPLAY
	BEQ	GCDIS2
	JSR PC,DSGCF		;GCOLL IT, TOO
GCDIS2:
GCDIS:
	.ENDC


		;OK NOW RETURN ALL IN MARKED NODES
		;RA ADDS OF LIT MAP
		;RB NODE ADDS
		;RC ACTUAL ADDER OF NODE
		;RD BIT MAP
		;RE POINT TO LIST OF FREE STORAGE RECYCLED NODES
		;RF NUMBER NODES LEFT TO CHECK
		;START COLLECTING AT LUNN(LOWEST UNPROTECTED NODE #)
	CLR E
	CLR NNGC
	MOV #NODESP,C	;NODE ZERO ADDRESS
	MOV NODTOP,F
	SUB C,F		;COMPUTE LEGNTH OF NODESP
	ASR F
	ASR F		;COMPUTE NUMBER OF NODES
	CLR B		;NODE ZERO
	MOV #GCBITS,A	;BIT TABLE ADDR
GCRT2A:	MOV (A)+,D	;GET NEXT WORD OF BIT MAP
	SEC
	ROR D

GCRT2:	BCS GCRT3
	CMP B,#LUNN
	BLOS GCRT3
	TST E		;WE HAVE A FREE NODE; IS FIRST FREE FOUND?
	BNE GCRT2B
	MOV B,FREE	;NO, THIS IS IT
	BR GCRT2C	;(NO LAST-FREE TO UPDATE)

GCRT2B:	BIS B,(E)	;ELSE: POINT LAST-FREE TO THIS NODE
GCRT2C:	MOV C,E		;THIS NODE IS NEW LAST-FREE
	MOV #IDLE,(C)+	;MAKE NEW IDLE NODE, POINTS NOWHERE
	CLR (C)+
	INC NNGC
	BR GCRT4
GCRT3:	CMP (C)+,(C)+
GCRT4:	INC B
	DEC F
	BLE GCRT5
	CLC
	ROR D
	BNE GCRT2
	BR GCRT2A
GCRT5:	MOV NNGC,NNIFSL
;DEBUGGING FEATURE
	BIT #PNNLF,FLAGS2
	BEQ GCRT6
	CPRTXT ^/[NODES LEFT /
	MOV NNGC,A
	JSR PC,PRDN
	PRTXTC ^/ ]/
;
GCRT6:
;	TST FILFLG
;	BEQ GCRT7	;NO
;	MOV #DREADC,E
;	JSR PC,GBITGS	;GET BACK THE BUFFERS
GCRT7:	POP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	JSR F,ACRES
	SEZ
	RTS PC

GBITGS:	MOV USER,U
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+
	MOV #-DBUFL/2,(A)+
	MOV #GCBITS-PURE,(A)
	MOV SLOTAS(U),B
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	MOVB C,6(A)
	MOV UDBFSV(U),(A)+
	MOV UDBFSV+2(U),(A)+
	TST (A)+
	BIS E,(A)
	JMP DSKWAI
	.STITL GET NEXT OBLIST ELEMENT
GNOLE:		;GET NEXT USER OBLIST ELEMENT - PTR
		;INPUT - VIA GNOLEI
		;OUTPUT - PTR TO THIS BUCKET IN B & GNCN
		;	   " " NEXT " " GNCN+2
		;	   " " PRED " " TMPBLK
		;	   IF NO PREV BUCKET, TMPBLK = 0
		;USES E.  SKIPS UNTIL NO UOE PTRS LEFT
	PUSH A
	MOV GNCN,B
	MOV GNCN+2,TMPBLK
GNOLE2:	MOV B,GNCN+2
	BIC #170000,B
	BEQ GNOLE1
	JSR PC,.LOAD	;GET NEXT PTR ON BUCKEN LIST
	MOV A,GNCN
	JMP SRETA
GNOLE1:	CLR TMPBLK
	MOV (E)+,B	;GET NEXT BUCKET LIST
	BGE GNOLE2
	JMP RETA	;DONE
GNOLEI:	MOV #UHCT,E
	CLR GNCN
	RTS PC
.STITL SYSTEM PRIMITIVES
	VERN==VERN+%FNAM2
.IFNZ ENG&FR
ENGLIS:ANGLAI:	MOV #ENGFLG,LANG
ENG1:	SEZ
	RTS PC
FRENCH:FRANCAIS:	MOV #PFRFLG!FRFLG,LANG
	BR ENG1
FRANGLAIS:	BIS #ENGFLG!FRFLG,LANG
	BR ENG1
.ENDC
;THIS IS THE STUFF FOR ARRAY HACKING

SETASZ:	JSR PC,G1NARG
	ASL B
	MOV ENDWLD,A
	SUB B,A		;COMPUTE NODTOP
	CMP #NODESP+400,A
	BLO .+4		;IS THIS POSSIBLE?
	ERROR+NAS	;NO
	MOV USER,A
	MOV B,UASIZE(A)
SEZWHO:	JMP HELLO	;REINITIALIZE USERS SLOT
AMAKE:	MOV 4(SP),D	;NO. OF ARGS
	ASL D
	ADD S,D
	MOV -(D),A	;ADDR OF ARRAY NAME
AMAKE5:	MOV A,B
	BIC #7777,A
	CMP #ATOM,A	;IS A TYPE ATOM?
	BNE AMAKE3	;NO
AMAKE4:	MOV #ABIND,A
	JSR PC,.BINDL
	BEQ AMAKE6
	CLR TOPS
	RTS PC
AMAKE3:	CMP #LSTR,A	;IS A TYPE LSTR?
	BNE AMAKE2	;YES
AMAKE1:	BIT #7777,B	;NULL POIMTER?
	BEQ AMAKE2	;YES
	MOV B,TOPS
	JSR PC,.OBSCH	;GET ATOM
	BNE AMAKE4
AMAKE6:	ERROR+UDA
AMAKE2:	ERROR+WTAB



ARRAD:	MOV B,E
	SPUSH E	;TOP OF ARRAY HEADER
	CMPB 4(E),F	;IS DIM=NO. OF INDICES?
	BEQ ARRAD1	;YES
	ERROR+WNA	;WRONG NO OF ARGS
ARRAD1:	CLR A	;TEMP ACCUMULATOR
	ADD #12,E	;LENGTH OF DIMENSION IN E
ARRAD2:	JSR PC,G1NARG	;GET INDEX OFF S-PDL
	CMP B,(E)	;INDEX IN BOUNDS?
	BGE ARRAD4	;NO
	TST B	;NEGATIVE INDEX?
	BGE .+4	;INDEX OK
ARRAD4:	ERROR+ROB
	ADD B,A
	DEC F
	BEQ ARRAD3	;MORE INPUT
	MUL -(E),A
	MOV B,A
	BR ARRAD2
ARRAD3:	SPOP E	;ADDR OF ARRAY HEADER
	TSTB 5(E)	;IS TYPE PTR?
	BEQ .+4
	ASL A
	ASL A		;TOTAL OFFSET (A*4)
	ADD #14,E	;ADDR OF FIRST VALUE
	ADD E,A		;ADDR OF VALUE TO BE STORED
	RTS PC


STORE:	JSR PC,AMAKE
	SPOP	A	;RETURRN ADDR
	SPOP F		;NO. OF ARGUMENTS
	SPUSH	A
	SUB #2,F
	POPS D		;VALUE TO BE STORED
	JSR PC,ARRAD	;FIND STORAGE LOCATION
	MOV A,F
	MOV -10(E),A
	MOV D,B
	BIC #7777,A
	BEQ STORE1
	JSR PC,CONVERT
	BNE .+4
	ERROR+WTAB
	JSR PC,.LOADB
	MOV A,(F)+
STORE1:	MOV B,(F)	;VALUE IS NOW STORED
	ADD #2,S
	SEZ
	RTS PC


GET:	JSR PC,AMAKE
	SPOP	A	;RETURN ADDR
	SPOP F	;NO. OF ARGUMENTS
	SPUSH	A
	DEC F		;NO. OF INDICES
	JSR PC,ARRAD	;COMPUTE STORAGE LOCATION
	MOV A,F		;STORAGE LOCATION ADDR IN F
	MOV (F),C
	TSTB -7(E)	;TEST TYPE
	BEQ GET1	;TYPE 0 (PTR)
	MOV (F)+,A
	MOV (F),B
	JSR PC,GRBAD	;STORES VALUE IN NODE SPACE
	MOV -10(E),D
	BIC #7777,D
	BIS D,C		;SET TYPE ON PTR TO VALUE
GET1:	MOV C,@S	;PTR ON TOP OF S-PDL
	CLZ
	RTS PC

LIMIT==3
HEADER==14
BKPTR==4
SIZE==2


	;INPUT--B HAS SIZE OF BLOCK TO BE ALLOCATED IN BYTES
	;OUTPUT--A HAS PTR.TO BLOCK IF ALLOCATION SUCESSFUL
	;        SECOND WORD OF BLOCK CONTAINS SIZE OF BLOCK IN BYTES
	;        AND SKIP RETURN


.ALLOC:	CMP	B,ASPACE	;SIZE OF ARRAY .LE. FREE SPACE?
	BLE	.+6		;YES
	SEZ
	RTS	PC		;NO,RETURN

	PUSH	C
	MOV	AROVER,A	;GET FRE BLOCK PTR.
SRCBLK:	CMP	B,SIZE(A)	;IS BLOCK NOW POINTED AT BIG ENOUGH?
	BLE	OKALOC		;YES
	CMP	@A,AROVER	;CHAIN GONE THRU' ONCE?
	BEQ	CMPRES		;YES
	MOV	@A,A		;NEXT FREE BLOCK
	BNE	SRCBLK		;LAST BLOCK IN CHAIN?
	MOV	AFREE,A		;YES,START FROM THE BEGINNING
	CMP A,AROVER
	BNE SRCBLK

CMPRES:	JSR	PC,.PRESS	;GO COMPRESS THE ARRAY SPACE
	MOV	AROVER,A	;A POINTS TO FREE SPACE
OKALOC:	MOV SIZE(A),C
	SUB B,C
	CMP #20,C
	BGE HOLE
	MOV	A,C		;TO ADDR.OF FREE BLOCK
	ADD	B,C		;ADD SIZE OF ALLOCATED BLOCK TO GET NEW FREE BLOCK ADDR.
	SUB	B,SIZE(A)	;GET SIZE OF NEW FREE BLOCK
	MOV	SIZE(A),SIZE(C)	;AND STORE IN SIZE FIELD OF NEW FREE BLOCK
	MOV B,SIZE(A)
	MOV	BKPTR(A),BKPTR(C)	;PTR. MANAGEMENT
	BEQ	NEWBK1		;IF THIS BLOCK FIRST OF CHAIN,SKIP
	MOV	C,@BKPTR(A)	;CHANGE FORWARD PTR. OF LAST BLOCK
NEWBK1:	MOV	(A),(C)		;FORWARD PTR. FOR NEW BLOCK
	BEQ	NEWBK3		;IF THIS BLOCK IS LAST IN CHAIN,SKIP
NEWBK2:	ADD	#BKPTR,@A	;TO ACCESS BKPTR FIELD OF NEXT BLOCK
	MOV	C,@(A)		;AND CHANGE IT
NEWBK3:	MOV	C,AROVER	;UPDATE FREE BLOCK ROVING POINTER
	CMP	AFREE,A		;REQUIRED TO UPDATE AFREE?
	BNE	ALDONE		;NO
	MOV	AROVER,AFREE	;YES
ALDONE:	SUB	SIZE(A),ASPACE	;UPDATE FREE SPACE AVAILABLE
	POP	C
	CLZ
	RTS PC
			;SKIP RETURN

HOLE:	MOV	BKPTR(A),C	;TO LINK UP WITH BLOCK BEFORE THE ONE ALLOCATED
	BNE	NEWBK1		
	MOV (A),C
	BR NEWBK3
	;RELEASE A BLOCK IN THE ARRAY SPACE
	;INPUT--B HAS PHYSICAL PTR TO BLOCK TO BE RELEASED
	;OUTPUT--B UNCHANGED. RELEASED BLOCK INSERTED INTO CHAIN OF FREE BLOCKS


.RELES:	ADD	SIZE(B),ASPACE	;UPDATE ASPACE
	TST	AFREE		;IS ARRAY SPACE EMPTY?
	BEQ	ONEBLK		;YES
	PUSH	A
	SPUSH	C
	SPUSH	D
	MOV	AROVER,C
	CMP	B,C		;ADDR OF RELEASED BLOCK > (AROVER)
	BHI CHAIN		;START TRYING TO INSERT AT AROVER
	MOV	AFREE,C		;OTHERWISE START AT AFREE
	CMP B,C
	BHI CHAIN
	MOV AFREE,A
	JSR PC,ONEBLK
	MOV B,C
	ADD SIZE(B),C
	CMP A,C
	BNE .RELE1
	MOV (C),(B)
	ADD SIZE(C),SIZE(B)
	BR REDONE
.RELE1:	MOV A,(B)
	MOV B,BKPTR(A)
	BR REDONE

CHAIN:	MOV	C,A		;A_CURRENT FREE BLOCK
	MOV	(A),C		;C_NEXT FREE BLOCK
	BEQ	LSTBLK		;CURRENT BLOCK IS LAST IN CHAIN
	CMP	C,B		;ADDR OF NEXT FREE > ADDR OF RELEASED?
	BLT	CHAIN		;NO,TRY NEXT ONE
	MOV	SIZE(B),D	;YES,START INSERTING THE RELEASED BLOCK
	ADD	B,D		;SIZE IN BYTESADDED TO (B) GIVES END OF RELEASED BLOCK
	CMP	C,D		;WHICH MIGHT BE ADJACENT TO NEXT FREE BLK
	BNE	LSTBLK		;NO
	ADD	SIZE(C),SIZE(B)	;YES,COLLAPSE THE TWO
	MOV	(C),C		;UPDATE FWDPTR

LSTBLK:	MOV	SIZE(A),D	;THIS FREE BLOCK 
	ADD	A,D		;MIGHT BE ADJACENT TO THE
	CMP	D,B		;RELEASED BLOCK
	BEQ	CONBLK		;YES
	MOV	C,(B)		;NO,JUST UPDATE PTR
	MOV	A,BKPTR(B)	;SIZE FIELD NEED NOT BE CHANGED
	MOV	B,(A)	
	TST	C		;IF THIS FREE BLOCK IS LAST IN CHAIN
	BEQ	REDONE		;THEN NOTHING
	MOV	B,BKPTR(C)	;ELSE UPDATE BKPTR OF NEXT BLK
REDONE:	POP	D
	SPOP	C
	SPOP	A
	RTS	PC

ONEBLK:	MOV	B,AFREE		;RELEASED BLOCK IS THE ONLY FREE ONE
	MOV	B,AROVER
	CLR	(B)
	CLR	BKPTR(B)
	RTS	PC


CONBLK:	ADD	SIZE(B),SIZE(A)	;COLLAPSE
	MOV	C,(A)		;AND UPDATE PTR
	BR	REDONE
	;THIS ROUTINE COMPRESS THE ARRAY SPACE BY STACKING FREE BLOCKS TOGETHER
	;AFREE POINTS TO FIRST FREE BLOCK IN THE CHAIN
	;FIRST WORD OF USED BLOCK MUST CONTAIN PTR. TO WORD POINTING TO THAT BLOCK FOR RELOCATING

.PRESS:	TST	AFREE		;ARE THERE ANY FREE BLOCKS?
	BNE	.+4		;YES
	RTS	PC		;NO,DONE
	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D

	MOV	AFREE,A		;A_FIRST FREE BLOCK ADDR
MOVNXT:	MOV	A,B		;B_CURRENT FREE BLOCK ADDR
	MOV	(B),A		;A_NEXT FREE BLOCK ADDR
	BEQ	PSDONE		;IF NEXT FREE BLOCK ADDR = 0,DONE
	MOV	SIZE(B),C	;FREE BLOCK SIZE IN BYTES
	ADD	B,C		;PLUS FREE BLOCK ADDR=STARTING ADDR OF USED BLOCK

COLAPS:	MOV	SIZE(C),D	;GET USED BLOCK SIZE
	ASR	D		;GET SIZE IN WORDS
	MOV	B,@(C)		;CHANGE PTRRR TO ARRAY		
	MOV	(C)+,(B)+	;BLOCK TRANSFER
	SOB	D,.-2		;COUNTER
	CMP	C,A		;THIS BLOC OF USED BLOCKS MOVED?
	BEQ	MOVNXT		;YES,MOVE NEXT BLOC
	BR	COLAPS		;NO,CONTINUE TO TRANSFER NEXT USED BLOCK

PSDONE:	SPOP	D
	SPOP	C
	SPOP	B
	SPOP	A
	MOV	ASPACE,SIZE(B)
	JMP	ONEBLK		;TAKE CARE OF AFREE AND RETURN
	;DEFINE AN ARRAY

DEFAR:	POP	A		;RETURN ADDR
	SPOP	F		;NO. OF ARGS PASSED
	SPUSH	A
	CMP	F,#LIMIT+2	;WHICH SHOULD BE < ALLOWABLE LIMIT
	BLE	OKARAY		;OKAY,THIS IS.
AERROR:	ERROR+WDIM
OKARAY:	SUB	#2,F		;DIMENSION OF ARRAY IN F
	MOV	F,A
	MOV	#1,D		;SET UP FOR MULTIPLICATION
	JSR	PC,G1NARG	;GET TYPE
	MOV	B,E		;SAVE IT
	TST	B
	BEQ	ALNUM		;0 FOR LNUM
	.IFNZ FPPF
	CMP	#1,B
	BEQ	AFNUM		;1 FOR FNUM
	.ENDC
	CMP #2,B
	BEQ NXTIDX	;2 FOR PTR
	ERROR+BAT
ALNUM:	BIS	#LNUM,F
	BR	NXTIDX
	.IFNZ FPPF
AFNUM:	BIS	#FNUM,F
	BR	NXTIDX
	.ENDC
NXTIDX:	JSR PC,G1NARG	;GET MAGNITUDE OF LAST DIMENSION
	PUSH	B		;SAVE THIS DIMENSION
	MUL	B,D		;D IS ODD
	BLE	AERROR		;DIMENSION < 0
	BCS	AERROR		;DIMENSION TOO BIG
	SOB	A,NXTIDX
	SPUSH	F		;SAVE DIMENSION OF ARRAY
	BIT	#160000,D	;SIZE SHOULD NOT BE TOO BIG
	BNE	AERROR
	CMP	#2,E		;IS THIS PTR ARRAY
	BEQ	.+4
	ASL	D		;THIS IS DOUBLE PRECISION ARRAY
	ASL	D		;TO CONVERT TO BYTES
	ADD	#HEADER,D
	SPUSH	D		;SAVE SIZE OF ARRAY BLOCK
	MOV	@S,B		;GET NAME OF ARRAY
	MOV	B,A		
	BIC	#7777,A		;SEE WHETHER IT HAS BEEN INTERNED?
	CMP	#ATOM,A		;BY TESTING ITS TYPE
	BEQ	FABIND		;YES
	CMP	#LSTR,A		;NO,IS NAME ALL RIGHT
	BEQ	.+4		;YES
	ERROR+WTAB
	MOV	B,TOPS
	JSR	PC,.INTRN	;INTERN NAME OF ARRAY
	MOV	B,@S		;SAVE UOE PTR
FABIND:	CLR	TOPS		;NOT TO CHANGE BINDING
	MOV	#ABIND,A	;SEE IF AN ARRAY IS
	JSR	PC,.BIND	;BINDED TO THIS NAME
	BEQ	GETSPA		;NO
	MOV	C,@S		,SAVE PTR TO BINDING NODE
	MOV	B,C
	MOV 2(C),B
	ADD	ASPACE,B	;ADDED TO AVAILABLE FREE SPACE
	CMP	B,@P		;IS SUM ENOUGH FOR NEW BINDING?
	BGE	ERAOLD		;YES
FULL:	ERROR+NAS		;NOT ENOUGH SPACE
ERAOLD:	MOV	C,B
	JSR	PC,.RELES	;RELEASE OLD BINDING

GETSPA: SPOP B	;GET SIZE OF ARRAY
	MOV B,D		;SAVE IT
	JSR	PC,.ALLOC	;ASSIGN SPACE
	BEQ	FULL		;NOT ENOUGH
	SPOPS	B		;UOE PTR
	MOV	A,TOPS		;ARRAY PTR
BINDA:	MOV	#ABIND,A
	JSR	PC,.BIND	;BIND NEW ARRAY
	BIC	#170000,C	;PTR TO BINDING NODE
	ASL	C
	ASL	C
	ADD	#NODESP+2,C	;THIS IS PHYSICAL ADDR OF BINDING NODE
	MOV	TOPS,A		;PTR TO ARRAY
	MOV	C,(A)+		;BACK PTR FIRST ENTRY IN HEADER
	MOV (A)+,D	;SIZE OF ARAY SECOND
	SPOP	F
	MOV	F,(A)+		;DIMENSION OF ARRAY THIRD
	ADD	#LIMIT*2,A	;TO ADVANCE (A)
	BIC	#177400,F	;GET DIMENSION PART
	MOV	F,E
	ASL	E		;TO GET IT INTO BYTES
	SUB	E,A		;FOR OFFSET INTO HEADER
POPDIM:	SPOP	(A)+
	SOB	F,POPDIM
	SUB #HEADER,D
	ASR D
	CLR (A)+	;ZERO ARRAY VALUES
	SOB D,.-2
	SEZ
	RTS	PC
ERARAY:	JSR	PC,GTUOEB	;GET NEXT TOKEN
	BNE	ERARA1
ERARA2:	CLR	TOPS
	MOV	#ABIND,A
	MOV	B,F
	JSR	PC,.BIND
	BEQ ERARAR
	JSR	PC,.RELES	;RELEASE ARRAY BLOCK
	MOV	F,B
	JSR PC,.UNBND
ERARAR:	SEZ
	RTS PC

ERARA1:	CMP	#UFUN,A
	BGT	.+4
	ERROR+ERW
	JSR	PC,CVSFLS
	MOV	#ATOM,A
	JSR	PC,.OBSCH
	BNE	ERARA2
ERARA3:	RTS PC


ERARAS:	JSR	PC,GNOLEI
ERARS1:	JSR	PC,GNOLE
	BEQ ERARAR
	MOV	B,F
	CLR	TOPS
	MOV	#ABIND,A
	JSR	PC,.BIND
	BEQ	ERARS1		;THIS NAME HAS NO ARRAY BINDING
	JSR	PC,.RELES	;RELEASE THIS ARRAYY
	MOV	F,B
	JSR	PC,.UNBND
	BR	ERARS1


;RETURNS SIZE OF ARRAY DIMENSIONS
ASIZEX:	MOV @S,A	;ARRAY NAME
	JSR PC,AMAKE	;FINDS TOP OF ARRAY SPACE
ASIZE2:	PUSH E
	MOV B,E
	MOVB 4(E),D	;TYPE/DIM WORD
	MOV D,F
	SPUSH D		;SAVE IT
	ASL D		;SETS UP OFFSET FOR DIMENSION WORD
	SUB D,E
	ADD #2,S	;POP OFF THE ARRAY NAME
	ADD #14,E	;ADDR. OF FIRST DIM.
ASIZE1:	MOV (E)+,B
	JSR PC,.CSNIN	;CONVERT TO INUM AND PUT IN NODE 
	SPUSHS C	;SAVE PTR ON S-PDL
	SOB F,ASIZE1	;CHECK FO MORE DIMS.
	SPOP D		;NO OF DIMS. IN D
	JSR PC,SENT.	;LINK DIMS. IN LIST
	POP E
	CLZ
	RTS PC


.IFNZ FPPF

;FLOATING POINT MACROS

.MACR FPUSH FF
	STF FF,-(P)
	JSR PC,PPUSHT
.ENDM


.MACR FPOP FF
	LDD (P)+,FF
	JSR PC,PPOPT
.ENDM

.ENDC





.IFZ FPPF


;SINGLE PRECISION ARITHMETIC ROUTINES

UPLUS:	CLZ	;UNARY PLUS - NOTHING TO DO
	RTS PC
UMINS:	JSR PC,G1IARG	;UNARY MINUS
	DPNEG	B,C
DONBC:	JMP	R1I.BC

SUM:
	EXCH (P),2(P)
	CLR	E
	CLR	F
	MOV	(SP)+,D	;NUMBER OF ARGS
	BLE	DIFF.2	;DONE
SUM.1:	JSR	PC,G1IARG	;GET 1 INTEGER
	DPADD	B,C,E,F
	DEC	D	;COUNTER
	BGT	SUM.1
	BR	DIFF.2	;DONE

DIFF:
	JSR	PC,G2IARG	;GET 2 INTEGERS
	DPSUB	B,C,E,F
DIFF.2:	CMP	E,#100000	;IS ANSWER = 100...00 ?
	BNE	DONEMP
	TST	F	;IF SO , THEN ERROR
	BNE	DONEMP
	ERROR+RTB	;SINCE THAT IS SMALLEST NEG NUMBER
DONEMP:	JMP	R1I.EF

PROD:
	EXCH (P),2(P)
	CLR	E
	MOV	#1,F
	MOV	(SP)+,D	;NUMBER OF ARGS
PROD.1:	DEC	D
	BLT	DONEMP	;DONE
	JSR	PC,G1IARG	;GET ONE ARG IN B
	JSR	PC,.DPMUL
	BNE PROD.1
	ERROR+RTB	;RESULT TOO BIG

MOD:
	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONBC
	ERROR+RTB

DIVDE:
DIV.1:	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONEMP
	ERROR+RTB


.ENDC


.IFNZ FPPF


;FLOATING POINT ARITHMETIC ROUTINES

ERRET:	ERROR+RTB
UPLUS:	CLZ
	RTS PC
UMINS:	MOV #INUM,F
	JSR PC,G1ARG
	LDD FA,FB
	NEGF FB
	BR .FSTOR	;STORE FB
DIFF:	JSR PC,G2ARG	;LOAD FA AND FB
	SUBF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
SUM:	EXCH (P),2(P)
	MOV #INUM,F
	CLRF FB
	SPOP D		;SET UP COUNTER
	BLE .FSTOR
SUM.1:	JSR PC,G1ARG	;GET A NUMBER
	ADDF FA,FB	
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT SUM.1	;ADD MORE NUMBERS
	BR .FSTOR	;DONE AT LAST
PROD:	EXCH (P),2(P)
	MOV #INUM,F
	LDCFD #40200,FB	;LOAD CONSTANT "1"
	SPOP D
	BLE .FSTOR	;DONE ALREADY
PROD.1:	JSR PC,G1ARG
	MULF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT PROD.1	;LOOK AT COUNTER

;THIS TAKES A NUMBER OUT OF FB AND
;CONVERTS IT ACCORDING TO TYPE IN REG F (INUM,FNUM)
;AND RETURNS

.FSTOR:CMP #FNUM,F	;FNUM OR INUM?
	BEQ .FST.2
	STCFI FB,-(P)	;PUT INUM ON STACK
	BCS ERRET	;OVERFLOW?
.FST.1:	SPOP A
	SPOP B
	JSR PC,GRBAD	;STORE ANSWER
	BIS F,C		;SET TYPE
	JMP ORTC
.FST.2:	STCDF FB,-(P)	;PUT FNUM ON STACK
	JMP .FST.1
DIVDE:	JSR PC,G2ARG	;GET ARGS
	TSTF FA		;TEST ZERO DIVIDE
	CFCC
	BEQ ERRET	;IT WAS!!??
	DIVF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
MOD:	JSR PC,G2ARG	;GET ARGUMENTS IN FA AND FB
	SPUSH #.FSTOR
.MOD:	TSTF FA		;IS FA 0?
	CFCC
	BEQ ERRET	;IT IS??
	LDD FB,FC	;FC <- FB
	DIVF FA,FC	;FC <- (FB/FA)
	CFCC
	BVS MOD2	;THE ANSWER IS 0
	MODD #40200,FC	;SEPERATE INTEGER AND FRACTION PARTS
	MULF FA,FD	;FD <- FA * (INT (FB/FA))
	SUBF FD,FB	;FB <- MOD (FB,FA)
MOD1:	CFCC
	BGE MOD3	;IS IT POSITIVE?
	ADDF FA,FB	;NO, ADD FA
	BR MOD1
MOD2:	CLRF FB
MOD3:	RTS PC


SQRT:	JSR PC,G1NUM
	BNE .+4
SQRT1:	ERROR+WTA
	TSTF FA
	CFCC
	BMI SQRT1
	BEQ SQRTRT
	LDF FA,FB
	STEXP FA,A
	LDEXP #0,FA
	ASR A
	ADC A
	ADDF #40000,FA
	BCS .+6
	ADDF #40000,FA
	CLRF FC
	LDEXP A,FC
	MULF FC,FA
	MOV #4,A
SQRTLP:	LDF FB,FC	;FC <= X
	DIVF FA,FC	;FC <= X/Y
	ADDF FC,FA	;FA <= Y + X/Y
	MULF #40000,FA	;FA <= 1/2 * (Y + X/Y)
	SOB A,SQRTLP
SQRTRT:	MOV #FNUM,F
	STCDF FA,-(P)
	JMP .FST.1
.ENDC





SENTENCE:
	SPOP EXCH1
	MOV (SP),D
	MOV EXCH1,(SP)	;# OF ARGS . DON'T CHANGE FROM D WITHOUT CHANGING SNAP!!!!
SENT.:	CLR	C
	TST	D
SENT.1:	BLE	SENT.R	;RETURN
	MOV	@S,B	;ARGUMENT.  LEAVE ON S-PDL FOR GARBGE COLLECTOR
	MOV	B,A
	BIC	#7777,A	;LEAVE ONLY DATA TYPE
	CMP	#LIST,A
	BEQ	SENT.S	;ARG IS LIST
	CMP	#ATOM,A
	BNE	SENT.2	;ARG IS LSTR OR INUM

;ARG IS AN ATOM
SENT.A:	JSR	PC,.LOAD	;CONVERT ATOM TO LSTR
	MOV	#LSTR,A

SENT.2:	BIS	C,A	;C POINTS TO PREVIOUS STUFF OF SENTENCE
	JSR	PC,GRBAD

SENT.3:	MOV	C,GCPREV	;POINTER TO PREVIOUS STUFF OF SENTENCE
	BIS	#LIST,GCPREV	;GARBAGE COLLECTOR NEEDS RIGHT DATA TYPE
SENT.4:	JSR	PC,SPOPT	;POP S
	DEC	D	;COUNTER
	BR	SENT.1

SENT.S:	BIT	#7777,B	;ARGUMENT IS A LIST
	BEQ	SENT.4	;EMPTY
	TST	C	;0 IF FIRST TIME CALLED
	BEQ	SENS.1	;NO NEED TO COPY
;SECOND OR LATER TIME THROUGH
SENS.2:	JSR	PC,COPYL	;COPY LIST. RETURN POINTER IN B
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;C STILL POINTS TO LAST NODE COPIED
SENS.1:	BIC	#170000,B	;LEAVE POINTER ONLY
	MOV	B,C
	BR	SENT.3

;RETURN.  POINTER TO SENTENCE IN C
SENT.R:	BIS	#LIST,C
	CLR	GCPREV
	PUSHS	C
	CLZ
	RTS	PC



LIST.P:
	EXCH (P),2(P)
	MOV	(SP),D	;COUNT
	MOV	#ORTC,(SP)	;RETURN ADDRESS
LIST1:	CLR	C
LIST.1:	DEC	D	;COUNT
	BLT	LIST.9	;DONE
	MOV	@S,B
	MOV	B,A
	BIC	#7777,A	;LEAVE DATA TYPE ONLY
LIST.2:	BIS	C,A	;POINTER TO REST OF LIST
	JSR	PC,GRBAD
	MOV	C,GCPREV	;PROTECT FROM GARBAGE COLLECTOR
	BIS	#LIST,GCPREV	;GAR. COLL. NEEDS RIGHT DATA TYPE
	JSR	PC,SPOPT
	BR	LIST.1	;GET NEXT ARG

LIST.9:	CLR	GCPREV
	BIS	#LIST,C
	RTS	PC


FPUT:
	CLR	F
	BR	.+6
LPUT:
	MOV	#<LPUT1-FPUT1>,F
	EXCH (P),2(P)
	MOV	(SP),D	;NUMBER OF ARGS
	MOV	#ORTC,(SP)	;RETURN ADDRESS
	DEC	D
	BGT	.+4
	ERROR+UEL	;NEED AT LEAST 2 ARGS
	JSR	PC,GLWARG
	BEQ	.+4	;LIST
	ERROR+WTA	;FIRST ARG MUST BE LIST
	ADD	F,PC	;CHOOSE BETWE