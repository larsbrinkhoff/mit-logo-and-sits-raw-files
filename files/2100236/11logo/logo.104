	.TITLE PDP11 LOGO
	.ABS
	%COMPAT==0
VERNF==%FNAM2
	.STITL CONFIGURATION PARAMETERS
.INSRT SITS;SITSS SYMS
.INSRT SITS;SITMAC >
.IF1
TS==1
SWAPF==1
DHON==0
SYSP==0
HALFLG==0
ASSSW==0
NPLOT==1
NDISP==1
	DDF==1
	FPPF==1

GUY==0
AI==0
FLASK ^/1==>REDEFINE, 0==>NO REDEFINE/,JGB
FLASK ^/1==>EDIT, 0==>NO EDIT/,JGJB
FLASK ^/1==>TVS, 0==>NO TVS/,TVS

	.IFZ ASSSW
	ENG==1
	FR==0
	AI==1
	.ENDC

	.IFZ ASSSW-1
	ENG==1
	FR==1
	GUY==1
	.ENDC

	.IFZ ASSSW-2
		.MACR SETFLG FLG
		.PRINT /FLG=/
		.TTYMAC FLAG
		FLG==FLAG
		.ENDM
		.ENDM
	
		SETFLG FPPF
		SETFLG DDF
	.ENDC

.ENDC

	.MACR FOR FLG
	.XLIST
	.IFNZ FLG
	.LIST
	.ENDM

	.MACR ENDC FLG
	.IFZ FLG
	.LIST
	.ENDC
	.ENDM
	.STITL SYSTEM PARAMETERS

A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
U=%5
P=%6
SP=%6
PC=%7

FA==%0
FB==%1
FC==%2
FD==%3
FE==%4
FF==%5

EOFCHR==3

ERROR==TRAP


.BUG.==ERROR+BUG

;DATA SPACE PAGE MAP

;PAGE 0
;	SYSTEM TRAP VECTOR(S)
;	MISC VARIABLES
;	BEGINING OF ARRAY SPACE

PURPG==1
PURAD==PURPG*20000
PURE==PURAD
;PAGE 1
;	PURE CONSTANTS
;		MISC
;		SOBLST
;		ERRORS+ERROR TABLES

ARYPG==2
ARYAD==ARYPG*20000
;PAGE 2
;	MORE ARRAYS

ARYHPG==3
;PAGE 3
;	STILL MORE ARRAYS
;	(END OF ARRAYS, CURRENTLY)

DISPG==4
DISAD==DISPG*20000
;PAGE 4
;	OLD STYLE DISPLAY
;	BEGINNING OF TV DISPLAY
;	MAYBE (UGH!) MORE ARRAYS

HAKPG==5
HAKAD==HAKPG*20000
;PAGE 5
;	MISC HACKS
;		DIRECTORY FOR PRINTING OUT

NODPG==6
NODESP==NODPG*20000
;PAGE 6
;	START OF NODE SPACE

NODPG1==7
;PAGE 7
;	END OF NODE SPACE
	.STITL MACROS
	.MACRO BRAKET
	TST BRAKE
	BEQ .+4
	ERROR+BRK
	.ENDM

	.MACR PUSH AA
	MOV AA,-(P)
	JSR PC,PPUSHT
	.ENDM

	.MACR POP AA
	MOV (P)+,AA
	JSR PC,PPOPT
	.ENDM

	.MACR PUSHS AA
	JSR PC,SPUSHT
	MOV AA,@S
	.ENDM

	.MACR POPS AA
	MOV @S,AA
	JSR PC,SPOPT
	.ENDM

	.MACR SPUSH AA
	MOV AA,-(P)
	.ENDM

	.MACR SPOP AA
	MOV (P)+,AA
	.ENDM

	.MACR SPUSHS AA
	SUB #2,S
	MOV AA,@S
	.ENDM

	.MACR SPOPS AA
	MOV @S,AA
	ADD #2,S
	.ENDM

.MACR	TEXT AA
	.ASCII ÁA‰;DON'T TRY TO INCLUDE RUBOUTS IN TEXT
	.BYTE 0		;('CAUSE DELIMITERS ARE RUBOUTS)
	.EVEN
.ENDM

.MACR	.PRTXT AA
	JSR A,ERTAS
	AA
.ENDM

.MACR	PRTXT AA
	.PRTXT ^ÔEXT ^&AA&‰;RUBOUTS AROUND .PRTXT ARG
.ENDM

.MACR	CPRTXT	AA
	.PRTXT ^®BYTE	15
	TEXT ^&AA&‰;RUBOUTS!
.ENDM

.MACR	BPRTXT X
	.PRTXT ^®BYTE	7,7,15
	TEXT	^&X&‰;RUBOUTS!
.ENDM

.MACR	PRTXTC	AA
	.PRTXT ^®ASCII	&AA&
	.BYTE	15,0
	.EVEN‰	;RUBOUTS!
.ENDM

.MACR PAD A,B
	.PRINT &A B
&
.ENDM

.MACR PRCR
	JSR PC,.CRLF
.ENDM

.MACR SPACE
	JSR PC,.SPACE
.ENDM

.MACR SPREND
	JSR A,SPEND
.ENDM
LGNSYM==0
.MACRO LANGC EN,F
.IFNZ <ENG&FR>
	BIT #PFRFLG,LANG
	CONS BNE ,LS,\LGNSYM
.ENDC
.IF NZ ENG
EN
.ENDC
.IF NZ <FR&ENG>
CONS BR ,LS,\LGNSYM+1
CONS LS,\LGNSYM,::
.ENDC
.IF NZ FR
F
.ENDC
.IF NZ <FR&ENG>
CONS LS,\LGNSYM+1,::
LGNSYM==LGNSYM+2
.ENDC
.ENDM

.MACR REPT1 A,B
	.REPT A
	B
	.ENDR
.ENDM

.MACR REPT2 A,B,C
	.REPT A
	B
	C
	.ENDR
.ENDM

.MACR SDPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
.ENDC
.ENDM

.MACR SDPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
.ENDC
.ENDM

.MACR VERR
.IFLE .-.VERR-127.
	BVS	.VERR
.ENDC
.IFG .-.VERR-127.
	BVC	.+4
	.VERR==.
	ERROR+RTB
.ENDC
.ENDM

.MACR DPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPCLR HIGH,LOW
	CLR	HIGH
	CLR	LOW
.ENDM

.MACR DPINC HIGH,LOW
	DPADD ,#1,HIGH,LOW
.ENDM

.MACR DPDEC HIGH,LOW
	DPSUB ,#1,HIGH,LOW
.ENDM

.MACR DPNEG HIGH,LOW
	NEG LOW
	ADC HIGH
	NEG HIGH
.ENDM

.MACR NOP NUM
	.IFG NUM
	BR .+<NUM*2>
	NOP <NUM-1>
	.ENDC
.ENDM

.MACR EXCH LOC1,LOC2
	MOV	LOC1,EXCH1
	MOV	LOC2,LOC1
	MOV	EXCH1,LOC2
.ENDM
	.MACR NODE A,B
$.==$$+1
	A
	B
$$==$$+1
.ENDM

.MACR	ZED
	Z==0
.ENDM

.MACR	ZPLUS
	Z==Z+1
.ENDM

.MACR	ZEPT A,B
	ZED
	.REPT	A
	B
	ZPLUS
	.ENDR
.ENDM

.MACR	CONS	A,B,C
	A'B'C
.ENDM

.MACR CONC6 A,B,C,D,E,F
	A'B'C'D'E'F
.ENDM
.STITL	DEVICE CONFIGURATION

.IFNZ	AI		;AI DEVICES
	NDISP==1	;CHECK DLENGT IN SYS VARS IF THIS IS CHANGED
.IFF
	NDISP==0
.IFTF
	CLKFRQ==60.
.ENDC


SYPDLL==240
DSECLN==400
PPDLL==2000
SPDLL==2000
PDSLOP==300.	;MUST BE EVEN AFTER DIVISION BY 3
PDSWOP==2000
MAXARG==32.
DBUFL==2000


FRTRCF==1
SWTRCF==2
SPTRCF==4
GCTRCF==10

	;NODE TYPES
SFUN==000000
INFIX==10000
UFUN==20000
UVAR==30000
IDLE==40000
BUKTEL==60000	;NODE IN BUCKET OF OBLIST (INVALID TOKEN TYPE)
;THE FOLLOWING TYPES ARE NEEDED IN THIS ORDER BY THE CONVERT ROUTINES
SSTR==70000	;NOT VALID TOKEN TYPE
SNP==100000
ATOM==110000
SNUM==120000	;NOT A VALID TOKEN TYPE
LNUM==130000
INUM==LNUM	;INTEGER NUMBER
LSTR==140000
FNUM==150000
LIST==170000
SENT==LIST
;END OF ORDER

	;BINDING TYPES
FBIND==20000
VBIND==30000
;DON'T USE 40000, IT IS "IDLE" (UGH)
ABIND==50000
SVBIND==130000	;SWAPPED OUT  VARIABLE BINDING


	;SOE FLAGS SEE OLE MACRO STUFF
VNAF==2000

	;READ FLAGS SEE DTBL:
DOTF==400	;IN LEFT HALF
	;EVAL FLAGS - PUSHED BY PEVAL
PTLPF==1	;PREVIOUS TOKEN WAS LEFT PAREN
RTF==2	;REPEAT TOKEN
CRF==4	;CURRENT TOKEN IS CR
EDITF==10	;EDIT FLAG
DORF==20	;SET IF THIS FRAME IS A DO OR A READ
;	TOF==20	;TO FLAG
;	IFF==40	;IF FLAG
TSTFLG==100	;TEST FLAG FOR TEST, IFTRUE AND IFFALSE
SPDF==200	;SKIP PROC DEF. FLAG
TPTF==400	;THIS PROCEDURE TRACED FLAG	;MUST BE IN LEFT HALF
EDTIF==1000	;EDIT TITLE FLAG
BRKF==2000	;BREAK MODE FLAG
ERRF==4000	;ERROR FLAG
EDTIF2==10000	;BECOMES EDTIF ON LEAVING EVAL
TPSF==20000	;THIS PROCEDURE STEPPED FLAG	;MUST BE IN LEFT HALF
TPBF==40000	;THIS PROCEDURE BURIED FLAG	; "   "  "   "    "
EVIFS==PTLPF+RTF+CRF	;FLAGS CLEARED BY EVLINE

	;EVAL FLAGS2 - NOT PUSHED
CPTBF==1	;CHANGE % TO BLANK
TRACEF==2
PQF==4		;PRINT QUOTE FLAG - FOR PRSTR
DPQF==10	;DONT " " "
MMF==20	;MULTIPLE MAKE FLAG
SSF==40	;SPECIAL STATUS FLAG
PADERF==100	;PRINT ADDRESS OF ERROR
MGCF==200	;MANY G. C.'S FLAG
PNNLF==400	;PRINT NO. NODES LEFT
DSAMFL==1000	;DISK ALMOST FULL
PPNAIF==2000	;P PDL NOT ALL THE WAY IN
SPNAIF==4000	;S PDL NOT ALL THE WAY IN
HERRF==10000	;HARD ERROR
CHEKUF==20000	;TURNS ON VARIOUS USER CHECKING THINGS

	;TEMP FLAGS IN TFLAGS
TF6==1
RBRKF==2	;BREAK FLAG - FOR ROUTINE THAT CALLS RDSTR
TF7==4
TF1==100	
TF2==200
TF3==400
TF4==10000
TF5==20000

	;FLAGS IN LEFT HALF OF 1ST NODE OF SWAPPED PROC LIST
; TPTF==400	DEFINED ABOVE- SET BY "TRACE FOO" CLEARED BY "ERASE TRACE FOO"
; TPSF==20000	DEFINED ABOVE- SET BY "STEP FOO" CLEARED BY "ERASE STEP FOO"
; TPBF==40000	DEFINED ABOVE- SET BY "BURY FOO" CLEARED BY "ERASE BURY FOO"

NBN==40	;# BUFFER NODES - IF FREE NODES < THIS, == NO STG LEFT


	.IFNZ NDISP
;DISPLAY COMMANDS
ADDX==150000
ADDY==144000
ADDXY==ADDX!ADDY
DPUSHJ==100000
DPOP==140200
DPOPJ==140100
DSTOP==140400
DRSTXY==143000	;RESET X AND Y TO 0
DINC==40000

TURSIZ==6	;THE SIZE OF THE TURTLE

TKRUN==4000
TKGO==10000
TKSTOP==20000
.ENDC


;FLAGS USED FOR DFLAGS
PENUF==1	;PEN UP
HIDETF==4	;TURTLE NOT SHOWN
TURTF==10
TEMF==20
DISPF==40	;DISPLAY IN USE
WRAPF==100	;WRAP AROUND MODE
PLOTF==200	;PLOTTER IN USE
TVF==400	;THIS IS A TV DISPLAY

.=400
LVERNF:	VERNF
PAT:
PATCH:	.=.+400	;PATCH AREA
PATEND=.
	.STITL USER VARIABLES
SSTATS::	;THE SITS STATUS AREA
SVERN:	0	;SITS VERSION
TIME:	.BLKW 2	;TIME SINCE SYS START IN 60THS
SCSR:	0	;CONSLOE SWITCHS
LOOKSW:	0
RANDS:	.BLKW 20	;POTENTIALLY THERE ARE MORE
INPUTH:	0
SPMSWP:	0	;THE PLACE WE ARE MARKING IN GHT ESWAPPED OUT PDL
PDLEMR:	0	;PDL EMERGENCY FLAG
S:	IS
SPOPL:	IS
SPDLCP:	0
SPEMR:	0	;S PDL EMERGENCY FLAG
SPLIMT:	20000	;LIMIT ON S PDL
SCRBLK:	.FAWSB
	.ASCIZ /S/
PPOPL:	IP
PPDLCP:	0
PPEMR:	0	;P PDL EMERGENCY FLAG
PPLIMT:	40000	;LIMIT ON P PDL
PCRBLK:	.FAWSB
	.ASCIZ /P/
ERDISP:	0
ERRPT:	0
ERRPNT:	0
PRBAO:	0	; = 0,374,770, ... N*PDSWOP
SPRBAO:	0	;WHERE N = # P OR S PDL BLOCKS SWAPPED OUT
NNGC:	0	;NUMBER OF NODES GARBAGE COLLECTED
NNIFSL:	0	;NO. NODES IN FREE STORAGE LIST
.IIF NZ ENG&FR,LANG:	FRFLG!PFRFLG
FREE:	SOFN	;START OF FREE NODES
GCP1:	0
GCP2:	0
GCPREV:	0
	ERCLR1==.	;ON ERROR, START ZEROING HERE
OLFUN:	0	;USED FOR REDEFINING SYS. FUN
HTNODE:	0	;USED FOR REDEFINING SYS. FUN
TOPS:	0	;GC MARK FROM HERE IF NON 0
TOPS1:	0	;   "
TOPS2:	0	; "	(SIGH)
JPLN:	0	;PROCEDURE LINE # BEFORE LAST "GO"
	;THE FOLLOWING ARE PUSHED BY PEVAL
CPP:	0	;CURRENT PROCEDURE UOE POINTER
CPSN:	0
CPLN:	0	;CURRENT PROCEDURE LINE NO.
CLP:	0	;CURRENT LINE POINTER - GOOD IF CPSN'S AGREE
CLGN:	0	;CURRENT LINE GENERATION NO.
CTN:	0	;CURRENT TOKEN NO.
CTP:	0	;CURRENT TOKEN POINTER
IFLEV:	0	;IF LEVEL
NOPAR:	0	;NUMBER OF PARENS SEEN BY STNE
CPDLP:	0	;CURRENT PDL PTR AFTER LAST PEVAL PUSH
CSPDLP:	0	;CURRENT S PDL PTR AFTER LAST PEVAL PUSH
	;END OF PEVAL PUSHES EXCEPT
	;CO, CO+2, FLAGS + ERPROC ARE ALSO PUSHED
FUNLEV:	0	;FUNCTION LEVEL
	;THE FOLLOWING ARE PUSHED (SOMETIMES) BY EVAL
CO:	0	;CURRENT OPERATOR
	0
NOR:	0	;NO. OF OPERANDS STILL NEEDED BEFORE CO CAN BE EXECUTED
	;END OF EVAL PUSHES
COF:	0	;CURRENT OPERATOR FLAGS
LO:	0	;LAST OPERATOR
	0
CT:	0	;CURRENT TOKEN
	0	; "
RDFLAG:	0	;FOR READ
LISTBD:	0	;LIST BUILD DEPTH
PSTOPR:	0	;RETURN ADDR FOR PSTOP
ERFRET:	0	;RETURN ADDR WHEN AN ERROR SET FRAME IS ENCOUNTERED
DOFRET:	0
TEMP:	0
TMPBLK:	.BLKW 7
TFLAGS:	0	;TEMP FLAGS (ALL TFN'S SHOULD EVENTALLY POINT HERE)
NCHR:	0	;FOR BLST
ABASE:	0	;(ABASE)+10. IS WHAT ARITHMETIC BASE WE ARE IN
		;(FOR CONVERT TO & FROM STRING ROUTINES)
	ERCLR2==.	; ON ERROR STOP CLEARING HERE
DSKNCH:	0	;NUMBER OF CHARS LEFT IN DISK BUFFER
REDFLG:	0
WRTFLG:	0
FILFLG:	0
NAME:	.BLKW 10.
USERS:	ASCIZ ^/USERS/
	.EVEN
CURROT:	10	;CURRENT ROOT
DEFROT:	10	;DEFAULT ROOT
CURCAP:	0	;CURRENT FILE CAP
DEFCAP:	4	;DEFAULT DIRECTORY CAP
DISCAP:	0
CAPSP:	CAPSTK:
CAPSTK:	.BLKW 20.
FILBLK:	.BLKW 20	;PALCE TO PUT FILE BLOCK FOR .FARI
TMPCP:	0
;DISPATCH TABLE FOR POTREE (INDEXED OFF OF DISK ENTRY TYPES)
PODIRC:	0					;CURRENT DIRECTORY BEING POTREE'D

BUFFER:	.BLKW 20.
DBUFL==512.
DBUFCC:	0		;NUMBER OF CHARS IN BUFFER
FEOF:	.BLKW 2		;REMAINING CHARS IN FILE (ON READ)
DBUFP:	0
DBUF:	.BLKB DBUFL

FLAGS:	0	;FLAG WORD
ERPROC:	0	;UOE PTR TO PROC TO CALL IF THERE IS AN ERROR
ILINEL:	0	;INPUT LINE PTR GC MARK FROM HERE)
NPROCL:	0	;NAME OF PROC BEING EXECUTED WHEN ERROR OCCURED
NLINEL:	0	;# OF PROC LINE BEING EXECUTED " " "
NTOKEL:	0	;# OF TOKEN BEING EXECUTED " " "
ERRORN:	-1	;ERROR NUMBER
BRAKEL:	0	;VALUE OF BRAKE(U)
BRAKE:	0
TOPRNM:	0	;PTR TO UOE OF PROC. BEING "TO"'ED
FNLLP:	0	;FIRST NODE OF LIST OF LINE POINTERS (FOR "TO")
FLAGS2:	0	;EVAL FLAGS - NOT PUSHED BY PEVAL
PRMTCH:	'?	;PROMPT CHAR
GNCN:	0	;"GET NEXT CHAR" NODE AND USED BY GNOLE
	0
NBKTS:	0	;FOR RDSTR
LASTER:	0	;ADDRESS OF LAST ERROR
LASTPR:	0	;LAST PROC DEFINED
GCHR:	0	;SOURCE OF CHARS
PCHR:	0	;PLACE WHERE OUTPUT CHARS GO (TYO, BLST, ...)
OTTYST:	0
TTYST:	0
PTBF:	0
PTBTAB:	.BLKW 4
TYICP:	2
TYOCP:	3
TBCCHR:	.WORD 117,112,105,40	;CONTROL CHARACTERS FOR TBOX
CHI:	0
RNSEED:	27.	;FOR RANDOM
ALEVN:	0	;NON-ZERO MEANS ALLOW N LEVEL BREAK STUFF
ENDWLD:	0
NODTOP:	NODESP+2000
SEXP:	0	;USED FOR SIGN OF EXPONENT IN CONVERT
FNPDL:	0	;AUXILIARY STACK IN CONVERT
	0
	0
	0
	0
	0
	0
	0

;MUSIC BOX VARIABLES (ONE SET FOR EACH MUSIC BOX)
	MUSBEG==.	
		;KEEP VARIABLES IN THIS ORDER
MVOC:	.WORD	0,0,0,0	;POINTERS TO VOICE LISTS--ONE FOR EACH VOICE
VLAST:	.WORD	0,0,0,0	;POINTERS TO LAST NODE IN LIST
VOICLN:	.WORD	0,0,0,0	;NUMBER OF NOTES IN EACH VOICE
VOICEN:	0	;INDEX FOR CURRENT ACTIVE VOICE
NVOIC:	0	;NUMBER OF ACTIVE VOICES
	MUSEND==.
MUCWRD:	100	;CONTROL CHAR FOR CURRENT MUSIC BOX MODE
PLTCHR:	0	;CHAR COMING BACK FROM PLOTTER

;TURTLE VARIABLES
TURDN:	0	;USER'S TURTLE DEVICE NUMBER
TURF:	0	;FUDGE FACTOR FOR TURTLE LEFT AMD RIGHT

DFLAGS:	.WORD 0
DIVOWN:	.WORD 0
DPENP:	.WORD 0
PLPENP:	.WORD 0
;PLOTTER VARIABLES
;THESE MUST BE IN ORDER
PORBEG==.
PCURX:	.WORD 0,0	;CURRENT PLOTTER X POS
PCURY:	.WORD 0,0	;PLOTTER CURRENT Y
PCURA:	.WORD 0,0		;CURRENT ANGLE PLOTTER
PCOSA:	.WORD 0,0
PSINA:	.WORD 0,0
RPCURX:	.WORD 0,0,0,0
POREND==.

;VARIABLES AND CONSTANTS FOR DISPLAY SYSTEM

;THESE MUST BE IN THIS ORDER
DORBEG==.
DCURX:	.WORD 0,0
DCURY:	.WORD 0,0
DCURA:	.WORD 0,0
DCOSA:	.WORD 0,0
DSINA:	.WORD 0,0
RDCURX:	.WORD 0,0,0,0
OLDX:	.WORD 0,0
OLDY:	.WORD 0,0
 
NADXY:	0	;NUMBER OF EXTRA ADDXY'S WE CAN TRY TO COLLAPSE
ODIREC:	0	;IF NOT EQUAL TO DIREC BREAK INCREMENTS TO NEW OWRD

DOREND==.	;MARKS END OF THESE VARIABLES
;END OF ORDER

STB:	0	;STATIC AREA BOTTOM
STT:	0	;STATIC AREA TOP.POINTS TO TOP OF STATIC DISPLAY AREA
DYB:	0	;DYNAMIC BOTTOM.  POINTS TO BOT OF DY AREA
DYR:	0	;ROVING POINTER USED BY DISPLAY STORAGE ALLOCATIN ROUTINES
DYT:	0	;POINTER TO DYNAMIC AREA TOP
TUB:	0	;POINTER TO TURTLE AREA BOTTOM
SNLIST:	0	;POINTER TO SNAP LIST
SNABOT:	0	;BOTTOM OF CURRENT SNAP
DFBCNT:	0	;KEEPS TRACK OF # OF FREE BITS IN DISPLAY LIST
PUSHJT:	0	;DISPLAY PUSHJ TO TURTLE
DRELOC:	0	;RELOCATION.  ADD THIS TO VIRTUAL ADDRESS TO GET DISPLAY ADDRESS
DIREC:	0

.IFNZ TVS
;VARIABLES FOR TV TURTLE ROUTINES
DRAWMD:	.TVDSI	;PEN MODE, CAN BE XOR IOR OR NULL
TVX:	288.
TVY:	152.	;POSITION OF THE TV DRAWER
TVTOP:	2.	;TOP LINE OF THE DISPLAY AREA
TVBOT:	302.	;BOTTOM LINE OF THE DISPLAY AREA
TVLEFT:	138.	;BIT POSITION OF LEFT SIDE OF DISPLAY AREA
TVRIGH:	438.	;BIT POSITION OF RIGHT SIDE OF DISPLAY AREA
TVSIZX:	301.	;SIZE OF DISPLAY AREA IN X DIRECTION
TVSIZY:	301.	;SIZE OF DISPLAY AREA IN Y DIRECTION
TVCENX:	288.	;BIT POSITION OF CENTER OF DISPLAY AREA
TVCENY:	152.	;LINE OF THE CENTER OF DISPLAY AREA
TVMIN:	301.	;MINIMUM DIMENSION OF DISPLAY AREA
TVSIZE: 0	;NUMBER OF LINES IN DISPLAY AREA (DOWN TO ECHO AREA)
TVHIGH:	0	;HEIGHT OF A CHAR LINE IN TV LINES
TVWIDE:	0	;WIDTH OF A CHAR IN BITS

;THE NEXT SET OF VARIABLES REFER TO THE TURTLE PICTURE. IE, THE SCREEN
;AS MEASURED IN TURTLE COORDINATES.
TRMIN:	400.	;MINIMUM DIMENSION OF DISPLAY AREA
TRCENX:	0	;CENTER OF TURTLE SCREEN IN X
TRCENY:	0	;CENTER OF TURTLE SCREEN IN Y

;FLOATING POINT VARIABLES
TRPRTV:	.WORD 0,0	;NUMBER OF TURTLE INCREMENTS PER TV INCREMENT
TRFRAD:	.WORD 0,0	;SIZE OF THE TURTLE FRONT RADIUS
TRSRAD:	.WORD 0,0	;SIZE OF THE TURTLE SIDE RADIUS
TRSIZX:	.WORD 0,0	;SIZE OF TURTLE SCREEN IN X
TRSIZY:	.WORD 0,0	;SIZE OF TURTLE SCREEN IN Y
TRLEFT:	.WORD 0,0	;TURTLE VALUE OF LEFT BORDER
TRBOT:	.WORD 0,0	;TURTLE VALUE OF BOTTOM BORDER

;FLOATING POINT CONSTANTS
FLTTOL:	.WORD 35603,11156	;FLOATING POINT TOLERANCE 0.001
SIN120:	.WORD 40135,131730	;SIN 120 OR 0.86602544
COS120:	.WORD 140000,0		;COS 120 OR -0.5
SIN240:	.WORD 140135,131731	;SIN 240 OR -0.86602544
COS240:	.WORD 140000,0		;COS 240 OR -0.5
FPC0.1:	.WORD 37314,146314	;FLOATING CONSTANT 0.1

;TEMPORARY LOCATION USED BY FACSAV
FACTMP:	.WORD 0,0
.ENDC

	.=.+PPDLL+PDSLOP
	IP=.
.=.+4
SSWPAD==IS-PDSWOP
	.=.+SPDLL+PDSLOP
	IS=.
.=.+4
PSWPAD==IP-PDSWOP
PPUSHL=IP-<PPDLL+<2*PDSLOP/3>>
POPLM=IP-<PDSLOP/3>
SPUSHL=IS-<SPDLL+<2*PDSLOP/3>>
SPOPLM=IS-<PDSLOP/3>
HCC==67.	;HASH CODE CONSTANT - A PRIME
UHCT:	.=UHCT+<2*HCC>
	-1
GCBITS:	.BLKW 400
	.=.+40	;FOR THE BREAK PROCESS
BRKPDL:

DEBSW:	01	;DEBUG SWITCH, NON-ZERO IF BEING DEBUGGED
NOADDR:	1	;ZERO MEANS PRINT ADDRESS OF ERRORS
ASIZE:	0	;SIZE OF ARRAY SPACE (SHOULD BE ZERO)


	FOR NDISP
;DISPLAY SYSTEM VARIABLES
DPDLL==60	;LENGTH OF EACH DISPLAY PDL (IN BYTES)
TLEN==20	;LENGTH OF EACH TURTLE LIST (IN BYTES)
TLIST==DISAD
DLIST==TLIST+TLEN
	.ENDC
	ENDC NDISP
TUT:	0	;TURTLE TOP.  POINTS TO TOP OF TURTLE DISPLAY LIST
SNPTEM:	0	;USED BY GARBAGE COLLECTOR


	CONSO==20
	PLOTT==40
	PMBOX==100
	INITF==1000	;MUSIC BOX INITIALIZED
	TURT==200
	TBMASK==177417

TEM0:	0
TEM1:	0
ANSWER:	.WORD	0,0	;USED BY DOUBLE PRECISION ROUTINES
SHFCNT:	0		;USED BY DOUBLE PRECISION ROUTINES
EXCH1:	0

INITED:	0	;IF NON-ZERO INIT CODE HAS BEEN RUN
ZERO:	0
AFREE:	0	;POINTER TO ARAY SPACE FREE LIST
AROVER:	0	;BOW-WOW
ASPACE:	0	;AMOUNT OF ARAY SPACE STILL FREE
ARTOP:	ARYAD
;KEEP THE NEXT 3 IN ORDER!!!!
ARRHPG:	ARYPG-1	;HIGHEST PAGE GOBBLED SO FAR
ARRHPL:	7		;LENGTH OF HIGHEST PAGE
ARRHP:	ARYHPG	;HIGEST PAGE TO EVER GOBBLE

;KEEP NEXT 3 IN ORDER!!!
NODEHP:	NODPG	;HIGEST NODE PAGE SO FAR
	0	;LENGTH THEREOF
	NODPG+1	;HIGHEST PAGE TO GRAB
SYSHTL==16.		;IF YOU CHANGE THIS YOU ALSO HAVE TO CHANGE THE MASKS IN THE CODE
SYSHTB:	.BLKW SYSHTL	;TABLE FOR REDEFINED SYS. FUN.
REDFYN:	0
OLDFLG:	0
;END OF VARIABLES
.IIF GT .-PURAD,.ERROR OOOOPS! TOO MUCH IMPURE STUFF
LSUPBL==._-10.
.=PURAD
;START OF PURE CONSTANTS
INODESP:	0	;NODE 0
N==NODESP
	0
	$$==1
.IFNZ ENG
TRUE=LSTR+$$
	NODE SSTR+$.,"TR
	NODE SSTR,"UE
FALSE=LSTR+$$
	NODE SSTR+$.,"FA
	NODE SSTR+$.,"LS
	NODE SSTR,'E
.ENDC
.IFNZ FR
	VRAI=LSTR+$$
	NODE SSTR+$.,"VR
	NODE SSTR,"AI
	FAUX=LSTR+$$
	NODE SSTR+$.,"FA
	NODE SSTR,"UX
.ENDC
.IFNZ ENG
$TOTO=LSTR+$$
	NODE SSTR,"TO
.ENDC
.IFNZ FR
$POURX=LSTR+$$
	NODE SSTR+$.,"PO
	NODE SSTR,"UR
.ENDC

	LUNN=$$-1
	NNN=$$	;NEXT NODE NO.
SOFN=NNN	;START OF FREE NODES
ASOFN=.



PODIRT:	PODIRP					;PARENT
	PODIRD					;DIRECTORY
	PODIRF					;FILE
	PODIRF					;LAST FILE
	PODIRS					;SELF
	PODIRL					;LINK
	PODIRL					;NOT IMPLEMENTED
	PODIRL					;NOT IMPLEMENTED
PI:	40511
	7732
	121041
	64303

ATANC0:	40177		;CONSTANTS FOR ARCTAN (IN TURTLE)
	177202
	76161
	112632
ATANC1:	137652
	46637
	115420
	63453
ATANC2:	37506
	30101
	136067
	177440
ATANC3:	137356
	71757
	163330
	35701
ATANC4:	37127
	125401
	173320
	15574
ATANC5:	136500
	5106
	125337
	36073
;PI / 4
PIFOUR:	40111
	7732
	121041
	64303

	.MACRO BEGER X,EN,F
X'.E::
FOO==.
	.ASCII /X/
	.=FOO+4
	BARF==0
	.IRPC Q,X
	BARF==<<''Q-'A+1>&17>+<BARF*20>
	.ENDM
	BARF
	.IFNZ ENG
	EN
	.ENDC
	.IIF NZ ENG&FR,.BYTE 0
	.IFNZ FR
	F
	.ENDC
	.BYTE 0
	.EVEN
	.ENDM

	.MACRO EROT A
	.BYTE A'.N
	.ENDM


	.MACRO ETEXT AA
	.ASCII \AA\
	.ENDM
ERRSRT:

MAXELN==0

BEGER BADD,<
ETEXT ^/BAD DIRECTORY./>,<
ETEXT ^/MAUVAIS UTILISATEUR/>

BEGER BADE,<
ETEXT ^/BAD ENTRY./>,<
ETEXT ^/MAUVAISE ENTREE/>

BEGER BAT,<
ETEXT ^/BAD ARRAY TYPE./>,<
ETEXT ^/MAUVAIS TYPE DE VECTEUR/>

BEGER BDD,<
ETEXT ^/BAD DISK./>,<
ETEXT ^/MAUVAIS DISQUE/>

BEGER BRK,<
EROT BRK>,<
EROT BRK>

BEGER BUG,<
EROT BUG>,<
EROT BUG>

BEGER CDE,<
ETEXT ^/CAN'T DELETE ENTRY./>,<
ETEXT ^/JE NE PEUX DETRUIRE CETTE ENTREE/>

BEGER CDF,<
ETEXT ^/CAN NOT DELETE THAT FILE./>,<
ETEXT ^/NE PEUX DETRUIRE CE FICHIER/>

BEGER COP,<
ETEXT ^/CHAR /
EROT TYO
ETEXT ^/ OUT OF PLACE./>,<
ETEXT ^/CAR /
EROT TYO
ETEXT ^/ HORS POSITION/>

BEGER CRE,<
ETEXT ^/CAN'T READ THAT ENTRY./>,<
ETEXT ^/NE PEUX RAMENER CETTE ENTREE/>

BEGER CTIT,<
ETEXT ^/YOU ARE ALREADY DEFINING /
EROT CTIT>,<
ETEXT ^/VOUS ETES ENTRAIN DE DEFINIR /
EROT CTIT>

BEGER DFU,<
ETEXT ^/DISC FULL./>,<
ETEXT ^/LE DISQUE EST REMPLI/>

BEGER DIU,<
ETEXT ^/DEVICE IN USE./>,<
ETEXT ^/L'APPAREIL N'EST PAS DISPONIBLE/>

BEGER DNA,<
EROT PRS1
ETEXT ^/ IS NOT A DEVICE NAME./>,<
EROT PRS1
ETEXT ^/ N'EST PAS UN APPAREIL./>

BEGER DNR,<
ETEXT ^/DEVICE NOT READY./>,<
ETEXT ^/L'APPAREIL N'EST PAS PRET/>

BEGER DOR,<
ETEXT ^/DURATION OUT OF RANGE/>,<
ETEXT ^/DUREE TROP LONGUE/>

BEGER DRF,<
ETEXT ^/DIRECTORY FULL./>,<
ETEXT ^/PLUS DE PLACE/>

BEGER EAES,<
ETEXT ^/ENTRY ALREADY EXISTS./>,<
ETEXT ^/ENTREE DEJA EXISTANTE/>

BEGER ELW,<
EROT PRCT
ETEXT ^/ - EDIT LINE WHAT?/>,<
ETEXT ^/ EDITE QUELLE LIGNE??/>

BEGER ENDR,<
ETEXT ^/ENTRY NOT A DIRECTORY./>,<
ETEXT ^/CETTE ENTREE N'EST PAS CELLE D'UN UTILISATEUR/>

BEGER ERP,<
ETEXT ^/UNEXPECTED RIGHT PARENTHESIS./>,<
ETEXT ^/PARENTHESE DROITE SUPERFLUE/>

BEGER ERW,<
ETEXT ^/CAN'T ERASE "/
EROT PRCT>,<
EROT PRCT
ETEXT ^/ - EFFACE QUOI?/>

BEGER FAE,<
ETEXT ^/FILE ALREADY EXISTS./>,<
ETEXT ^/FICHIER DEJA EXISTANT/>

BEGER FAO,<
ETEXT ^/FILE ALREADY OPEN./>,<
ETEXT ^/FICHIER DEJA OUVERT/>

BEGER FBUG,<
ETEXT ^/FATAL SYSTEM BUG./
EROT GDBY>,<
ETEXT ^/BUG FATAL AU SYSTEME/
EROT GDBY>

BEGER FNF,<
ETEXT ^/FILE NOT FOUND./>,<
ETEXT ^/N'AI PAS TROUVE CE FICHIER/>

BEGER HARD,<
ETEXT ^/HARDWARE ERROR/>,<
ETEXT ^/ERREUR DE MACHINERIE/>

BEGER HNM,<
ETEXT ^/YOU HAVEN'T DEFINED /
EROT HNM>,<
EROT HNM
ETEXT ^/ N'EXISTE PAS./>

BEGER HNM1,<
ETEXT ^/YOU HAVEN'T DEFINED /
EROT PRCT>,<
EROT PRCT
ETEXT ^/ N'EXISTE PAS./>

BEGER HNV,<
EROT PNAB
ETEXT ^/ HAS NO VALUE./>,<
EROT PNAB
ETEXT ^/ N'A PAS RECU DE VALEUR/>

BEGER IDN,<
ETEXT ^/IMPROPER DISPLAY NUMBER (UGH!)/>,<
ETEXT ^/CET ECRAN N'EXISTE PAS/>

BEGER IFN,<
EROT PRCO
ETEXT ^/ IS INVALID FILE NAME./>,<
EROT PRCO
ETEXT ^/ NE PEUT SERVIR COMME NOM DE FICHIER/>

BEGER INF1,<
EROT PRCO
ETEXT ^/ IS IN THE WRONG PLACE./>,<
EROT PRCO
ETEXT ^/ EST A LA MAUVAISE PLACE/>

BEGER INVN,<
ETEXT ^/INVALID NODE./>,<
ETEXT ^/NODE INVALIDE/>

BEGER ITN,<
ETEXT ^/A NONEXISTANT TURTLE?/>,<
ETEXT ^/NUMERO DE TORTUE INEXISTANT/>

BEGER IUN,<
ETEXT ^/INVALID USER./>,<
ETEXT ^/ON NE PEUT UTILISER CE NOM/>

BEGER IVV,<
ETEXT ^/INVALID VOICE NUMBER/>,<
ETEXT ^/NUMERO DE PISTE INEXISTANT/>

BEGER LCE,<
ETEXT ^/LINE ... CHANGED BY EDIT./>,<
ETEXT ^/LIGNE ... A ETE CHANGEE PAR EDITE/>

BEGER LDE,<
ETEXT ^/LINE /
EROT LDE1
ETEXT ^/ DOESN'T EXIST./>,<
ETEXT ^/LIGNE /
EROT LDE1
ETEXT ^/ INEXISTANTE/>

BEGER LNTB,<
ETEXT ^/LINE NUMBER TOO BIG./>,<
ETEXT ^/NUMERO DE LIGNE TROP GRAND/>

BEGER LNTS,<
ETEXT ^/LINE NUMBER TOO SMALL./>,<
ETEXT ^/NUMERO DE LIGNE TROP PETIT/>

BEGER NAS,<
ETEXT ^/NOT ENOUGH ARRAY SPACE./>,<
ETEXT ^/PAS ASSEZ D'ESPACE POUR LA MATRICE/>

BEGER NDU,<
ETEXT ^/YOU DON'T HAVE A DISPLAY CONSOLE/>,<
ETEXT ^/CE TERMINAL NE PEUT AVOIR UN ECRAN/>

BEGER NDV,<
ETEXT ^/NO DISPLAY AVAILABLE./>,<
ETEXT ^/PLUS D'ECRANS DISPONIBLES/>

BEGER NEC,<
EROT PRCT
ETEXT ^/ CAN'T BE EDITED./>,<
EROT PRCT
ETEXT ^/ N'EST PAS UN COMMANDEMENT D'EDITION/>

BEGER NED,<
ETEXT ^/DIRECTORY NOT FOUND./>,<
ETEXT ^/N'AI PAS TROUVE CET UTILISATEUR/>

BEGER NFO,<
ETEXT ^/NO FILE OPEN!/>,<
ETEXT ^/FICHIER N'EST PAS OUVERT!/>

BEGER NIP,<
ETEXT ^/NOTHING INSIDE PARENTHESES./>,<
ETEXT ^/LES PARENTHESES SONT VIDES/>

BEGER NOG,<
ETEXT ^/NOTE OUT OF RANGE/>,<
ETEXT ^/NOTE HORS LIMITE/>

BEGER NOU,<
EROT PRLO
ETEXT ^/ DIDN'T OUTPUT!/>,<
EROT PRLO
ETEXT ^/ N'A PAS PRODUIT D'OUTPUT/>

BEGER NSL,<
ETEXT ^/NO STORAGE LEFT./>,<
ETEXT ^/PLUS D'ESPACE DISPONIBLE/>

BEGER NTB,<
ETEXT ^/THORTON BOX SLOTS NOT AVAILABLE/>,<
ETEXT ^/IL N'Y A PAS DE TBOX/>

BEGER NTF,<
EROT PRS1
ETEXT ^/ NOT "TRUE OR "FALSE ./>,<
ETEXT ^/NI "VRAI NI "FAUX/>

BEGER NTVS,<
ETEXT ^/TVS CANNOT DO THIS FUNCTION/>,<
ETEXT ^/NOT ON TVS YOU DUMMY!/>

BEGER OIP,<
ETEXT ^/ ONLY WHEN DEFINING OR EDITING A PROCEDURE./>,<
ETEXT ^/ POSSIBLE SEULEMENT A L'INTERIEUR D'UNE PROCEDURE/>

BEGER OOB,<
ETEXT ^/OUT OF BOUNDS/>,<
ETEXT ^/HORS LIMITE/>

BEGER OOP,<
EROT PRCO
ETEXT ^/ OUT OF PLACE./>,<
EROT PRCO
ETEXT ^/ HORS POSITION/>

BEGER OOT,<
ETEXT ^/OUT OF TOKENS./>,<
ETEXT ^/JE SUIS VIDEE/>

BEGER PAE,<
EROT PAE
ETEXT ^/PROCEDURE /
EROT PRAB
ETEXT ^/ ALREADY EXISTS./>,<
ETEXT ^/PROCEDURE /
EROT PRAB
ETEXT ^/ DEJA EXISTANTE/>

BEGER PBE,<
EROT CTIT
ETEXT ^/ IS BEING EDITED./>,<
EROT CTIT
ETEXT ^/ EST SOUS EDITION/>

BEGER PNH,<
ETEXT ^/PROCEDURE /
EROT PRCT
ETEXT ^/ NOT HERE./>,<
ETEXT ^/LA PROCEDURE /
EROT PRCT
ETEXT ^/ N'EST PAS ICI/>

BEGER PNH1,<
EROT PNH1
ETEXT ^/PROCEDURE /
EROT PRAB
ETEXT ^/ NOT HERE./>,<
ETEXT ^/LA PROCEDURE/
EROT PRAB
ETEXT ^/ N'EST PAS ICI/>

BEGER ROB,<
ETEXT ^/INDEX REFERENCE OUT OF BOUNDS./>,<
ETEXT ^/INDEX DE REFERENCE HORS LIMITE/>

BEGER RTB,<
ETEXT ^/ARITHMETIC RESULT TOO BIG./>,<
ETEXT ^/NOMBRE TROP GRAND/>

BEGER SHW,<
ETEXT ^/CAN'T PRINTOUT "/
EROT PRCT>,<
EROT PRCT
ETEXT ^/ IMPRIME QUOI?/>

BEGER STD,<
ETEXT ^/TOO MANY SNAPS./>,<
ETEXT ^/TROP DE PHOTOS/>

BEGER TDE,<
ETEXT ^/TTY /
EROT TDE
ETEXT ^/ DOESN'T EXIST./>,<
ETEXT ^/TERMINAL /
EROT TDE
ETEXT ^/ NON EXISTANT/>

BEGER TGDZ,<
ETEXT ^/INPUT TO RIGHT OR LEFT TOO LARGE/>,<
ETEXT ^/INPUT TROP GRAND/>

BEGER TIP,<
ETEXT ^/TOO MUCH INSIDE PARENTHESES./>,<
ETEXT ^/TROP DE PARENTHTHESES INTERIEURES/>

BEGER TMAC,<
ETEXT ^/"/
EROT PRCO
ETEXT ^/" CAN'T TAKE MORE THAN 32 ARGS./>,<
EROT PRCO
ETEXT ^/ NE PEUT RECEVOIR PLUS DE 32 INPUTS/>

BEGER TMAP,<
ETEXT ^/TOO MANY ARGS!!!/
EROT TMAP>,<
ETEXT ^/TROP D'INPUTS!!!/
EROT TMAP>

BEGER TML,<
ETEXT ^/TOO MANY LINES/>,<
ETEXT ^/TROP DE LIGNES/>

BEGER TNR,<
ETEXT ^/HELP! TURTLE NOT RESPONDING./>,<
ETEXT ^/AU SECOURS! LA TORTUE NE REPOND PAS/>

BEGER UBL,<
EROT PRCT
ETEXT ^/ IS USED BY LOGO./>,<
EROT PRCT
ETEXT ^/ EST UTILISE PAR LOGO/>

BEGER UDA,<
ETEXT ^/YOU HAVE NOT DEFINED ARRAY "/
EROT PRCT>,<
ETEXT ^/MATRICE NON DEFINIE/>

BEGER UEL,<
ETEXT ^/UNEXPECTED END OF LINE./>,<
ETEXT ^/ENONCE INCOMPLET/>

BEGER UELX,<
EROT PRCO
ETEXT ^/ NEEDS MORE INPUTS./>,<
EROT PRCO
ETEXT ^/ A BESOIN DE PLUS D'INPUT(S)/>

BEGER VTD,<
EROT PRCO
ETEXT ^/ NEEDS A TURTLE OR A DISPLAY/>,<
EROT PRCO
ETEXT ^/ AVEZ-VOUS DEMANDE UNE TORTUE OU UN ECRAN/>

BEGER VTU,<
EROT PRCO
ETEXT ^/ NEEDS A TURTLE/>,<
EROT PRCO
ETEXT ^/ AVEZ-VOUS DEMANDE UNE TORTUE/>

BEGER WDIM,<
ETEXT ^/BAD DIMENSION(S)./>,<
ETEXT ^/MAUVAISES DIMENSIONS/>

BEGER WDW,<
ETEXT ^/YOU DON'T SAY WHAT TO DO WITH /
EROT PRS1>,<
ETEXT ^/QUE DOIS-JE FAIRE AVEC /
EROT PRS1>

BEGER WIT,<
EROT PRCT
ETEXT ^/ CAN'T BE AN INPUT./>,<
EROT PRCT
ETEXT ^/ NE PEUT SERVIR D'INPUT/>

BEGER WNA,<
ETEXT ^/WRONG NUMBER OF ARGUMENTS TO /
EROT PRCO>,<
ETEXT ^/NOMBRE INCORRECT D'INPUTS POUR /
EROT PRCO>

BEGER WTA,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT PRS1
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT PRS1
ETEXT ^/ COMME INPUT./>

BEGER WTAA,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT WTAA
EROT PRS1
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT WTAA
EROT PRS1
ETEXT ^/ COMME INPUT./>

BEGER WTAB,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT WTAB
EROT PRS1
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT WTAB
EROT PRS1
ETEXT ^/ COMME INPUT./>

BEGER WTIB,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT WTIB
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT WTIB
ETEXT ^/ COMME INPUT./>

.STITL SYSTEM OBLIST

VARIABLE==4	;FOR VARIABLE NUMBER OF ARGUMENTS
YINFIX==20	;"YES INFIX" FLAG FOR OLE

;SOE FIELDS		1.==RIGHT BYTE (EVEN ADDR) 2.==LEFT BYTE
	;		1.1==RIGHT BIT  2.8==LEFT BIT
ABRFLG==1
FRFLG==2
ENGFLG==4
PFRFLG==10
	;1.4-1.8 UNUSED
	;2.1-2.2 "STANDARD" NO. OF INPUT ARGS
	;2.3 VNAF 1==CAN TAKE "ANY" NO. OF ARGS
	;2.5 INFIX 1==THIS IS AN INFIX PROCEDURE
	;2.6-2.8 PRECEDENCE

	.MACR NGPTWO A
	NGP2=NGP2*2
	FOO==A
	.IFLE NGP2-FOO
	NGPTWO A
	.ENDC
	.ENDM

;****************************************************
;MACRO TO DEFINE SYSTEM OBLIST ELEMENTS
;THE PARAMETERS ARE:
;1)	THE PRINT NAME
;2)	PRINT NAME OF ABBREVIATION
;3)	THE NAME OF THE POINTER TO THE OBLIST ELEMENT.
;4)	THE ADDRESS OF THE PROGRAM
;5)	THE PRECEDENCE.  A NUMBER FROM 0-7
;6)	THE NUMBER OF ARGUMENTS, AND THE SYMBOL "VARIABLE"
;		IF IT CAN ALSO TAKE A VARIABLE NUMBER OF ARGUMENTS
;7)	THE SYMBOL "YINFIX" IF THIS IS AN INFIX OPERATOR
	;8)	IF 0, DONT ASSEMBLE THIS PRIMITIVE



;VERSION FOR OBLIST ELEMENTS THAT ARE BOTH FRENCH AND ENGLISH
.MACR OLB PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG!FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG!FRFLG
.ENDC
.ENDC
.ENDM
;VERSION FOR ENGLISH ONLY
.MACR OLE PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.ENDC
.ENDM
;VERSION FOR FRENCH ONLY
.MACR OLF PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
.MACR CDM A
A==<.-SOBLSU>/2
.ENDM

.MACR ABRV PN,OB,FLGS
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
OBLSTL==OBLSTL+4+OBL
.ENDC
.IF2
OBADD2-SOBLST
OBADD1=.
.=OBADD2
ABRFLG!FLGS
OB
TEXT ^\PN\
OBADD2=.
.=OBADD1
.ENDC
.ENDM
.MACR OLT PN,ABR,FPN,FAB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@FPN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@FPN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB FAB
ABRV FAB,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
;THE SYSTEM OBLIST
	;ADD ITEMS (EXCEPT FOR SPECIAL CHAR ITEMS) ALPHABETICALLY.

	.IF1
	NUMOBS==0
	.=.+4	;RESERVE SPACE FOR THE TWO WORDS ON PASS TWO
	.ENDC
	.IF2
SOBLSU=SOBLST+<NUMNSCOBS*2>-2
SOOMX=.
	2+SOBLSU	;2 > THAN HIGHEST ADDR USED IN SYS OBLIST
	NGP2==1
	NGPTWO SOBLSU-SOBLST+2
SOBP2=.
	NGP2	;( SMALLEST POWER OF 2 >= NUMOBS )*2
OBADD1=.
OBADD2=.+<2*NUMOBS>
OBSTRT=OBADD2	;WHERE THE SYSTEM OBLIST ELEMENTS START
	.ENDC

		;PRIORITIES
	PARPRI==1	; (  )
	BAKPRI==2	; _ __ IF TEST NOT BOTH EITHER
	RELPRI==3	; < = >
	PREPRI==4	;PRIORITY FOR MOST PREFIX PRIMITIVES
	PMPRI==5	; + -
	MDPRI==6	; * / \
	HIPRI==7	; : ! # -- ++
SOBLST:	OLB 0
	OLB .CASESW,,CASESW,CASESW,,1
	OLB .CGCF,,CGCF,CGCF
	OLB .CLOSE,,CLOSE,CLOSE,,1
	OLB .CLOSEF,,,.CLOSF
	OLB .CPNF,,CPNF,CPNF
	OLB .CTF,,CTF,CLRSTF
	OLB .CTYI,,CTYI,CTYI
	OLB .CTYO,,CTYO,CTYO,,1
	OLB .ECHOSW,,ECHOSW,ECHOSW,,1
	OLB .ERPOP
	OLB .FILEO
	OLB .FILEP,,,,,1
	OLB .FILER
	OLB .GCOLL
	OLB .NODES,,NODES,NODES
	OLB .OPENA,,,,,1
	OLB .OPENR,,,,,1
	OLB .OPENW,,,,,1
	OLB .RUG,,RUG,RUNRUG
	OLB .SGCF,,SGCF,SGCF
	OLB .SPNF,,SPNF,SPNF
	OLB .STATUS,,,STATUS
	OLB .STF,,,SETSTF
	OLB .TYI,,TYI,UGTYI,,1
	OLB .TYO,,TYO,UGTYO,,2
	OLB .VERSION,,VERSION,VERSN
	OLE ALL,,,NOTPRO
	OLT ALSO,,AUSSI,,,,,,DDF
	OLB ANGLAIS,,,,,,,<ENG&FR>
	OLF ARBRE,,,NOTPRO
	OLB ARCTAN,ATAN,,ATAN,,1,,FPPF
	OLE ARRAY,,,NOTPRO
	OLE ARRAYS,,ARAYS,NOTPRO
	OLT ASIZE,,DIMMAT,,ASIZEX,,1
	OLB ATOD,,,,,1,,AI
	OLT BACK,BK,RECULE,RE,,,1
	OLT BELL,,DING
	OLB BITOUT,,,,,1,,AI
	OLT BOTH,,LESDEUX,,,BAKPRI,2
	OLB BOXIN,,,,,1,,AI
	OLT BTOUCH,,TOUCHEAR
	OLE BURY
	OLT BUTFIRST,BF,SAUFPREMIER,SP,,,1
	OLT BUTLAST,BL,SAUFDERNIER,SD,,,1
	OLB CHAR,,,,,1
	OLT CLEARSCREEN,CS,VIDEECRAN,VE,,,,,NDISP
	OLT CLOCK,,SECONDES
	OLB CNTRL,,,,,,,DDF
	OLT CONTENTS,,CONTENU
	OLB CONTINUE,CO
	OLB COS,,,COSF,,1,,FPPF
	OLT COUNT,,COMPTE,,,,1
	OLB CRINDEX,,,.CRIND,,1
	OLB CTYOWAIT,,,,,1
	OLB DATE,,,UDATEG
	OLB DEBUG,,,DEBUGL
	OLT DEFINEARRAY,DEFAR,DEFMATRICE,DEFMAT,DEFAR,,3+VARIABLE
	OLT DELETE,ERF,DETRUIS,,.DELET,,1
	OLT DELETEINDEX,ERI,DETRUISINDEX,,.DELI,,1
	OLB DIFFERENCE,,,DIFF,,2
	OLE DISPLAY,,,,,1,,NDISP
	OLB ED,,,EDIT
	OLT EDIT,,EDITE
	OLB EDL,,,EDLINE
	OLB EDT,,,EDTITL
	OLT EITHER,,UNDE,,,BAKPRI,2
	OLE ELSE
	OLT EMPTYP,,VIDE,,EMPTYP,,1
	OLT END,,FIN
	OLF ENFOUIS,,,BURY
	OLB ENGLISH,,,,,,,<ENG&FR>
	OLT EQUAL,IS,EGAL,,EQUAL,,2
	OLT ERASE,ER,EFFACE,EF
	OLB ERBRK,,ERRBREAK,ERRBREAK
	OLB ERCLR,,ERRCLEAR,ERRCLEAR
	OLT ERL,,EFL
	OLB ERLIN,,ERRLINE,ERRLINE
	OLB ERLOC,,ERRLOCATION,ERRLOCATION
	OLB ERNAM,,,ERRNAM
	OLB ERNUM,,ERRNUMBER,ERRNUMBER
	OLB ERPRO,,ERRPROCEDURE,ERRPROCEDURE
	OLB ERRET,,RETURN,RETURN,,1
	OLB ERSET,,ERRSET,ERRSET
	OLB ERTOK,,ERRTOKEN,ERRTOKEN
	OLF EXECUTE,,,DO,,1
	OLE EYETURTLE,,,EYE,,1
	OLF FICHIER,,,NOTPRO
	OLE FILE,,,NOTPRO
	OLT FIRST,F,PREMIER,PREM,,,1
	OLT FORWARD,FD,AVANCE,AV,,,1
	OLT FPRINT,,ECRISC,,,,1+VARIABLE
	OLT FPUT,,INCLUSD,,,,2+VARIABLE
	OLB FRANCAIS,,,,,,,<ENG&FR>
	OLB FRANGLAIS,,,,,,,<ENG&FR>
	OLB FRENCH,,,,,,,<ENG&FR>
	OLT FTOUCH,,TOUCHEAV
	OLT GET,,SORT,,,,2+VARIABLE
	OLT GO,,VA,,,,1
	OLT GOODBYE,,SALUT
	OLT GREATER,,PLUSGRAND,,GREATR,,2
	OLB HALHACK,,,,,1,,HALFLG
	OLT HEADING,,CAP,,,,,,<NDISP!NPLOT>
	OLT HERE,,ICI,,,,,,<NDISP!NPLOT>
	OLT HIDETURTLE,HT,CACHETORTUE,CTT,,,,,NDISP
	OLT HISSPEED,,SAVITESSE,,,,2,,DHON
	OLT HOME,,ORIGINE,,,,,,<NDISP!NPLOT>
	OLE IF,,,,BAKPRI,1
	OLT IFFALSE,IFF,SIFAUX,SIF
	OLT IFTRUE,IFT,SIVRAI,SIV
	OLB ILINE
	OLB INDEX,,,NOTPRO
	OLB INTEGER,INT,,,,1,,FPPF
	OLT LAMPOFF,,ETEINT
	OLT LAMPON,,ALLUME
	OLT LAST,L,DERNIER,DER,,,1
	OLT LEFT,LT,GAUCHE,GA,,,1
	OLT LESS,,PLUSPETIT,,LESSP,,2
	OLT LEVEL,,NIVEAU,,FLEV
	OLT LIGHT,,LUMIERE
	OLF LIGNE,,,NOTPRO
	OLE LINE,,,NOTPRO
	OLT LIST,,LISTE,,LIST.P,,2+VARIABLE
	OLT LISTP,,LISTEP,,LISTP,,1
	OLB LOCAL,,,,,1
	OLT LPUT,,INCLUSF,,,,2+VARIABLE
	OLT LTOUCH,,TOUCHEG
	OLT MAKE,,RELIE,,,,2
	OLF MATRICE,,,NOTPRO
	OLF MATRICES,,MATRS,NOTPRO
	OLB MCLEAR
	OLT MLEN,,LONGM
	OLF MONTRE,,,DISPLAY,,1,,NDISP
	OLB MUCTRL,,,,,1
	OLB MUTYO,MUT,,,,2+VARIABLE
	OLB MUWAIT,,,,,1
	OLT MYSPEED,,MAVITESSE,,,,1,,DHON
	OLE NAME,,,NOTPRO
	OLE NAMES,,,NOTPRO
	OLT NEWSNAP,,NOUVPHOTO,,,,,,NDISP
	OLT NODISPLAY,,LIBECRAN,,KILLDISPLAY,,,,NDISP
	OLF NOM,,,NOTPRO
	OLF NOMS,,,NOTPRO
	OLT NOMUSIC,,LIBMUSIQUE
	OLT NOPLOTTER,,LIBTRACEUR,,KILLPL,,,,NPLOT
	OLT NOT,,NON,,,BAKPRI,1
	OLE NOTBOX,,,,,,,1
	OLB NOTE,,,SING,,2+VARIABLE
	OLT NOTURTLE,,LIBTORTUE,,KILLTURTLE
	OLT NOWRAP,,DEBORDEPAS,,,,,,NDISP
	OLT NUMBERP,,NOMBREP,,NUMBP,,1
	OLT NVOICES,,NPISTES,,,,1
	OLB OUTPUT,OP,,,,1
	OLF PASAPAS,,,STEP
	OLB PAUSE
	OLT PENDOWN,PD,DESCENDPLUME,DP
	OLT PENP,,PLUMEP,,,,,,1
	OLT PENUP,PU,LEVEPLUME,LP
	OLE PLOTTER,,,STRTPL,,,,NPLOT
	OLT PM,,JM
	OLT POF,,IMF,,.POF,,1
	OLT POI,,IMI,,.POI
	OLT POL,,IML
	OLT POT,,IMT
	OLT POTS,,IMTS
	OLT PRINT,PR,ECRIS,EC,,,1+VARIABLE
	OLT PRINTOUT,PO,IMPRIME,IM,SHOW
	OLB PROCEDURES,,,NOTPRO
	OLT PRODUCT,,PRODUIT,,PROD,,2+VARIABLE
	OLB QUOTIENT,,,DIVDE,,2
	OLT RANDOM,,HASARD
	OLT READ,,RAMENE,,.READ,,1
	OLT READPTR,,DECODE
	OLT RELAY,RELAIE,,,,,2,,AI
	OLT REMAINDER,MOD,RESTE,,MOD,,2
	OLT REQUEST,,REPONSE,,RQUEST
	OLT RIGHT,RT,DROITE,DR,,,1
	OLT RTOUCH,,TOUCHED
	OLE RUN,,DO,DO,,1
	OLT SENTENCE,SE,PHRASE,PH,,,2+VARIABLE
	OLT SETHEADING,,METSLECAP,,,,1,,<NDISP!NPLOT>
	OLT SETINDEX,SETI,FIXEINDEX,,.DIRSE,,1
	OLT SETTURTLE,SETT,PLACETORTUE,,,,1,,<NDISP!NPLOT>
	OLT SETX,,FIXEX,,,,1,,<NDISP!NPLOT>
	OLT SETXY,,FIXEXY,,,,2,,<NDISP!NPLOT>
	OLT SETY,,FIXEY,,,,1,,<NDISP!NPLOT>
	OLT SHOWTURTLE,ST,TORTUEPOINTEE,TIP,,,,,NDISP
	OLF SI,,,IF,BAKPRI,1
	OLB SIN,,,SINEF,,1,,FPPF
	OLF SINON,,,ELSE
	OLT SNAP,,PHOTO,,,,,,NDISP
	OLB SQRT,,,,,1,,FPPF
	OLT STARTDISPLAY,,ECRAN,,,,1,,NDISP
	OLE STEP,,.STEP
	OLB STOP
	OLB STORE,,,,,3+VARIABLE
	OLT SUM,,SOMME,,,,2+VARIABLE
	OLB SWITCH,,,,,2,,AI
	OLE TBOX,,,,,,,1
	OLT TEST,,TESTE,,,BAKPRI,1
	OLT TEXT,,TEXTE,,TEXTT,,1
	OLT THEN,,ALORS
	OLT THING,,CHOSE,,DOTS,,1
	OLT THINGP,,CHOSEP,,,,1
	OLT TIME,,HEURE,,UTIMEG
	OLE TITLE,,,NOTPRO
	OLE TITLES,,TITLS,NOTPRO
	OLF TITRE,,,NOTPRO
	OLF TITRES,,TITRS,NOTPRO
	OLT TO,,POUR
	OLT TOOT,,BEEP,,,,1
	OLT TOPLEVEL,,NIVEAUSUP,,EXIT
	OLF TORTUE,,,STARTT,,1
	OLF TOUT,,,NOTPRO
	OLB TRACE
	OLF TRACEUR,,TRAC,STRTPL,,,,NPLOT
	OLE TREE,,,NOTPRO
	OLB TTYP
	OLE TURTLE,,STTUR,STARTT,,1
	OLB TYOWAIT,,,,,2
	OLT TYPE,,TAPE,,,,1+VARIABLE
	OLT TYPEIN,,PREPONSE
	OLB UNTIL,,,,BAKPRI,1
	OLT USE,,REFERE,,.USE,,1
	OLT VLEN,,LONGP
	OLT VOICE,,PISTE,,,,1
	OLT WAIT,,ATTENDS,,UWAIT,,1
	OLT WIPE,,DEGAGE,,,,1,,NDISP
	OLT WIPECLEAN,WC,BALAYE,,,,,,NDISP
	OLT WORD,,MOT,,,,2+VARIABLE
	OLT WORDP,,MOTP,,WORDP,,1
	OLT WRAP,,DEBORDE,,,,,,NDISP
	OLT WRITE,,ENVOIE,,.WRITE,,1
	OLT WRITEPTP,,PERFORE
	OLB XCOR,,,,,,,<NDISP!NPLOT>
	OLB YCOR,,,,,,,<NDISP!NPLOT>
	.IF1
NUMNSC==NUMOBS	;NUMBER OF NON-SPECIAL CHARACTER OBLIST ELEMENTS

	.ENDC
	OLB ^\!(\,,LLPAR,LLPAR,PARPRI,1
	CDM EXCL$
	OLB ^\!\,,COMT,COMT,HIPRI
	CDM HASH$
	OLB ^\#\,,PROC,PROC,HIPRI,1
	CDM LP$
	OLB ^\(\,,LPAR,LPAR,PARPRI,1
	CDM RP$
	OLB ^\)\,,RPAR,RPAR,PARPRI
	CDM PRD$
	OLB ^\*\,,STAR,PROD,MDPRI,2+VARIABLE,YINFIX
	CDM PLU$
	OLB ^\+\,,PLUS,SUM,PMPRI,2+VARIABLE,YINFIX
	OLB ^\++\,,UPLUS,UPLUS,HIPRI,1
	CDM MIN$
	OLB ^\-\,,MINUS,DIFF,PMPRI,2,YINFIX
	OLB ^\--\,,UMINS,UMINS,HIPRI,1
	CDM DIV$
	OLB ^\/\,,SLSH,DIVDE,MDPRI,2,YINFIX
	CDM DOTS$
	OLB ^\:\,,DOTS,DOTS,HIPRI,1
	CDM LSS$
	OLB ^\<\,,LESS,LESS,RELPRI,2,YINFIX
	CDM EQL$
	OLB ^\=\,,EQUAL,EQUAL,RELPRI,2,YINFIX
	CDM GTR$
	OLB ^\>\,,GRTR,GREATR,RELPRI,2,YINFIX
	CDM BKSL$
	OLB ^/\/,,BKSL,MOD,MDPRI,2,YINFIX
	CDM BKAR$
	OLB ^/_/,,BKAR,MAKE,BAKPRI,2,YINFIX
	OLB ^/__/,,TBKAR,MMAKE,BAKPRI,2,YINFIX

	.IF1
.=.+<NUMOBS*6>
	.ENDC
	.IF2
.=OBADD2
	.ENDC


.VERR==-128.
.VRTS==-128.
GCMKL:	TOPS
	TOPS1
	TOPS2
	GCP1
	GCP2
	GCPREV
	MVOC
	MVOC+2
	MVOC+4
	MVOC+6
	ILINEL	;PTR TO TYPED INPUT LINE
	ERPROC	;PTR TO ERRSET PROC
	.IIF NZ NDISP, SNLIST
	0


SECRET:	TEXT ^/SECRET/


	.STITL GARBAGE COLLECTOR MARK-NODE TABLES

BMT:	.BYTE 1,2,4,10,20,40,100,200
LMT:	MARKV2	;SYSTEM FUNCTION
	MARKV2	;INFIX (SYSTEM FUNCTION)
	MKATOM	;USER FUNCTION
	MKATOM	;VARIABLE BINDING
	GCDIE	;IDLE NODE
	GCDIE	;UNUSED
	GCDIE	;BUCKET ELEMENT
	MARKV2	;SHORT STRING
	.IFNZ NDISP
	MKSNAP	;SNAP
	.ENDC
	.IFZ NDISP
	GCDIE
	.ENDC
	MKATOM	;ATOM
	MARKV2	;SHORT NUMBER
	MKINUM	;INTEGER NUMBEB
	MKLIST	;LONG STRING
.IFZ FPPF
	GCDIE	;TBA
.IFF
	MKINUM
.ENDC
	GCDIE	;UNUSED (WAS "SENTENCE" ONCE)
	MKLIST	;LIST

	.STITL ERROR MACROS

	.MACRO ERMM AA
	AA'.E
	AA==ERMNO
	ERMNO==ERMNO+1
	.ENDM

	.MACRO JROT A
.IIF NDF A'.R,A'.R==A
	.ENDM

	.MACRO ERRM A,C
	.IIF B C,JROT A
	.IIF NB C,A'.R==C
	A'.R
	A'.N==ERRNO
	ERRNO==ERRNO+1
	.ENDM

ERRNO==200
ERMNO==0
	.STITL ERROR TABLES


ROTTAB:	ERRM PNAB,PNODAB
	ERRM PRLO
	ERRM TYO
	ERRM PRCO
	ERRM PRS1
	ERRM PRCT
	ERRM GDBY,GOODBY
	ERRM CTIT
	ERRM HNM
	ERRM LDE1
	ERRM PAE
	ERRM PRAB,PROAB
	ERRM PNH1
	ERRM TMAP
	ERRM TDE
	ERRM BUG
	ERRM BRK
	ERRM WTA
	ERRM WTAA
	ERRM WTAB
	ERRM WTIB
ERTAB:	ERMM BADD	;BAD DIRECTORY
	ERMM BADE	;BAD ENTRY
	ERMM BAT	;BAD ARRAY TYPE
	ERMM BDD	;BAD DISK
	ERMM BRK	;BREAK!!
	ERMM BUG	;SYSTEM BUG!!
	ERMM CDE	;CAN'T DELETE ENTRY
	ERMM CDF	;CAN NOT DELETE THAT FILE
	ERMM COP	;CHAR (D) OUT OF PALCE
	ERMM CRE	;CAN'T READ THAT ENTRY
	ERMM CTIT	;CANT "TO" IN "TO"
	ERMM DFU	;DISC FULL
	ERMM DIU	;DEVIVE IN USE
	ERMM DNA	;INVALID DEVICE NAME
	ERMM DNR	;DEVICE NOT READY
	ERMM DOR	;DURATION OUT OF RANGE
	ERMM DRF	;DIRECTORY FULL
	ERMM EAES	;ENTRY ALREADY EXISTS
	ERMM ELW	;EDIT LINE WHAT?
	ERMM ENDR	;ENTRY NOT DIRECTORY
	ERMM ERP	;EXTRA RIGHT PAREN
	ERMM ERW	;ERASE WHAT??
	ERMM FAE	;FILE ALREADY EXISTS
	ERMM FAO	;FILE ALREADY OPEN
	ERMM FBUG	;FATAL SYSTEM BUG
	ERMM FNF	;FILE NOT FOUND
	ERMM HARD	;HARDWARE ERROR
	ERMM HNM	;.(B). HAS NO MEANING
	ERMM HNM1	;..CT.. HAS NO MEANING
	ERMM HNV	;.(CT). HAS NO VALUE
	ERMM IDN	;INVALID DISPLAY NUMBER (UGH!)
	ERMM IFN	;A,,B IS INVALID FILE NAME
	ERMM INF1	;INFIX IN THE WRONG PLACE
	ERMM INVN	;INVALID NODE
	ERMM ITN	;INVALID TURTLE NUMBER
	ERMM IUN	;INVALID USER NAME
	ERMM IVV	;INVALID VOICE NUMBER
	ERMM LCE	;LINE ... CHANGED BY EDIT
	ERMM LDE	;LINE ..(B).. DOESN'T EXIST
	ERMM LNTB	;LINE # TOO BIG
	ERMM LNTS	;LINE # TOO SMALL
	ERMM NAS	;NO ARRAY STORAGE
	ERMM NDU	;NOT A DISPLAY USER
	ERMM NDV	;NO DISPLAY AVAILABLE
	ERMM NEC	;NOT AN EDITING COMMAND
	ERMM NED	;NON EXISTENT DIRECTORY
	ERMM NIP	;NOTHING INSIDE PARENS
	ERMM NOG	;NOTE OUT OF RANGE
	ERMM NOU	;NO OUTPUT
	ERMM NSL	;NO STORAGE LEFT
	ERMM NTB	;NO THORTON BOX SLOTS AVAILABLE
	ERMM NTF	;(S) NOT "TRUE" OR "FALSE"
	ERMM NTVS	;TVS CANNOT DO SNAPS AND ASSOCIATED FUNCTIONS
	ERMM OIP	;ONLY IN PROCEDURE
	ERMM OOB	;OUT OF BOUNDS
	ERMM OOP	;(CO) OUT OF PLACE
	ERMM OOT	;OUT OF TOKENS
	ERMM PAE	;PROCEDURE (TEMP) ALREADY EXIXTS
	ERMM PBE	;PROCEDURE IS BEING EDITED
	ERMM PNH	;PROCEDURE .(CT). NOT HERE
	ERMM PNH1	;PROCEDURE .(CPP). NOT HERE
	ERMM ROB	;INDEX REFERENCE OUT OF BOUNDS
	ERMM RTB	;RESULT TOO BIG
	ERMM SHW	;SHOW WHAT??
	ERMM STD	;SNAP TOO DEEP
	ERMM TDE	;TTY ..(E/2).. DOESN'T  EXIST
	ERMM TGDZ	;TURTLE GETTING DIZZY
	ERMM TIP	;TOO MUCH INSIDE PARENS
	ERMM TMAC	;TOO MANY ARGS (CURRENT PROC)
	ERMM TMAP	;TOO MANY ARGS (PROC BEING TO'ED)
	ERMM TML	;TOO MANY LINES
	ERMM TNR	;TURTLE NOT RESPONDING
	ERMM UBL	;USED BY LOGO
	ERMM UDA	;UNDEFINED ARRAY
	ERMM UEL	;UNEXPECTED END OF LINE
	ERMM UELX	;...(CO) NEEDS ARGS
	ERMM VTD	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE OR A DISPLAY
	ERMM VTU	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE
	ERMM WDIM	;BAD DIMENSIONS
	ERMM WDW	;YOU DON'T SAY WHAT TO DO WITH...
	ERMM WIT	;(CT) IS WRONG INPUT TO "TO"
	ERMM WNA	;WRONG NUMBER OF ARGUMENTS TO ..(CO)
	ERMM WTA	;..(CO)..DOESN'T LIKE..(CT)..AS INPUT
	ERMM WTAA	;..(CO)..DOESN'T LIKE..(A)...AS INPUT
	ERMM WTAB	;..(CO)..DOESN'T LIKE..(B)...AS INPUT
	ERMM WTIB	;..(CO)..DOESN'T LIKE..NUMBER IN B...AS INPUT
	.STITL OTHER TABLES

;THE DISPATCH TABLE FOR CONVERT

CNVTBL:
	.BYTE CNVNOP	;SNAP TO SNAP
REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE 0	;ATOM TO SNUM
	.BYTE 0	;ATOM TO INUM
	.BYTE CA2LS	;ATOM TO LSTR
REPT1 3,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SNUM TO SNUM
	.BYTE CSN2IN	;SNUM TO INUM
	.BYTE CSN2LS	;SNUM TO LSTR
.IIF NZ FPPF,	.BYTE CSN2FN	;SNUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CIN2SN	;INUM TO SNUM
	.BYTE CNVNOP	;INUM TO INUM
	.BYTE CIN2LS	;INUM TO LSTR
.IIF NZ FPPF,	.BYTE CIN2FN	;INUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CLS2SN	;LSTR TO SNUM
	.BYTE CLS2IN	;LSTR TO INUM
	.BYTE CNVNOP	;LSTR TO LSTR
.IIF NZ FPPF,	.BYTE CLS2FN	;LSTR TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

.IFNZ FPPF

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME (RNUM TO ANYTHING)
	.BYTE CFN2SN	;FNUM TO SNUM
	.BYTE CFN2IN	;FNUM TO INUM
	.BYTE CFN2LS	;FNUM TO LSTR
	.BYTE CNVNOP	;FNUM TO FNUM
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME


.IFF

REPT1 8.,^\.BYTE 0\


.ENDC

REPT1 6,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SENT TO SENT
REPT1 1,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;LIST TO LIST

.IIF NZ .-CNVTBL-100,.PRINT /CONVERT TAB SCREWED UP!/
	.EVEN

;THE LIST OF VALID TYPES

CKLIST:	.IIF NZ FPPF,FNUM
	.IIF NZ NDISP,SNAP ;CRACKLE,POP
	LSTR
	LNUM
	LIST
	ATOM
.IIF NZ FPPF,	FNUM
	0
		;MUSIC BOX CHARACTERS

	MBTRAP==43	;TRAP CHARACTER
	MBFCH==100	;SHUT-UP CHARACTER
	MBREST==40	;REST CHARACTER FOR MUSIC BOX
	MBPERC==42	;HIGHEST CODED PERCUSSION EFFECT

MBVCH:	.BYTE	123,42,61,60	;CTL CHARACTERS FOR NUMBER OF VOICES
MBSCH:	.BYTE	103,102,101,100	;LIKE MBVCH, EXCEPT SPECIFIES SILENCE


STURF:	.BYTE 101.,36.,68.,19.	;TURTLE FUDGE FACTORS FOR LEFT AND RIGHT
;	MULTIPLY BY EVEN BYTE AND DIVIDE BY ODD BYTE
.IFZ FPPF

;BEAUTIFUL SINE TABLE IN WHOOPIE FORMAT


SIN:

	0	;0 DEGREES
	2167	;2 DEGREES
	4355	;4 DEGREES
	6541	;6 DEGREES
	10720	;8 DEGREES
	13072	;10 DEGREES
	15234	;12 DEGREES
	17367	;14 DEGREES
	21510	;16 DEGREES
	23615	;18 DEGREES
	25707	;20 DEGREES
	27763	;22 DEGREES
	32017	;24 DEGREES
	34034	;26 DEGREES
	36027	;28 DEGREES
	40000	;30 DEGREES
	41724	;32 DEGREES
	43623	;34 DEGREES
	45474	;36 DEGREES
	47315	;38 DEGREES
	51106	;40 DEGREES
	52646	;42 DEGREES
	54352	;44 DEGREES
	56023	;46 DEGREES
	57437	;48 DEGREES
	61015	;50 DEGREES
	62335	;52 DEGREES
	63615	;54 DEGREES
	65035	;56 DEGREES
	66214	;58 DEGREES
	67331	;60 DEGREES
	70404	;62 DEGREES
	71413	;64 DEGREES
	72357	;66 DEGREES
	73255	;68 DEGREES
	74107	;70 DEGREES
	74674	;72 DEGREES
	75412	;74 DEGREES
	76062	;76 DEGREES
	76463	;78 DEGREES
	77016	;80 DEGREES
	77301	;82 DEGREES
	77514	;84 DEGREES
	77660	;86 DEGREES
	77754	;88 DEGREES
	77777	;90 DEGREES
.ENDC

;PRINTOUT DISPATCH TABLE
.MACRO DT A,B
$'A
B
.ENDM
PODISP:	DT INDEX,.POI
	DT PROCED,SHALPR
.IFNZ ENG
	DT ALL,SHOWAL
	DT FILE,.POFILE
	DT TITLE,POT
	DT LINE,POL
	DT ARRAY,PO1AR
	DT ARAYS,POARR
	DT NAMES,SHALNA
	DT TREE,.POTREE
.ENDC
.IFNZ FR
	DT TOUT,SHOWAL
	DT FICHIER,.POFILE
	DT TITRE,POT
	DT TITRS,POTS
	DT LIGNE,POL
	DT MATRICE,PO1AR
	DT MATRS,POARR
	DT NOMS,SHALNA
	DT ARBRE,.POTREE
.ENDC
	0

;ERASE DISPATCH TABLE
ERSDISP:	DT TRACE,ETRACE
	DT INDEX,ERINDX
	DT PROCE,ERALPR
.IFNZ ENG
	DT ALL,ERALL
	DT .STEP,ESTEP
	DT BURY,EBURY
	DT FILE,ERFI
	DT LINE,ERLINE
	DT NAMES,ERALNA
	DT NAME,ERNAME
	DT ARRAY,ERARAY
	DT ARAYS,ERARAS
.ENDC
.IFNZ FR
	DT TOUT,ERALL
	DT PASAPAS,ESTEP
	DT ENFOUI,EBURY
	DT FICHIER,ERFI
	DT LIGNE,ERLINE
	DT NOMS,ERALNA
	DT NOM,ERNAME
	DT MATRICE,ERARAY
	DT MATRS,ERARAS
.ENDC
	0
;DISPLAY DIRECTION CODES

DREC:	.BYTE 10
	.BYTE 0
	.BYTE 20
	.BYTE 30
	.BYTE 60
	.BYTE 70
	.BYTE 50
	.BYTE 40
	.EVEN
	.STITL SYSTEM DISPATCH TABLE (BYTE ONE)

;FLAG DEFINITIONS
FSF==200	;SPECIAL INPUT
FOF==100	;SPECIAL OUTPUT
FQF==20		;QUOTING
SEPF==4		;SEPARATOR
WSF==2		;WORD SEPARATOR
NNUMF==40	;NOT A NUMBER
OPERF==10	;OPERATOR

DTBL:
.BYTE	NNUMF,FOF!NNUMF		;^@	;^A ECHOES AS CR
.BYTE	FSF!NNUMF,FSF!NNUMF	;^B IS CONVERTED TO %
				;^C COPYS NEXT CHARACTER
.BYTE	FSF!NNUMF,NNUMF		;^D DELETES NEXT CHARACTER	;^E
.BYTE	NNUMF,FSF!FOF!NNUMF	;^F	;^G BREAK
.BYTE	FOF!NNUMF,FOF!SEPF!WSF!NNUMF	;^H BACKSPACE	;^I TABULATE
.BYTE	FOF!SEPF!WSF!NNUMF,FOF!SEPF!WSF!NNUMF	;^J LINE FEED
				;^K TABULATE VERTICALLY
.BYTE	FOF!SEPF!WSF!NNUMF,FSF!FOF!SEPF!WSF!NNUMF	;^L FORM FEED
				;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	FSF!NNUMF,NNUMF		;^N GET NEXT WORD	;^O
.BYTE	NNUMF,FSF!NNUMF		;^P	;^Q SUPER-QUOTE
.BYTE	FSF!NNUMF,FSF!NNUMF	;^R COPY REST OF LINE
				;^S SKIP NEXT WORD
.BYTE	NNUMF,NNUMF		;^T	;^U
.BYTE	NNUMF,FSF!NNUMF		;^V	;^W ERASE LAST WORD
.BYTE	FSF!NNUMF,FSF!NNUMF	;^X CLARIFY INPUT
				;^Y EDIT PREVIOUS LINE
.BYTE	FSF!NNUMF,NNUMF		;^Z DESTROY INPUT BUFFER
				;^[ MAYBE ALTMODE
.BYTE	NNUMF,NNUMF		;^\	;^]
.BYTE	NNUMF,NNUMF		;^^	;^_ ANY BETTER IDEAS FOR THEM?
.BYTE	SEPF!WSF!NNUMF,NNUMF!SEPF!OPERF	;SP	;! COMMENT?
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;"	;# ACTION OF
.BYTE	NNUMF,NNUMF		;$	;%
.BYTE	NNUMF,NNUMF!OPERF	;&	;' (MAYBE LE)
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;( ARITHMETIC GROUPING
				;) DITTO
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;* MULTIPLY	;+ ADD
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;,	;- SUBTRACT
.IIF NZ FPPF, .BYTE	0,SEPF!NNUMF!OPERF
.IIF Z FPPF, .BYTE	NNUMF,SEPF!NNUMF!OPERF	;.	;/ DIVIDE
.BYTE	0,0	;0	;1
.BYTE	0,0	;2	;3
.BYTE	0,0	;4	;5
.BYTE	0,0	;6	;7
.BYTE	0,0	;8.	;9.
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF	;: THING OF	;; PROPERTY OF
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;<	;=
.BYTE	SEPF!NNUMF!OPERF,NNUMF	;>	;?
.BYTE	NNUMF,NNUMF		;@	;A
.BYTE	NNUMF,NNUMF		;B	;C
.IIF NZ FPPF,	.BYTE	NNUMF,0
.IIF Z FPPF, .BYTE	NNUMF,NNUMF		;D	;E
.BYTE	NNUMF,NNUMF		;F	;G
.BYTE	NNUMF,NNUMF		;H	;I
.BYTE	NNUMF,NNUMF		;J	;K
.BYTE	NNUMF,NNUMF		;L	;M
.IIF NZ FPPF,	.BYTE	0,NNUMF
.IIF Z FPPF,	.BYTE	NNUMF,NNUMF		;N	;O
.BYTE	NNUMF,NNUMF		;P	;Q
.BYTE	NNUMF,NNUMF		;R	;S
.BYTE	NNUMF,NNUMF		;T	;U
.BYTE	NNUMF,NNUMF		;V	;W
.BYTE	NNUMF,NNUMF		;X	;Y
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF	;Z	;[
.BYTE	SEPF!NNUMF!OPERF,FSF!FQF!SEPF!WSF!NNUMF	;\ MODULO	;]
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;^	EXPONENTIATE, MAYBE
				;_ MAKE
.BYTE	NNUMF,NNUMF		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	NNUMF,NNUMF		;b LOWER CASE	;c LOWER CASE
.BYTE	NNUMF,NNUMF		;d LOWER CASE	;e LOWER CASE
.BYTE	NNUMF,NNUMF		;f LOWER CASE	;g LOWER CASE
.BYTE	NNUMF,NNUMF		;h LOWER CASE	;i LOWER CASE
.BYTE	NNUMF,NNUMF		;j LOWER CASE	;k LOWER CASE
.BYTE	NNUMF,NNUMF		;l LOWER CASE	;m LOWER CASE
.BYTE	NNUMF,NNUMF		;n LOWER CASE	;o LOWER CASE
.BYTE	NNUMF,NNUMF		;p LOWER CASE	;q LOWER CASE
.BYTE	NNUMF,NNUMF		;r LOWER CASE	;s LOWER CASE
.BYTE	NNUMF,NNUMF		;t LOWER CASE	;u LOWER CASE
.BYTE	NNUMF,NNUMF		;v LOWER CASE	;w LOWER CASE
.BYTE	NNUMF,NNUMF		;x LOWER CASE	;y LOWER CASE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;Z LOWER CASE	;LEFT BRACE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;VERTICAL BAR	;RIGHT BRACE
.BYTE	NNUMF,FSF!NNUMF		;TILDE	;RUBOUT
	.STITLE SYSTEM DISPATCH TABLE (BYTE TWO)
;NUMBERS POINT TO OTHER TABLES
;$ POINTS TO SYSTEM OBLIST

DTBL2:
.BYTE	0,0		;^@ 			;^A
.BYTE	36,0		;^B BECOMES %, PRINTS AS SPACE IN STRINGS
			;^C COPY NEXT CHARACTER
.BYTE 2,0		;^D DELETES NEXT CHAR	;^E
.BYTE	0,4		;^F 			;^G BREAK
.BYTE	2,10		;^H BACKSPACE		;^I TABULATE
.BYTE	12,14		;^J LINE FEED		;^K TABULATE VERTICALLY
.BYTE	16,6		;^L FORM FEED
			;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	10,0		;^N GET NEXT WORD		;^O
.BYTE	0,12		;^P 			;^Q SUPER-QUOTE
.BYTE	14,16		;^R 			;^S SKIP NEXT WORD
.BYTE	0,0		;^T	;^U
.BYTE	0,20		;^V	;^W ERASE LAST WORD
.BYTE	22,24		;^X CLARIFY INPUT	;^Y
.BYTE	26,0		;^Z DESTROY INPUT BUFFER
			;^[ MAYBE ALTMODE
.BYTE	0,0		;^\	;^]
.BYTE	0,0		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	0,EXCL$		;SP	;! COMMENT?
.BYTE	0,HASH$		;"	;# ACTION OF
.BYTE	0,0		;$	;%
.BYTE	0,0		;&	;' (MAYBE LE)
.BYTE	LP$,RP$		;( ARITHMETIC GROUPING	;) DITTO
.BYTE	PRD$,PLU$	;* MULTIPLY	;+ ADD
.BYTE	0,MIN$		;,	;- SUBTRACT
.BYTE	0,DIV$		;.	;/ DIVIDE
.BYTE	0,0		;0	;1
.BYTE	0,0		;2	;3
.BYTE	0,0		;4	;5
.BYTE	0,0		;6	;7
.BYTE	0,0		;8.	;9.
.BYTE	DOTS$,0		;: THING OF	;; PROPERTY OF
.BYTE	LSS$,EQL$	;<	;=
.BYTE	GTR$,0		;>	;?
.BYTE	0,0		;@	;A
.BYTE	0,0		;B	;C
.BYTE	0,0		;D	;E
.BYTE	0,0		;F	;G
.BYTE	0,0		;H	;I
.BYTE	0,0		;J	;K
.BYTE	0,0		;L	;M
.BYTE	0,0		;N	;O
.BYTE	0,0		;P	;Q
.BYTE	0,0		;R	;S
.BYTE	0,0		;T	;U
.BYTE	0,0		;V	;W
.BYTE	0,0		;X	;Y
.BYTE	0,32		;Z	;[
.BYTE	BKSL$,34	;\ MODULO	;]
.BYTE	0,BKAR$		;^ (MAYBE EXPONENTIATE)		;_ MAKE
.BYTE	0,0		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	0,0		;b LOWER CASE	;c LOWER CASE
.BYTE	0,0		;d LOWER CASE	;e LOWER CASE
.BYTE	0,0		;f LOWER CASE	;g LOWER CASE
.BYTE	0,0		;h LOWER CASE	;i LOWER CASE
.BYTE	0,0		;j LOWER CASE	;k LOWER CASE
.BYTE	0,0		;l LOWER CASE	;m LOWER CASE
.BYTE	0,0		;n LOWER CASE	;o LOWER CASE
.BYTE	0,0		;p LOWER CASE	;q LOWER CASE
.BYTE	0,0		;r LOWER CASE	;s LOWER CASE
.BYTE	0,0		;t LOWER CASE	;u LOWER CASE
.BYTE	0,0		;v LOWER CASE	;w LOWER CASE
.BYTE	0,0		;x LOWER CASE	;y LOWER CASE
.BYTE	0,32		;z LOWER CASE	;{ OPEN BRACE
.BYTE	0,34		;| VERTICAL BAR, MAYBE OR, MAYBE XOR
			;} CLOSE BRACE
.BYTE	0,30		;~ TILDE, LOGICAL NOT	;RBO	RUBOUT

LPURBL==<.-PURAD>_-10.
.IIF GT .-PURAD-20000,.ERROR OOOPS!! TOO MUCH PURE STUFF!
.STITL SYSTEM PRIMITIVES
.IFNZ ENG&FR
ENGLIS:ANGLAI:	MOV #ENGFLG,LANG
ENG1:	SEZ
	RTS PC
FRENCH:FRANCAIS:	MOV #PFRFLG!FRFLG,LANG
	BR ENG1
FRANGLAIS:	BIS #ENGFLG!FRFLG,LANG
	BR ENG1
.ENDC

CLOCK:	SAVE <#SSTATS>	;THE SYSTEM STATUS BLOCK
	$SSTATUS	;FILL IT UP
	MOV TIME,A
	MOV TIME+2,B
	JSR PC,GRBAD	;MAKE NODE UP WITHT THE NUMBER IN IT
	BIS #INUM,C	;POINT TOT HE NUMBER
	JMP ORTC	;RETURN IT

UWAIT:	JSR PC,G1IARG
	SAVE <B,C>
	$SLEEP
	SEZ
	RTS PC
;THIS IS THE STUFF FOR ARRAY HACKING
AMAKE:	MOV 4(SP),D	;NO. OF ARGS
	ASL D
	ADD S,D
	MOV -(D),A	;ADDR OF ARRAY NAME
AMAKE5:	MOV A,B
	BIC #7777,A
	CMP #ATOM,A	;IS A TYPE ATOM?
	BNE AMAKE3	;NO
AMAKE4:	MOV #ABIND,A
	JSR PC,.BINDL
	BEQ AMAKE6
	CLR TOPS
	RTS PC
AMAKE3:	CMP #LSTR,A	;IS A TYPE LSTR?
	BNE AMAKE2	;YES
AMAKE1:	BIT #7777,B	;NULL POIMTER?
	BEQ AMAKE2	;YES
	MOV B,TOPS
	JSR PC,.OBSCH	;GET ATOM
	BNE AMAKE4
AMAKE6:	ERROR+UDA
AMAKE2:	ERROR+WTAB



ARRAD:	MOV B,E
	SPUSH E	;TOP OF ARRAY HEADER
	CMPB 4(E),F	;IS DIM=NO. OF INDICES?
	BEQ ARRAD1	;YES
	ERROR+WNA	;WRONG NO OF ARGS
ARRAD1:	CLR A	;TEMP ACCUMULATOR
	ADD #12,E	;LENGTH OF DIMENSION IN E
ARRAD2:	JSR PC,G1NARG	;GET INDEX OFF S-PDL
	CMP B,(E)	;INDEX IN BOUNDS?
	BGE ARRAD4	;NO
	TST B	;NEGATIVE INDEX?
	BGE .+4	;INDEX OK
ARRAD4:	ERROR+ROB
	ADD B,A
	DEC F
	BEQ ARRAD3	;MORE INPUT
	MUL -(E),A
	MOV B,A
	BR ARRAD2
ARRAD3:	SPOP E	;ADDR OF ARRAY HEADER
	TSTB 5(E)	;IS TYPE PTR?
	BEQ .+4
	ASL A
	ASL A		;TOTAL OFFSET (A*4)
	ADD #14,E	;ADDR OF FIRST VALUE
	ADD E,A		;ADDR OF VALUE TO BE STORED
	RTS PC

STORE:	JSR PC,AMAKE
	SPOP	A	;RETURRN ADDR
	SPOP F		;NO. OF ARGUMENTS
	SPUSH	A
	SUB #2,F
	POPS D		;VALUE TO BE STORED
	JSR PC,ARRAD	;FIND STORAGE LOCATION
	MOV A,F
	MOV -10(E),A
	MOV D,B
	BIC #7777,A
	BEQ STORE1
	JSR PC,CONVERT
	BNE .+4
	ERROR+WTAB
	JSR PC,.LOADB
	MOV A,(F)+
STORE1:	MOV B,(F)	;VALUE IS NOW STORED
	ADD #2,S
	SEZ
	RTS PC


GET:	JSR PC,AMAKE
	SPOP	A	;RETURN ADDR
	SPOP F	;NO. OF ARGUMENTS
	SPUSH	A
	DEC F		;NO. OF INDICES
	JSR PC,ARRAD	;COMPUTE STORAGE LOCATION
	MOV A,F		;STORAGE LOCATION ADDR IN F
	MOV (F),C
	TSTB -7(E)	;TEST TYPE
	BEQ GET1	;TYPE 0 (PTR)
	MOV (F)+,A
	MOV (F),B
	JSR PC,GRBAD	;STORES VALUE IN NODE SPACE
	MOV -10(E),D
	BIC #7777,D
	BIS D,C		;SET TYPE ON PTR TO VALUE
GET1:	MOV C,@S	;PTR ON TOP OF S-PDL
	CLZ
	RTS PC

LIMIT==3
HEADER==14
BKPTR==4
SIZE==2


	;INPUT--B HAS SIZE OF BLOCK TO BE ALLOCATED IN BYTES
	;OUTPUT--A HAS PTR.TO BLOCK IF ALLOCATION SUCESSFUL
	;        SECOND WORD OF BLOCK CONTAINS SIZE OF BLOCK IN BYTES
	;        AND SKIP RETURN


..ALLOC:	CMP	B,ASPACE	;SIZE OF ARRAY .LE. FREE SPACE?
	BGT ARREXP		;NO, TRY TO EXPAND
	PUSH	C
	MOV	AROVER,A	;GET FRE BLOCK PTR.
SRCBLK:	CMP	B,SIZE(A)	;IS BLOCK NOW POINTED AT BIG ENOUGH?
	BLE	OKALOC		;YES
	CMP	@A,AROVER	;CHAIN GONE THRU' ONCE?
	BEQ	CMPRES		;YES
	MOV	@A,A		;NEXT FREE BLOCK
	BNE	SRCBLK		;LAST BLOCK IN CHAIN?
	MOV	AFREE,A		;YES,START FROM THE BEGINNING
	CMP A,AROVER
	BNE SRCBLK

CMPRES:	JSR	PC,.PRESS	;GO COMPRESS THE ARRAY SPACE
	MOV	AROVER,A	;A POINTS TO FREE SPACE
OKALOC:	MOV SIZE(A),C
	SUB B,C
	CMP #20,C
	BGE HOLE
	MOV	A,C		;TO ADDR.OF FREE BLOCK
	ADD	B,C		;ADD SIZE OF ALLOCATED BLOCK TO GET NEW FREE BLOCK ADDR.
	SUB	B,SIZE(A)	;GET SIZE OF NEW FREE BLOCK
	MOV	SIZE(A),SIZE(C)	;AND STORE IN SIZE FIELD OF NEW FREE BLOCK
	MOV B,SIZE(A)
	MOV	BKPTR(A),BKPTR(C)	;PTR. MANAGEMENT
	BEQ	NEWBK1		;IF THIS BLOCK FIRST OF CHAIN,SKIP
	MOV	C,@BKPTR(A)	;CHANGE FORWARD PTR. OF LAST BLOCK
NEWBK1:	MOV	(A),(C)		;FORWARD PTR. FOR NEW BLOCK
	BEQ	NEWBK3		;IF THIS BLOCK IS LAST IN CHAIN,SKIP
NEWBK2:	ADD	#BKPTR,@A	;TO ACCESS BKPTR FIELD OF NEXT BLOCK
	MOV	C,@(A)		;AND CHANGE IT
NEWBK3:	MOV	C,AROVER	;UPDATE FREE BLOCK ROVING POINTER
	CMP	AFREE,A		;REQUIRED TO UPDATE AFREE?
	BNE	ALDONE		;NO
	MOV	AROVER,AFREE	;YES
ALDONE:	SUB	SIZE(A),ASPACE	;UPDATE FREE SPACE AVAILABLE
	POP	C
	CLZ
	RTS PC
			;SKIP RETURN

HOLE:	MOV	BKPTR(A),C	;TO LINK UP WITH BLOCK BEFORE THE ONE ALLOCATED
	BNE	NEWBK1		
	MOV (A),C
	BR NEWBK3

ARREXP:	MOV ASPACE,A	;AMOUNT OF FREE SPACE WE KNOW ABOUT
	ADD #<ARYHPG-ARYPG+1>_13.+ARYAD,A	;TOTAL POSSIBLE ARRAY SPACE
	SUB ARTOP,A	;AMOUNT ALREADY GOBBLED
	CMP B,A		;NOW THEN, IS THIS POTENTIALLY ENOUGH??
	BLE ARREX4
	BR ARREX1
ARREX3:	ADD #6,P
ARREX1:	SEZ		;TOO GREEDY
	RTS PC
ARREX4:	MOV B,A		;AMOUNT WE WANT
	SUB ASPACE,A	;AMOUNT WE HAVE
	ASH #-10.,A	;AMOUNT WE NEED IN 512 WORD BLOCKS
	SAVE <C,B,A>
ARREX2:	MOV #ARRHPG,A
	JSR PC,EXSPAC	;TRY TO EXPAND ARRAYS
	BEQ ARREX3	;NO LUCK
	MOV ARTOP,B	;OLD TOP OF ARRAYS
	ADD #2000,ARTOP	;NEW!
	MOV #2000,SIZE(B)	;SIZE OF "ARRAY" WE ARE "FREEING"
	JSR PC,.RELES	;FREE THE NEW SPACE
	DEC (P)		;IS THAT ENOUGH?
	BGE ARREX2	;NOT YET
	REST <A,B,C>
	BR ..ALLOC	;TRY IT AGAIN (THIS TIME SURE TO WIN!)
	;RELEASE A BLOCK IN THE ARRAY SPACE
	;INPUT--B HAS PHYSICAL PTR TO BLOCK TO BE RELEASED
	;OUTPUT--B UNCHANGED. RELEASED BLOCK INSERTED INTO CHAIN OF FREE BLOCKS


.RELES:	ADD	SIZE(B),ASPACE	;UPDATE ASPACE
	TST	AFREE		;IS ARRAY SPACE EMPTY?
	BEQ	ONEBLK		;YES
	PUSH	A
	SPUSH	C
	SPUSH	D
	MOV	AROVER,C
	CMP	B,C		;ADDR OF RELEASED BLOCK > (AROVER)
	BHI CHAIN		;START TRYING TO INSERT AT AROVER
	MOV	AFREE,C		;OTHERWISE START AT AFREE
	CMP B,C
	BHI CHAIN
	MOV AFREE,A
	JSR PC,ONEBLK
	MOV B,C
	ADD SIZE(B),C
	CMP A,C
	BNE .RELE1
	MOV (C),(B)
	ADD SIZE(C),SIZE(B)
	BR REDONE
.RELE1:	MOV A,(B)
	MOV B,BKPTR(A)
	BR REDONE

CHAIN:	MOV	C,A		;A_CURRENT FREE BLOCK
	MOV	(A),C		;C_NEXT FREE BLOCK
	BEQ	LSTBLK		;CURRENT BLOCK IS LAST IN CHAIN
	CMP	C,B		;ADDR OF NEXT FREE > ADDR OF RELEASED?
	BLT	CHAIN		;NO,TRY NEXT ONE
	MOV	SIZE(B),D	;YES,START INSERTING THE RELEASED BLOCK
	ADD	B,D		;SIZE IN BYTESADDED TO (B) GIVES END OF RELEASED BLOCK
	CMP	C,D		;WHICH MIGHT BE ADJACENT TO NEXT FREE BLK
	BNE	LSTBLK		;NO
	ADD	SIZE(C),SIZE(B)	;YES,COLLAPSE THE TWO
	MOV	(C),C		;UPDATE FWDPTR

LSTBLK:	MOV	SIZE(A),D	;THIS FREE BLOCK 
	ADD	A,D		;MIGHT BE ADJACENT TO THE
	CMP	D,B		;RELEASED BLOCK
	BEQ	CONBLK		;YES
	MOV	C,(B)		;NO,JUST UPDATE PTR
	MOV	A,BKPTR(B)	;SIZE FIELD NEED NOT BE CHANGED
	MOV	B,(A)	
	TST	C		;IF THIS FREE BLOCK IS LAST IN CHAIN
	BEQ	REDONE		;THEN NOTHING
	MOV	B,BKPTR(C)	;ELSE UPDATE BKPTR OF NEXT BLK
REDONE:	POP	D
	SPOP	C
	SPOP	A
	RTS	PC

ONEBLK:	MOV	B,AFREE		;RELEASED BLOCK IS THE ONLY FREE ONE
	MOV	B,AROVER
	CLR	(B)
	CLR	BKPTR(B)
	RTS	PC


CONBLK:	ADD	SIZE(B),SIZE(A)	;COLLAPSE
	MOV	C,(A)		;AND UPDATE PTR
	BR	REDONE
	;THIS ROUTINE COMPRESS THE ARRAY SPACE BY STACKING FREE BLOCKS TOGETHER
	;AFREE POINTS TO FIRST FREE BLOCK IN THE CHAIN
	;FIRST WORD OF USED BLOCK MUST CONTAIN PTR. TO WORD POINTING TO THAT BLOCK FOR RELOCATING

.PRESS:	TST	AFREE		;ARE THERE ANY FREE BLOCKS?
	BNE	.+4		;YES
	RTS	PC		;NO,DONE
	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D

	MOV	AFREE,A		;A_FIRST FREE BLOCK ADDR
MOVNXT:	MOV	A,B		;B_CURRENT FREE BLOCK ADDR
	MOV	(B),A		;A_NEXT FREE BLOCK ADDR
	BEQ	PSDONE		;IF NEXT FREE BLOCK ADDR = 0,DONE
	MOV	SIZE(B),C	;FREE BLOCK SIZE IN BYTES
	ADD	B,C		;PLUS FREE BLOCK ADDR=STARTING ADDR OF USED BLOCK

COLAPS:	MOV	SIZE(C),D	;GET USED BLOCK SIZE
	ASR	D		;GET SIZE IN WORDS
	MOV	B,@(C)		;CHANGE PTRRR TO ARRAY		
	MOV	(C)+,(B)+	;BLOCK TRANSFER
	SOB	D,.-2		;COUNTER
	CMP	C,A		;THIS BLOC OF USED BLOCKS MOVED?
	BEQ	MOVNXT		;YES,MOVE NEXT BLOC
	BR	COLAPS		;NO,CONTINUE TO TRANSFER NEXT USED BLOCK

PSDONE:	SPOP	D
	SPOP	C
	SPOP	B
	SPOP	A
	MOV	ASPACE,SIZE(B)
	JMP	ONEBLK		;TAKE CARE OF AFREE AND RETURN
	;DEFINE AN ARRAY

DEFAR:	POP	A		;RETURN ADDR
	SPOP	F		;NO. OF ARGS PASSED
	SPUSH	A
	CMP	F,#LIMIT+2	;WHICH SHOULD BE < ALLOWABLE LIMIT
	BLE	OKARAY		;OKAY,THIS IS.
AERROR:	ERROR+WDIM
OKARAY:	SUB	#2,F		;DIMENSION OF ARRAY IN F
	MOV	F,A
	MOV	#1,D		;SET UP FOR MULTIPLICATION
	JSR	PC,G1NARG	;GET TYPE
	MOV	B,E		;SAVE IT
	TST	B
	BEQ	ALNUM		;0 FOR LNUM
	.IFNZ FPPF
	CMP	#1,B
	BEQ	AFNUM		;1 FOR FNUM
	.ENDC
	CMP #2,B
	BEQ NXTIDX	;2 FOR PTR
	ERROR+BAT
ALNUM:	BIS	#LNUM,F
	BR	NXTIDX
	.IFNZ FPPF
AFNUM:	BIS	#FNUM,F
	BR	NXTIDX
	.ENDC
NXTIDX:	JSR PC,G1NARG	;GET MAGNITUDE OF LAST DIMENSION
	PUSH	B		;SAVE THIS DIMENSION
	MUL	B,D		;D IS ODD
	BLE	AERROR		;DIMENSION < 0
	BCS	AERROR		;DIMENSION TOO BIG
	SOB	A,NXTIDX
	SPUSH	F		;SAVE DIMENSION OF ARRAY
	BIT	#160000,D	;SIZE SHOULD NOT BE TOO BIG
	BNE	AERROR
	CMP	#2,E		;IS THIS PTR ARRAY
	BEQ	.+4
	ASL	D		;THIS IS DOUBLE PRECISION ARRAY
	ASL	D		;TO CONVERT TO BYTES
	ADD	#HEADER,D
	SPUSH	D		;SAVE SIZE OF ARRAY BLOCK
	MOV	@S,B		;GET NAME OF ARRAY
	MOV	B,A		
	BIC	#7777,A		;SEE WHETHER IT HAS BEEN INTERNED?
	CMP	#ATOM,A		;BY TESTING ITS TYPE
	BEQ	FABIND		;YES
	CMP	#LSTR,A		;NO,IS NAME ALL RIGHT
	BEQ	.+4		;YES
	ERROR+WTAB
	MOV	B,TOPS
	JSR	PC,.INTRN	;INTERN NAME OF ARRAY
	MOV	B,@S		;SAVE UOE PTR
FABIND:	CLR	TOPS		;NOT TO CHANGE BINDING
	MOV	#ABIND,A	;SEE IF AN ARRAY IS
	JSR	PC,.BIND	;BINDED TO THIS NAME
	BEQ	GETSPA		;NO
	MOV	C,@S		,SAVE PTR TO BINDING NODE
	MOV	B,C
	MOV 2(C),B
	ADD	ASPACE,B	;ADDED TO AVAILABLE FREE SPACE
	CMP	B,@P		;IS SUM ENOUGH FOR NEW BINDING?
	BGE	ERAOLD		;YES
FULL:	ERROR+NAS		;NOT ENOUGH SPACE
ERAOLD:	MOV	C,B
	JSR	PC,.RELES	;RELEASE OLD BINDING

GETSPA: SPOP B	;GET SIZE OF ARRAY
	MOV B,D		;SAVE IT
	JSR	PC,..ALLOC	;ASSIGN SPACE
	BEQ	FULL		;NOT ENOUGH
	SPOPS	B		;UOE PTR
	MOV	A,TOPS		;ARRAY PTR
BINDA:	MOV	#ABIND,A
	JSR	PC,.BIND	;BIND NEW ARRAY
	BIC	#170000,C	;PTR TO BINDING NODE
	ASL	C
	ASL	C
	ADD	#NODESP+2,C	;THIS IS PHYSICAL ADDR OF BINDING NODE
	MOV	TOPS,A		;PTR TO ARRAY
	MOV	C,(A)+		;BACK PTR FIRST ENTRY IN HEADER
	MOV (A)+,D	;SIZE OF ARAY SECOND
	SPOP	F
	MOV	F,(A)+		;DIMENSION OF ARRAY THIRD
	ADD	#LIMIT*2,A	;TO ADVANCE (A)
	BIC	#177400,F	;GET DIMENSION PART
	MOV	F,E
	ASL	E		;TO GET IT INTO BYTES
	SUB	E,A		;FOR OFFSET INTO HEADER
POPDIM:	SPOP	(A)+
	SOB	F,POPDIM
	SUB #HEADER,D
	ASR D
	CLR (A)+	;ZERO ARRAY VALUES
	SOB D,.-2
	SEZ
	RTS	PC
ERARAY:	JSR	PC,GTUOEB	;GET NEXT TOKEN
	BNE	ERARA1
ERARA2:	CLR	TOPS
	MOV	#ABIND,A
	MOV	B,F
	JSR	PC,.BIND
	BEQ ERARAR
	JSR	PC,.RELES	;RELEASE ARRAY BLOCK
	MOV	F,B
	JSR PC,.UNBND
ERARAR:	SEZ
	RTS PC

ERARA1:	CMP	#UFUN,A
	BGT	.+4
	ERROR+ERW
	JSR	PC,CVSFLS
	MOV	#ATOM,A
	JSR	PC,.OBSCH
	BNE	ERARA2
ERARA3:	RTS PC


ERARAS:	JSR	PC,GNOLEI
ERARS1:	JSR	PC,GNOLE
	BEQ ERARAR
	MOV	B,F
	CLR	TOPS
	MOV	#ABIND,A
	JSR	PC,.BIND
	BEQ	ERARS1		;THIS NAME HAS NO ARRAY BINDING
	JSR	PC,.RELES	;RELEASE THIS ARRAYY
	MOV	F,B
	JSR	PC,.UNBND
	BR	ERARS1


;RETURNS SIZE OF ARRAY DIMENSIONS
ASIZEX:	MOV @S,A	;ARRAY NAME
	JSR PC,AMAKE	;FINDS TOP OF ARRAY SPACE
ASIZE2:	PUSH E
	MOV B,E
	MOVB 4(E),D	;TYPE/DIM WORD
	MOV D,F
	SPUSH D		;SAVE IT
	ASL D		;SETS UP OFFSET FOR DIMENSION WORD
	SUB D,E
	ADD #2,S	;POP OFF THE ARRAY NAME
	ADD #14,E	;ADDR. OF FIRST DIM.
ASIZE1:	MOV (E)+,B
	JSR PC,.CSNIN	;CONVERT TO INUM AND PUT IN NODE 
	SPUSHS C	;SAVE PTR ON S-PDL
	SOB F,ASIZE1	;CHECK FO MORE DIMS.
	SPOP D		;NO OF DIMS. IN D
	JSR PC,SENT.	;LINK DIMS. IN LIST
	POP E
	CLZ
	RTS PC


.IFNZ FPPF

;FLOATING POINT MACROS

.MACR FPUSH FF
	STF FF,-(P)
	JSR PC,PPUSHT
.ENDM

.MACR FPOP FF
	LDD (P)+,FF
	JSR PC,PPOPT
.ENDM

.ENDC


.IFZ FPPF

;SINGLE PRECISION ARITHMETIC ROUTINES

UPLUS:	CLZ	;UNARY PLUS - NOTHING TO DO
	RTS PC
UMINS:	JSR PC,G1IARG	;UNARY MINUS
	DPNEG	B,C
DONBC:	JMP	R1I.BC

SUM:
	EXCH (P),2(P)
	CLR	E
	CLR	F
	MOV	(SP)+,D	;NUMBER OF ARGS
	BLE	DIFF.2	;DONE
SUM.1:	JSR	PC,G1IARG	;GET 1 INTEGER
	DPADD	B,C,E,F
	DEC	D	;COUNTER
	BGT	SUM.1
	BR	DIFF.2	;DONE

DIFF:
	JSR	PC,G2IARG	;GET 2 INTEGERS
	DPSUB	B,C,E,F
DIFF.2:	CMP	E,#100000	;IS ANSWER = 100...00 ?
	BNE	DONEMP
	TST	F	;IF SO , THEN ERROR
	BNE	DONEMP
	ERROR+RTB	;SINCE THAT IS SMALLEST NEG NUMBER
DONEMP:	JMP	R1I.EF

PROD:
	EXCH (P),2(P)
	CLR	E
	MOV	#1,F
	MOV	(SP)+,D	;NUMBER OF ARGS
PROD.1:	DEC	D
	BLT	DONEMP	;DONE
	JSR	PC,G1IARG	;GET ONE ARG IN B
	JSR	PC,.DPMUL
	BNE PROD.1
	ERROR+RTB	;RESULT TOO BIG

MOD:
	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONBC
	ERROR+RTB

DIVDE:
DIV.1:	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONEMP
	ERROR+RTB


.ENDC


.IFNZ FPPF


;FLOATING POINT ARITHMETIC ROUTINES

ERRET:	ERROR+RTB
UPLUS:	CLZ
	RTS PC
UMINS:	MOV #INUM,F
	JSR PC,G1ARG
	LDD FA,FB
	NEGF FB
	BR .FSTOR	;STORE FB
DIFF:	JSR PC,G2ARG	;LOAD FA AND FB
	SUBF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
SUM:	EXCH (P),2(P)
	MOV #INUM,F
	CLRF FB
	SPOP D		;SET UP COUNTER
	BLE .FSTOR
SUM.1:	JSR PC,G1ARG	;GET A NUMBER
	ADDF FA,FB	
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT SUM.1	;ADD MORE NUMBERS
	BR .FSTOR	;DONE AT LAST
PROD:	EXCH (P),2(P)
	MOV #INUM,F
	LDCFD #40200,FB	;LOAD CONSTANT "1"
	SPOP D
	BLE .FSTOR	;DONE ALREADY
PROD.1:	JSR PC,G1ARG
	MULF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT PROD.1	;LOOK AT COUNTER

;THIS TAKES A NUMBER OUT OF FB AND
;CONVERTS IT ACCORDING TO TYPE IN REG F (INUM,FNUM)
;AND RETURNS

.FSTOR:CMP #FNUM,F	;FNUM OR INUM?
	BEQ .FST.2
	STCFI FB,-(P)	;PUT INUM ON STACK
	BCS ERRET	;OVERFLOW?
.FST.1:	SPOP A
	SPOP B
	JSR PC,GRBAD	;STORE ANSWER
	BIS F,C		;SET TYPE
	JMP ORTC
.FST.2:	STCDF FB,-(P)	;PUT FNUM ON STACK
	JMP .FST.1
DIVDE:	JSR PC,G2ARG	;GET ARGS
	TSTF FA		;TEST ZERO DIVIDE
	CFCC
	BEQ ERRET	;IT WAS!!??
	DIVF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
MOD:	JSR PC,G2ARG	;GET ARGUMENTS IN FA AND FB
	SPUSH #.FSTOR
.MOD:	TSTF FA		;IS FA 0?
	CFCC
	BEQ ERRET	;IT IS??
	LDD FB,FC	;FC <- FB
	DIVF FA,FC	;FC <- (FB/FA)
	CFCC
	BVS MOD2	;THE ANSWER IS 0
	MODD #40200,FC	;SEPERATE INTEGER AND FRACTION PARTS
	MULF FA,FD	;FD <- FA * (INT (FB/FA))
	SUBF FD,FB	;FB <- MOD (FB,FA)
MOD1:	CFCC
	BGE MOD3	;IS IT POSITIVE?
	ADDF FA,FB	;NO, ADD FA
	BR MOD1
MOD2:	CLRF FB
MOD3:	RTS PC


SQRT:	JSR PC,G1NUM
	BNE .+4
SQRT1:	ERROR+WTA
	TSTF FA
	CFCC
	BMI SQRT1
	BEQ SQRTRT
	LDF FA,FB
	STEXP FA,A
	LDEXP #0,FA
	ASR A
	ADC A
	ADDF #40000,FA
	BCS .+6
	ADDF #40000,FA
	CLRF FC
	LDEXP A,FC
	MULF FC,FA
	MOV #4,A
SQRTLP:	LDF FB,FC	;FC <= X
	DIVF FA,FC	;FC <= X/Y
	ADDF FC,FA	;FA <= Y + X/Y
	MULF #40000,FA	;FA <= 1/2 * (Y + X/Y)
	SOB A,SQRTLP
SQRTRT:	MOV #FNUM,F
	STCDF FA,-(P)
	JMP .FST.1
.ENDC





SENTENCE:
	SPOP EXCH1
	MOV (SP),D
	MOV EXCH1,(SP)	;# OF ARGS . DON'T CHANGE FROM D WITHOUT CHANGING SNAP!!!!
SENT.:	CLR	C
	TST	D
SENT.1:	BLE	SENT.R	;RETURN
	MOV	@S,B	;ARGUMENT.  LEAVE ON S-PDL FOR GARBGE COLLECTOR
	MOV	B,A
	BIC	#7777,A	;LEAVE ONLY DATA TYPE
	CMP	#LIST,A
	BEQ	SENT.S	;ARG IS LIST
	CMP	#ATOM,A
	BNE	SENT.2	;ARG IS LSTR OR INUM

;ARG IS AN ATOM
SENT.A:	JSR	PC,.LOAD	;CONVERT ATOM TO LSTR
	MOV	#LSTR,A

SENT.2:	BIS	C,A	;C POINTS TO PREVIOUS STUFF OF SENTENCE
	JSR	PC,GRBAD

SENT.3:	MOV	C,GCPREV	;POINTER TO PREVIOUS STUFF OF SENTENCE
	BIS	#LIST,GCPREV	;GARBAGE COLLECTOR NEEDS RIGHT DATA TYPE
SENT.4:	JSR	PC,SPOPT	;POP S
	DEC	D	;COUNTER
	BR	SENT.1

SENT.S:	BIT	#7777,B	;ARGUMENT IS A LIST
	BEQ	SENT.4	;EMPTY
	TST	C	;0 IF FIRST TIME CALLED
	BEQ	SENS.1	;NO NEED TO COPY
;SECOND OR LATER TIME THROUGH
SENS.2:	JSR	PC,COPYL	;COPY LIST. RETURN POINTER IN B
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;C STILL POINTS TO LAST NODE COPIED
SENS.1:	BIC	#170000,B	;LEAVE POINTER ONLY
	MOV	B,C
	BR	SENT.3

;RETURN.  POINTER TO SENTENCE IN C
SENT.R:	BIS	#LIST,C
	CLR	GCPREV
	PUSHS	C
	CLZ
	RTS	PC



LIST.P:
	EXCH (P),2(P)
	MOV	(SP),D	;COUNT
	MOV	#ORTC,(SP)	;RETURN ADDRESS
LIST1:	CLR	C
LIST.1:	DEC	D	;COUNT
	BLT	LIST.9	;DONE
	MOV	@S,B
	MOV	B,A
	BIC	#7777,A	;LEAVE DATA TYPE ONLY
LIST.2:	BIS	C,A	;POINTER TO REST OF LIST
	JSR	PC,GRBAD
	MOV	C,GCPREV	;PROTECT FROM GARBAGE COLLECTOR
	BIS	#LIST,GCPREV	;GAR. COLL. NEEDS RIGHT DATA TYPE
	JSR	PC,SPOPT
	BR	LIST.1	;GET NEXT ARG

LIST.9:	CLR	GCPREV
	BIS	#LIST,C
	RTS	PC


FPUT:
	CLR	F
	BR	.+6
LPUT:
	MOV	#<LPUT1-FPUT1>,F
	EXCH (P),2(P)
	MOV	(SP),D	;NUMBER OF ARGS
	MOV	#ORTC,(SP)	;RETURN ADDRESS
	DEC	D
	BGT	.+4
	ERROR+UEL	;NEED AT LEAST 2 ARGS
	JSR	PC,GLWARG
	BEQ	.+4	;LIST
	ERROR+WTA	;FIRST ARG MUST BE LIST
	ADD	F,PC	;CHOOSE BETWEEN LPUT AND FPUT

FPUT1:	MOV	B,A	;POINTS TO ARG
	BIC	#170000,A	;CLEAR DATA TYPE
	JSR	PC,SPOPT
	MOV	@S,B	;FIRST ELEMENT TO BE PUT
	MOV	B,C
	BIC	#7777,C	;THIS DATA TYPE WILL BE SET INTO A
	DEC	D
	BR	LIST.2

LPUT1:	JSR	PC,COPYL	;COPY LIST. RETURN PTR IN B
	MOV	B,GCP1
	JSR	PC,SPOPT	;POP 1ST ARG
	JSR	PC,LIST1	;LIST REST OF ARGS
	TST F
	BEQ LPUT2
	BIC	#170000,C	;POINTER TO THAT LIST
	MOV	C,D	;SAVE IT
	MOV	F,C	;POINTER TO LAST NODE OF COPIED LIST
	JSR	PC,.LDP1
	BIS	D,A	;JOIN COPIED LIST TO LIST OF ARGS
	JSR	PC,.STP1
	MOV	GCP1,C
LPUT2:	CLR	GCP1
	RTS	PC


WORD:
	EXCH (P),2(P)
	CLR	C
	MOV	(SP)+,D	;NUMBER OF ARGS
WORD.1:	BLE	WORDR
	MOV	@S,B	;GET ARG,  BUT LEAVE ON STACK

.IFZ FPPF
	CMP	B,#LNUM	;IS ARG NUMBER?
	BLO	WORD.2
	CMP	B,#<LNUM+10000>
	BLO	WORD.N	;NUMBER
.IFF
	MOV B,A		;DOES B POINT TO INUM OR FNUM
	BIC #170000,A
	CMP #INUM,A
	BEQ WORD.N
	CMP #FNUM,A
	BEQ WORD.N
.ENDC

WORD.2:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE .+4
	ERROR+WTAB
	BIT	#7777,B	;IS ARG THE EMPTY WORD
	BEQ	WORD.4	;YES

	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3

;SECOND OR LATER ARG
WORD.5:	JSR	PC,CPYSTR	;COPY STRING
WORD.6:	JSR	PC,.LDP1	;LAST NODE OF COPIED STRING
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;BIS POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;STORE BACK

WORD.3:	BIC	#170000,B
	BIS	#LSTR,B	;GAR. COLL. NEEDS RIGHT DATA TYPE
	MOV	B,GCPREV	;POINTER TO PREVIOUS STUFF
WORD.4:	JSR	PC,SPOPT	;POP S
	DEC	D
	BR	WORD.1

;ARGUMENT IS NUMBER. CONVERT TO STRING
WORD.N:
.IFZ FPPF
	JSR PC,.CINLS
.IFF


.CLNLS:	MOV B,A
	BIC #170000,A
	CMP #INUM,A
	BEQ .CLNL1
	JMP .CINLS
.CLNL1:	JMP .CFNLS
.ENDC
	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3	;IS FIRST ARG
	BR	WORD.6	;SECOND OR LATER, BUT DON'T RECOPY!!

;RETURN
WORDR:	MOV	GCPREV,C
	BIS	#LSTR,C
	CLR	GCPREV
	JMP	ORTC



FIRST:
	JSR	PC,GLWANE
	BEQ	F.SENT	;ARG IS SENTENCE

;ARG IS WORD
	JSR	PC,INSTR	;RETURN ONE CHAR IN D
	BNE	.+4	;FOUND A CHAR
F.WTA:	ERROR+WTA	;NO CHARS IN STRING
	TST	(SP)+	;POP OFF CO-ROUTINE LINK
	MOV	D,B
F.STOR:	CLR	F
	JSR	PC,ACTSTO	;STORE THE CHAR.
	POPS C
	BIC #170000,C
	BIS	#LSTR,C	;POINTER TO THE NODE OF THE CHAR
	JMP	ORTNC

F.SENT:	MOV	B,C
	JSR	PC,.LDP2
	JMP	ORTNA


BUTFIRST:
	JSR	PC,GLWANE
	BEQ	BF.SEN

;ARG IS WORD
BF.W:	JSR	PC,INSTR	;RETURN ONE CHAR
	BEQ	F.WTA	;NO CHARS IN STRING
	TST	(SP)+
;A CONTAINS FIRST 2 CHARS OF THE STRING
;BUT IT MAY ONLY HAVE ONE.
	BIT	#177,A	;IS TOP CHAR OF A 0?
	BEQ BF.W1
	BIT #77400,A
	BEQ	BF.W1	;YES. ONLY ONE CHAR IN A
	CLRB	A	;KILL THE FIRST CHAR
	MOV	A,B
	MOV	C,A	;POINTER TO REST
	JSR	PC,GRBAD
BF.W1:	BIC	#170000,C
	BIS	#LSTR,C
	JMP	ORTNC

;ARG IS SENTENCE
BF.SEN:	MOV	B,C
	JSR	PC,.LDP1	;POINTER TO REST OF SENTENCE
	BIC	#170000,A	;LEAVE ONLY POINTER
	BIS	#SENT,A
	JMP	ORTNA


LAST:
	JSR	PC,GLWANE
	BEQ	L.SENT	;ARG IS SENTENCE

;ARG IS WORD
	MOV	B,C
	SPUSH	#INSTR1	;ADDRESS OF CO-ROUTINE
	CLR	D
L.W1:	MOV	D,B	;SAVE LAST CHAR
	JSR	PC,@(SP)+	;RETURNS CHAR IN D
	BNE	L.W1	;FOUND ONE
	TST	B	;STRING DONE
	BNE	F.STOR	;STORE THE CHAR AND RETURN
	ERROR+WTA	;NO CHARS FOUND

L.SEN1:	MOV	A,B
;ARG IS SENTENCE
L.SENT:	JSR	PC,.LOAD
	BIT	#7777,A	;LAST NODE OF SENTENCE YET?
	BNE	L.SEN1

L.SRET:	JMP	ORTNB


BUTLAST:
	JSR	PC,GLWANE
	BEQ	BL.SEN	;ARG IS A SENTENCE

;ARG IS A WORD
	JSR	PC,CPYSTR	;COPY STRING.
	JSR	PC,.LDP2	;LAST NODE OF NEW STRING
	SWAB	A
	BNE	BL.W2	;THE LAST CHARACTER IS REALLY THERE
	CLR	A	;(WE KNOW THE FIST CHAR IS REALLY THERE)
	CMP	B,C	;IS THERE ONLY ONE NODE
	BNE	BL.W1	;MORE TAN ONE NODE
	CLR	B	;ANSWER IS EMPTY WORD
	BR	BL.W3

BL.W2:	CLRB	A	;CLEAR LAST CHAR
BL.W1:	JSR	PC,.STP2	;STORE NODE BACK
BL.W3:	BIS	#LSTR,B	;POINTER TO THE WORD
BL.ORT:	JMP	ORTNB

;ARG IS A SENTENCE
BL.SEN:	JSR	PC,COPYL	;COPY LIST
	MOV	E,C	;POINTS TO NEXT TO LAST NODE
	BEQ	BL.SR	;ANSWER IS EMPTY
	JSR	PC,.LDP1
	BIC	#7777,A
	JSR	PC,.STP1
	MOV	B,C
BL.SR:	BIS	#LIST,C
	JMP	ORTNC


;INPUT IS NUMBER. OUTPUT IS THE CHARACTER CORRESPONDING TO THAT NUMBER

CHAR:	JSR	PC,G1IARG	;B,,C _ NUMBER
	MOV	C,B
	BIC	#177600,B
	MOV	#SSTR,A
	JSR	PC,GRBAD
	BIS	#LSTR,C
	JMP	ORTC


COUNT:
	JSR	PC,GLWARG
	BEQ	CT.SEN

;ARG IS WORD
	MOV	B,C
	CLR	B
	MOV	#INSTR1,-(SP)	;ADDRESS OF A CO-ROUTINE
CT.W1:	INC	B	;INCREMENT COUNTER
	JSR	PC,@(SP)+	;RETURNS CHAR IN B
	BNE	CT.W1
	DEC	B	;WHEN RETURNS HERE, NO MORE CHARS
CT.ORT:	POPS C
	JMP R1NARG	;C IS A THROW-AWAY

;ARG WAS A SENTENCE
CT.SEN:	MOV	B,C
	JSR	PC,CLE	;RETURNS NUMBER OF LIST ELEMENTS IN B
	BR	CT.ORT


;COPY LIST.
;	CALL WITH B POINTING TO LIST
;	RETURNS B POIOTING TO NEW LIST, C POINTING TO LAST NODE
COPYL:	CLR	E	;WILL POINT TO 2ND NODE FROM LAST
	CLR	F
	BIT #7777,B
	BEQ COPYR1
COPYL1:	BIT	#7777,B
	BEQ	COPYLR	;DONE
	JSR	PC,.LOAD
	MOV	F,E	;LISTB PLACES  LAST NODE PTR INTO F
	JSR	PC,LISTB
	MOV	A,B
	BR	COPYL1

COPYLR:	MOV F,C	;LISTB KEEPS PTR TO LAST NODE OF LIST IN F
	POPS	B	;LISTB KEEPS POINTER TO NEW LIST ON S.
COPYR1:	RTS	PC


;COPY STRING
;CALL WITH B POINTING TO STRING TO BE COPIED,
;ASSUMES THAT INPUT STRING HAS BEEN GARBAGE COLLECT PROTECTED ALREAEDY
;B POINTS TO FIRST NODE OF NEW STRING,  C POINTS TO LAST

CPYSTR:	MOV	#INSTR,A
MAKSTR:	MOV	D,-(SP)
	MOV	E,-(SP)
	MOV	F,-(SP)

	MOV	A,-(SP)	;ADDRESS OF INPUT STRING ROUTINE
	CLR	F

OUTSTR:	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE1	;INPUT STRING DONE

OSTR1:	MOV	D,B	;SAVE CHARACTER
	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE2	;INPUT STRING DONE

OSTR2:	SPUSH	A	;SAVE REGISTERS USED BY INPUT STRING
	SWAB	D
	BIS	D,B	;BIS SECOND CHARACTER
	JSR	PC,ACTSTO	;ACTUAL STORE
	SPOP	A
	BR	OUTSTR

;INPUT STRING HAS ENDED
OSTRE2:	JSR	PC,ACTSTO	;STORE CHAR IN B
OSTRE1:	POPS	B	;POINTER TO FIRST NODE OF STRING
	MOV	F,C	;POINTER TO LAST NODE
	BIC	#170000,B
	BIC	#170000,C
.RDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	SEZ
OSTRR:	RTS	PC


;ACTUALLY STORE OUTPUT NODE
ACTSTO:	MOV	#SSTR,A
	JMP	LISTB


;INPUT STRING
;A CO-ROUTINE THAT HANDS BACK A CHARACTER IN BOTTOM BYTE OF D
;DOES RTS PC WHEN INPUT STRING FINISHED

INSTR:	MOV	B,C
INSTR1:	BIT	#7777,C
	BEQ	OSTRR	;RTS PC
	JSR	PC,.LDP2I
	MOVB	A,D
	BIC	#177600,D	;CLEAR TOP BYTE
	BEQ	INSTR2	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE

INSTR2:	CLRB A
	SWAB	A
	MOV	A,D
	BIC #177600,D
	BEQ	INSTR1	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE
	BR	INSTR1


;LIKE INSTR, EXCEPT GETS CHAR FROM TEXT STRING (NOT NODE SPACE)
;NOTE -- ENTER AT INTXT
INTXT0:	JSR	PC,@(P)+
INTXT:	MOVB	(C)+,D
	BNE	INTXT0	;BR IF NOT END OF TEXT
	RTS	PC

MAKE:	BIC #MMF,FLAGS2
	BR .+10
MMAKE:	BIS #MMF,FLAGS2
	POPS TOPS	;PUT VALUE INTO TOPS
	MOV @S,B
	MOV B,A
	BIC #7777,A
	CMP #ATOM,A	;IS TYPE ATOM?
	BNE MAKE2
MAKE4:	MOV #VBIND,A	;YES< SET VARIABLE BINDING?
	JSR PC,.BIND
	BIT #MMF,FLAGS2	;IS IT MULTIPLE MAKE?
	BEQ MAKE1
	MOV TOPS,@S
	CLR TOPS
	CLR TOPS1
	CLZ
	RTS PC
MAKE1:	POPS A
	CLR TOPS
	CLR TOPS1
	RTS PC
MAKE2:	CMP #LSTR,A
	BEQ MAKE3
MAKE5:	ERROR+WTAB	;WRONG TYPE OF ARG
MAKE3:	BIT #7777,B
	BEQ MAKE5
	MOV TOPS,@S
	MOV B,TOPS	;FOR .INTRN
	JSR PC,UINTRN	;.INTRN FOR STRINGS THAT MAY INCLUDE NULL CHARS
	MOV @S,TOPS
	BIS #ATOM,B
	MOV B,TOPS1
	BR MAKE4

DOTS:	JSR PC,GETVAL	;GET VALUE IF IT HAS ONE
	BNE .+4
	ERROR+HNV	;HAS NO VALUE
	PUSHS B
	CLR TOPS
	CLZ
	RTS PC

THINGP:	JSR PC,GETVAL	;DOES IT HAVE A VALUE?
	BEQ THNGPF	;NO
	JMP RTTRUE
THNGPF:	JMP RTFALS

GETVAL:	JSR PC,GUOEB	;GET UOE PTR FROM S INTO B
	BEQ GETVA1
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ GETVA1
	TST B
GETVA1:	RTS PC		;HAS NO VALUE (UNBOUND LOCAL)
GUOEB:	POPS B	;GET UOE OR LSTR IN B FROM S
	MOV B,A	;    SKIP IF UOE
	BIC #7777,A
	CMP #ATOM,A
	BEQ GUOE1
	CMP #LSTR,A
	BEQ GUOE2
	ERROR+WTAB	;.(B). ISWRONG TYPE OF ARG
GUOE2:	MOV B,TOPS
	JMP UOBSCH	;.OBSCH FOR STRINGS THAT HAVE NULL CHARS
GUOE1:	CLZ
	RTS PC
		;PRINT TOP (C) THINGS ON S
FPRINT:	INC NBKTS	;PRINTS OUTER [,]'S
PRINT:	EXCH (P),2(P)
	JSR	PC,REVS	;DOESNT "
	POP	C
	JSR	PC,TYPE1
	JSR	PC,.CRLF
	SEZ
	RTS PC

TYPE:	EXCH (P),2(P)
	JSR	PC,REVS
	POP	C
	JSR	PC,TYPE1	;PRINT WITHOUT CRLF AT END
	SEZ
	RTS PC

TYPE1:	BIS #DPQF+CPTBF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
			;BUT DO  PRINT % AS BLANK
	JSR PC,PRS1
	POPS A
	DEC C
	BGT	TYPE1
	BIC #DPQF+CPTBF,FLAGS2
	RTS	PC

;PREDICATES

EQUAL:	MOV	S,F
	MOV	(F)+,B	;ARG1.  LEAVE ON STACK FOR GC PROTECTION
	MOV	(F),C	;ARG2
	JSR	PC,EQUAL1
	BEQ	EQ.F	;RETURNS HERE IF FALSE
	ADD #4,S
	JMP RTTRUE
EQ.F:	ADD #4,S
	JMP RTFALS


;COMPARE THE DATA ITEM POINTED TO BY B WITH
;THE DATA ITEM POINTED TO BY C.
;SKIP IF THEY ARE EQUAL
EQUAL1:	MOV #7777,E	;AN OFT-USED CONSTANT
	MOV B,A
	MOV C,D
	BIC E,A
	BIC E,D
	CMP A,D
	BNE WEQUAL
	CMP #LIST,A
	BNE WEQUAL
EQ.LST:	BIC #170000,B
	BIC #170000,C
	CMP B,C
	BEQ EQTRUE
	TST B
	BEQ EQFALS
	TST C
	BEQ EQFALS
	JSR PC,.LOAD
	PUSH A
	JSR PC,.LDP2I
	SPUSH C
	MOV A,C
	JSR PC,EQUAL1
	BEQ EQ.FF
	POP B
	SPOP C
	BR EQ.LST

	FOR 0
EQUAL1:	CMP	B,C	;ARE THE POINTERS THE SAME
	BEQ	EQTRUE
	MOV	B,A
	JSR	PC,EQ.SUB	;IS ARG1 A WORD?
	BNE	EQ.W1	;A WORD
	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BNE	EQFALS	;ARG1 ISN'T WORD, BUT ARG2 IS.
;BOTH ARGS ARE LISTS
EQ.LST:	JSR	PC,.LOAD	;FIRST NODE OF ARG1
	PUSH	A	;SAVE POINTER TO BF
	JSR	PC,.LDP2I	;FIRST NODE OF ARG2
	SPUSH	C	;SAVE POINTER TO BF
	MOV	A,C	;POINTER TO FIRST OF ARG1
;B POINTS TO FIRST ARG2.  C POINTS TO FIRST ARG1.
	JSR	PC,EQUAL1	;ARE THE FIRSTS EQUAL?
	BR	EQ.FF	;NO.  RETURN FALSE
	POP	B	;POINTER TO BF
	SPOP	C	;POINTER TO BF OF OTHER ARG
	BIC	#170000,B
	BIC	#170000,C
	CMP	B,C
	BEQ	EQTRUE
	JSR	PC,EQ.LST	;ARE THE BF'S EQUAL?
EQFALS:	RTS	PC	;NO
EQTRUE:	CLZ
	RTS PC	;YES


EQ.SB1:	MOV	C,A	;IS ARG A WORD?
EQ.SUB:	BIT	E,A	;EMPTY?
	BEQ	EQFALS	;ONE ARG FINISHED
	BIC	E,A
	CMP	#SENT,A
	RTS	PC

;ARG1 IS A WORD
EQ.W1:	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BEQ	EQFALS	;NOT A WORD
;FALLS INTO WEQUAL
	.ENDC
	ENDC 0
EQ.FF:	CMP	(SP)+,(SP)+	;POP OFF THE POINTERS TO THE BF'S
	JSR PC,PPOPT
	SEZ
	RTS PC

;COMPARE TWO WORDS

.IFZ FPPF

WEQUAL:	MOV	#INUM,A
	JSR	PC,CONVERT	;TRY CONVERTING ARG TO INUM
	BEQ	EQ.STR	;NOT NUMERIC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG
	BEQ	EQFALS	;NOT NUMERIC
	JSR	PC,.LOAD	;A,,B HAVE NUMBER
	MOV	A,D
	MOV	B,F
	JSR	PC,.LOADC
	CMP	A,D	;COMPARE 2 INTEGERS
	BNE	EQFALS
	CMP	B,F
	BNE	EQFALS
	BR	EQTRUE
.IFF

WEQUAL:	JSR PC,G1NUMS	;IS IT A NUMBER?
	BEQ EQ.STR
	LDD FA,FB	;IT WAS SO SAVE IT
	MOV C,B		;IS THE SECOND A NUM?
	JSR PC,G1NUMS
	BEQ EQFALS
	CMPF FA,FB	;COMPARE THEM
	CFCC
	BNE EQFALS
	BR EQTRUE

.ENDC


;ARG NOT NUMERIC.  TRY STRING COMPARE
EQ.STR:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BEQ EQFALS	;EQUAL NOT DEFINED FOR SNAPS, ETC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG, TOO
	BEQ	EQFALS	;NOT SAME TYPE AS FIRST ARG
	CMP	B,C
	BEQ	EQTRUE

;COMPARE TWO STRINGS.  POINTERS IN B AND C.
	SPUSH	#INSTR1
	MOV	C,GCP2
CMPSTR:	MOV	B,GCP1
	MOV	B,F
CMPST1:	BIT	E,F	;IS ARG 1 ENDED
	BEQ	CMPSTE	;YES
	SPUSH	A	;SAVE A
	MOV	F,B	;POINTER TO REST OF ARG1
	JSR	PC,.LOAD
	MOV	A,F	;POINTER TO REST OF ARG1
	SPOP	A	;RESTORE A
	BICB #200,B	;IS CHAR REAL OR NULL?
	BEQ	CMPST2	;NULL
	JSR	PC,@(SP)+	;PUTS 1 CHAR OF ARG 2 INTO B
	BEQ	CSFAL1	;ARG 2 ENDED
	CMPB	D,B	;COMPARE CHARS!!
	BNE	CSFALS
CMPST2:	SWAB	B
	BIC #177600,B
	BEQ	CMPST1	;NULL CHAR
	JSR	PC,@(SP)+	;1 CHAR OF ARG 2 IN B
	BEQ	CSFAL1
	CMPB	D,B	;COMPARE CHARS!!
	BEQ	CMPST1
CSFALS:	TST	(SP)+	;POP CO-ROUTINE LINKAGE
CSFAL1:	CLR	GCP1
	CLR	GCP2
EQFALS:	SEZ
	RTS PC

;ARG 1 HAS ENDED
CMPSTE:	JSR	PC,@(SP)+
	BNE	CSFALS	;BUT ARG 2 HASN'T ENDED
	CLR	GCP1
	CLR	GCP2
EQTRUE:	CLZ
	RTS PC	;BOTH ENDED AT THE SAME TIME!!!!



;CALL WITH B = POINTER TO STRING IN NODE SPACE
;	C = POINTER TO STRING IN DATA SPACE
EQ.TXT:	SPUSH	#INTXT	;ADDRESS OF CO-ROUTINE
	MOV	#7777,E	;AN OFT USED CONSTANT
	BR	CMPSTR



;MORE PREDICATES

GREATR:	JSR PC,CMP2IA
	BGT RTTRUE
RTFALS:
LANGC	<PUSHS #FALSE>,<
	PUSHS #FAUX>
RTNCMP:	CLZ
	RTS PC

LESSP:
LESS:	JSR PC,CMP2IA
	BGE RTFALS
RTTRUE:
LANGC	<PUSHS #TRUE>,<
	PUSHS #VRAI>
	BR RTNCMP

GREQ:	JSR PC,CMP2IA
	BGE RTTRUE
	BR RTFALS

LSEQ:	JSR PC,CMP2IA
	BLE RTTRUE
	BR RTFALS

NUMBP:	POPS B
 	MOV #INUM,A
	JSR	PC,CONVERT
.IFZ FPPF
	BEQ	RTFALS	;COULDN'T CONVERT IT
	BR RTTRUE
.IFF
	BNE RTTRUE
	MOV #FNUM,A
	JSR PC,CONVERT
	BEQ RTFALS
	BR RTTRUE
.ENDC

EMPTYP:	POPS B
	BIT	#7777,B
	BEQ	RTTRUE
	BR	RTFALS

LISTP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTTRUE
	BR	RTFALS

WORDP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTFALS
	BR	RTTRUE

.IFZ FPPF

;COMPARE TWO INTEGER ARGUMENTS
CMP2IA:	JSR	PC,G2IARG
;COMPARE 2 INTEGERS IN B,,C & E,,F
.ENDC
CMP2I:	CMP	E,B
	BNE	CMP2IR	;CONDITION CODES SET CORRECTLY
	CMP	F,C
	BEQ	CMP2IR
	BHI	CMP2IH
;E,,F < B,,C
	CMP	#0,(PC)
	RTS	PC
CMP2IH:	TST	(PC)
CMP2IR:	RTS	PC





.IFNZ FPPF


;GET AND COMPARE TWO (FNUM OR INUM) ARGS


CMP2IA:	SPUSH A
	JSR PC,G2ARG
	SPOP A
	CMPF FB,FA
	CFCC
	RTS PC

INTEGER:
	MOV @S,B
	MOV #INUM,A
	JSR PC,CONVERT
	BNE .+4
	ERROR+WTA
	MOV B,@S
	CLZ
	RTS PC


.ENDC


NOT:	JSR	PC,TSTST	;TEST S SKIP IF TRUE
	BEQ	RTTRUE
	BR	RTFALS

BOTH:	JSR	PC,TSTST
	BNE EITH1
	JSR PC,SPOPT
BOTH1:	BR RTFALS
EITH1:	JSR	PC,TSTST
	BEQ	BOTH1
	BR	RTTRUE	;BOTH ARE "TRUE !!

EITHER:	JSR	PC,TSTST
	BEQ	EITH1	;IS 2ND ONE "TRUE?
	JSR	PC,SPOPT	;POP 2ND ARG
	BR	RTTRUE
TEST:	JSR PC,TSTST	;IS TOP OF S "TRUE"?
	BEQ TES1	;NO, CLEAR FLAG
	BIS #TSTFLG,FLAGS	;YES, SET FLAG
	BR IFR
TES1:	BIC #TSTFLG,FLAGS
	BR IFR
IFTRUE:	BIT #TSTFLG,FLAGS	;FLAG SET?
	BNE IFR	;YES, CONTINUE
IFT1:	CLR CT	;NO, MAKE GNT THINK LINE HAS ENDED
	CLR CT+2
	RTS PC
IFFALS:	BIT #TSTFLG,FLAGS	;FLAG CLEARED?
	BEQ IFR	;YES, CONTINUE
	BR IFT1	;NO STOP
UNTIL:	JSR PC,TSTST
	BNE IFR
	JMP GOUNTL
IF:	INC IFLEV
	JSR PC,TSTST	;TEST S, SKIP IF "TRUE"
	BNE IFR
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	BIC #RTF,FLAGS
	DEC IFLEV
IFR:	SEZ
	RTS PC
THEN:	TST IFLEV
	BGT IFR
	ERROR+OOP	;THEN OUT OF PLACE
ELSE:	DEC IFLEV
	BGE .+4
ELSE1:	ERROR+OOP	;ELSE OUT OF PLACE
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	TST IFLEV
	BLE ELSE1
	BR IFR
STNE:	;SCAN TOO NEXT ELSE, CR OR UNMATCHED );
	;  SET RTF.  SKIP IIF "ELSE"
	JSR PC,GNT
	CMP #$RPAR,B
	BNE STNE4
	DEC NOPAR
	BGE STNE
	BIS #RTF,FLAGS
	SEZ
	RTS PC
STNE4:	CMP #$LPAR,B
	BNE STNE5
	INC NOPAR
	BR STNE
STNE5:	TST NOPAR
	BGT STNE
	.IFNZ ENG
	CMP #$ELSE,B
	BEQ STNE6
	.ENDC
	.IFNZ FR
	CMP #$SINON,B
	BEQ STNE6
	.ENDC
STNE1:	BIT #CRF,FLAGS
	BEQ STNE2
STNE3:	BIS #RTF,FLAGS	;IF "CR" SET RTF AND RETURN
	BIC #CRF,FLAGS
	SEZ
	RTS PC
STNE6:	BIS #RTF,FLAGS	;IF "ELSE", SET RTF AND SKIP RETURN
	RTS PC
STNE2:	.IFNZ ENG
	CMP #$IF,CT+2	;IF "IF", LOOK FOR NEXT ELSE!
	BEQ STNE7
	.ENDC
	.IFNZ FR
	CMP #$SI,CT+2
	BEQ STNE7
	.ENDC
	BR STNE
STNE7:	JSR PC,STNE
	BEQ STNE3
	BIC #RTF,FLAGS
	BR STNE
TSTST:	.IFNZ ENG
	MOV	@S,B		;TEST S, SKIP IF TRUE
	CMP	B,#FALSE
	BEQ	TSTF9	;IT'S "FALSE
.ENDC
.IFNZ FR
	CMP B,#FAUX
	BEQ TSTF9
.ENDC
.IFNZ ENG
	MOV	#TRUE,C	;ERROR IF NEITHER "TRUE" OR "FALSE"
	JSR	PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #VRAI,C
	JSR PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ ENG
	MOV	@S,B
	MOV	#FALSE,C
	JSR	PC,EQUAL1
	BNE TSTF9
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #FAUX,C
	JSR PC,EQUAL1
	BNE TSTF9
.ENDC
	ERROR+NTF	;NOT "FALSE, EITHER
TSTF9:	JSR	PC,SPOPT
	SEZ
	RTS	PC	;"FALSE!!
TESTIT:	JSR	PC,SPOPT
	CLZ
	RTS PC	;"TRUE!!
REVS:	CMP #1,2(P)	;REVERSES THE TOP ((P)+2) THINGS ON S
	BLT .+4	;IF <2 QUIT
	RTS PC
	CMP #MAXARG,2(P)
	BGE .+4
	.BUG.	;BARF, WHO ASKED REVS TO SWITCH > 32 THINGS?
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV 10.(P),C	;GET # TO BE SWITCHED
REVS5:	MOV S,A	;COMPUTE ADDR OF WORD JUST BEYOND BLOCK
	MOV C,B
	ASL B
	ADD A,B
	CMP #IS,B	;SHOULD WE FORCE A SWAPIN?
	BLO REVS4	;YES
	ASR C
	BEQ REVS1
REVS2:	MOV @A,D
	MOV -(B),(A)+
	MOV D,@B
	DEC C
	BGT REVS2
REVS1:	JMP RETD
REVS4:	JSR PC,SPSWPI	;SWAP S PDL BACK IN
	BR REVS5
.STITL DOUBLE PRECISION INTEGER ARITHMETIC
.IFZ FPPF

;INTEGER MULTIPLICATION

;CALL WITH ONE DOUBLE PRECISION ARGUMENT IN B,,C
;AND THE OTHER IN E,,F
;RETURNS PRODUCT IN E,,F.
;ALL OTHER ACCUMULATORS (INCLUDING B,C ARE UNCHANGED)

.DPMUL:	SPUSH	A	;SAVE A
	CLR	A
DVML:	PUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F
	PUSH B		;STUFF ABS(B,,C)
	SPUSH C
	SPUSH E		;AND ABS(E,,F)
	SPUSH F
	CLR	-(SP)	;A FLAG FOR NEG. ARGS
	TST	B	;MAKE SURE ARGS ARE POSITIVE
	BGE	DVML1
	DPNEG	B,C
	DPNEG 10(P),6(P) ;ALSO ON STACK (FOR DIV)
	COM	(SP)
DVML1:	TST	E
	BGE	DVML2
	DPNEG	E,F
	DPNEG 4(P),2(P)
	COM	(SP)
DVML2:	ADD	A,PC	;CHOOSE BETWEEN MUL AND DIV

;DOUBLE PRECISION MULTIPLY (CONT.)

MUL1:	TST	B	;OVERFLOW UNLESS A1*A2=0
	BEQ	MUL2
	TST	E
	BNE	MDV2	;OVERFLOW!
	EXCH	B,E	;WANT ARG1 TO HAVE ZERO HIGH ORDER PART
	EXCH	C,F
MUL2:	CLR	-(SP)	;SET B1 AND B2
	ASL	C
	BCC	.+6
	MOV	#100000,(SP)	;B2
	ASL	F
	BCC	.+6
	ADD	#200,(SP)	;B1 (ALSO CLEARS CARRY)
	ROR	C	;C2
	ROR	F	;C1
;IF B2*A1>0, THEN OVERFLOW
	TST	(SP)
	BGE	MUL3	;B2=0
	TST	E	;A1
	BNE	MDV1	;OVERFLOW

;DOUBLE PRECISION MULTIPLY (CONT.)

;GET A1*C2*(2**16.)
MUL3:
	MOV C,A		;C2*A1
	MUL E,A
	BCS MDV1	;CARRY INTO A IS OVERFLOW
	MOV B,ANSWER+2	;SINCE A1*C2 IS HIGH ORDER OF ANSWER
;GET C1*C2 AND ADD INTO ANSWER
	MOV C,A		;C1*C2
	MUL F,A
	MOV B,ANSWER	;LOW ORDER PARTIAL PRODUCT
	ADD A,ANSWER+2	;ADDED TO A1*C2
	BVS	MDV1	;OVERFLOW
;GET C2*B1*(2**15.) AND ADD INTO ANSWER
	TSTB	(SP)
	BEQ	MUL35	;B1=0
	CLR A
	MOV C,B		;GET C2
	ASHC #15.,A	;SHIFT C2 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B2*C1*(2**15.) AND ADD INTO ANSWER
MUL35:	TST	(SP)
	BGE	MUL4
	CLR A
	MOV F,B		;GET C1
	ASHC #15.,A	;SHIFT C1 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B1*B2*(2**30.)
MUL4:	CMP	(SP)+,#100200	;ARE BOTH B1 AND B2 SET
	BNE	MUL5	;NO (PRODUCT IS ZERO, OBVIOUSLY)
	ADD	#40000,ANSWER+2	;1*2**30. + ANSWER
	BVS	MDV2	;OVERFLOW
;PUT ANSWER IN THE RIGHT PLACE
MUL5:	MOV	ANSWER+2,E	;HIGH ORDER PARTS
	MOV	ANSWER,F	;LOW ORDER PARTS
	TST	(SP)+	;NEGATIVE?
	BEQ	MUL6
	DPNEG	E,F
MUL6:	ADD #14,SP	;THROW AWAY E,,F, ABS(B,,C) AND ABS(E,,F)
	JMP	SRETD	;BUT RESTORE THE REST

;OVERFLOW EXITS
MDV1:	TST (SP)+	;POP 2 WORDS + ABS'S
MDV2:	ADD #12,SP	;POP 1 WORD + ABS'S
	JMP	RETF	;RESTORE ALL AC'S AND RTS


;DOUBLE PRECISION DIVIDE
;	DIVIDE E,F BY B,C
;RETURN QUOTIENT IN E,F  AND REMAINDER IN B,C
.DPDIV:	SPUSH	A
	MOV	#<DIV1-MUL1>,A	;ADD TO THE PC IN A WHILE
	JMP	DVML	;INITIALIZATION.

DIV1:	TST	B	;IS DEN = 0, 1, OR DOUBLE PRECISION ?
	BNE	DIV2	;DOUBLE PRECISION
	TST	C
	BLT	DIV2	;DOUBLE PRECISION (SINCE TOP BIT WAS SET)
;DEN IS SINGLE PRECISION
	BEQ	MDV2	;DEN=0. OVERFLOW!
	CMP	C,#1	;IS IT 1?
	BNE	SPDEN1	;NO
	CLR	B
	CLR	C
	BR	DIV10
SPDEN1:	JSR	PC,.SPDEN	;DO THE DIVISION
	BR	DIV10

;DEN IS DOUBLE PRECISION
DIV2:	JSR	PC,CMP2I	;IS NUM < DEN
	BGE	DIV5	;NO
;NUM<DEN. QUOTIENT=0. REM=NUM
DIV4:	MOV	E,B
	MOV	F,C
	CLR	E
	CLR	F
	BR	DIV10

;NUM>=DEN.
DIV5:	PUSH B		;SAVE DENOMINATOR
	SPUSH C
	MOV B,A		;MOVE B,,C TO A,,B AND NORMALIZE
	MOV C,B
	CLR SHFCNT
DIV5A:	INC SHFCNT	;COUNT A LEFT SHIFT
	ASHC #1,A
	BVC DIV5A	;UNTIL SIGN BIT CHANGES (OVERFLOW)

	ASHC #-1,A	;UNDO LAST SHIFT
	BIC #100000,A	;AND CLEAR SIGN BIT WHICH WAS SET
	DEC SHFCNT	;UNCOUNT THE LAST SHIFT
	MOV A,C		;DIVIDE BY HIGH-ORDER OF NORMED DIVISOR
	JSR PC,.SPDEN	;E,,F _ (E,,F)/(DIVISOR*2^[N-16.])
	MOV E,A		;MOV (QUOTIENT*2^[16.-N]) TO A,,B
	MOV F,B
	ADD #-16.,SHFCNT	;TIMES 2^[N-16.] IS TRIAL QUOTIENT
	ASHC SHFCNT,A
;GET TRIAL NUM_(TRIAL QUOTIENT-1)*DEN. COMPARE WITH TRUE NUM
	POP F		;E,,F _ SAVED DENOMINATOR
	SPOP E
	MOV B,C		;B,,C _ A,,B (TRIAL QUOTIENT)
	MOV A,B
	SUB	#1,C	;TRY FIRST WITH Q_Q-1
	SBC	B
	BVS	MDV2	;OVERFLOW
	JSR	PC,.DPMUL
	BEQ	MDV2	;MULTIPLY GOT AN ERROR (HMM!)
;COMPARE NUM TO TEM
	MOV	B,ANSWER+2	;SAVE TRIAL QUO
	MOV	C,ANSWER
;GET TEM-NUM
	MOV	SP,D
	TST	(D)+
	SUB	(D)+,F
	SBC	E
	BVS	MDV2
	SUB	(D)+,E
	BVS	MDV2
;TURN INTO NUM-TEM
	DPNEG	E,F
	MOV	E,B
	MOV	F,C
	MOV	(D)+,F	;E,,F_DEN
	MOV	(D)+,E
DIV6:	TST	B	;NUM-TEM
	BEQ	DIV7
	BGT	DIV75
;ANSWER TOO BIG. TRY ANSWER _ ANSWER - 2
	SUB	#2,ANSWER
	SBC	ANSWER+2
	BVS	MDV2
;THIS MAKE TEM _ TEM + 2*DEN
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	BR	DIV6
DIV7:	TST	C
	BEQ	DIV9	;TRIAL QUOTIENT = QUOTIENT !!
;TEM < NUM. EITHER QUOT=QUOT OR QUOT+1
DIV75:	JSR	PC,CMP2I	;IS REM < DEN
	BGT	DIV9	;YES
DIV8:	ADD	#1,ANSWER	;QUOT _ QUOT + 1
	ADC	ANSWER+2
	BVS	MDV2
	SUB	F,C	;REM _ REM - DEN
	SBC	B
	BVS	MDV2
	SUB	E,B
	BVS	MDV2
DIV9:	MOV	ANSWER+2,E
	MOV	ANSWER,F
DIV10:	TST	(SP)+	;NEG. IF ANSWER SHOULD BE NEG.
	BGE	DIV11
	DPNEG	B,C
	DPNEG	E,F
DIV11:	ADD #14,SP	;POP ABS(E,,F), ABS(B,,C) AND E,,F
	POP	D	;RESTORE D
	CMP	(SP)+,(SP)+	;THROW AWAY B & C
	SPOP	A	;RESTORE A
	CLZ
	RTS PC



;SINGLE PRECISION DENOMINATOR. DOUBLE PRECISION NUMERATOR.
;C=DEN. E,F=NUM. RETURNS C_REM, E,F_QUOTIENT
.SPDEN:	SPUSH	A
	SPUSH	B
	ASL	E	;DOUBLE E,,F
	ASL	F
	ADC	E
	MOV E,B		;2E/C
	CLR A
	DIV C,A
	MOV A,E		;2*HIGH-QUOTIENT -> E
	MOV B,A		;(2REM + 2F)/2 /C
	MOV F,B
	ASHC #-1,A
	DIV C,A
	MOV A,F		;LOW-QUOTIENT -> F
	MOV B,C		; REMAINDER -> C
	ASR	E	;HALVE E TO GET PROPER HIGH-QUOTIENT
	BCC	.+6
	BIS #100000,F	;& LOW BIT FROM DOUBLE-E CLOBBERS F'S SIGN BIT
	SPOP	B
	SPOP	A
	RTS	PC
.ENDC


.IFNZ FPPF


;FLOATING DIVIDE AND MULTIPLY FROM REGS B,,C AND E,,F

.DPMUL:	PUSH A
	CLR A	;SET SWITCH
.DPMU1:	FPUSH FA
	FPUSH FB
	SPUSH C
	SPUSH B
	LDCIF (P)+,FA
	SPUSH F
	SPUSH E
	LDCIF (P)+,FB	;LOAD FLOATING REGS
	ADD A,PC	;WHICH ENTRY?
.DPMU5:	MULF FA,FB
	BR .DPMU2
.DPMU6:	LDD FB,FC	;SAVE FB
	DIVF FA,FB
.DPMU2:	STCFI FB,-(P)	;STACK QUOTIENT OR PRODUCT
	BCS .DPERR	;TOO BIG!?
	SPOP E
	SPOP F		;LOAD E,,F
	TST A
	BNE .DPMU4	;BRANCH ON DIVIDE
.DPMU3:	FPOP FB
	FPOP FA
	SPOP A
	CLZ
	RTS PC

.DPMU4:	STCFI FB,-(P)
	LDCIF (P)+,FB	;TRUNCATE QUOTIENT
	MULF FA,FB
	SUBF FB,FC	;GET REMAINDER
	STCFI FC,-(P)
	SPOP B
	SPOP C		;LOAD B,,C WITH REMAINDER
	BR .DPMU3


.DPDIV:	TST C				;DIVIDE ENTRY
	BNE .DPDI1
	TST B				;DON'T DIVIDE BY ZERO
	BEQ .DPERQ
.DPDI1:	PUSH A
	MOV #<.DPMU6-.DPMU5>,A		;SET DIVIDE SWITCH
	BR .DPMU1			;GO DO IT

.DPERR:	CMP (P)+,(P)+			;CLEAR STACK
	FPOP FB
	FPOP FA
	SPOP A
	SEZ
.DPERQ:	RTS PC




.ENDC





	.STITL CONVERSION ROUTINES


;CONVERT
;CALL WITH DESIRED DATA TYPE IN A
;CALL WITH POINTER TO DATA IN B
;IF CONVERSION SUCCEEDS, RETURN POINTER TO CONVERTED DATA IN B AND
;LEAVE A UNCHANGED.
;
;IF CONVERSION FAILS, LEAVE B UNCHANGED,BUT RETURN ITS DATA TYPE IN A

CONVERT:
	MOV	A,-(SP)	;SAVE A,B,C HERE
	MOV	B,-(SP)
	MOV	C,-(SP)

	BIC	#107777,A	;LEAVE DATA TYPE ONLY
	MOV	B,C
	BIC	#107777,C
	ASR	A	;SHIFT DESTINATION DATA TYPE 3 PLACES
	ASR	A
	ASR	A
	BIS	C,A	;SET SOURCE DATA TYPE IN THE 3 VACATED BITS
	ASR	A	;AND PLACE THE ENTIRE MESS IN BOTTOM 6 BITS
	SWAB	A
;(A IS NOW A 6 BIT DISPATCH ADDRESS)
	MOVB	CNVTBL(A),A	;PICK UP ENTRY FROM TABLE
	BIC	#177400,A	;CLEAR TOP BYTE
	ASL	A		;IT IS A BYTE ADDRESS
	JSR	PC,CNVTOP(A)	;RELATIVE TO CONVERT TOP
	BEQ	CONV.F	;THE CONVERSION FAILED
	MOV	(SP)+,C
	TST	(SP)+	;DON'T RESTORE B
	MOV	(SP)+,A
	RTS PC

CONV.F:	MOV	(SP)+,C
	MOV	(SP)+,B
	MOV	B,A
	BIC	#7777,A	;DATA TYPE OF ARG LEFT IN A
	TST	(SP)+	;DON'T RESTORE A
			;FALLS THROUGH

;CONVERT ROUTINE JUMPS TO THE PROGRAMS HERE

CNVTOP==.	;TOP OF CONVERT ROUTINES

;THE ARGUMENT CAN'T BE CONVERTED TO DESIRED DATA TYPE
.CERR:	SEZ
	RTS	PC


CA2LS==<.-CNVTOP>/2
;CONVERT ATOM TO LSTR
.CATLS:	JSR	PC,.LOAD

CNVNOP==<.-CNVTOP>/2
;THE ARGUMENT ALREADY HAS THE DESIRED TYPE
.CNOP:	CLZ
	RTS PC


CSN2IN==<.-CNVTOP>/2
;CONVERT SNUM TO INUM.  ASSUME NUMBER IN B, RATHER THAN POINTER
.CSNIN:	CLR	A
	TST	B	;IS NUM NEGATIVE?
	BGE	.+4
	COM	A	;SET TOP PART TO ALL 1'S
	JSR	PC,GRBAD
	BIS	#INUM,C	;C POINTS TO NEW NODE
	MOV	C,B
	RTS PC

;MORE CONVERSION ROUTINES

CIN2SN==<.-CNVTOP>/2
;CONVERT INUM TO SNUM.  RETURN NUMBER IN B
.CINSN:	JSR	PC,.LOAD
	TST B
	SXT C		;SEE IF B'S SIGN EXTENDED FILLS A.
	CMP A,C
	BNE .CERR
	CLZ
	RTS PC


CSN2LS==<.-CNVTOP>/2
;CONVERT SNUM TO LSTR
.CSNLS:	JSR	PC,.CSNIN	;CONVERT TO INUM FIRST

CIN2LS==<.-CNVTOP>/2
;CONVERT INUM TO LSTR
.CINLS:	SPUSH	D
	SPUSH	E
	SPUSH	F
	JSR	PC,.LOAD	;A,B HAS NUMBER
	JSR	PC,.CINST	;CONVERT TO STRING ON P-PDL
.CINL0:	CLR	F
	MOV	#SSTR,A
.CINL1:	SPOP	B
	BEQ	.CINL2		;0 MARKS END OF DIGITS
	JSR	PC,LISTB	;PUT NEXT 2 CHARS ONTO LIST
	BR	.CINL1
.CINL2:	POPS	B	;POINTER TO FIRST NODE OF ANSWER
	BIC	#170000,B	;CLEAR DATA TYPE
	BIS	#LSTR,B	;REPLACE BY LSTR
	MOV F,C	;GET PTR TO LAST NODE IN STRING

.SRDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	CLZ
	RTS PC


;GET NEXT CHARACTER IN B
;SKIP UNLESS NO MORE CHARS
.CNXTD:	TST	E	;IS THERE MORE NUMBER LEFT
	BNE	.CNXD1	;YES
	TST	F
	BEQ .CNXD2
.CNXD1:	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPDIV	;C_REM, E,,F_QUO
	BEQ .CNXD2
	ADD	#60,C	;TURN TO ASCII
.CNXD2:	RTS PC


;CONVERT INUM TO STRING ON P-PDL
.CINST:	MOV	(SP),TEM1	;RETURN ADDRESS
	CLR	(SP)
	MOV	#10,D
	MOV	A,E
	BGE	.CINI1	;NUMBER IS POSITIVE
	DPNEG	E,B	;NUMBER IS NEG
	CLR	D	;FLAG
.CINI1:	MOV	 B,F

.CINI2:	JSR	PC,.CNXTD	;GET NEXT DIGIT IN C
	BEQ	.CINI5	;NO MORE CHARS
	SWAB	C
	PUSH	C
	JSR	PC,.CNXTD
	BEQ	.CINI6
	BISB	C,(SP)	;SET NEW CHAR INTO PREVIOUS ONE
	BR	.CINI2

.CINI5:	ADD	D,PC	;NEGATIVE?
	SPUSH	#<55*256.>	;PUSH A MINUS SIGN IN HIGH BYTE
.CINIR:	JMP	@TEM1	;RETURN
	BR	.CINI7

.CINI6:	ADD	D,PC	;NEGATIVE?
	BIS	#55,(SP)	;PUT A MINUS SIGN IN LOW BYTE
	JMP	@TEM1
.CINI7:	TST	(SP)	;WERE ANY CHARACTERS GENERATED?
	BNE	.CINIR	;YES, SO RETURN
	SPUSH	#<60*256.>	;NO, SO PUSH A "0 IN HIGH BYTE
	BR	.CINIR

;MORE CONVERSION ROUTINES


CLS2SN==<.-CNVTOP>/2
;CONVERT LSTR TO SNUM
.CLSSN:	JSR	PC,.CLSIN	;CONVERT TO INUM FIRST
	BEQ .CLNR
	JSR	PC,.CINSN	;THEN CONVERT TO SNUM
.CLNR:	RTS	PC	;FAILED

CLS2IN==<.-CNVTOP>/2
;CONVERT LSTR TO INUM
.CLSIN:	BIT	#7777,B	;IS B EMPTY
	BEQ	.CLNR	;CAN'T CONVERT EMPTY
	PUSH	D
	SPUSH	E
	SPUSH	F
	MOV	B,GCP1	;POINT TO INPUT. (GETS CLEARED AT .RDEF & .SRDEF)
	MOV	B,C
	CLR	E
	CLR	F

.CLSS0:	CLR	-(SP)	;A FLAG
	JSR	PC,INSTR1	;GET FIRST CHAR IN D
	BEQ	.CLSS8	;NO CHARS (HMM)
	CMPB	D,#53	;PLUS
	BEQ	.CLSSA
	CMPB	D,#55	;MINUS
	BNE	.CLSS3	;NOT + OR -
	COM	2(SP)	;-1
.CLSSA:	JSR PC,@(SP)+
	BEQ .CLSS8
	BR .+4
.CLSS1:	JSR	PC,@(SP)+	;GET NEXT CHAR INTO D
	BEQ	.CLSS9	;ALL CHARS GOTTEN
.CLSS3:	SPUSH	C	;SAVE C
	SUB	#60,D	;CONVERT FROM ASCII
	BLT	.CLSS7	;NOT DIGIT
	CMPB	D,#10.
	BGE	.CLSS7	;NOT DIGIT
	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPMUL
	BEQ	.CLSS7	;TOO BIG
	ADD	D,F	;ADD NEXT DIGIT IN
	ADC	E
	BVS	.CLSS7	;OVERFLOW
	SPOP	C
	BR	.CLSS1

;EITHER A NON-DIGIT CHARACTER WAS FOUND, OR ELSE 
;THERE WAS OVERFLOW
.CLSS7:	CMP	(SP)+,(SP)+	;POP OFF C & CO-ROUTINE LINKAGE
.CLSS8:	TST	(SP)+	;POP OFF FLAG
	JMP	.RDEF

;ALL CHARS GOTTEN.  NUMBER IS IN E,,F
.CLSS9:	TST	(SP)+	;BUT SHOULD IT BE NEG?
	BGE	.CLSSR	;NO
	DPNEG	E,F
.CLSSR:	MOV	E,A
	MOV	F,B
	JSR	PC,GRBAD
	BIS	#INUM,C
	MOV	C,B
	JMP	.SRDEF
.IFNZ FPPF

;FLOATING POINT CONVERSION ROUTINES

CSN2FN==<.-CNVTOP>/2
.CSNFN:	SPUSH #.CINFN
	JMP .CSNIN


CIN2FN==<.-CNVTOP>/2
.CINFN:	MOV #INUM,A
	JSR PC,.FLOAD
	STCFD FA,-(P)
RFSTR:	SPOP A
	SPOP B
	JSR PC,GRBAD
	BIS #FNUM,C
	MOV C,B
	CLZ
	RTS PC


CFN2IN==<.-CNVTOP>/2
.CFNIN:	MOV #FNUM,A
	JSR PC,.FLOAD
	ADDF #40000,FA
	CFCC
	BVS .LERR1
	BGE .+6
	SUBF #40200,FA
	STCFI FA,-(P)
	BCS .LERR
	SPOP A
	SPOP B
	JSR PC,GRBAD
	MOV C,B
	BIS #INUM,B
	CLZ
	RTS PC
.LERR:	CMP (P)+,(P)+
.LERR1:	SEZ
	RTS PC


CFN2SN==<.-CNVTOP>/2
.CFNSN:	JSR PC,.CFNIN
	BEQ .LERR1
	JMP .CINSN


CFN2LS==<.-CNVTOP>/2
.CFNLS:	SPUSH D
	SPUSH E
	SPUSH F
	MOV #FNUM,A
	JSR PC,.FLOAD
	JSR PC,.CFNST
	JMP .CINL0




CLS2FN==<.-CNVTOP>/2
.CLSFN:	CLR FNPDL+2
	CLR SEXP
	CLR FNPDL
	STF FA,FE	;STORE FLOATING REGISTERS
	STF FB,FF
	CLRF FB
	BIT #7777,B	;CAN'T CONVERT EMPTY LSTR
	BEQ .FNLR
	PUSH D
	SPUSH E
	SPUSH F
	MOV B,GCP1
	MOV B,C
	CLR E	
	CLR F
CLSS0:	CLR -(P)	;A FLAG FOR THE SIGN OF NUMBER
	JSR PC,INSTR1	;GET FIRST CHAR
	BEQ .FERR	;NO CHARS
	SETI		;TO PREPARE FOR MOVES FROM REGS TO FLOAT REGS
	CMPB D,#53	;IS CHAR A "+?
	BEQ CLSSA
	CMPB D,#55	;IS CHAR A "-?
	BNE CLSS3
	COM 2(P)	;SET NEGATIVE NUMBER FLAG
CLSSA:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ .FERR	;NO MORE CHAR????
	BR .+4
CLSS1:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ CLSS9
CLSS3:	SUB #60,D	;CONVERT FROM ASCII
	BLT CLSS7	;IT WASN'T A DIGIT
	CMPB D,#12
	BGE CLSS7	;IT WASN'T A DIGIT
	CLR B
	LDCFD #41040,FA	;CONSTANT 10
	MULF FA,FB
	CFCC
	BVS CLSS8
	LDCIF D,FD
	INC FNPDL+2	;SET SWITCH
	ADDF FD,FB
	CFCC
	BVS CLSS8	;OVERFLOWED A FLOATING REGISTER??????!!!
	ADD E,F
	BR CLSS1	;GET ANOTHER CHAR
CLSS8:	TST (P)+	;DESTROY CO-ROUTINE LINKAGE
	JMP .FERR
CLSS9:	CLR B		;NO EXPONENT
	JMP OKY
CLSS7:	INC FNPDL
	CMPB D,#25	;IS IT "E?
	BEQ GTEXP
	CMPB D,#36	;IS IT "N?
	BEQ GTNEXP
	CMPB D,#177776	;ITS NOT ".!!??
	BNE CLSS8
	TST E
	BNE CLSS8	;THERE WERE TWO ".
	DEC E
	BR CLSS1
.FNLR:	LDF FE,FA	;RESTORE REGS
	LDF FF,FB
	SEZ
	RTS PC
FERR2:	POPS GCP1
	FPOP FB
	FPOP FA
.FERR:	TST (P)+
	LDF FF,FB
	LDF FE,FA
	SETL
	JMP .RDEF
GTNEXP:	DEC SEXP	;SET NEG EXPONENT FLAG
GTEXP:	SETL
	SPOP D		;SAVE CO-ROUTINE LINKAGE
	FPUSH FA
	FPUSH FB
	JSR PC,KL	;GET EXPONENT
	BEQ FERR2
	POPS GCP1
	FPOP FB
	FPOP FA
	SPUSH A
	CLR A
	JSR PC,.LOAD	;GET EXPONENT IN A,,B
	TST A
	BEQ OKAY
	SPOP A		;THE EXPONENT WAS TOO TOO LARGE!!!
	BR .FERR
OKAY:	SPOP A
OKY:	TST FNPDL+2
	BEQ .FERR
	SETL
	TST (P)+	;THE NUMBER IS NEGATIVE?
	BGE OKY1
	NEGF FB
OKY1:	LDCDF #40200,D	;CONSTANT 1
	TST SEXP	;GET FINAL EXPONENT
	BGE .+4		;IS EXP NEGATIVE
	NEG B
	CLR SEXP
	ADD B,F
	TST F		;GET ABSOLUTE VALUE IN F
	BGE LOOP
	DEC SEXP
	NEG F
LOOP:	DEC F		;GET 10 TO THE EXPONENT IN FD
	BLT DONEX
	MULF FA,FD
	CFCC
	BVS .FERR+2	;TO BIG
	BR LOOP
DONEX:	TST SEXP	;IF EXP IS POSITIVE MULTIPLY BY IT
	BLT DIVE	;IF NEG DIVIDE BY IT
	MULF FD,FB	;AND PUT RESULT IN FB
	CFCC
	BVS .FERR+2
	BR FIN
DIVE:	DIVF FD,FB
FIN:	STCFD FB,-(P)
	SPOP A		;GET RESULT IN A,,B
	SPOP B
	JSR PC,GRBAD	;STORE RESULT IN NODE SPACE
	BIS #FNUM,C	;PUT POINTER TO DATA IN B
	MOV C,B
	TST FNPDL
	BEQ .FERR+2
	LDF FF,FB	;RESTORE FLOATING REGS
	LDF FE,FA
	JMP .SRDEF
KL:	SPUSH D		;SHORT FOR KLUDGE.
	SPUSH E		;PREPARE TO FAKE OUT .CLSSA
	SPUSH F		;IT WILL GET US AN EXPONENT
	CLR -(P)	;FAKE A FLAG
	SPUSH D		;RESTORE CO-ROUTINE LINKAGE
	CLR E
	CLR F
	PUSHS GCP1
	JMP .CLSSA	;GET POINTER TO EXPONENT



;CONVERT FROM FNUM TO SSTR ON P-PDL

.CFNST:	SPOP SEXP	;SAVE PC
	CLR -(P)
	MOV #FNPDL+16,D	;INITIALIZE STACK POINTER
	TSTF FA
	CFCC
	BEQ .CFNZE	;ITS ZERO
	BGE .CFNS0
	MOVB #'-,-(D)	;PUT IN A MINUS SIGN
	NEGF FA		;PROCESS SIGN OF FNUM
.CFNS0:	CLR A
  	LDCFD #40200,FB	;CONSTANT 1
	LDCFD #41040,FD	;CONSTANT 10
	CMPF FA,FB
	CFCC
	BLT .CFNS2
.CFNS1:	DIVF FD,FA	;NORMALIZE FA
	INC A		;DIVIDE UNTIL 0<FA<1
	CMPF FA,FB
	CFCC
	BGE .CFNS1
.CFNS2:	MULF FD,FA	;MULTIPLY UNTIL 1<F=FA<10
	DEC A
	CMPF FA,FB
	CFCC
	BLT .CFNS2
	SPUSH #66152
	SPUSH #2657
	SPUSH #33675
	SPUSH #33006
	ADDF (P)+,FA	;ADD .0000005 FOR ROUNDING
	CMPF FA,FD	;9.99999999999999 WILL OVERFLOW
	CFCC
	BLT .+6
	DIVF FD,FA
	INC A		;MAKE IT 1.000 WHEN IT WAS 10.000
	MOV A,FNPDL	;SAVE EXPONENT
	MOV #7,B	;COUNTER FOR SEVEN DIGITS
	SETI
	INC A
	BLT .CFNS3-4	;ITS LESS THAN .1
	CMP #7,A
	BLT .CFNS3-4	;ITS GREATER THAN 10000000.
	INC A
	CLR FNPDL
	BR .CFNS3
	MOV #2,A
.CFNS3:	DEC A		;A COUNTS PLACES TO DECIMAL POINT
	BNE .+6
	MOVB #'.,-(D)	;PUT IN ".
	STCFI FA,C	;GET DIGIT
	LDCIF C,FB
	ADD #'0,C
	MOVB C,-(D)	;STACK CHARACTER
	SUBF FB,FA	;GET FRACTIONAL PART OF NUMBER
	MULF FD,FA
	SOB B,.CFNS3
	DEC A
	BNE .+6
	MOVB #'.,-(D)
	SETL
	CLR A
.CFNS4:	INC A		;COUNT ZEROS POPPED
	CMPB #'0,(D)+
	BEQ .CFNS4	;POP INSIGNIFICANT ZEROS
	DEC D		;RESET POINTER
	MOV FNPDL,B	;RETRIEVE EXPONENT
	BEQ .CFNS6	;NO EXPONENT
	BGT .CFNS5
	ADD B,A
	BGE .CFNS8	;IT NOW FITS DUE TO POPPED ZEROS
	NEG B
	MOVB #'N,-(D)	;STACK "N
	BR .CFNS5+4
.CFNS5:	MOVB #'E,-(D)	;STACK "E
	CLR A
	MOV D,FNPDL	;SAVE POINTER
	JSR PC,.CINST	;REDUCE EXPONENT TO SSTR
	SPOP A
	SPOP B
	MOV FNPDL,D	;RESTORE POINTER
	MOVB A,-(D)	;STACK EXPONENT DIGIT
	BNE .+4
	INC D		;IT WASN'T A DIGIT SO KILL IT
	SWAB A
	MOVB A,-(D)	;GET OTHER DIGIT
.CFNS6:	MOVB (D)+,-(P)	;GET HIGH BYTE
	BEQ .CFNS7	;A ZERO BYTE MEANS ITS DONE
	SWAB (P)
	MOVB (D)+,(P)	;GET ANOTHER BYTE
	BNE .CFNS6	;ZERO BYTE SIGNALS END
	SUB #2,P
.CFNS7:	ADD #2,P	;FIX UP STACK POINTER
	JMP @SEXP
.CFNZE:	SPUSH #"0.	;PUT "0. ON STACK
	JMP @SEXP
.CFNS8:	ADD D,B		;CREATE POINTER
	INC B
	MOV B,C		;SAVE IT
.CFNS9:	MOVB (D)+,(B)+	;SHIFT STACK
	CMPB #'.,-1(B)
	BNE .CFNS9
	MOVB (D),-1(B)	;GET LAST DIGIT
	MOV FNPDL,A
	COM A		;COMPUTE HOW MANY ZEROS ARE TO BE ADDED
.CFN10:	MOVB #'0,(B)+
	SOB A,.CFN10
	MOVB #'.,(B)
	MOV C,D		;RESTORE POINTER
	BR .CFNS6	;I HOPE YOUR HAPPY THAT THE EXPONENT IS GONE


.ENDC




	.STITL GET ARGUMENT ROUTINES

;GET 2 SNUM'S OFF OF S PDL
;RETURN TOP ONE IN A, BOTTOM ONE IN B
G2NARG:	JSR	PC,G1NARG	;NUMBER IN B
	MOV	B,A

;GET 1 SNUM OFF OF S PDL
;RETURN IT IN B
G1NARG:	POPS B
G1NAR1:	MOV	A,-(SP)	;ENTER HERE WITH ARG IN B
	MOV	#SNUM,A
	JSR	PC,CONVERT
G1WTA:	BEQ G1ARG1
	MOV	(SP)+,A
G1RET:	RTS	PC

;GET ONE LIST OR WORD ARG
;SKIP IF WORD
GLWARG:	MOV	@S,B	;DON'T POP ARG.  LEAVE IT GC PROTECTED
GLWAR1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE GSW2
GSW1:	CMP	A,#SENT
	BNE	G1ARG1	;NOT SENTENCE EITHER
	SEZ
GSW2:	RTS	PC

;GET ONE LIST OR WORD.  ERRROR IF EMPTY
GLWANE:	MOV	@S,B
	BIT	#7777,B
	BEQ	G1ARG1
	BR	GLWAR1

;RETURN ONE NUMERIC ARGUMENT
;CALL WITH SNUM IN B
R1INT:	JSR	PC,GETINT
R1NARG:	JSR	PC,.CSNIN	;CONVERT SNUM TO INUM
	JMP ORTB

PSHINT:	JSR	PC,GETINT
;PUSH A NUMBER ONTO THE S-PDL
PSHNUM:	JSR	PC,.CSNIN
	SPUSHS	B
	RTS	PC
.IFZ FPPF


;GET 2 INTEGERS FROM THE S-PDL
G2IARG:	JSR	PC,G1IARG
	MOV	B,E
	MOV	C,F
	JSR	PC,G1IARG
	EXCH	B,E
	EXCH	C,F
ILOAD1:	RTS	PC
G1ARG1:	ERROR+WTAB
.ENDC


;GET 1 INTEGER FROM THE S-PDL
G1IARG:	POPS	B
	SPUSH	A	;SAVE A
	MOV	#INUM,A
	JSR	PC,CONVERT
	BEQ G1ARG1
	JSR	PC,.LOAD	;INTEGER IN A,,B
	MOV	B,C
	MOV	A,B
	SPOP	A
	RTS	PC

.IFZ FPPF


;RETURN 1 INTEGER FROM B,,C
R1I.BC:	MOV	B,A
	MOV	C,B
	BR	R1I.N

;;RETURN 1 INTEGER FROM E,,F
R1I.EF:	MOV	E,A
	MOV	F,B
R1I.N:	JSR	PC,GRBAD
	BIS	#INUM,C
	JMP	ORTC
.ENDC

.IFNZ FPPF

;ROUTINES TO LOAD FLOATING REGS FROM NODESPACE

G2ARG:	MOV #INUM,F
	JSR PC,G1NUM	;GET 1 INTO FA
	BEQ G1ARG1
	LDD FA,FC
	JSR PC,G1NUM	;GET ANOTHER
	BEQ G1ARG1
	LDD FA,FB
	LDD FC,FA	;SWITCH THEM
	RTS PC		;F WILL CONTAIN TYPE EXPECTED OF
			;ARITHMETIC RESULT

;LOAD ONE ARG INTO FA AND ERROR+WTA

G1ARG:	JSR PC,G1NUM
	BNE ILOAD1
G1ARG1:	ERROR+WTAB


;LOAD ONE ARG INTO FA AND CLZ

G1NUM:	POPS B
G1NUMS:	MOV B,A	;IS IT ALREADY AN FNUM?
	BIC #7777,A
	CMP #FNUM,A
	BEQ G1FAG
	MOV #INUM,A
	JSR PC,CONVERT	;TRY TO GET AN INUM
	BNE .FLOAD
G1FARG:	MOV #FNUM,A
	JSR PC,CONVERT	;TRY TO GET A FNUM
	BEQ ILOAD1
G1FAG:	MOV A,F		;SET F TO SHOW FNUM

.FLOAD:	BIC #170000,B
	ASL B
	ASL B
	ADD #NODESP,B
	CMP #INUM,A
	BEQ .ILOAD	;LOAD AN INUM?
	LDCFD (B),FA	;LOAD FNUM
	CLZ
	RTS PC
.ILOAD: LDCIF (B),FA	;LOAD INUM
	CLZ
ILOAD1:	RTS PC


.ENDC




;GET 1 SNAP
;	RETURN POINTER TO SNAP IN D, DELTA X IN E, DELTA Y IN F
G1SNAP:	MOV	@S,C	;POINTER TO ARG
	BIT	#7777,C	;IS IT EMPTY?
	BEQ	ILOAD1	;YES. RETURN WITHOUT SKIPPING


;LOAD 3 NUMBERS
;	GROVEL DOWN A LIST OF NUMBERS RETURNING 3 NUMBERS IN D,E,F
;	CALL WITH C POINTING TO LIST
;	IF LIST CONTAINS 1)NON-NUMBERS OR 2)MORE THAN 3 ELEMENTS,
;	THEN ERROR+WTA
LD3NUM:	PUSH	A
	SPUSH	B
	SPUSH	C
	MOV	#7777,D	;AN OFT USED CONSTANT
	MOV	#3,F	;COUNTER
LDN.L:	BIT	D,C	;IS THERE MORE LIST?
	BEQ	LDN.ER	;ERROR
	JSR	PC,.LOADC	;LOAD A WITH NEXT ELEMENT
	MOV	A,C
.IFNZ FPPF
	CMP #3,F
	BGT LDN.E
.ENDC
	MOV	#SNUM,A
	JSR	PC,CONVERT
	BEQ LDN.ER
LDN.E:	SPUSH	B	;PUSH THIS ELEMENT
	SOB F,LDN.L
	BIT	D,C	;IS THE LIST FINISHED?
	BNE	LDN.ER	;NO. ERROR
	JMP	SRETF	;SKIP RETURN AND RESTORE ALL AC'S!

LDN.ER:	ERROR+WTA
	.STITL EVAL

EVAL:	JSR PC,GNT	;GET NEXT TOKEN, RETURNED IN A
	JSR PC,STRACE	;CHECK FOR SYSTEM TRACE
	BIC #DPQF+CPTBF,FLAGS2	;DON'T PRINT QUOTE, CHANGE % TO BLANK
	BIC #7777,A
	CMP A,#UFUN	;USER FUNCTION?
	BLOS EVFUN
	CMP A,#UVAR	;USER VARIABLE?
	BEQ EVVAR
	CMP A,#SSTR
	BHI .+4
EVWHAT:	.BUG.
	CMP A,#ATOM
	BEQ EVATM
	CMP A,#SNUM	;INTEGER?
	BEQ EVWHAT
.IIF Z FPPF,	CMP A,#LSTR
.IIF NZ FPPF,	CMP A,#FNUM
	BLOS EVCON
	CMP A,#LIST
	BNE EVWHAT
EVCON:
EVATM:	PUSHS CT+2	;SAVE ON S-PDL FOR OUTPUT
	BR EVI
EVVAR:	BIC #170000,B
	BIS #ATOM,B
	MOV B,D		;SAVE UOE PTR FOR ERROR
	JSR PC,.BINDL
	BEQ EVVAR2	;NO BINDING FOUND
	TST B		;NIL?
	BNE EVVAR1	;NO, GOOD
	MOV D,B
EVVAR2:	ERROR+HNV	;... HAS NO VALUE
EVVAR1:	PUSHS B		;SAVE IT FOR OUTPUT
EVI:	JSR PC,GNT	;ABOUT TO OUTPUT A VALUE.
			;BEFORE WE DO, CHECK TO SEE IF
			;NEXT TOKEN IS INFIX WHICH SHOULD GOBBLE IT.
	BIC #7777,A	;IS NEXT TOKEN INFIX?
	CMP #INFIX,A
	BEQ CKPRCD	;YES
EVI1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS	;CLEAR CARRIAGE RETURN TOKEN FLAG
	CLZ
	RTS PC
CKPRCD:	TST CO+2	;COMPARE PRECEDENCE
	BEQ EVI2
	MOV CT+2,A
	ASL A
	MOV SOBLST(A),A	;SYSTEM OBLIST ELEMENT (NEXT OPER.)
	BIC #7777,A
	MOV COF,B	;CURRENT OPERATOR FLAG
	BIC #7777,B
	CMP A,B		;IS PRECD OF CO >= PRECD NEXT OPER
	BLO EVI1	;YES, > - GIVE OUTPUT TO CO
	BEQ EVI4	;YES, = - CHECK FOR _
		;NO - NEXT TOKEN SHOULD GOBBLE THIS OUTPUT
EVI2:	JSR PC,STRACE
EVI12:	CMP #$BKAR,CT+2	;CHECK FOR SUCCESSIVE _'S
	BNE EVI3		;   "A _"B _0
	CMP #$BKAR,CO+2
	BEQ EVI13
	CMP #$TBKAR,CO+2
	BNE EVI3
EVI13:	MOV #$TBKAR,CT+2
EVI3:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF OPERANDS STILL NEEDED
	MOV CT,CO
	MOV CT+2,CO+2
	MOV CO+2,A	;GET FLAGS
	ASL A
	MOV SOBLST(A),COF	;SET CURRENT OPERATOR FLAG
	MOV #1,NOR
	JMP EVW		;CALLS EVAL
EVI4:	CMP #$BKAR,CT+2	;PRECD ARE = - IF _ DO RIGHT ONE FIRST
	BEQ EVI2	;IT IS _
	BR EVI1
EVFUN:	BIT #CRF,FLAGS	;CT IS A FUNCTION
	BEQ .+4
	ERROR+UELX	;UNEXPECTED END OF LINE
	CMP #$LPAR,CT+2	;IS NEXT TOKEN A LEFT PAREN?
	BNE EVF1
	TST CO+2	;NEXT OPERATOR?
	BEQ EVF11	;NOTHING THERE
.IFNZ ENG
	CMP #$DO,CO+2	;IS NEXT OPERATOR A RUN COMMAND?
	BEQ EVF11
.ENDC
.IFNZ FR
	CMP #$EXECUT,CO+2
	BEQ EVF11
.ENDC
	CMP #$LLPAR,CO+2
	BNE EVF1
EVF11:	MOV #$LLPAR,CT+2	;INSERT PARENS.FOR PARSE
EVF1:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF ARGS NEEDED FOR CO'S EXECUTION
	CMP #$LLPAR,CO+2	;IF CO IS !(, PUSH IFLEV INSTEAD OF NOR
	BNE EVF13
	MOV IFLEV,(P)
	CLR IFLEV
EVF13:	MOV CT,CO
	MOV CT+2,CO+2
	BIC #EDTIF2,FLAGS
EVF2:	CMP A,#UFUN	;IS POPPED OPER. A  USER FUNCTION?
	BLO MFUN	;NO, MACHINE
	MOV #<PREPRI_13.>,COF	;SET PRECD TO PREPRI
	JSR PC,GNASN	;GET NO. OF ARGS IN B
	BNE .+4
	ERROR+HNM	;... HAS NO MEANING
	MOVB B,B	;CLEAR ANY LEFT HALF FLAGS
	MOV B,NOR
	BEQ .+6
	JMP EVL1

EVXP:	JSR PC,STRACS	;NO MORE, SPACE AND CHECK FOR SYSTEM TRACE
	JSR PC,PEVAL	;SET TO EVALUATE THIS USER PROCEDURE
	BEQ XNORT	;PEVAL DOES SEZ  IF THERE IS NO OUTPUT
	JMP XORT		;DOES CLZ IF THERE IS
.IFNZ	JGB
MFUN:	MOV CO+2,A
	BIC #177761,A	;DID HE REDEFINE IT?
	MOV SYSHTB(A),B	;GET THE RIGHT HASH BUCKET
	BEQ MFUN3	;NO ENTRIES THERE, USE MFUN
	TST OLDFLG	;DOES HE WANT SYS DEF?
	BNE MFUN2	;YES, GIVE IT TO HIM
MFRUN:	JSR PC,.LOAD	;GET NODE
	SAVE A		;KEEP THE PTR TO NEXT NODE.
	JSR PC,.LOAD	;GET THIS NODE
	CMP CO+2,A	;COMP MFUN WITH SFUN
	BEQ FOUND	;HE REDEFINED IT
	REST B		;GET NEXT NODE TO CMP
	BEQ MFUN3	;NO MORE, HE DIDN'T REDEFINE
	BR MFRUN	;KEEP LOOKING
FOUND:	TST (P)+	;CLEAR STACK
	MOV B,CO+2		;GET EVERYTHING RIGHT
	MOV #UFUN,A
	BIS A,CO
	BR EVF2		;GO BACK AND PROCESS
MFUN2:	CLR OLDFLG	;DON'T STAY IN 'OLD' MODE
MFUN3:	MOV CO+2,A	;GET FLAGS FOR THIS MACHINE PRCEDURE
MFUN1:
.IFF
MFUN:	MOV CO+2,A	;GET FLAGS FOR THIS MACHINE PROCEDURE
.ENDC
	ASL A
	MOV SOBLST(A),A
	MOV A,COF
	SWAB A
	BIC #177774,A	;FIND NO. OF ARGS. NECESSARY
	MOV A,NOR
	BNE EVS		;IS  NO. ARGS = 0? (BRANCH IF NO)
EVXM:	JMP MEVAL	;YES.  EXECUTE THIS MACHINE PROCEDURE

XNORT:	BIC #EDTIF,FLAGS
	BIT #EDTIF2,FLAGS
	BEQ .+10
	BIS #EDTIF,FLAGS
NORT0:	MOV #EVDNO,A	;SET RETURN TO INDICATE NO OUTPUT
NORT1:	MOV CO+2,LO+2	;UPDATE OPERATORS
	MOV CO,LO
	POP NOR
	SPOP B
	MOV B,CO+2
	SPOP CO
	CMP #$LLPAR,B	;IF POPPED OPER IS !(, IFLEV_NOR, NOR_1	
	BNE NORT3
	MOV NOR,IFLEV
	MOV #1,NOR
NORT3:	CLR COF
	TST B
	BEQ NORT2	;NO MORE OPERATORS
	BIT #160000,CO	;IS IT A UFUN
	BNE NORT2	;YES
	ASL B		;NO, MUST BE A PRIMITIVE. GET OFFSET IN BYTES
	MOV SOBLST(B),COF
NORT2:	JMP @A		;RETURN DEPENDS ON WHETHER OUTPUT EXISTS
EVDNO:	SEZ
	RTS PC
EVS:	BIT COF,#INFIX	;IS CO INFIX OP
	BEQ EVL		;NO
	JSR PC,CKUI	;CHECK FOR VALID UNARY INFIX +,-
	BNE EVW
	ERROR+INF1	;INFIX IN WRONG PLACE
PROC:	MOV @S,B	;THE WORD
	BIT #7777,B	;IS IT THE EMPTY WORD
	BNE .+4
	ERROR+WTA
	JSR PC,GUOEB	;PEVAL INVOKED VIA "#"
	BEQ PROC1
	MOV B,@P	;OLD RETURN - POPPED LATER
	JSR PC,.BINDF	;IS A PROC DEFINED
	BEQ PROC3	;NO
	MOV #UFUN,CO	;YES
	MOV @P,B
PROC2:	CLR TOPS
	MOV B,CO+2
	SPOP B		;GET P BACK IN PHASE
	JMP EVF2
PROC3:	JSR PC,.LOAD	;GET PNAME FOR UOBSCH
PROC1:	MOV B,TOPS
	MOV #SFUN,A
	JSR PC,UOBSCH	;MAKE SURE CO EXISTS
	BNE .+4
	ERROR+HNM	;HAS NO MEANING
	MOV A,CO
	BR PROC2

EVL:	BIT #PTLPF,FLAGS	;WAS PREVIOUS TOKEN A LEFT PAREN
	BEQ EVL1		;NO
	BIT #VNAF,COF	;DOES CO USE VARIABLE NO. OF ARGS.?
	BEQ EVL1	;NO
	CLR NOR
EVL1:	JSR PC,GNT
EVW1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS
EVW:	JSR PC,EVAL	;EVALUATE THIS ARGUMENT
	BEQ EVW2	;NO OUTPUT FROM EVAL
	DEC NOR
	BEQ EVX		;WHEN NOR = 0, WE'VE ENUF INPUTS
	JSR PC,GNT
	TST NOR		;IF NOR < 0 AND NEXT TOKEN IS ")" THEN THE ")" 
	BGE EVW1	;TERMINATES THE ARG SCAN FOR THE CO
	CMP #$RPAR,CT+2  ;IS IT?
	BNE EVW1	;NO
	BIS #RTF,FLAGS
	BIC #CRF,FLAGS
	NEG NOR
	CMP #MAXARG,NOR
	BGE MEVALN	;EXECUTE MACHINE PROC.
	ERROR+TMAC	;TOO MANY ARGS COMMAND/OPERATION
EVX:	BIT #160000,CO	;IS IT A MACHINE PROCEDURE
	BEQ .+6
	JMP EVXP	;NO
	BIT #VNAF,COF	;MACHINE PROC NOW HAS ITS "STD" NO. OF ARGS.
		;IF IT CAN TAKE A VARIABLE NO., THEN THE "STD" NO. HAS
		;BE PUSHED ON P
	BEQ MEVAL	;IT DOESN'T- GO EVALUATE IT
	MOV COF,A
	SWAB A
	BIC #177774,A
	MOV A,NOR
	BR MEVALN	;SAME AS MEVAL BUT SAVES NO. OF ARGS
EVW2:	CMP #$LLPAR,CO+2	;EVAL SHOULD OUTPUT WHEN NOT AT TOP LEVEL
	BEQ EVW		;EXCEPT WHEN CO IS LLPAR
	ERROR+NOU	;WHAT, NO OUTPUT??!!

LLPAR:
LPAR:	JSR PC,GNT
	CMP #$RPAR,CT+2
	BEQ LPAR1
	ERROR+TIP	;TOO MUCH INSIDE PARENS
LPAR1:	CLZ
	RTS PC

RPAR:	BIT #PTLPF,FLAGS
	BEQ .+4
	ERROR+NIP	;NOTHING INSIDE PARENS
	CMP 4(P),#$LLPAR	;IS PENDING COMMAND !(
	BNE RPAR1
RPAR2:	POP A
	MOV (P),IFLEV
	ADD #6,P	;POP !( OFF STACK
	MOV A,(P)
	SEZ
	RTS PC

RPAR1:	ERROR+ERP	;EXTRA RIGHT PAREN
CKUI:	PUSH A
	MOV CO+2,A
	CMP A,#$PLUS	;+
	BNE CKUI1
	MOV #$UPLUS,A
CKUI0:	MOV A,CO+2
	ASL A
	MOV SOBLST(A),COF
	MOV #1,NOR
	JMP SRETA

CKUI1:	CMP A,#$MINUS	;-
	BNE CKUI2
	MOV #$UMINS,A
	BR CKUI0

CKUI2:	POP A
	RTS PC

MEVALN:	PUSH NOR
MEVAL:	JSR PC,STRACS
	MOV CO+2,A	;GET SOE POINTER
	CLR NBKTS
	ASL A
	JSR PC,@2+SOBLST(A)	;JMP ADDR IS IN 2ND WORD
	BNE XORT	;PROCEDUE OUTPUTS
	LDFPS #40300
	JMP XNORT	;NO OUTPUT
XORT:	LDFPS #40300
	MOV #EVI,A
	JMP NORT1

ORTNA:	MOV A,@S
	BR SRET
ORTNB:	MOV B,@S
	BR SRET
ORTNC:	MOV C,@S
	BR SRET
ORTND:	MOV D,@S
	BR SRET
ORTNE:	MOV E,@S
	BR SRET
ORTNF:	MOV F,@S
	BR SRET
ORTNP:	MOV	(SP)+,@S
	BR SRET


ORTA:	PUSHS A
	BR SRET
ORTB:	PUSHS B
	BR SRET
ORTC:	PUSHS C
	BR SRET
ORTD:	PUSHS D
	BR SRET
ORTE:	PUSHS E
	BR SRET
ORTF:	PUSHS F
	BR SRET
ORTP==.
ORTSP:	PUSHS	(SP)+

RETF:	POP F
	BR RETE1
RETE:	POP E
	BR RETD1
RETD:	POP D
	BR RETC1
RETC:	POP C
	BR RETB1
RETB:	POP B
	BR RETA1
RETA:	POP A
	SEZ
	RTS PC

RETF1:	SPOP F
RETE1:	SPOP E
RETD1:	SPOP D
RETC1:	SPOP C
RETB1:	SPOP B
RETA1:	SPOP A
RET:	SEZ
	RTS PC

SRETF:	POP F
	BR SRETE1
SRETE:	POP E
	BR SRETD1
SRETD:	POP D
	BR SRETC1
SRETC:	POP C
	BR SRETB1
SRETB:	POP B
	BR SRETA1
SRETA:	POP A	;POP A THEN DO CLZ RETURN
	BR SRET

SRETE1:	SPOP E
SRETD1:	SPOP D
SRETC1:	SPOP C
SRETB1:	SPOP B
SRETA1:	SPOP A	;POP A THEN DO CLZ RETURN
CKTYP:
SRET:	CLZ
	RTS PC
	.STITL PROCEDURE EVALUATOR
PEVAL:	JSR PC,CKSTG	;CHECK STORAGE
	MOV CO+2,B	;FIRST CHECK IF PROC IS THERE
	JSR PC,.BINDF	;GET BINDING
	BNE .+4
	ERROR+HNM	;PROCEDURE HAS NO MEANING
	JSR PC,SAVEVL	;SAVE ALL PROCEDURE INFORMATION

	;GET ARG LIST - PUT UOE POINTERS AND VALUES FROM THERE ON S
	MOV A,C		;SAVE PTR TO LLP (LIST OF LINEPTRS)
	JSR PC,.LOAD	;GET FLAGS,,#ARGS
	MOV B,FLAGS
	MOVB B,B
	SPUSH B		;PUSH # ARGS
	BIC #-<TPTF+TPSF>-1,FLAGS  ;CLEAR ALL BUT TRACE AND STEP FLAGS
	BNE PEV3
	BIT #TRACEF,FLAGS2	;IS TRACE SET?
	BEQ PEV6	;NO
PEV3:	MOV CO+2,B
	INC FUNLEV
	JSR PC,TINDNT	;SET SPACING ACCORDING TO FUNCTION LEVEL
	DEC FUNLEV
LANGC	<JSR PC,PPNAME	;PRINT PROCEDURE NAME
	PRTXT ^\'S INPUTS: \>,<
	PRTXT ^/LES INPUTS DE /
	JSR PC,PPNAME
	PRTXT ^/ SONT:/>
	MOV @P,B	;# OF ARGS
PEV6:	SPUSH C		;SAVE FOR BELOW (POINTS TO LASTLINEPTR)
	MOV B,D		;NO. OF ARGS
	BEQ PEV2	;NO ARGS
.IFNZ SWAPF
	JSR PC,.LOADC
	JSR PC,.LOAD
.ENDC
	SPUSH A		;SAVE PTR TO REST OF TITLE LINE
	CMP #SPUSHL,S	;ENOUGH ROOM ON S-PDL?
	BLOS .+6	;OK
	JSR PC,SPSWPO	;SWAP OUT S-PDL
	MOV D,B		;# OF ARGS
	ASL B		;MULTIPLY BY TWO FOR OFFSET
	MOV S,D
	MOV D,E
	SUB B,E
	MOV E,S
	ASR B
PEV7:	MOV (D)+,(E)+	;GET ARGS ON TOP OF STACK
	SOB B,PEV7
	MOV @P,A	;GET SAVED LLP PTR
PEV1:	TST FLAGS
	BNE PEV4	;TRACE IS SET
	BIT #TRACEF,FLAGS2
	BEQ PEV5	;NO TRACE
PEV4:	MOV -2(E),B	;TOP ARGUMENT
	MOV B,A
	INC NBKTS
	SPUSH D
	JSR PC,PRTAB	;PRINT TOKEN IN A,,B
	DEC NBKTS
	SPOP D
	MOV @P,A	;POINTER TO ARG ON TOP OF SATCK
PEV5:	JSR PC,.LOADA	;GET THE ARG
	MOV A,@P	;PTR. TO NEXT NODE
	CMP #$COMT,B	;IS CURRENT NODE A COMMENT?
	BNE PEV10
PEV12:	BIT #7777,A	;END OF ARGUMENT?
	BEQ PEV11	;YES
	JSR PC,.LOADA
	CMP #$COMT,B
	BNE PEV12
	BR PEV5
PEV10:	JSR PC,SAVVAR	;SAVE THIS VARIABLE BINDING
	MOV @P,A
	BIT #7777,A
	BEQ PEV11
	TST FLAGS
	BNE PEV10A
	BIT #TRACEF,FLAGS2
	BEQ PEV1
PEV10A:	PRTXT ^/,/
	BR PEV1		;GO DO NEXT ARG

PEV11:	SPOP C		;USED TITLE LINE POINTER
PEV2:	SPOP C		;PTR TO LLP THAT WAS PUSHED WAY ABOVE
	TST FLAGS
	BNE PEV2A	;TRACE SET
	BIT #TRACEF,FLAGS2
	BEQ PEV2B	;NO TRACE
PEV2A:	PRCR
PEV2B:	JSR PC,SAVPPS	;SAVE PDL PTRS
	BIS #1,CPDLP	;INDICATES PROC PUSH AS OPPOSED TO A LOCAL PUSH
	MOV CO+2,B
	CLR CPLN
	MOV C,CLP
	MOV B,CPP	;GET CPSN IN A
.IFNZ SWAPF
	JSR PC,GNASN
	MOV A,CPSN
.ENDC
	CLR CO
	CLR CO+2
	CLR IFLEV
	INC FUNLEV
	JMP MLOOP
SAVVAR:	;SAVE IN (D) VARIABLE BINDING OF UOE PT'ED TO BY B
		;GIVE IT NEW VALUE WHICH IS AT (E)
		;USES A,C.  TOPS MUST BE 0
		;BOTH D AND E ARE -()ED
	MOV B,-(D)	;SAVE UOE PTR
	MOV #VBIND,A	;THIS WILL CHECK SPDL THINGS--
			;NOP IT IF IT SEEMS TO CAUSE TROUBLE.  RWW
	JSR PC,.BINDL	;NOW GET VARIB. BINDING
	BEQ SAVV2	;NOT THERE
SAVV1:	MOV -(E),A	;GET NEW VALUE PTR
	MOV B,-(D)	;SAVE OLD VALUE PO[NTER
	MOV A,B
	JSR PC,.LDP1
	BIC #100000,A	;MAKE SURE BINDING NODE SAYS "VBIND"
	JSR PC,.STORE	;STORE NEW BINDING AWAY
	RTS PC

SAVV3:	TST -(E)
	CLR -(D)	;THERE IS NO OLD VALUE POINTER
	RTS PC

SAVV2:	TST -2(E)
	BEQ SAVV3	;IF NEW VALUE = 0, DON'T BOTHER TO CREATE CELL
	MOV #VBIND,A
	CLR B
	JSR PC,GRBAD1
	BR SAVV1

SAVPPS:	POP F	;SAVE P AND S PDL PTRS
	SPUSH CSPDLP
	MOV #IS,A	;COMPUTE RELATIVE S PDL PTR
	SUB S,A		;CURRENT TOP OF S-PDL
	ADD SPRBAO,A	;# OF PDL BLOCKS SWAPPED OUT
	MOV A,CSPDLP
	SPUSH CPDLP
	MOV #IP,A	;COMPUTE RELATIVE P PDL PTR
	SUB P,A
	ADD PRBAO,A
	MOV A,CPDLP
	JMP @F

TINDNT:	PUSH A	;TRACE INDENT
	MOV FUNLEV,A
TIND2:	DEC A
	BGT TIND1
	JMP RETA
TIND1:	SPACE
	BR TIND2
LOCAL:	JSR PC,GUOEB	;GET UOE PTR FROM S
LOC9:	MOV #IS,F	;MOVE STUFF FROM S TO P PDLS
	SUB S,F
	ADD SPRBAO,F
	MOV CSPDLP,D
	BIC #1,D
	SUB D,F
	ASR F
	MOV F,A
	BLE LOC2
LOC1:	POPS D
	PUSH D
	DEC A
	BGT LOC1
LOC2:	MOV S,D	;NOW STORE AWAY PTR & OLD VALUE
	PUSHS #0
	MOV S,E
	PUSHS #0
	JSR PC,SAVVAR
	MOV F,A	;NOW RETURN STUFF FROM P TO S
	BLE LOC4
LOC3:	POP D
	PUSHS D
	DEC A
	BGT LOC3
LOC4:	MOV #IP,A	;NOW MOVE STUFF FROM P TO S
	SUB P,A
	ADD PRBAO,A
	MOV CPDLP,D
	BIC #1,D
	SUB D,A
	ASR A
	MOV A,F
	BLE LOC6
LOC5:	POP D
	PUSHS D
	DEC A
	BGT LOC5
LOC6:	PUSH #1	;PUSH GOODIES ON P
	SPUSH CSPDLP
	SPUSH CPDLP
	BIC #1,CPDLP	;INDICATE LOCAL PUSH
	BIC #1,CSPDLP
	ADD #4,CSPDLP
	ADD #6,CPDLP
	MOV F,A
	BLE LOC8
LOC7:	POPS D	;NOW RETURN STUFF TO P
	PUSH D
	DEC A
	BGT LOC7
LOC8:	SEZ
	RTS PC


;CHECK (E) FOR VALID DATA TYPE IF CHEKUF ON
CKSARG:	BIT #CHEKUF,FLAGS2
	BNE .+4
	RTS PC

	SPUSH D		;D & E ARE USED
	SPUSH E
	MOV #CKLIST,D	;THIS RUNS THROUGH THE VALID TYPES
	MOV (E),E	;GET THE DATUM
	BIC #7777,E	;ITS TYPE
CKSAR1:	CMP (D)+,E	;IS THIS A VALID TYPE?
	BEQ CKSRET	;AHA! IS!
	TST (D)		;MORE VALID TYPES?
	BNE CKSAR1	;THERE ARE
	.BUG.		;THERE AIN'T--*DIE*

CKSRET:	SPOP E		;WELL AND GOOD--IT'S VALID.
	SPOP D
	RTS PC

.STITL PROC EVAL - "OUTPUT" "STOP"
OUTPUT:	TST FUNLEV
	BGT .+4
OUTPU1:	ERROR+OIP	;ONLY IN PROCEDURE
	MOV #SRET,PSTOPR ;"OUTPUT" (CLZ FOR RETURN)
	POPS TOPS1	;SAVE THE OUTPUT
	BR PSTP10
STOP:
PSTOP:	TST FUNLEV
	BLE OUTPU1
	MOV #RET,PSTOPR	;"STOP" AND "END" (SEZ FOR RETURN)
	CLR TOPS1
	MOV #PSTP15,ERFRET	;RETURN ADDRESS FROM ERROR SET FRAME
PSTP10:	MOV #PSTP18,DOFRET	;SAME FOR DO FRAME
	BIT #DORF,FLAGS		;IS THIS A DO OR READ FRAME?
	BEQ PSTP12	;NO
PSTP14:	JSR PC,RESPPS	;RESTORE PDLS
	POP B		;RETURN ADDRESS
	BIT #TF7,TFLAGS	;IS THIS AN ERROR SET FRAME?
	BEQ PSTP16	;NO
	MOV B,ERPROC
	BR PSTP14
PSTP16:	JSR PC,RESEVL	;RESTORE PROCEDURE VARIABLES
	MOV B,FLAGS
	BR PSTP10
PSTP12:	BIT #TPTF+TPSF,FLAGS	;STEP OR TRACE FLAGS SET?
	BNE PSTP11	;YES
	BIT #TRACEF,FLAGS2
	BEQ PSTP15	;NO TRACE
PSTP11:	JSR PC,TINDNT
	MOV CPP,B
	JSR PC,PPNAME
	MOV TOPS1,B
	BEQ PSTP13
	PRTXT ^\ OUTPUTS \
	INC NBKTS
	JSR PC,PNODAB	;USES A (PRINTS OUT OBJECT ON S AS STRING)
	DEC NBKTS
	PRCR
	BR PSTP15
PSTP13:	LANGC <PRTXTC ^\ STOPS.\>,<
	PRTXTC ^/ STOPPE./>
PSTP15:	JSR PC,RESPPS	;RESTORE PDLS
	BIT #TF7,TFLAGS	;IF IT WAS AN ERROR SET FRAME, GO TO @ERFRET
	BEQ PSTP21	;IT WASN'T
	POP ERPROC
	JMP @ERFRET
PSTP21:
	SPOP D	;# ARGS SAVED
	BEQ PSTOP4	;NO ARGS
PSTOP3:	POPS E		;GET OLD VARIBLE BINDING
	SPOPS B		;GET NEXT UOE PTR
	MOV #VBIND,A
	TST E		;IS OLD BINDING NIL?
	BNE PSTP31	;NO
	JSR PC,.UNBND	;YES, GET RID OF IT
	BR PSTP33
PSTP31:	JSR PC,.BINDL	;GET VARIB BINDING PTR
	BEQ PSTPE3	;NONE THERE
	MOV E,B		;GET OLD VARIB BINDING
	JSR PC,.STORE	;RESTORE OLD BINDING
PSTP33:	DEC D		;ONE LESS ARG
	BGT PSTOP3	;GET NEXT BINDING IF MORE LEFT
PSTOP4:	BIT #TF3,TFLAGS	;WAS IT A LOCAL PUSH OR PROC PUSH
	BEQ PSTP15	;LOCAL
	CMP #SRET,PSTOPR	;WAS IT "OUTPUT"
	BNE PSTP42	;NO
	PUSHS TOPS1	;PUT THE OUTPUT BACK ON S
	CLR TOPS
	CLR TOPS1
PSTP42:	BIT #DORF,FLAGS	;DO OR READ FRAME?
	BNE PSTP45	;YES
	DEC FUNLEV	;UP ONE LEVEL
PSTP45:
	JSR PC,RESEVL
	MOV B,FLAGS
	BIT #DORF,FLAGS
	BEQ .+6
	JMP @DOFRET
PSTP18:	TST FUNLEV	;IF AT TOP LEVEL, ALMOST DONE!
	BLE PSTOP9	;IT IS
PSTP43:	MOV CPP,B
	JSR PC,.BINDF	;MAKE SURE PROC IS IN
	BEQ PSTPE2	;PROCEDURE ... NOT HERE
.IFNZ SWAPF
	MOV CPP,B	;SEE IF PROC'S CPSN AGREE
	JSR PC,GNASN	;GET CPSN
	BEQ PSTPE3	;IMPOSSIBLE!!!
.ENDC
	MOV CLP,C
	BIS #TF3,TFLAGS
.IFNZ SWAPF
	CMP A,CPSN
	BEQ PSTP41	;OK
	BIC #TF3,TFLAGS
	MOV CPLN,B	;DON'T AGREE, GO RELOCATE LINE WE WERE IN
	JSR PC,GTLINE
	BEQ PSTPE4	;LINE NOT THERE
.ENDC
PSTP41:	MOV C,CLP
	JSR PC,.LOADC	;GET LLP NODE
	JSR PC,.LOAD	;GET LINE #
	MOV A,C
	JSR PC,.LOADC	;GET NEXT NODE-SEE IF SNUM (I.E. GEN NO.)
	BIC #7777,A
	CMP #SNUM,A
	BEQ .+4
	CLR B	;NOT SNUM, SO SET GEN NO. TO 0
	CMP B,CLGN	;ARE GEN #'S =?
	BNE PSTPE4
	BIT #TF3,TFLAGS	;IF PROC WASNT SWAPPED
	BEQ PSTOP8	;THEN CTP IS GOOD
PSTOP9:	CLR D
	MOV CTP,C
	BR PSTOP6
PSTOP8:	MOV CTN,D	;OK, NOW GET NODE NO.
	TST B	;IF B > 0, WE WERE LOOKING GEN NO.
	BEQ PSTOP6
	JSR PC,.LDP1
PSTOP7:	MOV A,C
PSTOP6:	JSR PC,.LOADC
	DEC D
	BGT PSTOP7
	MOV C,CTP
	MOV A,CT
	MOV B,CT+2
	JMP @PSTOPR
PSTPE2:	JSR PC,CHKER
	ERROR+PNH1	;POPPED PROCEDURE NOT HERE
PSTPE3:	JSR PC,CHKER
	.BUG.		;PROCEDURE STRUCTURE SCREWED
PSTPE4:	JSR PC,CHKER
	ERROR+LCE	;LINE CHANGED BY EDIT

RESPPS:	SPOP E	;RESTORE P AND S PDLS
	MOV CPDLP,A
	BIC #TF3+TF7,TFLAGS ;SAVE MODE OF PROC/LOCAL PUSH FLAG
	BIT #1,A
	BEQ .+10
	BIS #TF3,TFLAGS	;SET PROCEDURE PUSH FLAG
	BIC #1,A	;ALWAYS EVEN
	JSR PC,PPTA	;POP P TO (A)
	POP CPDLP	 ;RESTORE OLD CPDLP
	MOV CSPDLP,A
	BIT #1,A
	BEQ .+10
	BIS #TF7,TFLAGS	;ERROR SET FLAG
	BIC #1,A
	JSR PC,PSTA	;POP S TO (A)
	SPOP CSPDLP	;RESTORE OLD CSPDLP
	JMP @E

CHKER:	BIT #HERRF,FLAGS2  ;THIS IS A TERRIBLE THING TO HAPPEN
	BNE CKHER1	;AND IT'S HAPPENED BEFORE!
	BIS #HERRF,FLAGS2  ;OR IF NOT, "DON'T LET IT HAPPEN AGAIN!"
	RTS PC
CKHER1:	CPRTXT ^/HELP!!  RECURSIVE BUG!/
	JSR PC,PPLACE
	CLR CPP
	CLR FUNLEV
	CLR IFLEV
	CLR FLAGS
	JMP ERTL3	;CLEAN UP THE WORLD

DO:	MOV @S,A	;DO...(RUN)
	MOV A,B
	BIC #7777,A
	CMP #LIST,A	;INPUT MUST BE A LIST
	BEQ DO1		;OK
	ERROR+WTAB
DO1:	JSR PC,BLSTI
	PUSH PCHR
	MOV #BLST,PCHR
	CLR NBKTS
	JSR PC,PNODAB	;CONVERT THING ON S TO STRING ON S
	POP PCHR
	JSR PC,BLSTF
	BEQ DO3		;EMPTY STRING
	MOV TOPS,@S
DO2:	JSR PC,READ	;CONVERT STRING ON S TO TOKEN LIST ON S
	BEQ DO4		;NO TOKENS
	JSR PC,SAVEVL
	PUSH #0		;NO. OF ARGS
	JSR PC,SAVPPS	;SAVE PDL POINTERS
	BIS #DORF,FLAGS	;SET FOR DO FRAME
	BIS #1,CPDLP	;RESULTS IN PROC PUSH
	JSR PC,EVLINE	;EVALUATE THE LINE
	BEQ DO5		;NO OUTPUT
	MOV #-1,C
	MOV #RET,PSTOPR	;RETURN ADDRESS (NO OUTPUT)
	BR DO6
DO5:	POPS C		;GET THE "OUTPUT"
	MOV #SRET,PSTOPR	;RETURN ADDRESS (OUTPUT)
DO6:
	JSR PC,RESPPS	;RESTORE PDLS
	POP B
	JSR PC,RESEVL	;RESTORE PROC VALUES
	BIC #EVIFS+DORF,FLAGS
	BIC #-EVIFS-1,B	  ;EVIFS=PTLPF+CRF+RTF
	BIS B,FLAGS
	POPS B
	CMP #-1,C	;WAS THERE OUTPUT?
	BEQ DO7		;NO
	PUSHS C		;PUT "OUTPUT" BACK ON S
DO7:	CLR D
	MOV CTP,C
	JMP	PSTOP6
DO3:	POPS A
DO8:	SEZ
DO4:	RTS PC

SAVEVL:	POP F	;SAVE THE WORLD
	PUSH CPP		;PUSH THE WORLD!
.IFNZ SWAPF
	SPUSH CPSN
.ENDC
	SPUSH CPLN
	SPUSH CLP
	SPUSH CLGN
	SPUSH CTN
	PUSH CTP
	SPUSH FLAGS
	SPUSH CO
	SPUSH CO+2
	SPUSH IFLEV
	SPUSH ERPROC
	JMP @F

RESEVL:	POP F
	POP ERPROC	;PROC, RESTORE REST OF WORLD
	SPOP IFLEV
	SPOP CO+2
	SPOP CO
	SPOP B
	SPOP CTP
	SPOP CTN
	SPOP CLGN
	POP CLP
	SPOP CPLN
.IFNZ SWAPF
	SPOP CPSN
.ENDC
	SPOP CPP
	JMP @F
	.STITL "TO" ETC.
GTLN:	JSR PC,GTUOEB	;GET LINE # FROM NEXT TOKEN INTO B
	BEQ DO8
	MOV #SNUM,A
	JSR PC,CONVER	;MAKE NEXT TOKEN INTO AN SNUM
	RTS PC
GTLP:	PUSH CPP	;GET LINE PTR OF LINE (B) FOR PROC (TOPRNM)
	MOV TOPRNM,CPP	;LEAVE PTR IN C
	JSR PC,GTLINE
	BEQ GTLP1
	POP CPP
	CLZ
	RTS PC

GTLP1:	POP CPP
	ERROR+LDE
EDTITL:	TST TOPRNM
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	JSR PC,EDITA	;SET UP FOR EDIT BUFFER INSERT
	PUSH PCHR
	MOV #ETYO,PCHR
	MOV TOPRNM,B
	JSR PC,SHTITL	;"PRINT" TITLE LINE INTO EDIT BUFFER
	BNE .+4
	.BUG.
	BIS #EDTIF2,FLAGS
	BR EDLIN1
EDLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	BNE .+4
	ERROR+ELW	;EDIT LINE WHAT
	JSR PC,GTLP	;GET PTR TO THAT LINE
	JSR PC,EDITA
	PUSH PCHR
	MOV #ETYO,PCHR
	JSR PC,.LOADC	;GET PTR TO LINE (IN LLP NODE)
	PUSHS B	;FOR INPUT TO PRLN
	JSR PC,PRLN	;"PRINT" THE LINE TO THE EDIT BUFFER
	POPS B
EDLIN1:	POP PCHR
	SEZ
	RTS PC
EDIT2:	CMP #TYI,GCHR
	BNE EDIT3
	CMP #INFIX,A
	BHIS .+4
	ERROR+WTAB
.IFNZ JGB
REDEF:	SAVE A		;SAVE YOUR OLD REGISTERS
	MOV B,OLFUN
	SAVE B
	BIC #177761,B	;FIND WHERE IT GOES IN THE H.T.
	SAVE B
	MOV SYSHTB(B),B	;CHECK THE H.T. FOR THIS FNCT.
	SAVE B
HTLOOK:	BEQ ENTER	;NOTHING IN THAT BUCKET, ENTER IT
	JSR PC,.LOAD
	SAVE A
	JSR PC,.LOAD
	CMP OLFUN,A
	BNE .+4
	ERROR+PAE
	REST B
	BR HTLOOK
ENTER:	PRTXT ^/USED BY LOGO, REDEFINE?/	;ITS A SYS DEF. FUN
	JSR PC,QUEST	;DOES HE WANT TO REDEFINE
	BEQ ENTRE	;YES, GO DO IT
	ERROR+UBL	;SORRY, YOU LOSE
ENTRE:	MOV #1,REDFYN	;SET UP TO MAKE IT POSSIBLE
	REST A
	BIS #LIST,A
	JSR PC,GRBAD
	REST B
	BIS #LIST,C
	MOV C,SYSHTB(B)
	MOV (P),B
	ASL B
	ADD #SOBLST+4,B
	JSR PC,BLSTI
RDLP:	MOVB (B)+,D
	BEQ RDLP1
	JSR PC,BLST
	BR RDLP
RDLP1:	JSR PC,BLSTF
	MOV #LSTR,A
	JSR PC,.INTRN
	REST A
	BIS #UFUN,B
	JSR PC,GRBAD2
	REST A
	JMP TOJ
.IFF
	ERROR+UBL
.ENDC
EDIT3:	JSR PC,CVSFLS
	MOV TOPS,B
	JSR PC,GRBAD
	MOV C,TEMP
	BIS #LIST,C
	MOV C,TOPS2
	JMP TO86
EDIT1:	.IFNZ ENG
	CMP #$TITLE,B
	BNE EDIT1A
	JMP EDTITL
EDIT1A:	CMP #$LINE,B
	BNE .+6
	JMP EDLINE
.ENDC
.IFNZ FR
	CMP #$TITRE,B
	BEQ EDTITL
	CMP #$LIGNE,B
	BEQ EDLINE
.ENDC
		;NOT A VALID EDITING COMMAND
	TST B	;IS THIS A CR?
.IFNZ JGJB
	BEQ JEDIT
	SAVE A		;SAVE YOUR OLD REGISTERS
	MOV B,OLFUN
	BIC #177761,B	;FIND WHERE IT GOES IN THE H.T.
	MOV SYSHTB(B),B	;CHECK THE H.T. FOR THIS FNCT.
HTLK:	BEQ ERRO	;NOTHING IN THAT BUCKET, ENTER IT
	JSR PC,.LOAD
	SAVE A
	JSR PC,.LOAD
	CMP OLFUN,A
	BNE .+4
	BR EDFIX
	REST B
	BR HTLK
EDFIX:	REST A
	BIS #EDITF,FLAGS
	JMP TO0
.IFF
	BEQ .+4
.ENDC
ERRO:	ERROR+NEC
JEDIT:	BIS #EDITF,FLAGS
	MOV LASTPR,B
	BNE TO0
	ERROR+UELX

EDITA:	TST -(P)	;DUMMY ARG
	SAVE <#.TIEDM!.TERST,#.TTBIS_8.+2>
	$INVOK		;RESET EDIT BUFFER AND ENTER EDIT MODE
	RTS PC

ETYO:	TST BRAKE
	BEQ .+4
	RTS PC
	SPUSH D
	SPUSH TYOCP
	BIS #.TTEDM,(P)	;SAY IT SHOULD BE WRITTEN INTO THE EDIT BUFFER
	$BYTO
	RTS PC

EDIT:	BIC #EDTIF,FLAGS
	JSR PC,GTUOEB	;LOOK AT NEXT TOKEN
	BNE EDIT1	;NOT A UOE
	BIS #EDITF,FLAGS
	BR TO0
TO:	BIC #EDITF,FLAGS
	JSR PC,GTUOEB	;GET UOE PTR FROM NEXT TOKEN
	BEQ TOJ
	JMP EDIT2
TOJ:	BIC #170000,B
	BIS #UFUN,B
	MOV B,TOPS2	;SO THIS "TOTALLY WORTHLESS ATOM WONT BE G.C.
	JSR PC,TITLDF
TO0:	TST TOPRNM
	BEQ TO8
	MOV FNLLP,TMPBLK
	BIT #EDTIF,FLAGS
	BNE TO8
	ERROR+CTIT	;CANT "TO" IN TO
TO8:	MOV B,TEMP
	CLR TOPS
	JSR PC,.BINDF
	BEQ TO6
	BIT #EDTIF,FLAGS
	BEQ TO84
	CMP TOPRNM,TEMP
	BNE TO85
	MOV TOPS1,A
	BIS #LIST,A
	JSR PC,.STP2
	MOV TOPS1,B
	BR TITED1
TO84:	MOV A,FNLLP
	BIT #EDITF,FLAGS	;IS IT "EDIT"?
	BNE TO5	;YES
	CMP #TYI,GCHR	;IS INPUT FROM TTY?
	BNE .+4
	ERROR+PAE	;YES - PROCEDURE ALREADY EXISTS
TO86:	BIS #SPDF,FLAGS	;NO - SET SKIP PROC DEF. FLAG
	MOV TEMP,TOPRNM
TO81:	BIT #CRF,FLAGS
	BNE TO82
	JSR PC,GNT	;READ TO END OF LINE
	BR TO81
TO82:	CLR TOPS
	CLR TOPS1
	CLR TOPS2
	RTS PC
TO7:	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
	JSR PC,.LOAD
	MOV A,FNLLP
TO5:	MOV TEMP,TOPRNM
	MOV #'>,PRMTCH
	BR TO82
TO6:	BIT #EDTIF,FLAGS	;EDITING TITLE?
	BNE TITED
	BIT #EDITF,FLAGS	;IS IT "EDIT"
	BEQ TO7	;NO
	ERROR+PNH	;YES, PROCEDUTE NOT HERE
TO85:	ERROR+PAE	;PROC (TEMP) ALREADY EXISTS
TITED:	;EDIT THAT TITLE...
	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
TITED1:	JSR PC,.LOAD
	MOV A,FNLLP
;MAKE NEW PROC POINT TO OLD LINES
	MOV A,C
	MOV TMPBLK,B
	JSR PC,.LOAD
	JSR PC,.STP1
	CMP TEMP,TOPRNM
	BEQ TITED2
	MOV TOPRNM,B
	MOV #FBIND,A
	JSR PC,.UNBND
	MOV TEMP,TOPRNM
TITED2:	BR TO82
GO:	MOV CPLN,JPLN	;SAVE CURRENT LINE # AS LINE JUMPED-FROM
	JSR PC,G1NARG
	MOV B,CPLN
GOUNTL:	CLR CLP
	CLR CT
	CLR CT+2
	BIC #RTF,FLAGS
	SEZ
	RTS PC

RETURN:	JSR PC,G1NARG
	MOV B,TMPBLK
	MOV #RETU1,PSTOPR
	MOV #RETU3,ERFRET	;CATCH ERROR SET FRAME
	MOV #PSTP15,DOFRET
RETU1:	TST FUNLEV
	BEQ PROCE1
	JMP PSTP15
RETU3:	MOV #RETU2,PSTOPR
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
.IFNZ SWAPF
	MOV #-1,CPSN
.ENDC
	BR PROCE2
RETU2:	MOV TMPBLK,CPLN
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
	CLR CTP
	CLR CLP
	JMP MLOOP
CONTINUE:	;MOV	USER,U
;	JSR	PC,BRKMON	;RESTART MUSIC BOX IF APPROPRIATE
	MOV #MLOOP,PSTOPR
	MOV #PSTP15,DOFRET
PROCE2:	TST FUNLEV
	BEQ PROCE1
	BIT #DORF,FLAGS
	BEQ PROCE3
PROCE4:	JSR PC,RESPPS
	POP B
	JSR PC,RESEVL
	BR PROCE2
PROCE3:	MOV CPDLP,A
	BIC #1,A
	JSR PC,PPTA
	MOV CSPDLP,A
	JSR PC,PSTA
	BIC #BRKF,FLAGS
	JMP PSTP43	;TRY RESTARTING
PROCE1:	JMP ERTL3

GTUOEB: 	JSR PC,GNT	;GET UOE PTR FROM NEXT TOKEN IN B
	BIT #CRF,FLAGS
	BEQ .+4
	ERROR+UEL	;UNEXPECTED END OF LINE
	BIC #7777,A	;SKIP UNLESS NEXT TOKEN NOT UOE.  USES A
	CMP #UFUN,A
	BEQ GTU1
	CMP #ATOM,A
	BEQ GTU1
	CMP #LSTR,A
	BNE GTU2
	MOV B,TOPS
	JSR PC,.INTRN
GTU1:	CLR TOPS
GTU2:	RTS PC
TITLDF:		;INPUT-CURRENT TOKEN LIST VIA GNT
		;OUTPUT-TOPS1  - POINTS TO FIRST NODE OF LLP
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV CT,TEMP
	CLR D
TO3:	JSR PC,GNT
	BIT #CRF,FLAGS
	BNE TO4	;DONE
	BIC #7777,A
	INC D
	CMP #UVAR,A
	BEQ TO3
	ERROR+WIT	;WRONG TYPE OF INPUT TO "TO"
TO4:	CMP #MAXARG,D
	BGE TO9
	ERROR+TMAP	;TOO MANY ARGS (PROCEDURE)
	CLR D	;THIS ERROR RETURNS HERE!!
	CLR TEMP
TO9:	MOV #LIST,A
	MOV A,B
.IFNZ SWAPF
	JSR PC,GRBAD	;ZEROTH NODE IN LLP - PTS TO SWAP INFO
	MOV C,TOPS1	;SAVE - PTR TO LLP
.ENDC
	MOV #SNUM,A
	MOV D,B
.IFNZ SWAPF
	JSR PC,GRBAD2	; - # ARGS NODE
	CLR B
	JSR PC,GRBAD1	; - CPSN NODE (START CPSN AT 0)
	MOV TOPS1,C
.IFF
	JSR PC,GRBAD
	MOV C,TOPS1
.ENDC
	MOV #LIST,A
	MOV A,B
	JSR PC,GRBAD1	;FIRST NODE OF LLP - POINTS TO ARG LIST
	MOV TEMP,A
	BIC #170000,A
	BIS #SNUM,A
	MOV D,B	;# ARGS SAVED ABOVE
	JSR PC,GRBAD2	;FIRST NODE OF LINE 0 (ARG LINE)
	JMP RETD
END:	MOV TOPRNM,B
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE DEFINITION
	MOV B,LASTPR	;SAVE FOR "PO"
	TST REDFLG
	BEQ END4
	BIT #SPDF,FLAGS
	BEQ END3
END4:	TST FUNLEV	;DON'T PRINT "FOO DEFINED" IF NOT AT TOP LEVEL
	BEQ END5
	BIT #BRKF,FLAGS
	BEQ END3
END5:	JSR PC,PPNAME
	BIT #SPDF,FLAGS
	BNE END1
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^\ DEFINED\
.IIF NZ FR,	PRTXTC ^/ EST DEFINI/
.IFF
	BIT #FRFLG,LANG
	BEQ END6
	PRTXTC ^/ EST DEFINI/
	BR END7
END6:	PRTXTC ^/ DEFINED/
END7:
.ENDC
END3:	CLR TOPRNM
	BIC #SPDF,FLAGS
	MOV #'?,PRMTCH
END2:	SEZ
	RTS PC
END1:
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^/ SKIPPED/
.IIF NZ FR,	PRTXTC ^/ A ETE PASSE/
.IFF
	BIT #FRFLG,LANG
	BEQ END8
	PRTXTC ^/ A ETE PASSE/
	BR END9
END8:	PRTXTC ^/ SKIPPED/
END9:
.ENDC
	BR END3
	.STITL UTILITY - COUNT LIST ELEMENTS
CLE:		;COUNT LIST ELEMENTS
		  ;IN - LIST PTR IN C
		 ;OUT - # OF ELEMENTS IN B
	PUSH A
	SPUSH C
	CLR B
	MOV C,A
CLE1:	BIT #7777,A
	BEQ CLE2
	MOV A,C
	JSR PC,.LDP1
	INC B
	BR CLE1
CLE2:	POP C
	SPOP A
	RTS PC
	.STITL UTILITY - ADD A LINE
ADLN:		;ON S IS A "NEW LINE" INSERT IN PROPER PLACE
		;IN LLP POINTED TO BY FNLLP.
		;IF "NEW LINE" # IS NEG, DELETE THE LINE
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	MOV @S,C
	JSR PC,.LOADC
	MOV B,F	;SAVE LINE #
	BLT ADLN6	;IF < 0, THIS IS A DELETE
	BIC #TF4,TFLAGS
ADLN7:	MOV FNLLP,C
	JSR PC,.LOADC	;SKIP OVER ARG LINE
	MOV C,D
	MOV A,C
	;LOOK DOWN LLP FOR LINE #(@P)
ADLN1:	MOV D,E	;SAVE PTR TO PREDECESSOR IN E
	MOV C,D	;SAVE PTR TO CURRENT IN D
	MOV #LIST,A
	BIT #7777,C
	BEQ ADLN2	;AT END, ADD NEW NODE
	JSR PC,.LOADC
	MOV A,C	;SAVE PTR TO SUCCESSOR IN C
	JSR PC,.LOAD
	CMP B,F
	BLT ADLN1	;NOT THERE YET
	BEQ ADLN3	;FOUND LINE
	MOV D,A	;OTHERWISE, INSERT NEW LINE
ADLN2:	BIT #TF4,TFLAGS	;PASSED IT - IF DELETE
	BNE ADLN5	;ALL DONE
	MOV @S,B	;ADD NEW NODE TO END
	MOV E,C
	JSR PC,GRBAD1
ADLN5:	JMP RETF
ADLN3:	BIT #TF4,TFLAGS	;FOUND LINE NO.  DELETE?
	BEQ ADLN31	;NO
	MOV C,A	;YES
	MOV E,C
	JSR PC,.STP1
	BR ADLN5
		;NOT DELETE, REPLACE THEN CHECK GEN. NO.
ADLN31:	MOV A,E	;SAVE A, POINT TO FIRST TOKEN IN OLD LINE
	MOV @S,A
	MOV D,C	;D POINTS TO RELEVENT LLP NODE
	JSR PC,.STP2	;STORE LINK TO NEW LINE
	TST FUNLEV	;IF AT FUNLEV 0, DON'T BOTHER WITH GEN #
	BEQ ADLN5
	MOV E,C	;E POINTS TO OLD LINE
	JSR PC,.LOADC	;GET NEXT NODE IN OLD LINE(1ST TOKEN OR GEN )
	BIC #7777,A
	CMP #SNUM,A
	BEQ ADLN4
	CLR B
ADLN4:	INC B	;ALREADY HAS GEN NO.
	MOV @S,C
	JSR PC,.LDP1
	BIC #170000,A
	BIS #SNUM,A
	JSR PC,GRBAD1
	BR ADLN5
ADLN6:	NEG F
	BIS #TF4,TFLAGS
	BR ADLN7
	.STITL UTILITY - GET A LINE, GET ARGS
GTLINE:		;GET LLP POINTER OF LINE WHOSE NO. IS IN B
			;FOR PROCEDURE PONTED TO BY "CPP"
			;OUTPUT - LLP PTR WILL BE IN C AND WILL SKIP
	BIS #TF1,TFLAGS
	BR .+10
GNLINE:		;SAME EXCEPT LOOKING FOR LINE WHOSE # IS > # IN B
	BIC #TF1,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	MOV B,D
	MOV CPP,B
	JSR PC,.BINDF	;LOOK FOR PROC BINDING
	BNE .+4
	.BUG.	;WHAT NO PROC BINDING??!!
	JSR PC,.LOADA
	MOV A,E
GNL1:	BIT #7777,E
	BEQ GNL4	;NONE LEFT
	MOV E,C
	JSR PC,.LOADC	;GET NEXT NODE IN LLP
	MOV A,E
	JSR PC,.LOADB	;GET FIRST NODE OF THAT LINE
	CMP B,D
	BLT GNL1	;NOT THERE YET
	BEQ GNL2	;FOUND IT
	BIT #TF1,TFLAGS	;WENT PAST, WERE WE LOOKING FOR IT?
	BEQ GNL3	;NO, OK
GNL4:	JMP RETE	;YES "NO SUCH LINE NO."
GNL2:	BIT #TF1,TFLAGS	;FOUND IT, LOOKING FOR IT?
	BEQ GNL1	;NO, GET NEXT
GNL3:	MOV C,4(P)	;OUTPUT (C) INTO C
	JMP SRETE
GNASN:		;GET NO. OF ARGS AND CPSN OF USER PROC
		;IN: PROC PTR IN B
		;OUTPUT: CPSN IN A # IN B
		;DONT SKIP IF NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BNE .+6
	JMP RETC
	JSR PC,.LOADB
	MOV B,2(P)	;# IN OLD B
.IFNZ SWAPF
	JSR PC,.LOADA
	MOV B,4(P)	;CPSN IN OLD A
.ENDC
	JMP SRETC
	.STITL UTILITY - LOAD AND STORE
.LOADA:	MOV A,B		;(A) -> A,,B
	BR .LOAD
.LOADC:	MOV C,B	;NODE ADDR IN C
		;NODE RETURNED IN A,B
.LOADB:
.LOAD:	BIC #170000,B	;NODE ADDR IN B
	ASL B	;NODE RETURNED IN A,B
	ASL B
	ADD #NODESP,B
	MOV (B)+,A
	MOV @B,B
	RTS PC
.STORE:	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ASL C	;NODE IN A,B IS STORED AT C
	ASL C
	ADD #NODESP,C
	MOV A,(C)+
	MOV B,@C
	SPOP C
	RTS PC

.STP2:		;SAME AS .STP1 EXCEPT STORE IN 2ND WORD OF NODE
	SEC	;THEN RESULT OF ROL'S WILL BE TWO GREATER THAN  .STP1
	BR .+4
.STP1:	CLC	;STORE (A) IN FIRST WORD OF NODE AT C
	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ROL C
	ROL C
	ADD #NODESP,C
	MOV A,@C
	SPOP C
	RTS PC

.LDP2:	SEC		;NODE ADDR IN C (TYPE FIELD =0)
	BR .+4		;LOAD 2ND WORD OF NODE INTO A
.LDP1:	CLC		;SAME AS .LDP2 EXCEPT 1ST WORD
	MOV C,A
	BIC #170000,A
	ROL A
	ROL A
	ADD #NODESP,A
	MOV @A,A
	RTS PC

.LDP2I:	MOV C,A	;SAME AS .LDP2 EXCEPT C WILL
	BIC #170000,A	;CONTAIN ADDR OF NEXT NODE
	ASL A
	ASL A
	ADD #NODESP,A
	MOV (A)+,C
	MOV @A,A
	RTS PC
	.STITL UTILITY - BINDING
	;INPUT:	A=TYPE	B=UOE POINTER
	;		TOPS=0 OR TYPE+VALUE POINTER
	;OUTPUT:	A - UCHANGED
	;		B - EITHER UNCHANGED OR VALUE POINTER
	;		C - POINTS TO BINDING NODE, EITHER 
	;		    RELEVANT ONE OR LAST IN BINDING LIST
	;		IF TOPS = 0, SKIPS IF BINDING FOUND
	;		IF TOPS NOT = 0, TOPS WILL BE INSERTED
	;		   AS THE NEW VALUE POINTER (A NEW BINDING
	;		   NODE WILL BE ADDED IF NECESSARY) NEVER SKIPS.
.BINDL:	TST TOPS
	BEQ .BIND
	PUSHS TOPS
	CLR TOPS
	JSR PC,.BIND
	BEQ .BNDL2
	POPS TOPS
	CLZ
	RTS PC
.BNDL2L:	POPS TOPS
	SEZ
	RTS PC

.BIND:	PUSH D
	SPUSH B
	SPUSH A
	MOV B,A
BINDF1:	MOV A,C
	JSR PC,.LOADC
	MOV A,D
	BIC #7777,D
	CMP @P,D
	BEQ BINDF4	;FOUND IT
	BIT #7777,A
	BNE BINDF1
	TST TOPS	;DIDNT FIND IT
	BEQ BINDF2	;SHOULD ONE BE CREATED?
	SPOP A
	MOV TOPS,B
	JSR PC,GRBAD1
BINDF5:	POP D	;OLD B
BINDF3:	SPOP D
	SEZ
	RTS PC

BINDF2:	POP A	;NO, DONT CREATE NODE
	SPOP B
	BR BINDF3

BINDF4:	TST TOPS	;FOUND, CHANGE VALUE POINTER?
	BEQ BINDF6
	MOV TOPS,A	;YES + DONT SKIP
	JSR PC,.STP2
	POP A
	BR BINDF5

BINDF6:	POP A	;NO, LEAVE VALUE POINTER, BUT SKIP
	SPOP D	;OLD B
	SPOP D
	CLZ
	RTS PC
.UNBND:	PUSH A	;ERASE TYPE (A) FROM UOE (B)
	SPUSH B	;SKIP UNLESS NOT FOUND
	SPUSH C
	SPUSH D
	MOV B,C
.UNB1:	MOV C,D
	MOV B,C
	BIT #7777,C
	BNE .+6
	JMP RETD
	JSR PC,.LOADC
	MOV A,B
	BIC #7777,A
	CMP 6(P),A
	BNE .UNB1
	MOV D,C
	JSR PC,.LDP1
	BIC #7777,A
	BIC #170000,B
	BIS B,A
	JSR PC,.STP1
	JMP SRETD
.BINDF:	MOV #FBIND,A	;GET FUNCTION BINDING, SWAP IN IF NECESSARY
		;PTR TO UOE IN B
		;OUTPUT AS IN .BIND: EXCEPT A,,B = NODE PTD TO BY C
	JSR PC,.BINDL	;LOOK FOR FUNCTION BINDING
	BEQ BIF1
	JSR PC,.LOADB
	BIT #7777,A	;IS PROC SWAPPED IN?
	BNE BIF1	;YEP
	ERROR+BUG
	CLZ
BIF1:	RTS PC

.BNDFS:	MOV #FBIND,A	;SAME AS .BINDF EXCEPT DONT SWAPIN
	JSR PC,.BINDL
	BEQ BIF1
	JSR PC,.LOADB
	CLZ
	RTS PC

	.STITL .INTRN!!
.OBSCH:		;SAME AS .INTRN EXCEPT WONT INSERT IF ENTRY ISNT FOUND
		;(ALSO SEE UOBSCH ON NEXT PAGE)
	BIC #TF5,TFLAGS
	BR .+10
.INTRN:		;(ALSO SEE UINTRN ON NEXT PAGE)
		;INPUT:  TYPE IN A, LSTR IN "TOPS"
		;OUTPUT:  IF TYPE IS UFUN OR SFUN,
		; SEARCH SYSTEM OBLIST FIRST.
		;  IF FOUND THERE, RETURN THAT PTR IN B,
		; MAKING TYPE OF A TO "SFUN".
		;  IF NOT FOUND THERE, AND IF A=UFUN, OR IF TYPE
		;  IS > "UFUN", DO THE LOOKUP IN THE USER OBLIST.
		;  RETURN WITH THE UOE PTR IN B.
		; DONT SKIP IF A NEW ONE HAD TO BE ADDED,
		;  OR IF IN SEARCHING FOR AN SFUN
		;  ONE WAS NOT FOUND.
;*******  NOTE  ********
;A NEW UOE IS "TOTALLY USELESS" AND SO MUST BE PROTECTED FROM G.C.
	BIS #TF5,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
	CMP #UFUN,A	;IS TYPE SFUN OR UFUN
	BLO INT2	;NO
	JSR PC,SSOL	;YES, SEARCH SYSTEM OBLIST
	BEQ INT1	;NOT THERE
	MOV #SFUN,4(P)	;SET TYPE TO "SFUN"
	BR INT5

INT1:	CMP #SFUN,A	;IS A = TYPE SFUN
	BEQ INT0	;YES, DONE, DONT SKIP
INT2:	JSR PC,HSSL	;NO, HASH TO AND SEARCH SUBLIST
	BEQ INT3

INT5:	MOV B,2(P)
	JMP SRETC	;FOUND ATOM

INT3:	BIT #TF5,TFLAGS	;NOT THERE, SHOULD IT BE ADDED
	BEQ INT0	;NO, RETURN AND DONT SKIP
	SPUSH B		;SAVE WORD POINTER TO LAST NODE OF BUCKET
	MOV #LIST,A
	MOV #ATOM,B
	JSR PC,GRBAD	;CONS UP NEW LAST NODE
			;  (STRANGE TYPE LEST GARBAGE COLLECT)
	BIS #LIST,C
	PUSHS C		;SAVE POINTER TO IT, ALSO FOR G.C.
	MOV #ATOM,A
	MOV TOPS,B
	JSR PC,GRBAD2	;CONS UP ATOM NODE; NEW BUCKET NODE PTS TO IT
	MOV C,4(P)	;SO WILL B ON RETURN
	POPS C
	BIC #LIST,C	;GET BACK POINTER TO NEW BUCKET NODE

	MOV #BUKTEL,A
	JSR PC,.STP1	;MAKE IT AN END-OF-BUCKET NODE
	BIS C,A		;OLE & PTR TO IT
	SPOP C		;TO OLD END-OF-BUCKET WORD
	MOV A,(C)

INT0:	JMP RETC


;"UNPURE" .INTRN AND .OBSCH
;BY "UNPURE" IT IS MEANT THAT THE INPUT STRING MAY INCLUDE
;NULL CHARACTERS
;SPECIFICATIONS ARE OTHERWISE IDENTICAL TO .INTRN AND .OBSCH

;ROUTINE TO PURIFY STRING
UINOB:	PUSH A
	PUSH B
	PUSH C
	MOV	TOPS,B
	JSR PC,CPYSTR	;OUTPUT POINTER IN B TO STRING WITH NO NULLS
	BIS #LSTR,B
	MOV	B,TOPS
	POP C
	POP B
	POP A
	RTS PC

UINTRN:	SPUSH #.INTRN
	BR UINOB

UOBSCH:	SPUSH #.OBSCH
	BR UINOB
	.STITL SEARCH SYSTEM OBLIST
SSOL:		;SEARCH SYSTEM OBLIST
		;INPUT:  C POINTS TO STRING
		;OUTPUT:  SKIP = FOUND AND SOE PTR IN B
		;  NO SKIP = NOT FOUND AND NO CHANGE
		;NULL MUST BE USED AS FILLER CHAR BUT NOT BE IMBEDDED
	PUSH A
	SPUSH B
	SPUSH C		; -> STRING (DESIRED PNAME)
	SPUSH D		; -> CURRENT PNAME
	SPUSH E		; 2^N
	SPUSH F		; -> SYSTEM OBLIST ELEMENT
	MOV SOBP2,E	;GET 2^N
	MOV #SOBLST,F	;GET START OF OBLIST
SSOL1:	ASR E		;HALVE 2^N
	BIT #177776,E	;NOT FOUND IF 2^N = 1
	BEQ SSOL5
	ADD E,F		;ADD 2^N TO OBLIST PTR
	CMP F,SOOMX	;OVERSHOT END OF LIST THEN UNDO ADD
	BHIS SSOL2
	MOV @F,D
	ADD #4+SOBLST,D	;FIND START OF THIS PNAME
	MOV C,A		;AND DESIRED PNAME
SSOL4:	JSR PC,.LOADA	;GET TWO CHARS OF DESIRED
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED:  ADD 2^(N-1)
	BLO SSOL2	;PNAME > DESIRED:  UNADD 2^N AND ADD 2^(N-1)
	SWAB B
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED
	BLO SSOL2	;PNAME > DESIRED
	BIT #7777,A	;MORE PNAME TO COMPARE?
	BNE SSOL4	;YES
	TSTB B		;MATCHING NULLS FOUND?
	BEQ SSOL3	;FOUND
	TSTB (D)	;AT END OF STRING, IS IT END OF SYS PNAME
	BNE SSOL2	;NO:  TRY ANOTHER (COUNT AS OVERSHOOT)
SSOL3:	MOV (F),F	;POINTER TO OBLIST ELEMENT
	.IFNZ ENG&FR
	BIT LANG,SOBLST(F)
	BEQ SSOL5
	.ENDC
	BIT #ABRFLG,SOBLST(F)	;IS IT AN ABBRVIATION?
	BEQ .+6
	MOV 2+SOBLST(F),F	;YES, "EXPAND" IT
	ASR F
	MOV F,10(P)	;YES, SAVE F AS OUTPUT
	JMP SRETF

SSOL5:	JMP RETF

SSOL2:	SUB E,F		;UNADD 2^N
	BR SSOL1
	.STITL HASH AND SEARCH USER SUB-OBLIST
HSSL:		;HASH, THEN SEARCH SUB-LIST
		;INPUT:  C POINTS TO LSTR
		;OUTPUT:  IF NOT FOUND, B IS A WORD POINTER
		;	 TO LAST BUCKET ELEMENT.
		;  IF FOUND, B POINTS TO ATOM CELL, AND RETURN SKIPS.
	PUSH A
	SPUSH B		;PTR TO THIS PNAME
	SPUSH C		;PTR TO DESIRED PNAME
	SPUSH D		;NEXT OLE
	SPUSH E		;THIS OLE
	MOV C,A		;PTR TO STRING
	CLR D		;SUM OF WORDS FOR HASHING
HSSLA:	JSR PC,.LOADA	;GET A TWO-LETTER FRAGMENT
	ADD B,D		;ADD IN
	BIT #7777,A	;MORE FRAGMENTS?
	BNE HSSLA	;YES
	MOV D,B		;CREATE SUM OF ALL CHARS
	SWAB B
	ADD D,B		;IN LOWER BYTE (UPPER WON'T HURT)
	CLR A
	DIV #HCC,A
	ASL B
	ADD #UHCT,B
	MOV B,E		;RETURN ADDR OF LAST ELEMENT OF BUCKET IF NOT FOUND
	MOV @B,A	;A POINTS TO FIRST OLE NOW
HSSL1:	BIT #7777,A	;END OF BUCKET?
	BNE HSSLB
	MOV E,6(P)	;YES: NOT-FOUND RETURN:
	JMP RETE	;OUTPUT END-OF-BUCKET POINTER IN B

HSSLB:	MOV A,E		;SAVE PTR TO THIS OLE
	JSR PC,.LOADA	;GET THIS OLE
	MOV A,D		;SAVE PTR TO NEXT ONE
	JSR PC,.LOADB	;GET FIRST NODE OF ATOM STRUCTURE
	JSR PC,CSEQ	;CSEQ COMPARES STRINGS AT (B) AND (C)
	BEQ HSSL2	;NOT EQUAL:  TRY NEXT OLE
	MOV E,A		;EQUAL:
	JSR PC,.LOADA	;OUTPUT ATOM POINTER
	MOV B,6(P)
	JMP SRETE	;SKIP RETURN

HSSL2:	MOV D,A		;NOT FOUND, CHECK NEXT BUCKET ELEMENT
	BIC #LIST,E	;MAKE E A WORD PTR TO FIRST WORD OF PREV. NODE
	ASL E		;IN CASE IT'S THE LAST ONE.
	ASL E
	ADD #NODESP,E
	BR HSSL1
CSEQ:	PUSH A		;COMPARE TWO STRINGS - POINTERS IN B & C
	PUSH B		;SKIP IF EQUAL
	PUSH C		;"NULL" (8-BIT ON) CHARACTERS
	PUSH D		;  DON'T MATCH CORRESPONDING 8-BIT OFF CHARS
	MOV B,D		;SAVE STR 1 PTR
CSEQ1:	BIT #7777,D	;CHECK IF EITHER STRING DONE
	BEQ CSEQ3	;FIRST IS:  IS SECOND?
	BIT #7777,C
	BEQ CSEQ2	;SECOND BUT NOT FIRST:  NOT EQUAL
	MOV D,A
	JSR PC,.LOADA	;GET NEXT NODE OF STR 1: (A) TO A,,B
	MOV A,D	;SAVE POINTER IN D
	JSR PC,.LDP2I	;GET NEXT NODE OF STR 2: (C) TO C,,A
	CMP A,B
	BEQ CSEQ1	;WELL, THESE WORDS MATCH
CSEQ2:	JMP RETD	;STRINGS NOT EQUAL

CSEQ3:	BIT #7777,C	;SEE IF BOTH STRINGS ARE DONE
	BNE CSEQ2	;NOPE, NOT EQUAL
	JMP SRETD	;STRINGS EQUAL
	.STITL UTILITY - GRAB NODE ROUTINES
GRBAD2:	SEC	;GRAB A FREE NODE, FILL IT WITH A,,B
			;IF C NOT =0, PUT PTR TO NEW NODE IN WORD 2 OF NODE(C)
			;C ALSO GETS POINTER TO NEW NODE REGARDLESS
	BR .+6
GRBAD:	CLR	C	;SAME AS ABOVE EXCEPT NEW POINTER ALWAYS IN C
GRBAD1:	CLC	;SAME AS ABOVE EXCEPT NEW PTR IN WORD 1
	SPUSH A
	BIC #170000,C
	BEQ GRB2	;C IS ZERO, FORGET STORING NEW NODE PTR
	ROL C
	ROL C
	ADD #NODESP,C	;ELSE MAKE NODE ADDRESS TO STORE AT
GRB2:
	BIT #MGCF,FLAGS2
	BNE GRB4
	MOV FREE,A
	BNE GRB1
GRB4:	JSR PC,.GCOLL
	MOV FREE,A
	BNE GRB1
	CLR ERPROC	;DISABLE ERRSET IF 0 NODES
	ERROR+NSL	;NO STORAGE LEFT
GRB1:	DEC NNIFSL
	BGE .+4		;NEG NODES LEFT??
	.BUG.
	TST C
	BEQ GRB3
	BIC #170000,A
	BIC #7777,@C
	ADD A,@C
GRB3:	MOV A,C
	JSR PC,.LDP1
	SPUSH A		;CHECK THAT NODE WAS IDLE
	BIC #7777,A
	CMP #IDLE,A
	BEQ .+4
	.BUG.		;GRABBED AN UNIDLE NODE!!!!!
	SPOP A
	BIC #170000,A
	MOV A,FREE
	SPOP A
	JSR PC,.STORE
	RTS PC
	;.STITL UTILITY  -  FREE NODE ROUTINES
.FREE:	SPUSH A	;RETURN NODE IN C TO FREE STORAGE
	SPUSH B
	MOV FREE,A
	BIS #IDLE,A
	CLR B		;MAKE SURE POINTER 2 IS ZERO
	JSR PC,.STORE
	BIC #170000,C
	MOV C,FREE
	INC NNIFSL
	SPOP B
	SPOP A
.FREE1:	RTS PC
FRELST:	BIT #7777,TOPS	;RETURN LIST (TOP-LEVEL ONLY) IN TOPS
			;TO FREE STORAGE
	BEQ .FREE1
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
FRL1:	JSR PC,.LOADC
	JSR PC,.FREE
	BIT #7777,A
	BEQ FRL2
	MOV A,C
	BR FRL1
FRL2:	CLR TOPS
	JMP RETC
	.STITL READ A STRING

RDSTR7:	BIS #RBRKF,TFLAGS
	SEZ
RDSTR8:	RTS PC
RDSTR1:	PRCR	;OUTPUT - PTR ON S, SKIP UNLESS EMPTY OR BREAK
RDSTR:	CLR NBKTS
	TST	BRAKE
	BNE RDSTR7
	CMP #TYI,GCHR	;WILL CHARS BE COMING FROM TTY?
	BNE RLINE1	;NO
	MOV PC,INPUTH
	TST BRAKE
	BEQ .+4
	ERROR+BRK
	MOV PRMTCH,D
	BEQ	RLINE
;	TST ALEVN
;	BEQ RLINE2
	BIT #BRKF,FLAGS
	BEQ RLINE2
	MOV FUNLEV,A
	BEQ RLINE2
LANGC	<MOV #'L,D>,<
	MOV #'N,D>
	JSR PC,TYO
	JSR PC,PRDN
	MOV PRMTCH,D
RLINE2:	JSR PC,TYO
RLINE:RLINE1:	JSR PC,BLSTI
RDSTR2:	JSR PC,@GCHR
	CLR INPUTH
	CMP #TYI,GCHR
	BEQ RDST2A
	CMP #2,D	;NOT FROM TTY: CHANGE ^B TO %
	BNE RDST2A	;(PRINTS AS SPACE STILL)
RDST2A:	TST	BRAKE
	BNE	RDSTR7
	CMP #EOFCHR,D
	BNE RDSTR9
	MOV #TYI,GCHR	;NON-TTY INPUT DONE
	MOV #'],D	;FILL IN MISSING ]'S
	TST NBKTS
RDSR10:	BLE RDSTR4
	JSR PC,BLST
	DEC NBKTS
	BR RDSR10
RDSTR9:	CMP #'G-100,D	;BREAK TYPED?
	BEQ RDSTR7	;YES
	CMP #'Z-100,D
	BEQ RDSTR7
	TST NBKTS	;IN A LIST?
	BGT RDSTR3	;YES
	CMP #15,D	;CR?
	BEQ RDSTR4
RDSTR3:	CMP #'[,D
	BNE RDSTR6
	INC NBKTS
RDSTR6:	CMP #'],D
	BNE RDSTR5
	DEC NBKTS
RDSTR5:	JSR PC,BLST
	BR RDSTR2
RDSTR4:	BIC #RBRKF,TFLAGS
	JSR PC,BLSTF
	BEQ RDSTR8
	PUSHS TOPS
	CLR TOPS
RDSTSR:	CLZ
	RTS PC

	.STITL REQUEST, FILE READ & WRITE
RQUEST:
RQU1:	PUSH PRMTCH
	JSR PC,INPUTL
	BEQ RQU5
	MOV E,C	;E POINTS TO LAST NODE OF STRING
	JSR PC,.LOADC	;NEED TO ADD A "]", IS THERE ROOM?
	BIT #177400,B
	BNE RQU2	;YES
	BIS #']*400,B	;NO - PUT A "]" THERE
	JSR PC,.STORE
RQU3:	MOV @S,GNCN
	BIC #170000,GNCN
	JSR PC,RDLST
	POPS TOPS
RQU4:	MOV TOPS,@S
	CLR TOPS
RQUR:	POP PRMTCH
	CLZ
	RTS PC
RQU2:	MOV #'],B
	JSR PC,GRBAD1
	BR RQU3
RQU5:	MOV #LIST,@S
	BR RQUR
INPUTL:	MOV #'<,PRMTCH
	CMP -(P),-(P)
	SPUSH TYICP
	BIS #.TTCNO*400,(P)
	$INVOK
	TST (P)+
	BEQ .+6
	CLR PRMTCH
	JSR PC,RDSTR
	BNE IPUL2
IPUL1:	BIT #RBRKF,TFLAGS
	BEQ IPUL3
	POP PRMTCH	;THE RETURN
	SPOP PRMTCH	;NOW THE OLD PRMTCH
	ERROR+BRK
IPUL3:	PUSHS #LSTR
	SEZ
IPUL2:	RTS PC
TYPEIN:	JSR PC,RQU1	;INPUT A WORD FROM TTY
	BIT #7777,@S
	BNE TYPIN2
	MOV #LSTR,@S
	RTS PC
TYPIN2:	JMP FIRST
	.STITLE  READ -

READ:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	CLR RDFLAG
	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F
READA:	JSR PC,RDWRD
	BEQ READB
	BIS #SEPF,RDFLAG
	JSR PC,CKDOTF
READC:	JSR PC,LISTB
	BIT #SEPF,RDFLAG
	BEQ READA
READB:	BIC #SEPF,RDFLAG	;CHECK SPECIAL CHAR IN D
	JSR PC,CKDOTF	;FIRST CHECK FOR PENDING ":"
	CMP #15,D
	BEQ READR	;C-R
	CMP #'",D
	BEQ READS	;STRING
	CMP #'[,D
	BEQ READL	;LIST
	CMP #'],D
	BNE .+4
	ERROR+COP	;CHAR (]) OUT OF PLACE
	CMP #':,D
	BEQ READD	;DOTS
	BITB #OPERF,DTBL(D)	;IS CHAR AN OPERATOR
	BEQ READA	;NO
	MOVB DTBL2(D),A
	ASL A
	MOV SOBLSU(A),B
		;SET TYPE TO SFUN OR INFIX
	MOV SOBLST(B),A	;THIS CROCK WORKS BECAUSE #SFUN=0
	BIC #-INFIX-1,A	; AND #INFIX=10000
	ASR B
	BR READC
READR:	POPS A
	CLR	TOPS
	TST	F
	BNE	READR1
	JMP RETF
READR1:	MOV A,@S
	JMP SRETF

READS:	JSR PC,GNC
	JSR PC,RDST
	BIS #SEPF,RDFLAG
	BR READC
READL:	JSR PC,RDLST
	POPS TOPS
	BIC #SEPF,RDFLAG
	BR READC
READD:	BIS #DOTF,RDFLAG
	BR READA
	.STITLE READ - READ WORD
	;READ CHARS UP THRU NEXT SEPARATOR CHAR.  IF JUST A SEP, RETURN
	;WITH IT IN D.  OTHERWISE NUMBERIFY OR INTERN CHAR STRING,
	;SKIP RETURN WITH TOKEN IN A,,B
RDWRD:	CLRB RDFLAG
	JSR PC,BLSTI
RDWA:	JSR PC,GNC
	JSR PC,GETCHF	;GET FLAGS IN A
	BIT #SEPF,A	;IS THIS CHAR A SEPARATOR?
	BNE RDWB	;YES
	BISB A,RDFLAG
	JSR PC,BLST
	BEQ RDWA
RDWB:	JSR PC,BLSTF	;FINISH OFF STRING
	BEQ RDWR+2
	BIT #NNUMF,RDFLAG
	BNE RDWC	;NOT A POSSIBLE NUMBER
	MOV TOPS,B
	MOV #LNUM,A
	JSR PC,CONVER	;TRY MAKING A #
.IFNZ FPPF
	BNE RDWR1
	MOV #FNUM,A
	JSR PC,CONVER	;IT MIGHT BE AN FNUM
.ENDC
	BNE RDWR1
RDWC:	MOV #UFUN,A	;TRY TO INTERN STRING IN TOPS AS A SYSTEM OR USER FUNCTION
	BIT #DOTF,RDFLAG	; UNLESS DOTF ON, THEN AS USER VARIABLE
	BEQ RDWD
	MOV #UVAR,A
	BIC #DOTF,RDFLAG
RDWD:	JSR PC,.INTRN	;RDST COMES HERE ALSO
	BEQ RDWE
	JSR PC,FRELST
RDWE:	BIC #170000,B
	BIS A,B
	CMP #UFUN,A	;IF WE GOT A UOE
	BHI RDWR+2	;THEN--
RDWR1:	MOV B,TOPS	;PROTECT THIS NEWLY HATCHED UOE FROM G.C.
RDWR:	CLZ
	RTS PC

GETCHF:		;GET FLAGS FOR CHAR IN D INTO A
	MOV #NNUMF,A
	TSTB D	;CHECK FOR 200 BIT
	BLT .+6
	MOVB DTBL(D),A
	RTS PC
	.STITLE READ - READ STRING
	;READ CHAR UP TO NEXT SPACE OR ] IF INSIDE
	;A LIST.  DONT ALLOW ] OR [.
	; SKIPS UNLESS EMPTY STRING
RDST:	CLRB RDFLAG
	JSR PC,BLSTI
	BR RDSB
RDSA:	JSR PC,GNC
RDSB:	JSR PC,GETCHF
	BIT #SEPF,A
	BEQ RDSE
	CMP #' ,D
	BEQ RDSX
	CMP #'],D
	BEQ RDSC
	CMP #'[,D
	BEQ RDSX
	CMP #15,D
	BEQ RDSX
RDSE:	BISB A,RDFLAG
	JSR PC,BLST
	BR RDSA
RDSC:	TST LISTBD	;ARE WE IN LIST
	BNE RDSX	;YES
RDSD:	ERROR+COP	;CHAR (D) OUT OF PLACE
RDSX:	MOV #LSTR,A
	MOV #LSTR, B
	JSR PC,BLSTF
	BEQ RDWR+2
	MOV #LSTR,A
	MOV TOPS,B
	BIT #NNUMF,RDFLAG
	BEQ RDWR	;IT IS A POSSIBLE NUMBER
	BIT #SEPF,RDFLAG
	BNE RDWR+2	;IT HAS A SEP CHAR IN IT
	MOV #ATOM,A
	BR RDWD	; INTERN IT
	.STITL READ - READ LIST
	;READ THRU MATCHING ] MAKING A LIST AS U GO
RDLST:	CLRB RDFLAG
	JSR PC,SLISTB
RDLA:	JSR PC,GNC
	CMP #' ,D
	BEQ RDLA	;SKIP OVER SPACES
	CMP #'[,D
	BEQ RDLB	;READ A LIST
	CMP #'],D
	BEQ RDLY	;DONE
	JSR PC,RDST	;READ A STRING
RDLX:	JSR PC,LISTB	;ADD THIS NODE TO LIST
	CMP #'[,D
	BEQ RDLB
	CMP #'],D	;AT END?
	BNE RDLA	;NO, GET NEXT ELEMENT
RDLY:	JSR PC,FLISTB
	RTS PC
RDLB:	JSR PC,RDLST
	POPS TOPS
	CLR D
	BR RDLX
	.STITLE READ - MISC
CKDOTF:	BIT #DOTF,RDFLAG
	BEQ LISTBR
	BIC #DOTF,RDFLAG
	PUSH A
	SPUSH B
	MOV #SFUN,A
	MOV #$DOTS,B
	JSR PC,LISTB
	JMP RETB
LISTB:	PUSH C
	MOV F,C	;BUILD A LIST, ADD NODE IN A,,B TO
	JSR PC,GRBAD1	;LIST WHOSE LAST NODE PTR IS IN F
	TST F	;CAREFUL - THE FIRST TIME IT IS CALLED, THE
		;POINTER TO THE FIRST NODE IS PUSHED ONTO S
	BNE LISTB1
	PUSHS	C
	BIS #LIST,@S
LISTB1:	MOV C,F
	POP C
LISTBR:	RTS PC
SLISTB:		;START LISTB
	PUSHS F	;SAVE CURRENT LAST NODE PTR
	CLR F
	INC LISTBD
	RTS PC
FLISTB:	TST F
	BNE FLSB1
	PUSHS #LIST
FLSB1:	POPS B	;THIS IS THE OUTPUT
	MOV @S,F	;RESTORE OLD LAST NODE PTR
	MOV B,@S	;THE RESULT
	MOV #LIST,A
	DEC LISTBD
	RTS PC
BLSTI:	CLR NCHR
	CLR E
	CLR TOPS
BLSTI1:	BIS #100000,E
	RTS PC
BLST:		;BUILD STRING - CHAR IN D, USES E
	PUSH A
	SPUSH B
	SPUSH C
	CMPB #200,D	;CHECK IF NULL CHARACTER
	BEQ BLSTRT
	BIT #177,D	;CHECK IF NULL
	BEQ BLSTRT
	INC NCHR	;WE HAVE A CHAR
	ADD #40000,E
	BGE BLST2	;IS IT  THE SECOND
	MOVB D,TEMP	;NO, 1ST
BLSTRT:	JMP RETC
BLST2:	MOVB D,TEMP+1	;IT IS THE SECOND CHAR
	MOV TEMP,B
	;STORE THE CHARACTERS
BLST3:	JSR PC,BSAN
	BIS #100000,E
	BR BLSTRT
BLSTF:	;FINISH BUILDING STRING, PUT PTR IN TOPS.
		; DONT SKIP IF EMPTY STRING (TOPS=0)
	TST NCHR
	BEQ BSANR	;EMPTY STRING
	ADD #40000,E
	BLT BSANR
	PUSH A
	SPUSH B
	SPUSH C
	MOVB TEMP,B	;YES
	JSR PC,BSAN
BLSTF1:	JMP SRETC
BSAN:	MOV E,C
	MOV #SSTR,A
	JSR PC,GRBAD1
	TST E
	BNE BSAN1
	MOV C,TOPS	;SAVE NEW STRING PTR ON S
	BIS #LSTR,TOPS
BSAN1:	MOV C,E
BSANR:	RTS PC
	.STITL GNC - GET NEXT CHAR
GNC:	PUSH A		;GET NEXT CHAR INTO D
	SPUSH B		;INITIALIZE BY MOVING LSTR PTR INTO GNCN
GNC4:	MOVB GNCN+2,D	;    AND CLEARING TYPE FIELD (#170000)
	MOV GNCN,B	;PUTS CR (=#15) IN D IF NO MORE CHAR
	BLT GNC1	;JUST GOT 2ND CHAR
	BNE GNC3
	MOV #15,D
	JMP RETB	;NONE LEFT
GNC3:	JSR PC,.LOAD	;GET NEXT NODE
	BIS #100000,A	;SET "STILL ANOTHER CHAR" BIT
	MOV A,GNCN
	MOVB B,D	;FOR OUTPUT
	SWAB B
	MOVB B,GNCN+2
GNC2:	TST D
	BEQ GNC4	;IGNORE NULL CHARS
	JMP RETB
GNC1:	BIC #170000,GNCN	;CLEAR "STILL ..." BIT
	BR GNC2
	.STITL PRINT ROUTINES

PRLO:	PUSH A	;PRINT LAST OPERATOR
	SPUSH B
	MOV LO,A
	BEQ EMPTY
	MOV LO+2,B
	BR PRCO1
PRCO:	PUSH A,	;PRINT CURRENT OPERATOR
	SPUSH B
	MOV CO,A
	MOV CO+2,B
	BEQ EMPTY
PRCO1:	SPUSH D
	JSR PC,PROAB
	SPOP D
	JMP RETB
PROAB:	CMP A,#UFUN	;PRINT OPERATOR IN A,B
	BLO PRCO2
	JMP PPNAME	;PRINT PNAME
PRCO2:	MOV B,A	;SYSTEM FUNCTION
	BNE PRCO3
	PRTXT ^\ CR.\
	RTS PC
PRCO3:	ASL A
	ADD #4+SOBLST,A
	BR	PRAS	;PRINT ASCIZ PNAME
NOTPRO:	ERROR+OOP	;SOMETHING OUT OF PLACE
EMPTY:	PRTXT ^\ EMPTY \
	JMP RETB

ERTAS:	SPUSH D
.IFZ TS
ERTAS1:	MFPI (A)
	MOVB (P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	MOVB 1(P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	ADD #2,A
	TST (P)+
	BR ERTAS1
ERTAS2:	ADD #2,A
	TST (P)+
.IFF
	SPUSH B
	SPUSH C
MAPRD3:	MOV A,C		;ADDRESS IN I SPACE
	ASH #-13.,C	;PAGE IN I SPACE
	BIC #177770,C	;WHAT WE WANT IS A LSH (OR A BOTTLE OF BOOZE)
	SPUSH #7*400+0
	SPUSH C
	SPUSH #<10+HAKPG>*400+1
	SPUSH #.CRRD+1
	.MAP
	BNE .+4
	BPT
	MOV A,B
	BIC #160000,B
	ADD #HAKAD,B
MAPRD1:	MOVB (B)+,D
	BEQ MAPRD2
	JSR PC,@PCHR
	INC A
	CMP B,#HAKAD+20000
	BEQ MAPRD3
	BR MAPRD1
MAPRD2:	INC A
	BIT #1,A
	BEQ .+4
	INC A
	SPOP C
	SPOP B
.ENDC
	SPOP D
	RTS A


PRAS:	SPUSH	D	;PRINT ASCIZ STRING POINTED TO BY A
	BR	.+6
PRAS1:	JSR	PC,@PCHR
	MOVB	(A)+,D
	BNE	PRAS1
	SPOP	D
	RTS	PC

PRON:	BIC #TF2,TFLAGS	;PRINT OCTAL NO., NO. IN A
	BR PRON1	;CALL-	JSR PC,PRON
PRONL:	BIS #TF2,TFLAGS
PRON1:	PUSH A		;PRON DOESN'T PRINT LEADING ZEROS, PRONL DOES
	SPUSH D
	CLR D
	SEC
	ROL A	;TO TELL WHEN WE ARE DONE
	BR PRON2
PRON3:	CLR D
	ASL A
	BEQ PRON5
	ROL D
	ASL A
	ROL D
	ASL A
PRON2:	ROL D
	BNE PRON4
	BIT #TF2,TFLAGS
	BEQ PRON3
PRON4:	BIS #TF2,TFLAGS
	BIS #60,D
	JSR PC,@PCHR
	BR PRON3
PRON5:	BIS #60,D
	BIT #TF2,TFLAGS
	BNE .+6	;IF NOTHING HAS BEEN TYPED, TYPE A ZERO
	JSR PC,@PCHR
	SPOP D
	SPOP A
	RTS PC
PRDN:	PUSH B		;PRINT DECIMAL NO. IN A
	SPUSH C
	SPUSH D
	CLR C
	MOV A,B
	BGT PRDN1	;POSITIVE
	BEQ PRDN0	;ZERO
	NEG B		;NEGATIVE:
	MOV #'-,D	;"-" (ABS VAL)
	JSR PC,@PCHR
PRDN1:	INC C		;COUNT A STORED DIGIT
	CLR A
	DIV #10.,A	;DIVIDE BY 10
	PUSH B		;SAVE REMAINDER = NEW DIGIT
	MOV A,B		;QUOTIENT:  = 0?
	BNE PRDN1	;NO:  GET SOME MORE LOW-ORDER DIGITS
PRDN2:	POP D		;GET SAVED HIGH-ORDER DIGIT
	ADD #'0,D	;ENCODE IT
	JSR PC,@PCHR	;PRINT IT
	DEC C
	BGT PRDN2	;UNTIL NO. DIGITS LEFT = 0
PRDNX:	POP D
	SPOP C
	SPOP B
	RTS PC

PRDN0:	MOV #'0,D	;TYPE "0"
	JSR PC,@PCHR
	BR PRDNX

EMPTY1:	JMP EMPTY
PRS1:	PUSH A	;PRINT TOP ELEMENT OF SS
	SPUSH B
	MOV #IS,A	;COMPUTE RELATIVE S PD PTR
	SUB S,A
	ADD SPRBAO,A
	CMP A,CSPDLP
	BLOS EMPTY1
	MOV @S,B
	SPUSH D
	JSR PC,PNODAB
	SPOP D
	JMP RETB
PNODAB:	MOV B,A
	BIC #7777,A
	CMP #SSTR,A
	BEQ PRS11
	CMP #SNP,A
	BLOS PRS11
	ERROR+INVN	;INVALID NODE
PRS11:	JSR PC,PRDATA
	RTS PC
PRCT:	PUSH A	;PRINT CURRENT TOKEN
	SPUSH B
	SPUSH D
	MOV CT,A
	MOV CT+2,B
	JSR PC,PRTAB
	SPOP D
	JMP RETB
PRTAB:	BIC #7777,A	;PRINT TOKEN IN A,B
	CMP A,#UVAR
	BHIS .+6
	JMP PROAB
	CMP A,#UVAR
	BEQ PRUV
	BR PRDATA
PRATM:	BIS #PQF,FLAGS2	;PRINT ATOM IN A,B
	BR PRUV1
PRUV:	MOVB #':,D	;PRINT USER VARIABLE IN A,B
	JSR PC,@PCHR
PPNAME:	BIC #PQF,FLAGS2	;PRINT PNAME - UOE PTR IN B
PRUV1:	JSR PC,.LOAD
	JMP PRLSTR	;PRINT PNAME
PRDATA:	CMP #INUM,A	;PRINT DATA IN A,B. 7777 FIELD OF A IS 0000
	BEQ PRINUM	;NUMBER
.IFNZ FPPF
	CMP #FNUM,A
	BEQ PRFNUM
.ENDC
	CMP #SNUM,A
	BEQ PRSNUM
	BIS #PQF,FLAGS2	;SET PRINT QUOTE FLAG
	CMP #ATOM,A
	BEQ PRUV1
	CMP #LSTR,A
	BEQ PRLSTR	;LONG STRING
	CMP #SSTR,A
	BEQ PRSSTR	;SHORT STRING
	BIC #PQF,FLAGS2
	CMP #LIST,A
	BEQ PRLST
	TST WRTFLG
	BEQ	PRSNP	;YES
	PRTXT	^/" /	;OUTPUT EMPTY
	BR	PRSRET
PRSNP:	PRTXT ^\%SNAP%\	;CANT PRINT A SNAP
	BR PRSRET
PRLSTR:	JSR PC,.LOAD	;PRINT LONG STRING
PRSSTR:	JSR PC,PRQQ	;PRINT SHORT STRING
PRSTR2:	MOVB B,D
	JSR PC,PRSPT
PRSTR3:	SWAB B
	MOVB B,D
	JSR PC,PRSPT
PRSTR4:	MOV A,B
	BIC #170000,B
	BEQ PRSRET
	JSR PC,.LOAD
	BR PRSTR2
PRSRET:	RTS PC
PRQQ:	BIT #PQF,FLAGS2	;PRINT ' " ' IF PQF=1
	BEQ PRSRET
	BIT #DPQF,FLAGS2
	BNE PRSRET
	MOVB #'",D
	JMP @PCHR
.IFNZ FPPF
PRFNUM:	PUSH C
	JSR PC,.FLOAD
	MOV #FNUM,C
	BR PRFNM1
.ENDC
PRSNUM:	CLR A	;PRINT SNUM
	TST B
	BGE PRINM1
	COM A
	BR PRINM1
PRINUM:	JSR PC,.LOAD	;PRINT INUM
PRINM1:	PUSH C
.IFNZ FPPF
	 MOV #INUM,C	;SET FLAG FOR INUM ENTRY
.ENDC
PRFNM1:	MOV E,TMPBLK+2
	MOV F,TMPBLK+4
.IFNZ FPPF
	CMP #FNUM,C
	BNE .+8
	JSR PC,.CFNST
	BR .+6
.ENDC
	JSR PC,.CINST	;CONVERT INUM IN A,,B TO STRING ON P
	MOV TMPBLK+2,E
	MOV TMPBLK+4,F
	MOV P,A
	MOVB (A)+,D
	BNE PRINM3
PRINM2:	MOVB (A)+,D
	BEQ PRINM4
PRINM3:	JSR PC,@PCHR
	BR PRINM2
PRINM4:	INC A	;TO MAKE IT EVEN (??)
	MOV A,P
	POP C
PRSPT2:	RTS PC

PRSPT:	CMPB #200,D
	BEQ PRSPT2
	TSTB D
	BEQ PRSPT2
	BIT #CPTBF,FLAGS2
	BEQ PRSPT1
	CMPB #'%,D
	BNE .+6
	MOV #' ,D
PRSPT1:	JMP @PCHR
PRLST:	PUSH A	;PRINT LIST, PTR IN B
	SPUSH B
	SPUSH C
	TST NBKTS
	BEQ PRL4
	MOV #'[,D
	JSR PC,@PCHR
PRL4:	INC NBKTS
	MOV B,C
PRL1:	SPUSH FLAGS2
	BIT #7777,C	;EMPTY LIST
	BEQ PRL2	;YES, DONE
	BIS #DPQF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
	BR PRL3
PRL6:	SPACE
PRL3:	JSR PC,.LOADC	;GET THIS NODE
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	JSR PC,PRTAB
	BIT #7777,C
	BNE PRL6
PRL2:	DEC NBKTS
	BEQ PRL5
	MOV #'],D
	JSR PC,@PCHR
PRL5:	BIC #DPQF,FLAGS2
	SPOP C	;GET OLD FLAGS2
	BIC #<-DPQF-1>,C	;MASK ALL BUT DPQF
	BIS C,FLAGS2	;AND RESTORE IT
	JMP RETC
PRNODE:	PUSH A	;PRINT NODE POINTED TO BY B
	SPUSH B
	SPUSH D
	JSR PC,.LOAD
	JSR PC,PRON
	SPACE
	MOV B,A
	JSR PC,PRON
	SPOP D
	JMP RETB


	.STITL PRINTOUT (ONCE KNOWN AS SHOW)
SHALPR:		;SHOW ALL PROCEDURES
		;USES A-F
	JSR PC,GNOLEI
	BR SHALP2
SHALP1:	JSR PC,.CRLF
SHALP2:	JSR PC,GNOLE
	BEQ SHOWA1
	JSR PC,BURYQ
	BEQ SHALP2
	JSR PC,PSHOW
	BNE .+4
	.BUG.
	CMP PCHR,#TYO
	BNE SHALP2
	BR SHALP1

POTS:
SHALTI:	;SHOW ALL TITLES
	JSR PC,GNOLEI
SHATI1:	JSR PC,GNOLE
	BEQ SHOWA1
	JSR PC,BURYQ
	BEQ SHATI1
	JSR PC,SHTITL
	BR SHATI1

SHOWAL:	JSR PC,SHALPR	;SHOW ALL PROCEDURES
	JSR PC,SHALNA	;SHOW ALL NAMES
	TST WRTFLG	;DON'T SHOW ARRAYS ON WRITE
	BNE .+6
	JSR PC,POARR	;SHOW ALL ARRAYS
SHOWA1:	SEZ
	RTS PC

SHOW:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE SHOW00	;YEP
	MOV TOPRNM,B
	BNE SHOW0
	MOV LASTPR,B
	BNE SHOW0
	ERROR+SHW

SHOW00:	JSR PC,GTUOEB
	BNE SHOW1	;THE TOKEN ISNT A USER PROC
SHOW0:	JSR PC,PSHOW
	BNE SHOWA1
	ERROR+PNH	;PROCEDURE NOT HERE
SHOW1:	CMP #SFUN,A
	BNE SHOWE1
	TST B	;IS IT CR?
	BNE SHOW12	;NO
	MOV TOPRNM,B
	BNE SHOW0
SHOWE1:	ERROR+SHW

SHOW12:	MOV #PODISP,A
SHOW13:	CMP (A)+,B
	BNE SHOW23
	JMP @(A)
SHOW23:	TST (A)+
	TST (A)
	BNE SHOW13
	ERROR+SHW

.IFNZ DDF
CNTRL:	CLR C
	INC C
	BR ALSO2
ALSO:	CLR C
ALSO2:	BIT #7777,CT
	BNE .+4
ALSOWH:	ERROR+WTAB
	JSR PC,GNT
	BIC #7777,A
	CMP #SFUN,A
	BNE ALSOWH
	TST B
	BEQ ALSOWH
.IFNZ ENG
	CMP #$STTUR,B
	BEQ TUR
.IFNZ NDISP
	CMP #$DISPLAY,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$PLOTTER,B
	BEQ PLOT
.ENDC
.ENDC
.IFNZ FR
	CMP #$TORTUE,B
	BEQ TUR
.IFNZ NDISP
	CMP #$ECRAN,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$TRACEUR,B
	BEQ PLOT
.ENDC
.ENDC
	BR ALSOWH
.IFNZ NDISP
DIS:	TST C
	BEQ .+6
	JMP CTRDIS
	JSR PC,EVAL
	BEQ TUR2
	JMP ASTRDI
.ENDC
TUR:	TST C
	BEQ TUR1
	JSR PC,EVAL
	BEQ TUR2
	JMP CTRTUR
TUR1:	JSR PC,EVAL
	BNE .+4
TUR2:	ERROR+WTAB
	JMP ASSTUR
.IFNZ NPLOT
PLOT:	TST C
	BEQ .+6
	JMP CTRPLT
	JMP ASSTPL
.ENDC

.ENDC


POT:	MOV TOPRNM,B	;SHOW THIS TITLE
	BEQ POL1
	JSR PC,SHTITL
	BNE POL2
	.BUG.

POL:	TST TOPRNM
	BNE .+4
POL1:	ERROR+OIP
	JSR PC,GTLN	;GEN LINE NO. FROM NEXT TOKEN INTO B
	BNE .+4
	ERROR+SHW	;SHOW WHAT??
	JSR PC,GTLP	;GET POINTER TO LINE
	JSR PC,.LOADC
	PUSHS B	;FOR PRLN
	JSR PC,PRLN	;PRINT LINE
	PRCR
	POPS C
POL2:	SEZ
POL3:	RTS PC
.POFILE:	JSR PC,EVAL
	BNE .+4
	ERROR+UELX
	JMP .POF

PSHOW:	;SHOW (B).  SKIP UNLESS (B) NOT A USER PROC
	JSR PC,SHTITL	;SHOW TITLE LINE, SKIPS IF PROC THERE
	BEQ POL3
	BIT #7777,A
	BEQ PSHOW4
	MOV A,C
	PUSHS #0
PSHOW3:	JSR PC,.LOADC
	MOV A,C
	MOV B,@S
	JSR PC,PRLN
	PRCR
	BIT #7777,C
	BNE PSHOW3
	POPS A
PSHOW4:	LANGC <PRTXTC ^\END\>,<
	PRTXTC ^/FIN/>
	CLZ
	RTS PC


PON:
SHALNA:		;SHOW ALL NAMES
		;USES A-F
	JSR PC,GNOLEI
SHALN1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ POL2+2
	MOV B,F
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ SHALN1	;NO THING FOR THIS UOE
	MOV B,C	;SAVE VALUE PTR
	MOV F,B	;GET UOE PTR
	TST WRTFLG
	BEQ SHALN2	;NO
	TST C		;IS VALUE = "UNBOUND"? (0?)
	BEQ SHALN1	;SKIP THIS ATOM
	SPUSH B
LANGC	<PRTXT ^/MAKE "/>,<
	PRTXT ^/RELIE "/>
	SPOP B
	JSR PC,PPNAME	;PRINT THE NAME
	PRTXT ^\ (\
	BR SHALN3
SHALN2:	JSR PC,PRUV	;PRINT THE NAME
LANGC	<PRTXT ^/ IS/>,<
	PRTXT ^/ EST/>
	TST C		;UNBOUND?
	BEQ SHALN5	;YES; JUST SAY SO
SHALN3:	SPACE
	SPUSHS C
	INC NBKTS
	JSR PC,PRS1
	ADD #2,S
	TST WRTFLG
	BEQ SHALN4
	PRTXT ^\ )\
SHALN4:	PRCR
	BR SHALN1

SHALN5:	PRTXT ^/ UNBOUND./
	BR SHALN4

POARR:	JSR PC,GNOLEI
POARR1:	JSR PC,GNOLE	;GET NEXT UOE
.IFZ <ENG&FR>
	BEQ POARR6
	.IFF
	BNE .+6
	JMP POARR6
.ENDC
	MOV B,F		;PTR TO UOE
	MOV #ABIND,A
	JSR PC,.BINDL	;GET ARRAY BINDING
	BEQ POARR1	;NO BINDING FOUND
	JSR PC,POARR5	;PRINT ARRAY NAME,SIZE,TYPE
	BR POARR1	;LOOK FOR MORE ARRAYS
POARR5:	MOV B,C		;SAVE VALUE PTR
	MOV F,B		;GET UOE PTR
	JSR PC,PPNAME	;PRINT THE NAME
LANGC	<PRTXT ^/ SIZE / >,<
	PRTXT ^/ DIMMENSION />
	MOV C,B	;SAVE VALUE PTR
	PUSH B
	JSR PC,ASIZE2	;PUTS DIMS. OF ARAY IN LIST
	MOV C,B		;PPTR TO LIST
	JSR PC,PRLST	;PRINT IT
	SPACE
	PRTXT ^/ TYPE/
	POP B		;VALUE PTR
	MOV 4(B),B	;TYPE/DIM WORD IN ARRAY HEADER
	BIC #7777,B	;GET THE TYPE
	BEQ POARR2	;TYPE POINTER
	CMP #FNUM,B
	BEQ POARR3	;TYPE FNUM
LANGC	<PRTXT ^/ INTEGER/>,<
	PRTXT ^/ NOMBRE ENTIER/>
	BR POARR4
POARR2: LANGC	<PRTXT ^/ POINTER/>,<
	PRTXT ^/ POINTEUR/>
	BR POARR4
POARR3: LANGC	<PRTXT ^/ FLOATING POINT/>,<
	PRTXT ^/ NOMBRE DECIMAL/>
POARR4:	PRCR		;CARRIAGE RETURN
	SEZ
POARR6:	RTS PC
PO1AR:	JSR PC,GTUOEB
	BEQ .+4
	MOV B,F
	MOV #ABIND,A
	JSR PC,.BINDL
.IFZ <ENG&FR>
	BNE POARR5
	ERROR+UDA
	.IFF
	BEQ .+4
	ERROR+UDA
	JMP POARR5
.ENDC

CONTEN:	;MAKE A LIST OF ALL ATOMS THAT HAVE A PROCEDURE
	JSR PC,SLISTB
	JSR PC,GNOLEI
CONTN1:	JSR PC,GNOLE
	BEQ CONTN2	;DONE
	JSR PC,BURYQ
	BEQ CONTN1
	MOV B,D
	JSR PC,.BINDF	;A PROCEDURE
	BEQ CONTN1	;NOPE
	MOV D,C
	JSR PC,.LOADC	;GET PNAME
	MOV #LSTR,A
	JSR PC,LISTB
	BR CONTN1
CONTN2:	JSR PC,FLISTB
	CLZ
	RTS PC
SHTITL:		;INPUT - UOE PTR IN B
		;OUTPUT - "SHOWS" TITLE LINE
		;	-A POINTS TO LLP NODE FOR 1ST LINE
		;	- SKIPS UNLESS NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF
	BNE .+6
	JMP RETC
	MOV A,4(P)
LANGC	<PRTXT ^\TO \>,<
	PRTXT ^/POUR />
	MOV 2(P),B
	JSR PC,PPNAME
	MOV 4(P),C
	JSR PC,.LOADC
	MOV A,4(P)	;SAVE PTR TO NEXT NODE
	JSR PC,.LOAD	;#ARGS IN B
	BIT #7777,A	;ANY TOKENS LEFT?
	BEQ SHTI1
	MOV A,C
SHTI2:	SPACE
	JSR PC,.LOADC	;NEXT ARG
	MOV A,C
	JSR PC,PRTAB	;PRINT TOKEN
	BIT #7777,C
	BNE SHTI2
SHTI1:	PRCR
	JMP SRETC
PRLN:	PUSH A	;PRINT PROC LINE ON S
	SPUSH B
	SPUSH C
	SPUSH D
	INC NBKTS	;PRINT OUTER LIST BRACKETS
	BIC #DPQF,FLAGS2	;DO PRINT QUOTE BEFORE STRINGS
	MOV @S,C
	JSR PC,.LOADC	;PRINT LINE #
	MOV A,C
	JSR PC,PRTAB
	BIT #7777,C
	BEQ PRLN3	;DONE
	JSR PC,.LOADC	;CHECK FOR TYPE = SNUM
	MOV A,C	;THIS MEANS 2ND TOKEN IS A CLGN & SHOULDNT PRINT
	BIC #7777,A
	CMP #SNUM,A
	BNE PRLN4
	BR PRLN2
PRLN1:	JSR PC,.LOADC
	MOV A,C
PRLN4:	SPACE
	JSR PC,PRTAB
PRLN2:	BIT #7777,C	;DONE?
	BNE PRLN1	;NO
PRLN3:	DEC NBKTS
	JMP RETD
	.STITL TEXT
TEXTT:	;LISTIFY TEXT OF PROC ON (S)
		;OUTPUT ON S
	JSR F,CACSAV
	JSR PC,LISTIT	;LISTIFY THE TITLE
	CLR F	;FOR LISTB
	SPOPS TOPS	;PRESERVE TITLE FROM GC!!!!!
	JSR PC,LISTB	;THE TITLE LINE
	SUB #2,S	;WORK CELL
	BR TEXT2
TEXT1:	JSR PC,.LOADC	;GET NEXT LLP NODE
	MOV A,C	;SAVE PTR TO NEXT ONE
	MOV B,@S	;NPUT TO LISTLN
	JSR PC,LISTLN	;LISTIFY THIS LINE
	JSR PC,LISTB	;ADD TO LIST
TEXT2:	BIT #7777,C
	BNE TEXT1	;NOT DONE YET
	ADD #2,S	;POP WORK CELL
	BR LIL2
LISTIT:	;LISTIFY TITLE LINE OF PROC ON (S)
		;SKIP IF THERE
		;OUTPUT ON S AND IN A,,B.  C POINTS TO LLP NODE FOR 1ST LINE
	JSR F,CACSAV
	JSR PC,GUOEB	;GET UOE PTR FROM S
	BEQ LIT4	;NONE THERE
	MOV B,D	;SAVE UOE PTR
	CLR TOPS
	JSR PC,.BINDF	;GET PROC BINDING
	BEQ LIT4	;NONE THERE
			;RETURNS WITH FIRST NODE OF LLP IN A,,B
	JSR PC,.LOADA	;GET 2ND NODE
	MOV A,4(P)	;SAVE PTR TO 3RD NODE IN SAVED C
	JSR PC,.LOADB	;GET #ARGS NODE
LIT1:	PUSHS A
	JSR PC,LTOK	;LISTIFY THE DUMMY ARGS
	BEQ LIT4	;LOST???
	MOV #LSTR,A	;NOW ADD "TO FOO"
LANGC	<MOV #$TOTO,B>,<
	MOV #$POURX,B>
	JSR PC,GRBAD	;"TO"
	MOV D,B
	JSR PC,.LOADB	;GET PNAME PTR
	MOV @S,A
	MOV A,TOPS
	BIC #170000,A
	BIS #LSTR,A
	BIS #LIST,C
	MOV C,2(P)
	MOV #LIST,(P)
	MOV C,@S
	JSR PC,GRBAD1	;"FOO"
	BR LIL2
LIT4:	ERROR+HNM
LISTLN:	;LISTIFY PROC LINE ON S
		;OUTPUT ON S AND IN A,,B
		;SKIPS UNLESS BAD TOKEN
	JSR F,CACSAV
	MOV @S,C	;GET LLP  IN C
	JSR PC,.LOADC	;GET LINE # NODE
	MOV B,F		;SAVE IT
	MOV A,@S	;SAVE PTR TO REST OF LINE
	MOV A,B
	JSR PC,.LOAD	;GET NEXT TOKEN AND CHECK IF IT IS ALSO SNUM
	BIC #7777,B
	CMP #SNUM,B
	BNE .+6
	MOV A,@S	;IT IS - SKIP OVER IT
	JSR PC,LTOK	;LISTIFY THE REST OF THE TOKENS
	BEQ LIL1		;LOST
	MOV F,B	;NOW ADD LINE # ON FRONT.  GET IT FROM F
	JSR PC,.CSNLS	;CONVERT SNUM TO LSTR
	MOV B,TOPS	;PTR TO LSTR IS IN B - PROTECT FROM G..C.
	MOV @S,A	;PTR TO TOKEN-LISTIFIED
	BIC #170000,A
	BIS #LSTR,A
	JSR PC,GRBAD
	CLR TOPS
	BIS #LIST,C
	MOV C,@S	;OUTPUT ON S
	MOV C,2(P)	;AND IN SAVED A AND B
	MOV #LIST,(P)
LIL2:	JSR F,CACRES
	CLZ
	RTS PC

LIL1:	.BUG.
LTOK:	;LISTIFY TOKEN LIST ON S
		;OUTPUT ON S AND IN A,,B
		;SKIP UNLESS A "BAD" TOKEN IS FOUND
	JSR F,CACSAV
	POPS C	;GET PTR TO TOKEN LIST
	JSR PC,SLISTB
LTOK1:	BIT #7777,C	;ANY TOKENS LEFT
	BEQ LTOKF
	JSR PC,.LOADC	;GET NEXT TOKEN
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	CMP #SNUM,A
	BEQ LTOK1	;IGNORE SNUM'S
	CMP #UFUN,A
	BHI LTOKSF	;MUST BE SFUN OR INFIX
	BEQ LTOKUF	;A USER PROC
	MOV #':,D
	CMP #UVAR,A
	BEQ LTOKCT	;A USER VARIABLE
	MOV #'",D
	CMP #ATOM,A
	BEQ LTOKCT	;A STRING
	BHI LTOKBD
	CMP #LSTR,A
	BNE LTOKAD	;AN INUM OR LIST - OK AS IS
	JSR PC,CONCTL	;AN LSTR, ADD A "
	BR LTOKAD
LTOKBD:	JSR PC,FLISTB	;BAD TOKEN
	POPS A
	BR LIL2
LTOKUF:	JSR PC,.LOAD	;USER PROC
LTOK3:	MOV #LSTR,A
LTOKAD:	JSR PC,LISTB
	BR LTOK1
LTOKSF:	JSR PC,CVSFLS	;CONVERT SYSTEM FUNCTION TO LSTR
	MOV TOPS,B
	BR LTOK3
LTOKCT:	JSR PC,CONCT
	BR LTOK3
LTOKF:	JSR PC,FLISTB
	MOV A,(P)	;SAVED A
	MOV B,2(P)	;SAVED B
LIL3:	BR LIL2
CONCT:	;APPEND CHAR IN D TO BEGINING OF PNAME OF ATOM IN B
		;OUTPUT #LSTR,,PTR IN A,,B
	JSR PC,.LOAD	;GET PNAME PTR
CONCTL:	PUSH C
	MOV B,A
	BIC #170000,A
	BIS #SSTR,A
	MOV D,B
	JSR PC,GRBAD
	MOV C,B
	MOV #LSTR,A
	BIS A,B
	POP C
	MOV B,TOPS
	RTS PC
CVSFLS:	;CONVERT SFUN NAME TO LSTR
		;INPUT - A,,B SFUN OR INFIX TOKEN IN TOPS
		;OUTPUT -  LSTR PTR IN TOPS
	JSR F,CACSAV
	SPUSH PCHR
	JSR PC,BLSTI
	MOV #BLST,PCHR
	JSR PC,PROAB
	JSR PC,BLSTF
	BNE .+4
	.BUG.	;CANT HAVE NO CHARS!!
	POP PCHR
	BR LIL3
	.STITL ILINE & ERSET STUFF
ILINE:	;OUTPUT LAST LINE TYPED IN
	PUSHS ILINEL
	JSR PC,LTOK
	BNE ERRPR2
	.BUG.	;A BAD TOKEN??
ERRPRO:	;OUTPUT NAME OF PROC EXTENT AT LAST ERROR
	MOV NPROCL,B
	BEQ ERRPR1
	JSR PC,.LOAD
	PUSHS B
	CLZ
	RTS PC

ERRPR1:	PUSHS #LSTR
ERRPR2:	RTS PC
ERRLIN:	;OUTPUT LINE # EXTENT AT LAST ERROR
	MOV NLINEL,B
	BR NTOKE1
ERRTOK:	;OUTPUT TOKEN # EXTENT AT LAST ERROR
	MOV NTOKEL,B
NTOKE1:	JMP R1NARG
ERRLOC:	;OUTPUT ADDR OF LAST ERROR
	MOV LASTER,B
	BR NTOKE1
ERRNUM:	;OUTPUT NO. OF LAST ERROR
	MOV ERRPNT,B
	CMP (B)+,(B)+
	MOV (B),B
	BR NTOKE1
ERRNAM:	MOV #4,C	;MAX CHARS
	MOV ERRPNT,B
	JSR PC,BLSTI	;START AN LSTR
ERRNA2:	MOVB (B)+,D	;GET CHAR
	BEQ ERRNA1
	JSR PC,BLST
	SOB C,ERRNA2	;CONTINUE UNLESS DONE
ERRNA1:	JSR PC,BLSTF
	BEQ ERRPR1
	PUSHS TOPS
	CLZ
	RTS PC

ERRBREAK:	;OUTPUT BRAKE(U)
	MOV BRAKEL,B
	BR NTOKE1
ERRSET:	JSR PC,GTUOEB
	BEQ .+4
	ERROR+HNM
	MOV B,ERPROC
	SEZ
	RTS PC
ERRCLE:	CLR ERPROC
ERRC3:	RTS PC
ERNAME:	;ERASE NAME
	JSR PC,GTUOEB
	BEQ ERN2
ERN1:	CMP #UFUN,A	;AN SFUN OR INFIX?
	BGT .+4
	ERROR+ERW
	JSR PC,CVSFLS
	MOV #ATOM,A
	JSR PC,.OBSCH
	BEQ ERRC3
ERN2:	MOV #VBIND,A
	JSR PC,.UNBND
	SEZ
	RTS PC
	.STITLE ERASE
ERASE:	JSR PC,GTUOEB	;ERASE ...
	BNE ERASE1	;NOT A PROCEDURE
	JSR PC,ERPR
	BEQ ERASER
	SEZ
	RTS PC
ERASER:	ERROR+PNH	;PROCEDURE NOT HERE

ERASE1:	MOV #ERSDISP,A
ERASE2:	CMP (A)+,B
	BNE ERASE4
	JMP @(A)
ERASE4:	TST (A)+
	TST (A)
	BNE ERASE2
ERASE3:	ERROR+ERW	;ERASE WHAT
ERALL:	JSR	PC,ERALPR
	JSR	PC,ERALNA
	JSR PC,ERARAS
	JMP ERTL3
ERL:
ERLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	BEQ ERASE3
	NEG B		;SO ADLN WILL ERASE IT
	MOV #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	PUSHS C
	JSR PC,ADLN
	ADD #2,S	;POP S
ERL1:	SEZ
	RTS PC
ERPR:		;ERASE PROCEDURE (B)
	BIC #170000,B
	BIS #UFUN,B
	CMP B,TOPRNM
	BNE .+4
	ERROR+PBE	;PROCEDURE IS BEEN EDITED (UGH!!!)
	MOV #FBIND,A
	JMP .UNBND
ERALPR:		;ERASES ALL PROCEDURES
	TST TOPRNM
	BEQ ERALP2
	MOV TOPRNM,B
	BR ERPR
ERALP2:	JSR PC,GNOLEI
	MOV #FBIND,A
ERALP1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ ERL1+2
	JSR PC,BURYQ
	BEQ ERALP1
	JSR PC,.UNBND
	BR ERALP1
ERALNA:		;ERASE ALL NAMES
	JSR PC,GNOLEI
ERALN1:	JSR PC,GNOLE
	BEQ ERL1+2
	MOV #VBIND,A
	JSR PC,.UNBND
	BR ERALN1	;EVENTUALLY HAVE TO CHECK FOR SVBIND
ERFI:	JSR PC,EVAL
	BEQ ERINX1
	JMP .DELETE
ERINDX:	JSR PC,EVAL
	BNE .+4
ERINX1:	ERROR+UELX
	JMP .DELI
	.STITL TRACE
EBURY:	BIC #TF6,TFLAGS
BURY1:	MOV #TPBF,D
	BR TRA3

ESTEP:	BIC #TF6,TFLAGS
STEP1:	MOV #TPSF,D
	BR TRA3
ERTR:
ETRACE:	BIC #TF6,TFLAGS
TRA1:	MOV #TPTF,D
TRA3:	JSR PC,GTUOEB
	BNE TRA6
	JSR PC,CSSTF
	BNE TRA11
TRA5:	ERROR+PNH	;PROC NOT HERE
TRA6:	CMP #SFUN,A
	BNE TRA5
	.IFNZ ENG
	CMP #$ALL,B
	BEQ TRA10
	.ENDC
	.IFNZ FR
	CMP #$TOUT,B
	BEQ TRA10
	.ENDC
	ERROR+ERW
TRA10:	JSR PC,GNOLEI
TRA7:	JSR PC,GNOLE
	BEQ TRA9
	CMP #TPBF,D	;UNBURY BURIED PROCS
	BEQ TRA8
	JSR PC,BURYQ	;BUT DON'T TRACE UNTRACE STEP OR UNSTEP THEM.
	BEQ TRA7
TRA8:	JSR PC,CSSTF
	BR TRA7

CSSTF:	JSR PC,.BNDFS
	BEQ TRA9
	MOV B,C	;B POINTS TO LIST OF GOODIES. FIRST IS FLAGS,,#ARGS
	JSR PC,.LDP2
	BIC D,A
	BIT #TF6,TFLAGS
	BEQ TRA2
	BIS D,A
TRA2:	JSR PC,.STP2
	CLZ
TRA9:	RTS PC
TRA11:	SEZ
	RTS PC

BURYQ:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BEQ BURYQ1
	JSR PC,.LOADB
	BIT #TPBF,B
	BEQ .+6
BURYQ1:	JMP RETC
	JMP SRETC

TRACE:	BIS #TF6,TFLAGS
	BR TRA1
STEP:	BIS #TF6,TFLAGS
	BR STEP1
BURY:	BIS #TF6,TFLAGS
	BR BURY1

STRACS:	BIT #TRACEF,FLAGS2
	BEQ TRA9
	SPACE
	BR STRA1
STRACE:	BIT #TRACEF,FLAGS2	;SYSTEM TRACE
	BEQ TRA9
STRA1:	INC NBKTS
	PUSH A
	PRTXT ^/CT=/
	BIC #DPQF,FLAGS2
	JSR PC,PRCT
	PRTXT ^/ CO=/
	JSR PC,PRCO
	PRTXT ^/ S=/
	BIC #DPQF,FLAGS2
	JSR PC,PRS1
	PRCR
	CLR NBKTS
	POP A
	RTS PC

SETSTF:	BIS #TRACEF,FLAGS2	;SET SYSTEM TRACE FLAG
	SEZ
	RTS PC

CLRSTF:	BIC #TRACEF,FLAGS2
	SEZ
	RTS PC

FLEV:	MOV FUNLEV,B	;RETURN USER PROC CALL DEPTH
FLEV1:	JMP R1NARG
NODES:	;OUTPUT NO. OF NODES IN FREE STG LIST
	MOV NNIFSL,B
	BR FLEV1
.STITL	UTILITY ROUTINES

GOODBYE:
LANGC	<CPRTXT ^/AND A PLEASANT DAY TO YOU!/>,<
	CPRTXT ^/BONNE JOURNEE/>
	IOT


VERSN:	MOV LVERNF,B
	BR	RANDO1
RANDOM:
	MOV RNSEED,B	;GET OLD SEED
	MUL #71275,B	;MUL SEED BY GOOD NUMBER!!
	ADD #13713,B	;ADD ANOTHER GOOD NUMBER!! TO LOW ORDER PART
	MOV B,RNSEED	;THIS IS THE NEW SEED
	MOV B,A
	MUL #10.,A	;MULTIPLY IT BY 10
	MOV A,B		;HIGH-ORDER PART IS THE DESIRED DIGIT
	ADD #5,B
RANDO1:	JMP R1NARG
BELL:	MOV #7,D
	BR .+6
CR:	MOV #1,D
	JSR PC,TYO
	SEZ
	RTS PC
DEBUGL:	TST ALEVN
	BEQ DEBUG1
	PRTXTC ^\OFF\
	CLR ALEVN
	JMP ERTL2
DEBUG1:	PRTXTC ^\ON\
	MOV #1,ALEVN
DEBUG2:	SEZ
	RTS PC
SGCF:	JSR PC,CKSST
	BIS #MGCF,FLAGS2
	SEZ
	RTS PC
CGCF:	JSR PC,CKSST
	BIC #MGCF,FLAGS2
	SEZ
	RTS PC
STATUS:	BIT #SSF,FLAGS2
	BNE	STATU2	;IF ON TURN OFF
	JSR PC,TINECH
	JSR PC,RDSTR	;READ A STRING
	BEQ	STATU2	;EMPTY OR BREAK
	MOV @S,B	;SEE IF EQUAL TO "SECRET
	MOV #SECRET,C
	JSR PC,EQ.TXT
	BEQ STATU1	;NOPE
	BIS #SSF,FLAGS2	;YES
	POPS A	;POINTER TO STRING READ IN
	PRTXTC	^\ON\
	BR	STATU3
STATU1:	POPS	A
STATU2:	PRTXTC	^\OFF\
	BIC	#SSF,FLAGS2
STATU3:	JSR	PC,SETTTY
	SEZ
	RTS PC

CKSST:	TST DEBSW
	BNE CKSST1
	BIT #SSF,FLAGS2
	BEQ .+4
CKSST1:	RTS PC
	ERROR+HNM1

SPNF:			;SET PRINT NODES FLAG
	BIS #PNNLF,FLAGS2
	SEZ
	RTS PC
CPNF:	BIC #PNNLF,FLAGS2	;CLEAR IT
	SEZ
	RTS PC

COMT:	.BUG.		;GNT SHOULD SWALLOW ALL COMMENTS;
			; THEY SHOULD NEVER BE SEEN BY EVAL
	.STITL ERRORS AND HANDLER
EMTBK:	MOV #SRET,@P	;FAKE IT OUT
	RTT
ERRBK:	LDFPS #40300
	PUSH A
ERBK2:	TST REDFLG
	BEQ ERBK3	;FINISH UP PENDING PROC DEF
	CLR FILFLG
	TST TOPRNM
	BEQ ERBK3
	JSR PC,END
ERBK3:	TST WRTFLG
;	BEQ .+6
;	JSR PC,WDELBL
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	MOV 2(P),A
	MOV A,LASTER
;	MFPI -2(A)	;GET ERROR NUMBER (CROCK!!!)
.IFNZ TS
	SUB #2,A
	SPUSH B
	SPUSH C
	MOV A,C		;ADDRESS IN I SPACE
	ASH #-13.,C	;PAGE IN I SPACE
	BIC #177770,C	;WHAT WE WANT IS A LSH (OR A BOTTLE OF BOOZE)
	SPUSH #7*400+0
	SPUSH C
	SPUSH #<10+HAKPG>*400+1
	SPUSH #.CRRD+1
	$MAP
	MOV A,B
	BIC #160000,B
	ADD #HAKAD,B
	MOV (B),A
	SPOP C
	SPOP B
.ENDC
;	MOV (P)+,A
	BIC #177400,A
	MOV A,ERRORN
	ASL A
	MOV ERTAB(A),ERRPNT
	MOV ERRORN,A
ERBK4:	CLR NTOKEL
	CLR NLINEL
	MOV CPP,NPROCL
	BEQ ERBK5
	MOV CPLN,NLINEL
	MOV CTN,NTOKEL
ERBK5:	CMP A,#BUG	;DONT ALLOW ERRSET FOR .BUG. OR FBUG
	BEQ ERSET3
	CMP A,#FBUG
	BEQ ERSET3
	TST ERPROC	;ERROR SET ON?
	BEQ ERSET2
	JSR F,CACSAV
	PUSH CO
	SPUSH CO+2
	SPUSH NOR
	SPUSH BRAKE
	CLR BRAKE
	MOV (P),BRAKEL
	BEQ .+6	;IF THERE REALLY WAS A BRAKE PENDING,
;	JSR PC,BRAKR	;ALLOW TYPEOUT AGAIN
	SPUSH ERPROC
	MOV ERPROC,CO+2
	CLR ERPROC
	JSR PC,SAVPPS	;YES - SAVE THE PDLS
	BIS #1,CSPDLP	;INDICATE ERRORSET PUSH
	BIS #1,CPDLP
	MOV #UFUN,CO
	CLR NOR
	BIC #DORF,FLAGS	;NOTE THAT THIS IS NOT A RUN FRAME
	JSR PC,PEVAL
	BEQ ERSET1	;DIDNT OUTPUT
	JSR PC,PRS1	;DID OUTPUT, PRINT IT
	JSR PC,RESPPS
	POP ERPROC
	JMP ERTLN	;THEN ERROR RETURN
ERSET1:		;DIDNT OUTPUT, DO WHAT U WERE GOING TO
	JSR PC,RESPPS
	POP ERPROC
	SPOP BRAKE
	SPOP NOR
	SPOP CO+2
	SPOP CO
	JSR F,CACRES
ERSET2:
	TST NOADDR
	BNE NEWER4
ERSET3:
	MOV 2(P),A
	JSR PC,PRONL	;PRINT ADDR WHERE ERROR OCCURED
	SPACE
NEWER4:	MOV ERRPNT,ERRPT
	ADD #6,ERRPT
	.IFNZ ENG&FR
	BIT #FRFLG,LANG
	BEQ NEWER1
	INC ERRPT
	TSTB @ERRPT
	BNE .-10
	INC ERRPT
	.ENDC
NEWER1:	MOVB @ERRPT,D
	BEQ ERTLN
	BGT NEWER2
	BIC #177600,D
	ASL D
	MOV ROTTAB(D),A
	INC NBKTS
	JSR PC,(A)
NEWER3:	INC ERRPT
	BR NEWER1
NEWER2:	JSR PC,TYO
	BR NEWER3
ERRRT:	POP A
	RTT

PPLACE:	MOV FUNLEV,A
	BEQ PPLAC1
LANGC	<CPRTXT ^\AT LEVEL \>,<
	CPRTXT ^/AU NIVEAU />
	JSR PC,PRDN
LANGC	<PRTXT ^\  LINE \>,<
	PRTXT ^/ LIGNE />
	MOV CPLN,A
	JSR PC,PRDN
LANGC	<PRTXT ^\  IN \>,<
	PRTXT ^/ DE />
	MOV CPP,B
	JSR PC,PPNAME
PPLAC1:	JMP .CRLF

ERTLN:			;ERR RETURN TO LEVEL N
	TST ALEVN
	BEQ ERTL0
ERPO1:
	JSR PC,RRPOP
	BIS #ERRF+BRKF,FLAGS
	CLR BRAKE
ERTLN1:	JSR PC,PPLACE
	JMP MLOOP
ERTL0:			;ERR RETURN TO LEVEL 0
	CLR	BRAKE
ERTL01:
	JSR PC,RRPOP
	JSR PC,PPLACE
EXIT:
ERTL2:	TST FUNLEV	;POP UP TO LEVEL 0
	BLE ERTL3
	MOV #ERTL2,PSTOPR
ERTL4:	MOV #PSTP15,A
	MOV A,ERFRET	;SET UP ERROR FRAME RETURN
	MOV A,DOFRET
	JMP (A)
ERTL3:	CLR A	;CLEAR OUT PDLS
	JSR PC,PPTA
	CLR A
	JSR PC,PSTA
	CLR CSPDLP
	CLR CPDLP
	MOV #ERCLR1,A
	MOV #<ERCLR2-ERCLR1>/2,B
	CLR (A)+
	SOB B,.-2
	BIC #EDTIF+ERRF+BRKF,FLAGS
	JMP MLOOP
.ERPOP:	PRTXT ^\ERPOP TO\
	TST FUNLEV
	BLE ERTL3
	MOV #ERPO1,PSTOPR
	BR ERTL4

	;POP RUN AND READ FRAMES
RRPOP:	SPOP C	;SAVE RETURN ADDR
ERTLN2:		BIT #DORF,FLAGS
	BEQ ERTLN4
ERTLN3:	JSR PC,RESPPS
	SPOP B
	BIT #TF7,TFLAGS
	BEQ ERTN32
	MOV B,ERPROC
	BR ERTLN3
ERTN32:	JSR PC,RESEVL
	MOV B,FLAGS
	BR ERTLN2
ERTLN4:	JMP @C

	.STITL ERROR ROUTINES
		; ****  THESE ARE NOW ALPHABETIZED   *****

.IIF NDF MAXELN,MAXELN==0

BRK.R:	MOV BRAKE,A
	CLR BRAKE
;	JSR PC,BRAKR
	TST A
	BLT PAUSE
BRK.2:
	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
LANGC	<PRTXT ^\STOPPED!!\>,<
	PRTXT ^/ARRET/>
	JMP ERTL01

PAUSE:	BIS #BRKF,FLAGS
	SPUSH	MUCWRD	;SO THAT CONTINUE WILL WORK (GROAN)
	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
	SPOP	MUCWRD
	PRTXT ^\PAUSE \
	JMP ERTLN1

BUG.R:	TST	DEBSW
	BNE	BUG.1	;BR IF DEBUGGING
;	DEC NSYBUG
;	BGE .+4
;	ERROR+FBUG
BUG.1:	PRTXT ^/HELP!!!  SYSTEM BUG VER=/
	MOV #VERNF,A
	JSR PC,PRDN
	JSR PC,.SPACE
	SPOP A
	TST	DEBSW
	BEQ	.+4
BUGBPT:	BPT	;BRK IF IN DEBUG MODE
	MOV 6(P),A
	JSR PC,PRONL
	JMP ERTLN

CTIT.R:	MOV TOPRNM,B
	JMP PPNAME

HNM.R:	MOV #UFUN,A
	JMP PROAB

LDE1.R:	MOV JPLN,CPLN	;MAKE JUMPED-FROM LINE = POINT OF ERROR
WTIB.R:	MOV B,A
	JMP PRDN	;LINE # SHOULD BE IN A

TDE.R:	ASR	E
	MOV	E,A
	JMP	PRDN

PAE.R:	MOV #UFUN,A
	MOV TEMP,B
	RTS PC

PNH1.R:	MOV CPP,B
	MOV #UFUN,A
	RTS PC

TMAP.R:	TST (P)+
	JMP ERRRT

WTA.R:	RTS PC

WTAA.R:	PUSHS A
	RTS PC

WTAB.R:	PUSHS B
	RTS PC
	.STITL TURTLE,DISPLAY, RANDOM DEVICES, AND OTHER CRAP
;CONVERT ADDRESS TO DISPLAY PUSHJ
;ARGUMENT IS AC
.MACR MAKEPJ F
	ASR F
	ADD DRELOC,F
	BIS #DPUSHJ,F
.ENDM

;CONVERT DISPLAY CONTROLLER ADDRESSES TO REAL WORLD ADDRESSES
;	ARG IS AC
.MACR MAKEAD F
	SUB DRELOC,F
	ASL F
.ENDM

MUCTYO:	ERROR+FNF
TBTW:	ERROR+FNF
OPEN1:	ERROR+FNF
CLOSE2:	ERROR+FNF
MBDN==13455
PLTDVN==10105
	.STITL RANDOM DEVICE CONTROL

.IFNZ AI

ATOD:	ERROR+FNF
.IFZ 105
	JSR PC,G1NARG
	TST B		;IS B NEGATIVE
	BLT ATODLS	;YES, SO NO GOOD
	CMP #7,B	;IS B TOO BIG A CHANNEL NO.?
	BLT ATODLS	;YES ITS BIGGER THEN 7
	ASH #10.,B
	MOV B,ATODB
	TST ATODB
	BPL .-4
	MOV ATODB,B
	BIC #176000,B
	SUB #1000,B
	JMP R1NARG
ATODLS:	ERROR+WTA	;HERE FOR BAD ARG TO ATOD
.ENDC


BITOUT:	ERROR+FNF
.IFZ 105
	JSR PC,G1NARG
	MOV B,DIGO
BITOU1:	SEZ
	RTS PC
.ENDC
RELAY:	ERROR+FNF
.IFZ 105
	JSR PC,G1NARG
	MOV B,F
	JSR PC,G1NARG
	MOV #1,C
	ASH B,C
	TST F
	BEQ RELAY1
	BIS C,DIGO
	BR BITOU1
RELAY1:	BIC C,DIGO
	BR BITOUT

.ENDC
DEVICE==160106	;THE ADDRESS OF THE BUFFER REGISTER
DEVADD==160104	;THE SELECTOR REGISTER

BOXIN:	JSR PC,G1NARG
	JSR PC,RDBOX	;READ THE BOX
	JMP R1NARG

SWITCH:	JSR PC,G2NARG
	CMP A,#15
	BGT SWTWTA
	TST A
	BLT SWTWTA
	JSR PC,RDBOX	;BOX NUMBER IN B, RETURNS THE BOX IN B
	MOV #1,C	;GET THE BIT
	ASH A,C		;SHIFT THE BIT THE NUMBER OF THE SWITCH
	BIT C,B		;IS THE BIT SET
	BNE .+6		;YES
	JMP RTFALS	;RETURN FALS
	JMP RTTRUE	;RETURN TRUE

RDBOX:	ERROR+FNF
SWTWTA:	ERROR+FNF
.IFZ 105
	TST B		;IS IT NEGATIVE
	BGE .+4
SWTWTA:	ERROR+WTA	;BAD ARG
	CMP B,#3	;TO LARGE BOX NO.
	BGT SWTWTA
	ASH #10.,B	;THE NUMBER IS SHIFTED 10 PLACES
	MOV B,DEVADD	;TELL IT WHICH BOX TO READ
	CLR DEVICE	;TELL IT TO GO
	TST DEVICE	;DATA IN YET
	BPL .-4		;NOT YET
	MOV DEVICE,B	;GET THE DATA INTO B
	COM B		;THE BITS ARE COMPLEMENTED
	RTS PC
.ENDC
.ENDC
;ROUTINE FOR THE EYETURTLE.  WE WANT TO FILL A LOGO ARRAY WITH WHAT APPEARS
;A-TO-D CHANNEL, SAMPLING THAT A-TO-D 720 TIMES IN ONE ROTATION OF THE TURTLES'S
;EYE. THE TURTLE SENDS US A PULSE WHENEVER IT SHOULD BE SAMPLED
EYE:	ERROR+FNF
.IFZ 105
	SPUSH #1	;TELL AMAKE THERE IS ONLY ONE ARG
	SPUSH PS	;SAVE PSW AND PRIORITY
	MOV @S,A	;S POINTS TO ARRAY NAME
	JSR PC,AMAKE	;FIND TOP OF THE ARRAY
	ADD #2,S	;POP STACK
	CMPB 5(B),#260	;TEST TYPE BYTE
	BEQ .+4		;BRANCH IF IT'S AN INTEGER ARRAY
	ERROR+BAT	;BAD ARRAY TYPE
	CMP 10.(B),#720.;IS THE FIRST DIMENSION 720. LONG?
	BGE .+4		;AT LEAST THAT BIG
	ERROR+BAT	;TOO SMALL,TOO BAD
	CRDPOS==5	;USE INTERFACE LINE FIVE
;THE A-TO-D DEVICE BUFFER REFERRED TO ABOVE IS ALSO THE SWITCHBOX ADDRESS
;REGISTER. I DON'T KNOW WHY.
	ADD #12.,B	;B NOW POINTS TO FIRST ENTRY OF ARRAY
	MOV #CRDPOS,D
	ASH #10.,D	;THIS MAKES THE LINE-SELECTION ACCEPTABLE TO ADDRESS BUFFER
	MOV D,ATODB	;AND WE HAVE NOW SELECTED INTERFACE LINE FIVE.
	MOV #720.,C	;WE WANT 720. POINTS
	SPL 7		;LOCK OUT ALL INTERRUPTS
GNDATA:	CLR DEVICE	;TAP THE EYETURTLE ON THE SHOLDER,GET READY FOR A PULSE
	TST DEVICE	;DID WE GET A TIMING PULSE BACK YET?
	BPL .-4		;WAIT FOR THAT PULSE
	TST ATODB	;IS CONVERSION COMPLETE?
	BPL .-4		;NO, WAIT
	TST (B)+	;ARRAYS ARE DOUBLEWORD LONG, SO INCR PNTR
	MOV ATODB,(B)+	;YES PUT IN THE ARRAY AND INCREMENT POINTER
	SOB C,GNDATA	;IF NOT YET 720 POINTS GO GET ANOTHER
	SPOP PS		;RESTORE THE OLD PRIORITY
	SPOP A		;CLEAN THE P-PDL UP
	SEZ		;TELL EVAL THAT NOTHING IS BEING RETURNED
	RTS PC
.ENDC


.IF NE HALFLG
;ORBIT HACK--CALL WITH THE NAME OF ARRAY OF DATA
;THE FORMAT FOR THE DATA IS
;NUMBER OF ATTRACTIVE SOURCES
;NUMBER OF INTEGRATION STEPS PER CALL (<50)
;DT
;OBJECT	XPOS
;	YPOS
;	XVEL
;	YVEL
;	XFORCE
;	YFORCE
;	MINIMUM LEGAL RADIUS
;GRAV SOURCE XPOS
;	YPOS
;	DIST FROM OBJECT
;	FIELD CONSTANT
;THIS LAST BLOCK REPEATED FOR EACH SOURCE

;THE ROUTINE UPDATES THE VARIABLES

HALHACK:	SPOPS	A
	JSR	PC,AMAKE5	;B NOW POINTS TO ARRAY HEADER
	MOV	B,C
	CMP	(C)+,(C)+
	CMP	(C)+,#150001	;TYPE=FLOATING   #DIMS=1
	BEQ	.+4
	ERROR+BAT
	CMP	(C)+,(C)+
	MOV	(C)+,A	;ARRAY SIZE
	LDCFD	(C)+,FA
	LDCFD	(C)+,FB
	SETI
	STCFI	FA,D	;#OF ATTRACTORS
	STCFI	FB,B	;#OF INTEGRATION STEPS
	SETL
	TST	B	;POSITIVE?
	BGT	.+4
	ERROR+DOR
	CMP	B,#50.	;NOT TOO BIG (PIGGY)
	BLE	.+4
	ERROR+DOR
	ASL	D
	ASL	D
	ADD	#10.,D	;SIZE ARRAY SHOULD BE
	CMP	A,D
	BGE	.+4
	ERROR+ROB	;ARRAY TOO SMALL
	SUB	#3,D
	ASL	D
	ASL	D
	ADD	C,D	;POINTS TO LAST DATA WORD
	MOV	C,A
	ADD	#32.,A	;POINTS TO XPOS OF FIRST BODY
	PUSH	A
	SPUSH	D
;A NOW POINTS TO XPOS OF FIRST BODY
;B HAS NUMBER OF STEPS PER CALL
;C POINTS TO DT
;D POINTS TO CONSTANT FOR LAST BODY
;NOW COMPUTE THE FORCE ON THE OBJECT

	SETF
HALOP:	MOV	(P),D
	MOV	2(P),A
HALOP1:	LDF	4(C),FB	;POSITION OF OBJECT
	LDF	8.(C),FC
	SUBF	(A)+,FB	;DX
	SUBF	(A)+,FC	;DY
	STF	FC,FD
	MULF	FD,FD	;DY^2
	STF	FB,FA
	MULF	FA,FA	;DX^2
	ADDF	FD,FA
	JSR	PC,HALSQ	;GET SQRT OF FA INTO FD
	STF	FD,(A)+	;RADIAL DISTANCE FROM SOURCE
	CMPF	28.(C),FD	;IS RADIUS LESS THAN 10?
	CFCC
	BGT	HALERR
	MULF	FD,FA
	LDF	(A)+,FD	;FIELD CONSTANT
	DIVF	FA,FD	;K/(R*R^2)
	MULF	FD,FB	;FX=(ABOVE)*DX
	MULF	FD,FC
	ADDF	20.(C),FB
	STF	FB,20.(C)	;INCREMENT FORCE-X
	ADDF	24.(C),FC	;FORCE-Y
	STF	FC,24.(C)
	CMP	A,D
	BLO	HALOP1	;MORE FORCES?

;NOW DO THE INTEGRATION
	MOV	C,E
	LDF	(C),FB	;DT
HALOP2:	LDF	20.(C),FA
	MULF	FB,FA	;FORCE*DT
	ADDF	12.(C),FA	;V_V+A
	STF	FA,12.(C)
	MULF	FB,FA	;V*DT
	ADDF	4(C),FA	;R_R+V*DT
	STF	FA,4(C)
	CMP	C,E
	BHI	HALOP3
	ADD	#4,C	;NOW DO Y COORDINATE
	BR	HALOP2
HALOP3:	MOV	E,C	;RESTORE POINTER TO DT
	CLRF	20.(C)	;CLEAR THE FORCES
	CLRF	24.(C)
	SOB	B,HALOP
	SETD
	CMP	(P)+,(P)+	;FIX THE STACK
	SEZ
	RTS	PC

HALERR:	SETD
	ERROR+RTB
;SQUARE ROOT ROUTINE RETURN ROOT OF FA IN FD

HALSQ:	JSR	PC,PPUSHT
	STF	FB,-(P)	;SAVE FB
	STF	FA,FD
	DIVF	#40400,FD	;START ITER AT A/2
HALSQ1:	STF	FD,FB
	STF	FA,FD
	DIVF	FB,FD	;A/B
	ADDF	FB,FD
	DIVF	#40400,FD	;(B+A/B)/2
	SUBF	FD,FB
	ABSF	FB	;ERROR
	DIVF	FA,FB
	CMPF	#34000,FB	;ERR LESS THAN 2^(-15) ?
	CFCC
	BLT	HALSQ1
	LDF	(P)+,FB	;
	RTS	PC

.ENDC
.STITL DISPLAY AND TURTLE

;A  BRIEF DESCRIPTION OF WHAT IS LEFT TO BE DONE TO THIS PROGRAM.


;4)	DECIDING WHAT SNAP AND WIPE REALLY ARE GOING TO DO.
;AT THIS TIME, SNAP OUTPUTS THE ENTIRE SCREEN
;AND WIPE ERASES ONLY TOP LEVEL OCCURRENCES OF THE SNAP



;DISPLAY AND TURTLE COMMANDS
	.IFZ <NDISP!NPLOT>
	DLT==0
	DRT==1
	DFD==2
	DBK==3
	DPD==4
	DPU==5
	.ENDC
.IFNZ DDF
	CURY==4		;USED FOR INDEXING OFF CURX FOR
	CURA==10	;PLOTTER AND DISPLAY
	COSA==14
	SINA==20
	RCURX==24
.ENDC
BACK:	MOV	#"@C,D	;D _ CHAR. TO SEND TO TURTLE
	MOV	#DBK,E	;IN ORDER TO CAUSE 1 STEP OF MOTION
	BR	TURD	;THE TOP BYTE CONTAINS THE CHAR.
LEFT:	MOV	#"BA,D	;IF THE NUMBER OF STEPS IS NEGATIVE
	MOV	#DLT,E
	BR	TURD
RIGHT:	MOV	#"AB,D	;E CONTAINS THE ADDRESS OF THE PARALLEL
	MOV	#DRT,E	;DISPLAY ROUTINE
	BR	TURD
FORWARD:	MOV	#"C@,D
	MOV	#DFD,E
;THE MOVE COMMANDS ARE PROCESSED HERE

TURD:
.IFZ FPPF
	JSR	PC,G1NARG	;B_SINGLE PRECISION NUMBER
.IFF
	JSR PC,G1NUM	;FA_FLOATING NUMBER
	BNE .+4
	ERROR+WTAB
.ENDC
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;DISPLAY, OR REAL TURTLE?
	BEQ	TURD.1
	JMP	(E)		;DISPLAY
	.ENDC
TURD.1:	BIT	#TURTF,DFLAGS
	BNE	TURD.A	;TURTLE
	.IFNZ	NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	TURD.E
	JMP	(E) ;HANDLE PLOTTER COMMAND LIKE DISPLAY
	.ENDC
TURD.E: ERROR+VTD   ;ONLY VALID FOR TURTLE,DSPLY,OR PLTR
TURD.A:
.IFNZ FPPF
	SETI		;IF IT'S A TURTLE CHANGE FLOATING
	STCFI FA,B	;TO AN INTEGER
	SETL
.ENDC
	TST	B
	BGE	TURD.2
	NEG	B	;MAKE NUMBER POSITIVE
	SWAB	D	;AND SWITCH CHARS
;NOW DO THE MOVING
TURD.2:	CMP	E,#DLT	;FOR LEFT OR RIGHT USE FUDGE FACTOR
	BEQ	TURD.0
	CMP	E,#DRT
	BEQ	TURD.0
	BR	TURD.3
TURD.0:	ASL B
	MOV B,A
	MOVB TURF,E	;MULTIPLY BY FIRST BYTE
	MUL E,A
	MOVB TURF+1,E	;DIVIDE BY SECOND
	DIV E,A
TUTE:	BVS TUTER	;OVERFLOW--LOSE.
	MOV A,B
	ASR B
	ADC B		;DIVIDE BY TWO, ROUNDING.
TURD.3:	MOV TURDN,E	;TURTLE DEVICE NUMBER (FOR TYO ROUTINES)
	SUB	#6.,B
	BLT	TURD.5	;NEVER EVEN MAKE IT TO FULL ACCELERATE MODE
	MOV	#10,C
	CLR A		;AGAIN, DIVIDE BY 4 (8)
	DIV #4,A
	MOV	B,F
		;REM.=NUMBER OF STEPS NEEDED BESIDES ACCELERATION
;		AND DECELERATION WHICH CAN'T BE TAKEN IN 8'S
	INC	F	;F_TOTAL NUMBER OF 1 STEPS
	JSR	PC,TUROUT
	ADD	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	MOV A,F	;F _ NUMBER OF 8 STEPS
	INC F
	ADD C,D	;D_CHAR FOR 8 STEPS
	JSR	PC,TUROUT
	SUB	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	SUB	C,D	;D_CHAR FOR 1 STEP
	JSR	PC,TURTYO
	SEZ
TURD.4:	RTS PC

;FOR FEWER THAN 14 STEPS, JUST SEND OUT 1 STEPS
;(IN THE WORS CASE, THIS STUPID ALGORITHM REQUIRES TWICE AS
;MANY CHARS AS THE OPTIMAL ALGORITHM)
TURD.5:	ADD	#6.,B	;RESTORE WHAT WAS SUBTRACTED
	MOV	B,F
	INC F
	JSR	PC,TUROUT
	BR	TURB.2
TUTER:	ERROR+TGDZ	;TURTLE GETTING DIZZY

;MORE TURTLE COMMANDS

LAMPON:	MOV	#'!,D
	BR	TURB
LAMPOFF:	MOV	#'",D

TURB:	JSR	PC,TURTST
TURB.1:	MOV	TURDN,E
	JSR	PC,TURTYO
TURB.2:	SEZ
	RTS PC


PENDOWN:	MOV	#'0,D
	MOV	#DPD,E
	BR	TURC
PENUP:	MOV	#'8,D
	MOV	#DPU,E

TURC:	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;TURTLE, OR DISPLAY?
	BEQ	TURC.1
	JMP	(E)
	.ENDC
TURC.1:	BIT	#TURTF,DFLAGS
	BNE	TURB.1
	.IFNZ NPLOT
	BIT #PLOTF,DFLAGS	;USING PLOTTER
	BEQ	TURC.2
	JMP (E)
	.ENDC
	
TURC.2: ERROR+VTD  ;ONLY VALID FOR TURTLE,DISPLAY,OR PLOTTER

TURTS1:	MOV	TURDN,E
TURTST:	BIT	#TURTF,DFLAGS
	BEQ	.+4
	RTS	PC
	ERROR+VTU


TOOT:	JSR	PC,G1NARG
	JSR	PC,TURTS1
	MOV	#"( ,D	;TOOT CHAR IN BOTTOM, NULL IN TOP
	MOV B,A
TOOT.1:	DEC	A	;HOW MANY TIMES TO TOOT
	BLT	TURB.2
	JSR	PC,TURTYO	;SHIP OUT TOOT CHAR
	MOV	#3,F	;THEN FOLLOW IT WITH 3 NULLS
	SWAB	D
	JSR	PC,TUROUT
	SWAB	D	;RETURN TOOT CHAR TO BOTTOM
	BR	TOOT.1

;TURTLE OUTPUT
;CALL WITH CHAR IN D, NUMBER OF TIMES IN F
TURO9:	JSR	PC,TURTYO
TUROUT:	TST BRAKE
	BNE TURDOR
	SOB	F,TURO9
TURDOR:	RTS	PC


TURTYO:	SPUSH C
	MOV #TURT,C
	BIS TURDN,C
	JSR PC,TBTYO
	SPOP C
	RTS PC



TOUCH:	PUSH	A
	JSR	PC,TURTS1
	MOV	#'#,D
	TST PTBF
	BNE TOUCH2
	JSR	PC,TBTW
TOUCH3:	POP	A
	BIT	A,D
	BEQ	TOUCH1
	JMP	RTFALS
TOUCH1:	JMP	RTTRUE
TOUCH2:	JSR PC,TURTYO	;SEND THE CHARACTER FOR READING SENSORS
	JSR PC,CTYI	;GET A CHARACTER	
	JSR PC,SETTTY
	BR TOUCH3	

FTOUCH:	MOV #20,A
	BR	TOUCH
BTOUCH:	MOV	#4,A
	BR	TOUCH
LTOUCH:	MOV	#10,A
	BR	TOUCH
RTOUCH:	MOV	#40,A
	BR	TOUCH
LFTOUC:	MOV #30,A
	BR TOUCH
RFTOUC:	MOV #60,A
	BR TOUCH
LBTOUC:	MOV #14,A
	BR TOUCH
RBTOUC:	MOV #44,A
	BR TOUCH

;LIGHT--RETURN INTENSITY SEEN BY TURTLE EYE
LIGHT:	.IFNZ NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	LIGHT1
	MOV	PLTCHR,B
	BIC	#177774,B	;ONLY 2 SIGNIFICANT BITS
	JMP	R1NARG
	.ENDC
LIGHT1:	JSR	PC,TURTS1	;CHECK TO SEE IF HE HAS A TURTLE
	MOV	#'#,D
	TST PTBF
	BNE LIGHT2
	JSR	PC,TBTW
LIGHT3:	MOV	D,B
	BIC	#177700,B	;ONLY 6 SIGNIFICANT BITS
	JMP	R1NARG
LIGHT2:	JSR PC,TURTYO
	JSR PC,CTYI
	JSR PC,SETTTY
	BR LIGHT3



;START TURTLE

.IFNZ DDF
ASSTUR:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4

STARTTURTLE:
	CLR A		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTTURTLE:
.ENDC
	JSR	PC,G1NARG	;WHICH TURTLE
	TST	B
	BGE	.+4
STRTT1:	ERROR+ITN	;INVALID TURTLE NUMBER
	DEC	B
;	CMP	B,#NTUR-1
	BGT STRTT1
STRTT2:	TST PTBF
	BEQ STRTT3
	MOV #TURT,A	;TYPE OF TURTLE
	ADD B,A		;WHICH TURTLE
	JSR PC,TBCHK	;CHECK TO SEE IF HE HAS IT
	BNE .+4
	ERROR+VTU
	MOV B,TURDN	;TURTLE NUMBERR
	MOV STURF,TURF	;USE TURTLE 1'S FUDGE FACTORS
	TST A
	BLT STRTT4
	PUSH B
	JSR PC,KILLT1	;KILL ANOTHER TURTLE
	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
	POP B
	BR STRTT4
STRTT3:	ASL	B	;TURN INTO WORD INDEX
.IFZ DDF
	.IFNZ NDISP
	PUSH	B
	JSR	PC,KILLD1
	POP	B
	.ENDC
	JSR	PC,KILLT1	;KILL TURTLE IF HE ALREADY HAS ONE
	.IFNZ NPLOT
	JSR	PC,KILLPL
	.ENDC
.IFF
	PUSH B
	TST A		;KILL OTHER DEVICS?
	BLT ASTRT1	;NO
.IIF NZ NDISP, JSR PC,KILLD1
.IIF NZ NPLOT, JSR PC,KILLPL
	JSR PC,KILLT1
ASTRT1:	SPOP B
.ENDC
;	MOV	TUDN(B),E
	JSR	PC,OPEN1	;TRY TO OPEN IT
	MOV	E,TURDN	;USER VARIABLE
	MOV	STURF(B),TURF	;TURTLE FUDGE FACTOR
STRTT4:	BIC	#<DISPF+PLOTF>,DFLAGS
	BIS	#TURTF,DFLAGS	;SET FLAG FOR CONTROL OF TURTLE
.IIF NZ DDF, BIS #TURTF,DIVOWN	;SET FLAG FOR OWNING TURTLE
	SEZ
	RTS PC

KILLTURTLE:
KILLT1:.IIF Z DDF,	BIT	#TURTF,DFLAGS
.IIF NZ DDF,	BIT	#TURTF,DIVOWN
	BEQ	KILLT9	;DOESN'T HAVE A TURTLE
	TST PTBF
	BNE KILLT3
	MOV	TURDN,E
	JSR	PC,CLOSE2
KILLT3:	BIC	#TURTF,DFLAGS
.IIF NZ DDF, BIC #TURTF,DIVOWN
KILLT9:	SEZ
	RTS	PC

NODEV:	.IFNZ NDISP
	JSR	PC,KILLD1
	.ENDC
	JSR	PC,NOMUSIC
	.IFNZ	NPLOT
	JSR	PC,KILLPL
	.ENDC
;	JSR	PC,SLAM	;RELEASE ALL DEVICES FOR THIS USER
	TST PTBF
	BNE KILLT3
	RTS	PC

	.IFNZ   NPLOT
;STARTPLOTTER
.IFNZ DDF
ASSTPL:	CLR C		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM C
	BR .+4
STRTPL:	CLR C		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STRTPL:
.ENDC
	MOV	#PLTDVN,E
	JSR	PC,OPEN1
.IFNZ DDF
	TST C		;SHOULD WE KILL OTHER DEVICES?
	BLT STRTP1	;NOPE
.ENDC
	JSR	PC,KILLT1   ;KILL TURTLE IF HE HAS ONE
	BIT	#DISPF,DFLAGS
	BEQ	STRTP1
.IIF NZ NDISP,	JSR	PC,KILLD2   ;KILL DISPLAY IF HE HAS ONE
STRTP1: MOV     #PORBEG,F   ;SETT [0 0 0]
	BIS     #PLOTF,DFLAGS     ;SET PLOTTER FLAG
.IFNZ DDF
	BIC #<DISPF+TURTF>,DFLAGS
	BIS #PLOTF,DIVOWN	;SET FLAG FOR OWNING PLOTTER
.ENDC
ZVAR:	CLR (F)+	;CLEAR USER'S PLOTTER VARIABLES
	CMP #POREND,F
	BNE ZVAR
.IIF NZ DDF,	BIS #PENUF,PLPENP	;SET PENUP FLAG IN PLOTTER 
	BIS     #PENUF,DFLAGS     ;START WITH PEN UP
	JSR	PC,ANGCRP	;INIT SINE AND COSINE
	CLR	B
	CLR	C
	JSR     PC,MTO.02     ;MOVE PLOTTER THERE
ZVAR1:	SEZ
	RTS	PC
;KILLPLOTTER
KILLPL:
	MOV	#PLTDVN,E
	JSR	PC,CLOSE2
.IIF NZ DDF, BIC #PLOTF,DIVOWN
	BIC	#PLOTF,DFLAGS  ;ELIM. PLOTTER FLAG
	BR ZVAR1
	.ENDC
;HERE IS WHERE THE DISPLAY PRIMITIVES START.
.IFNZ NDISP

;STARTDISPLAY
;	INITIALIZE EVERYTHING
;	ALLOCATE DISPLAY BUFFERS
.IFNZ DDF
ASTRDI:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4
STARTDISPLAY:	CLR A	;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTDISPLAY:
.ENDC


;USE THIS PRIMITIVE TO SPECIFY A LARGE DISPLAY
	JSR	PC,G1NARG	;B _ #.  SHOULD BE 0 OR 1


STRTD0:	SPUSH	B	;THE KILLERS CLOBBER B
.IFNZ DDF
	TST A		;KILL OTHER DEVICES?
	BLT ASTRD1	;NO
.ENDC
	JSR	PC,KILLT1	;GET RID OF TURTLE IF NECSSARY
	.IFNZ	NPLOT
	JSR	PC,KILLPL   ;KILL PLOTTER IF HE HAS ONE
	.ENDC
.IFNZ DDF
ASTRD1:	BIT #DISPF,DIVOWN	;DOES HE ALREADY OWN ONE?
	BEQ ASD1	;YES
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLING DISPLAY
ASD1:
.ENDC

	BIT	#DISPF,DFLAGS	;DOES HE HAVE A DISPLAY?
	BEQ	STRTD1	;USER DOESN'T HAVE A DISPLAY YET
	JSR	PC,KILLD2	;KILL HIS PREVIOUS DISPLAY FIRST

STRTD1:;IS THIS USER A DISPLAY USER?
;I.E. IS THERE AN ACTUAL DISPLAY CONSOLE
;	ASSOCIATED WITH HIM?

;NOW WE MUST ALLOCATE HIM A DISPLAY BUFFER
;FIRST DETERMINE WHAT SIZE BUFFER HE IS LOOKING FOR.
	SPOP	B

.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV DISPLAY?
	BEQ .+6			;NO, START UP TK DISPLAY
	JMP TVSTRT		;YES, START UP TVS
.ENDC

	SAVE <#-1,TYICP>
	MOVB B,1(P)
	BIS #100000,(P)		;SAY GET THE DISPLAY FOR THIS TTY
	SAVE #.DSCAP*400+0	;ZERO IS MY CREATE CAPABILITY
	.INVOK
	BNE .+4
	ERROR+NDV
	REST <DISCAP,B,A>
	SUB #<DISAD/2>&77777,A
	MOV A,DRELOC
	CLR -(P)	;START AND LENGTH DON'T MATER
	CLR -(P)	;NEIRTHER DOES PAGE IN SOURCE
	SAVE DISCAP	;SOURCE
	MOVB #10+DISPG,1(P)	;PAGE IN ME
	SAVE <#.CRWRT+1>	;MY SPHERE CAP AND GIVE ME WRITE ACCESS
	$MAP
	MOV	#DORBEG,F	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,D	;LAST WORD
SDLOOP:	CLR	(F)+	;ZERO WORD
	CMP	F,D
	BLE	SDLOOP

.IFNZ DDF
	BIC #<PLOTF+TURTF+PENUF>,DFLAGS	;CLEAR VARIOUS FLAGS
	CLR DPENP		;START WITH THE PENDOWN
	BIS #DISPF,DIVOWN	;SET FLAG FOR OWNING DISPLAY
.ENDC
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY


;SET UP TURTLE VARIABLES
	MOV	#TLIST,D
	MOV	D,TUB
	MAKEPJ	D
	MOV	D,PUSHJT

;SET FIRST 2 WORDS OF DLIST
;AND SET THE BUFFER VARIABLES
	MOV	#DLIST,D
	MOV	#<DRSTXY!DPOP>,(D)+
	MOV	PUSHJT,(D)
	MOV	D,STB	;STATIC AREA BOTTOM
	MOV	D,STT	;STATIC AREA TOP

	ASL	B	;B _ LENGTH OF DISPLAY IN BYTES.
			;USE THIS TO CALCULATE WHERE DYNAMIC AREA ENDS
	ADD	#DISAD,B
	CLR	-(B)	;SET UP DUMMY FREE AREA
	MOV	B,DYT	;DYNAMIC AREA TOP
	CLR	-(B)
	MOV	B,DYB	;DYNAMIC AREA BOTTOM
	MOV	B,DYR	;DYNAMIC AREA ROVING POINTER


;DRAW THE TURTLE
	PUSH	C
	JSR	PC,ANGCRP	;CALCULATE ANGLE CRAP
	JSR	PC,DR.TUR	;DRAW TURTLE
	SPOP	C

;NOW MAKE A PUSHJ TO THE DISPLAY LIST
;AND STUFF IT INTO THE HARDWARE FIRST LOCATION FOR THIS DISPLAY
	TST -(P)
	SAVE #<DLIST/2>&77777
	ADD DRELOC,(P)
	SAVE DISCAP
	$INVOK		;START UP THE DISPLAY
;AND LAST BUT NOT LEAST
	JSR	PC,NEWSN2	;SET UP FOR SNAPS TO START HERE
	SEZ
	RTS	PC

;KILLDISPLAY
;	USER WANTS TO GIVE UP HIS DISPLAY
KILLDISPLAY:
KILLD1:
.IIF Z DDF,	BIT	#DISPF,DFLAGS
.IIF NZ DDF,	BIT #DISPF,DIVOWN
	BEQ	KILLDR	;USER DOESN'T HAVE DISPLAY
KILLD2:	CLR	A	;GET USER NUMBER
;	JSR	PC,SNZAP	;SET ALL SNAPS TO EMPTY-WORD
	CLR	SNLIST	;CLEAR  SNAPS
.IIF NZ DDF, BIC #DISPF,DIVOWN	;CLEAR DISPLAY FLAG
	BIC	#DISPF,DFLAGS
	JSR	PC,.GCOLL

.IFNZ TVS
	BIT #TVF,DFLAGS	;ARE WE USING TV?
	BEQ KILLD3	;NO
	CLR B
	JSR PC,CRECHO	;CREATE AN ECHO AREA OF SIZE 0 IE NO ECHO AREA
KILLD3:
.ENDC

	MOV DISCAP,A
	JSR PC,DELCAP
KILLDR:	SEZ
	RTS	PC
.IFTF
DCHKPL: .IFNZ    NPLOT
	BIT     #PLOTF,DFLAGS      ;USING PLOTTER?
	BEQ	DCHK
	RTS	PC
	.ENDC
DCHK:
.IFF
	ERROR+VTU
.IFT
	BIT	#DISPF,DFLAGS
	BNE	DCHK1
	PUSH	B
	CLR	B	;SPECIFY A SMALL DISPLAY BUFFER
.IFNZ DDF
	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
.ENDC
	JSR	PC,STRTD0	;STARISPLAY
	SPOP	B
	RTS	PC
DCHK1:	.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV?
	BNE KILLDR		;YES, JUST RETURN
	.ENDC
	CMP	NADXY,#20
	BLT	KILLDR	;DON'T BOTHER TRYING TO COMPRESS ADDXY'S
	JSR	PC,DSGC8	;TRY TO COLLAPSE
	BR	KILLDR

.ENDC
TBOX:	JSR PC,NODEV
	CLR E
	MOV #PTBTAB,B
	MOV #4,A
TBOX3:	DEC A
	BLT TBOX4
TBOX7:	SPUSH A
	SPUSH E
	PRTXT ^\PORT \
	JSR PC,PRDN
	PRTXT ^\: ?\
	JSR PC,QUEST
	SPOP E
	SPOP A
	CMP D,#'P	;IS IT A PLOTTER
	BEQ TPLOT
	CMP D,#'N	;IS IT NULL
	BEQ TNUL
	CMP D,#'C	;IS IT HIS CONSOLE
	BEQ TCON
	CMP D,#'T	;IS IT A TURTLE
	BEQ TTUR
	CMP D,#'M	;IS IT A MUSIC BOX
	BEQ TMUS
	CMP D,#7
	BEQ TBOX6
	SPUSH A
	PRTXT ^\ ? \
	SPOP A
	BR TBOX7
TMUS:	MOV #PMBOX,(B)+
	BR TBOX3
TNUL:	CLR (B)+
	BR TBOX3
TCON:	MOV #CONSO,(B)+
	BR TBOX3
TTUR:	MOV E,(B)
	BIS #TURT,(B)+
	INC E
	BR TBOX3
TPLOT:	MOV #PLOTT,(B)+
	BR TBOX3
TBOX4:	TST -(P)
	SPUSH #.TIRST
	SPUSH TYOCP
	BIS #.TTBIS*400,(P)
	$INVOK
	SUB #4,P
	SAVE TYOCP
	BIS #.TTRD*400,(P)
	$INVOK
	SPOP OTTYST
	MOV #CONSO,C
	JSR PC,TBINIT
	BEQ TBOX5
	MOV #-1,PTBF
	SEZ
	RTS PC
TBOX5:	JSR PC,NOTBOX
	ERROR+TDE
TBOX6:	JSR PC,NOTBOX
	ERROR+BRK


NOTBOX:	JSR PC,NODEV
	CLR PTBF
	SEZ
	RTS PC

.IFNZ DDF

.IFNZ NDISP

CTRDIS:	BIT #DISPF,DIVOWN	;DOES HE OWN A DISPLAY?
	BEQ CTRERR		;NO
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+PLOTF>,DFLAGS
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY
	BIS DPENP,DFLAGS	;SET DISPLAY PEN POSITION
	SEZ
	RTS PC
.ENDC

CTRTUR:	BIT #TURTF,DIVOWN	;DOES HE OWN A TURTLE?
	BNE .+4			;NO,ERROR
CTRERR:	ERROR+VTD
	BIC #<PLOTF+DISPF>,DFLAGS
	BIS #TURTF,DFLAGS	;SET FLAG FOR CONTROLLING TURTLE
	JSR PC,G1NARG		;WHICH TURTLE DOES HE WANT TO CONTROL?
	TST B			;TEST TURTLE NO.
	BGE .+4			;IT'S OKAY SO FAR
CTRER2:	ERROR+ITN		;INVALID TURTLE NUMBER
	DEC B			;TO START TO TURN INTO AN INDEX
;	CMP B,#NTUR-1
	BGT CTRER2		;IT WAS TO LARGE
	ASL B			;TURN IT INTO A WORD INDEX
;	CMP TURUSE(B),USER	;DOES HE OWN IT?
	BNE CTRERR		;NOPE
;	MOV TUDN(B),TURDN	;FOR THE OUTPUT ROUTINES
	MOV STURF(B),TURF
CTRRET:	SEZ
	RTS PC

.IFNZ NPLOT

CTRPLT:	BIT #PLOTF,DIVOWN	;DOES HE OWN THE PLOTTER?
	BEQ CTRERR		;NOPE
	BIT #PLOTF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+DISPF>,DFLAGS
	BIS PLPENP,DFLAGS	;SET PLOTTER PEN POSITION
	BIS #PLOTF,DFLAGS	;SET FLAG FOR CONTROLLING PLOTTER
	SEZ
	RTS PC

.ENDC
.ENDC

.IFNZ <NDISP!NPLOT>


.IFZ FPPF

DBK:	NEG	B
;DISPLAY FORWARD AND BACK
DFD:	MOV	B,C
	CLR	B
	TST	C
	BGE	DFD1	;IF ARG IS NEG,
	COM	B	;SET B = -1
	CLR	A	;CLEAR FLAG
DFD1:	MOV	#CURX,D
	JSR	PC,MULSIN	;PUTS DX IN E,,F
	SDPADD	(D)+,(D)+,E,F	;NEW X
	PUSH	F	;FRACTION PART
	SPUSH	E	;INTEGER PART
	JSR	PC,MULCOS	;DY IS IN E,,F
	SDPADD	(D),(D)+,E,F	;NEW Y
	SPUSH	F
	SPUSH	E
	BR	SETMOV

.IFF

DBK:	NEGF FA
DFD:	
.IFZ DDF
	LDCFD COSA,FB
	MULF FA,FB
	LDCFD CURY,FC
.IFF
	JSR PC,GTCURX		;IS HE CONTROLLING PLOTTER OR DISPLAY?
	LDCFD COSA(F),FB	;COSINE OF ANGLE -> FB
	MULF FA,FB		;DY -> FB
	LDCFD CURY(F),FC	;CURY -> FC
.IFTF
	ADDF FC,FB	;GET NEW Y IN FB
	STCDF FB,-(P)	;PUT NEW Y ON STACK
.IFT
	LDCFD SINA,FB
	MULF FA,FB	;DX IN FB
	LDCFD CURX,FC	;CURRENT X IN FC
.IFF
	LDCFD SINA(F),FB	;SINE OF ANGLE -> FB
	MULF FA,FB		;DX -> FB
	LDCFD (F),FC		;CURX -> FC
.ENDC
	ADDF FC,FB	;GET NEW X IN FB
	STCDF FB,-(P)	;PUT NEW X ON STACK
	BR SETMOV

.ENDC
.IFNZ DDF
	;PUTS THE ADDRESS OF THE CURX OF DISPLAY IN F
	;IF HE OWN A DISPLAY, ELSE PUTS CURX OF PLOTTER IN F
.IFNZ NDISP
GTCURX:	BIT #DISPF,DFLAGS	;DOES HE OWN A DISPLAY?
	BNE DISP		;YES
	MOV #PCURX,F		;PUT ADDRESS OF PCURX IN F
	BR DISP1
DISP:	MOV #DCURX,F		;PUT ADDRESS OF DCURX IN F
DISP1:	RTS PC
.IFF
GTCURX:	MOV #PCURX,F
	RTS PC
.ENDC
.ENDC


.IFZ FPPF


SETX:	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;;NEW X IN B
	CLR	-(SP)	;FRACTION PART OF NEW X
	PUSH	B	;INTEGER PART
	SPUSH	CURY	;NEW Y UNCHANGED
	SPUSH	CURY+2
	BR	SETMOV

SETY:	JSR	PC,DCHKPL
	JSR	PC,G1NARG
	PUSH	CURX	;NEW X UNCHANGED
	SPUSH	CURX+2
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	B	;INTEGER PART OF NEW Y
	BR	SETMOV

SETXY:	JSR	PC,DCHKPL
	JSR	PC,G2NARG
	CLR	-(SP)	;FRATION PART OF NEW X
	PUSH	B	;INTEGER PART
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	A	;INTEGER PART
SETMOV:	JSR	PC,MOVETO
	RTS PC

SETTURTLE:
	JSR	PC,DCHKPL
	MOV	@S,C
	JSR	PC,LD3NUM	;LOAD D,E,F
SETT1:	PUSH	F	;SAVE NEW ANGLE
	JSR	PC,SPOPT	;POP OFF ARG
	CLR	-(SP)	;FRACTION PART OF NEW X
	SPUSH	D	;INTEGER
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	E
	CLR	A	;A FLAG
	JSR	PC,MOVETO	;MOVE TO NEWX,NEWY
	SPOP	B	;NEW HEADING
	JMP	DRT.HD	;SET HEADING

.IFF
SETX:	JSR PC,DCHKPL
.IFZ DDF
	SPUSH CURY+2
	SPUSH CURY
.IFF
	JSR PC,GTCURX
	SPUSH CURY+2(F)	;PUT CURY ON STACK
	SPUSH CURY(F)
.IFTF
	JSR PC,GARG	;PUT NEWX ON STACK
	BR SETMOV
SETY:	JSR PC,DCHKPL
	JSR PC,GARG	;PUT NEW Y ON STACK
.IFT
	SPUSH CURX+2
	SPUSH CURX
.IFF
	JSR PC,GTCURX
	SPUSH 2(F)	;PUT CURX ON STACK
	SPUSH (F)
.ENDC
	BR SETMOV
SETXY:	JSR PC,DCHKPL
	JSR PC,GARG	;PUT Y ON
	JSR PC,GARG	;PUT X ON
SETMOV:	JSR PC,MOVETO
	RTS PC

SETTURTLE:
	MOV @S,C
	JSR PC,.GFLST	;FA <- NEWX
	LDD A,B		;FB <- NEWX
	JSR PC,.GFLST	;FA <- NEWY
	BIT #7777,C	;ANY MORE LIST?
	BEQ SETT1	;NO?!
	JSR PC,.LOADC	;GET POINTER TO ANGLE
	BIT #7777,A	;ANY MORE LIST? (SHOULDN'T BE)
	BNE SETT1	;THERE IS??
	MOV #SNUM,A	;TAKE POINTER AND TRY TO
	JSR PC,CONVER	;CONVERT IT TO A SNUM
	BNE .+4
SETT1:	ERROR+WTA
	SPUSH B		;STORE ANGLE
	STCDF FA,-(P)	;STORE NEWY
	STCDF FB,-(P)	;STORE NEWX
SETT2:	JSR PC,DCHKPL
	CLR A		;SET A FLAG
	JSR PC,MOVETO	;MOVE IT
	SPOP B		;POP ANGLE
	JMP DRT.HD

.GFLST:	BIT #7777,C	;GETS FLOATING NUMBER OUT OF LIST
	BEQ SETT1	;EMPTY LIST
	JSR PC,.LOADC	;GET NODE IN A AND B
	MOV A,C		;GET POINTER TO REST OF LIST IN C
	JSR PC,G1NUMS	;GET FNUM POINTED TO BY B INTO FA
	BEQ SETT1
	RTS PC

GARG:	SPOP FNPDL+4	;SO THAT THE JMP WILL WORK BELOW
	SPUSH A		;STORES REGISTERS AND GETS NUMBER IN FA
	SPUSH B
	SPUSH F
	JSR PC,G1NUM	;FA <- FNUM POINTER TO BY B
	BEQ SETT1
	SPOP F		;RESTORE REGISTERS
	SPOP B
	SPOP A
	STCDF FA,-(P)	;PUT FA ON STACK
	JMP @FNPDL+4	;DOES A RTS PC





.ENDC



;CALL WITH NEWX AND NEWY ON THE STACK




MOVETO:	JSR PC,PPOPT	;INSURE ENOPUGH STACK IS IN CORE
	.IFNZ	NPLOT
.IFNZ NDISP
	BIT	#PLOTF,DFLAGS ;USING PLOTTER?
	BEQ	MTO.09   ;IF NOT,SKIP ALL THIS
.ENDC


.IFZ FPPF

	MOV	2(P),C	;INT OF Y
	MOV	4(P),A	;FRACTION Y
	MOV	6(P),B	;INT OF X
	MOV	10(P),D	;FRACTION X
	ASL	A
	ADC	C	;ROUND Y
	ASL	D
	ADC	B	;ROUND X
	CMP	B,#128.   ;CHECK IF EXCEEDS PLOTTER BOUNDS
	BGE	MTO.03
	CMP	B,#-128.
	BLT	MTO.03
	CMP     C,#128.    ;NOW CHECK Y BOUNDS
	BGE	MTO.03
	CMP	C,#-128.
	BLT	MTO.03
	JSR	PC,MTO.02
	JMP	MTO.R
;SEND OUT PLOTTER CHARACTERS

.IFF

	LDCFD 2(P),FA	;LOAD NEWX
	LDCFD 6(P),FB	;LOAD NEWY
	STF FA,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	STF FB,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	SETI
	STCFI FA,B	;PUT NEWX INTO B
	STCFI FB,C	;PUT NEWY INTO C
	SETL
	ASR B		;ROUND NEWX
	ADC B
	ASR C		;ROUND NEWY
	ADC C
	JSR PC,MTO.02	;MOVE IT
	JMP MTO.R	;STORE AWAY NEWX AND NEWY
.IFZ DDF

CHKPL:	CMPF #42000,FC
	CFCC
	BLT MTO.03
	CMPF #142000,FC
	CFCC
	BGT MTO.03
	RTS PC
.ENDC

.ENDC

MTO.02: MOV	#35,D   ;PRIMING CHARACTER
	MOV	#PLTDVN,E
	SPUSH C
	MOV #PLOTT,C
	JSR	PC,TBTYO   ;SEND TO TTY
	JSR	PC,MTO.04	;SEND NEW X TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTYO
	SPOP B
	JSR	PC,MTO.04   ;SEND NEW Y TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTW
	MOV	D,PLTCHR	;PLOTTER WILL SEND BACK SENSING CHAR
	RTS	PC
MTO.03: ERROR+OOB
MTO.04:	MOV	B,D   ;SEND LOW ORDER 6 BITS
	BIC	#177700,D
	JSR	PC,PLT67
	JSR	PC,TBTYO
	MOV	B,D	;SEND REMAINING 2 BITS
	ASL	D
	ASL	D
	SWAB	D
	BIC	#177774,D
	BIT	#PENUF,DFLAGS   ;SEND PENUP INFO
	BEQ	MTO.05
	BIS	#40,D   ;SET PENUP BIT
MTO.05:	RTS	PC

PLT67:	BIT	#40,D	;SET BIT 6 TO COMP OF BIT 7
	BNE	PLT671
	BIS	#100,D
PLT671:	RTS	PC


.ENDC
.IFNZ NDISP

.IFZ FPPF

MTO.09:	MOV SP,F
	TST	(F)+	;POINT TO ARGS
	MOV	(F)+,B	;INTEGER PART OF NEW Y
	MOV	(F)+,C	;FRACTION PART OF NEW Y
	JSR	PC,CHKBND	;CHECK TO SEE IF IN BOUNDS
	MOV	B,E	;ROUNDED NEWY
	MOV	(F)+,B	;INTEGER PART OF NEW X
	MOV	(F),C	;FRACTION PART OF NEW X
	JSR	PC,CHKBND
	MOV	B,D	;ROUNDED NEWX
;GET D_DX AND E_DY
	MOV	#CURX,F
	ASL	(F)+	;FRACTION OF CURX
	ADC	(F)	;ROUND CURX
	SUB	(F)+,D	;DX
	ASL	(F)+
	ADC	(F)
	SUB	(F),E	;DY

.IFF

MTO.09:	.IFNZ TVS
	BIT #TVF,DFLAGS
	BEQ MTO.10
	SETF
	LDF DCURX,FA	;FROM X
	LDF DCURY,FB	;FROM Y
	REST F		;THE RETURN ADDRESS	
	LDF (P)+,FC	;TO X
	LDF (P)+,FD	;TO Y
	SAVE F		;PUT THE RETURN ADDRESS BACK
	JMP VECTOR	;DRAW THE VECTOR
MTO.10:
	.ENDC
	
	MOV P,F		;SO IT CAN DO POPS W/O DISTURBING THE STACK
	TST (F)+	;TO GET AROUND THE PC
	LDCFD (F)+,FA	;GET NEW X
	STF FA,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
	LDCFD (F)+,FB	;GET NEW Y
	STF FB,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
.IIF Z DDF,	MOV #RCURX,F
.IFNZ DDF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	ADD #RCURX,F	;TO TELL WHERE TO PUT ROUNDED FA AND FB
.ENDC 
	JSR PC,ROUND	;ROUND FA AND FB
	SETF
	SUBF (F)+,FA	;FA <- NEWX - CURX
	SUBF (F)+,FB	;FB <- NEWY - CURY
	SETD
	JSR PC,MOD1K	;PERFORM A MODULAR 32K. (ANY BETTER IDEAS?)
	SETI
	STCFI FA,D	;PUT DX IN D
	STCFI FB,E	;PUT DY IN E
	SETL

.ENDC

	BNE	MTO.1	;CHECK FOR DX=DY=0
	TST	D
	BEQ	MTO.R	;JUST RETURN

MTO.1:	BIT	#PENUF,DFLAGS	;IS PEN UP?
	BNE	MTO.PU	;YES

;THE PEN IS DOWN
	SPUSH	DIREC
	JSR	PC,XYDIR	;CALCULATE DIREC
	JSR	PC,DR.LIN	;AND DRAW LINE!!
	SPOP	DIREC

;RETURN.  SET CURX & CURY TO NEWX & NEWY


.ENDC

.IFZ FPPF

MTO.R:	POP	A	;RETURN ADDRESS
	MOV	#CURY+2,B
	SPOP	(B)	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP	-(B)
	SPOP	-(B)
	SPOP	-(B)
	JMP	(A)

.IFF

MTO.R:	POP A
.IFZ DDF
	MOV #CURX,B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE SET OF VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
.ENDC
	SPOP (B)+	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP (B)+
	SPOP (B)+
	SPOP (B)+
	JSR PC,ROUNDER	;ROUND AND PUT IN RCURX AND RCURY
	SEZ
	JMP (A)		;DOES AN RTS!!?

ROUNDER:	;PUTS ROUNDED CURX AND CURY INTO RCURX AND RCURY
.IFZ DDF
	MOV #CURX,B
	MOV #RCURX,F
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
	ADD #RCURX,F	;MAKE F POINT TO RCURX
.ENDC
	LDCFD (B)+,FA	;FA <-CURX
	LDCFD (B)+,FB	;FB <- CURY
	JSR PC,ROUND	;ROUND FA AND FB
	STCDF FA,(F)+	;RCURX <- ROUNDED CURX
	STCDF FB,(F)+	;RCURY <- ROUNDED CURY
	RTS PC

	;ROUNDS FA AND FB
ROUND:	ADDF #40000,FA	;FA <- FA + 1/2
	STCFI FA,-(P)	;INTEGERIZE FA
	BCS EROOB	;TOO BIG
	LDCIF (P)+,FA	;FA <- INTEGER (FA)
	CFCC		;IS FA > 0?
	BGE .+6		;YES
	SUBF #40200,FA	;FA <- FA - 1 (TO ROUND AWAY FROM 0)
	ADDF #40000,FB	;REPEAT SAME PROCESS FOR FB
	STCFI FB,-(P)
	BCS EROOB
	LDCIF (P)+,FB
	CFCC
	BGE .+6
	SUBF #40200,FB
	RTS PC
EROOB:	CMP (P)+,(P)+	;GET RID OF TRASH ON STACK
	ERROR+OOB

MOD1K:	LDD FB,FC
	MODF #34600,FC	;DIVIDES BY 2^16 (FC <- ONLY FRACTIONAL PART)
	CFCC
	BEQ MODK1	;IT WAS ZERO OR UNDERFLOWED
	MULF #43600,FC	;FRACTION * 2^16
	LDD FC,FB	;PUT IT BACK NOW
MODK1:	LDD FA,FC	;NOW DO IT TO FA
	MODF #34600,FC
	CFCC
	BEQ MODK2
	MULF #43600,FC
	LDD FC,FA
MODK2:	RTS PC

.ENDC

.ENDC
.IFNZ NDISP


;THE PEN IS UP
;PUT ADDX AND ADDY COMMANDS INTO DISPLAY LIST
MTO.PU:	SPUSH	#MTO.R	;SO RTS PC'S BELOW WILL WORK (GROAN !!!)
	MOV	STT,A	;POINTER TO TOP OF STATIC DISPLAY ALLOCATION
	CMP	-(A),#ADDY
	BLO	MTO.AD	;PREVIOUS STUFF NOT ADDS ANYWAY
	CMP	-(A),#ADDY	;IS THE NEXT TO LAST DCODE AN ADD,TOO ?
	BLO	MTO.AD	;NO
	CMP	A,SNABOT	;DON'T COMPRESS ACROSS SNAP BOTTOM
	BLO	MTO.AD	;NO
;THERE ARE TWO ADD COMMANDS IN A ROW
	JSR	PC,MTO.AS	;TAKE CARE OF FIRST ADD
	JSR	PC,MTO.AS	;AND SECOND ADD
	BR	MTO.R1


;MTO.AS ADDS THE DELTA X OF AN ADD COMMAND TO THE NEW DX OR DY
MTO.AS:	CMP	(A),#ADDX	;ADDX IS THE BIGGER OF THE ADDS
	BHIS	.+6
	ADD	(A)+,E	;DY
	RTS	PC
	ADD	(A)+,D
	RTS	PC



;HAVE TO EXPAND STATIC AREA AND PUT IN ADD COMMANDS
MTO.AD:	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

MTO.RM:	MOV	A,STT	;A WAS SET IN STXPND
	MOV	PUSHJT,(A)	;DISPLAY JUMP TO TURTLE
MTO.R1:	BIC	#176000,D	;IN CASE EITHER DX OR DY WERE NEGATIVE
	BIC	#176000,E	;CLEAR THE TOP 6 BITS
	BIS	#ADDY,E	;TURN E INTO ADDY COMMAND
	MOV	E,-(A)	;STORE IN DLIST
	BIS	#ADDX,D	;TURN D INTO ADDX COMMAND
	MOV	D,-(A)	;STORE IN DLIST
	CLR DFBCNT
	RTS	PC

.ENDC
.IFNZ <NDISP!NPLOT>

.IFZ FPPF

DLT:	NEG	B

;DISPLAY RIGHT AND LEFT

DRT:	ADD	CURA,B

.IFF

DLT:	NEGF FA
DRT:	SETI
	STCFI FA,B
	SETL
	BCC .+4		;NUMBER TOO LARGE??, NOPE
	ERROR+TGDZ	;TURTLE GETTING DIZZY
.IFZ DDF
	ADD CURA,B
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE VARIABLES
	ADD CURA(F),B	;B <- NEWA + CURA
.ENDC

.ENDC
DRT.HD:	JSR	PC,MOD360	;SET B=B MOD 360

.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV?
	BEQ .+6			;NO
	JMP TVHEAD		;TV VERSION OF HEADING UPDATE
.ENDC

.IIF Z DDF,	MOV	B,CURA
.IFNZ DDF
	JSR PC,GTCURX
	MOV B,CURA(F)	;MOVE NEWLY COMPUTED ANGLE TO CURA
.ENDC

;DRAW THE TURTLE IF IT'S BEING SHOWN
TURDO:	JSR	PC,ANGCRP	;DO ALL THE ANGLE CRAP.
	.IFNZ	   NPLOT
	BIT     #PLOTF,DFLAGS   ;USING PLOTTER?
	BNE	DRTRET	;YES, SO RETURN
	.ENDC
.IFZ NDISP
	ERROR+VTU
.IFF
	BIT	#HIDETF,DFLAGS	;IS THE TURTLE BEING HIDDEN ?
	BNE	DRTRET	;YES. SO RETURN
;THE TURTLE IS BEING SHOWN. SO DRAW THE TURTLE
	JSR	PC,DR.TUR
.ENDC

DRTRET:	SEZ
	RTS	PC


;SETHEAD
;	LIKE RIGHT, EXCEPT SET CURA TO ARGUMENT
SETHEAD:	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;NUMERIC ARGUMENT IN B
	BR	DRT.HD	;JUMP INTO RIGHT

;WRAPAROUND
.IFNZ NDISP

WRAP:	BIS	#WRAPF,DFLAGS
	BR DRTRET

NOWRAP:	BIC	#WRAPF,DFLAGS
	BR DRTRET

.ENDC

.IFZ FPPF



;HERE
;	OUTPUT A SENTENCE OF CURX,CURY,CURA
HERE:	JSR	PC,DCHKPL
	MOV	#CURX,D
	JSR	PC,PSHINT	;PUSH INTEGER OF CURX ONTO S-PDL
	JSR	PC,PSHINT	;PUSH INTEGER OF CURY
	MOV	(D),B	;CURRENT ANGLE
HERE.1:	JSR	PC,PSHNUM	;PUSH CURRENT ANGLE
HERE.2:	MOV	#3,D	;PUSH 3 ONTO P-PDL
	JMP	SENT.


;XCOR
;	OUTPUT THE X COORDINATE
XCOR:	JSR	PC,DCHKPL
	MOV	#CURX,D
	BR	YCOR1
;YCOR
;	OUTPUT THE Y COORDINATE
YCOR:	JSR	PC,DCHKPL
	MOV	#CURY,D
YCOR1:	JMP	R1INT	;RETURN INTEGER


;HEADING
;	RETURN THE CURRENT ANGLE
HEADING:	JSR	PC,DCHKPL
	MOV	CURA,B
	JMP	R1NARG
	;HOME -- SAME AS SETT [0 0 0]
HOME:	JSR PC,DCHKPL
	JSR PC,SPUSHT
	CLR D
	CLR E
	CLR F
	JMP SETT1

.IFF

HERE:	JSR PC,DCHKPL	;DOES HE OWN DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURX,D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
.ENDC
	JSR PC,WHOPIE	;PUT (F) INTO A NODE, POINTER IN B
	PUSHS B		;STORE POINTER TO FNUMS ON STACK
	JSR PC,WHOPIE	;DO IT AGAIN
	PUSHS B
.IIF Z DDF,	MOV (D),B	;STORE ANGLE (SNUM) ON STACK
.IIF NZ DDF,	MOV (F),B	;PUT ANGLE (SNUM) IN B
	JSR PC,PSHNUM	;PUT SNUM IN B ON S-PDL
	MOV #3,D	;PUSH A FLAG ON	
	JMP SENT.	;CHANGE THE THREE THINGS INTO A SENTENCE

XCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IIF Z DDF,	MOV #CURX,D	;PUT POINTER TO CURRENT X IN D
.IIF NZ DDF,	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	BR YCOR1	;GET NUMBER AND RETURN

YCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURY,D	;PUT POINTER TO CURRENT Y IN D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURY,F	;MAKE F POINT TO CURY
.ENDC
YCOR1:	JSR PC,WHOPIE	;PUT NUMBER INTO A NODE,POINTER RETURNED IN B
	JMP ORTB	;PUT POINTER IN B ON S-PDL

HEADING:JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV CURA,B	;PUT POINTER TO ANGLE IN B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURA,F	;MAKE F POINT TO CURA
	MOV (F),B	;MOVE CURA TO B
.ENDC
	JMP R1NARG	;RETURN B

HOME:	CLR -(P)	;SETTURTLE [0 0 0]
	CLR -(P)
	CLR -(P)
	CLR -(P)
	CLR -(P)
	JMP SETT2	;SET THE TURTLE!

	;TAKES FNUM POINTED TO BY F, AND PUTS IT IN A NODE
	;RETURNS POINTER TO IT IN B
WHOPIE:	SPUSH C
.IFZ DDF
	MOV (D)+,A
	MOV (D)+,B
.IFF
	MOV (F)+,A	;PUT FNUM IN A AND B
	MOV (F)+,B
.ENDC
	JSR PC,GRBAD	;PUT FNUM IN NODE SPACE
	BIS #FNUM,C	;SET APPROPRIATE TYPE
	MOV C,B		;PUT POINTER IN B
	SPOP C
	RTS PC

.ENDC

;PENP
;RETURNS TRUE IF THE PEN IS DOWN
;RETURNS FALSE IF IT IS UP
PENP:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
	BIT #PENUF,DFLAGS	;IS THE PEN UP?
	BNE PENP1	;YES
	JMP RTTRUE	;NO, RETURN TRUE
PENP1:	JMP RTFALS	;YES, RETURN FALSE
.IFNZ NDISP


;	HIDETURTLE
HIDETURTLE:
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY??

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV?
	BEQ .+6		;NO
	JMP TVHIDE	;YES, DO THINGS FOR TV
.ENDC

	BIS	#HIDETF,DFLAGS	;SET THE HIDETURTLE FLAG
	MOV	#DPOP!DSTOP,@TUB
	BR SHOWT9


;	SHOWTURTLE
SHOWTURTLE:
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ .+6		;NO
	JMP TVSHOW	;YES, SHOW THE TV TURTLE
.ENDC

	BIT	#HIDETF,DFLAGS	;IS TURTLE HIDDEN NOW ?
	BEQ	SHOWT9	;NO, IT'S ALREADY BEING SHOWN
;HAVE TO DRAW THE TURTLE
	BIC	#HIDETF,DFLAGS	;CLEAR THE FLAG FIRST
	JSR	PC,DR.TUR
SHOWT9:	SEZ
	RTS PC

.ENDC


;	DISPLAY PENUP
DPU:	BIS	#PENUF,DFLAGS	;SET PEN UP FLAG
.IFNZ TVS
	MOV #.TVDSN,DRAWMD	;DRAW LINES IN NULL MODE, IE DON'T SHOW
.ENDC
.IFNZ DDF
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING A DISPLAY?
	BEQ DPU1	;NO
	BIS #PENUF,DPENP	;SET PEN UP FLAG IN DISPLAY VARIABLES
	BR DPR			;RETURN
DPU1:	BIS #PENUF,PLPENP	;SET PEN UP FLAG IN PLOTTER VARIABLES
.ENDC
DPU2:	SEZ
	RTS PC


	;SAME AS ABOVE BUT CLEARING PEN UP FLAG
;	DISPLAY PENDOWN
DPD:	BIC	#PENUF,DFLAGS	
.IFNZ TVS
	MOV #.TVDSI,DRAWMD	;DRAW LINES IN IOR MODE
.ENDC
.IFNZ DDF
	BIT #DISPF,DFLAGS
	BEQ DPD1
	BIC #PENUF,DPENP
	BR DPR
DPD1:	BIC #PENUF,PLPENP
DPR:
.ENDC
	BR DPU2
.ENDC

.IFNZ NDISP
;CLEARSCREEN--WIPE SCREEN AND RESTORE TURTLE TO [0 0 0]
CLEARSCREEN:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV?
	BEQ .+6			;NO
	JMP TVCS		;YES, DO THINGS FOR TV
.ENDC
	JSR	PC,WC.1	;WIPE IT CLEAN
	SPUSH DFLAGS
	MOV	#DORBEG,C	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,B	;INCLUDING CURX, CURY AND OTHERS
CSLOOP:	CLR	(C)+
	CMP	C,B
	BLT	CSLOOP

	SPOP DFLAGS
	CLR DFBCNT
	JSR	PC,TURDO	;DO ANGLE CRAP AND DRAW TURTLE IF SHOWN
	MOV	STB,STT
	MOV	PUSHJT,@STB
	JSR	PC,NEWSN2	;RECALCULATE STARTING POINT FOR SNAPS
	SEZ
	RTS PC

.IFZ FPPF

;SNAP

SNAP:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

;FIRST SET UP THE 3 NODE SNAP STRUCTURE ITSELF
	JSR	PC,PSHNUM	;FIRST NUMBER IS DUMMY FOR NOW
.IIF NZ DDF,	MOV	#DCURX,D
.IIF Z DDF,	MOV	#CURX,D
	JSR	PC,GETINT	;INTEGER OF CURX IN B
	SUB	OLDX,B	;TO GET DELTA X
	JSR	PC,PSHNUM	;PUSH ON S-PDL
	JSR	PC,GETINT	;INTEGER OF CURY
	SUB	OLDY,B	;TO GET DELTA-Y
	JSR	PC,PSHNUM
	MOV	#3,D	;NUMBER OF ARGS TO SENTENCE
	JSR	PC,SENT.

.IFF
	;CALCULATES DX AND DY, AND PUTS POINTERS TO THEM ON S-PDL
OLD:	JSR PC,(PC)	;DO THIS TWICE
	SETF
	LDF (D)+,FA	;SECOND TIME IT POINTS TO CURY
	SUBF (F)+,FA	;SECOND TIME POINTS TO OLDY
	STF FA,-(P)	;PUT DX OR DY ON STACK
	SPOP A		;PUT FNUM IN A,,B
	SPOP B
	SETD
	JSR PC,GRBAD	;PUT A,,B IN NODE
	BIS #FNUM,C	;SET TYPE
	SPUSHS C	;PUT POINTER ON S-PDL
	RTS PC


SNAP:	JSR PC,DCHK	;DOES HE OWN ADISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ .+4		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
.ENDC
	JSR PC,PSHNUM	;PUSH SNAP POINTER
.IIF NZ DDF,	MOV	#DCURX,D	;D POINTS TO CURX
.IIF Z DDF,	MOV	#CURX,D		;DITTO
	MOV #OLDX,F	;E POINTS TO WHERE SNAP IS TAKEN FROM
	JSR PC,OLD	;CALCULATE DX AND DY OF SNAP
	MOV #3,D	;SET FLAG FOR SENTENCE
	JSR PC,SENT.	;MAKE THE THREE THINGS INTO A SENTENCE


.ENDC


;NOW GRAB A NODE FOR THE SNLIST HACKING
	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BNE	SNAP.2
	MOV	#SNUM,A	;FIRST SNAP
	CLR	B	;CREATE SNAP LIST. FIRST NODE IS A DUMMY
	JSR	PC,GRBAD
	BIS	#LIST,C
	MOV	C,SNLIST
SNAP.2:	JSR	PC,.LDP1	;POINTER TO REST OF SNAP LIST
	JSR	PC,GRBAD	;STORE A NODE
	BIS	#LIST,C
	MOV	C,GCP1	;GARBAGE COLLECT PROTECT

;NOW TRANSFER THE DISPLAY CODE (YEAH)
	MOV	SNABOT,D	;BOTTOM OF STUFF TO BE SNAPPED
	JSR	PC,DYXFR	;TRANSFER THE DCODE. SKIP IF SUCCEEDS
	BEQ	SNAP.4	;COULDN'T FIND ENOUGH FREE MEMORY
SNAP.0:	TST	D	;IF 0
	BEQ	SNAP.3	;NO CODE MOVED

;CHECK THAT THIS SNAP WON'T CAUSE DISPLAY PDL OVERFLOW
	TST	-(D)	;POINTER TO SNAP
	CMP	-(D),#<<<DPDLL_-1>&77777>-1>	;DEPTH COUNTER
	BLE	SNAP.1
	CLR	GCP1
	ERROR+STD	;SNAP TOO DEEP

;NOW GO BACK AND PUT THE SNAP ADDRESS IN RIGHT PLACES
SNAP.1:	TST	(D)+	;POINT D TO REF COUNTER
	INC	(D)+	;INC COUNTER THAT SAYS HOW MANY TIMES DISPLAYED
	MOV	GCP1,C	;NOW HACK SNLIST
	MOV	D,A
	JSR	PC,.STP2	;STORE ADDRESS IN 2ND WORD OF NODE
	MOV	C,A	;POINTER TO NODE
	BIC	#170000,A
	BIS	#SNUM,A
	MOV	SNLIST,C
	JSR	PC,.STP1	;STORE NEW NODE POINTER INTO FIRST NODE OF SNLIST

	CLR	GCP1


	MOV	@S,C	;NOW HACK THE SNAP STRUCTURE
	BIC	#170000,C
	BIS	#SNP,C
	MOV	C,@S	;PUT IN RIGHT DATA TYPE
;PUT ADDRESS OF SNAP INTO FIRST OF STRUCTURE
	JSR	PC,.LDP2	;A_POINTER TO FIRST OF STRUCTURE
	MOV	A,C
	CLR	A
	MOV	D,B
	BGE	SNAP.6	;SIGN EXTEND ADDRESS
	COM	A
SNAP.6:	JSR	PC,.STORE	;STORE ADDRESS OF SNAP AS FIRST OF STRUCTURE

;NOW COLLAPSE STATIC AREA AND DISPLAY THE SNAP
	MOV	#SNABOT,A	;MAKE SURE THERE IS ROOM FOR DISPLAY HERE
	JSR	PC,STXPND
	MOV	A,STT
	MAKEPJ	D
	MOV	PUSHJT,(A)
	MOV	D,-(A)
	CLR	-(A)
	CLR DFBCNT
	CLZ
	RTS PC


;SINCE NO DISPLAY CODE WAS MOVED, RETURN EMPTY SNAP
SNAP.3:	MOV	#SNP,@S
	CLR	GCP1
	CLZ
	RTS PC

SNAP.4:	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	SNABOT,D
	JSR	PC,DYXFR	;TRY TO TRANSFER D.CODE AGAIN
	BNE	SNAP.0	;SUCCESS!
SNAP.5:	CLR	GCP1
	ERROR+TML
.IFZ FPPF

;NEWSNAP
;SET UP FOR NEXT SNAP TO START HERE
NEWSNAP:	JSR	PC,DCHK
NEWSN1:
.IIF NZ DDF,	MOV	#DCURX,D	;ENTER HERE AS SUBROUTINE
.IIF Z DDF,	MOV	#CURX,D	;ENTER HERE AS SUBROUTINE
	JSR	PC,GETINT	;GET INTEGER OF CURX IN B
	MOV	B,OLDX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,OLDY

.IFF

NEWSNAP:	JSR PC,DCHK	;DOES HE OWN A DISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ .+4		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
.ENDC
NEWSN1:	;ENTER HERE AS SUBROUTINE
.IIF NZ DDF,	MOV	#DCURX,D	;GET POINTER TO CURX
.IIF Z DDF,	MOV	#CURX,D		;GET POINTER TO CURX
	MOV #OLDX,B		;GET POINTER TO OLDX
	MOV (D)+,(B)+	;PUT CURX AND CURY INTO OLDX AND OLDY
	MOV (D)+,(B)+
	MOV (D)+,(B)+
	MOV (D)+,(B)+

.ENDC

NEWSN2:	MOV	STT,SNABOT	;RESET SNAP BOTTOM TO TOP OF DISPLAY
	CLR DFBCNT
	SEZ
	RTS	PC	;EITHER RETURN FROM SUBROUTINE , OR JMP NORT

;DISPLAY A SINGLE SNAP

DISPLAY:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ .+4		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
.ENDC

	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP,CURX,CURY
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFZ FPPF

	MOV	E,B
	ADD	CURX+2,B
	CLR	C	;FRACTION PART IS 0 (SEE SNAP)
	JSR	PC,CHKBND	;IS NEW X COR IN BOUNDS?
	MOV	F,B
	ADD	CURY+2,B
	JSR	PC,CHKBND	;IS NEW Y COR IN BOUNDS?

.IFF

	MOV F,B		;PUT POINTER TO DY IN B
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	STF FA,FB	;FB <- DY
	MOV E,B		;PUT POINTER TO DX IN B
	JSR PC,G1NUMS	;FA <- DX
	BNE .+4
DIPSEY:	.BUG.		;NO WAY IT SHOULD FAIL EITHER
.IIF NZ DDF,	MOV #DCURX,B	;PUT POINTER TO CURX IN B
.IIF Z DDF,	MOV #CURX,B
	SETF
	ADDF (B)+,FA	;GET NEW XCOR
	ADDF (B)+,FB	;GET NEW YCOR
	SETD
	STF FA,FD	;CHECK TO SEE IF XCOR IS IN BOUNDS
	JSR PC,CHKBND
	STF FB,FD	;CHECK TO SEE IF YCOR IS IN BOUNDS
	JSR PC,CHKBND

.IFTF

;NOW SEE IF THERE'S ENOUGH ROOM IN THE DISPLAY AREA

	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

;FINALLY, WE CAN PLACE THE PUSHJ TO THE SNAP INTO THE DISPLAY LIST
DISRM:	INC	-2(D)	;INCREMENT THE REF COUNTER OF THE SNAP
	MOV	A,STT	;SET STATIC TOP TO HERE IN DLIST
	MOV	PUSHJT,(A)	;PUT PUSHJ TO TURTLE AT TOP OF DLIST
	MAKEPJ D
	MOV	D,-(A)	;PUT IN THE PUSHJ
	CLR	-(A)	;PRECEDE BY A NOP

;NOW, SET CURX AND CURY
.IFT

	ADD	E,CURX+2	;E HAD DX OF THE SNAP
	ADD	F,CURY+2	;F HAS DY OF THE SNAP
.IFF

.IIF NZ DDF,	MOV #DCURX,B	;B <- POINTER TO CURX
.IIF Z DDF,	MOV #CURX,B
	STCDF FA,(B)+	;PUT NEW XCOR INTO CURX
	STCDF FB,(B)+	;PUT NEW YCOR INTO CURY
	JSR PC,ROUNDER	;ROUND CURX,CURY AND PUT INTO RCURX,RCURY

.ENDC

	CLR DFBCNT
D.RET:	JSR	PC,SPOPT	;POP S
	SEZ
	RTS PC

;WIPE A SNAP

WIPE:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ .+4		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
.ENDC

	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP, X,  Y
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFNZ FPPF

	MOV F,B		;B <- POINTER TO DY OF SNAP
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	LDD FA,FB	;FB <- DY
	MOV E,B		;B <- POINTER TO DX
	JSR PC,G1NUMS	;FA <- DX
	BEQ DIPSEY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	JSR PC,ROUND	;ROUND FA AND FB
	SETI
	STCFI FA,E	;E <- DX OF THE SNAP
	STCFI FB,F	;F <- DY OF SNAP
	SETL
.ENDC
	BIC	#176000,E	;CLEAR TOP 6 BITS
	BIS	#ADDX,E	;AND TURN INTO ADDX COMMAND
	BIC	#176000,F	;CLEAR TOP 6 BITS
	BIS	#ADDY,F	;TURN INTO ADDY

	MOV	D,B
	TST	-(D)	;POINT D TO SNAP'S REF COUNTER
	MAKEPJ B	;MAKE B INTO DPUSHJ TO SNAP
	MOV	STT,A	;POINTER TO TOP OF DISPLAY LIST
	MOV	STB,C	;POINTER TO BOTTOM OF DLIST

WIPE.L:	CMP	A,C	;ARE WE AT THE BOTTOM YET?
	BLO	D.RET	;YES, SO WE ARE DONE
	CMP	B,-(A)	;IS THE NEXT WORD A PUSHJ?
	BNE	WIPE.L	;NO.  LOOP BACK AND TRY ANOTHER
;YES!  IT IS A PUSHJ
;PUT ADDX AND ADDY COMMANDS INTO DLIST
	INC	NADXY	;NADXY IS ACOUNTER TO TELL WHEN TO COMPRESS
	MOV	F,(A)	;INSERT ADDY MADE FROM DY OF SNAP
	MOV	E,-(A)	;INSERT ADDX MADE FROM DX OF SNAP

	DEC	(D)	;DECREMENT REF COUNTER
	BR	WIPE.L	;AND THEN LOOP BACK TO SEE IF THERE'S ANOTHER
;			PUSHJ TO THIS SNAP


;WIPE THE ENTIRE DISPLAY

WIPECLEAN:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS
	BEQ .+6		;NO
	JMP TVWC	;TO THE TV FUNCTIONS
.ENDC

WC.1:	MOV	STB,A	;POINTER TO BOTTOM OF DISPLAY LIST
	MOV	STT,B	;POINTER TO TOP OF DLIST
	MOV	#100000,E	;SMALLEST DPUSHJ
	MOV	#140000,F	;SMALLEST COMMAND BIGGER THAN PUSHJ

WC.LP:	CMP	B,A	;ARE WE AT BOTTOM YET?
	BLOS	WC.DUN	;YES, WE ARE DONE
	CMP	-(B),E	;IS NEXT WORD DOWN A PUSHJ?
	BLO	WC.LP	;NO, IT'S TOO SMALL
	CMP	(B),F
	BHIS	WC.LP	;NO, IT'S TOO BIG
;THIS WORD IS A PUSHJ
	MOV	(B),D	;MOVE	THE PUSHJ COMMAND INTO D
	MAKEAD D	;TURN INTO PDP-11 ADDRESS
	DEC	-(D)	;DECREMENT SNAP'S REF COUNTER
	BR	WC.LP	;LOOP BACK TO LOOK FOR MORE PUSHJ'S

;NOW PLACE ADDX AND ADDY COMMANDS IN THE DISPLAY LIST
;SO THAT THE TURTLE WILL STAY AT THE SAME PLACE IT WAS BEFORE THE WIPE

.IFZ FPPF

WC.DUN:	MOV	#CURX,D
	JSR	PC,GETINT	;GET INTEGER OF  CURX IN B
	SPUSH	B	;SAVE DX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,E	;PUT DY IN E
	SPOP	D	;PUT DX IN B
.IFF
WC.DUN:
.IIF NZ DDF,	MOV #RDCURX,F	;F <- POINTER TO RCURX
.IIF Z DDF,	MOV #RCURX,F
	LDCFD (F)+,FA	;FA <- RCURX
	LDCFD (F)+,FB	;FB <- RCURY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	SETI
	STCFI FA,D	;F <- RCURX
	STCFI FB,E	;E <- RCURY
	SETL
.ENDC
	MOV	STB,STT
	JSR	PC,MTO.AD	;PUTS THE ADD COMMANDS INTO THE DLIST
	JSR	PC,NEWSN1	;SO THAT SNAPS WILL START HERE

	RTS	PC
.ENDC
.STITL DISPLAY UTILITY ROUTINES

.IFZ FPPF


;CHKBND
;	CHECK BOUNDS.  ERROR IF B IS OFF SCREEN
;	ALSO ROUNDS B,,C
CHKBND:	BIT	#WRAPF,DFLAGS
	BNE	CBRND	;GO AND ROUND
	CMP	B,#200.
	BGE	CBIBIG	;INTEGER PART MAY BE TOO BIG
	CMP	B,#-200.
	BLT	ERROOB	;DUE TO THE FACT THAT FRACTION IS ALWAYS
			;POSITIVE, IF B=-200 THAT GUARANTEES IT IS IN
			;BOUNDS. (I HOPE)
CBRND:	ASL	C
	ADC	B
	RTS	PC
;HERE, THE INTEGER PART IS >= 200.
;SO IF THE FRACTION PART IS NON-ZERO, THAT WILL MEAN THAT THE ENTIRE
;NUMBER IS GREATER THAN 200
CBIBIG:	BGT	ERROOB	;INTEGER>200
	TST	C
	BEQ	CBRND
ERROOB:	ERROR+OOB

.IFF

CHKBND:	BIT #PLOTF,DFLAGS	;IS HE USING PLOTTER?
	BNE CHK1	;YES, IGNORE WRAP FLAG
	BIT #WRAPF,DFLAGS	;IS HE WRAPPING
	BNE CBRND	;YES, DON'T CHECK BOUNDS
CHK1:	CMPF #42110,FD	;IS 200 < FD?
	CFCC
	BLT ERROOB	;YES, ERROR
	CMPF #142110,FD	;IS -200 > FD?
	CFCC
	BGT ERROOB	;YES,ERROR
CBRND:	RTS PC
ERROOB:	ERROR+OOB	;OUT OF BOUNDS

.ENDC
;	CALL WITH D POINTING TO CURX OR CURY.
;	RETURN THE INTEGER OF CURX OR CURY IN B
GETINT:	MOV	(D)+,B	;THE FRACTION PART
	ROL	B
	MOV	(D)+,B	;THE INTEGER PART
	ADC	B	;ROUND
	RTS	PC

.IFNZ NDISP

;STATIC AREA EXPAND.
;	IS THERE ROOM IN STATIC AREA FOR 2 DISPLAY WORDS?
;	RETURN POINTER TO NEW STATIC TOP IN A
STXPND:	PUSH	A
	MOV	@A,A	;ROUTINE IS CALLED WITH ADDRESS OF VARIABLE
	CMP	(A)+,(A)+	;A _ A+4
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN8	;THERE'S ROOM!
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	@(SP)+,A	;AND TRY AGAIN
	CMP	(A)+,(A)+
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN9
	ERROR+TML	;TOO MANY LINES
STXPN8:	TST	(SP)+	;POP OFF A
STXPN9:	RTS	PC

.ENDC


;MOD360
;	OUTPUT B MOD 360 IN B.
;	ALWAYS OUTPUTS A POSITIVE NUMBER
MOD360:
	TST B
	SXT A
	DIV #360.,A	;DIVIDE B BY 360
	TST B		;REM >= 0?
	BGE	M360R
	ADD	#360.,B	;IF REMAINDER WAS NEGATIVE, ADD 360 TO IT
M360R:	RTS	PC


.IFZ FPPF

;MULCOS
;	RETURN A*COSINE OF CURA IN B,,C
MULCOS:	MOV	COSA,F
	BR	MULCS2
;MULSIN
;	RETURN A*SINE OF CURA IN B,,C
MULSIN:	MOV	SINA,F
MULCS2:	CLR	E
	ASL	F	;TURN INTO BOTTOM HALF OF DP NUMBER
	SBC	E	;MAKE E NEG. IF F WAS
	JSR	PC,.DPMUL
	NOP	1
	RTS	PC
.ENDC

;ANGCRP
;	CALCULATE ANGLE CRAP.
;	CALCULATE DIREC, SINA, COSA
ANGCRP:
.IFZ FPPF
	CLR E
.IFZ DDF
	MOV CURA,F	;DIVIDE CURA BY 90.
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	MOV CURA(F),F	;F <- CURX
.ENDC
	DIV #90.,E
	MOV F,C		;THE REMAINDER
	MOV E,F		;THE QUOTIENT
	MOV #90.,E	;THE RIGHT ANGLE
	SUB	C,E	;NOW E = 90.- REMAINDER
	MOV	C,A	;A_REMAINDER
	JSR	PC,SINGET	;D_SIN (A)
	MOV	D,B
	MOV	E,A
	JSR	PC,SINGET
	ASL	F	;F = 0,1,2,3
	ADD	F,PC	;JUMP THROUGH THIS DISPATCH TABLE
	BR	ACR.D
	BR	ACRII	;QUADRANT II
	BR	ACRIII	;QUADRANT III
;FOURTH QUADRANT
	MOV	B,A	;SIN (A)
	MOV	D,B	;SIN (90-A)
	NEG	B	;SINA=-SIN(90-A) IN 4TH QUADRANT
	MOV	A,D	;AND COSA=SIN(A) IN 4TH QUADRANT
	BR	ACR.D

;THE THIRD QUADRANT
ACRIII:	NEG	B	;SINA = -SIN (A) IN 3RD QUADRANT
	NEG	D	;COSA = - SIN (90-A) IN 3RD QUADRANT
	BR	ACR.D

;SECOND QUADRANT
ACRII:	MOV	B,A	;SIN (A)
	MOV	D,B	;SINA = SIN (90-A) IN 2ND QUADRANT
	MOV	A,D
	NEG	D	;COSA = -SIN (A) IN 2ND QUADRANT

;IN THE FIRST QUADRANT
;SINA = SIN (A) AND
;COSA = SIN (90-A)
ACR.D:	MOV	B,SINA
	MOV	D,COSA

;FALLS THROUGH
;FALLS IN

;CLACULATE DIREC FROM STUFF LEFT IN F AND C BY ANGCRP
ANGDIR:	CMP	#45.,C
	ADC	F	;CARRY SET IF C<45
	ASL	F
	ASL	F
	ASL	F
	MOV	F,DIREC
	RTS	PC

;GET SIN (A) INTO D.
;THE SINE TABLE HAS ONLY EVEN ANGLES.  INTERPOLATE ODD ANGLES.
SINGET:	BIT	#1,A	;ODD OR EVEN
	BEQ	AEVEN
	ADD	#<SIN+1>,A	;POINT TO ANGLE AFTER IT
	MOV	(A),D	;SIN (A+1)
	ADD	-(A),D	;PLUS SIN (A-1)
	ROR	D	;DIVIDED BY 2
	RTS	PC
AEVEN:	MOV	SIN(A),D
	RTS	PC

.IFF
	SETI
.IFZ DDF
	LDCIF CURA,FA	;ANGCRP FOR FLOATING DISP
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	LDCIF CURA(F),FA	;FA <- CURA
.ENDC
	SETL
	STF FA,FE	;SAVE ANGLE
	JSR PC,SINDEG	;FA <- SIN (FA)
.IIF Z DDF,	STCDF FA,SINA
.IIF NZ DDF,	STCDF FA,SINA(F)	;SINA <- SINE OF ANGLE
	LDD FE,FA	;GET ANGLE
	JSR PC,COSDEG	;FA <- COS (FA)
.IIF Z DDF,	STCDF FA,COSA
.IIF NZ DDF,	STCDF FA,COSA(F)	;COSA <- COSINE OF ANGLE
	ASL C		;CALCULATE DIRECTION
	ASL C
	MOV C,DIREC
 	RTS PC

SINEF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BNE .+4
	ERROR+WTAB	;WRONG TYPE OF ARG
	JSR PC,SINDEG	;FA <- SINE (FA)
	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT SINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE


COSF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BEQ SINEF+6
	JSR PC,COSDEG	;FA <- COSINE (FA)
COSF1:	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT COSINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE

SINDEG:	MOV #-1,A
	BR TRIG
COSDEG:	MOV #1,A
TRIG:	MOV #1,B
	TSTF FA
	CFCC
	BGE TRIG1
	NEGF FA
	MUL A,B
TRIG1:	DIVF #41464,FA	;DIVIDE BY 45
	MODD #40200,FA	;SEPERATE FRACTION AND INTEGER
	MODD #37400,FB
	MULF #41000,FB	;MOD 8
	SETI
	STCFI FB,C
	SETL
	ASL C
	ADD C,PC
	BR .TRIG0
	BR .TRIG1
	BR .TRIG2
	BR .TRIG3
	BR .TRIG4
	BR .TRIG5
	BR .TRIG6
	MUL A,B
	BR .TRIG7
.TRIG6:	MUL A,B 
	NEG A
	BR .TRIG0
.TRIG4:	NEG B
	BR .TRIG0
.TRIG3:	NEG B
	MUL A,B
	BR .TRIG7
.TRIG2:	NEG A
	MUL A,B
	BR .TRIG0
.TRIG5:	NEG B
.TRIG1:	NEG A
.TRIG7:	SUBF #40200,FA	;WE WANT 45 - ANGLE
	NEGF FA
.TRIG0:	MULF PI,FA
	MULF #37600,FA	;CONVERT FROM DEGREES TO RADIANS
	LDD FA,FD
	MULF FD,FD
	NEGF FD		;-ANGLE SQUARED INTO FD
	LDCFD #40200,FB	;COUNTING CONSTANT "1"
	STF FB,FF
	TST A
	BLT .TRIG9	;WE WANT SIN
	LDD FB,FA
	CLRF FB
.TRIG9:	LDD FA,FC
	TSTF FD
	CFCC
	BEQ TRIG11
TRIG10:	ADDF FF,FB
	DIVF FB,FC
	ADDF FF,FB
	DIVF FB,FC
	MULF FD,FC
	ADDF FC,FA
	CMPF #41100,FB
	CFCC
	BGE TRIG10
TRIG11:	TST B
	BGE .+4
	NEGF FA
	RTS PC

ATAN:	JSR PC,G1ARG	;ARG IN FA, DOES SEZ IF IT FINDS A NUMBER
	BNE .+4		;DID WE GET A NUMBER?
	ERROR+WTA	;NO
	CLRF FB		;WILL HOLD THE SUM
	CLR A		;A FLAG
	MOV #5,C	;FOR A LOOP
	SETD		;WE WILL BE VERY ACCURATE
	MOV #ATANC0,D	;D POINTS TO CONSTANT TABLE
	MOV #PIFOUR,B	;B POINTS TO PI/4
	TSTF FA		;IS ARG NEGATIVE
	CFCC		;A DREADFUL DEC CROCK
	BGE ATANOK	;ARG NON-NEGATIVE
	ABSF FA		;ARG IS NEGATIVE
	INC A		;SO SET FLAG
ATANOK:	STF FA,FC	;SAVE ARG INTO FC
	CMPF #40200,FA	;#40200 IS A FLOATING 1. IS ARG
	CFCC		;BIGGER THEN 1?
	BGE ATANK1	;YES, NO HACKING NEEDED
			;FOR ARG > 1 A DIFFERENT APPROXIMATION IS USED
	LDCFD (B)+,FB	;B POINTS TO A CONSTANT TO BE ADDED TO THE SUM
	ADDF #40200,FC	;ARG BECOMES ((ARG - 1)/(ARG + 1))
	SUBF #40200,FA	
	DIVF FC,FA	;NEW ARG IS IN FA
	STF FA,FC	;AND ALSO IN FC
ATANK1:	MULF FA,FC	;FC NOW HAS (ARG ** 2)
	STF FC,FE	;FE HOLDS (ARG**2) FOR USE IN THE LOOP
	STF FA,FC	;RESTORE ARG
	BR .+4		;SKIP FIRST INSTRUCTION
ATANLP:	MULF FE,FC	;FC _ (ARG ** (2*I + 1)
	LDF (D)+,FD	;LOAD CONSTANT INTO FD
	MULF FC,FD	;IN THE I'TH LOOP, FC HAS (ARG **(2*I + 1)
	ADDF FD,FB	;ADD IT TO THE SUM
	SOB C,ATANLP	;WE DO THIS FIVE TIMES
	SETI
	LDCIF #180.,FA	;CHANGE TO DEGREES
	SETL
	MULF FB,FA	;GET THE NUMBER OF DEGREES * PI INTO FA
	DIVF PI,FA	;DIVIDE BY PI
	TST A		;WAS ARG NEGATIVE?
	BEQ .+4		;NO, NEVER WAS
	NEGF FA		;YES, SO CHANGE SIGN AGAIN
	JMP COSF1	;RETURN ARG
.ENDC


;XYDIR
;	CALL WITH D=DX, E=DY
;	CALCULATE DIREC BASED ON DX AND DY
XYDIR:	CLR	A	;BUILD INDEX IN A
	TST	D	;IS DX POSITIVE
	BGE	XYDIR1
	NEG	D	;ABSOLUTE VALUE OF DX
	TST	(A)+	;PUT 2 INTO A
XYDIR1:	TST	E	;IS DY POSITIVE
	BGE	XYDIR2
	NEG	E	;ABSOLUTE VALUE OF DY
	INC	A	;INCREMENT INDEX
XYDIR2:	CMP	D,E	;WILL GENERATE CARRY IF D<E
	ROL	A	;PUT CARRY INTO BOTTOM BIT OF INDEX.  AND MULTIPLY REST BY 2
	MOVB	DREC(A),DIREC	;NOW MOVE THE RIGHT THING INTO DIREC
	RTS	PC




.IFNZ NDISP

;DYXFR
;	TRANSFER FROM STATIC AREA TO DYNAMIC AREA
;	THE CODE BEING TRANSFERRED STARTS AT D AND GOES UP TO STT
;	ON RETURN, D POINTS TO THE TRANSFERRED DCODE
;	IF NO CODE WAS TRANSFERRED, THEN D = 0.
;	SKIPS IF THERE'S ROOM FOR TRANSFER
DYXFR:	MOV	STT,E
	SUB	D,E	;LENGTH OF DCODE TO BE MOVED
	BEQ	DYRET	;NOTHING TO BE MOVED
;ALLOCATE STORAGE
;LENGTH OF BLOCK TO BE ALLOCATED IS IN E
DYAL:	ADD	#6,E	;INCREASE LENGTH TO ALLOW FOR REF CNTR, DEPTH CNTR, AND POPJ
	MOV	DYR,B	;INITIALIZE POINTER
	MOV	#1,C	;INITIALIZE FLAG
DYAL1:	MOV	2(B),A	;POINTER TO NEXT FREE BLOCK
	BNE	DYAL2
	DEC	C	;NO NEXT FREE BLOCK--TEST AND SET FLAG
	BNE	DYAL7	;NO MORE ROOM--GO TO EXPAND DY AREA
	MOV	DYB,B	;START AGAIN AT BOTTOM OF LIST
	BR	DYAL1
DYAL2:	MOV	(A),F	;FREE BLOCK FOUND--CHECK LENGTH
	SUB	E,F
	BPL	DYAL4
DYAL3:	MOV	A,B	;BLOCK TOO SHORT--MOVE TO NEXT BLOCK
	BR	DYAL1
DYAL4:	BNE	DYAL5	;BLOCK LONG ENOUGH--IF FILLED EXACTLY
	MOV	2(A),2(B)	;REMOVE BLOCK FROM LIST BY CHANGING POINTERS
DYAL5:	CMP	F,#2	;DONT LEAVE A BLOCK OF LENGTH 2 BYTES
	BEQ	DYAL3
	MOV	F,(A)	;NEW LENGTH OF FREE BLOCK
	MOV	2(B),C	;RESET ROVING POINTER
	BNE	DYAL6	;DONT SET IT TO O
	MOV	DYB,C
DYAL6:	MOV	C,DYR	
	ADD	F,A	;START STORING AT THIS ADDRESS
	BR	DYAL9
DYAL7:	MOV	DYB,A	;ADD NEW BLOCK TO BOTTOM OF LIST
	MOV	2(A),F	;POINTER TO 2ND FREE BLOCK
	SUB	E,A
	CMP	A,STT
	BHI	DYAL8	;THERE IS ENOUGH ROOM IN THE DY AREA
	SEZ
	RTS	PC	;NOT ENOUGH ROOM
DYAL8:	MOV	A,DYB	;NEW BOTTOM OF DY
	MOV	A,DYR	;FIX ROVING POINTER
	MOV	DYB,C	;SET UP NEW LIST BOTTOM
	CLR	(A)+
	MOV	F,(A)+
DYAL9:	SUB	#6,E	;RESTORE LENGTH


;NOW A CONTAINS ADDRESS OF FREE BLOCK
;E CONTAINS NUMBER OF BYTES TO BE TRANSFERRED
;NOW FINALLY YOU GET TO DO THE TRANSFER
;WHILE YOU DO IT, INCREMENT THE REF COUNTER OF ANY PUSHJ'S
DYXFR1:	MOV	#100000,C	;THE CODE FOR DISPLAY PUSHJ
	MOV	#140000,B	;NEXT HIGHER DISPLAY COMMAND
	SPUSH	A	;SAVE POINTER TO DEPTH COUNTER
	CLR	(A)+	;DEPTH_0
	CLR	(A)+	;SET REFERENCE COUNTER TO ZERO
	ASR	E	;E/2 = NUMBER OF WORDS TO BE TRANSFERRED
;PICK UP A WORD.  SEE IF ITS A PUSHJ. AND TRANSFER IT
DYXFR2:	DEC	E	;NUMBER OF WORDS TO BE XFRED
	BLT	DYXFR3
	MOV	(D)+,F	;WORD OF DCODE IN F
	MOV	F,(A)+	;PUT THIS WORD IN ITS NEW PLACE
	CMP	F,C
	BLO	DYXFR2	;NOT A PUSHJ
	CMP	F,B
	BHIS	DYXFR2	;NOT A PUSHJ
;IT IS A PUSHJ
	MAKEAD	F
	INC	-(F)	;INCREMENT THE REF COUNTER
	CMP	-(F),@(SP)	;DEPTH _ MAX (DEPTH OF SUB SNAPS)
	BLE	DYXFR2
	MOV	(F),@(SP)	;DEPTH OF SUB SNAP BIGGEST YET
	BR	DYXFR2	;LOOP BACK

;ALL TRANSFERRING DONE.  END THE BLOCK WITH A POPJ
DYXFR3:	MOV	#DPOPJ,(A)
	SPOP	D	;POINTER TO DEPTH COUNTER
	INC	(D)+
	TST	(D)+	;POINTER TO FIRST D.WORD OF SNAP
	CLZ
	RTS PC	;AND RETURN

;THERE WAS NOTHING TO BE MOVED
DYRET:	CLR	D	;TO SIGNAL THIS FACT
	CLZ
	RTS PC

;DYFREE
;	CALLED DURING GARBAGE COLLECTIONS
;	CALL WITH D POINTING TO REF COUNTER (WORD BEFORE SNAP)
;	FREES THE BLOCK!!
DYFREE:	PUSH	A	;SAVE REGISTERS
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	MOV	#100000,A
	MOV	#140000,B
	MOV	#DPOPJ,C
	JSR	PC,DYF1	;DOES THE FREEING
	JMP	RETF	;RESTORE AC'S AND RETURN TO OUT OF DYFREE

;REAL WORK OF FREEING STARTS HERE.
DYF1:	MOV	D,-(SP)	;SAVE PTR TO 2ND WORD OF BLOCK
	TST	(D)+	;POINT D TO FIRST WORD

;PICK UP EACH WORD OF BLOCK.  IF IT IS A PUSHJ, FREE THAT BLOCK
;CONTINUE UNTIL A POPJ IS REACHED
DYF11:	MOV	(D)+,F	;NEXT WORD
	CMP	F,A
	BLO	DYF11	;NOT PUSHJ OR POPJ
	CMP	F,B
	BHIS	DYF2	;NOT PUSHJ, BUT MAY BE POPJ

;	ITS A PUSHJ
	MAKEAD	F
	DEC	-(F)	;REF COUNTER
	BR DYF11	;LOOK AT NEXT WORD

;IS THE WORD A POPJ
DYF2:	CMP	F,C	;C CONTAINS A POPJ
	BNE	DYF11	;NOT A POPJ.  LOOK AT NEXT WORD
	SPOP	C	;POINTER TO 2ND WORD OF BLOCK
	TST	-(C)	;NOW IT POINTS TO BOTTOM WORD
	SUB	C,D	;LENGTH OF BLOCK
	MOV	D,F


;NOW LINK BLOCK BACK TO FREE CORE
;C/ADDRESS OF BLOCK TO BE LIBERATED
;F CONTAINS LENGTH OF BLOCK

DYLIB:	MOV	DYB,B	;INITIALIZE POINTER TO BOTTOM OF LIST
DYLIB1:	MOV	2(B),A	;NEXT FREE BLOCK
	BEQ	DYLIB3	;AT END OF LIST
	CMP	A,C
	BHI	DYLIB2	;PASSED BLOCK TO BE FREED
	MOV	A,B	;TRY NEXT FREE BLOCK
	BR	DYLIB1
DYLIB2:	MOV	F,D	;CHECK UPPER BOUND
	ADD	C,D	;DO WE COLLAPSE NEW BLOCK WITH NEXT ONE?
	CMP	D,A
	BNE	DYLIB3	;NO
	ADD	(A),F	;YES--NEW LENGTH
	MOV	2(A),2(C)	;NEW POINTER
	CMP	A,DYR	;DID WE JUST SCREW ROVING POINTER?
	BNE	DYLIB4
	MOV	DYB,DYR	;YES--RESET IT
	BR DYLIB4
DYLIB3:	MOV	A,2(C)	;POINTER TO NEXT FREE BLOCK--NO COLLAPSE ON TOP
DYLIB4:	MOV	(B),D	;CHECK LOWER BOUND
	ADD	B,D
	CMP	D,C	;DO WE COLLAPSE WITH BLOCK ON BOTTOM?
	BNE	DYLIB5	;NO
	ADD	F,(B)	;NEW LENGTH OF PREVIOUS BLOCK
	MOV	2(C),2(B)	;NEW POINTER
	BR	DYLIB6
DYLIB5:	MOV	C,2(B)	;POINTER IN PREVIOUS BLOCK--NO COLLAPSE
	MOV	F,(C)	;LENGTH OF BLOCK JUST FREED
DYLIB6:	MOV	C,A	;DID WE JUST FREE BOTTOM BLOCK IN DY?
	SUB	#4,A
	CMP	A,DYB	;NOTE THAT IF CURRENT BLOCK = DYB+4
			;THEN PREVIOUS BLOCK (ADDR IN B) MUST BE DYB
	BNE	DYLIB7	;NO
	ADD	(C),B	;YES--COLLAPSE DY AREA
	CLR	(B)
	MOV	2(C),2(B)	;NEW BOTTOM BLOCK
	MOV	B,DYB
	MOV	B,DYR	;FIX POINTERS
DYLIB7:	RTS	PC


;DSGCF
;	CALLED BY LOGO GARBAGE COLLECTOR WHEN ITS ALL DONE
;	SEE IF EACH SNAP ON THE SNAP LIST WAS MARKED.
;	AND DYFREE THE SNAP IF NOT MARKED AND IT'S REFERENCE COUNTER IS 0

DSGCF:	CLR	F
	BR	DSGC1

DSGC4:	TST	F	;0 IF FIRST TIME THROUGH
	BEQ	DSGC5

;
;CODE FROM DSGC8 - DSGC9 GETS CALLED BY DCHK TO COMPRESS DISPLAY AREA
;
DSGC8:	MOV	STB,A	;COMPRESS ADDX'S AND ADDY'S IN STATIC AREA
	MOV	SNABOT,B	;FIRST DO PART BELOW SNAP BOTTOM
	JSR	PC,ADDSHK
	MOV	C,SNABOT	;C IS NEXT LOCATION TO STORE INTO
	MOV	STT,B	;NOW DO PART ABOVE SNAP BOTTOM
	JSR	PC,ADHK0	;DON'T RECLOBBER C.
	MOV	(A),(C)	;STORE PUSHJ TURTLE, TOO
	MOV	C,STT
	CLR	NADXY

DSGC9:	RTS	PC
DSGC5:	MOV	#<DSGC6-DSGCF1>,F	;NOW CLEAR MARKED BITS
DSGC1:	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BEQ	DSGC8	;OBVIOUSLY DOESN'T HAVE SNAPS

	JSR	PC,.LOADC	;FIRST NODE OF LIST IS DUMMY
DSGC2:	MOV	C,E	;SAVE POINTER TO NODE
DSGC3:	BIT	#7777,A	;LEAVE ADDRESS ONLY
	BEQ	DSGC4	;END OF LIST
	MOV	A,C	;POINTER TO NEXT NODE
	JSR	PC,.LOADC
	ADD	F,PC	;CHOOSE BETWEEN FREEING AND CLEARING

;TRY TO FREE THE SNAP
DSGCF1:	TST	-(B)	;WAS SNAP MARKED?  (B POINTS TO REF COUNT)
	BNE	DSGC2	;EITHER DISPLAYED OR MARKED

;NOT MARKED, AND NOT DISPLAYED ANYWHERE!!
;FREE THIS SNAP
	JSR	PC,.FREE	;CLEAN UP SNLIST
	MOV	E,C	;POINTER TO PREVIOUS NODE OF SNLIST
	JSR	PC,.STP1	;STORE A AS TOP WORD OF PREVIOUS NODE
	MOV	B,D	;POINTER TO SNAP DCODE
	JSR	PC,DYFREE
	BR	DSGC3

DSGC6:	BIC	#100000,-(B)	;CLEAR MARKED BIT
	BR	DSGC3

;ADDS HACK
;	COMPRESS ADDX'S AND ADDY'S STARTING AT LOCATION IN A
;	AND GOING TO LOCATION IN B. (DOESN'T STORE WORD AT LOC IN B)
ADDSHK:	MOV	A,C	;C IS NEXT LOC TO STORE INTO.
ADHK0:	CLR	-(SP)	;FLAG. (NOT IN MIDDLE OF ADD'S)
ADHK1:	CMP	A,B	;ARE WE DONE?
	BHIS	ADFIN	;YES
	MOV	(A)+,D	;NEXT WORD
	CMP	D,#ADDY
	BLO	ADNOT	;NOT AN ADD
	TST	(SP)	;IN MIDDLE OF ADD'S ALREADY ?
	BNE	ADPHS1	;YES
	CLR	E	;NO. THIS IS FIRST ADD
	CLR	F
	INC	(SP)	;SET FLAG
ADPHS1:	CMP	D,#ADDX	;THE BIGGER ADD COMMAND
	BHIS	ADPHSX
;IT IS AN ADDY
	ADD	D,F	;ADD THE DELTA-Y INTO F
	BR	ADHK1	;LOOP BACK
ADPHSX:	ADD	D,E	;ADD THE DELTA-X INTO E
	BR	ADHK1

ADNOT:	TST	(SP)
	BEQ	ADHK2	;NOT END OF ADD'S
	JSR	PC,ADPHSF	;JUST ENDED ADDS.
	CLR	(SP)
ADHK2:	MOV	D,(C)+	;STORE THIS WORD
	BR	ADHK1

ADFIN:	TST	(SP)+	;ALL WORDS PICKED UP
	BEQ	ADHK3
	JSR	PC,ADPHSF	;BUT FIRST FINISH ADDS
ADHK3:	RTS	PC

;ADD PHASE FINISHED.  STORE ADDX E, ADDY F.
ADPHSF:	BIC	#176000,E
	BIC	#176000,F
	BEQ	ADPF1	;DELTA-Y = 0
	BIS	#ADDY,F
	MOV	F,(C)+	;STORE ADDY
ADPF1:	TST	E
	BEQ	ADPF9	;DELTA-X = 0
	BIS	#ADDX,E
	MOV	E,(C)+	;STORE ADDX
ADPF9:	RTS	PC


;MKDC
;	CALLED BY LOGO GARBAGE COLLECTOR DURING MARKING PHASE
;	CALLED WITH B POINTING TO SNAP NODE
MKDC:	TST	SNLIST	;CALLED TO KILL THE DISPLAY?
	BEQ	MKDC.K	;YES
	BIT	#7777,B
	BEQ DSGC9	;EMPTY SNAP
;MARK THE SNAP
	PUSH	A
	SPUSH	B
	JSR	PC,.LOAD	;POINT B TO NODE CONTAINING SNAP ADDR
	TST B
	BEQ MKDC1
	JSR	PC,.LOAD	;B_SNAP ADDRESS
	BIS	#100000,-(B)	;MARK REF COUNTER
MKDC1:	SPOP	B	;RESTORE A AND B
	SPOP	A
	RTS	PC

;CALLED BY KILLDISPLAY
;TURN SNAP INTO EMPTY SNAP
MKDC.K:	SPUSH	A
	SPUSH	B
	SPUSH	C
	MOV	B,C	;POINTER TO DCODE NODE
	CLR	A
	JSR	PC,.STP2
	JMP	RETC



;HERE START THE LINE AND TURTLE DRAWING PROGRAMS

;DR.LIN
;	DRAW A LINE. D=DX, E=DY, OR VICE VERSA.
;	THE DIRECTION CODE FOR THE LINE IS IN DIREC
DR.LIN:	CMP DIREC,ODIREC
	BEQ .+6
	CLR DFBCNT
	JSR	PC,DR.STUP	;SET A=CON, B=AC.
	SPUSH	D
	ADD	STT,D	;D = HOW MANY MORE WORDS IN DLIST
	CMP	D,DYB	;COMPARE TO DY BOTTOM
	BLO	DR.L1	;THERE'S ROOM
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	SPOP	D	;TRY TO FIT LINE AGAIN
	ADD	STT,D
	CMP	D,DYB
	BLO	DR.L2	;THERE'S ROOM!
	ERROR+TML	;TOO MANY LINES

;OKAY, THERE WAS ROOM FOR THE LINE
DR.L1:	TST	(SP)+	;WE HAD PUSHED D UP ABOVE
DR.L2:	MOV	D,STT	;SET STT TO NEW STATIC TOP
	MOV	PUSHJT,(D)	;PUT PUSHJ TURTLE AT TOP
	JSR	PC,DR.ASC	;ASSEMBLE THE DISPLAY CODE
	MOV DIREC,ODIREC
	RTS	PC	;RETURN


;DRAW THE TURTLE
DR.TUR:	PUSH DIREC
	SPUSH DFBCNT
	MOV	#TURSIZ,C	;TURTLE SIZE
.IFZ FPPF
	CLR	B
	JSR	PC,MULCOS	;E,,F _ SIZE * COSA
	ROL	F
	ADC	E	;ROUND
	MOV	E,D
	JSR	PC,MULSIN	;E,,F _ SIZE * SINA
	ROL	F
	ADC	E	;ROUNFD
.IFF
	SETI
	LDCIF C,FA
	SETL
.IIF NZ DDF,	LDCFD DSINA,FB
.IIF Z DDF,	LDCFD SINA,FB
	MULF FA,FB
	ADDF #40000,FB	;ROUND
.IIF NZ DDF,	LDCFD DCOSA,FC
.IIF Z DDF,	LDCFD COSA,FC
	MULF FA,FC
	ADDF #40000,FC
	SETI
	STCFI FB,E
	STCFI FC,D
	SETL
.ENDC

	SPUSH	D
	SPUSH	D
	SUB	E,2(SP)	;NOW SIZE * (COSA - SINA) IS ON STACK
	ADD	E,(SP)	;NOW SIZE * (COSA + SINA) IS ON STACK

	MOV	TUB,TUT	;TUT WILL BE POINTER TO TOP OF TURTLE DLIST SO FAR

;SIDE 1
	ADD	#20,DIREC	;SIDE 1 IS 2*45 DEGREES LEFT OF CURRENT DIRECTION
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 2
	SUB	#30,DIREC	;SIDE 2 IS 3*45 DEGREES RIGHT OF SIDE 1
	MOV	(SP)+,D	;DX IS SIZE * (COSA + SINA)
	MOV	(SP)+,E	;DY IS SIZE * (COSA - SINA)
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 3 HAS THE SAME INCREMENTS AS SIDE 2.
;JUST THE DIRECTION IS DIFFERENT
	MOV	DIREC,B
	SUB	#20,B	;SIDE 3 IS 2*45 DEGREES RIGHT
	BIC	#177707,B	;LEAVE ONLY THE 3 BITS
	SWAB	B	;PUT THE DIREC BITS IN TOP BYTE
	MOV	TUT,C	;POINTS TO WORD ABOVE LAST ONE OF TURTLE DLIST
	MOV	C,A
	SUB	D,C	;SINCE D POINTS TO BOTTOM WORD OF SIDE 2
			;C-D IS NUMBER OF BYTES IN SIDE 2'S DLIST
	ASR	C	;C/2 = NUMBER OF WORDS
DR.TS3:	MOV	(D)+,E	;NEXT WORD OF SIDE 2'S DLIST
	BIC	#34000,E	;CLEAR THE DIRECTION BITS THEREIN
	BIS	B,E	;AND SET THEM FROM THE NEW DIREC IN B
	MOV	E,(A)+	;STORE IN DLIST
	DEC	C	;NUMBER OF WORDS IN SIDE 2'S DLIST
	BGT	DR.TS3	;THERE ARE MORE WORDS

;SIDE 4 IS IDENTICAL TO SIDE 1
;FURTHERMORE, SIDE 1 IS MADE UP OF ONLY ONE WORD
	MOV	@TUB,(A)+	;PUT THE FIRST WORD OF TURTLE INTO TOP WORD
	MOV	#DSTOP!DPOP,(A)

;RESTORE DIREC, THEN RETURN
	SPOP DFBCNT
	POP DIREC
	RTS	PC


;DRAW TURTLE SIDE
;	DRAW ONE SIDE OF THE TURTLE
;	DIREC CONTAINS THE DIRECTION
;	TUT POINTS TO TOP OF TURTLE DISPLAY LIST SO FAR
;	C,D = + OR - DX OR DY
DR.TSD:	BIC	#177707,DIREC	;BITS MAY HAVE BEEN SET BY THE SUBTRACTING
	CLR DFBCNT
	JSR	PC,DR.STUP
	ADD	TUT,D	;D = NEW TOP OF TURTLE
	MOV	D,TUT
	JMP	DR.ASC	;ACTUALLY CREAT THE DISPLAY LIST


;SET UP CON AND AC
;	CALL WITH D,E = + OR - DX OR DY
;	PASSES ON A=FRACTION: MIN (DX/DY,DY/DX)
;		B=ACCUMULATED FRACTION PART SIDEWAYS OF MAIN DIRECT.
;		STARTS AT 1/2
DR.STUP:	TST	D
	BGE	DR.TE	;TEST E
	NEG	D	;MAKE D POSITIVE
;MAKE SURE E IS POSITIVE
DR.TE:	TST	E
	BGE	DR.BIG	;NEXT WE'LL SEE WHICH IS BIGGER
	NEG	E	;MAKE D POSITIVE

;WHICH IS BIGGER
DR.BIG:
	CLR B		;CLEAR LOW WORD OF WHICHEVER NUMBER
	CMP	D,E
	BGT	DR.DBG	;D IS BIGGER
	BEQ	DR.EQ	;THEY ARE THE SAME SIZE

;OTHERWISE, E IS BIGGER
	ASL	E	;SO EAE WON'T OVERFLOW WITH A 16 BIT QUOTIENT
	MOV D,A		;DIVIDE D,,0 BY E
	DIV E,A
	MOV	E,F	;WHICHEVER IS BIGGER IS THE NUMBER OF INCS
	BR	DR.SC4

;THEY ARE THE SAME SIZE
DR.EQ:	MOV	#-1,A	;SET CON = .777...
	MOV	E,F	;NUMBER OF INCS
	BR	DR.SC5

;D IS BIGGER
DR.DBG:	ASL D
	MOV E,A		;DIVIDE E,,0 BY D
	DIV D,A
	MOV	D,F	;NUMBER OF INCS

;NOW PICK UP THE QUOTIENT
DR.SC4:
	ASL	A	;MAKE QUOTIENT 16 BITS
	ASR	F	;SINCE WE DOUBLED IT ABOVE

;NOW SET AC = .1000 = 1/2 IN THIS REPRESENTATION
DR.SC5:	MOV	#100000,B
;FALLS IN!

;CALCULATE THE NEW END POINT OF THE DLIST
;	RETURNS A AND B AS ABOVE
;	C = BIT-POSITION OF LAST BIT OF NEW CODE
;	  (GENERATED BACKWARDS--STORE FROM HERE BACK)
;	D = NUMBER OF MORE WORDS IN DLIST
;	  (WILL BECOME ADDR OF LAST NEW WORD + 2)
;	E = TOP BYTE OF INCR INSTRUCTION, SWAPPED
;	F = # NEW INCREMENTS
DR.NEP:	CLR C		;CLEAR BIT-POSITION
	MOV F,E		;GET # OF INCREMENTS
	SUB DFBCNT,E	;LESS # LEFT OVER
	MOV E,D
	ASH #-3,D	;DIVIDE BY 8
	ASL D
	BIC #177770,E	;REMAINDER IS # BITS IN LAST WORD
	BEQ DR.NE2	;IF 0 THEN = 8 IN PREVIOUS WORD

	MOV #8.,DFBCNT	;ELSE FREE BITS = 8 - # USED
	SUB E,DFBCNT
	TST (D)+	;ADD ONE-WORD FUDGE FACTOR IN THIS CASE
	SPUSH E
	SEC
DR.NE1:	RORB C		;SHIFT FIRST-BIT IN OR RIGHT ONE BIT
	DEC E		;SHIFT IT RIGHT (REMAINDER) PLACES
	BNE DR.NE1
	SPOP E
	BR DR.NE3

;REMAINDER WAS 0:  LAST WORD GETS FILLED UP
DR.NE2:	INC C		;LAST BIT IS LAST IN WORD
	CLR DFBCNT	;NO FREE BITS

DR.NE3:	ADD #DINC_-8,E	;PUT IN "INCREMENT" CODE
	ADD	DIREC,E	;ADD IN THE DIRECTION
	RTS	PC


;ACTUALLY ASSEMBLE THE NEW DISPLAY LIST
;	CALL WITH A=SIDEWAYS/FORWARD, B=1/2 (ACCUM SIDEWAYS),
;	C=FIRST BIT POS., D=POINTER  TO FIRST WORD TO STORE OF DLIST
;	E=TOP HALF OF THE INC MODE INSTRUCTION, F=NUMBER OF INCS
DR.ASC:	SWAB	E	;STUFF IN E WAS IN WRONG HALF
DR.AS0:	ADD	A,B	;CON+AC
	BCC	DR.AS1
	ADD	C,E	;CARRY, SO PUT A 1 INTO DCODE
DR.AS1:	DEC	F	;NUMBER OF INCS
	BLE	DR.ALW	;THIS WAS THE LAST WORD
	CLC
	ROLB	C	;SHIFT BYCNT
	BCC	DR.AS0	;CONTINUE WITH THIS WORD

;THIS WORD DONE
	JSR	PC,DR.SH
	MOV	E,-(D)	;STORE IN DLIST
	BIC	#3777,E	;0 THE COUNT AND BOTTOM BYTE
	MOV	#1,C	;RESET BYCNT
	BR	DR.AS0

;ALL THAT'S LEFT TO DO IS STORE THE BOTTOM WORD OF NEW DLIST
DR.ALW:	MOV -(D),B	;GET WORD TO HOOK
	CLR A		;SET UP BIT TO HOOK FROM
	SEC		;  "
DR.LW1:	ROL A		;  "  OR NEXT BIT TO HOOK FROM
	CLC
	ROLB C		;NEXT BIT TO HOOK INTO
	BCS DR.LW2	;DONE HOOKING
	BIT A,B		;GET BIT
	BEQ DR.LWX
	ADD C,E		;STORE IT
DR.LWX:	CLC		;SET UP FOR ROL A
	BR DR.LW1

DR.LW2:	JSR	PC,DR.SH	;SHOVE TO RIGHT END OF WORD
	MOV	E,(D)	;STORE LAST WORD
	RTS	PC

;SHIFT CODE RIGHT 8 MINUS COUNT TIMES

DR.SH:	PUSH	E
	SWAB E		;GET COUNT OF USED BITS
DR.SH1:	BIC #177770,E	;ISOLATE COUNT
	BEQ	DR.SH2	;DONE
	INC E		;COUNT UP; DONE AT 8 (OR 0)
	CLC
	RORB	(SP)	;MAKE ANOTHER FREE BIT AT LEFT
	BR	DR.SH1
DR.SH2:	POP	E
	RTS	PC

.ENDC

.IFNZ TVS
.SBTTL TV TURTLE ROUTINES
;;;;;;;;;;;;;;;;;;;;
;TV TURTLE ROUTINTES
;;;;;;;;;;;;;;;;;;;;

;THESE ROUTINES ARE USED TO PROCESS DISPLAY GRAPHICS FOR TVS.
;THE ROUTINES ARE IN MANY CASES BASED ON, AND TRY TO FOLLOW THE
;WORK OF HENRY LIEBERMAN WITH HIS TVRTLE ROUTINES FOR LLOGO.

TVSTRT:	JSR PC,TVINIT		;CREATE DISPLAY
	MOV TVBOT,B		;EVERYTHING BELOW DISPLAY AREA CAN BE ECHO AREA
	JSR PC,CRECHO		;CREATE THE ECHO AREA IN SCREEN
	JSR PC,TVCS		;CLEAR SCREEN, RESET TURTLE
	SEZ
	RTS PC


;CREATE A DISPLAY CAPABILITY AND INITIALIZE VARIABLES
TVINIT:	SAVE <#-1,TYOCP>
	BIS #140000,(P)
	SAVE #0+.DSCAP*400	;0 IS CREATE CAPABILITY
	$INVOK
	REST <DISCAP,A,B>	;CREATE THE DISPLAY CAP
	BIC #<PLOTF!HIDETF!TURTF!PENUF!WRAPF>,DFLAGS	;ZERO THE FLAGS
	CLR DPENP		;START WITH PENDOWN
	BIS #DISPF!TVF,DFLAGS	;WE ARE CONTROLING DISPLAY AND IT IS A TV DISPLAY
	BIS #DISPF,DIVOWN	;WE OWN A DISPLAY
	MOV #.TVDSI,DRAWMD	;INITIALLY PENDOWN => IOR MODE ON DISPLAY
	MOV #DORBEG,A
TVINI1:	CLR (A)+		;CLEAR OUT THIS AREA
	CMP A,#DOREND
	BLO TVINI1
	MOV #2.,TVTOP		;TOP OF DISPLAY AREA IS TV LINE 2
	MOV #302.,TVBOT		;BOTTOM OF DISPLAY AREA IS TV LINE 302
	MOV #138.,TVLEFT	;LEFT SIDE OF DISPLAY AREA IS LINE 138
	MOV #438.,TVRIGHT	;RIGHT SIDE OF DISPLAY AREA IS LINE 438
	MOV #301.,TVSIZY	;Y SIZE IS 300.
	MOV #301.,TVSIZX	;X SIZE IS 300.
	MOV #152.,TVCENY	;Y CENTER IS 152.
	MOV #288.,TVCENX	;X CENTER IS 288.
	MOV #301.,TVMIN		;SIZE OF TV PICTURE
	MOV #400.,TRMIN		;TURTLE PICTURE SIZE
	CLR TRCENX		;TURTLE PICTURE CENTER X
	CLR TRCENY		;TURTLE PICTURE CENTER Y
	MOV TVCENX,TVX
	MOV TVCENY,TVY		;THE DRAWER SHOULD GO INTO THE CENTER OF BOX
	SAVE <TVX,TVY,DISCAP>
	BIS #.TVDSS*400,(P)	;SET THE DRAWER TO THE RIGHT PLACE
	$INVOK
	SETF
	SETI			;THE FOLLOWING STUFF IS IN SHORT INTEGER AND FLOAT MODE
	LDCIF TRMIN,FA
	LDCIF TVMIN,FB
	SUBF FLTTOL,FB
	SUBF FLTTOL,FB
	DIVF FB,FA
	STF FA,TRPRTV		;TURTLE PER TV = TRMIN / (TVMIN - FLOAT TOLERANCE * 2)
	LDCIF #15.,FA
	MULF TRPRTV,FA
	STF FA,TRFRAD		;TURTLE FRONT RADIUS
	LDCIF #10.,FA
	MULF TRPRTV,FA
	STF FA,TRSRAD		;TURTLE SIDE RADIUS
	LDCIF #400.,FA
	STF FA,TRSIZX		;TURTLE PICTURE X SIZE
	STF FA,TRSIZY		;TURTLE PICTURE Y SIZE
	LDCIF #-200.,FA
	STF FA,TRLEFT		;TURTLE PICTURE LEFT BOUNDRY
	STF FA,TRBOT		;TURTLE PICTURE BOTTOM BOUNDRY
	RTS PC

;TVCHK CHECKS IF MY TTY IS A TV. IT CLEARS Z IF IT IS, SETS Z OTHERWISE.
;ALSO SETS THE TV FLAG IN DFLAGS.
TVCHK:	SAVE <,,TYOCP>
	BIS #.TTTYP*400,(P)	;GET FLAGS FROM TTY TABLE
	$INVOK
	BIT #200,(P)+		;BIT 200 IS THE TV FLAG
	BEQ TVCHK1		;IS NOT A TV
	BIS #TVF,DFLAGS		;YES IT IS!
TVCHK1:	RTS PC

;CREATE AN ECHO AREA WITH SIZE BASED ON FONT. EXPECTS THE TV LINE OF THE TOP
;OF THE ECHO AREA IN B
CRECHO:	SAVE <,#.TSCRL,TYOCP>
	BIS #.TTBS2*400,(P)	;GO INTO SCROLL MODE FOR NOW
	$INVOK
	SAVE <,,TYOCP>
	BIS #.TVCL*400,(P)	;SO WE CAN RESET THE SCREEN
	$INVOK			;AND DO A REAL CLEAR
	SAVE <,#.TSCRL,TYOCP>
	TST B			;DOES HE REALLY WANT AN ECHO AREA?
	BNE CRECH1
	BIS #.TTBS2*400,(P)	;NO, SET THE SCROLL MODE BIT
	BR CRECH2
CRECH1:	BIS #.TTBC2*400,(P)	;YES, CLEAR THE SCROLL MODE BIT TO USE WRAP MODE
CRECH2:	$INVOK
	SAVE <,,TYOCP>
	BIS #.TVRFN*400,(P)	;READ THE NUMBER OF TV LINES PER CHAR LINE
	$INVOK			;AND THE WIDTH OF CHAR IN BITS
	REST <TVHIGH,TVWIDE>
	CLR A			;FOR THE DIVIDE
	DIV TVHIGH,A		;DIVIDE BY NUBER OF TV LINES PER CHAR LINE
	TST B			;ANY REMAINDER?
	BEQ .+4			;COUNT IT AS ONE MORE LINE
	INC A
	SAVE <,A,TYOCP>
	BIS #<.TVOFF+.PRWRT>*400,(P)	;SET THE OFFSET TO SET THE ECHO AREA
	$INVOK			;THIS WILL CLEAR SCREEN AND THUS SET CURSOR
	MUL TVHIGH,A
	MOV B,TVSIZE		;THE DISPLAY AREA HAS THIS MANY LINES
	RTS PC

TVCS:	SETF
	SETI
	LDCIF TRCENX,FA
	STF FA,DCURX		;RESET DCURX
	LDCIF TRCENY,FA
	STF FA,DCURY		;RESET DCURY
	CLR DCURA		;RESET DCURA
	CLRF FA
	STF FA,DSINA		;RESET DSINA
	LDCIF #1,FA
	STF FA,DCOSA		;RESET DCOSA
	MOV TVCENX,TVX
	MOV TVCENY,TVY		;SO THE DRAWER WILL GO BACK TO CENTER OF SCREEN
	JSR PC,TVWC		;CLEAR SCREEN AREA, DRAW OUTLINE AND RESET DRAWER
	RTS PC

TVWC:	SAVE <#0,#0,DISCAP>
	BIS #.TVDSS*400,(P)	;SET THE TV DRAWER TO TOP LEFT OF DISPLAY
	$INVOK
	SAVE <#575.,TVSIZE,DISCAP>
	BIS #.TVDSC*400,(P)	;CLEAR THE AREA OF DISPLAY
	$INVOK			;THIS LEAVES DRAWER AT BOTTOM RIGHT
	SAVE <TVLEFT,TVTOP,DISCAP>
	BIS #.TVDSS*400,(P)	;SET THE CURSOR TO TOP LEFT
	$INVOK
	SAVE <TVSIZX,#0,DISCAP>	;X WIDTH OF SCREEN, NO DELTA Y
	BIS #.TVDSI*400,(P)	;DRAW THE TOP LINE
	$INVOK
	SAVE <#0,TVSIZY,DISCAP>	;NO DELTA X, SCREEN HEIGHT IS DELTA Y
	BIS #.TVDSI*400,(P)	;DRAW THE RIGHT SIDE
	$INVOK
	SAVE TVSIZX		;X WIDTH OF SCREEN
	NEG (P)			;TO GO BACK
	SAVE <#0,DISCAP>	;NO DELTA Y
	BIS #.TVDSI*400,(P)	;DRAW THE BOTTOM LINE
	$INVOK
	SAVE <#0,TVSIZY>	;NO DELTA X, THE SCREEN HEIGHT AS DELTA Y
	NEG (P)			;TO GO UP THE SCREEN
	SAVE DISCAP
	BIS #.TVDSI*400,(P)	;DRAW THE LEFT SIDE
	$INVOK


	SAVE <TVX,TVY,DISCAP>
	BIS #.TVDSS*400,(P)	;RESET THE DRAWER TO ITS OLD POSITION
	$INVOK
	BIT #HIDETF,DFLAGS	;ARE WE SHOWING THE TURTLE
	BNE TVWC1		;NO
	JSR PC,TVTUR		;DRAW THE TURTLE
TVWC1:	SEZ
	RTS PC


TVSHOW:	BIT #HIDETF,DFLAGS	;IS THE TURTLE ALREADY BEING SHOWN?
	BEQ TVSHO1		;YES
	BIC #HIDETF,DFLAGS	;NO, SAY THAT IT IS NOW
	JSR PC,TVTUR		;DRAW IT IN
TVSHO1:	SEZ
	RTS PC

TVHIDE:	BIT #HIDETF,DFLAGS	;IS THE TURTLE BEING SHOWN NOW?
	BNE TVHID1		;NO
	BIS #HIDETF,DFLAGS	;YES, BUT NOT AFTER THIS
	JSR PC,TVTUR		;XOR IT OUT
TVHID1:	SEZ
	RTS PC

TVTUR:	SAVE DRAWMD
	MOV #.TVDSX,DRAWMD	;DRAWMODE IS XOR TO XOR THE TURTLE
	JSR PC,TRIANG		;DRAW THE TRIANGLE OF TURTLE
	REST DRAWMD
	RTS PC

TRIANG:	SETF
	SETI			;THE FOLLOWING STUFF IS DONE IN SHORT, FLOAT MODE
	LDF DCURX,FA
	LDF DCURY,FB		;LOAD UP CURRENT X AND Y
	LDF TRFRAD,FC		;TURTLE FRONT RADIUS
	STF FC,FD		;COPY THE RADIUS
	MULF DSINA,FC		;FONT LINE X IS FRONT RADIUS * SIN A
	MULF DCOSA,FD		;FONT LINE Y IS FRONT RADIUS * COS A
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE THIS POINT LESS RELATIVE
	JSR PC,WRPVEC		;DRAW AS WRAP VECTOR
	STF FC,-(P)		;SAVE THIS POINT
	STF FD,-(P)
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF TRSRAD,FC		;TURTLE SIDE RADIUS
	STF FC,-(P)		;SAVE IT ON STACK
	LDF DSINA,FD
	MULF SIN120,FD
	STF FD,-(P)
	LDF DCOSA,FD
	MULF COS120,FD
	ADDF (P)+,FD		;Y = SIN A * SIN 120 + COS A * COS 120
	MULF (P),FD		;Y = TURTLE SIDE RADIUS * Y
	LDF DCOSA,FC
	MULF SIN120,FC
	STF FC,-(P)
	LDF DSINA,FC
	MULF COS120,FC
	SUBF (P)+,FC		;X = SIN A * COS 120 - COS A * SIN 120
	MULF (P),FC		;X = TURTLE SIDE RADIUS * X
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE LESS RELATIVE
	JSR PC,WRPVEC		;DRAW THE RIGHT SIDE OF TURTLE
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF DSINA,FD
	MULF SIN240,FD
	STF FD,-(P)
	LDF DCOSA,FD
	MULF COS240,FD
	ADDF (P)+,FD		;Y = COS A * COS 240 + SIN A * SIN 240
	MULF (P),FD		;Y = TURTLE SIDE RADIUS * Y
	LDF DCOSA,FC
	MULF SIN240,FC
	STF FC,-(P)
	LDF DSINA,FC
	MULF COS240,FC
	SUBF (P)+,FC		;X = SIN A * COS 240 - COS A * SIN 240
	MULF (P)+,FC		;X = TURTLE SIDE RADIUS * X
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE LESS RELATIVE
	JSR PC,WRPVEC		;DRAW THE BOTTOM OF TURTLE
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF (P)+,FD		;Y FROM FRONT LINE
	LDF (P)+,FC		;X FROM FRONT LINE
	JSR PC,WRPVEC		;DRAW THE LEFT SIDE OF THE TURTLE
	RTS PC

;VECTOR DRAW LINES ON THE SCREEN. IT EXPECTS:
;FROM X IN FA
;FROM Y IN FB
;TO X IN FC
;TO Y IN FD

VECTOR:	SETF			;ALL THE FOLLOWING STUFF IS IN FLOAT MODE
	SETI			;AND IN SHORT INTEGER MODE
	JSR PC,CHKBND		;MAKE SURE TO Y IS IN BOUNDS
	STF FD,-(P)
	STF FC,FD
	JSR PC,CHKBND		;MAKE SURE TO X IS IN BOUNDS
	LDF (P)+,FD
	BIT #HIDETF,DFLAGS	;ARE WE SHOWING THE TURTLE?
	BNE VECTO1		;NO
	JSR F,FACSAV		;SAVE THE REGISTERS
	JSR PC,TVTUR		;THIS CAUSES IT TO GO AWAY
	JSR F,FACRES		;RESTORE THE REGISTERS
VECTO1:	BIT #WRAPF,DFLAGS	;ARE WE IN WRAP MODE?
	BNE VECTO2		;YES
	JSR PC,BNDVEC		;NO DRAW A BOUNDED VECTOR
	BR VECTO3
VECTO2:	JSR PC,WRPVEC		;YES DRAW VECTORS WITH WRAPAROUND
VECTO3:	STF FC,DCURX
	STF FD,DCURY		;THE NEW CURRENT POSITION
	BIT #HIDETF,DFLAGS	;ARE WE SHOWING TURTLE?
	BNE VECTO4		;NO
	JSR PC,TVTUR		;PUT THE TURTLE IN ITS NEW HOME
VECTO4:	SEZ
	RTS PC

;WRPVEC DRAWS VECTORS WITH WRAP AROUND BY SPLITTING THE LINES IN THE VARIOUS
;SCREENS THAT IT CROSSES, AND CALLING BNDVEC TO ACTUALLY DRAW THE LINES ON
;EACH OF THE VIRTUAL SCREENS.  THE SCREEN SPLITTING IS DONE BY CHOPPING OFF
;PIECES OF THE LINE AND CALLING WRPVEC RECURSIVELY.  THIS PROCEDURE IS
;ESSENTIALLY A HAND COMPILATION OF THE PROCEEDURE WRAP-VECTOR IN HENRY
;LIEBERMAN'S TVRTLE, A PART OF LISP LOGO

WRPVEC:	JSR F,FACSAV		;SAVE ALL THE REGISTERS
	STF FA,FE
	SUBF TRLEFT,FA
	DIVF TRSIZX,FA
	TSTF FA
	CFCC
	BGE .+6
	SUBF #40200,FA		;-0.1 SHOULD TRUNCATE TO -1 NOT 0
	STCFI FA,A		;FROM-SCREEN-X=(FROM-X - TR-PIC-LEFT)/ TR-PICT-SIZE
	LDF FE,FA
	STF FC,FE
	SUBF TRLEFT,FC
	DIVF TRSIZX,FC
	TSTF FC
	CFCC
	BGE .+6
	SUBF #40200,FC
	STCFI FC,C		;TO-SCREEN-X=(TO-X - TR-PICT-LEFT)/ TR-PICT-SIZE
	LDF FE,FC
	CMP A,C			;FROM-SCREEN-X = TO-SCREEN-X ?
	BEQ WRPVE2		;YES
	STF FC,-(P)
	STF FD,-(P)		;GET SOME REGISTERS
	SUBF FA,FC		;CHANGE-X = TO-X - FROM-X
	SUBF FB,FD		;CHANGE-Y = TO-Y - FROM-Y
	TSTF FC
	CFCC
	BGE WRPVE1
	MOV #-1,E
	BR .+6
WRPVE1:	MOV #1,E		;IF CHANGE-X >= 0 THEN SIGN-X = 1 ELSE SIGN-X = -1
	DIVF FC,FD
	STF FD,FE		;TAN-HEADING = CHANGE-Y / CHANGE-X
	LDCIF A,FC		;FROM-SCREEN-X
	MULF TRSIZX,FC
	ADDF TRLEFT,FC		;TO-EDGE-X=TR-PIC-SIZE-X*FROM-SCREEN-X + TR-PICT-LEFT
	TST E
	BLT .+6			;IF SIGN-X >= 0
	ADDF TRSIZX,FC		;	THEN ADD TURTLE-PICT-SIZE-X TO TO-EDGE-X
	LDF FC,FD
	SUBF FA,FD
	MULF FE,FD
	ADDF FB,FD		;TO-EDGE-Y=(TO-EDGE-X - FROM-X)*TAN-HEADING + FROM-Y
	STF FC,FE
	LDCIF E,FC
	ADDF FPC0.1,FC
	STF FC,FF		;BACK-OFF-EDGE = SIGN X + 0.1
	LDF FE,FC
	SUBF FF,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	FROM-X
				;		FROM-Y
				;		TO-EDGE-X - BACK-OFF-EDGE
				;		TO-EDGE-Y)
	LDF FE,FA
	ADDF FF,FA
	LDF FD,FB
	LDF (P)+,FD
	LDF (P)+,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	TO-EDGE-X + BACK-OFF-EDGE
				;		TO-EDGE-Y
				;		TO-X
				;		TO-Y)
	JSR F,FACRES
	RTS PC

WRPVE2:	STF FB,FE
	SUBF TRBOT,FB
	DIVF TRSIZY,FB
	TSTF FB
	CFCC
	BGE .+6
	SUBF #40200,FB		;TO MAKE -0.1 TRUNCATE TO -1
	STCFI FB,B		;FROM-SCREEN-Y=(FROM-Y - TR-PICT-BOTTOM) / TR-SIZE-Y
	LDF FE,FB
	STF FD,FE
	SUBF TRBOT,FD
	DIVF TRSIZY,FD
	TSTF FD
	CFCC
	BGE .+6
	SUBF #40200,FD		;TO MAKE -0.1 TRUNCATE TO -1
	STCFI FD,D		;TO-SCREEN-Y=(TO-Y - TR-PICT-BOTTOM) / TR-SIZE-Y
	LDF FE,FD
	CMP B,D			;FROM-SCREEN-Y = TO-SCREEN-Y ?
	BEQ WRPVE4		;YES
	STF FC,-(P)
	STF FD,-(P)		;GET SOME REGISTERS
	SUBF FA,FC		;CHANGE-X = TO-X - FROM-X
	SUBF FB,FD		;CHANGE-Y = TO-Y - FROM-Y
	TSTF FD
	CFCC
	BGE WRPVE3		;IF CHANGE-Y < 0
	MOV #-1,E		;	THEN SIGN-Y = -1
	BR .+6
WRPVE3:	MOV #1,E		;	ELSE SIGN-Y = 1
	DIVF FD,FC
	STF FC,FE		;TAN-HEADING = CHANGE-X / CHANGE-Y
	LDCIF B,FD
	MULF TRSIZY,FD
	ADDF TRBOT,FD		;TO-EDGE-Y=FROM-SCREEN-Y * TR-PICT-SIZE-Y + TR-PICT-BOT
	TST E
	BLT .+6			;IF SIGN-Y >= 0
	ADDF TRSIZY,FD		;	THEN TO-EDGE-Y = TO-EDGE-Y + TR-SIZE-Y
	LDF FD,FC
	SUBF FB,FC
	MULF FE,FC
	ADDF FA,FC		;TO-EDGE-X=TAN-HEADING*(TO-EDGE-Y - FROM-Y)+FROM-X
	STF FD,FE
	LDCIF E,FD
	MULF FPC0.1,FD
	STF FD,FF		;BACK-OFF-EDGE = SIGN-Y * 0.1
	LDF FE,FD
	SUBF FF,FD
	JSR PC,WRPVEC		;(WRAP-VECTOR	FROM-X
				;		FROM-Y
				;		TO-EDGE-X
				;		TO-EDGE-Y - BACK-OFF-EDGE)
	LDF FC,FA
	LDF FE,FB
	ADDF FF,FB
	LDF (P)+,FD
	LDF (P)+,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	TO-EDGE-X
				;		TO-EDGE-Y + BACK-OFF-EDGE
				;		TO-X
				;		TO-Y)
	JSR F,FACRES
	RTS PC

;NOW BOTH FROM X, TO X AND FROM Y, TO Y ARE ALL ON THE SAME SCREEN.
;WE MUST CONVERT THAT SCREEN TO OVERLAY THE CENTER SCREEN BY A
;MODULO TYPE OPERATION.
WRPVE4:	STF FB,-(P)
	SUBF TRLEFT,FA
	DIVF TRSIZX,FA
	MODF #40200,FA		;MUL BY 1, FRACTION IN FA, INTEGER IN FB
	TSTF FA
	CFCC
	BGE .+6
	ADDF #40200,FA		;SO NEGATIVE VALUES WRAP PROPERLY
	MULF TRSIZX,FA
	ADDF TRLEFT,FA		;SHIFT FROM X TO THIS SCREEN
	LDF (P)+,FB
	SUBF TRBOT,FB
	DIVF TRSIZY,FB
	MODF #40200,FB		;MUL BY 1 TO GET FRACTION IN FB
	TSTF FB
	CFCC
	BGE .+6
	ADDF #40200,FB		;SO NEGATIVE VALUES WRAP PROPERLY
	MULF TRSIZY,FB
	ADDF TRBOT,FB		;SHIFT FROM Y TO THIS SCREEN
	STF FD,-(P)
	SUBF TRLEFT,FC
	DIVF TRSIZX,FC
	MODF #40200,FC		;#1 IN FLOATING
	TSTF FC
	CFCC
	BGE .+6
	ADDF #40200,FC		;SO NEGATIVE VALUES WRAP PROPERLY
	MULF TRSIZX,FC
	ADDF TRLEFT,FC		;SHIFT TO X TO THIS SCREEN
	LDF (P)+,FD
	SUBF TRBOT,FD
	DIVF TRSIZY,FD
	MODF #40200,FD		;#1 IN FLOATING
	TSTF FD
	CFCC
	BGE .+6
	ADDF #40200,FD		;SO NEGATIVE VALUES WRAP PROPERLY
	MULF TRSIZY,FD
	ADDF TRBOT,FD		;SHIFT TO Y TO THIS SCREEN
	JSR PC,BNDVEC		;(BOUNDED-VECTOR FROM-X FROM-Y TO-X TO-Y)
	JSR F,FACRES
	RTS PC

;BNDVEC IS THE EQUIVALENT OF HENRY'S BOUNDED-VECTOR. IT IS USED TO DRAW A
;LINE ON THE SCREEN WITHOUT CONSIDERING WRAP AROUND.  THIS PROGRAM ASSUMES
;THAT THE LINE IS WITHIN BOUNDS.

BNDVEC:	JSR F,FACSAV		;SAVE THE REGISTERS
	JSR PC,TVSCAL		;CONVERT FROM TURTLE COORDINATES TO TV COORDS
	JSR PC,ROUND		;ROUND FA AND FB TO NEAREST INTEGER
	STCFI FA,A
	STCFI FB,B
	LDF FC,FA
	LDF FD,FB
	JSR PC,TVSCAL		;CONVERT FROM TURTLE COORDINATES TO TV COORDS
	JSR PC,ROUND		;ROUND TO NEAREST INTEGER
	STCFI FA,C
	STCFI FB,D
	CMP A,TVX		;SEE IF WE SHOULD MOVE THE DRAWER
	BNE BNDVE1		;YES
	CMP B,TVY
	BEQ BNDVE2
BNDVE1:	SAVE <A,B,DISCAP>
	BIS #.TVDSS*400,(P)	;SET THE DRAWER TO FROM-X AND FROM-Y
	$INVOK
BNDVE2:	MOV C,TVX
	MOV D,TVY		;TO-X AND TO-Y BECOME CURRENT TV DRAWER COORDS
	SUB A,C
	SUB B,D			;TO GET DELTA-X AND DELTA-Y
	SAVE <C,D,DISCAP>
	BISB DRAWMD,1(P)	;SET THE MODE OF THE LINE
	$INVOK
	JSR F,FACRES		;RESTORE THE REGISTERS
	RTS PC

;CONVERT FROM TURTLE COORDINATES TO TV COORDINATES
TVSCAL:	SUBF TRLEFT,FA
	DIVF TRPRTV,FA
	STF FA,-(P)
	LDCIF TVLEFT,FA
	ADDF (P)+,FA		;X = (X - TR-PICTURE-LEFT)/TURTLE-PER-TV + TV-PICT-LEFT
	SUBF TRBOT,FB
	DIVF TRPRTV,FB		;THIS GIVES THE NUMBER OF TV STEPS FROM TOP OF DISPLAY
	STF FB,-(P)		;  AND SINCE TV LINES INCREASE DOWN THE SCREEN:
	LDCIF TVBOT,FB		
	SUBF (P)+,FB		;Y = TV-PICT-BOTTOM - (Y - TR-PICT-BOTTOM)/TR-PER-TV
	RTS PC

;TVHEAD IS USED TO SET THE TURTLE TO THE APPROPRIATE HEADING.
;EXPECTS THE NEW HEADING IN B
TVHEAD:	BIT #HIDETF,DFLAGS	;ARE WE SHOWING THE TURTLE?
	BNE TVHEA2		;NO
	JSR PC,TVTUR		;XOR OUT THE OLD TURTLE
TVHEA2:	MOV B,DCURA		;THIS BECOMES THE CURRENT ANGLE
	SETI
	SETD
	LDCIF B,FA
	STF FA,-(P)
	JSR PC,SINDEG		;GET DSIN A
	STCDF FA,DSINA
	LDF (P)+,FA
	JSR PC,COSDEG		;GET DCOS A
	STCDF FA,DCOSA
	BIT #HIDETF,DFLAGS	;ARE WE SHOWING THE TURTLE?
	BNE TVHEA1		;NO
	JSR PC,TVTUR		;SHOW THE NEW TURTLE
TVHEA1:	SEZ
	RTS PC

;ROUTINES FOR SAVING AND RESTORING FLOATING POINT REGISTERS
FACSAV:	PUSH E
	SAVE <D,C,B,A>
	STF FA,-(P)
	STF FB,-(P)
	STF FC,-(P)
	STF FD,-(P)
	STF FA,FACTMP		;TEMPORARY LOCATION
	LDF FE,FA
	STF FA,-(P)
	LDF FF,FA
	STF FA,-(P)
	LDF FACTMP,FA		;RESTORE FA
	JMP (F)			;RETURN

FACRES:	TST (P)+
	LDF (P)+,FA
	STF FA,FF
	LDF (P)+,FA
	STF FA,FE
	LDF (P)+,FD
	LDF (P)+,FC
	LDF (P)+,FB
	LDF (P)+,FA
	REST <A,B,C,D>
	POP E
	RTS F

.ENDC
	.STITL	MUSIC PRIMITIVES

SING:	EXCH (P),2(P)
	JSR	PC,MCHK
	JSR	PC,REVS	;FOR MULTIPLE ARGUMENTS
	MOV	(SP)+,D	;NUMBER OF ARGS
	ASR	D	;IS IT EVEN?
	BCC	SING2
	ERROR+WNA	;WRONG NUMBER OF ARGS
SING2:	MOV	VOICEN,E	;INDEX FOR VOICE (0,2,4 OR 6)
	MOV	VLAST(E),F	;POINTER TO LAST NODE IN VOICE
SING3:	DEC	D
	BGE	SING31
	SEZ
	RTS PC
SING31:	JSR	PC,G2NARG	;DURATION IN B, PITCH IN A
	JSR	PC,SINGNO	;NORMALIZE MIDDLE C TO 0.  ERROR IF NOTE OUT OF RANGE
	TST	B	;DURATION
	BGE	SING7
SING6:	ERROR+DOR	;DURATION OUT OF RANGE
SING7:	CMP	B,#177	;LARGEST LEGAL DURATION (+- 7 BITS)
	BGT	SING6
	ADD	B,VOICLN(E)	;ACCUMULATE TOTAL FOR VOICE
	CMP	B,#1
	BLT	SING3	;IF ZERO THEN GO ON
	BNE	SING8
	NEG	B	;IF 1 THEN SET TO -1 AS FLAG FOR PERFORM
SING8:	SWAB	A
	BIC	#177400,B	;CLEAR TOP HALF
	BIS	A,B	;SET UP 8 BITS PITCH, 8 BITS DURATION IN B
	JSR	PC,ACTSTO	;BUILD ON TO VOICE LIST
	MOV	F,VLAST(E)	;NEW LAST NOTE
	BR	SING3


;NORMALIZE MIDDLE C TO 0
;ERROR IF NOTE OUT OF RANGE.
SINGNO:	ADD	#74,A	;NORMALIZE 0 TO MIDDLE C
	CMP A,#MBTRAP
	BEQ SINGN1
	CMP	A,#MBREST	;SMALLEST VALID PITCH
	BGE	SINGN2
SINGN1:	ERROR+NOG	;NOTE OUT OF RANGE
SINGN2:	CMP	A,#137	;HIGHEST VALID NOTE
	BGT	SINGN1
	RTS	PC
NOMUSIC:
	TST PTBF
	BEQ NOMUS1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BEQ NOMU9
	BIC #INITF,(A)
	BR MUSIN
NOMUS1:	MOV	#MBDN,E
	JSR	PC,CLOSE2
	BNE	NOMU9	;BR IF NOT OPEN ANYWAY
	BR	MUSIN	;ELSE CLEAR OUT MUSIC VOICES, ETC.

;TRY TO GET MUSIC BOX AND INITIALIZE
;IF DON'T ALREADY HAVE IT
MCHK:	TST PTBF
	BEQ MCHK1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BNE .+4
	ERROR+DNR
	BIT #INITF,(A)
	BNE NOMU9
	BIS #INITF,(A)
	BR MUSIN
MCHK1:	MOV	#MBDN,E
;	CMP	A,TTYU(E)
	BEQ	NOMU9	;BR IF ALREADY OPEN
	JSR	PC,OPEN1
MUSIN:	MOV	#100,MUCWRD	;FOR NVOICES 4
	MOV	#MUSBEG,A
MUSIN1:	CLR	(A)+
	CMP	A,#MUSEND
	BLT	MUSIN1
	MOV	#MVOC,A	;CLEAR OUT THE POINTERS IN USER SPACE
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	JSR	PC,MCL	;SET UP DUMMY NODES
	MOV	#6,NVOIC	;NUMBER OF VOICES
NOMU9:	SEZ
	RTS	PC

TBCHK:	TST PTBF
	BNE TBCHK2
	RTS PC
TBCHK2:	SPUSH B
	SPUSH C
	MOV #4,B
TBCHK3:	CMPB A,(C)
	BEQ TBCHCZ
	TST (C)+
	SOB B,TBCHK3
TBCHSZ:	SPOP C
	SPOP B
	SEZ
	RTS PC
TBCHCZ:	MOV C,A
	SPOP C
	SPOP B
	CLZ
	RTS PC

			;SET UP DUMMY MUSIC LISTS
MCL:	MOV	#6,F
	CLR	B
	MOV	#LSTR,A
MCL2:	MOV	MVOC(F),TOPS	;FREE MUSIC NODES
	JSR	PC,FRELST
	JSR	PC,GRBAD	;GET A NEW NODE
	BIS	A,C
	CLR	B
	JSR	PC,.STORE
	MOV	C,MVOC(F)	;POINTER TO IT
	MOV	C,VLAST(F)
	CLR	VOICLN(F)
	SUB	#2,F
	BGE	MCL2
	RTS	PC

MCLEAR:	JSR	PC,MCHK
	JSR	PC,MCL
	SEZ
	RTS PC
VLEN:	JSR	PC,MCHK	;OUTPUT LENGTH OF CURENT VOICE
	MOV	VOICEN,B
	MOV	VOICLN(B),B
	JMP	R1NARG

MLEN:	JSR	PC,MCHK
	MOV	#4,D
	MOV	#VOICLN,F
	CLR	B
MLEN1:	MOV	(F)+,A	;GET MAXIMUM VOICE LENGTH
	CMP	A,B
	BLE	MLEN2
	MOV	A,B
MLEN2:	DEC	D
	BNE	MLEN1
	JMP	R1NARG
GTVARG:	JSR	PC,G1NARG
	DEC	B	;TRANSFORM VOICE NUMBER (1,2,3,4) TO INDEX (0,2,4,6)
	ASL	B
	TST	B
	BGE	GTV2
GTV1:	ERROR+IVV	;INVALID VOICE NUMBER
GTV2:	CMP	B,#6
	BGT	GTV1
	RTS	PC

VOICE:	JSR	PC,MCHK
	JSR	PC,GTVARG
	MOV	B,VOICEN
	SEZ
	RTS PC

NVOICES:	JSR	PC,MCHK
	JSR	PC,MCL	;REINITIALIZE
	JSR	PC,GTVARG
	MOV	B,NVOIC	;SET NEW VOICE NUMBER
	SEZ
	RTS PC

MBON:	MOV #MBDN,E
	MOV	NVOIC,A
	ASR	A	;TURN INTO BYTE INDEX
	MOV	A,B
	CMP	#2,A	;IN NVOICES 3,
	BNE	MBON1
	INC	A	;IT IS NECESSARY TO SILENCE 4 VOICES
MBON1:	MOVB	MBSCH(A),D	;CHAR FOR A VOICES, BUT ALL SILENT
	JSR	PC,MUCTYO
	MOV	#MBREST,D
	INC	A
MBON2:	JSR	PC,TYO	;OUTPUT REST
	SOB	A,MBON2
	MOVB	MBVCH(B),D	;CONTROL CHR  FOR NUMBER OF VOICES
	MOV	D,MUCWRD
	JSR	PC,MUCTYO	;LEAVE BOX READY FOR NOTES
	RTS	PC

;SILENCE MBOX, BUT DON'T CHANGE NUMBER OF VOICES OR ANYTHING
MBOFF:	MOV	MUCWRD,D
	BIC	#177774,D	;LEAVE NUMBER OF VOICES INFO INTACT
	BIS	#100,D
	MOV	D,MUCWRD
	JSR	PC,MUCTYO
	RTS	PC

;CALLED BY BREAK AND PAUSE TO SHUT THE  DAMN THING UP
BRKMOF:	MOV	#MBDN,E
;	CMP	U,TTYU(E)
	BNE	BRKMO9
	JSR	PC,MBOFF
	RTS	PC

;CALLED BY CONTINUE TO TURN MBOX BACK ON
BRKMON:	MOV	#MBDN,E
;	CMP	U,TTYU(E)
	BNE	BRKMO9
	MOV	MUCWRD,D
	JSR	PC,MUCTYO
BRKMO9:	RTS	PC
			;OUTPUT MUSIC TO THE BOX
PM:	JSR	PC,MCHK
	JSR	PC,MBON
	MOV	NVOIC,A
	MOV	A,F	;USED AS POINTER TO CORRECT VOICE
	ADD	#VOICLN+2,A	;SET UP FLAGS IN VOICLN SLOTS
PM1:	MOV	#-1,-(A)
	CMP	A,#VOICLN
	BGT	PM1
PM2:	JSR	PC,PMCHP	;GRAB DUMMY NODE OF EACH VOICE
	JSR	PC,PMCHP	;NOW SET UP FIRST NODE OF MUSIC
PM21:	TST	-(F)
	TST	F
	BGE	PM2
PM3:	TST BRAKE
	BNE PM7
	CLR	F	;LOOP TO OUTPUT NOTES
PM4:	JSR	PC,PMNXT	;F IS INDEX TO VOICE
	TST	(F)+
	CMP	F,NVOIC	;ONE NOTE FROM EACH VOICE
	BLE	PM4
	CLR	B
	MOV	NVOIC,A	;ADD FLAGS FOR ALL VOICES
	ADD	#VOICLN+2,A
PM5:	ADD	-(A),B
	CMP	A,#VOICLN
	BGT	PM5
	TST	B	;IF ALL FLAGS CLEARED THEN DONE
	BNE	PM3
PM6:	JSR	PC,MBOFF
	JSR	PC,MCL	;REINIT MUSIC VARIABLES
	SEZ
	RTS PC
PM7:;	JSR PC,TBREST
	BR PM6
			;OUTPUT ONE NOTE FROM VOICE(F)
PMNXT:	DEC	TEMP	;NOTE COUNTER
	MOV	#MBREST,D
	TST	VOICLN(F)	;IF FLAG CLEARED OUTPUT REST
	BNE	PMNXT2
	JSR PC,TMBTYO
	RTS	PC
PMNXT2:	CMPB	VLAST(F),#1	;IF DUR=1 PLAY A REST
	BEQ	PMNX2A
	MOVB	VLAST+1(F),D	;PITCH
PMNX2A:	JSR	PC,TMBTYO
	DECB	VLAST(F)	;DECREMENT DURATION
	BGT	PMNXT3
	JSR	PC,PMCHP	;IF DUR<=0 SET UP NEXT NODE
	RTS	PC
PMNXT3:	CMPB	D,#MBPERC	;IS THIS A PERCUSSION SOUND?
	BGT	PMNXT4	;NO
	MOVB	#MBREST,VLAST+1(F)	;YES--CHANGE ALL BUT FIRST TO RESTS
PMNXT4:	RTS	PC

PMCHP:	MOV	MVOC(F),C	;SET UP NEXT NODE SKIP IF SUCCESSFUL
	BIC	#170000,C
	BNE	PMCHP1
	CLR	VOICLN(F)	;CLEAR FLAG TO INDICATE NO NEXT NODE
	RTS	PC
PMCHP1:	JSR	PC,.LOADC
	BIC #170000,A
	BIS #LSTR,A
	MOV	A,MVOC(F)
	MOV	B,VLAST(F)	;PUT PITCH,,DURATION IN VLAST SLOT
	JSR	PC,.FREE	;FREE OLD NODE
	RTS	PC

TMBTYO:	SPUSH C
	MOV #PMBOX,C
	JSR PC,TBTYO
	SPOP C
	RTS PC

READPT:WRITEP:MUTYO:MUCTRL:MUWAIT:
CLOSE:USETTV:UGTYI:UGTYO:CTYOWA:
UDATEG:UTIMEG:TTYP:TYOWAI:
	ERROR+FNF

	.STITL NEW FILING

;USER PRIMITIVE ROUTINES

;DIRSET TAKES A LIST AND SETS THE CURRENT DIRECTORY

DSET:	JSR PC,SETNM	;GET NAME OF DIRECTORY
	BNE DSET1	;INPUT IS A LIST
	JMP COPDEF
DSET1:	JSR PC,COPDEF
DIRSET:	JSR PC,GNWRD	;GET A WORD FROM THE LIST
	BNE .+4		;ANY LEFT?
	RTS PC		;NONE LEFT, DONE
	JSR PC,DIRGET	;GET NEXT ITEM FROM LIST
	BR DIRSET	;AND CONTINUE WITH THE NEXT NAME


DIRGET:	JSR PC,NNFNGT	;GET A FILE NAME
	MOV #NAME,E
	TSTB (E)+	;NO, FIND IT
	BNE .-2
	DEC E
	CMPB #';,-(E)	;IS THIS THE ROOT DIRECTORY?
	BNE DIRGT1
	CMP #NAME,E	;JUST ROOT?
	BEQ DIRGT2
	MOVB -(E),A	;NO, GET WHICH ROOT HE WANTS
	SUB #60,A	;MAKE SURE HE TYPED A NUMBER
	BGE .+4
DIRGT3:	ERROR+BDD
	CMP #10.,A	;NUMBER?
	BLE DIRGT3
	ADD #10,A	;GET TO THE ROOT CAPABILITIES
	MOV A,CURROT
DIRGT2:	MOV CURROT,A
	JMP COPCUR
DIRGT1:	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)	;MUTATE IT
	.INVOK
	BNE .+4
	ERROR+NED	;DIRECTORY NOT FOUND
	SAVE <#FILBLK,#10,CURCAP>
	BIS #.FARI,(P)	;READ THE CAPABILITY TYPE
	$INVOK
	BIT #.FADIR,FILBLK+2	;CHECK THAT IT IS A DIRECTORY
	BNE .+4
	ERROR+ENDR
	RTS PC
;COPY THE DEFAULT CAPABILITY INTO THE CURRENT CAPABILITY
COPDEF:	MOV DEFCAP,A
	MOV DEFROT,CURROT
COPCUR:	JSR PC,FLSCUR	;GET RID OF ANY CURRENT CAPABILITY
	SAVE <#-1,#0,A>	;TO COPY CAPABILITY
	BIS #.CPYCP,(P)	;TO COPY
	.INVOK
	BNE .+4
	ERROR+BDD
	REST CURCAP
	RTS PC
	
.DIRSET:
	BIT #7777,@S	;CHECK NAME OF DIRECTORY ON S-PDL
	BNE .DIRS1
	SPOPS A		;NOTHING TO DO
	SEZ
	RTS PC
.DIRS1:	JSR PC,DSET	;SET THE DIRECTORY
USEENT:	JSR PC,DIRGET	;SET UP FILES
	MOV CURCAP,DEFCAP
	CLR CURCAP
	MOV CURROT,DEFROT
	SEZ
	RTS PC
.USE:	BIT #7777,@S
	BNE .USE1
	SPOPS A
	SEZ
	RTS PC
.USE1:	MOV DEFROT,A
	JSR PC,COPCUR	;MAKE THE DEFAULT ROOT BE THE CURRENT CAP
	TST -(P)
	SAVE <#USERS,CURCAP>
	BIS #.FAMU,(P)	;TO MAKE A CAP TO USERS
	.INVOK
	BNE .+4
	ERROR+BDD
	JSR PC,SETNM
	BEQ .+6
	JSR PC,DIRSET
	BR USEENT


.DELETE:	JSR PC,DSET
	JSR PC,NNFNGT
	TST -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FADL,(P)
	.INVOK
	BNE .+4
	ERROR+CDE
	SEZ
	RTS PC


.READ:	JSR PC,.READF
.READ1:	MOV #.READCH,GCHR
	MOV PC,REDFLG
	JSR PC,SAVEVL
	PUSH #0	;NO. OF ARGS
	JSR PC,SAVPPS
	BIS #DORF,FLAGS
	BIS #1,CPDLP
RMLOOP:	CMP #TYI,GCHR
	BEQ RMLOO1
	JSR PC,RDSTR
	BEQ RMLOO2
	JSR PC,READ
	BEQ RMLOOP	;NO TOKENS
	JSR PC,EVLINE
	BEQ RMWDW
	POPS A
	BR RMLOOP
RMWDW:	ERROR+WDW
RMLOO1:	TST TOPRNM	;DONE, PROC DEF PENDING?
	BEQ .+6
	JSR PC,END
	MOV #RET,PSTOPR
	JSR PC,RESPPS
	POP B
	JSR PC,RESEVL
	MOV B,FLAGS
	MOV CTP,C
	CLR D
	JMP PSTOP6
RMLOO2:	BIT #RBRKF,TFLAGS
	BEQ .+4
	ERROR+BRK
	CMP #TYI,GCHR
	BEQ RMLOO1
	BR RMLOOP

.WRITE:	JSR PC,.WRTEF
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	BR .+2
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	SEZ
	RTS PC
.READF:.OPENR:	JSR PC,DSET
	JSR PC,NNFNGT
	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)
	.INVOK
	BNE .+4
	ERROR+FNF
	SAVE <,,CURCAP>
	BIS #.FARE,(P)
	$INVOK		;GET FILE LENGTH
	REST <FEOF+2,FEOF>
	CLR DBUFCC
	MOV #1,FILFLG
	SEZ
	RTS PC

;READ A CHARACTER
.READC:	TST FILFLG	;IS FILE OPEN FOR READING?
	BLE .REDC1	;NO
	DEC DBUFCC	;ONE LESS CHAR IN BUFF
	BLT .REDC4
	MOVB @DBUFP,D
	INC DBUFP
	RTS PC
.REDC4:	TST FEOF+2	;PAST EOF?
	BLT .REDC1
	CLR DBUFCC
	SUB #DBUFL,FEOF
	SBC FEOF+2
	BGE .REDC8
	MOV FEOF,DBUFCC
.REDC8:	SAVE <#DBUF,#-DBUFL,CURCAP>	
	.BLKI
	BNE .REDC7
	ADD #6,P
.REDC7:	MOV #DBUF,DBUFP
	ADD #DBUFL,DBUFCC
	BR .READC
.REDC3:	TST (P)+
.REDC1:	JSR PC,.REDCL	;CLOSE FILE FOR READING
	CLR REDFLG	;CLEAR READ FLAG
	MOV #EOFCHR,D	;D POINTS TO LAST CHARACTER OF FILE
.REDC2:	RTS PC
.OPENA:	JSR PC,DSET	;SETS DIRECTORY
	JSR PC,NNFNGT	;SET FILE NAME
	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)
	.INVOK		;TRY TO READ THE FILE
	BNE .OPNA1
	CLRB 1(P)	;FLUSH OLD FUNCTION
	BIS #.FAAD,(P)	;TRY TO MAKE A NEW FILE
	.INVOK
	BNE .+4
	BPT
.OPNA1:	CMP -(P),-(P)	;DUMMY
	SAVE <CURCAP>
	BIS #.FARE,(P)
	$INVOK		;READ THE END OF FILE
	MOV 2(P),A	;GET LOW ORDER PART OF EOF
	BIC #-DBUFL,A	;CLEAR BLOCK #
	ADD #DBUF,A	;MAKE A POINTER INTO DBUF
	MOV A,DBUFP
	BIC #DBUFL-1,2(P)	;MAKE IT ON BLOCK BOUNDARY
	SAVE <CURCAP>
	BIS #.FASP,(P)	;SET THE POINTER TO THE END OF FILE
	$INVOK
	SAVE <#DBUF,#-DBUFL,CURCAP>
	.BLKI		;READ THE LAST BLOCK OF THE FILE
	MOV #-1,FILFLG	;SET OPEN FILE FLAG FOR WRITE
	SEZ
	RTS PC
QUEST:	MOV #.TICVM!.TIECM,D
	JSR PC,TSSET
	JSR PC,TYI	;GET THE CHARACTER
	JSR PC,SETTTY
	SPUSH D		;SAVE IT
	JSR PC,.CRLF	;PRINT CR AND LINEFEED
	SPOP D		;GET CHARACTER
.IFNZ FR
	CMP #'O,D
	BEQ QUEST1
	CMP #'O+40,D
	BEQ QUEST1
.ENDC
.IFNZ ENG
	CMP #'Y,D	;IS IT "Y"?
	BEQ QUEST1
	CMP #'Y+40,D	;IS IT SMALL Y
.ENDC
QUEST1:	RTS PC
.WRTEF:.OPENW:	JSR PC,DSET	;SET DIRECTORY
	JSR PC,NNFNGT	;SET IT
.WRTF2:	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAAD,(P)
	.INVOK		;TRY TO PUT IT INTO THE DIRECTORY
	BEQ .WRTF2
	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)
	$INVOK		;GET A CAPABILITY TO THE NEW FILE
	MOV #DBUF,DBUFP
	MOV #-1,FILFLG
.WRTF6:	SEZ
	RTS PC
.WRTF1:
LANGC	<PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/>,<
	PRTXT ^/FICHIER DEJA EXISTANT. A DETRUIRE?/>
	JSR PC,QUEST	;GET REPLY
	BEQ .+4		;OK, DELETE IT
	ERROR+EAES	;ENTRY ALREADY EXISTS
	BR .WRTF2

.WRTEC:	TST FILFLG
	BLT .+4
	BPT
	MOVB D,@DBUFP
	INC DBUFP
	CMP #DBUF+DBUFL,DBUFP
	BNE .WRTF6
	SAVE <#DBUF,#-DBUFL,CURCAP>	
	.BLKO
	BNE .+4	
.WRTDF:	ERROR+DFU
	RTS PC

.WRTCL:	SAVE <#DBUF,DBUFP>
	SUB #DBUF,(P)
	BIC #1,(P)
	NEG (P)
	SAVE CURCAP
	.BLKO
	BNE .WRTDF
	BIT #1,DBUFP
	BEQ .WRCL1
	DEC DBUFP
	MOVB @DBUFP,-(P)
	$BYTO
.WRCL1:	
.REDCL:	JSR PC,FLSCUR
	CLR FILFLG
	SEZ
	RTS PC

FLSCUR:	SAVE A
	MOV CURCAP,A
	JSR PC,DELCAP
	REST A
	CLR CURCAP
	RTS PC

.DELI==.DELETE

.FILEP:	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .+4		;YES
	ERROR+IFN	;NO, INVALID FILE NAME
	SPUSH PCHR
	MOV #.WRTEC,PCHR
	SPUSH #1
	JSR PC,PRINT	;PRINT THE CHARACTERS
.FILP1:	SPOP PCHR
	SEZ
	RTS PC

.FILER:	TST FILFLG	;IS FILE OPEN FOR READ?
	BGT .+4		;YES
	ERROR+IFN	;NO,INVALID FILE NAME
	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	SPOP GCHR
	CLZ
	RTS PC

.CLOSF:	MOV #TYI,GCHR	;RESET IT FOR TTY INPUT
	CLR REDFLG	;CLEAR READFLAG
	CLR WRTFLG	;CLEAR WRITE FLAG
	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .WRTCL
	BGT .REDCL
	RTS PC


.FILEO:	TST FILFLG	;IS A FILE OPEN
	BEQ .+6		;NO
	JMP RTTRUE	;RETURN TRUE
	JMP RTFALS	;RETURN FALSE


;PAGENO == THE UPT SLOT WE CAN USE
;PGADD  == THE PAGE ADDRESS
;WE ALSO HAVE TO GET THE CAPABILITY
;BUFFER== THE ADDRESS OF A BUFFER
;POTREE AND POI ROUTINES

.POTREE:	MOV PC,B				;FLAG ALLOWS LISTING OF INFERIOR DIR'S.
	BR POI.1
.POI:	CLR B					;SUPRESSES LISTING OF INFERIOR DIR'S.
POI.1:	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO
	JSR PC,COPDEF
	CLR A					;RECURSION DEPTH COUNTER
	MOV CURCAP,TMPCP
	CLR CURCAP
	JSR PC,PODIR				;LIST IT
	CMP -(P),-(P)
	SAVE <TMPCP>			;GET DISK DATA
	BIS #.FADI,(P)
	$INVOK
	MOV (P)+,A				;NUMBER OF FREE BLOCKS
	JSR PC,PRDN				;PRINT NUMBER OF FREE BLOCKS ON DISK
	PRTXT ^\ FREE BLOCKS ON DISK #\
	MOV (P)+,A				;DISK NUMBER
	JSR PC,PRDN				;PRINT DISK NUMBER
	PRCR					;AND CAR-RET
	MOV TMPCP,A
	JSR PC,DELCAP
	CLR TMPCP
	RTS PC					;WE ARE DONE
;GIVEN DIRECTORY CAPABILITY, TREE FLAG AND LEVEL

PODIR:	CLR D					;NUMBER OF ENTRY BEING PROCESSED
PODIR0:	CLR -(P)				;MAP IN ALL OF PAGE #0
	CLR -(P)
	SAVE <TMPCP>				;CAP TO DIRECTORY
	MOVB #HAKPG+10,1(P)			;DESTINATION OF PAGE
	SAVE <#.CRRD!1>			;SPHERE CAP AND TYPE OF PAGE
	$MAP
PODIR1:	MOV #HAKAD,C
	MOV 6(C),-(P)				;SAVE EOF
	ADD C,(P)				;ABSOLUTE EOF
PODI11:	MOV #HAKAD,C				;ADDRESS OF START OF PAGE
	MOV D,E					;SKIP SOME ENTRIES
	BEQ PODIR3
PODIR2:	CMP C,(P)				;CHECK EOF
	BLO PODI10
PODI12:	TST (P)+
	RTS PC					;NO MORE ENTRIES SO RETURN
PODI10:	MOV (C),F
	INC F
	BIC #177401,F				;SIZE OF THIS ENTRY
	ADD F,C
	SOB E,PODIR2				;SKIP ANOTHER ENTRY
	CMP C,(P)
	BHIS PODI12
PODIR3: MOVB 1(C),F
	BIC #177761,F				;GET TYPE FIELD
	SAVE C
	JMP @PODIRT(F)				;DISPATCH TO SERVICE ROUTINE

PODIRL:	BPT					;BUG LINKS NOT IMPLEMENTED
	BR PODIRP				;JUST SKIP THE ENTRY
PODIRS:	TST A					;ENTER HERE FOR SELF ENTRY
	BEQ PODIR7				;DON'T PRINT "I" AT TOP LEVEL
	MOV A,F					;LEVEL IS IN A
	SUB #2,F				;PRINT LEVEL-2 SPACES	
PODIR4:	BEQ PODIR6				;DON'T TRY TO PRINT ZERO SPACES
PODIR5:	JSR PC,PODIRB				;PRINT (F) BLANKS
PODIR6:	SAVE D
	MOV #'I,D
	JSR PC,@PCHR
	SPACE
	REST D					;INDICATES INFERIOR DIRECTORY
PODIR7: JSR PC,PODIRN				;PRINT NAME,VERSION, AND SIZE
PODIRP:	INC D					;ENTER HERE FOR PARENT TYPE ENTRY
	REST C
	BR PODI11				;DO THE NEXT ENTRY

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

PODIRF:	MOV A,F					;ENTER HERE FOR FILES
	ADD #2,F				;NUMBER OF SPACES BEFORE NAME
	JSR PC,PODIRB				;PRINT THE BLANKS
	BR PODIR7				;PRINT REST OF INFORMATION
PODIRD:	TST B					;ENTER HERE FOR DIRECTORY ENTRY
	BNE PODIR8
	MOV A,F					;NUMBER OF PRECEDING SPACES
	BR PODIR4				;SUPPRESS LISTING OF INFERIOR DIRECTORY
PODIR8:	SAVE <D,TMPCP>				;SAVE THE WORLD
	ADD #2,A				;INCREMENT THE LEVEL
	SAVE <#-1,#0,TMPCP>
	BIS #.CPYCP,(P)				;COPY THE CAP.
	$INVOK
	JSR PC,PODIRE				;SKIP TO NAME
	MOV TMPCP,@CAPSP
	ADD #2,CAPSP
	SPOP TMPCP
	MOV #BUFFER,E				;PUT NAME FOR MUTATE INTO BUFFER
PODIR9:	MOVB (C)+,(E)+
	BPL PODIR9				;MOVE THE NAME
	BICB #200,-1(E)				;CLEAR BIT IN LAST CHARACTER
	CLRB (E)				;ZERO BYTE AT END OF ASCII STRING
	CLR -(P)
	SAVE <#BUFFER,TMPCP>
	BIS #.FAMU,(P)				;MUTATE THE NEW CAP.
	$INVOK
	JSR PC,PODIR				;LIST INFERIOR
	CLR -(P)
	CLR -(P)
	SAVE <TMPCP>
	BIS #.DELCP,(P)				;DELETE THE CAP.
	$INVOK
	SUB #2,CAPSP
	CLR @CAPSP
	REST <TMPCP,D>				;RESTORE WORLD
	SUB #2,A				;DECREMENT THE LEVEL
	INC D
	REST C
	JMP PODIR0				;CONTINUE LISTING THIS DIRECTORY

;PRINT (F) BLANKS ON THE OUTPUT DEVICE

PODIRB:	SAVE <D>
	MOV #' ,D				;PUT ASCII BLANK IN D
PODIB1:	JSR PC,@PCHR				;PRINT A CHARACTER
	SOB F,PODIB1
	REST <D>
	RTS PC
;SKIP TO BEGINNING OF NAME
;(C)= POINTER TO BEGINNING OF ENTRY

PODIRE:	MOV (C)+,F				;GET THE HEADER WORD
	TST (C)+				;SKIP VERSION NUMBER
	ROL F					;NOW TEST BITS IN HEADER WORD
	BCC .+6
	ADD #10,C				;SKIP EOF DATE AND TIME
	ROL F
	BCC PODIE2
PODIE1:	ADD #2,A				;SKIP ACCESS CODES
	TSTB (C)+
	BLT PODIE1				;MORE ACCESS CODES?
PODIE2:	RTS PC
;PRINT OUT A LINE OF INFORMATION ABOUT FILE
;(C)= POINTS TO ENTRY TO PRINT
;SAVE REGISTERS A,B,D

PODIRN:	SAVE <A,D>				;SAVE REGISTERS
	MOV 6(C),F				;BYTE PONTER
	ADD #1777,F				;ROUND UP TO BLOCK BOUNDARY
	ASH #3,F
	MOV 4(C),E				;PAGE NUMBER
	ASHC #3,E				;NOW LEGNTH IN BLOCKS
	SAVE <E,2(C)>				;SAVE LEGNTH AND VERSION NUMBER
	JSR PC,PODIRE				;SKIP TO BEGINNING OF NAME
PODIN2:	MOVB (C),D				;NOW PRINT NAME
	BIC #177600,D				;CLEAR TOP BIT OF BYTE
	JSR PC,@PCHR				;PRINT A CHARACTER
	TSTB (C)+				;LAST BYTE HAS 200 BIT SET
	BPL PODIN2
	REST <A>				;VERSION NUMBER
	BLT PODIN3				;NO VERSION NUMBER
	SPACE
	MOV #'#,D
	JSR PC,@PCHR
	JSR PC,PRDN				;PRINT THE VERSION NUMBER
PODIN3:	REST <A>				;PRINT THE BLOCK LEGNTH
	SPACE
	SPACE
	JSR PC,PRDN
	JSR PC,.CRLF
	REST <D,A>
	RTS PC					;DONE WITH THIS ENTRY


.CRINDEX:
	JSR PC,DSET	;SET THE DIRECTORY
	JSR PC,NNFNGT	;GET THE NAME
	SAVE <#.FADIR,#NAME,CURCAP>
	BIS #.FAAD,(P)
	.INVOK		;TRY TO CREATE THE DIRECTORY
	BNE .+4
	ERROR+EAES
	SEZ
	RTS PC

.POF:	JSR PC,.READF
.POF1:	JSR PC,.READC
	CMP #EOFCHR,D
	BEQ .POF2
	JSR PC,@PCHR
	BR .POF1
.POF2:	CLR FILFLG
	RTS PC
.PREAD:.PWRIT:	ERROR+OOP

GNWRD:	;INPUT	POINTER TO LIST OF WORDS ON S
	;OUTPUT	-IF LIST IS NOT EMPTY,
	;	 POINTER TO  FIRST OF LIST ON TOP OF S
	;	 POINTER TO BF OF LIST NEXT
	;	 Z WILL BE CLEAR
	;	-IF LIST IS EMPTY, POP S AND SET Z
	;IF F LIST ISNT A WORD, WTA ERROR ISSUED
	JSR F,CACSAV
	MOV @S,B
	BIT #7777,B	;IS LIST EMPTY?
	BEQ GNWRD1
	JSR PC,.LOADB	;NO GET 1ST NODE
	MOV A,@S	;SAVE BF ON S
	PUSHS B		;YES - PUSH FIRST ON S
	JSR F,CACRES
	CLZ
	RTS PC
GNWRD1:	POPS A		;EMPTY LIST QUIT
	JSR F,CACRES
	SEZ
	RTS PC
NNFNGT:	MOV #NAME,E
NFNGET:		;INPUT	ADDRESS OF BLOCK IN E
		;	PTR TO LSTR ON S
		;OUTPUT	PUT 1ST 10. CHAR OF LSTR INTO BLOCK
		;	SET 200 BIT IN LAST CHAR, POP S
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,B	;POINTER TO FILE NAME IN B
	MOV #LSTR,A	;DATA TYPE FOR CONVERSION
	JSR PC,CONVER	;MAKE NAME AN LSTR
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME (CONVERSION FAILED)
	MOV B,@S	;POINTER TO NEW DATA ON STACK
	BIC #170000,B	;LEAVE DATA TYPE
	MOV B,GNCN	;"GET NEXT CHARACTER" NODE
	MOV #10.,C	;TAKES ONLY THIS MANY CHARACTERS
NFNG1:	JSR PC,GNC	;GET NEXT CHAR
	CMP #15,D	;UGH! (IS IT A CARRIAGE RETURN?)
	BEQ NFNG2	;YES- NO MORE CHARACTERS
	MOVB D,(E)+	;STORE THE NEXT CHARACTER
	MOV D,TEMP
	SOB C,NFNG1	;KEEP GOING UNTIL WE HIT TEN
NFNG2:	CLRB (E)	;CLREAR LAST BYTE
	JSR F,CACRES	;GET BACK THE OLD REGISTERS
	JSR PC,SPOPT
	RTS PC
SETNM:		;INPUT	LIST OR WoRD ON S
		;OUTPUT	IF WORD, OUTPUT WORD AND SET Z
		;	IF LIST, OUTPUT LAST AND BL OF LIST ON S
		;		PUT BL ON TOP AND CLEAR Z
		;	OTHERWISE ERROR
	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO	;FILE ALREADY OPEN
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,C	;GET INPUT
	BIT #7777,C
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME
	MOV C,B		;SEE IF IT'S A LIST
	BIC #7777,C
	CMP C,#LIST
	BEQ SETNM1	;YES, IT IS
SETNM2:	JSR F,CACRES	;OK, SET Z AND QUIT
	SEZ
	RTS PC
SETNM1:	JSR PC,COPYL	;COPY LIST - INPUT IN B
		;OUTPUT IN B;  C POINTS TO LAST NODE IN NEW LIST
		; E POINTS TO 2ND TO LAST NODE
	JSR PC,.LDP2
	MOV A,@S
	MOV E,C
	BEQ SETNM3	;NO BUTLAST
	JSR PC,.LDP1	;FIX UP  LINK
	BIC #7777,A
	JSR PC,.STP1
	BIS #LIST,B
SETNM4:	PUSHS B
	JSR F,CACRES
	CLZ
	RTS PC
SETNM3:	MOV #LSTR,B
	BR SETNM4
	.STITL MISC ROUTINES

CACSAV:	JSR PC,PPUSHT	;CAREFUL AC SAVE
ACSAV:	MOV E,-(P)
	MOV D,-(P)
	MOV C,-(P)
	MOV B,-(P)
	MOV A,-(P)
	JMP (F)

CACRES:	JSR PC,PPOPT	;CAREFUL AC RESTORE
ACRES:	TST (P)+
	MOV (P)+,A
	MOV (P)+,B
	MOV (P)+,C
	MOV (P)+,D
	MOV (P)+,E
	RTS F

PPUSHT:	CMP P,#PPUSHL
	BLOS .+4
	RTS PC
	JMP PPSWPO	;PDL REALLY OVERFLOWED

PPOPT:	CMP P,PPOPL
	BHIS .+4
	RTS PC
	JMP PPSWPI

SPUSHT:	SUB #2,S
	CMP S,#SPUSHL
	BLOS .+4
	RTS PC
	JMP SPSWPO

SPOPT:	ADD #2,S
SPOPT1:	CMP S,SPOPL
	BHI .+4
	RTS PC
	JMP SPSWPI

.SPACE:	SAVE D
	MOV #' ,D
.SPAC1:	JSR PC,@PCHR
	REST D
	RTS PC

.CRLF:	SAVE D
	MOV #15,D
	BR .SPAC1

	.STITL P AND S PDL SWAP OUTERS

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
.IFNZ TS
	TST PPEMR	;HAS A P PDL EMERGENCY ALREADY OCCURED?
	BEQ .+4		;NOPE
	ERROR+BUG	;SYSTEM BUG!!
	JSR F,SETUPP
	.BLKO
	BEQ PPEMRP	;GO DO AN EMERGENCY PUSH OF THE STACK
	CMP PPLIMT,PRBAO	;ARE WE BEYOND THE LIMIT ON P YET?
	BHI PPSWP1
	BIS #DSAMFL,FLAGS2	;YES, SET DISK ALMOST FULL
.ENDC
PPSWP1:	MOV #POPLM,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IP,A
	MOV #PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PPDLL,P	;PDL HAS MOVED!
	ADD #PPDLL,PRBAO
	JSR F,ACRES
	RTS PC

.IFNZ TS
PPEMRP:	MOV PC,PDLEMR	;FLAG THAT A PDL EMERGENCY OCCURED
	MOV PC,PPEMR	;FLAG A P PDL EMERGENCY
	CLR -(P)
	CLR -(P)
	SAVE PPDLCP
	BIS #.FASP,(P)
	$INVOK		;SET POINTER TO BEG OF FILE
	$BLKO		;OUTPUT THIS PDL BLOCK (CAN'T FAIL!!)
	BIS #DSAMFL,FLAGS2	;WARN THE REST OF THE SYSTEM WE ARE IN TROUBLE
	BR PPSWP1
.ENDC


SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
.IFNZ TS
	TST SPEMR	;HAS A P PDL EMERGENCY ALREADY OCCURED?
	BEQ .+4		;NOPE
	ERROR+BUG	;SYSTEM BUG!!
	JSR F,SETUPS
	.BLKO
	BEQ SPEMRP	;GO DO AN EMERGENCY PUSH OF THE STACK
	CMP SPLIMT,SPRBAO	;ARE WE BEYOND THE LIMIT ON P YET?
	BHI SPSWP1
	BIS #DSAMFL,FLAGS2	;YES, SET DISK ALMOST FULL
.ENDC
SPSWP1:	MOV #SPOPLM,SPOPL
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IS,A
	MOV #SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #SPDLL,S	;PDL HAS MOVED!
	ADD #SPDLL,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

.IFNZ TS
SPEMRP:	MOV PC,PDLEMR	;FLAG THAT A PDL EMERGENCY OCCURED
	MOV PC,SPEMR	;FLAG A P PDL EMERGENCY
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;SET POINTER TO BEG OF FILE
	$BLKO		;OUTPUT THIS PDL BLOCK (CAN'T FAIL!!)
	BIS #DSAMFL,FLAGS2	;WARN THE REST OF THE SYSTEM WE ARE IN TROUBLE
	BR SPSWP1
.ENDC
	.STITL P AND S PDL SWAPER INERS
PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV #PSWPAD,A
	MOV A,B
	ADD #PPDLL,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PPDLL,P
	SUB #PPDLL,PRBAO
	BNE PSWPI3
	BIC #PPNAIF,FLAGS2
	MOV #IP,PPOPL
PSWPI3:
.IFNZ TS
	JSR F,SETUPP
	$BLKI
.ENDC
	JSR F,ACRES
	RTS PC
.IFNZ TS
SETUPP:	TST (P)+
	TST PPEMR	;HAS A P PDL EMERGENCY OCCURED?
	BEQ SETUP1	;NO, DO NORMAL THING
	CLR -(P)	;GO TO START OF FILE FOR EMERGENCY BLOCK
	CLR PPEMR	;NO MORE EMERGENCY!
	BR SETUP2
SETUP1:	SPUSH PRBAO
	ADD #PPDLL,(P)	;SKIP THE EMERGENCY BLOCK
SETUP2:	CLR -(P)
	SPUSH PPDLCP
	BIS #.FASP,(P)
	$INVOK
	SPUSH #PSWPAD
	SPUSH #-PPDLL
	SPUSH PPDLCP
	JMP (F)
.ENDC

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV #SSWPAD,A
	MOV A,B
	ADD #SPDLL,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #SPDLL,S
	SUB #SPDLL,SPRBAO
	BNE SPSWI3
	MOV #IS,SPOPL
	BIC #SPNAIF,FLAGS2
SPSWI3:
.IFNZ TS
	JSR F,SETUPS
	$BLKI
.ENDC
	JSR F,ACRES
	RTS PC
.IFNZ TS
SETUPS:	TST (P)+
	TST SPEMR	;HAS EMERGENCY OCCURED?
	BEQ SETUS1	;NOPE
	CLR -(P)	;GET EMERGENCY BLOCK THEN
	CLR SPEMR	;NO MORE EMERGENCY
	BR SETUS2
SETUS1:	SPUSH SPRBAO
	ADD #SPDLL,(P)	;PASS BY EMRG BLOCK
SETUS2:	CLR -(P)
	SPUSH SPDLCP
	BIS #.FASP,(P)
	$INVOK
	SPUSH #SSWPAD
	SPUSH #-SPDLL
	SPUSH SPDLCP
	JMP (F)
.ENDC


	.STITL P AND S PDL POPPERS
PPTA:		;POP PP PDL TO (A) RELATIVE
		;USES A,F
	SPOP F
PPTA1:	CMP A,PRBAO
	BHIS PPTA3
	MOV PPOPL,P
	JSR PC,PPSWPI
	BR PPTA1
PPTA3:	SUB PRBAO,A
	SUB #IP,A
	NEG A
	CMP A,P
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,P
	JSR PC,PPOPT
	JMP @F
PSTA:		;POP S PDL TO (A) RELATIVE
		;USES A
	CMP A,SPRBAO
	BHIS PSTA3
	MOV SPOPL,S
	JSR PC,SPSWPI
	BR PSTA
PSTA3:	SUB SPRBAO,A
	SUB #IS,A
	NEG A
	CMP A,S
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,S
	JMP SPOPT1
.STITL INITIALIZE NODE SPACE
;ON ENTRY B = START OF FREE NODES NODE #
;	C = " " " " NODE ADDRESS
;	D = FIRST WORD AFTER END OF SLOT
INIT:	MOV #PSTP15,ERFRET
	MOV #RET,DOFRET
	MOV #NODESP,A
	MOV #INODES,B
	MOV #400,C
	MOV #IDLE,D
INODCP:	MOV (B)+,(A)+
	MOV (B)+,(A)+
	DEC C
	INC D
	CMP #ASOFN,B
	BNE INODCP
FREEND:	INC D
	INC NNGC
	MOV D,(A)+
	CLR (A)+
	SOB C,FREEND
	CMP -(A),-(A)
	MOV #IDLE,(A)+
	CLR (A)+
	MOV A,NODTOP
	MOV NNGC,NNIFSL
	RTS PC

;A IS START OF ARRAY SPACE
;B IS LENGTH OF ARRAY SPACE
	MOV A,AFREE
	MOV A,AROVER
	CLR (A)+
	MOV B,(A)+
	CLR (A)
	MOV B,ASPACE

INIT1:	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
STARTF:	RTS PC
	.STITL READ-EVAL LOOP DRIVER (THE ONE-USER MAIN LOOP)
.IFNZ TS
PURIFY:	MOV #IP,P
	JSR PC,PURINT
	MOV PC,INITED
	BPT
.ENDC

START:	MOV #IP,P
.IFNZ TS
	TST INITED	;HAS THE TS INITING ALREADY BEEN DONE?
	BNE NOINIT
	JSR PC,PURINT
NOINIT:
.ENDC
;FOLLOWING FOR STANDALONE ONLY, FLUSH FOR TS

	MOV #ERRBK,34
.IFZ TS
	JSR PC,SORT
	MOV #2,A
	MOV #100,B
TRINT:	MOV A,-2(A)
	ADD #4,A
	SOB B,TRINT
	CLR 0
	MOV #TYIBRK,60
	MOV #100,177560
SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
KIDR=172300
KIAR=172340
KDDR=172320
KDAR=172360
SEGSET:	CLR SSR0
	MOV #KIDR,A
	MOV #20,B
	MOV #77406,(A)+
	SOB B,.-4
	MOV #10,C
SEGST1:	MOV B,20(A)
	MOV B,(A)+
	ADD #200,B
	SOB C,SEGST1
	MOV #77406,A
	MOV #KDDR+6,B
	MOV A,(B)+
	MOV A,(B)+
	MOV A,(B)
	MOV #1600,KDAR+4
	MOV #2000,KDAR+6
	MOV #2200,KDAR+10
	MOV #7600,KDAR+16
	MOV #4,SSR3
	MOV #1,SSR0
.IFF
	MOV #.TICTM!.TIECM!.TLIPM!.TICVM,TTYST
	JSR PC,SETTTY
.IFNZ TVS
	JSR PC,TVCHK				;SET THE TV FLAG
.ENDC
	SAVE <#PSWPAD,#-PPDLL>			;KLUDGE, TEHSE ARGS FOR BLKO
	SAVE <#-1,#PCRBLK,#.FACAP*400+0>	;THESE ARGS FOR THE INVOKE
	$INVOK
	MOV (P),PPDLCP
	$BLKO			;RESEVRE THE EMERG BLOCK
	SAVE <#SSWPAD,#-SPDLL>			;ARGS FOR BLKO
	SAVE <#-1,#SCRBLK,#.FACAP*400+0>	;ARGS FOR INVOK
	$INVOK
	MOV (P),SPDLCP
	$BLKO			;FOR EMRG BLOCK
	SAVE <#0,#4,#<1*400>+1>
	$INVOK			;READ THE C-LIST AT 4 (DEFAULT DIR)
	TST (P)+		;IS ANYTHING THERE?
	BNE HAVDEF		;YES, WE HAVE A DEFAULT DIR.
	SAVE <#-1,#0,#.CPYCP+10>	;NO DEFAULT DIRECTORY,
	$INVOK			;SO USE THE ROOT
	SPOP DEFCAP
HAVDEF:	SAVE <#BRKPRS>
	.FORK		;CREATE A PROCESS TO BREAK LOGO
	BEQ .-2		;MAKE SURE WE BREAK IT
.ENDC
.IF NZ FPPF
.IIF NZ TS,.FLOAT
	LDFPS #40300
.ENDC
	BR UGO
BRKPRS:	MOV #BRKPDL,P	;MY OWN SPECIAL PDL
BRKPR3:	SAVE <#0,#<'Z-100>*400+'G-100,TYICP>
	MOVB #.TTBRK,1(P)	;TO WAIT FOR ONE OF THESE CHARS
	$INVOK		;WAIT
	TST INPUTH	;IS HE HANGING ON INPUT?
	BNE BRKPR2
	CMPB #'Z-100,(P)	;WAS IT A PAUSE?
	BNE BRKPR1
	MOV #-1,BRAKE
BRKPR1:	CMPB #'G-100,(P)	;WAS IT A BREAK?
	BNE BRKPR2
	MOV #1,BRAKE
BRKPR2:	TST (P)+
	TST BRAKE
	BEQ BRKPRS
	SAVE <,#.TIRST!.TORST,TYICP>
	MOVB #.TTBIS,1(P)
	$INVOK		;RESET TTY INPUT AND OUTPUT
	BR BRKPR3
UGO:	MOV #TYO,PCHR
	MOV #TYI,GCHR
LANGC <	CPRTXT ^/WELCOME TO 11LOGO />,<
	CPRTXT ^/BIENVENUE A 11LOGO />
	.IFNZ FPPF
	PRTXT ^/FPP /
	.ENDC
	MOV LVERNF,A
	JSR PC,PRDN
	TST DEBSW
	BEQ UGO1	;IF DEBUG SWITCH IS ON
		;PRINT MESSAGE
	CPRTXT ^/LOGO BEING DEBUGGED!/
UGO1:	PRCR		;PRINT CR
	JSR PC,INIT
MLOOP:	BIC #HERRF,FLAGS2
	JSR PC,GETSTR
	JSR PC,MREAD
	BEQ MLOOP	;NO TOKEN LIST
	JSR PC,EVLINE
	BEQ MWDW
	POPS A
	BR MLOOP
MWDW:	ERROR+WDW	;WHAT SHOULD I DOO WITH (S)

.IFNZ TS
PURINT:	MOV #PURPG+1+10,A
DELPAG:	CMP -(P),-(P)		;IN DELETE, NOT USED
	SAVE #-3		;DELETE FUNCTION
	MOVB A,1(P)		;WHICH PAGE
	SAVE #1			;SELF
	$MAP		;BETTER NOT FAIL!
	INC A
	BIT #7,A		;LAST PAGE DONE?
	BNE DELPAG
	SAVE <#LSUPBL_8.+0,,#20_8.+374,#.CRWRT+1>	;SHRINK PAGE 0
	$MAP
	SPUSH #0*400+0		;LENGTH AND START
	TST -(P)		;PAGE TO GET NOT USED WITH SOURCE=FRESH
	SPUSH #<10+NODPG>*400+377	;40000-60000, FRESH PAGE
	SPUSH #<.CRWRT+1>	;INSERT INTO SELF
	$MAP
	JSR PC,SORT
;HERE MAKE READ ONLY PAGE READ ONLY
	RTS PC

;THE EXPAND SPACE ROUTINE
;CALL WITH A POINTER IN A TO A BLOCK:
;(A) CURRENT HIGHEST PAGE
;2(A) CURRENT LENGTH OF HIGHEST PAGE
;4(A) HIGHEST PAGE TO USE FOR THIS SPACE
;MAY CLOBBER B AND C
EXSPAC:	INC 2(A)	;INCREASE HIGH PAGE?
	CMP #10,2(A)	;IS IT ALREADY 4K?
	BEQ EXSPA1	;YUP
	SAVE <#0,#0,#10_8.+374,#.CRWRT+1>	;TO EXPAND THE PAGE
	MOVB 2(A),7(P)	;HOW LONG?
	BISB (A),3(P)	;WHICH PAGE?
	.MAP 		;ATTEMPT TO EXPAND
	BNE EXSPA2	;LOSE?
	ADD #10,P	;POP ARGS OF FAILED CALL
	DEC 2(A)	;WE DIDN'T DO WHAT WE SET OUT TO
EXSPA3:	SEZ		;INFORM OF FAILURE
EXSPA2:	RTS PC
EXSPA1:	DEC 2(A)	;NOT INCREASING PAGE SIZE AFTER ALL
	CMP (A),4(A)	;ALREADY ON LAST PAGE?
	BEQ EXSPA3	;IF YES LOSE
	INC (A)		;GO TO NEXT PAGE
	CLR 2(A)	;START WITH 512 WORDS
	SAVE <#0,#0,#10_8.+377,#.CRWRT+1>	;TO CREATE NEW PAGE
	BISB (A),3(P)	;WHICH PAGE?
	.MAP		;TRY TO CREATE
	BNE EXSPA2	;BR ON WINNING
	ADD #10,P	;POP ARGS
	MOV #7,2(A)	;BACK UP
	DEC (A)		;TO PREVIOUS PAGE
	BR EXSPA3	;GO FAIL
.ENDC
RUNRUG:	JSR PC,CKSST
	BPT
	SEZ
	RTS PC

TSSET:	TST -(P)
	SPUSH D
	SPUSH #.TTMOV*400+2	;SET THE TTY STATUS
	$INVOK
	SEZ
	RTS PC

SETTTY:	SAVE D
	MOV TTYST,D
SETTT1:	JSR PC,TSSET
	REST D
	RTS PC

TINECH:	SAVE D
	MOV #.TLIPM!.TICVM,D
	BR SETTT1

ECHOSW:	MOV #.TIECM,A
	BR CASES1
CASESW:	MOV #.TICVM,A
CASES1:	XOR A,TTYST
	JMP TSSET	

DELCP:
DELCAP:	TST A
	BEQ DELCP1
	CMP -(P),-(P)
	SAVE A
	BIS #.DELCP,(P)
	$INVOK
DELCP1:	RTS PC

	.STITL GET A STRING
GSTR4:	PUSHS C
	PUSH GCHR
	SPUSH PCHR
	SPUSH PRMTCH
	CLR PRMTCH
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	JSR PC,.LOADC
	PUSHS B
	JSR PC,PRLN
	POPS B
	JSR PC,RDSTR
	BEQ GSTR5
GSTR7:	POPS A		;IGNORE ANY LINE TYPED IN
GSTR10:	POP PRMTCH
	SPOP PCHR
	SPOP GCHR
	POPS C
	JSR PC,.LOADC
	JSR PC,.LOADB	;PUT THINGS BACK AS THEY WERE
	BR GSTR3

GSTR5:	BIT #RBRKF,TFLAGS
	BEQ GSTR10
	POP PRMTCH
	ERROR+BRK
GETSTR:	TST FUNLEV	;ARE WE IN A PROC
	BEQ GSTR0	;NO
	BIT #BRKF,FLAGS	;ERROR, MAYBE
	BNE GSTR0	;YES
	MOV CLP,B	;NO, GET THIS NODE OF LLP
	BEQ GSTR9
	JSR PC,.LOAD
	BIT #7777,A	;IS IT LAST NODE
	BNE GSTR8
	SPOP A		;POP RETURN ADDR
	JMP PSTOP

GSTR9:	MOV CPLN,B
	JSR PC,GTLINE
	BNE .+4
	ERROR+LDE	;LINE ..(B).. DOESN'T EXIST
	MOV C,A
GSTR8:	CLR CLP
	MOV A,C
	JSR PC,.LOADC
	JSR PC,.LOAD	;OK, GET FIRST NODE OF LINE, = LINE #
	MOV B,CPLN
	BIT #TPSF,FLAGS
	BNE GSTR4
GSTR3:	MOV C,CLP
	MOV A,CTP	;IN CASE THERE IS NO GENERATION #
	MOV A,C
	JSR PC,.LOADC	;GET SECOND NODE
	CLR CLGN	; IF TYPE = SNUM, IT IS GEN #
	MOV A,C
	BIC #7777,C
	CMP #SNUM,C
	BNE GSTR6
	MOV B,CLGN	;IT IS
	MOV A,CTP
GSTR6:	BIS #LIST,CTP
	PUSHS CTP
	BIT #TRACEF,FLAGS2
	BEQ GSTRT
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
	PRCR
GSTRT:	RTS PC


GSTR0:
GSTR1:	JSR PC,RDSTR
	BNE GSTRT
GSTR2:	BIT #RBRKF,TFLAGS
	BEQ GSTR1
	ERROR+BRK
	.STITL MORE READ ROUTINES!!!
MREAD:	TST FUNLEV	;ARE WE IN PROC?
	BEQ MRD1	;NO
	BIT #BRKF,FLAGS	;YES, BUT ERROR?
	BEQ MRD3
MRD1:	CLR ILINEL
	JSR PC,READ	;CONVERT CHAR STRING TO TOKEN LIST
	BEQ MRD4	;NO TOKENS
	MOV @S,ILINEL
MRD3:	CLZ
MRD4:	RTS PC

CKSTG:	;CKECK IF DISC OR NODES ARE ALMOST GONE
	BIT #DSAMFL,FLAGS2
	BNE CKSTG1
	CMP NNIFSL,#NBN
	BHIS MRD4
	JSR PC,.GCOLL	;GC AND EXPAND IF NEEDED
	CMP NNIFSL,#NBN
	BHIS MRD4
CKSTG1:	CLR ERPROC
	ERROR+NSL
	.STITL EVAL 1 LINE

EVLINE:	BRAKET
	TST TOPRNM
	BNE EVLI4
EVLI6:	BIC #EVIFS,FLAGS
	CLR CO
	CLR CO+2
	CLR NOR
	CLR COF
	CLR LO
	CLR LO+2
	JSR PC,IGNT
EVLI1:	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,EVAL
	BEQ EVLI3	;NO OUTPUT, OK
	JSR PC,CKSTG
	SEZ
	RTS PC
EVLI3:	JSR PC,CKSTG
	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,GNT
	BIS #RTF,FLAGS
	BR EVLI1
EVLI4:	JSR PC,CKSTG
	MOV @S,B
	JSR PC,.LOAD
	MOV A,D
	BIC #7777,A
	CMP #SNUM,A
	BEQ EVLI5	;AN SNUM
	CMP #INUM,A
	BEQ EVLI8	;AN INUM
	CMP #LSTR,A
	BNE EVLI6	;NOT AN SNUM, INUM OR LSTR
	JSR PC,.CLSIN	;CONVERT LSTR TO INUM
	BEQ EVLI6	;NOT NO. OR TOO BIG
EVLI8:	BIT #SPDF,FLAGS	;IS THIS PROC DEF. BEING SKIPPED?
	BNE EVLI2
	JSR PC,.CINSN	;CONVERT INUM TO SNUM
	BEQ EVLI7	;TOO BIG
	TST B	;IS NO. TOO SMALL?
	BGT .+4
	ERROR+LNTS
	MOV D,A
	BIC #170000,A	;MAKE IT INTO AN SNUM
	BIS #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	MOV C,@S
EVLI5:	JSR PC,ADLN
EVLI2:	CLZ
	RTS PC
EVLI7:	ERROR+LNTB	;LINE # TOO BIG
	.STITL GET NEXT TOKEN

GNT:	MOV CT,A
	MOV CT+2,B
	BIT #RTF,FLAGS	;IS REPEAT TOKEN FLAG SET?
	BEQ GNT1
	BIC #RTF,FLAGS	;YES
	CMP #SFUN,A
	BNE GNT6
	TST B
	BNE GNT6
	BIS #CRF,FLAGS
GNT6:	RTS PC
GNT1:	BIC #PTLPF,FLAGS
	CMP #$LLPAR,B	;IS CT "("
	BEQ GNT3
	CMP #$LPAR,B
	BNE GNT3A
GNT3:	BIS #PTLPF,FLAGS	;YES, SET PTLPF
GNT3A:	MOV A,CTP	;GET LINK TO NEXT TOKEN
	BIT #7777,A
	BEQ GNT2	;ANY TOKENS LEFT
	JSR PC,.LOADA	;YES
	INC CTN
GNT3B:	CMP #$COMT,B
	BEQ SKPCOM
GNT4:	MOV A,CT
	MOV B,CT+2
	RTS PC
GNT2:	BIT #CRF,FLAGS
	BNE GNT5
	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR GNT4
GNT5:	ERROR+OOT	;OUT OF TOKENS
SKPCOM:	MOV A,CTP	;SKIP OVER A COMMENT
	BIT #7777,A
	BEQ GNT2	;END ON CR FOUND
	JSR PC,.LOADA
	INC CTN
	CMP #$COMT,B
	BNE SKPCOM	;DON'T STOP TILL CR OR CLOSING "!"
	BR GNT3A	;RETURN TOKEN AFTER CLOSING "!"

IGNT:	MOV @S,B	;INIT "GNT"
	BIT #7777,B
	BEQ IGNT1
	BIC #CRF,FLAGS
	MOV B,CTP
	JSR PC,.LOAD
IGNT2:	MOV A,CT
	MOV B,CT+2
	BIS #RTF,FLAGS
	MOV #1,CTN
	BR GNT3B
IGNT1:	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR IGNT2
	.STITL LOGO TYI/O
CTYI:TYI:	.IFZ TS
	WAIT
	TST CHI
	BEQ TYI
	MOVB CHI,D
	CLR	CHI
	BIC #177600,D
.IFF
	SPUSH TYICP
	$BYTI
	SPOP D
	RTS PC
.ENDC

TBTYO:	JSR PC,TBINIT	;INIT PTBOX
	BNE .+4		;HAS ONE
	ERROR+FNF
;DROPS INTO TYO

CTYO:TYO:	.IFZ TS
	TSTB 177564
	BPL .-4
	MOVB D,177566
	CMP #15,D
	BEQ .+4
	RTS PC
	MOV D,-(P)
	MOV #12,D
	JSR PC,TYO
	SPOP D
	RTS PC
TYIBRK:	MOV 177562,CHI
	RTT
.IFF
	TST BRAKE
	BNE TYO1
	SPUSH D
	SPUSH TYOCP
	$BYTO
TYO1:	RTS PC
.ENDC

TBINIT:	TST PTBF
	BNE .+4		;OWNS ONE
	RTS PC
	SPUSH A
	SPUSH B
	SPUSH D
	SPUSH E
	SPUSH F
	NEG C
	MOV #PTBTAB,B
TBINT2:	MOV #4,A
TBINT3:	CMPB C,(B)
	BEQ TBINT4
	TST (B)+
	SOB A,TBINT3
TBINSZ:	SPOP F
	SPOP E
	SPOP D
	SPOP B
	SPOP A
	SEZ
	RTS PC
TBINT4:	TST F
	BMI TBINT5
	TST (B)
	BPL TBINT5
TBINCZ:	SPOP F
	SPOP E
	SPOP D
	SPOP B
	SPOP A
	CLZ
	RTS PC
TBINT5:	TST -(P)	;FOR THE SETTING OF THE STATUS BELOW
	CMP -(P),-(P)
	SPUSH TYOCP
	BIS #.TTRD*400,(P)
	$INVOK		;READ OLD STATUS
	TST -(P)
	SPUSH #.TIMGO
	SPUSH TYOCP
	BIS #.TTBIS*400,(P)	;BIS THE IMAGE OUT BIT
	$INVOK
;NOTE HERE ON THE STACK IS THE OLD STATUS, THEN AN EMPTY WORD
	MOV #21,D
	JSR PC,TYO	;OUTPUT THE ATTENTION CHARACTER TO THE THORTON BOX
	MOV B,D
	SUB #PTBTAB,D	;GET THE INDEX OF THE THING SELECTED
	MOV TBCCHR(D),D	;GET THE SELECT CHARACTER
	JSR PC,TYO
	BIS #100000,(B)
	MOV (B),C
	BIC #TBMASK,C
	CMP C,#CONSO
	BNE TBINT6
	MOV OTTYST,(P)	;CHANGE THE STATUS
	BIS #.TIRST,(P)
	BR TBINT7	;DESTROY OLD USER
TBINT6:	BIS #.TIMGO,(P)
TBINT7:	SAVE TYOCP	;THE CAPABILITY
	BIS #.TTMOV*400,(P)	;SET THE TTY STATUS
	$INVOK
	MOV #PTBTAB,C		;POINT TO THE TABLE AGAIN
	MOV #4,D
TBINT8:	TST (C)
	BGE TBINT9
	CMP C,B
	BEQ TBINT9	;DONT CLEAR THE ONE WE JUST SET
	BIC #100000,(C)
TBINT9:	TST (C)+
	SOB D,TBINT8
	BR TBINCZ

	.STITL	GARBAGE COLLECTOR
NNODES==4096.
GCBTL== NNODES/8./2.*2.	;GARBAGE COLLECT BIT TABLE LENGTH

MARKNI:	SPUSH A
	SPUSH B
	BR MARKN4
MARKN:	SPUSH A	;MARK NODE(B)
	SPUSH B
;DEBUGGING FEATURE
	JSR PC,.LOAD	;ARE WE MARKING AN IDLE NODE
	BIC #7777,A
	CMP #IDLE,A
	BNE .+4
	.BUG.
	MOV (P),B
;
MARKN4:	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;ALREADY MARKED?
	BEQ MARKN1	;NO
MARKN3:	SPOP B
	SPOP A
	SEZ
	RTS PC
MARKN1:	BISB B,(A)
MARKN2:	SPOP B
	SPOP A
	CLZ
	RTS PC
MARKDN:	;SKIP IF NODE (B) IS MARKED
	SPUSH A
	SPUSH B
	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;MARKED?
	BEQ MARKN3	;NO
	BR MARKN2	;YES-SKIP

MARKL:	PUSH A	;MARK LIST
	SPUSH B	;NODE ADDS IN B
	SPUSH C
	JSR	PC,MKLIST
	BR MARKV1

MARKV:	PUSH	A	;MARK VARIABLE
	SPUSH	B	;NODE ADDS IN B
	SPUSH	C
	CLR	A
	MOV	B,C
	JSR	PC,MARKF1	;TREAT POINTER AS A FIRST PTR
MARKV1:	SPOP C
	SPOP B
	POP A
MARKV2:	RTS PC

MARKF:	MOV A,C	;MARK FIRST OF A DATUM (NODE) IN A,,B
MARKF1:	BIT #DSAMFL,FLAGS2
	BEQ MARKF2	;DISK NOT ALMOST FULL
	TST SPMSWP	;TOP OF PDL SWAPED OUT FOR MARKING?
	BEQ MARKF4	;NO, JUST ERROR OUT
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;ACCESS BEG OF FILE
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>	;INPUT THE BLOCK IT WAS SAVES ON
	$BLKI
MARKF4:	CLR ERPROC
	.IFNZ NDISP
	ADD #2,S	;POP SNLIST OFF S PDL
	.ENDC
	ERROR+NSL
MARKF2:	ASH #-11.,C
	BIC #177741,C	;GET THE DATA TYPE
	JMP	@LMT(C)	;WHICH YOU MIGHT MARK ON

	.IFNZ NDISP
MKSNAP:	JSR	PC,MKDC	;MARK DISPLAY CODE
	.ENDC
MKLIST:	BIT	#7777,B	;IS THIS NODE REALLY HERE?
	BEQ	MARKV2	;NO. RETURN
MKL1:	PUSH	A	;SAVE BUTFIRST OF CURRENT (I.E. PARENT) NODE
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MKL2
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	JSR	PC,MARKBF	;MARK BUTFIRST OF  NEWTHIS NODE
MKL2:	POP A
	RTS PC

MKATOM:		;MARK ATOM CELL BUT NOTHING INSIDE IT
MKINUM:	JMP MARKNI

GCDIE:	ERROR+FBUG

MARKBF:	BIT	#7777,A	;MARK BUTFIRST OF LIST
	BEQ	MARKV2	;AT END OF LIST
MKBF1:	MOV	A,B
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MARKV2	;ALREADY MARKED, QUIT
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	BR	MARKBF	;MARK BUTFIRST OF  NEW NODE

GCOLL:.GCOLL:	JSR F,ACSAV
	PUSH GNCN
	SPUSH GNCN+2
	SPUSH TMPBLK
.GCOL2:	MOV #GCBITS,A	;GARBAGE COLLECT
	MOV #GCBTL/2-1,B	;CLEAR BIT TABLE
	MOV #1,(A)+	;ALWAYS PROTECT NODE ZERO
.GCOL1:	CLR (A)+
	DEC B
	BGT .GCOL1
;	CLR SSAVEA	;MAKE SURE THIS IS CLEAR
;NOW MARK EVERYTHING POINTED BY OBLIST.  DONT MARK OBLIST NODES YET
	JSR PC,GNOLEI
MKUOBJ:	JSR PC,GNOLE	;GET NEXT UOE PTR
	BEQ MKTPS
	MOV B,C
	JSR PC,.LOADC	;GET THE NODE
	MOV A,C
MKUOE:	BIT #7777,C	;ONE OTHER NODE?
	BEQ MKUOBJ	;NO
	MOV C,B	;YES
	JSR PC,MARKN	;MARK IT
	JSR PC,.LOADC
	MOV A,C
	BIC #7777,A
	CMP #FBIND,A
	BEQ MKFB	;FUNCTION BINDING
	CMP #VBIND,A
	BEQ MKVB	;VARIABLE BINDING
	CMP #ABIND,A
	BEQ MKARR
	CMP #SVBIND,A
	BEQ MKSVB	;SWAPPED VB
	.BUG.		;BUG
MKVB:	JSR PC,MARKV	;MARK VARIABLE
	BR MKUOE
MKFB:	JSR PC,MARKL
	BR MKUOE
MKSVB:	BR MKUOE
MKARR:	TSTB 5(B)	;IS IT A POINTER ARRAY?
	BNE MKUOE
	MOV B,F		;POINT TO BEG OF ARRAY
	MOV 2(B),-(P)	;PUSH COUNT
	SUB #HEADER,(P)
	ASR (P)
	ADD #HEADER,F
MKAR1:	MOV (F)+,B
	JSR PC,MARKV
	DEC (P)
	BNE MKAR1
	TST (P)+
	BR MKUOE

	;MARK FROM GCMKL LIST
MKTPS:	MOV #GCMKL,F
MKRNDM:	MOV (F)+,B	;POINTER TO POINTER
	BEQ MKSPDL	;LAST ONE
	MOV (B),B	;REAL NODE ADDRESS
	BEQ MKRNDM	;NOTHING THERE
	BIT #170000,B	;IS TYPE FIELD BLANK
	BEQ MKRND1	;YES, MAKE IT LIKE LIST
	JSR PC,MARKV	;MARK VARIABLE
	BR MKRNDM
MKRND1:	JSR PC,MKL1
	BR MKRNDM
;MARK FROM THE SYSTEM REDEFINED FUNCTION TABLE
.IFNZ JGB
	MOV #SYSHTB,E	;POINT TO START OF TABLE
	MOV #SYSHTL,F
MKJGB:	MOV (E)+,B	;GET A RANDOM POINTER
	JSR PC,MARKV	;MARK IT
	SOB F,MKJGB
.ENDC
MKSPDL:	MOV #IS,E
MKSP1:	MOV -(E),B	;GET A S PDL WORD
	CMP E,S	;END OF S PDL?
	BLO MKSP2	;YES
	JSR PC,MARKV	;MARK S PDL WORD
	BR MKSP1
MKSP2:	TST IS
	BEQ MKSP4
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;GO TO BEG OF FILE
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKO
	CLR SPMSWP
MKSP8:	ADD #2000,SPMSWP
	CMP SPMSWP,SPRBAO
	BHIS MKSP6	;NO
MKSP5:	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKI
	MOV #SSWPAD,E
	MOV #SPDLL/2,F
MKSP7:	MOV (E)+,B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	SOB F,MKSP7
	BR MKSP8

MKSP6:	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKI
	CLR SPMSWP
MKSP4:
;OK, NOW MARK ALL UOE'S THAT POINT TO FUNCION OR VARIABLE BINDING
	JSR PC,GNOLEI
MKOBL:	JSR PC,GNOLE	;GET NEXT UOE PTR IN B
	BEQ MKOBL6	;NONE LEFT
	MOV B,C
	JSR PC,.LOADC	;GET THE PNAME NODE
	MOV B,D
	BIT #7777,A	;DOES IT POINT TO ANYTHING?
	BNE MKOBL2	;YES, MARK IT
	MOV C,B	;NO WAS IT MARKED?
	JSR PC,MARKDN
	BEQ MKOBL3	;NO - LINK IT OUT
	BR MKOBL7	;YES - ALSO MARK PNAME & BUCKET PTR
MKOBL2:	; - MARK THE UOE ETC.
	MOV C,B	;  -THE UOE NODE
	JSR PC,MARKN
MKOBL7:	MOV D,B	;  -THE PNAME LSTR
	JSR PC,MARKL
	MOV GNCN+2,B	;  -THE BUCKET LIST NODE
	JSR PC,MARKN
	BR MKOBL
	;THIS UOE IS NOT MARKED AND POINTS TO NOTHING - LINK IT OUT
MKOBL3:	MOV TMPBLK,C	;GET PTR TO PREDECESSOR NODE
	BNE MKOBL4	;NONE, SO UHCT WAS PRED.
	MOV GNCN,-2(E)	;SO CHANGE IT
	BR MKOBL5
MKOBL4:	MOV GNCN,A	;CHANGE PTR IN PRED NODE
	JSR PC,.STP1
MKOBL5:	MOV C,GNCN+2	;SO GNOLE WILL WORK
	BR MKOBL
MKOBL6:



	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;IF GUY HAS DISPLAY
	BEQ	GCDIS2
	JSR PC,DSGCF		;GCOLL IT, TOO
GCDIS2:
GCDIS:
	.ENDC


		;OK NOW RETURN ALL IN MARKED NODES
		;RA ADDS OF LIT MAP
		;RB NODE ADDS
		;RC ACTUAL ADDER OF NODE
		;RD BIT MAP
		;RE POINT TO LIST OF FREE STORAGE RECYCLED NODES
		;RF NUMBER NODES LEFT TO CHECK
		;START COLLECTING AT LUNN(LOWEST UNPROTECTED NODE #)
	CLR E
	CLR NNGC
	MOV #NODESP,C	;NODE ZERO ADDRESS
	MOV NODTOP,F
	SUB C,F		;COMPUTE LEGNTH OF NODESP
	ASR F
	ASR F		;COMPUTE NUMBER OF NODES
	CLR B		;NODE ZERO
	MOV #GCBITS,A	;BIT TABLE ADDR
GCRT2A:	MOV (A)+,D	;GET NEXT WORD OF BIT MAP
	SEC
	ROR D

GCRT2:	BCS GCRT3
	CMP B,#LUNN
	BLOS GCRT3
	TST E		;WE HAVE A FREE NODE; IS FIRST FREE FOUND?
	BNE GCRT2B
	MOV B,FREE	;NO, THIS IS IT
	BR GCRT2C	;(NO LAST-FREE TO UPDATE)

GCRT2B:	BIS B,(E)	;ELSE: POINT LAST-FREE TO THIS NODE
GCRT2C:	MOV C,E		;THIS NODE IS NEW LAST-FREE
	MOV #IDLE,(C)+	;MAKE NEW IDLE NODE, POINTS NOWHERE
	CLR (C)+
	INC NNGC
	BR GCRT4
GCRT3:	CMP (C)+,(C)+
GCRT4:	INC B
	DEC F
	BLE GCRT5
	CLC
	ROR D
	BNE GCRT2
	BR GCRT2A
GCRT5:	MOV NNGC,NNIFSL
;DEBUGGING FEATURE
	BIT #PNNLF,FLAGS2
	BEQ GCRT6
	CPRTXT ^/[NODES LEFT /
	MOV NNGC,A
	JSR PC,PRDN
	PRTXTC ^/ ]/
;
GCRT6:
;	TST FILFLG
;	BEQ GCRT7	;NO
;	MOV #DREADC,E
;	JSR PC,GBITGS	;GET BACK THE BUFFERS
GCRT7:	POP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	CMP NNIFSL,#128.	;LESS THAN 1/2 BLOCK LEFT
	BHIS .+6
	JSR PC,EXNODE		;EXPAND NODE SPACE
	JSR F,ACRES
	SEZ
	RTS PC
	.STITL GET NEXT OBLIST ELEMENT
GNOLE:		;GET NEXT USER OBLIST ELEMENT - PTR
		;INPUT - VIA GNOLEI
		;OUTPUT - PTR TO THIS BUCKET IN B & GNCN
		;	   " " NEXT " " GNCN+2
		;	   " " PRED " " TMPBLK
		;	   IF NO PREV BUCKET, TMPBLK = 0
		;USES E.  SKIPS UNTIL NO UOE PTRS LEFT
	PUSH A
	MOV GNCN,B
	MOV GNCN+2,TMPBLK
GNOLE2:	MOV B,GNCN+2
	BIC #170000,B
	BEQ GNOLE1
	JSR PC,.LOAD	;GET NEXT PTR ON BUCKEN LIST
	MOV A,GNCN
	JMP SRETA
GNOLE1:	CLR TMPBLK
	MOV (E)+,B	;GET NEXT BUCKET LIST
	BGE GNOLE2
	JMP RETA	;DONE
GNOLEI:	MOV #UHCT,E
	CLR GNCN
	RTS PC
EXNODE:	MOV #NODEHP,A	;POINTER TO BLOCK
	JSR PC,EXSPAC	;TRY TO EXPAND NODE SPACE
	BEQ EXNOD1	;FAILED
	MOV NODTOP,A	;GET THE OLD TOP
	ADD #2000,NODTOP
	MOV A,B		;COPY TOP ADDRESS
	SUB #NODESP,B	;GET TOTAL LENGTH
	ASH #-2,B	;MAKE INTO NODE NUMBER
	BIS #IDLE,B	;IDLE NODE POINTER
	MOV FREE,(A)	;POINT AT OLD FREE LIST
	BIS #IDLE,(A)+	;MAKE SURE IT IS IDLE
	CLR (A)+	;ZERO SECOND WORD OF NODE
	MOV #377,C	;NUMBER OF NODES-1 CREATED
EXNOD2:	MOV B,(A)+	;POINT TO PREVIOUS FREE NODE
	CLR (A)+
	INC B		;POINT TO NODE JUST CLEARED
	SOB C,EXNOD2
	MOV B,FREE	;POINT TO THE END OF THE LIST WE JUST CREATED
	ADD #256.,NNIFSL	;MORE NODES IN FREE LIST
EXNOD1:	RTS PC		;LOSE OR WIN
.STITLE SYSTEM OBLIST SORT
SORT:	MOV #SOBLST+2,A	;POINTER TO START AT
	MOV #SOBLSU,B	;PLACE TO FINISH
	MOV PC,F	;SET "SOMETHING MOVED" FLAG
SORTUG:	TST F	;DID SOMETHING GET MOVED LAST PASS?
	BEQ SORTDN	;NO, WE ARE DONE
	CLR F	;NOTHING SO FAR THIS PASS
	MOV A,C	;POINTER INTO TABLE
SORTU:	MOV (C)+,D	;START OF SORT UP
	MOV (C),E	;THINGS TO SORT
	ADD #4+SOBLST,D	;GET TO STRING
	ADD #4+SOBLST,E	;FOR BOTH
SORTU3:	CMPB (D),(E)	;COMPARE THE WORDS
	BLT SORTU2	;IN ORDER, GO TO NEXT PAIR
	BEQ SORTU1	;SAME, CHECK NEXT WORD
	INC F	;HAVE TO SWITHC THEM
	MOV -(C),D
	MOV 2(C),(C)+
	MOV D,(C)
SORTU2:	CMP C,B	;ARE WE AT END?
	BNE SORTU	;NO, CONTINUE
	TST -(B)	;YES, NEXT TIME NOT SO FAR
	BR SORTDG	;GO TO DOWNWARD SORT
SORTU1:	TSTB (D)+
	BNE .+6	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
	TSTB (E)+
	BNE .+6
	MOV #ZERO,E
	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTU3	;OK, CONTINUE
	BPT	;BARF, THEY'RE EQUAL????
	BR SORTU3

SORTDG:	TST F	;DID WE MOVE ANY ON THE UP PASS?
	BEQ SORTDN	;NO,DONE
	CLR F	;CLEAR FLAG
	MOV B,C	;SET POINTER
SORTD:	MOV (C),D
	MOV -(C),E
	ADD #4+SOBLST,D
	ADD #4+SOBLST,E
SORTD3:	CMPB (D),(E)
	BGT SORTD2
	BEQ SORTD1
	INC F
	MOV (C)+,D
	MOV (C),-(C)
	MOV D,2(C)
SORTD2:	CMP C,A
	BNE SORTD
	TST (A)+
	BR SORTUG
SORTD1:	TSTB (D)+
	BNE .+6	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
	TSTB (E)+
	BNE .+6
	MOV #ZERO,E
	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTD3
	BPT
	BR SORTD3

SORTDN:	RTS PC
LOGEND=.
.IIF P2,PAD ^\LOGEND=\,\.
	.END START
