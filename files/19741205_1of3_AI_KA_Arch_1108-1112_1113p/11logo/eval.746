.STITL SYSTEM PRIMITIVES
	VERN==VERN+%FNAM2
.IFNZ ENG&FR
ENGLIS:ANGLAI:	MOV #ENGFLG,LANG
ENG1:	SEZ
	RTS PC
FRENCH:FRANCAIS:	MOV #PFRFLG!FRFLG,LANG
	BR ENG1
FRANGLAIS:	BIS #ENGFLG!FRFLG,LANG
	BR ENG1
.ENDC
;THIS IS THE STUFF FOR ARRAY HACKING

SETASZ:	JSR PC,G1NARG
	ASL B
	MOV ENDWLD,A
	SUB B,A		;COMPUTE NODTOP
	CMP #NODESP+400,A
	BLO .+4		;IS THIS POSSIBLE?
	ERROR+NAS	;NO
	MOV USER,A
	MOV B,UASIZE(A)
SEZWHO:	JMP HELLO	;REINITIALIZE USERS SLOT
AMAKE:	MOV 4(SP),D	;NO. OF ARGS
	ASL D
	ADD S,D
	MOV -(D),A	;ADDR OF ARRAY NAME
AMAKE5:	MOV A,B
	BIC #7777,A
	CMP #ATOM,A	;IS A TYPE ATOM?
	BNE AMAKE3	;NO
AMAKE4:	MOV #ABIND,A
	JSR PC,.BINDL
	BEQ AMAKE6
	CLR TOPS
	RTS PC
AMAKE3:	CMP #LSTR,A	;IS A TYPE LSTR?
	BNE AMAKE2	;YES
AMAKE1:	BIT #7777,B	;NULL POIMTER?
	BEQ AMAKE2	;YES
	MOV B,TOPS
	JSR PC,.OBSCH	;GET ATOM
	BNE AMAKE4
AMAKE6:	ERROR+UDA
AMAKE2:	ERROR+WTAB



ARRAD:	MOV B,E
	SPUSH E	;TOP OF ARRAY HEADER
	CMPB 4(E),F	;IS DIM=NO. OF INDICES?
	BEQ ARRAD1	;YES
	ERROR+WNA	;WRONG NO OF ARGS
ARRAD1:	CLR A	;TEMP ACCUMULATOR
	ADD #12,E	;LENGTH OF DIMENSION IN E
ARRAD2:	JSR PC,G1NARG	;GET INDEX OFF S-PDL
	CMP B,(E)	;INDEX IN BOUNDS?
	BGE ARRAD4	;NO
	TST B	;NEGATIVE INDEX?
	BGE .+4	;INDEX OK
ARRAD4:	ERROR+ROB
	ADD B,A
	DEC F
	BEQ ARRAD3	;MORE INPUT
	MUL -(E),A
	MOV B,A
	BR ARRAD2
ARRAD3:	SPOP E	;ADDR OF ARRAY HEADER
	TSTB 5(E)	;IS TYPE PTR?
	BEQ .+4
	ASL A
	ASL A		;TOTAL OFFSET (A*4)
	ADD #14,E	;ADDR OF FIRST VALUE
	ADD E,A		;ADDR OF VALUE TO BE STORED
	RTS PC


STORE:	JSR PC,AMAKE
	SPOP	A	;RETURRN ADDR
	SPOP F		;NO. OF ARGUMENTS
	SPUSH	A
	SUB #2,F
	POPS D		;VALUE TO BE STORED
	JSR PC,ARRAD	;FIND STORAGE LOCATION
	MOV A,F
	MOV -10(E),A
	MOV D,B
	BIC #7777,A
	BEQ STORE1
	JSR PC,CONVERT
	BNE .+4
	ERROR+WTAB
	JSR PC,.LOADB
	MOV A,(F)+
STORE1:	MOV B,(F)	;VALUE IS NOW STORED
	ADD #2,S
	SEZ
	RTS PC


GET:	JSR PC,AMAKE
	SPOP	A	;RETURN ADDR
	SPOP F	;NO. OF ARGUMENTS
	SPUSH	A
	DEC F		;NO. OF INDICES
	JSR PC,ARRAD	;COMPUTE STORAGE LOCATION
	MOV A,F		;STORAGE LOCATION ADDR IN F
	MOV (F),C
	TSTB -7(E)	;TEST TYPE
	BEQ GET1	;TYPE 0 (PTR)
	MOV (F)+,A
	MOV (F),B
	JSR PC,GRBAD	;STORES VALUE IN NODE SPACE
	MOV -10(E),D
	BIC #7777,D
	BIS D,C		;SET TYPE ON PTR TO VALUE
GET1:	MOV C,@S	;PTR ON TOP OF S-PDL
	CLZ
	RTS PC

LIMIT==3
HEADER==14
BKPTR==4
SIZE==2


	;INPUT--B HAS SIZE OF BLOCK TO BE ALLOCATED IN BYTES
	;OUTPUT--A HAS PTR.TO BLOCK IF ALLOCATION SUCESSFUL
	;        SECOND WORD OF BLOCK CONTAINS SIZE OF BLOCK IN BYTES
	;        AND SKIP RETURN


.ALLOC:	CMP	B,ASPACE	;SIZE OF ARRAY .LE. FREE SPACE?
	BLE	.+6		;YES
	SEZ
	RTS	PC		;NO,RETURN

	PUSH	C
	MOV	AROVER,A	;GET FRE BLOCK PTR.
SRCBLK:	CMP	B,SIZE(A)	;IS BLOCK NOW POINTED AT BIG ENOUGH?
	BLE	OKALOC		;YES
	CMP	@A,AROVER	;CHAIN GONE THRU' ONCE?
	BEQ	CMPRES		;YES
	MOV	@A,A		;NEXT FREE BLOCK
	BNE	SRCBLK		;LAST BLOCK IN CHAIN?
	MOV	AFREE,A		;YES,START FROM THE BEGINNING
	CMP A,AROVER
	BNE SRCBLK

CMPRES:	JSR	PC,.PRESS	;GO COMPRESS THE ARRAY SPACE
	MOV	AROVER,A	;A POINTS TO FREE SPACE
OKALOC:	MOV SIZE(A),C
	SUB B,C
	CMP #20,C
	BGE HOLE
	MOV	A,C		;TO ADDR.OF FREE BLOCK
	ADD	B,C		;ADD SIZE OF ALLOCATED BLOCK TO GET NEW FREE BLOCK ADDR.
	SUB	B,SIZE(A)	;GET SIZE OF NEW FREE BLOCK
	MOV	SIZE(A),SIZE(C)	;AND STORE IN SIZE FIELD OF NEW FREE BLOCK
	MOV B,SIZE(A)
	MOV	BKPTR(A),BKPTR(C)	;PTR. MANAGEMENT
	BEQ	NEWBK1		;IF THIS BLOCK FIRST OF CHAIN,SKIP
	MOV	C,@BKPTR(A)	;CHANGE FORWARD PTR. OF LAST BLOCK
NEWBK1:	MOV	(A),(C)		;FORWARD PTR. FOR NEW BLOCK
	BEQ	NEWBK3		;IF THIS BLOCK IS LAST IN CHAIN,SKIP
NEWBK2:	ADD	#BKPTR,@A	;TO ACCESS BKPTR FIELD OF NEXT BLOCK
	MOV	C,@(A)		;AND CHANGE IT
NEWBK3:	MOV	C,AROVER	;UPDATE FREE BLOCK ROVING POINTER
	CMP	AFREE,A		;REQUIRED TO UPDATE AFREE?
	BNE	ALDONE		;NO
	MOV	AROVER,AFREE	;YES
ALDONE:	SUB	SIZE(A),ASPACE	;UPDATE FREE SPACE AVAILABLE
	POP	C
	CLZ
	RTS PC
			;SKIP RETURN

HOLE:	MOV	BKPTR(A),C	;TO LINK UP WITH BLOCK BEFORE THE ONE ALLOCATED
	BNE	NEWBK1		
	MOV (A),C
	BR NEWBK3
	;RELEASE A BLOCK IN THE ARRAY SPACE
	;INPUT--B HAS PHYSICAL PTR TO BLOCK TO BE RELEASED
	;OUTPUT--B UNCHANGED. RELEASED BLOCK INSERTED INTO CHAIN OF FREE BLOCKS


.RELES:	ADD	SIZE(B),ASPACE	;UPDATE ASPACE
	TST	AFREE		;IS ARRAY SPACE EMPTY?
	BEQ	ONEBLK		;YES
	PUSH	A
	SPUSH	C
	SPUSH	D
	MOV	AROVER,C
	CMP	B,C		;ADDR OF RELEASED BLOCK > (AROVER)
	BHI CHAIN		;START TRYING TO INSERT AT AROVER
	MOV	AFREE,C		;OTHERWISE START AT AFREE
	CMP B,C
	BHI CHAIN
	MOV AFREE,A
	JSR PC,ONEBLK
	MOV B,C
	ADD SIZE(B),C
	CMP A,C
	BNE .RELE1
	MOV (C),(B)
	ADD SIZE(C),SIZE(B)
	BR REDONE
.RELE1:	MOV A,(B)
	MOV B,BKPTR(A)
	BR REDONE

CHAIN:	MOV	C,A		;A_CURRENT FREE BLOCK
	MOV	(A),C		;C_NEXT FREE BLOCK
	BEQ	LSTBLK		;CURRENT BLOCK IS LAST IN CHAIN
	CMP	C,B		;ADDR OF NEXT FREE > ADDR OF RELEASED?
	BLT	CHAIN		;NO,TRY NEXT ONE
	MOV	SIZE(B),D	;YES,START INSERTING THE RELEASED BLOCK
	ADD	B,D		;SIZE IN BYTESADDED TO (B) GIVES END OF RELEASED BLOCK
	CMP	C,D		;WHICH MIGHT BE ADJACENT TO NEXT FREE BLK
	BNE	LSTBLK		;NO
	ADD	SIZE(C),SIZE(B)	;YES,COLLAPSE THE TWO
	MOV	(C),C		;UPDATE FWDPTR

LSTBLK:	MOV	SIZE(A),D	;THIS FREE BLOCK 
	ADD	A,D		;MIGHT BE ADJACENT TO THE
	CMP	D,B		;RELEASED BLOCK
	BEQ	CONBLK		;YES
	MOV	C,(B)		;NO,JUST UPDATE PTR
	MOV	A,BKPTR(B)	;SIZE FIELD NEED NOT BE CHANGED
	MOV	B,(A)	
	TST	C		;IF THIS FREE BLOCK IS LAST IN CHAIN
	BEQ	REDONE		;THEN NOTHING
	MOV	B,BKPTR(C)	;ELSE UPDATE BKPTR OF NEXT BLK
REDONE:	POP	D
	SPOP	C
	SPOP	A
	RTS	PC

ONEBLK:	MOV	B,AFREE		;RELEASED BLOCK IS THE ONLY FREE ONE
	MOV	B,AROVER
	CLR	(B)
	CLR	BKPTR(B)
	RTS	PC


CONBLK:	ADD	SIZE(B),SIZE(A)	;COLLAPSE
	MOV	C,(A)		;AND UPDATE PTR
	BR	REDONE
	;THIS ROUTINE COMPRESS THE ARRAY SPACE BY STACKING FREE BLOCKS TOGETHER
	;AFREE POINTS TO FIRST FREE BLOCK IN THE CHAIN
	;FIRST WORD OF USED BLOCK MUST CONTAIN PTR. TO WORD POINTING TO THAT BLOCK FOR RELOCATING

.PRESS:	TST	AFREE		;ARE THERE ANY FREE BLOCKS?
	BNE	.+4		;YES
	RTS	PC		;NO,DONE
	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D

	MOV	AFREE,A		;A_FIRST FREE BLOCK ADDR
MOVNXT:	MOV	A,B		;B_CURRENT FREE BLOCK ADDR
	MOV	(B),A		;A_NEXT FREE BLOCK ADDR
	BEQ	PSDONE		;IF NEXT FREE BLOCK ADDR = 0,DONE
	MOV	SIZE(B),C	;FREE BLOCK SIZE IN BYTES
	ADD	B,C		;PLUS FREE BLOCK ADDR=STARTING ADDR OF USED BLOCK

COLAPS:	MOV	SIZE(C),D	;GET USED BLOCK SIZE
	ASR	D		;GET SIZE IN WORDS
	MOV	B,@(C)		;CHANGE PTRRR TO ARRAY		
	MOV	(C)+,(B)+	;BLOCK TRANSFER
	SOB	D,.-2		;COUNTER
	CMP	C,A		;THIS BLOC OF USED BLOCKS MOVED?
	BEQ	MOVNXT		;YES,MOVE NEXT BLOC
	BR	COLAPS		;NO,CONTINUE TO TRANSFER NEXT USED BLOCK

PSDONE:	SPOP	D
	SPOP	C
	SPOP	B
	SPOP	A
	MOV	ASPACE,SIZE(B)
	JMP	ONEBLK		;TAKE CARE OF AFREE AND RETURN
	;DEFINE AN ARRAY

DEFAR:	POP	A		;RETURN ADDR
	SPOP	F		;NO. OF ARGS PASSED
	SPUSH	A
	CMP	F,#LIMIT+2	;WHICH SHOULD BE < ALLOWABLE LIMIT
	BLE	OKARAY		;OKAY,THIS IS.
AERROR:	ERROR+WDIM
OKARAY:	SUB	#2,F		;DIMENSION OF ARRAY IN F
	MOV	F,A
	MOV	#1,D		;SET UP FOR MULTIPLICATION
	JSR	PC,G1NARG	;GET TYPE
	MOV	B,E		;SAVE IT
	TST	B
	BEQ	ALNUM		;0 FOR LNUM
	.IFNZ FPPF
	CMP	#1,B
	BEQ	AFNUM		;1 FOR FNUM
	.ENDC
	CMP #2,B
	BEQ NXTIDX	;2 FOR PTR
	ERROR+BAT
ALNUM:	BIS	#LNUM,F
	BR	NXTIDX
	.IFNZ FPPF
AFNUM:	BIS	#FNUM,F
	BR	NXTIDX
	.ENDC
NXTIDX:	JSR PC,G1NARG	;GET MAGNITUDE OF LAST DIMENSION
	PUSH	B		;SAVE THIS DIMENSION
	MUL	B,D		;D IS ODD
	BLE	AERROR		;DIMENSION < 0
	BCS	AERROR		;DIMENSION TOO BIG
	SOB	A,NXTIDX
	SPUSH	F		;SAVE DIMENSION OF ARRAY
	BIT	#160000,D	;SIZE SHOULD NOT BE TOO BIG
	BNE	AERROR
	CMP	#2,E		;IS THIS PTR ARRAY
	BEQ	.+4
	ASL	D		;THIS IS DOUBLE PRECISION ARRAY
	ASL	D		;TO CONVERT TO BYTES
	ADD	#HEADER,D
	SPUSH	D		;SAVE SIZE OF ARRAY BLOCK
	MOV	@S,B		;GET NAME OF ARRAY
	MOV	B,A		
	BIC	#7777,A		;SEE WHETHER IT HAS BEEN INTERNED?
	CMP	#ATOM,A		;BY TESTING ITS TYPE
	BEQ	FABIND		;YES
	CMP	#LSTR,A		;NO,IS NAME ALL RIGHT
	BEQ	.+4		;YES
	ERROR+WTAB
	MOV	B,TOPS
	JSR	PC,.INTRN	;INTERN NAME OF ARRAY
	MOV	B,@S		;SAVE UOE PTR
FABIND:	CLR	TOPS		;NOT TO CHANGE BINDING
	MOV	#ABIND,A	;SEE IF AN ARRAY IS
	JSR	PC,.BIND	;BINDED TO THIS NAME
	BEQ	GETSPA		;NO
	MOV	C,@S		,SAVE PTR TO BINDING NODE
	MOV	B,C
	MOV 2(C),B
	ADD	ASPACE,B	;ADDED TO AVAILABLE FREE SPACE
	CMP	B,@P		;IS SUM ENOUGH FOR NEW BINDING?
	BGE	ERAOLD		;YES
FULL:	ERROR+NAS		;NOT ENOUGH SPACE
ERAOLD:	MOV	C,B
	JSR	PC,.RELES	;RELEASE OLD BINDING

GETSPA: SPOP B	;GET SIZE OF ARRAY
	MOV B,D		;SAVE IT
	JSR	PC,.ALLOC	;ASSIGN SPACE
	BEQ	FULL		;NOT ENOUGH
	SPOPS	B		;UOE PTR
	MOV	A,TOPS		;ARRAY PTR
BINDA:	MOV	#ABIND,A
	JSR	PC,.BIND	;BIND NEW ARRAY
	BIC	#170000,C	;PTR TO BINDING NODE
	ASL	C
	ASL	C
	ADD	#NODESP+2,C	;THIS IS PHYSICAL ADDR OF BINDING NODE
	MOV	TOPS,A		;PTR TO ARRAY
	MOV	C,(A)+		;BACK PTR FIRST ENTRY IN HEADER
	MOV (A)+,D	;SIZE OF ARAY SECOND
	SPOP	F
	MOV	F,(A)+		;DIMENSION OF ARRAY THIRD
	ADD	#LIMIT*2,A	;TO ADVANCE (A)
	BIC	#177400,F	;GET DIMENSION PART
	MOV	F,E
	ASL	E		;TO GET IT INTO BYTES
	SUB	E,A		;FOR OFFSET INTO HEADER
POPDIM:	SPOP	(A)+
	SOB	F,POPDIM
	SUB #HEADER,D
	ASR D
	CLR (A)+	;ZERO ARRAY VALUES
	SOB D,.-2
	SEZ
	RTS	PC
ERARAY:	JSR	PC,GTUOEB	;GET NEXT TOKEN
	BNE	ERARA1
ERARA2:	CLR	TOPS
	MOV	#ABIND,A
	MOV	B,F
	JSR	PC,.BIND
	BEQ ERARAR
	JSR	PC,.RELES	;RELEASE ARRAY BLOCK
	MOV	F,B
	JSR PC,.UNBND
ERARAR:	SEZ
	RTS PC

ERARA1:	CMP	#UFUN,A
	BGT	.+4
	ERROR+ERW
	JSR	PC,CVSFLS
	MOV	#ATOM,A
	JSR	PC,.OBSCH
	BNE	ERARA2
ERARA3:	RTS PC


ERARAS:	JSR	PC,GNOLEI
ERARS1:	JSR	PC,GNOLE
	BEQ ERARAR
	MOV	B,F
	CLR	TOPS
	MOV	#ABIND,A
	JSR	PC,.BIND
	BEQ	ERARS1		;THIS NAME HAS NO ARRAY BINDING
	JSR	PC,.RELES	;RELEASE THIS ARRAYY
	MOV	F,B
	JSR	PC,.UNBND
	BR	ERARS1


;RETURNS SIZE OF ARRAY DIMENSIONS
ASIZEX:	MOV @S,A	;ARRAY NAME
	JSR PC,AMAKE	;FINDS TOP OF ARRAY SPACE
ASIZE2:	PUSH E
	MOV B,E
	MOVB 4(E),D	;TYPE/DIM WORD
	MOV D,F
	SPUSH D		;SAVE IT
	ASL D		;SETS UP OFFSET FOR DIMENSION WORD
	SUB D,E
	ADD #2,S	;POP OFF THE ARRAY NAME
	ADD #14,E	;ADDR. OF FIRST DIM.
ASIZE1:	MOV (E)+,B
	JSR PC,.CSNIN	;CONVERT TO INUM AND PUT IN NODE 
	SPUSHS C	;SAVE PTR ON S-PDL
	SOB F,ASIZE1	;CHECK FO MORE DIMS.
	SPOP D		;NO OF DIMS. IN D
	JSR PC,SENT.	;LINK DIMS. IN LIST
	POP E
	CLZ
	RTS PC


.IFNZ FPPF

;FLOATING POINT MACROS

.MACR FPUSH FF
	STF FF,-(P)
	JSR PC,PPUSHT
.ENDM


.MACR FPOP FF
	LDD (P)+,FF
	JSR PC,PPOPT
.ENDM

.ENDC





.IFZ FPPF


;SINGLE PRECISION ARITHMETIC ROUTINES

UPLUS:	CLZ	;UNARY PLUS - NOTHING TO DO
	RTS PC
UMINS:	JSR PC,G1IARG	;UNARY MINUS
	DPNEG	B,C
DONBC:	JMP	R1I.BC

SUM:
	EXCH (P),2(P)
	CLR	E
	CLR	F
	MOV	(SP)+,D	;NUMBER OF ARGS
	BLE	DIFF.2	;DONE
SUM.1:	JSR	PC,G1IARG	;GET 1 INTEGER
	DPADD	B,C,E,F
	DEC	D	;COUNTER
	BGT	SUM.1
	BR	DIFF.2	;DONE

DIFF:
	JSR	PC,G2IARG	;GET 2 INTEGERS
	DPSUB	B,C,E,F
DIFF.2:	CMP	E,#100000	;IS ANSWER = 100...00 ?
	BNE	DONEMP
	TST	F	;IF SO , THEN ERROR
	BNE	DONEMP
	ERROR+RTB	;SINCE THAT IS SMALLEST NEG NUMBER
DONEMP:	JMP	R1I.EF

PROD:
	EXCH (P),2(P)
	CLR	E
	MOV	#1,F
	MOV	(SP)+,D	;NUMBER OF ARGS
PROD.1:	DEC	D
	BLT	DONEMP	;DONE
	JSR	PC,G1IARG	;GET ONE ARG IN B
	JSR	PC,.DPMUL
	BNE PROD.1
	ERROR+RTB	;RESULT TOO BIG

MOD:
	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONBC
	ERROR+RTB

DIVDE:
DIV.1:	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONEMP
	ERROR+RTB


.ENDC


.IFNZ FPPF


;FLOATING POINT ARITHMETIC ROUTINES

ERRET:	ERROR+RTB
UPLUS:	CLZ
	RTS PC
UMINS:	MOV #INUM,F
	JSR PC,G1ARG
	LDD FA,FB
	NEGF FB
	BR .FSTOR	;STORE FB
DIFF:	JSR PC,G2ARG	;LOAD FA AND FB
	SUBF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
SUM:	EXCH (P),2(P)
	MOV #INUM,F
	CLRF FB
	SPOP D		;SET UP COUNTER
	BLE .FSTOR
SUM.1:	JSR PC,G1ARG	;GET A NUMBER
	ADDF FA,FB	
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT SUM.1	;ADD MORE NUMBERS
	BR .FSTOR	;DONE AT LAST
PROD:	EXCH (P),2(P)
	MOV #INUM,F
	LDCFD #40200,FB	;LOAD CONSTANT "1"
	SPOP D
	BLE .FSTOR	;DONE ALREADY
PROD.1:	JSR PC,G1ARG
	MULF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT PROD.1	;LOOK AT COUNTER

;THIS TAKES A NUMBER OUT OF FB AND
;CONVERTS IT ACCORDING TO TYPE IN REG F (INUM,FNUM)
;AND RETURNS

.FSTOR:CMP #FNUM,F	;FNUM OR INUM?
	BEQ .FST.2
	STCFI FB,-(P)	;PUT INUM ON STACK
	BCS ERRET	;OVERFLOW?
.FST.1:	SPOP A
	SPOP B
	JSR PC,GRBAD	;STORE ANSWER
	BIS F,C		;SET TYPE
	JMP ORTC
.FST.2:	STCDF FB,-(P)	;PUT FNUM ON STACK
	JMP .FST.1
DIVDE:	JSR PC,G2ARG	;GET ARGS
	TSTF FA		;TEST ZERO DIVIDE
	CFCC
	BEQ ERRET	;IT WAS!!??
	DIVF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
MOD:	JSR PC,G2ARG	;GET ARGUMENTS IN FA AND FB
	SPUSH #.FSTOR
.MOD:	TSTF FA		;IS FA 0?
	CFCC
	BEQ ERRET	;IT IS??
	LDD FB,FC	;FC <- FB
	DIVF FA,FC	;FC <- (FB/FA)
	CFCC
	BVS MOD2	;THE ANSWER IS 0
	MODD #40200,FC	;SEPERATE INTEGER AND FRACTION PARTS
	MULF FA,FD	;FD <- FA * (INT (FB/FA))
	SUBF FD,FB	;FB <- MOD (FB,FA)
MOD1:	CFCC
	BGE MOD3	;IS IT POSITIVE?
	ADDF FA,FB	;NO, ADD FA
	BR MOD1
MOD2:	CLRF FB
MOD3:	RTS PC
.ENDC





SENTENCE:
	SPOP EXCH1
	MOV (SP),D
	MOV EXCH1,(SP)	;# OF ARGS . DON'T CHANGE FROM D WITHOUT CHANGING SNAP!!!!
SENT.:	CLR	C
	TST	D
SENT.1:	BLE	SENT.R	;RETURN
	MOV	@S,B	;ARGUMENT.  LEAVE ON S-PDL FOR GARBGE COLLECTOR
	MOV	B,A
	BIC	#7777,A	;LEAVE ONLY DATA TYPE
	CMP	#LIST,A
	BEQ	SENT.S	;ARG IS LIST
	CMP	#ATOM,A
	BNE	SENT.2	;ARG IS LSTR OR INUM

;ARG IS AN ATOM
SENT.A:	JSR	PC,.LOAD	;CONVERT ATOM TO LSTR
	MOV	#LSTR,A

SENT.2:	BIS	C,A	;C POINTS TO PREVIOUS STUFF OF SENTENCE
	JSR	PC,GRBAD

SENT.3:	MOV	C,GCPREV	;POINTER TO PREVIOUS STUFF OF SENTENCE
	BIS	#LIST,GCPREV	;GARBAGE COLLECTOR NEEDS RIGHT DATA TYPE
SENT.4:	JSR	PC,SPOPT	;POP S
	DEC	D	;COUNTER
	BR	SENT.1

SENT.S:	BIT	#7777,B	;ARGUMENT IS A LIST
	BEQ	SENT.4	;EMPTY
	TST	C	;0 IF FIRST TIME CALLED
	BEQ	SENS.1	;NO NEED TO COPY
;SECOND OR LATER TIME THROUGH
SENS.2:	JSR	PC,COPYL	;COPY LIST. RETURN POINTER IN B
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;C STILL POINTS TO LAST NODE COPIED
SENS.1:	BIC	#170000,B	;LEAVE POINTER ONLY
	MOV	B,C
	BR	SENT.3

;RETURN.  POINTER TO SENTENCE IN C
SENT.R:	BIS	#LIST,C
	CLR	GCPREV
	PUSHS	C
	CLZ
	RTS	PC



LIST.P:
	EXCH (P),2(P)
	MOV	(SP),D	;COUNT
	MOV	#ORTC,(SP)	;RETURN ADDRESS
LIST1:	CLR	C
LIST.1:	DEC	D	;COUNT
	BLT	LIST.9	;DONE
	MOV	@S,B
	MOV	B,A
	BIC	#7777,A	;LEAVE DATA TYPE ONLY
LIST.2:	BIS	C,A	;POINTER TO REST OF LIST
	JSR	PC,GRBAD
	MOV	C,GCPREV	;PROTECT FROM GARBAGE COLLECTOR
	BIS	#LIST,GCPREV	;GAR. COLL. NEEDS RIGHT DATA TYPE
	JSR	PC,SPOPT
	BR	LIST.1	;GET NEXT ARG

LIST.9:	CLR	GCPREV
	BIS	#LIST,C
	RTS	PC


FPUT:
	CLR	F
	BR	.+6
LPUT:
	MOV	#<LPUT1-FPUT1>,F
	EXCH (P),2(P)
	MOV	(SP),D	;NUMBER OF ARGS
	MOV	#ORTC,(SP)	;RETURN ADDRESS
	DEC	D
	BGT	.+4
	ERROR+UEL	;NEED AT LEAST 2 ARGS
	JSR	PC,GLWARG
	BEQ	.+4	;LIST
	ERROR+WTA	;FIRST ARG MUST BE LIST
	ADD	F,PC	;CHOOSE BETWEEN LPUT AND FPUT

FPUT1:	MOV	B,A	;POINTS TO ARG
	BIC	#170000,A	;CLEAR DATA TYPE
	JSR	PC,SPOPT
	MOV	@S,B	;FIRST ELEMENT TO BE PUT
	MOV	B,C
	BIC	#7777,C	;THIS DATA TYPE WILL BE SET INTO A
	DEC	D
	BR	LIST.2

LPUT1:	JSR	PC,COPYL	;COPY LIST. RETURN PTR IN B
	MOV	B,GCP1
	JSR	PC,SPOPT	;POP 1ST ARG
	JSR	PC,LIST1	;LIST REST OF ARGS
	TST F
	BEQ LPUT2
	BIC	#170000,C	;POINTER TO THAT LIST
	MOV	C,D	;SAVE IT
	MOV	F,C	;POINTER TO LAST NODE OF COPIED LIST
	JSR	PC,.LDP1
	BIS	D,A	;JOIN COPIED LIST TO LIST OF ARGS
	JSR	PC,.STP1
	MOV	GCP1,C
LPUT2:	CLR	GCP1
	RTS	PC


WORD:
	EXCH (P),2(P)
	CLR	C
	MOV	(SP)+,D	;NUMBER OF ARGS
WORD.1:	BLE	WORDR
	MOV	@S,B	;GET ARG,  BUT LEAVE ON STACK

.IFZ FPPF
	CMP	B,#LNUM	;IS ARG NUMBER?
	BLO	WORD.2
	CMP	B,#<LNUM+10000>
	BLO	WORD.N	;NUMBER
.IFF
	MOV B,A		;DOES B POINT TO INUM OR FNUM
	BIC #170000,A
	CMP #INUM,A
	BEQ WORD.N
	CMP #FNUM,A
	BEQ WORD.N
.ENDC

WORD.2:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE .+4
	ERROR+WTAB
	BIT	#7777,B	;IS ARG THE EMPTY WORD
	BEQ	WORD.4	;YES

	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3

;SECOND OR LATER ARG
WORD.5:	JSR	PC,CPYSTR	;COPY STRING
WORD.6:	JSR	PC,.LDP1	;LAST NODE OF COPIED STRING
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;BIS POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;STORE BACK

WORD.3:	BIC	#170000,B
	BIS	#LSTR,B	;GAR. COLL. NEEDS RIGHT DATA TYPE
	MOV	B,GCPREV	;POINTER TO PREVIOUS STUFF
WORD.4:	JSR	PC,SPOPT	;POP S
	DEC	D
	BR	WORD.1

;ARGUMENT IS NUMBER. CONVERT TO STRING
WORD.N:
.IFZ FPPF
	JSR PC,.CINLS
.IFF


.CLNLS:	MOV B,A
	BIC #170000,A
	CMP #INUM,A
	BEQ .CLNL1
	JMP .CINLS
.CLNL1:	JMP .CFNLS
.ENDC
	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3	;IS FIRST ARG
	BR	WORD.6	;SECOND OR LATER, BUT DON'T RECOPY!!

;RETURN
WORDR:	MOV	GCPREV,C
	BIS	#LSTR,C
	CLR	GCPREV
	JMP	ORTC



FIRST:
	JSR	PC,GLWANE
	BEQ	F.SENT	;ARG IS SENTENCE

;ARG IS WORD
	JSR	PC,INSTR	;RETURN ONE CHAR IN D
	BNE	.+4	;FOUND A CHAR
F.WTA:	ERROR+WTA	;NO CHARS IN STRING
	TST	(SP)+	;POP OFF CO-ROUTINE LINK
	MOV	D,B
F.STOR:	CLR	F
	JSR	PC,ACTSTO	;STORE THE CHAR.
	POPS C
	BIC #170000,C
	BIS	#LSTR,C	;POINTER TO THE NODE OF THE CHAR
	JMP	ORTNC

F.SENT:	MOV	B,C
	JSR	PC,.LDP2
	JMP	ORTNA


BUTFIRST:
	JSR	PC,GLWANE
	BEQ	BF.SEN

;ARG IS WORD
BF.W:	JSR	PC,INSTR	;RETURN ONE CHAR
	BEQ	F.WTA	;NO CHARS IN STRING
	TST	(SP)+
;A CONTAINS FIRST 2 CHARS OF THE STRING
;BUT IT MAY ONLY HAVE ONE.
	BIT	#177,A	;IS TOP CHAR OF A 0?
	BEQ BF.W1
	BIT #77400,A
	BEQ	BF.W1	;YES. ONLY ONE CHAR IN A
	CLRB	A	;KILL THE FIRST CHAR
	MOV	A,B
	MOV	C,A	;POINTER TO REST
	JSR	PC,GRBAD
BF.W1:	BIC	#170000,C
	BIS	#LSTR,C
	JMP	ORTNC

;ARG IS SENTENCE
BF.SEN:	MOV	B,C
	JSR	PC,.LDP1	;POINTER TO REST OF SENTENCE
	BIC	#170000,A	;LEAVE ONLY POINTER
	BIS	#SENT,A
	JMP	ORTNA


LAST:
	JSR	PC,GLWANE
	BEQ	L.SENT	;ARG IS SENTENCE

;ARG IS WORD
	MOV	B,C
	SPUSH	#INSTR1	;ADDRESS OF CO-ROUTINE
	CLR	D
L.W1:	MOV	D,B	;SAVE LAST CHAR
	JSR	PC,@(SP)+	;RETURNS CHAR IN D
	BNE	L.W1	;FOUND ONE
	TST	B	;STRING DONE
	BNE	F.STOR	;STORE THE CHAR AND RETURN
	ERROR+WTA	;NO CHARS FOUND

L.SEN1:	MOV	A,B
;ARG IS SENTENCE
L.SENT:	JSR	PC,.LOAD
	BIT	#7777,A	;LAST NODE OF SENTENCE YET?
	BNE	L.SEN1

L.SRET:	JMP	ORTNB


BUTLAST:
	JSR	PC,GLWANE
	BEQ	BL.SEN	;ARG IS A SENTENCE

;ARG IS A WORD
	JSR	PC,CPYSTR	;COPY STRING.
	JSR	PC,.LDP2	;LAST NODE OF NEW STRING
	SWAB	A
	BNE	BL.W2	;THE LAST CHARACTER IS REALLY THERE
	CLR	A	;(WE KNOW THE FIST CHAR IS REALLY THERE)
	CMP	B,C	;IS THERE ONLY ONE NODE
	BNE	BL.W1	;MORE TAN ONE NODE
	CLR	B	;ANSWER IS EMPTY WORD
	BR	BL.W3

BL.W2:	CLRB	A	;CLEAR LAST CHAR
BL.W1:	JSR	PC,.STP2	;STORE NODE BACK
BL.W3:	BIS	#LSTR,B	;POINTER TO THE WORD
BL.ORT:	JMP	ORTNB

;ARG IS A SENTENCE
BL.SEN:	JSR	PC,COPYL	;COPY LIST
	MOV	E,C	;POINTS TO NEXT TO LAST NODE
	BEQ	BL.SR	;ANSWER IS EMPTY
	JSR	PC,.LDP1
	BIC	#7777,A
	JSR	PC,.STP1
	MOV	B,C
BL.SR:	BIS	#LIST,C
	JMP	ORTNC


;INPUT IS NUMBER. OUTPUT IS THE CHARACTER CORRESPONDING TO THAT NUMBER

CHAR:	JSR	PC,G1IARG	;B,,C _ NUMBER
	MOV	C,B
	BIC	#177600,B
	MOV	#SSTR,A
	JSR	PC,GRBAD
	BIS	#LSTR,C
	JMP	ORTC


COUNT:
	JSR	PC,GLWARG
	BEQ	CT.SEN

;ARG IS WORD
	MOV	B,C
	CLR	B
	MOV	#INSTR1,-(SP)	;ADDRESS OF A CO-ROUTINE
CT.W1:	INC	B	;INCREMENT COUNTER
	JSR	PC,@(SP)+	;RETURNS CHAR IN B
	BNE	CT.W1
	DEC	B	;WHEN RETURNS HERE, NO MORE CHARS
CT.ORT:	POPS C
	JMP R1NARG	;C IS A THROW-AWAY

;ARG WAS A SENTENCE
CT.SEN:	MOV	B,C
	JSR	PC,CLE	;RETURNS NUMBER OF LIST ELEMENTS IN B
	BR	CT.ORT


;COPY LIST.
;	CALL WITH B POINTING TO LIST
;	RETURNS B POIOTING TO NEW LIST, C POINTING TO LAST NODE
COPYL:	CLR	E	;WILL POINT TO 2ND NODE FROM LAST
	CLR	F
	BIT #7777,B
	BEQ COPYR1
COPYL1:	BIT	#7777,B
	BEQ	COPYLR	;DONE
	JSR	PC,.LOAD
	MOV	F,E	;LISTB PLACES  LAST NODE PTR INTO F
	JSR	PC,LISTB
	MOV	A,B
	BR	COPYL1

COPYLR:	MOV F,C	;LISTB KEEPS PTR TO LAST NODE OF LIST IN F
	POPS	B	;LISTB KEEPS POINTER TO NEW LIST ON S.
COPYR1:	RTS	PC


;COPY STRING
;CALL WITH B POINTING TO STRING TO BE COPIED,
;ASSUMES THAT INPUT STRING HAS BEEN GARBAGE COLLECT PROTECTED ALREAEDY
;B POINTS TO FIRST NODE OF NEW STRING,  C POINTS TO LAST

CPYSTR:	MOV	#INSTR,A
MAKSTR:	MOV	D,-(SP)
	MOV	E,-(SP)
	MOV	F,-(SP)

	MOV	A,-(SP)	;ADDRESS OF INPUT STRING ROUTINE
	CLR	F

OUTSTR:	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE1	;INPUT STRING DONE

OSTR1:	MOV	D,B	;SAVE CHARACTER
	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE2	;INPUT STRING DONE

OSTR2:	SPUSH	A	;SAVE REGISTERS USED BY INPUT STRING
	SWAB	D
	BIS	D,B	;BIS SECOND CHARACTER
	JSR	PC,ACTSTO	;ACTUAL STORE
	SPOP	A
	BR	OUTSTR

;INPUT STRING HAS ENDED
OSTRE2:	JSR	PC,ACTSTO	;STORE CHAR IN B
OSTRE1:	POPS	B	;POINTER TO FIRST NODE OF STRING
	MOV	F,C	;POINTER TO LAST NODE
	BIC	#170000,B
	BIC	#170000,C
.RDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	SEZ
OSTRR:	RTS	PC


;ACTUALLY STORE OUTPUT NODE
ACTSTO:	MOV	#SSTR,A
	JMP	LISTB


;INPUT STRING
;A CO-ROUTINE THAT HANDS BACK A CHARACTER IN BOTTOM BYTE OF D
;DOES RTS PC WHEN INPUT STRING FINISHED

INSTR:	MOV	B,C
INSTR1:	BIT	#7777,C
	BEQ	OSTRR	;RTS PC
	JSR	PC,.LDP2I
	MOVB	A,D
	BIC	#177600,D	;CLEAR TOP BYTE
	BEQ	INSTR2	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE

INSTR2:	CLRB A
	SWAB	A
	MOV	A,D
	BIC #177600,D
	BEQ	INSTR1	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE
	BR	INSTR1


;LIKE INSTR, EXCEPT GETS CHAR FROM TEXT STRING (NOT NODE SPACE)
;NOTE -- ENTER AT INTXT
INTXT0:	JSR	PC,@(P)+
INTXT:	MOVB	(C)+,D
	BNE	INTXT0	;BR IF NOT END OF TEXT
	RTS	PC

MAKE:	BIC #MMF,FLAGS2
	BR .+10
MMAKE:	BIS #MMF,FLAGS2
	POPS TOPS	;PUT VALUE INTO TOPS
	MOV @S,B
	MOV B,A
	BIC #7777,A
	CMP #ATOM,A	;IS TYPE ATOM?
	BNE MAKE2
MAKE4:	MOV #VBIND,A	;YES< SET VARIABLE BINDING?
	JSR PC,.BIND
	BIT #MMF,FLAGS2	;IS IT MULTIPLE MAKE?
	BEQ MAKE1
	MOV TOPS,@S
	CLR TOPS
	CLR TOPS1
	CLZ
	RTS PC
MAKE1:	POPS A
	CLR TOPS
	CLR TOPS1
	RTS PC
MAKE2:	CMP #LSTR,A
	BEQ MAKE3
MAKE5:	ERROR+WTAB	;WRONG TYPE OF ARG
MAKE3:	BIT #7777,B
	BEQ MAKE5
	MOV TOPS,@S
	MOV B,TOPS	;FOR .INTRN
	JSR PC,UINTRN	;.INTRN FOR STRINGS THAT MAY INCLUDE NULL CHARS
	MOV @S,TOPS
	BIS #ATOM,B
	MOV B,TOPS1
	BR MAKE4

DOTS:	JSR PC,GETVAL	;GET VALUE IF IT HAS ONE
	BNE .+4
	ERROR+HNV	;HAS NO VALUE
	PUSHS B
	CLR TOPS
	CLZ
	RTS PC

THINGP:	JSR PC,GETVAL	;DOES IT HAVE A VALUE?
	BEQ THNGPF	;NO
	JMP RTTRUE
THNGPF:	JMP RTFALS

GETVAL:	JSR PC,GUOEB	;GET UOE PTR FROM S INTO B
	BEQ GETVA1
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ GETVA1
	TST B
GETVA1:	RTS PC		;HAS NO VALUE (UNBOUND LOCAL)
GUOEB:	POPS B	;GET UOE OR LSTR IN B FROM S
	MOV B,A	;    SKIP IF UOE
	BIC #7777,A
	CMP #ATOM,A
	BEQ GUOE1
	CMP #LSTR,A
	BEQ GUOE2
	ERROR+WTAB	;.(B). ISWRONG TYPE OF ARG
GUOE2:	MOV B,TOPS
	JMP UOBSCH	;.OBSCH FOR STRINGS THAT HAVE NULL CHARS
GUOE1:	CLZ
	RTS PC
		;PRINT TOP (C) THINGS ON S
FPRINT:	INC NBKTS	;PRINTS OUTER [,]'S
PRINT:	EXCH (P),2(P)
	JSR	PC,REVS	;DOESNT "
	POP	C
	JSR	PC,TYPE1
	JSR	PC,.CRLF
	SEZ
	RTS PC

TYPE:	EXCH (P),2(P)
	JSR	PC,REVS
	POP	C
	JSR	PC,TYPE1	;PRINT WITHOUT CRLF AT END
	SEZ
	RTS PC

TYPE1:	BIS #DPQF+CPTBF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
			;BUT DO  PRINT % AS BLANK
	JSR PC,PRS1
	POPS A
	DEC C
	BGT	TYPE1
	BIC #DPQF+CPTBF,FLAGS2
	RTS	PC

;PREDICATES

EQUAL:	MOV	S,F
	MOV	(F)+,B	;ARG1.  LEAVE ON STACK FOR GC PROTECTION
	MOV	(F),C	;ARG2
	JSR	PC,EQUAL1
	BEQ	EQ.F	;RETURNS HERE IF FALSE
	ADD #4,S
	JMP RTTRUE
EQ.F:	ADD #4,S
	JMP RTFALS


;COMPARE THE DATA ITEM POINTED TO BY B WITH
;THE DATA ITEM POINTED TO BY C.
;SKIP IF THEY ARE EQUAL
EQUAL1:	MOV #7777,E	;AN OFT-USED CONSTANT
	MOV B,A
	MOV C,D
	BIC E,A
	BIC E,D
	CMP A,D
	BNE WEQUAL
	CMP #LIST,A
	BNE WEQUAL
EQ.LST:	BIC #170000,B
	BIC #170000,C
	CMP B,C
	BEQ EQTRUE
	TST B
	BEQ EQFALS
	TST C
	BEQ EQFALS
	JSR PC,.LOAD
	PUSH A
	JSR PC,.LDP2I
	SPUSH C
	MOV A,C
	JSR PC,EQUAL1
	BEQ EQ.FF
	POP B
	SPOP C
	BR EQ.LST

	FOR 0
EQUAL1:	CMP	B,C	;ARE THE POINTERS THE SAME
	BEQ	EQTRUE
	MOV	B,A
	JSR	PC,EQ.SUB	;IS ARG1 A WORD?
	BNE	EQ.W1	;A WORD
	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BNE	EQFALS	;ARG1 ISN'T WORD, BUT ARG2 IS.
;BOTH ARGS ARE LISTS
EQ.LST:	JSR	PC,.LOAD	;FIRST NODE OF ARG1
	PUSH	A	;SAVE POINTER TO BF
	JSR	PC,.LDP2I	;FIRST NODE OF ARG2
	SPUSH	C	;SAVE POINTER TO BF
	MOV	A,C	;POINTER TO FIRST OF ARG1
;B POINTS TO FIRST ARG2.  C POINTS TO FIRST ARG1.
	JSR	PC,EQUAL1	;ARE THE FIRSTS EQUAL?
	BR	EQ.FF	;NO.  RETURN FALSE
	POP	B	;POINTER TO BF
	SPOP	C	;POINTER TO BF OF OTHER ARG
	BIC	#170000,B
	BIC	#170000,C
	CMP	B,C
	BEQ	EQTRUE
	JSR	PC,EQ.LST	;ARE THE BF'S EQUAL?
EQFALS:	RTS	PC	;NO
EQTRUE:	CLZ
	RTS PC	;YES


EQ.SB1:	MOV	C,A	;IS ARG A WORD?
EQ.SUB:	BIT	E,A	;EMPTY?
	BEQ	EQFALS	;ONE ARG FINISHED
	BIC	E,A
	CMP	#SENT,A
	RTS	PC

;ARG1 IS A WORD
EQ.W1:	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BEQ	EQFALS	;NOT A WORD
;FALLS INTO WEQUAL
	.ENDC
	ENDC 0
EQ.FF:	CMP	(SP)+,(SP)+	;POP OFF THE POINTERS TO THE BF'S
	JSR PC,PPOPT
	SEZ
	RTS PC

;COMPARE TWO WORDS

.IFZ FPPF

WEQUAL:	MOV	#INUM,A
	JSR	PC,CONVERT	;TRY CONVERTING ARG TO INUM
	BEQ	EQ.STR	;NOT NUMERIC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG
	BEQ	EQFALS	;NOT NUMERIC
	JSR	PC,.LOAD	;A,,B HAVE NUMBER
	MOV	A,D
	MOV	B,F
	JSR	PC,.LOADC
	CMP	A,D	;COMPARE 2 INTEGERS
	BNE	EQFALS
	CMP	B,F
	BNE	EQFALS
	BR	EQTRUE
.IFF

WEQUAL:	JSR PC,G1NUMS	;IS IT A NUMBER?
	BEQ EQ.STR
	LDD FA,FB	;IT WAS SO SAVE IT
	MOV C,B		;IS THE SECOND A NUM?
	JSR PC,G1NUMS
	BEQ EQFALS
	CMPF FA,FB	;COMPARE THEM
	CFCC
	BNE EQFALS
	BR EQTRUE

.ENDC


;ARG NOT NUMERIC.  TRY STRING COMPARE
EQ.STR:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BEQ EQFALS	;EQUAL NOT DEFINED FOR SNAPS, ETC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG, TOO
	BEQ	EQFALS	;NOT SAME TYPE AS FIRST ARG
	CMP	B,C
	BEQ	EQTRUE

;COMPARE TWO STRINGS.  POINTERS IN B AND C.
	SPUSH	#INSTR1
	MOV	C,GCP2
CMPSTR:	MOV	B,GCP1
	MOV	B,F
CMPST1:	BIT	E,F	;IS ARG 1 ENDED
	BEQ	CMPSTE	;YES
	SPUSH	A	;SAVE A
	MOV	F,B	;POINTER TO REST OF ARG1
	JSR	PC,.LOAD
	MOV	A,F	;POINTER TO REST OF ARG1
	SPOP	A	;RESTORE A
	BICB #200,B	;IS CHAR REAL OR NULL?
	BEQ	CMPST2	;NULL
	JSR	PC,@(SP)+	;PUTS 1 CHAR OF ARG 2 INTO B
	BEQ	CSFAL1	;ARG 2 ENDED
	CMPB	D,B	;COMPARE CHARS!!
	BNE	CSFALS
CMPST2:	SWAB	B
	BIC #177600,B
	BEQ	CMPST1	;NULL CHAR
	JSR	PC,@(SP)+	;1 CHAR OF ARG 2 IN B
	BEQ	CSFAL1
	CMPB	D,B	;COMPARE CHARS!!
	BEQ	CMPST1
CSFALS:	TST	(SP)+	;POP CO-ROUTINE LINKAGE
CSFAL1:	CLR	GCP1
	CLR	GCP2
EQFALS:	SEZ
	RTS PC

;ARG 1 HAS ENDED
CMPSTE:	JSR	PC,@(SP)+
	BNE	CSFALS	;BUT ARG 2 HASN'T ENDED
	CLR	GCP1
	CLR	GCP2
EQTRUE:	CLZ
	RTS PC	;BOTH ENDED AT THE SAME TIME!!!!



;CALL WITH B = POINTER TO STRING IN NODE SPACE
;	C = POINTER TO STRING IN DATA SPACE
EQ.TXT:	SPUSH	#INTXT	;ADDRESS OF CO-ROUTINE
	MOV	#7777,E	;AN OFT USED CONSTANT
	BR	CMPSTR



;MORE PREDICATES

GREATR:	JSR PC,CMP2IA
	BGT RTTRUE
RTFALS:
LANGC	<PUSHS #FALSE>,<
	PUSHS #FAUX>
RTNCMP:	CLZ
	RTS PC

LESSP:
LESS:	JSR PC,CMP2IA
	BGE RTFALS
RTTRUE:
LANGC	<PUSHS #TRUE>,<
	PUSHS #VRAI>
	BR RTNCMP

GREQ:	JSR PC,CMP2IA
	BGE RTTRUE
	BR RTFALS

LSEQ:	JSR PC,CMP2IA
	BLE RTTRUE
	BR RTFALS

NUMBP:	POPS B
 	MOV #INUM,A
	JSR	PC,CONVERT
.IFZ FPPF
	BEQ	RTFALS	;COULDN'T CONVERT IT
	BR RTTRUE
.IFF
	BNE RTTRUE
	MOV #FNUM,A
	JSR PC,CONVERT
	BEQ RTFALS
	BR RTTRUE
.ENDC

EMPTYP:	POPS B
	BIT	#7777,B
	BEQ	RTTRUE
	BR	RTFALS

LISTP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTTRUE
	BR	RTFALS

WORDP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTFALS
	BR	RTTRUE

.IFZ FPPF

;COMPARE TWO INTEGER ARGUMENTS
CMP2IA:	JSR	PC,G2IARG
;COMPARE 2 INTEGERS IN B,,C & E,,F
.ENDC
CMP2I:	CMP	E,B
	BNE	CMP2IR	;CONDITION CODES SET CORRECTLY
	CMP	F,C
	BEQ	CMP2IR
	BHI	CMP2IH
;E,,F < B,,C
	CMP	#0,(PC)
	RTS	PC
CMP2IH:	TST	(PC)
CMP2IR:	RTS	PC





.IFNZ FPPF


;GET AND COMPARE TWO (FNUM OR INUM) ARGS


CMP2IA:	SPUSH A
	JSR PC,G2ARG
	SPOP A
	CMPF FB,FA
	CFCC
	RTS PC

INTEGER:
	MOV @S,B
	MOV #INUM,A
	JSR PC,CONVERT
	BNE .+4
	ERROR+WTA
	MOV B,@S
	CLZ
	RTS PC


.ENDC


NOT:	JSR	PC,TSTST	;TEST S SKIP IF TRUE
	BEQ	RTTRUE
	BR	RTFALS

BOTH:	JSR	PC,TSTST
	BNE EITH1
	JSR PC,SPOPT
BOTH1:	BR RTFALS
EITH1:	JSR	PC,TSTST
	BEQ	BOTH1
	BR	RTTRUE	;BOTH ARE "TRUE !!

EITHER:	JSR	PC,TSTST
	BEQ	EITH1	;IS 2ND ONE "TRUE?
	JSR	PC,SPOPT	;POP 2ND ARG
	BR	RTTRUE
TEST:	JSR PC,TSTST	;IS TOP OF S "TRUE"?
	BEQ TES1	;NO, CLEAR FLAG
	BIS #TSTFLG,FLAGS	;YES, SET FLAG
	BR IFR
TES1:	BIC #TSTFLG,FLAGS
	BR IFR
IFTRUE:	BIT #TSTFLG,FLAGS	;FLAG SET?
	BNE IFR	;YES, CONTINUE
IFT1:	CLR CT	;NO, MAKE GNT THINK LINE HAS ENDED
	CLR CT+2
	RTS PC
IFFALS:	BIT #TSTFLG,FLAGS	;FLAG CLEARED?
	BEQ IFR	;YES, CONTINUE
	BR IFT1	;NO STOP
IF:	INC IFLEV
	JSR PC,TSTST	;TEST S, SKIP IF "TRUE"
	BNE IFR
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	BIC #RTF,FLAGS
	DEC IFLEV
IFR:	SEZ
	RTS PC
THEN:	TST IFLEV
	BGT IFR
	ERROR+OOP	;THEN OUT OF PLACE
ELSE:	DEC IFLEV
	BGE .+4
ELSE1:	ERROR+OOP	;ELSE OUT OF PLACE
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	TST IFLEV
	BLE ELSE1
	BR IFR
STNE:	;SCAN TOO NEXT ELSE, CR OR UNMATCHED );
	;  SET RTF.  SKIP IIF "ELSE"
	JSR PC,GNT
	CMP #$RPAR,B
	BNE STNE4
	DEC NOPAR
	BGE STNE
	BIS #RTF,FLAGS
	SEZ
	RTS PC
STNE4:	CMP #$LPAR,B
	BNE STNE5
	INC NOPAR
	BR STNE
STNE5:	TST NOPAR
	BGT STNE
	.IFNZ ENG
	CMP #$ELSE,B
	BEQ STNE6
	.ENDC
	.IFNZ FR
	CMP #$SINON,B
	BEQ STNE6
	.ENDC
STNE1:	BIT #CRF,FLAGS
	BEQ STNE2
STNE3:	BIS #RTF,FLAGS	;IF "CR" SET RTF AND RETURN
	BIC #CRF,FLAGS
	SEZ
	RTS PC
STNE6:	BIS #RTF,FLAGS	;IF "ELSE", SET RTF AND SKIP RETURN
	RTS PC
STNE2:	.IFNZ ENG
	CMP #$IF,CT+2	;IF "IF", LOOK FOR NEXT ELSE!
	BEQ STNE7
	.ENDC
	.IFNZ FR
	CMP #$SI,CT+2
	BEQ STNE7
	.ENDC
	BR STNE
STNE7:	JSR PC,STNE
	BEQ STNE3
	BIC #RTF,FLAGS
	BR STNE
TSTST:	.IFNZ ENG
	MOV	@S,B		;TEST S, SKIP IF TRUE
	CMP	B,#FALSE
	BEQ	TSTF9	;IT'S "FALSE
.ENDC
.IFNZ FR
	CMP B,#FAUX
	BEQ TSTF9
.ENDC
.IFNZ ENG
	MOV	#TRUE,C	;ERROR IF NEITHER "TRUE" OR "FALSE"
	JSR	PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #VRAI,C
	JSR PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ ENG
	MOV	@S,B
	MOV	#FALSE,C
	JSR	PC,EQUAL1
	BNE TSTF9
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #FAUX,C
	JSR PC,EQUAL1
	BNE TSTF9
.ENDC
	ERROR+NTF	;NOT "FALSE, EITHER
TSTF9:	JSR	PC,SPOPT
	SEZ
	RTS	PC	;"FALSE!!
TESTIT:	JSR	PC,SPOPT
	CLZ
	RTS PC	;"TRUE!!
REVS:	CMP #1,2(P)	;REVERSES THE TOP ((P)+2) THINGS ON S
	BLT .+4	;IF <2 QUIT
	RTS PC
	CMP #MAXARG,2(P)
	BGE .+4
	.BUG.	;BARF, WHO ASKED REVS TO SWITCH > 32 THINGS?
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV 10.(P),C	;GET # TO BE SWITCHED
REVS5:	MOV S,A	;COMPUTE ADDR OF WORD JUST BEYOND BLOCK
	MOV C,B
	ASL B
	ADD A,B
	CMP #SDLINK,B	;SHOULD WE FORCE A SWAPIN?
	BLO REVS4	;YES
	ASR C
	BEQ REVS1
REVS2:	MOV @A,D
	MOV -(B),(A)+
	MOV D,@B
	DEC C
	BGT REVS2
REVS1:	JMP RETD
REVS4:	JSR PC,SPSWPI	;SWAP S PDL BACK IN
	BR REVS5
.STITL DOUBLE PRECISION INTEGER ARITHMETIC
.IFZ FPPF

;INTEGER MULTIPLICATION

;CALL WITH ONE DOUBLE PRECISION ARGUMENT IN B,,C
;AND THE OTHER IN E,,F
;RETURNS PRODUCT IN E,,F.
;ALL OTHER ACCUMULATORS (INCLUDING B,C ARE UNCHANGED)

.DPMUL:	SPUSH	A	;SAVE A
	CLR	A
DVML:	PUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F
	PUSH B		;STUFF ABS(B,,C)
	SPUSH C
	SPUSH E		;AND ABS(E,,F)
	SPUSH F
	CLR	-(SP)	;A FLAG FOR NEG. ARGS
	TST	B	;MAKE SURE ARGS ARE POSITIVE
	BGE	DVML1
	DPNEG	B,C
	DPNEG 10(P),6(P) ;ALSO ON STACK (FOR DIV)
	COM	(SP)
DVML1:	TST	E
	BGE	DVML2
	DPNEG	E,F
	DPNEG 4(P),2(P)
	COM	(SP)
DVML2:	ADD	A,PC	;CHOOSE BETWEEN MUL AND DIV

;DOUBLE PRECISION MULTIPLY (CONT.)

MUL1:	TST	B	;OVERFLOW UNLESS A1*A2=0
	BEQ	MUL2
	TST	E
	BNE	MDV2	;OVERFLOW!
	EXCH	B,E	;WANT ARG1 TO HAVE ZERO HIGH ORDER PART
	EXCH	C,F
MUL2:	CLR	-(SP)	;SET B1 AND B2
	ASL	C
	BCC	.+6
	MOV	#100000,(SP)	;B2
	ASL	F
	BCC	.+6
	ADD	#200,(SP)	;B1 (ALSO CLEARS CARRY)
	ROR	C	;C2
	ROR	F	;C1
;IF B2*A1>0, THEN OVERFLOW
	TST	(SP)
	BGE	MUL3	;B2=0
	TST	E	;A1
	BNE	MDV1	;OVERFLOW

;DOUBLE PRECISION MULTIPLY (CONT.)

;GET A1*C2*(2**16.)
MUL3:
	MOV C,A		;C2*A1
	MUL E,A
	BCS MDV1	;CARRY INTO A IS OVERFLOW
	MOV B,ANSWER+2	;SINCE A1*C2 IS HIGH ORDER OF ANSWER
;GET C1*C2 AND ADD INTO ANSWER
	MOV C,A		;C1*C2
	MUL F,A
	MOV B,ANSWER	;LOW ORDER PARTIAL PRODUCT
	ADD A,ANSWER+2	;ADDED TO A1*C2
	BVS	MDV1	;OVERFLOW
;GET C2*B1*(2**15.) AND ADD INTO ANSWER
	TSTB	(SP)
	BEQ	MUL35	;B1=0
	CLR A
	MOV C,B		;GET C2
	ASHC #15.,A	;SHIFT C2 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B2*C1*(2**15.) AND ADD INTO ANSWER
MUL35:	TST	(SP)
	BGE	MUL4
	CLR A
	MOV F,B		;GET C1
	ASHC #15.,A	;SHIFT C1 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B1*B2*(2**30.)
MUL4:	CMP	(SP)+,#100200	;ARE BOTH B1 AND B2 SET
	BNE	MUL5	;NO (PRODUCT IS ZERO, OBVIOUSLY)
	ADD	#40000,ANSWER+2	;1*2**30. + ANSWER
	BVS	MDV2	;OVERFLOW
;PUT ANSWER IN THE RIGHT PLACE
MUL5:	MOV	ANSWER+2,E	;HIGH ORDER PARTS
	MOV	ANSWER,F	;LOW ORDER PARTS
	TST	(SP)+	;NEGATIVE?
	BEQ	MUL6
	DPNEG	E,F
MUL6:	ADD #14,SP	;THROW AWAY E,,F, ABS(B,,C) AND ABS(E,,F)
	JMP	SRETD	;BUT RESTORE THE REST

;OVERFLOW EXITS
MDV1:	TST (SP)+	;POP 2 WORDS + ABS'S
MDV2:	ADD #12,SP	;POP 1 WORD + ABS'S
	JMP	RETF	;RESTORE ALL AC'S AND RTS


;DOUBLE PRECISION DIVIDE
;	DIVIDE E,F BY B,C
;RETURN QUOTIENT IN E,F  AND REMAINDER IN B,C
.DPDIV:	SPUSH	A
	MOV	#<DIV1-MUL1>,A	;ADD TO THE PC IN A WHILE
	JMP	DVML	;INITIALIZATION.

DIV1:	TST	B	;IS DEN = 0, 1, OR DOUBLE PRECISION ?
	BNE	DIV2	;DOUBLE PRECISION
	TST	C
	BLT	DIV2	;DOUBLE PRECISION (SINCE TOP BIT WAS SET)
;DEN IS SINGLE PRECISION
	BEQ	MDV2	;DEN=0. OVERFLOW!
	CMP	C,#1	;IS IT 1?
	BNE	SPDEN1	;NO
	CLR	B
	CLR	C
	BR	DIV10
SPDEN1:	JSR	PC,.SPDEN	;DO THE DIVISION
	BR	DIV10

;DEN IS DOUBLE PRECISION
DIV2:	JSR	PC,CMP2I	;IS NUM < DEN
	BGE	DIV5	;NO
;NUM<DEN. QUOTIENT=0. REM=NUM
DIV4:	MOV	E,B
	MOV	F,C
	CLR	E
	CLR	F
	BR	DIV10

;NUM>=DEN.
DIV5:	PUSH B		;SAVE DENOMINATOR
	SPUSH C
	MOV B,A		;MOVE B,,C TO A,,B AND NORMALIZE
	MOV C,B
	CLR SHFCNT
DIV5A:	INC SHFCNT	;COUNT A LEFT SHIFT
	ASHC #1,A
	BVC DIV5A	;UNTIL SIGN BIT CHANGES (OVERFLOW)

	ASHC #-1,A	;UNDO LAST SHIFT
	BIC #100000,A	;AND CLEAR SIGN BIT WHICH WAS SET
	DEC SHFCNT	;UNCOUNT THE LAST SHIFT
	MOV A,C		;DIVIDE BY HIGH-ORDER OF NORMED DIVISOR
	JSR PC,.SPDEN	;E,,F _ (E,,F)/(DIVISOR*2^[N-16.])
	MOV E,A		;MOV (QUOTIENT*2^[16.-N]) TO A,,B
	MOV F,B
	ADD #-16.,SHFCNT	;TIMES 2^[N-16.] IS TRIAL QUOTIENT
	ASHC SHFCNT,A
;GET TRIAL NUM_(TRIAL QUOTIENT-1)*DEN. COMPARE WITH TRUE NUM
	POP F		;E,,F _ SAVED DENOMINATOR
	SPOP E
	MOV B,C		;B,,C _ A,,B (TRIAL QUOTIENT)
	MOV A,B
	SUB	#1,C	;TRY FIRST WITH Q_Q-1
	SBC	B
	BVS	MDV2	;OVERFLOW
	JSR	PC,.DPMUL
	BEQ	MDV2	;MULTIPLY GOT AN ERROR (HMM!)
;COMPARE NUM TO TEM
	MOV	B,ANSWER+2	;SAVE TRIAL QUO
	MOV	C,ANSWER
;GET TEM-NUM
	MOV	SP,D
	TST	(D)+
	SUB	(D)+,F
	SBC	E
	BVS	MDV2
	SUB	(D)+,E
	BVS	MDV2
;TURN INTO NUM-TEM
	DPNEG	E,F
	MOV	E,B
	MOV	F,C
	MOV	(D)+,F	;E,,F_DEN
	MOV	(D)+,E
DIV6:	TST	B	;NUM-TEM
	BEQ	DIV7
	BGT	DIV75
;ANSWER TOO BIG. TRY ANSWER _ ANSWER - 2
	SUB	#2,ANSWER
	SBC	ANSWER+2
	BVS	MDV2
;THIS MAKE TEM _ TEM + 2*DEN
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	BR	DIV6
DIV7:	TST	C
	BEQ	DIV9	;TRIAL QUOTIENT = QUOTIENT !!
;TEM < NUM. EITHER QUOT=QUOT OR QUOT+1
DIV75:	JSR	PC,CMP2I	;IS REM < DEN
	BGT	DIV9	;YES
DIV8:	ADD	#1,ANSWER	;QUOT _ QUOT + 1
	ADC	ANSWER+2
	BVS	MDV2
	SUB	F,C	;REM _ REM - DEN
	SBC	B
	BVS	MDV2
	SUB	E,B
	BVS	MDV2
DIV9:	MOV	ANSWER+2,E
	MOV	ANSWER,F
DIV10:	TST	(SP)+	;NEG. IF ANSWER SHOULD BE NEG.
	BGE	DIV11
	DPNEG	B,C
	DPNEG	E,F
DIV11:	ADD #14,SP	;POP ABS(E,,F), ABS(B,,C) AND E,,F
	POP	D	;RESTORE D
	CMP	(SP)+,(SP)+	;THROW AWAY B & C
	SPOP	A	;RESTORE A
	CLZ
	RTS PC



;SINGLE PRECISION DENOMINATOR. DOUBLE PRECISION NUMERATOR.
;C=DEN. E,F=NUM. RETURNS C_REM, E,F_QUOTIENT
.SPDEN:	SPUSH	A
	SPUSH	B
	ASL	E	;DOUBLE E,,F
	ASL	F
	ADC	E
	MOV E,B		;2E/C
	CLR A
	DIV C,A
	MOV A,E		;2*HIGH-QUOTIENT -> E
	MOV B,A		;(2REM + 2F)/2 /C
	MOV F,B
	ASHC #-1,A
	DIV C,A
	MOV A,F		;LOW-QUOTIENT -> F
	MOV B,C		; REMAINDER -> C
	ASR	E	;HALVE E TO GET PROPER HIGH-QUOTIENT
	BCC	.+6
	BIS #100000,F	;& LOW BIT FROM DOUBLE-E CLOBBERS F'S SIGN BIT
	SPOP	B
	SPOP	A
	RTS	PC
.ENDC


.IFNZ FPPF


;FLOATING DIVIDE AND MULTIPLY FROM REGS B,,C AND E,,F

.DPMUL:	PUSH A
	CLR A	;SET SWITCH
.DPMU1:	FPUSH FA
	FPUSH FB
	SPUSH C
	SPUSH B
	LDCIF (P)+,FA
	SPUSH F
	SPUSH E
	LDCIF (P)+,FB	;LOAD FLOATING REGS
	ADD A,PC	;WHICH ENTRY?
	MULF FA,FB
	BR .DPMU2
	LDD FB,FC	;SAVE FB
	DIVF FA,FB
.DPMU2:	STCFI FB,-(P)	;STACK QUOTIENT OR PRODUCT
	CFCC
	BVS .DPERR	;TOO BIG!?
	SPOP E
	SPOP F		;LOAD E,,F
	TST A
	BNE .DPMU4
.DPMU3:	FPOP FB
	FPOP FA
	SPOP A
	CLZ
	RTS PC

.DPMU4:	STCFI FB,-(P)
	LDCIF (P)+,FB	;TRUNCATE QUOTIENT
	MULF FA,FB
	SUBF FB,FC	;GET REMAINDER
	STCFI FC,-(P)
	SPOP B
	SPOP C		;LOAD B,,C WITH REMAINDER
	BR .DPMU3


.DPDIV:	TST C	;DIVIDE ENTRY
	BNE .DPDI1
	TST B		;DON'T DIVIDE BY ZERO
	BEQ .DPERQ
.DPDI1:	PUSH A
	MOV #4,A	;SET DIVIDE SWITCH
	BR .DPMU1	;GO DO IT

.DPERR:	CMP (P)+,(P)+	;CLEAR STACK
	FPOP FB
	FPOP FA
	SPOP A
	SEZ
.DPERQ:	RTS PC




.ENDC





	.STITL CONVERSION ROUTINES


;CONVERT
;CALL WITH DESIRED DATA TYPE IN A
;CALL WITH POINTER TO DATA IN B
;IF CONVERSION SUCCEEDS, RETURN POINTER TO CONVERTED DATA IN B AND
;LEAVE A UNCHANGED.
;
;IF CONVERSION FAILS, LEAVE B UNCHANGED,BUT RETURN ITS DATA TYPE IN A

CONVERT:
	MOV	A,-(SP)	;SAVE A,B,C HERE
	MOV	B,-(SP)
	MOV	C,-(SP)

	BIC	#107777,A	;LEAVE DATA TYPE ONLY
	MOV	B,C
	BIC	#107777,C
	ASR	A	;SHIFT DESTINATION DATA TYPE 3 PLACES
	ASR	A
	ASR	A
	BIS	C,A	;SET SOURCE DATA TYPE IN THE 3 VACATED BITS
	ASR	A	;AND PLACE THE ENTIRE MESS IN BOTTOM 6 BITS
	SWAB	A
;(A IS NOW A 6 BIT DISPATCH ADDRESS)
	MOVB	CNVTBL(A),A	;PICK UP ENTRY FROM TABLE
	BIC	#177400,A	;CLEAR TOP BYTE
	ASL	A		;IT IS A BYTE ADDRESS
	JSR	PC,CNVTOP(A)	;RELATIVE TO CONVERT TOP
	BEQ	CONV.F	;THE CONVERSION FAILED
	MOV	(SP)+,C
	TST	(SP)+	;DON'T RESTORE B
	MOV	(SP)+,A
	RTS PC

CONV.F:	MOV	(SP)+,C
	MOV	(SP)+,B
	MOV	B,A
	BIC	#7777,A	;DATA TYPE OF ARG LEFT IN A
	TST	(SP)+	;DON'T RESTORE A
			;FALLS THROUGH

;CONVERT ROUTINE JUMPS TO THE PROGRAMS HERE

CNVTOP==.	;TOP OF CONVERT ROUTINES

;THE ARGUMENT CAN'T BE CONVERTED TO DESIRED DATA TYPE
.CERR:	SEZ
	RTS	PC


CA2LS==<.-CNVTOP>/2
;CONVERT ATOM TO LSTR
.CATLS:	JSR	PC,.LOAD

CNVNOP==<.-CNVTOP>/2
;THE ARGUMENT ALREADY HAS THE DESIRED TYPE
.CNOP:	CLZ
	RTS PC


CSN2IN==<.-CNVTOP>/2
;CONVERT SNUM TO INUM.  ASSUME NUMBER IN B, RATHER THAN POINTER
.CSNIN:	CLR	A
	TST	B	;IS NUM NEGATIVE?
	BGE	.+4
	COM	A	;SET TOP PART TO ALL 1'S
	JSR	PC,GRBAD
	BIS	#INUM,C	;C POINTS TO NEW NODE
	MOV	C,B
	RTS PC

;MORE CONVERSION ROUTINES

CIN2SN==<.-CNVTOP>/2
;CONVERT INUM TO SNUM.  RETURN NUMBER IN B
.CINSN:	JSR	PC,.LOAD
	TST B
	SXT C		;SEE IF B'S SIGN EXTENDED FILLS A.
	CMP A,C
	BNE .CERR
	CLZ
	RTS PC


CSN2LS==<.-CNVTOP>/2
;CONVERT SNUM TO LSTR
.CSNLS:	JSR	PC,.CSNIN	;CONVERT TO INUM FIRST

CIN2LS==<.-CNVTOP>/2
;CONVERT INUM TO LSTR
.CINLS:	SPUSH	D
	SPUSH	E
	SPUSH	F
	JSR	PC,.LOAD	;A,B HAS NUMBER
	JSR	PC,.CINST	;CONVERT TO STRING ON P-PDL
.CINL0:	CLR	F
	MOV	#SSTR,A
.CINL1:	SPOP	B
	BEQ	.CINL2		;0 MARKS END OF DIGITS
	JSR	PC,LISTB	;PUT NEXT 2 CHARS ONTO LIST
	BR	.CINL1
.CINL2:	POPS	B	;POINTER TO FIRST NODE OF ANSWER
	BIC	#170000,B	;CLEAR DATA TYPE
	BIS	#LSTR,B	;REPLACE BY LSTR
	MOV F,C	;GET PTR TO LAST NODE IN STRING

.SRDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	CLZ
	RTS PC


;GET NEXT CHARACTER IN B
;SKIP UNLESS NO MORE CHARS
.CNXTD:	TST	E	;IS THERE MORE NUMBER LEFT
	BNE	.CNXD1	;YES
	TST	F
	BEQ .CNXD2
.CNXD1:	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPDIV	;C_REM, E,,F_QUO
	BEQ .CNXD2
	ADD	#60,C	;TURN TO ASCII
.CNXD2:	RTS PC


;CONVERT INUM TO STRING ON P-PDL
.CINST:	MOV	(SP),TEM1	;RETURN ADDRESS
	CLR	(SP)
	MOV	#10,D
	MOV	A,E
	BGE	.CINI1	;NUMBER IS POSITIVE
	DPNEG	E,B	;NUMBER IS NEG
	CLR	D	;FLAG
.CINI1:	MOV	 B,F

.CINI2:	JSR	PC,.CNXTD	;GET NEXT DIGIT IN C
	BEQ	.CINI5	;NO MORE CHARS
	SWAB	C
	PUSH	C
	JSR	PC,.CNXTD
	BEQ	.CINI6
	BISB	C,(SP)	;SET NEW CHAR INTO PREVIOUS ONE
	BR	.CINI2

.CINI5:	ADD	D,PC	;NEGATIVE?
	SPUSH	#<55*256.>	;PUSH A MINUS SIGN IN HIGH BYTE
.CINIR:	JMP	@TEM1	;RETURN
	BR	.CINI7

.CINI6:	ADD	D,PC	;NEGATIVE?
	BIS	#55,(SP)	;PUT A MINUS SIGN IN LOW BYTE
	JMP	@TEM1
.CINI7:	TST	(SP)	;WERE ANY CHARACTERS GENERATED?
	BNE	.CINIR	;YES, SO RETURN
	SPUSH	#<60*256.>	;NO, SO PUSH A "0 IN HIGH BYTE
	BR	.CINIR

;MORE CONVERSION ROUTINES


CLS2SN==<.-CNVTOP>/2
;CONVERT LSTR TO SNUM
.CLSSN:	JSR	PC,.CLSIN	;CONVERT TO INUM FIRST
	BEQ .CLNR
	JSR	PC,.CINSN	;THEN CONVERT TO SNUM
.CLNR:	RTS	PC	;FAILED

CLS2IN==<.-CNVTOP>/2
;CONVERT LSTR TO INUM
.CLSIN:	BIT	#7777,B	;IS B EMPTY
	BEQ	.CLNR	;CAN'T CONVERT EMPTY
	PUSH	D
	SPUSH	E
	SPUSH	F
	MOV	B,GCP1	;POINT TO INPUT. (GETS CLEARED AT .RDEF & .SRDEF)
	MOV	B,C
	CLR	E
	CLR	F

.CLSS0:	CLR	-(SP)	;A FLAG
	JSR	PC,INSTR1	;GET FIRST CHAR IN D
	BEQ	.CLSS8	;NO CHARS (HMM)
	CMPB	D,#53	;PLUS
	BEQ	.CLSSA
	CMPB	D,#55	;MINUS
	BNE	.CLSS3	;NOT + OR -
	COM	2(SP)	;-1
.CLSSA:	JSR PC,@(SP)+
	BEQ .CLSS8
	BR .+4
.CLSS1:	JSR	PC,@(SP)+	;GET NEXT CHAR INTO D
	BEQ	.CLSS9	;ALL CHARS GOTTEN
.CLSS3:	SPUSH	C	;SAVE C
	SUB	#60,D	;CONVERT FROM ASCII
	BLT	.CLSS7	;NOT DIGIT
	CMPB	D,#10.
	BGE	.CLSS7	;NOT DIGIT
	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPMUL
	BEQ	.CLSS7	;TOO BIG
	ADD	D,F	;ADD NEXT DIGIT IN
	ADC	E
	BVS	.CLSS7	;OVERFLOW
	SPOP	C
	BR	.CLSS1

;EITHER A NON-DIGIT CHARACTER WAS FOUND, OR ELSE 
;THERE WAS OVERFLOW
.CLSS7:	CMP	(SP)+,(SP)+	;POP OFF C & CO-ROUTINE LINKAGE
.CLSS8:	TST	(SP)+	;POP OFF FLAG
	JMP	.RDEF

;ALL CHARS GOTTEN.  NUMBER IS IN E,,F
.CLSS9:	TST	(SP)+	;BUT SHOULD IT BE NEG?
	BGE	.CLSSR	;NO
	DPNEG	E,F
.CLSSR:	MOV	E,A
	MOV	F,B
	JSR	PC,GRBAD
	BIS	#INUM,C
	MOV	C,B
	JMP	.SRDEF
.IFNZ FPPF


;FLOATING POINT CONVERSION ROUTINES

CSN2FN==<.-CNVTOP>/2
.CSNFN:	SPUSH #.CINFN
	JMP .CSNIN


CIN2FN==<.-CNVTOP>/2
.CINFN:	MOV #INUM,A
	JSR PC,.FLOAD
	STCFD FA,-(P)
RFSTR:	SPOP A
	SPOP B
	JSR PC,GRBAD
	BIS #FNUM,C
	MOV C,B
	CLZ
	RTS PC


CFN2IN==<.-CNVTOP>/2
.CFNIN:	MOV #FNUM,A
	JSR PC,.FLOAD
	ADDF #40000,FA
	CFCC
	BVS .LERR1
	BGE .+6
	SUBF #40200,FA
	STCFI FA,-(P)
	BCS .LERR
	SPOP A
	SPOP B
	JSR PC,GRBAD
	MOV C,B
	BIS #INUM,B
	CLZ
	RTS PC
.LERR	:CMP (P)+,(P)+
.LERR1:	SEZ
	RTS PC


CFN2SN==<.-CNVTOP>/2
.CFNSN:	JSR PC,.CFNIN
	BEQ .LERR1
	JMP .CINSN


CFN2LS==<.-CNVTOP>/2
.CFNLS:	SPUSH D
	SPUSH E
	SPUSH F
	MOV #FNUM,A
	JSR PC,.FLOAD
	JSR PC,.CFNST
	JMP .CINL0




CLS2FN==<.-CNVTOP>/2
.CLSFN:	CLR FNPDL+2
	CLR SEXP
	CLR FNPDL
	STF FA,FE	;STORE FLOATING REGISTERS
	STF FB,FF
	CLRF FB
	BIT #7777,B	;CAN'T CONVERT EMPTY LSTR
	BEQ .FNLR
	PUSH D
	SPUSH E
	SPUSH F
	MOV B,GCP1
	MOV B,C
	CLR E	
	CLR F
CLSS0:	CLR -(P)	;A FLAG FOR THE SIGN OF NUMBER
	JSR PC,INSTR1	;GET FIRST CHAR
	BEQ .FERR	;NO CHARS
	SETI		;TO PREPARE FOR MOVES FROM REGS TO FLOAT REGS
	CMPB D,#53	;IS CHAR A "+?
	BEQ CLSSA
	CMPB D,#55	;IS CHAR A "-?
	BNE CLSS3
	COM 2(P)	;SET NEGATIVE NUMBER FLAG
CLSSA:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ .FERR	;NO MORE CHAR????
	BR .+4
CLSS1:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ CLSS9
CLSS3:	SUB #60,D	;CONVERT FROM ASCII
	BLT CLSS7	;IT WASN'T A DIGIT
	CMPB D,#12
	BGE CLSS7	;IT WASN'T A DIGIT
	CLR B
	LDCFD #41040,FA	;CONSTANT 10
	MULF FA,FB
	CFCC
	BVS CLSS8
	LDCIF D,FD
	INC FNPDL+2	;SET SWITCH
	ADDF FD,FB
	CFCC
	BVS CLSS8	;OVERFLOWED A FLOATING REGISTER??????!!!
	ADD E,F
	BR CLSS1	;GET ANOTHER CHAR
CLSS8:	TST (P)+	;DESTROY CO-ROUTINE LINKAGE
	JMP .FERR
CLSS9:	CLR B		;NO EXPONENT
	JMP OKY
CLSS7:	INC FNPDL
	CMPB D,#25	;IS IT "E?
	BEQ GTEXP
	CMPB D,#36	;IS IT "N?
	BEQ GTNEXP
	CMPB D,#177776	;ITS NOT ".!!??
	BNE CLSS8
	TST E
	BNE CLSS8	;THERE WERE TWO ".
	DEC E
	BR CLSS1
.FNLR:	LDF FE,FA	;RESTORE REGS
	LDF FF,FB
	SEZ
	RTS PC
FERR2:	POPS GCP1
	FPOP FB
	FPOP FA
.FERR:	TST (P)+
	LDF FF,FB
	LDF FE,FA
	SETL
	JMP .RDEF
GTNEXP:	DEC SEXP	;SET NEG EXPONENT FLAG
GTEXP:	SETL
	SPOP D		;SAVE CO-ROUTINE LINKAGE
	FPUSH FA
	FPUSH FB
	JSR PC,KL	;GET EXPONENT
	BEQ FERR2
	POPS GCP1
	FPOP FB
	FPOP FA
	SPUSH A
	CLR A
	JSR PC,.LOAD	;GET EXPONENT IN A,,B
	TST A
	BEQ OKAY
	SPOP A		;THE EXPONENT WAS TOO TOO LARGE!!!
	BR .FERR
OKAY:	SPOP A
OKY:	TST FNPDL+2
	BEQ .FERR
	SETL
	TST (P)+	;THE NUMBER IS NEGATIVE?
	BGE OKY1
	NEGF FB
OKY1:	LDCDF #40200,D	;CONSTANT 1
	TST SEXP	;GET FINAL EXPONENT
	BGE .+4		;IS EXP NEGATIVE
	NEG B
	CLR SEXP
	ADD B,F
	TST F		;GET ABSOLUTE VALUE IN F
	BGE LOOP
	DEC SEXP
	NEG F
LOOP:	DEC F		;GET 10 TO THE EXPONENT IN FD
	BLT DONEX
	MULF FA,FD
	CFCC
	BVS .FERR+2	;TO BIG
	BR LOOP
DONEX:	TST SEXP	;IF EXP IS POSITIVE MULTIPLY BY IT
	BLT DIVE	;IF NEG DIVIDE BY IT
	MULF FD,FB	;AND PUT RESULT IN FB
	CFCC
	BVS .FERR+2
	BR FIN
DIVE:	DIVF FD,FB
FIN:	STCFD FB,-(P)
	SPOP A		;GET RESULT IN A,,B
	SPOP B
	JSR PC,GRBAD	;STORE RESULT IN NODE SPACE
	BIS #FNUM,C	;PUT POINTER TO DATA IN B
	MOV C,B
	TST FNPDL
	BEQ .FERR+2
	LDF FF,FB	;RESTORE FLOATING REGS
	LDF FE,FA
	JMP .SRDEF
KL:	SPUSH D		;SHORT FOR KLUDGE.
	SPUSH E		;PREPARE TO FAKE OUT .CLSSA
	SPUSH F		;IT WILL GET US AN EXPONENT
	CLR -(P)	;FAKE A FLAG
	SPUSH D		;RESTORE CO-ROUTINE LINKAGE
	CLR E
	CLR F
	PUSHS GCP1
	JMP .CLSSA	;GET POINTER TO EXPONENT



;CONVERT FROM FNUM TO SSTR ON P-PDL

.CFNST:	SPOP SEXP	;SAVE PC
	CLR -(P)
	MOV #FNPDL+16,D	;INITIALIZE STACK POINTER
	TSTF FA
	CFCC
	BEQ .CFNZE	;ITS ZERO
	BGE .CFNS0
	MOVB #'-,-(D)	;PUT IN A MINUS SIGN
	NEGF FA		;PROCESS SIGN OF FNUM
.CFNS0:	CLR A
  	LDCFD #40200,FB	;CONSTANT 1
	LDCFD #41040,FD	;CONSTANT 10
	CMPF FA,FB
	CFCC
	BLT .CFNS2
.CFNS1:	DIVF FD,FA	;NORMALIZE FA
	INC A		;DIVIDE UNTIL 0<FA<1
	CMPF FA,FB
	CFCC
	BGE .CFNS1
.CFNS2:	MULF FD,FA	;MULTIPLY UNTIL 1<F=FA<10
	DEC A
	CMPF FA,FB
	CFCC
	BLT .CFNS2
	SPUSH #66152
	SPUSH #2657
	SPUSH #33675
	SPUSH #33006
	ADDF (P)+,FA	;ADD .0000005 FOR ROUNDING
	CMPF FA,FD	;9.99999999999999 WILL OVERFLOW
	CFCC
	BLT .+6
	DIVF FD,FA
	INC A		;MAKE IT 1.000 WHEN IT WAS 10.000
	MOV A,FNPDL	;SAVE EXPONENT
	MOV #7,B	;COUNTER FOR SEVEN DIGITS
	SETI
	INC A
	BLT .CFNS3-4	;ITS LESS THAN .1
	CMP #7,A
	BLT .CFNS3-4	;ITS GREATER THAN 10000000.
	INC A
	CLR FNPDL
	BR .CFNS3
	MOV #2,A
.CFNS3:	DEC A		;A COUNTS PLACES TO DECIMAL POINT
	BNE .+6
	MOVB #'.,-(D)	;PUT IN ".
	STCFI FA,C	;GET DIGIT
	LDCIF C,FB
	ADD #'0,C
	MOVB C,-(D)	;STACK CHARACTER
	SUBF FB,FA	;GET FRACTIONAL PART OF NUMBER
	MULF FD,FA
	SOB B,.CFNS3
	DEC A
	BNE .+6
	MOVB #'.,-(D)
	SETL
	CLR A
.CFNS4:	INC A		;COUNT ZEROS POPPED
	CMPB #'0,(D)+
	BEQ .CFNS4	;POP INSIGNIFICANT ZEROS
	DEC D		;RESET POINTER
	MOV FNPDL,B	;RETRIEVE EXPONENT
	BEQ .CFNS6	;NO EXPONENT
	BGT .CFNS5
	ADD B,A
	BGE .CFNS8	;IT NOW FITS DUE TO POPPED ZEROS
	NEG B
	MOVB #'N,-(D)	;STACK "N
	BR .CFNS5+4
.CFNS5:	MOVB #'E,-(D)	;STACK "E
	CLR A
	MOV D,FNPDL	;SAVE POINTER
	JSR PC,.CINST	;REDUCE EXPONENT TO SSTR
	SPOP A
	SPOP B
	MOV FNPDL,D	;RESTORE POINTER
	MOVB A,-(D)	;STACK EXPONENT DIGIT
	BNE .+4
	INC D		;IT WASN'T A DIGIT SO KILL IT
	SWAB A
	MOVB A,-(D)	;GET OTHER DIGIT
.CFNS6:	MOVB (D)+,-(P)	;GET HIGH BYTE
	BEQ .CFNS7	;A ZERO BYTE MEANS ITS DONE
	SWAB (P)
	MOVB (D)+,(P)	;GET ANOTHER BYTE
	BNE .CFNS6	;ZERO BYTE SIGNALS END
	SUB #2,P
.CFNS7:	ADD #2,P	;FIX UP STACK POINTER
	JMP @SEXP
.CFNZE:	SPUSH #"0.	;PUT "0. ON STACK
	JMP @SEXP
.CFNS8:	ADD D,B		;CREATE POINTER
	INC B
	MOV B,C		;SAVE IT
.CFNS9:	MOVB (D)+,(B)+	;SHIFT STACK
	CMPB #'.,-1(B)
	BNE .CFNS9
	MOVB (D),-1(B)	;GET LAST DIGIT
	MOV FNPDL,A
	COM A		;COMPUTE HOW MANY ZEROS ARE TO BE ADDED
.CFN10:	MOVB #'0,(B)+
	SOB A,.CFN10
	MOVB #'.,(B)
	MOV C,D		;RESTORE POINTER
	BR .CFNS6	;I HOPE YOUR HAPPY THAT THE EXPONENT IS GONE


.ENDC




	.STITL GET ARGUMENT ROUTINES

;GET 2 SNUM'S OFF OF S PDL
;RETURN TOP ONE IN A, BOTTOM ONE IN B
G2NARG:	JSR	PC,G1NARG	;NUMBER IN B
	MOV	B,A

;GET 1 SNUM OFF OF S PDL
;RETURN IT IN B
G1NARG:	POPS B
G1NAR1:	MOV	A,-(SP)	;ENTER HERE WITH ARG IN B
	MOV	#SNUM,A
	JSR	PC,CONVERT
G1WTA:	BEQ G1ARG1
	MOV	(SP)+,A
G1RET:	RTS	PC

;GET ONE LIST OR WORD ARG
;SKIP IF WORD
GLWARG:	MOV	@S,B	;DON'T POP ARG.  LEAVE IT GC PROTECTED
GLWAR1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE GSW2
GSW1:	CMP	A,#SENT
	BNE	G1ARG1	;NOT SENTENCE EITHER
	SEZ
GSW2:	RTS	PC

;GET ONE LIST OR WORD.  ERRROR IF EMPTY
GLWANE:	MOV	@S,B
	BIT	#7777,B
	BEQ	G1ARG1
	BR	GLWAR1

;RETURN ONE NUMERIC ARGUMENT
;CALL WITH SNUM IN B
R1INT:	JSR	PC,GETINT
R1NARG:	JSR	PC,.CSNIN	;CONVERT SNUM TO INUM
	JMP ORTB

PSHINT:	JSR	PC,GETINT
;PUSH A NUMBER ONTO THE S-PDL
PSHNUM:	JSR	PC,.CSNIN
	SPUSHS	B
	RTS	PC
.IFZ FPPF


;GET 2 INTEGERS FROM THE S-PDL
G2IARG:	JSR	PC,G1IARG
	MOV	B,E
	MOV	C,F
	JSR	PC,G1IARG
	EXCH	B,E
	EXCH	C,F
ILOAD1:	RTS	PC
G1ARG1:	ERROR+WTAB
.ENDC


;GET 1 INTEGER FROM THE S-PDL
G1IARG:	POPS	B
	SPUSH	A	;SAVE A
	MOV	#INUM,A
	JSR	PC,CONVERT
	BEQ G1ARG1
	JSR	PC,.LOAD	;INTEGER IN A,,B
	MOV	B,C
	MOV	A,B
	SPOP	A
	RTS	PC

.IFZ FPPF


;RETURN 1 INTEGER FROM B,,C
R1I.BC:	MOV	B,A
	MOV	C,B
	BR	R1I.N

;;RETURN 1 INTEGER FROM E,,F
R1I.EF:	MOV	E,A
	MOV	F,B
R1I.N:	JSR	PC,GRBAD
	BIS	#INUM,C
	JMP	ORTC
.ENDC

.IFNZ FPPF

;ROUTINES TO LOAD FLOATING REGS FROM NODESPACE

G2ARG:	MOV #INUM,F
	JSR PC,G1NUM	;GET 1 INTO FA
	BEQ G1ARG1
	LDD FA,FC
	JSR PC,G1NUM	;GET ANOTHER
	BEQ G1ARG1
	LDD FA,FB
	LDD FC,FA	;SWITCH THEM
	RTS PC		;F WILL CONTAIN TYPE EXPECTED OF
			;ARITHMETIC RESULT

;LOAD ONE ARG INTO FA AND ERROR+WTA

G1ARG:	JSR PC,G1NUM
	BNE ILOAD1
G1ARG1:	ERROR+WTAB


;LOAD ONE ARG INTO FA AND CLZ

G1NUM:	POPS B
G1NUMS:	MOV B,A	;IS IT ALREADY AN FNUM?
	BIC #7777,A
	CMP #FNUM,A
	BEQ G1FAG
	MOV #INUM,A
	JSR PC,CONVERT	;TRY TO GET AN INUM
	BNE .FLOAD
G1FARG:	MOV #FNUM,A
	JSR PC,CONVERT	;TRY TO GET A FNUM
	BEQ ILOAD1
G1FAG:	MOV A,F		;SET F TO SHOW FNUM

.FLOAD:	BIC #170000,B
	ASL B
	ASL B
	ADD #NODESP,B
	CMP #INUM,A
	BEQ .ILOAD	;LOAD AN INUM?
	LDCFD (B),FA	;LOAD FNUM
	CLZ
	RTS PC
.ILOAD: LDCIF (B),FA	;LOAD INUM
	CLZ
ILOAD1:	RTS PC


.ENDC




;GET 1 SNAP
;	RETURN POINTER TO SNAP IN D, DELTA X IN E, DELTA Y IN F
G1SNAP:	MOV	@S,C	;POINTER TO ARG
	BIT	#7777,C	;IS IT EMPTY?
	BEQ	ILOAD1	;YES. RETURN WITHOUT SKIPPING


;LOAD 3 NUMBERS
;	GROVEL DOWN A LIST OF NUMBERS RETURNING 3 NUMBERS IN D,E,F
;	CALL WITH C POINTING TO LIST
;	IF LIST CONTAINS 1)NON-NUMBERS OR 2)MORE THAN 3 ELEMENTS,
;	THEN ERROR+WTA
LD3NUM:	PUSH	A
	SPUSH	B
	SPUSH	C
	MOV	#7777,D	;AN OFT USED CONSTANT
	MOV	#3,F	;COUNTER
LDN.L:	BIT	D,C	;IS THERE MORE LIST?
	BEQ	LDN.ER	;ERROR
	JSR	PC,.LOADC	;LOAD A WITH NEXT ELEMENT
	MOV	A,C
.IFNZ FPPF
	CMP #3,F
	BGT LDN.E
.ENDC
	MOV	#SNUM,A
	JSR	PC,CONVERT
	BEQ LDN.ER
LDN.E:	SPUSH	B	;PUSH THIS ELEMENT
	SOB F,LDN.L
	BIT	D,C	;IS THE LIST FINISHED?
	BNE	LDN.ER	;NO. ERROR
	JMP	SRETF	;SKIP RETURN AND RESTORE ALL AC'S!

LDN.ER:	ERROR+WTA
	.STITL EVAL

EVAL:	JSR PC,GNT	;GET NEXT TOKEN, RETURNED IN A
	JSR PC,STRACE	;CHECK FOR SYSTEM TRACE
	BIC #DPQF+CPTBF,FLAGS2	;DON'T PRINT QUOTE, CHANGE % TO BLANK
	BIC #7777,A
	CMP A,#UFUN	;USER FUNCTION?
	BLOS EVFUN
	CMP A,#UVAR	;USER VARIABLE?
	BEQ EVVAR
	CMP A,#SSTR
	BHI .+4
EVWHAT:	.BUG.
	CMP A,#ATOM
	BEQ EVATM
	CMP A,#SNUM	;INTEGER?
	BEQ EVWHAT
.IIF Z FPPF,	CMP A,#LSTR
.IIF NZ FPPF,	CMP A,#FNUM
	BLOS EVCON
	CMP A,#LIST
	BNE EVWHAT
EVCON:
EVATM:	PUSHS CT+2	;SAVE ON S-PDL FOR OUTPUT
	BR EVI
EVVAR:	BIC #170000,B
	BIS #ATOM,B
	MOV B,D		;SAVE UOE PTR FOR ERROR
	JSR PC,.BINDL
	BEQ EVVAR2	;NO BINDING FOUND
	TST B		;NIL?
	BNE EVVAR1	;NO, GOOD
	MOV D,B
EVVAR2:	ERROR+HNV	;... HAS NO VALUE
EVVAR1:	PUSHS B		;SAVE IT FOR OUTPUT
EVI:	JSR PC,GNT	;ABOUT TO OUTPUT A VALUE.
			;BEFORE WE DO, CHECK TO SEE IF
			;NEXT TOKEN IS INFIX WHICH SHOULD GOBBLE IT.
	BIC #7777,A	;IS NEXT TOKEN INFIX?
	CMP #INFIX,A
	BEQ CKPRCD	;YES
EVI1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS	;CLEAR CARRIAGE RETURN TOKEN FLAG
	CLZ
	RTS PC
CKPRCD:	TST CO+2	;COMPARE PRECEDENCE
	BEQ EVI2
	MOV CT+2,A
	ASL A
	MOV SOBLST(A),A	;SYSTEM OBLIST ELEMENT (NEXT OPER.)
	BIC #7777,A
	MOV COF,B	;CURRENT OPERATOR FLAG
	BIC #7777,B
	CMP A,B		;IS PRECD OF CO >= PRECD NEXT OPER
	BLO EVI1	;YES, > - GIVE OUTPUT TO CO
	BEQ EVI4	;YES, = - CHECK FOR _
		;NO - NEXT TOKEN SHOULD GOBBLE THIS OUTPUT
EVI2:	JSR PC,STRACE
EVI12:	CMP #$BKAR,CT+2	;CHECK FOR SUCCESSIVE _'S
	BNE EVI3		;   "A _"B _0
	CMP #$BKAR,CO+2
	BEQ EVI13
	CMP #$TBKAR,CO+2
	BNE EVI3
EVI13:	MOV #$TBKAR,CT+2
EVI3:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF OPERANDS STILL NEEDED
	MOV CT,CO
	MOV CT+2,CO+2
	MOV CO+2,A	;GET FLAGS
	ASL A
	MOV SOBLST(A),COF	;SET CURRENT OPERATOR FLAG
	MOV #1,NOR
	JMP EVW		;CALLS EVAL
EVI4:	CMP #$BKAR,CT+2	;PRECD ARE = - IF _ DO RIGHT ONE FIRST
	BEQ EVI2	;IT IS _
	BR EVI1
EVFUN:	BIT #CRF,FLAGS	;CT IS A FUNCTION
	BEQ .+4
	ERROR+UELX	;UNEXPECTED END OF LINE
	CMP #$LPAR,CT+2	;IS NEXT TOKEN A LEFT PAREN?
	BNE EVF1
	TST CO+2	;NEXT OPERATOR?
	BEQ EVF11	;NOTHING THERE
.IFNZ ENG
	CMP #$DO,CO+2	;IS NEXT OPERATOR A RUN COMMAND?
	BEQ EVF11
.ENDC
.IFNZ FR
	CMP #$EXECUT,CO+2
	BEQ EVF11
.ENDC
	CMP #$LLPAR,CO+2
	BNE EVF1
EVF11:	MOV #$LLPAR,CT+2	;INSERT PARENS.FOR PARSE
EVF1:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF ARGS NEEDED FOR CO'S EXECUTION
	CMP #$LLPAR,CO+2	;IF CO IS !(, PUSH IFLEV INSTEAD OF NOR
	BNE EVF13
	MOV IFLEV,(P)
	CLR IFLEV
EVF13:	MOV CT,CO
	MOV CT+2,CO+2
	BIC #EDTIF2,FLAGS
EVF2:	CMP A,#UFUN	;IS POPPED OPER. A  USER FUNCTION?
	BLO MFUN	;NO, MACHINE
	MOV #<PREPRI_13.>,COF	;SET PRECD TO PREPRI
	JSR PC,GNASN	;GET NO. OF ARGS IN B
	BNE .+4
	ERROR+HNM	;... HAS NO MEANING
	MOVB B,B	;CLEAR ANY LEFT HALF FLAGS
	MOV B,NOR
	BNE EVL1	;EVALUATE NEEDED ARGS

EVXP:	JSR PC,STRACS	;NO MORE, SPACE AND CHECK FOR SYSTEM TRACE
	JSR PC,PEVAL	;SET TO EVALUATE THIS USER PROCEDURE
	BEQ XNORT	;PEVAL DOES SEZ  IF THERE IS NO OUTPUT
	JMP XORT		;DOES CLZ IF THERE IS
MFUN:	MOV CO+2,A	;GET FLAGS FOR THIS MACHINE PROCEDURE
	ASL A
	MOV SOBLST(A),A
	MOV A,COF
	SWAB A
	BIC #177774,A	;FIND NO. OF ARGS. NECESSARY
	MOV A,NOR
	BNE EVS		;IS  NO. ARGS = 0? (BRANCH IF NO)
EVXM:	JMP MEVAL	;YES.  EXECUTE THIS MACHINE PROCEDURE

XNORT:	BIC #EDTIF,FLAGS
	BIT #EDTIF2,FLAGS
	BEQ .+10
	BIS #EDTIF,FLAGS
NORT0:	MOV #EVDNO,A	;SET RETURN TO INDICATE NO OUTPUT
NORT1:	MOV CO+2,LO+2	;UPDATE OPERATORS
	MOV CO,LO
	POP NOR
	SPOP B
	MOV B,CO+2
	SPOP CO
	CMP #$LLPAR,B	;IF POPPED OPER IS !(, IFLEV_NOR, NOR_1	
	BNE NORT3
	MOV NOR,IFLEV
	MOV #1,NOR
NORT3:	CLR COF
	TST B
	BEQ NORT2	;NO MORE OPERATORS
	BIT #160000,CO	;IS IT A UFUN
	BNE NORT2	;YES
	ASL B		;NO, MUST BE A PRIMITIVE. GET OFFSET IN BYTES
	MOV SOBLST(B),COF
NORT2:	JMP @A		;RETURN DEPENDS ON WHETHER OUTPUT EXISTS
EVDNO:	SEZ
	RTS PC
EVS:	BIT COF,#INFIX	;IS CO INFIX OP
	BEQ EVL		;NO
	JSR PC,CKUI	;CHECK FOR VALID UNARY INFIX +,-
	BNE EVW
	ERROR+INF1	;INFIX IN WRONG PLACE
PROC:
	JSR PC,GUOEB	;PEVAL INVOKED VIA "#"
	BEQ PROC1
	MOV B,@P	;OLD RETURN - POPPED LATER
	JSR PC,.BINDF	;IS A PROC DEFINED
	BEQ PROC3	;NO
	MOV #UFUN,CO	;YES
	MOV @P,B
PROC2:	CLR TOPS
	MOV B,CO+2
	SPOP B		;GET P BACK IN PHASE
	JMP EVF2
PROC3:	JSR PC,.LOAD	;GET PNAME FOR UOBSCH
PROC1:	MOV B,TOPS
	MOV #SFUN,A
	JSR PC,UOBSCH	;MAKE SURE CO EXISTS
	BNE .+4
	ERROR+HNM	;HAS NO MEANING
	MOV A,CO
	BR PROC2

EVL:	BIT #PTLPF,FLAGS	;WAS PREVIOUS TOKEN A LEFT PAREN
	BEQ EVL1		;NO
	BIT #VNAF,COF	;DOES CO USE VARIABLE NO. OF ARGS.?
	BEQ EVL1	;NO
	CLR NOR
EVL1:	JSR PC,GNT
EVW1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS
EVW:	JSR PC,EVAL	;EVALUATE THIS ARGUMENT
	BEQ EVW2	;NO OUTPUT FROM EVAL
	DEC NOR
	BEQ EVX		;WHEN NOR = 0, WE'VE ENUF INPUTS
	JSR PC,GNT
	TST NOR		;IF NOR < 0 AND NEXT TOKEN IS ")" THEN THE ")" 
	BGE EVW1	;TERMINATES THE ARG SCAN FOR THE CO
	CMP #$RPAR,CT+2  ;IS IT?
	BNE EVW1	;NO
	BIS #RTF,FLAGS
	BIC #CRF,FLAGS
	NEG NOR
	CMP #MAXARG,NOR
	BGE MEVALN	;EXECUTE MACHINE PROC.
	ERROR+TMAC	;TOO MANY ARGS COMMAND/OPERATION
EVX:	BIT #160000,CO	;IS IT A MACHINE PROCEDURE
	BEQ .+6
	JMP EVXP	;NO
	BIT #VNAF,COF	;MACHINE PROC NOW HAS ITS "STD" NO. OF ARGS.
		;IF IT CAN TAKE A VARIABLE NO., THEN THE "STD" NO. HAS
		;BE PUSHED ON P
	BEQ MEVAL	;IT DOESN'T- GO EVALUATE IT
	MOV COF,A
	SWAB A
	BIC #177774,A
	MOV A,NOR
	BR MEVALN	;SAME AS MEVAL BUT SAVES NO. OF ARGS
EVW2:	CMP #$LLPAR,CO+2	;EVAL SHOULD OUTPUT WHEN NOT AT TOP LEVEL
	BEQ EVW		;EXCEPT WHEN CO IS LLPAR
	ERROR+NOU	;WHAT, NO OUTPUT??!!

LLPAR:
LPAR:	JSR PC,GNT
	CMP #$RPAR,CT+2
	BEQ LPAR1
	ERROR+TIP	;TOO MUCH INSIDE PARENS
LPAR1:	CLZ
	RTS PC

RPAR:	BIT #PTLPF,FLAGS
	BEQ .+4
	ERROR+NIP	;NOTHING INSIDE PARENS
	CMP 4(P),#$LLPAR	;IS PENDING COMMAND !(
	BNE RPAR1
RPAR2:	POP A
	MOV (P),IFLEV
	ADD #6,P	;POP !( OFF STACK
	MOV A,(P)
	SEZ
	RTS PC

RPAR1:	ERROR+ERP	;EXTRA RIGHT PAREN
CKUI:	PUSH A
	MOV CO+2,A
	CMP A,#$PLUS	;+
	BNE CKUI1
	MOV #$UPLUS,A
CKUI0:	MOV A,CO+2
	ASL A
	MOV SOBLST(A),COF
	MOV #1,NOR
	JMP SRETA

CKUI1:	CMP A,#$MINUS	;-
	BNE CKUI2
	MOV #$UMINS,A
	BR CKUI0

CKUI2:	POP A
	RTS PC

MEVALN:	PUSH NOR
MEVAL:	JSR PC,STRACS
	MOV CO+2,A	;GET SOE POINTER
	CLR NBKTS
	ASL A
	JSR PC,@2+SOBLST(A)	;JMP ADDR IS IN 2ND WORD
	BNE XORT	;PROCEDUE OUTPUTS
	JMP XNORT	;NO OUTPUT
XORT:	MOV #EVI,A
	JMP NORT1

ORTNA:	MOV A,@S
	BR SRET
ORTNB:	MOV B,@S
	BR SRET
ORTNC:	MOV C,@S
	BR SRET
ORTND:	MOV D,@S
	BR SRET
ORTNE:	MOV E,@S
	BR SRET
ORTNF:	MOV F,@S
	BR SRET
ORTNP:	MOV	(SP)+,@S
	BR SRET


ORTA:	PUSHS A
	BR SRET
ORTB:	PUSHS B
	BR SRET
ORTC:	PUSHS C
	BR SRET
ORTD:	PUSHS D
	BR SRET
ORTE:	PUSHS E
	BR SRET
ORTF:	PUSHS F
	BR SRET
ORTP==.
ORTSP:	PUSHS	(SP)+

RETF:	POP F
	BR RETE1
RETE:	POP E
	BR RETD1
RETD:	POP D
	BR RETC1
RETC:	POP C
	BR RETB1
RETB:	POP B
	BR RETA1
RETA:	POP A
	SEZ
	RTS PC

RETF1:	SPOP F
RETE1:	SPOP E
RETD1:	SPOP D
RETC1:	SPOP C
RETB1:	SPOP B
RETA1:	SPOP A
RET:	SEZ
	RTS PC

SRETF:	POP F
	BR SRETE1
SRETE:	POP E
	BR SRETD1
SRETD:	POP D
	BR SRETC1
SRETC:	POP C
	BR SRETB1
SRETB:	POP B
	BR SRETA1
SRETA:	POP A	;POP A THEN DO CLZ RETURN
	BR SRET

SRETE1:	SPOP E
SRETD1:	SPOP D
SRETC1:	SPOP C
SRETB1:	SPOP B
SRETA1:	SPOP A	;POP A THEN DO CLZ RETURN
CKTYP:
SRET:	CLZ
	RTS PC
	.STITL PROCEDURE EVALUATOR
PEVAL:	JSR PC,CKSTG	;CHECK STORAGE
	MOV CO+2,B	;FIRST CHECK IF PROC IS THERE
	JSR PC,.BINDF	;GET BINDING
	BNE .+4
	ERROR+HNM	;PROCEDURE HAS NO MEANING
	JSR PC,SAVEVL	;SAVE ALL PROCEDURE INFORMATION

	;GET ARG LIST - PUT UOE POINTERS AND VALUES FROM THERE ON S
	MOV A,C		;SAVE PTR TO LLP (LIST OF LINEPTRS)
	JSR PC,.LOAD	;GET FLAGS,,#ARGS
	MOV B,FLAGS
	MOVB B,B
	SPUSH B		;PUSH # ARGS
	BIC #-<TPTF+TPSF>-1,FLAGS  ;CLEAR ALL BUT TRACE AND STEP FLAGS
	BNE PEV3
	BIT #TRACEF,FLAGS2	;IS TRACE SET?
	BEQ PEV6	;NO
PEV3:	MOV CO+2,B
	INC FUNLEV
	JSR PC,TINDNT	;SET SPACING ACCORDING TO FUNCTION LEVEL
	DEC FUNLEV
LANGC	<JSR PC,PPNAME	;PRINT PROCEDURE NAME
	PRTXT ^\'S INPUTS: \>,<
	PRTXT ^/LES INPUTS DE /
	JSR PC,PPNAME
	PRTXT ^/ SONT:/>
	MOV @P,B	;# OF ARGS
PEV6:	SPUSH C		;SAVE FOR BELOW (POINTS TO LASTLINEPTR)
	MOV B,D		;NO. OF ARGS
	BEQ PEV2	;NO ARGS
.IFNZ SWAPF
	JSR PC,.LOADC
	JSR PC,.LOAD
.ENDC
	SPUSH A		;SAVE PTR TO REST OF TITLE LINE
	CMP #SPUSHL,S	;ENOUGH ROOM ON S-PDL?
	BLOS .+6	;OK
	JSR PC,SPSWPO	;SWAP OUT S-PDL
	MOV D,B		;# OF ARGS
	ASL B		;MULTIPLY BY TWO FOR OFFSET
	MOV S,D
	MOV D,E
	SUB B,E
	MOV E,S
	ASR B
PEV7:	MOV (D)+,(E)+	;GET ARGS ON TOP OF STACK
	SOB B,PEV7
	MOV @P,A	;GET SAVED LLP PTR
PEV1:	TST FLAGS
	BNE PEV4	;TRACE IS SET
	BIT #TRACEF,FLAGS2
	BEQ PEV5	;NO TRACE
PEV4:	MOV -2(E),B	;TOP ARGUMENT
	MOV B,A
	INC NBKTS
	SPUSH D
	JSR PC,PRTAB	;PRINT TOKEN IN A,,B
	DEC NBKTS
	SPOP D
	MOV @P,A	;POINTER TO ARG ON TOP OF SATCK
PEV5:	JSR PC,.LOADA	;GET THE ARG
	MOV A,@P	;PTR. TO NEXT NODE
	CMP #$COMT,B	;IS CURRENT NODE A COMMENT?
	BNE PEV10
PEV12:	BIT #7777,A	;END OF ARGUMENT?
	BEQ PEV11	;YES
	JSR PC,.LOADA
	CMP #$COMT,B
	BNE PEV12
	BR PEV5
PEV10:	JSR PC,SAVVAR	;SAVE THIS VARIABLE BINDING
	MOV @P,A
	BIT #7777,A
	BEQ PEV11
	TST FLAGS
	BNE PEV10A
	BIT #TRACEF,FLAGS2
	BEQ PEV1
PEV10A:	PRTXT ^/,/
	BR PEV1		;GO DO NEXT ARG

PEV11:	SPOP C		;USED TITLE LINE POINTER
PEV2:	SPOP C		;PTR TO LLP THAT WAS PUSHED WAY ABOVE
	TST FLAGS
	BNE PEV2A	;TRACE SET
	BIT #TRACEF,FLAGS2
	BEQ PEV2B	;NO TRACE
PEV2A:	PRCR
PEV2B:	JSR PC,SAVPPS	;SAVE PDL PTRS
	BIS #1,CPDLP	;INDICATES PROC PUSH AS OPPOSED TO A LOCAL PUSH
	MOV CO+2,B
	CLR CPLN
	MOV C,CLP
	MOV B,CPP	;GET CPSN IN A
.IFNZ SWAPF
	JSR PC,GNASN
	MOV A,CPSN
.ENDC
	CLR CO
	CLR CO+2
	CLR IFLEV
	INC FUNLEV
	JMP MLOOP
SAVVAR:	;SAVE IN (D) VARIABLE BINDING OF UOE PT'ED TO BY B
		;GIVE IT NEW VALUE WHICH IS AT (E)
		;USES A,C.  TOPS MUST BE 0
		;BOTH D AND E ARE -()ED
	MOV B,-(D)	;SAVE UOE PTR
	MOV #VBIND,A	;THIS WILL CHECK SPDL THINGS--
			;NOP IT IF IT SEEMS TO CAUSE TROUBLE.  RWW
	JSR PC,.BINDL	;NOW GET VARIB. BINDING
	BEQ SAVV2	;NOT THERE
SAVV1:	MOV -(E),A	;GET NEW VALUE PTR
	MOV B,-(D)	;SAVE OLD VALUE PO[NTER
	MOV A,B
	JSR PC,.LDP1
	BIC #100000,A	;MAKE SURE BINDING NODE SAYS "VBIND"
	JSR PC,.STORE	;STORE NEW BINDING AWAY
	RTS PC

SAVV3:	TST -(E)
	CLR -(D)	;THERE IS NO OLD VALUE POINTER
	RTS PC

SAVV2:	TST -2(E)
	BEQ SAVV3	;IF NEW VALUE = 0, DON'T BOTHER TO CREATE CELL
	MOV #VBIND,A
	CLR B
	JSR PC,GRBAD1
	BR SAVV1

SAVPPS:	POP F	;SAVE P AND S PDL PTRS
	SPUSH CSPDLP
	MOV #SDLINK,A	;COMPUTE RELATIVE S PDL PTR
	SUB S,A		;CURRENT TOP OF S-PDL
	ADD SPRBAO,A	;# OF PDL BLOCKS SWAPPED OUT
	MOV A,CSPDLP
	SPUSH CPDLP
	MOV #PDLINK,A	;COMPUTE RELATIVE P PDL PTR
	SUB P,A
	ADD PRBAO,A
	MOV A,CPDLP
	JMP @F

TINDNT:	PUSH A	;TRACE INDENT
	MOV FUNLEV,A
TIND2:	DEC A
	BGT TIND1
	JMP RETA
TIND1:	SPACE
	BR TIND2
LOCAL:	JSR PC,GUOEB	;GET UOE PTR FROM S
LOC9:	MOV #SDLINK,F	;MOVE STUFF FROM S TO P PDLS
	SUB S,F
	ADD SPRBAO,F
	MOV CSPDLP,D
	BIC #1,D
	SUB D,F
	ASR F
	MOV F,A
	BLE LOC2
LOC1:	POPS D
	PUSH D
	DEC A
	BGT LOC1
LOC2:	MOV S,D	;NOW STORE AWAY PTR & OLD VALUE
	PUSHS #0
	MOV S,E
	PUSHS #0
	JSR PC,SAVVAR
	MOV F,A	;NOW RETURN STUFF FROM P TO S
	BLE LOC4
LOC3:	POP D
	PUSHS D
	DEC A
	BGT LOC3
LOC4:	MOV #PDLINK,A	;NOW MOVE STUFF FROM P TO S
	SUB P,A
	ADD PRBAO,A
	MOV CPDLP,D
	BIC #1,D
	SUB D,A
	ASR A
	MOV A,F
	BLE LOC6
LOC5:	POP D
	PUSHS D
	DEC A
	BGT LOC5
LOC6:	PUSH #1	;PUSH GOODIES ON P
	SPUSH CSPDLP
	SPUSH CPDLP
	BIC #1,CPDLP	;INDICATE LOCAL PUSH
	BIC #1,CSPDLP
	ADD #4,CSPDLP
	ADD #6,CPDLP
	MOV F,A
	BLE LOC8
LOC7:	POPS D	;NOW RETURN STUFF TO P
	PUSH D
	DEC A
	BGT LOC7
LOC8:	SEZ
	RTS PC


;CHECK (E) FOR VALID DATA TYPE IF CHEKUF ON
CKSARG:	BIT #CHEKUF,FLAGS2
	BNE .+4
	RTS PC

	SPUSH D		;D & E ARE USED
	SPUSH E
	MOV #CKLIST,D	;THIS RUNS THROUGH THE VALID TYPES
	MOV (E),E	;GET THE DATUM
	BIC #7777,E	;ITS TYPE
CKSAR1:	CMP (D)+,E	;IS THIS A VALID TYPE?
	BEQ CKSRET	;AHA! IS!
	TST (D)		;MORE VALID TYPES?
	BNE CKSAR1	;THERE ARE
	.BUG.		;THERE AIN'T--*DIE*

CKSRET:	SPOP E		;WELL AND GOOD--IT'S VALID.
	SPOP D
	RTS PC

.STITL PROC EVAL - "OUTPUT" "STOP"
OUTPUT:	TST FUNLEV
	BGT .+4
OUTPU1:	ERROR+OIP	;ONLY IN PROCEDURE
	MOV #SRET,PSTOPR ;"OUTPUT" (CLZ FOR RETURN)
	POPS TOPS1	;SAVE THE OUTPUT
	BR PSTP10
STOP:
PSTOP:	TST FUNLEV
	BLE OUTPU1
	MOV #RET,PSTOPR	;"STOP" AND "END" (SEZ FOR RETURN)
	CLR TOPS1
	MOV #PSTP15,ERFRET	;RETURN ADDRESS FROM ERROR SET FRAME
PSTP10:	MOV #PSTP18,DOFRET	;SAME FOR DO FRAME
	BIT #DORF,FLAGS		;IS THIS A DO OR READ FRAME?
	BEQ PSTP12	;NO
PSTP14:	JSR PC,RESPPS	;RESTORE PDLS
	POP B		;RETURN ADDRESS
	BIT #TF7,TFLAGS	;IS THIS AN ERROR SET FRAME?
	BEQ PSTP16	;NO
	MOV B,ERPROC
	BR PSTP14
PSTP16:	JSR PC,RESEVL	;RESTORE PROCEDURE VARIABLES
	MOV B,FLAGS
	BR PSTP10
PSTP12:	BIT #TPTF+TPSF,FLAGS	;STEP OR TRACE FLAGS SET?
	BNE PSTP11	;YES
	BIT #TRACEF,FLAGS2
	BEQ PSTP15	;NO TRACE
PSTP11:	JSR PC,TINDNT
	MOV CPP,B
	JSR PC,PPNAME
	MOV TOPS1,B
	BEQ PSTP13
	PRTXT ^\ OUTPUTS \
	INC NBKTS
	JSR PC,PNODAB	;USES A (PRINTS OUT OBJECT ON S AS STRING)
	DEC NBKTS
	PRCR
	BR PSTP15
PSTP13:	LANGC <PRTXTC ^\ STOPS.\>,<
	PRTXTC ^/ STOPPE./>
PSTP15:	JSR PC,RESPPS	;RESTORE PDLS
	BIT #TF7,TFLAGS	;IF IT WAS AN ERROR SET FRAME, GO TO @ERFRET
	BEQ PSTP21	;IT WASN'T
	POP ERPROC
	JMP @ERFRET
PSTP21:
	SPOP D	;# ARGS SAVED
	BEQ PSTOP4	;NO ARGS
PSTOP3:	POPS E		;GET OLD VARIBLE BINDING
	SPOPS B		;GET NEXT UOE PTR
	MOV #VBIND,A
	TST E		;IS OLD BINDING NIL?
	BNE PSTP31	;NO
	JSR PC,.UNBND	;YES, GET RID OF IT
	BR PSTP33
PSTP31:	JSR PC,.BINDL	;GET VARIB BINDING PTR
	BEQ PSTPE3	;NONE THERE
	MOV E,B		;GET OLD VARIB BINDING
	JSR PC,.STORE	;RESTORE OLD BINDING
PSTP33:	DEC D		;ONE LESS ARG
	BGT PSTOP3	;GET NEXT BINDING IF MORE LEFT
PSTOP4:	BIT #TF3,TFLAGS	;WAS IT A LOCAL PUSH OR PROC PUSH
	BEQ PSTP15	;LOCAL
	CMP #SRET,PSTOPR	;WAS IT "OUTPUT"
	BNE PSTP42	;NO
	PUSHS TOPS1	;PUT THE OUTPUT BACK ON S
	CLR TOPS
	CLR TOPS1
PSTP42:	BIT #DORF,FLAGS	;DO OR READ FRAME?
	BNE PSTP45	;YES
	DEC FUNLEV	;UP ONE LEVEL
PSTP45:
	JSR PC,RESEVL
	MOV B,FLAGS
	BIT #DORF,FLAGS
	BEQ .+6
	JMP @DOFRET
PSTP18:	TST FUNLEV	;IF AT TOP LEVEL, ALMOST DONE!
	BLE PSTOP9	;IT IS
PSTP43:	MOV CPP,B
	JSR PC,.BINDF	;MAKE SURE PROC IS IN
	BEQ PSTPE2	;PROCEDURE ... NOT HERE
.IFNZ SWAPF
	MOV CPP,B	;SEE IF PROC'S CPSN AGREE
	JSR PC,GNASN	;GET CPSN
	BEQ PSTPE3	;IMPOSSIBLE!!!
.ENDC
	MOV CLP,C
	BIS #TF3,TFLAGS
.IFNZ SWAPF
	CMP A,CPSN
	BEQ PSTP41	;OK
	BIC #TF3,TFLAGS
	MOV CPLN,B	;DON'T AGREE, GO RELOCATE LINE WE WERE IN
	JSR PC,GTLINE
	BEQ PSTPE4	;LINE NOT THERE
.ENDC
PSTP41:	MOV C,CLP
	JSR PC,.LOADC	;GET LLP NODE
	JSR PC,.LOAD	;GET LINE #
	MOV A,C
	JSR PC,.LOADC	;GET NEXT NODE-SEE IF SNUM (I.E. GEN NO.)
	BIC #7777,A
	CMP #SNUM,A
	BEQ .+4
	CLR B	;NOT SNUM, SO SET GEN NO. TO 0
	CMP B,CLGN	;ARE GEN #'S =?
	BNE PSTPE4
	BIT #TF3,TFLAGS	;IF PROC WASNT SWAPPED
	BEQ PSTOP8	;THEN CTP IS GOOD
PSTOP9:	CLR D
	MOV CTP,C
	BR PSTOP6
PSTOP8:	MOV CTN,D	;OK, NOW GET NODE NO.
	TST B	;IF B > 0, WE WERE LOOKING GEN NO.
	BEQ PSTOP6
	JSR PC,.LDP1
PSTOP7:	MOV A,C
PSTOP6:	JSR PC,.LOADC
	DEC D
	BGT PSTOP7
	MOV C,CTP
	MOV A,CT
	MOV B,CT+2
	JMP @PSTOPR
PSTPE2:	JSR PC,CHKER
	ERROR+PNH1	;POPPED PROCEDURE NOT HERE
PSTPE3:	JSR PC,CHKER
	.BUG.		;PROCEDURE STRUCTURE SCREWED
PSTPE4:	JSR PC,CHKER
	ERROR+LCE	;LINE CHANGED BY EDIT

RESPPS:	SPOP E	;RESTORE P AND S PDLS
	MOV CPDLP,A
	BIC #TF3+TF7,TFLAGS ;SAVE MODE OF PROC/LOCAL PUSH FLAG
	BIT #1,A
	BEQ .+10
	BIS #TF3,TFLAGS	;SET PROCEDURE PUSH FLAG
	BIC #1,A	;ALWAYS EVEN
	JSR PC,PPTA	;POP P TO (A)
	POP CPDLP	 ;RESTORE OLD CPDLP
	MOV CSPDLP,A
	BIT #1,A
	BEQ .+10
	BIS #TF7,TFLAGS	;ERROR SET FLAG
	BIC #1,A
	JSR PC,PSTA	;POP S TO (A)
	SPOP CSPDLP	;RESTORE OLD CSPDLP
	JMP @E

CHKER:	BIT #HERRF,FLAGS2  ;THIS IS A TERRIBLE THING TO HAPPEN
	BNE CKHER1	;AND IT'S HAPPENED BEFORE!
	BIS #HERRF,FLAGS2  ;OR IF NOT, "DON'T LET IT HAPPEN AGAIN!"
	RTS PC
CKHER1:	CPRTXT ^/HELP!!  RECURSIVE BUG!/
	JSR PC,PPLACE
	CLR CPP
	CLR FUNLEV
	CLR IFLEV
	CLR FLAGS
	JMP ERTL3	;CLEAN UP THE WORLD

DO:	MOV @S,A	;DO...(RUN)
	MOV A,B
	BIC #7777,A
	CMP #LIST,A	;INPUT MUST BE A LIST
	BEQ DO1		;OK
	ERROR+WTAB
DO1:	JSR PC,BLSTI
	PUSH PCHR
	MOV #BLST,PCHR
	CLR NBKTS
	JSR PC,PNODAB	;CONVERT THING ON S TO STRING ON S
	POP PCHR
	JSR PC,BLSTF
	BEQ DO3		;EMPTY STRING
	MOV TOPS,@S
DO2:	JSR PC,READ	;CONVERT STRING ON S TO TOKEN LIST ON S
	BEQ DO4		;NO TOKENS
	JSR PC,SAVEVL
	PUSH #0		;NO. OF ARGS
	JSR PC,SAVPPS	;SAVE PDL POINTERS
	BIS #DORF,FLAGS	;SET FOR DO FRAME
	BIS #1,CPDLP	;RESULTS IN PROC PUSH
	JSR PC,EVLINE	;EVALUATE THE LINE
	BEQ DO5		;NO OUTPUT
	MOV #-1,C
	MOV #RET,PSTOPR	;RETURN ADDRESS (NO OUTPUT)
	BR DO6
DO5:	POPS C		;GET THE "OUTPUT"
	MOV #SRET,PSTOPR	;RETURN ADDRESS (OUTPUT)
DO6:
	JSR PC,RESPPS	;RESTORE PDLS
	POP B
	JSR PC,RESEVL	;RESTORE PROC VALUES
	BIC #EVIFS+DORF,FLAGS
	BIC #-EVIFS-1,B	  ;EVIFS=PTLPF+CRF+RTF
	BIS B,FLAGS
	POPS B
	CMP #-1,C	;WAS THERE OUTPUT?
	BEQ DO7		;NO
	PUSHS C		;PUT "OUTPUT" BACK ON S
DO7:	CLR D
	MOV CTP,C
	JMP	PSTOP6
DO3:	POPS A
DO8:	SEZ
DO4:	RTS PC

SAVEVL:	POP F	;SAVE THE WORLD
	PUSH CPP		;PUSH THE WORLD!
.IFNZ SWAPF
	SPUSH CPSN
.ENDC
	SPUSH CPLN
	SPUSH CLP
	SPUSH CLGN
	SPUSH CTN
	PUSH CTP
	SPUSH FLAGS
	SPUSH CO
	SPUSH CO+2
	SPUSH IFLEV
	SPUSH ERPROC
	JMP @F

RESEVL:	POP F
	POP ERPROC	;PROC, RESTORE REST OF WORLD
	SPOP IFLEV
	SPOP CO+2
	SPOP CO
	SPOP B
	SPOP CTP
	SPOP CTN
	SPOP CLGN
	POP CLP
	SPOP CPLN
.IFNZ SWAPF
	SPOP CPSN
.ENDC
	SPOP CPP
	JMP @F
	.STITL "TO" ETC.
GTLN:	JSR PC,GTUOEB	;GET LINE # FROM NEXT TOKEN INTO B
	BEQ DO8
	MOV #SNUM,A
	JSR PC,CONVER	;MAKE NEXT TOKEN INTO AN SNUM
	RTS PC
GTLP:	PUSH CPP	;GET LINE PTR OF LINE (B) FOR PROC (TOPRNM)
	MOV TOPRNM,CPP	;LEAVE PTR IN C
	JSR PC,GTLINE
	BEQ GTLP1
	POP CPP
	CLZ
	RTS PC

GTLP1:	POP CPP
	ERROR+LDE
EDTITL:	TST TOPRNM
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	JSR PC,EDITA	;SET UP FOR EDIT BUFFER INSERT
	PUSH PCHR
	MOV #ETYO,PCHR
	MOV TOPRNM,B
	JSR PC,SHTITL	;"PRINT" TITLE LINE INTO EDIT BUFFER
	BNE .+4
	.BUG.
	JSR PC,EDITE	;CLEAN UP EDIT BUFFER INPUT
	BIS #EDTIF2,FLAGS
	BR EDLIN1
EDLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	BNE .+4
	ERROR+ELW	;EDIT LINE WHAT
	JSR PC,GTLP	;GET PTR TO THAT LINE
	JSR PC,EDITA
	PUSH PCHR
	MOV #ETYO,PCHR
	JSR PC,.LOADC	;GET PTR TO LINE (IN LLP NODE)
	PUSHS B	;FOR INPUT TO PRLN
	JSR PC,PRLN	;"PRINT" THE LINE TO THE EDIT BUFFER
	POPS B
	JSR PC,EDITE
EDLIN1:	POP PCHR
	SEZ
	RTS PC
EDIT2:	CMP #TYI,GCHR
	BNE EDIT3
	CMP #INFIX,A
	BHIS .+4
	ERROR+WTAB
	ERROR+UBL
EDIT3:	JSR PC,CVSFLS
	MOV TOPS,B
	JSR PC,GRBAD
	MOV C,TEMP
	BIS #LIST,C
	MOV C,TOPS2
	BR TO86
EDIT1:	.IFNZ ENG
	CMP #$TITLE,B
	BEQ EDTITL
	CMP #$LINE,B
	BEQ EDLINE
.ENDC
.IFNZ FR
	CMP #$TITRE,B
	BEQ EDTITL
	CMP #$LIGNE,B
	BEQ EDLINE
.ENDC
		;NOT A VALID EDITING COMMAND
	TST B	;IS THIS A CR?
	BEQ .+4
	ERROR+NEC
	BIS #EDITF,FLAGS
	MOV LASTPR,B
	BNE TO0
	ERROR+UELX
EDIT:	BIC #EDTIF,FLAGS
	JSR PC,GTUOEB	;LOOK AT NEXT TOKEN
	BNE EDIT1	;NOT A UOE
	BIS #EDITF,FLAGS
	BR TO0
TO:	BIC #EDITF,FLAGS
	JSR PC,GTUOEB	;GET UOE PTR FROM NEXT TOKEN
	BNE EDIT2
	BIC #170000,B
	BIS #UFUN,B
	MOV B,TOPS2	;SO THIS "TOTALLY WORTHLESS ATOM WONT BE G.C.
	JSR PC,TITLDF
TO0:	TST TOPRNM
	BEQ TO8
	MOV FNLLP,TMPBLK
	BIT #EDTIF,FLAGS
	BNE TO8
	ERROR+CTIT	;CANT "TO" IN TO
TO8:	MOV B,TEMP
	CLR TOPS
	JSR PC,.BINDF
	BEQ TO6
	BIT #EDTIF,FLAGS
	BEQ TO84
	CMP TOPRNM,TEMP
	BNE TO85
	MOV TOPS1,A
	BIS #LIST,A
	JSR PC,.STP2
	MOV TOPS1,B
	BR TITED1
TO84:	MOV A,FNLLP
	BIT #EDITF,FLAGS	;IS IT "EDIT"?
	BNE TO5	;YES
	CMP #TYI,GCHR	;IS INPUT FROM TTY?
	BNE .+4
	ERROR+PAE	;YES - PROCEDURE ALREADY EXISTS
TO86:	BIS #SPDF,FLAGS	;NO - SET SKIP PROC DEF. FLAG
	MOV TEMP,TOPRNM
TO81:	BIT #CRF,FLAGS
	BNE TO82
	JSR PC,GNT	;READ TO END OF LINE
	BR TO81
TO82:	CLR TOPS
	CLR TOPS1
	CLR TOPS2
	RTS PC
TO7:	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
	JSR PC,.LOAD
	MOV A,FNLLP
TO5:	MOV TEMP,TOPRNM
	MOV #'>,PRMTCH
	BR TO82
TO6:	BIT #EDTIF,FLAGS	;EDITING TITLE?
	BNE TITED
	BIT #EDITF,FLAGS	;IS IT "EDIT"
	BEQ TO7	;NO
	ERROR+PNH	;YES, PROCEDUTE NOT HERE
TO85:	ERROR+PAE	;PROC (TEMP) ALREADY EXISTS
TITED:	;EDIT THAT TITLE...
	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
TITED1:	JSR PC,.LOAD
	MOV A,FNLLP
;MAKE NEW PROC POINT TO OLD LINES
	MOV A,C
	MOV TMPBLK,B
	JSR PC,.LOAD
	JSR PC,.STP1
	CMP TEMP,TOPRNM
	BEQ TITED2
	MOV TOPRNM,B
	MOV #FBIND,A
	JSR PC,.UNBND
	MOV TEMP,TOPRNM
TITED2:	BR TO82
GO:	MOV CPLN,JPLN	;SAVE CURRENT LINE # AS LINE JUMPED-FROM
	JSR PC,G1NARG
	MOV B,CPLN
	CLR CLP
	CLR CT
	CLR CT+2
	BIC #RTF,FLAGS
	SEZ
	RTS PC

RETURN:	JSR PC,G1NARG
	MOV B,TMPBLK
	MOV #RETU1,PSTOPR
	MOV #RETU3,ERFRET	;CATCH ERROR SET FRAME
	MOV #PSTP15,DOFRET
RETU1:	TST FUNLEV
	BEQ PROCE1
	JMP PSTP15
RETU3:	MOV #RETU2,PSTOPR
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
.IFNZ SWAPF
	MOV #-1,CPSN
.ENDC
	BR PROCE2
RETU2:	MOV TMPBLK,CPLN
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
	CLR CTP
	CLR CLP
	JMP MLOOP
CONTINUE:	MOV	USER,U
	JSR	PC,BRKMON	;RESTART MUSIC BOX IF APPROPRIATE
	MOV #MLOOP,PSTOPR
	MOV #PSTP15,DOFRET
PROCE2:	TST FUNLEV
	BEQ PROCE1
	BIT #DORF,FLAGS
	BEQ PROCE3
PROCE4:	JSR PC,RESPPS
	POP B
	JSR PC,RESEVL
	BR PROCE2
PROCE3:	MOV CPDLP,A
	BIC #1,A
	JSR PC,PPTA
	MOV CSPDLP,A
	JSR PC,PSTA
	BIC #BRKF,FLAGS
	JMP PSTP43	;TRY RESTARTING
PROCE1:	JMP ERTL3

GTUOEB: 	JSR PC,GNT	;GET UOE PTR FROM NEXT TOKEN IN B
	BIT #CRF,FLAGS
	BEQ .+4
	ERROR+UEL	;UNEXPECTED END OF LINE
	BIC #7777,A	;SKIP UNLESS NEXT TOKEN NOT UOE.  USES A
	CMP #UFUN,A
	BEQ GTU1
	CMP #ATOM,A
	BEQ GTU1
	CMP #LSTR,A
	BNE GTU2
	MOV B,TOPS
	JSR PC,.INTRN
GTU1:	CLR TOPS
GTU2:	RTS PC
TITLDF:		;INPUT-CURRENT TOKEN LIST VIA GNT
		;OUTPUT-TOPS1  - POINTS TO FIRST NODE OF LLP
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV CT,TEMP
	CLR D
TO3:	JSR PC,GNT
	BIT #CRF,FLAGS
	BNE TO4	;DONE
	BIC #7777,A
	INC D
	CMP #UVAR,A
	BEQ TO3
	ERROR+WIT	;WRONG TYPE OF INPUT TO "TO"
TO4:	CMP #MAXARG,D
	BGE TO9
	ERROR+TMAP	;TOO MANY ARGS (PROCEDURE)
	CLR D	;THIS ERROR RETURNS HERE!!
	CLR TEMP
TO9:	MOV #LIST,A
	MOV A,B
.IFNZ SWAPF
	JSR PC,GRBAD	;ZEROTH NODE IN LLP - PTS TO SWAP INFO
	MOV C,TOPS1	;SAVE - PTR TO LLP
.ENDC
	MOV #SNUM,A
	MOV D,B
.IFNZ SWAPF
	JSR PC,GRBAD2	; - # ARGS NODE
	CLR B
	JSR PC,GRBAD1	; - CPSN NODE (START CPSN AT 0)
	MOV TOPS1,C
.IFF
	JSR PC,GRBAD
	MOV C,TOPS1
.ENDC
	MOV #LIST,A
	MOV A,B
	JSR PC,GRBAD1	;FIRST NODE OF LLP - POINTS TO ARG LIST
	MOV TEMP,A
	BIC #170000,A
	BIS #SNUM,A
	MOV D,B	;# ARGS SAVED ABOVE
	JSR PC,GRBAD2	;FIRST NODE OF LINE 0 (ARG LINE)
	JMP RETD
END:	MOV TOPRNM,B
	BNE .+4
	ERROR+OIPD	;ONLY IN PROCEDURE DEFINITION
	MOV B,LASTPR	;SAVE FOR "PO"
	TST REDFLG
	BEQ END4
	BIT #SPDF,FLAGS
	BEQ END3
END4:	TST FUNLEV	;DON'T PRINT "FOO DEFINED" IF NOT AT TOP LEVEL
	BEQ END5
	BIT #BRKF,FLAGS
	BEQ END3
END5:	JSR PC,PPNAME
	BIT #SPDF,FLAGS
	BNE END1
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^\ DEFINED\
.IIF NZ FR,	PRTXTC ^/ EST DEFINI/
.IFF
	BIT #FRFLG,LANG
	BEQ END6
	PRTXTC ^/ EST DEFINI/
	BR END7
END6:	PRTXTC ^/ DEFINED/
END7:
.ENDC
END3:	CLR TOPRNM
	BIC #SPDF,FLAGS
	MOV #'?,PRMTCH
END2:	SEZ
	RTS PC
END1:
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^/ SKIPPED/
.IIF NZ FR,	PRTXTC ^/ A ETE PASSE/
.IFF
	BIT #FRFLG,LANG
	BEQ END8
	PRTXTC ^/ A ETE PASSE/
	BR END9
END8:	PRTXTC ^/ SKIPPED/
END9:
.ENDC
	BR END3
	.STITL UTILITY - COUNT LIST ELEMENTS
CLE:		;COUNT LIST ELEMENTS
		  ;IN - LIST PTR IN C
		 ;OUT - # OF ELEMENTS IN B
	PUSH A
	SPUSH C
	CLR B
	MOV C,A
CLE1:	BIT #7777,A
	BEQ CLE2
	MOV A,C
	JSR PC,.LDP1
	INC B
	BR CLE1
CLE2:	POP C
	SPOP A
	RTS PC
	.STITL UTILITY - ADD A LINE
ADLN:		;ON S IS A "NEW LINE" INSERT IN PROPER PLACE
		;IN LLP POINTED TO BY FNLLP.
		;IF "NEW LINE" # IS NEG, DELETE THE LINE
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	MOV @S,C
	JSR PC,.LOADC
	MOV B,F	;SAVE LINE #
	BLT ADLN6	;IF < 0, THIS IS A DELETE
	BIC #TF4,TFLAGS
ADLN7:	MOV FNLLP,C
	JSR PC,.LOADC	;SKIP OVER ARG LINE
	MOV C,D
	MOV A,C
	;LOOK DOWN LLP FOR LINE #(@P)
ADLN1:	MOV D,E	;SAVE PTR TO PREDECESSOR IN E
	MOV C,D	;SAVE PTR TO CURRENT IN D
	MOV #LIST,A
	BIT #7777,C
	BEQ ADLN2	;AT END, ADD NEW NODE
	JSR PC,.LOADC
	MOV A,C	;SAVE PTR TO SUCCESSOR IN C
	JSR PC,.LOAD
	CMP B,F
	BLT ADLN1	;NOT THERE YET
	BEQ ADLN3	;FOUND LINE
	MOV D,A	;OTHERWISE, INSERT NEW LINE
ADLN2:	BIT #TF4,TFLAGS	;PASSED IT - IF DELETE
	BNE ADLN5	;ALL DONE
	MOV @S,B	;ADD NEW NODE TO END
	MOV E,C
	JSR PC,GRBAD1
ADLN5:	JMP RETF
ADLN3:	BIT #TF4,TFLAGS	;FOUND LINE NO.  DELETE?
	BEQ ADLN31	;NO
	MOV C,A	;YES
	MOV E,C
	JSR PC,.STP1
	BR ADLN5
		;NOT DELETE, REPLACE THEN CHECK GEN. NO.
ADLN31:	MOV A,E	;SAVE A, POINT TO FIRST TOKEN IN OLD LINE
	MOV @S,A
	MOV D,C	;D POINTS TO RELEVENT LLP NODE
	JSR PC,.STP2	;STORE LINK TO NEW LINE
	TST FUNLEV	;IF AT FUNLEV 0, DON'T BOTHER WITH GEN #
	BEQ ADLN5
	MOV E,C	;E POINTS TO OLD LINE
	JSR PC,.LOADC	;GET NEXT NODE IN OLD LINE(1ST TOKEN OR GEN )
	BIC #7777,A
	CMP #SNUM,A
	BEQ ADLN4
	CLR B
ADLN4:	INC B	;ALREADY HAS GEN NO.
	MOV @S,C
	JSR PC,.LDP1
	BIC #170000,A
	BIS #SNUM,A
	JSR PC,GRBAD1
	BR ADLN5
ADLN6:	NEG F
	BIS #TF4,TFLAGS
	BR ADLN7
	.STITL UTILITY - GET A LINE, GET ARGS
GTLINE:		;GET LLP POINTER OF LINE WHOSE NO. IS IN B
			;FOR PROCEDURE PONTED TO BY "CPP"
			;OUTPUT - LLP PTR WILL BE IN C AND WILL SKIP
	BIS #TF1,TFLAGS
	BR .+10
GNLINE:		;SAME EXCEPT LOOKING FOR LINE WHOSE # IS > # IN B
	BIC #TF1,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	MOV B,D
	MOV CPP,B
	JSR PC,.BINDF	;LOOK FOR PROC BINDING
	BNE .+4
	.BUG.	;WHAT NO PROC BINDING??!!
	JSR PC,.LOADA
	MOV A,E
GNL1:	BIT #7777,E
	BEQ GNL4	;NONE LEFT
	MOV E,C
	JSR PC,.LOADC	;GET NEXT NODE IN LLP
	MOV A,E
	JSR PC,.LOADB	;GET FIRST NODE OF THAT LINE
	CMP B,D
	BLT GNL1	;NOT THERE YET
	BEQ GNL2	;FOUND IT
	BIT #TF1,TFLAGS	;WENT PAST, WERE WE LOOKING FOR IT?
	BEQ GNL3	;NO, OK
GNL4:	JMP RETE	;YES "NO SUCH LINE NO."
GNL2:	BIT #TF1,TFLAGS	;FOUND IT, LOOKING FOR IT?
	BEQ GNL1	;NO, GET NEXT
GNL3:	MOV C,4(P)	;OUTPUT (C) INTO C
	JMP SRETE
GNASN:		;GET NO. OF ARGS AND CPSN OF USER PROC
		;IN: PROC PTR IN B
		;OUTPUT: CPSN IN A # IN B
		;DONT SKIP IF NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BNE .+6
	JMP RETC
	JSR PC,.LOADB
	MOV B,2(P)	;# IN OLD B
.IFNZ SWAPF
	JSR PC,.LOADA
	MOV B,4(P)	;CPSN IN OLD A
.ENDC
	JMP SRETC
	.STITL UTILITY - LOAD AND STORE
.LOADA:	MOV A,B		;(A) -> A,,B
	BR .LOAD
.LOADC:	MOV C,B	;NODE ADDR IN C
		;NODE RETURNED IN A,B
.LOADB:
.LOAD:	BIC #170000,B	;NODE ADDR IN B
	ASL B	;NODE RETURNED IN A,B
	ASL B
	ADD #NODESP,B
	MOV (B)+,A
	MOV @B,B
	RTS PC
.STORE:	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ASL C	;NODE IN A,B IS STORED AT C
	ASL C
	ADD #NODESP,C
	MOV A,(C)+
	MOV B,@C
	SPOP C
	RTS PC

.STP2:		;SAME AS .STP1 EXCEPT STORE IN 2ND WORD OF NODE
	SEC	;THEN RESULT OF ROL'S WILL BE TWO GREATER THAN  .STP1
	BR .+4
.STP1:	CLC	;STORE (A) IN FIRST WORD OF NODE AT C
	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ROL C
	ROL C
	ADD #NODESP,C
	MOV A,@C
	SPOP C
	RTS PC

.LDP2:	SEC		;NODE ADDR IN C (TYPE FIELD =0)
	BR .+4		;LOAD 2ND WORD OF NODE INTO A
.LDP1:	CLC		;SAME AS .LDP2 EXCEPT 1ST WORD
	MOV C,A
	BIC #170000,A
	ROL A
	ROL A
	ADD #NODESP,A
	MOV @A,A
	RTS PC

.LDP2I:	MOV C,A	;SAME AS .LDP2 EXCEPT C WILL
	BIC #170000,A	;CONTAIN ADDR OF NEXT NODE
	ASL A
	ASL A
	ADD #NODESP,A
	MOV (A)+,C
	MOV @A,A
	RTS PC
	.STITL UTILITY - BINDING
	;INPUT:	A=TYPE	B=UOE POINTER
	;		TOPS=0 OR TYPE+VALUE POINTER
	;OUTPUT:	A - UCHANGED
	;		B - EITHER UNCHANGED OR VALUE POINTER
	;		C - POINTS TO BINDING NODE, EITHER 
	;		    RELEVANT ONE OR LAST IN BINDING LIST
	;		IF TOPS = 0, SKIPS IF BINDING FOUND
	;		IF TOPS NOT = 0, TOPS WILL BE INSERTED
	;		   AS THE NEW VALUE POINTER (A NEW BINDING
	;		   NODE WILL BE ADDED IF NECESSARY) NEVER SKIPS.
.BINDL:	TST TOPS
	BEQ .BIND
	PUSHS TOPS
	CLR TOPS
	JSR PC,.BIND
	BEQ .BNDL2
	POPS TOPS
	CLZ
	RTS PC
.BNDL2L:	POPS TOPS
	SEZ
	RTS PC

.BIND:	PUSH D
	SPUSH B
	SPUSH A
	MOV B,A
BINDF1:	MOV A,C
	JSR PC,.LOADC
	MOV A,D
	BIC #7777,D
	CMP @P,D
	BEQ BINDF4	;FOUND IT
	BIT #7777,A
	BNE BINDF1
	TST TOPS	;DIDNT FIND IT
	BEQ BINDF2	;SHOULD ONE BE CREATED?
	SPOP A
	MOV TOPS,B
	JSR PC,GRBAD1
BINDF5:	POP D	;OLD B
BINDF3:	SPOP D
	SEZ
	RTS PC

BINDF2:	POP A	;NO, DONT CREATE NODE
	SPOP B
	BR BINDF3

BINDF4:	TST TOPS	;FOUND, CHANGE VALUE POINTER?
	BEQ BINDF6
	MOV TOPS,A	;YES + DONT SKIP
	JSR PC,.STP2
	POP A
	BR BINDF5

BINDF6:	POP A	;NO, LEAVE VALUE POINTER, BUT SKIP
	SPOP D	;OLD B
	SPOP D
	CLZ
	RTS PC
.UNBND:	PUSH A	;ERASE TYPE (A) FROM UOE (B)
	SPUSH B	;SKIP UNLESS NOT FOUND
	SPUSH C
	SPUSH D
	MOV B,C
.UNB1:	MOV C,D
	MOV B,C
	BIT #7777,C
	BNE .+6
	JMP RETD
	JSR PC,.LOADC
	MOV A,B
	BIC #7777,A
	CMP 6(P),A
	BNE .UNB1
	MOV D,C
	JSR PC,.LDP1
	BIC #7777,A
	BIC #170000,B
	BIS B,A
	JSR PC,.STP1
	JMP SRETD
.BINDF:	MOV #FBIND,A	;GET FUNCTION BINDING, SWAP IN IF NECESSARY
		;PTR TO UOE IN B
		;OUTPUT AS IN .BIND: EXCEPT A,,B = NODE PTD TO BY C
	JSR PC,.BINDL	;LOOK FOR FUNCTION BINDING
	BEQ BIF1
	JSR PC,.LOADB
	BIT #7777,A	;IS PROC SWAPPED IN?
	BNE BIF1	;YEP
	JSR PC,PSWPIN	;GO GET IT
	CLZ
BIF1:	RTS PC

.BNDFS:	MOV #FBIND,A	;SAME AS .BINDF EXCEPT DONT SWAPIN
	JSR PC,.BINDL
	BEQ BIF1
	JSR PC,.LOADB
	CLZ
	RTS PC

	.STITL .INTRN!!
.OBSCH:		;SAME AS .INTRN EXCEPT WONT INSERT IF ENTRY ISNT FOUND
		;(ALSO SEE UOBSCH ON NEXT PAGE)
	BIC #TF5,TFLAGS
	BR .+10
.INTRN:		;(ALSO SEE UINTRN ON NEXT PAGE)
		;INPUT:  TYPE IN A, LSTR IN "TOPS"
		;OUTPUT:  IF TYPE IS UFUN OR SFUN,
		; SEARCH SYSTEM OBLIST FIRST.
		;  IF FOUND THERE, RETURN THAT PTR IN B,
		; MAKING TYPE OF A TO "SFUN".
		;  IF NOT FOUND THERE, AND IF A=UFUN, OR IF TYPE
		;  IS > "UFUN", DO THE LOOKUP IN THE USER OBLIST.
		;  RETURN WITH THE UOE PTR IN B.
		; DONT SKIP IF A NEW ONE HAD TO BE ADDED,
		;  OR IF IN SEARCHING FOR AN SFUN
		;  ONE WAS NOT FOUND.
;*******  NOTE  ********
;A NEW UOE IS "TOTALLY USELESS" AND SO MUST BE PROTECTED FROM G.C.
	BIS #TF5,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
	CMP #UFUN,A	;IS TYPE SFUN OR UFUN
	BLO INT2	;NO
	JSR PC,SSOL	;YES, SEARCH SYSTEM OBLIST
	BEQ INT1	;NOT THERE
	MOV #SFUN,4(P)	;SET TYPE TO "SFUN"
	BR INT5

INT1:	CMP #SFUN,A	;IS A = TYPE SFUN
	BEQ INT0	;YES, DONE, DONT SKIP
INT2:	JSR PC,HSSL	;NO, HASH TO AND SEARCH SUBLIST
	BEQ INT3

INT5:	MOV B,2(P)
	JMP SRETC	;FOUND ATOM

INT3:	BIT #TF5,TFLAGS	;NOT THERE, SHOULD IT BE ADDED
	BEQ INT0	;NO, RETURN AND DONT SKIP
	SPUSH B		;SAVE WORD POINTER TO LAST NODE OF BUCKET
	MOV #LIST,A
	MOV #ATOM,B
	JSR PC,GRBAD	;CONS UP NEW LAST NODE
			;  (STRANGE TYPE LEST GARBAGE COLLECT)
	BIS #LIST,C
	PUSHS C		;SAVE POINTER TO IT, ALSO FOR G.C.
	MOV #ATOM,A
	MOV TOPS,B
	JSR PC,GRBAD2	;CONS UP ATOM NODE; NEW BUCKET NODE PTS TO IT
	MOV C,4(P)	;SO WILL B ON RETURN
	POPS C
	BIC #LIST,C	;GET BACK POINTER TO NEW BUCKET NODE

	MOV #BUKTEL,A
	JSR PC,.STP1	;MAKE IT AN END-OF-BUCKET NODE
	BIS C,A		;OLE & PTR TO IT
	SPOP C		;TO OLD END-OF-BUCKET WORD
	MOV A,(C)

INT0:	JMP RETC


;"UNPURE" .INTRN AND .OBSCH
;BY "UNPURE" IT IS MEANT THAT THE INPUT STRING MAY INCLUDE
;NULL CHARACTERS
;SPECIFICATIONS ARE OTHERWISE IDENTICAL TO .INTRN AND .OBSCH

;ROUTINE TO PURIFY STRING
UINOB:	PUSH A
	PUSH B
	PUSH C
	MOV	TOPS,B
	JSR PC,CPYSTR	;OUTPUT POINTER IN B TO STRING WITH NO NULLS
	BIS #LSTR,B
	MOV	B,TOPS
	POP C
	POP B
	POP A
	RTS PC

UINTRN:	SPUSH #.INTRN
	BR UINOB

UOBSCH:	SPUSH #.OBSCH
	BR UINOB
	.STITL SEARCH SYSTEM OBLIST
SSOL:		;SEARCH SYSTEM OBLIST
		;INPUT:  C POINTS TO STRING
		;OUTPUT:  SKIP = FOUND AND SOE PTR IN B
		;  NO SKIP = NOT FOUND AND NO CHANGE
		;NULL MUST BE USED AS FILLER CHAR BUT NOT BE IMBEDDED
	PUSH A
	SPUSH B
	SPUSH C		; -> STRING (DESIRED PNAME)
	SPUSH D		; -> CURRENT PNAME
	SPUSH E		; 2^N
	SPUSH F		; -> SYSTEM OBLIST ELEMENT
	MOV SOBP2,E	;GET 2^N
	MOV #SOBLST,F	;GET START OF OBLIST
SSOL1:	ASR E		;HALVE 2^N
	BIT #177776,E	;NOT FOUND IF 2^N = 1
	BEQ SSOL5
	ADD E,F		;ADD 2^N TO OBLIST PTR
	CMP F,SOOMX	;OVERSHOT END OF LIST THEN UNDO ADD
	BHIS SSOL2
	MOV @F,D
	ADD #4+SOBLST,D	;FIND START OF THIS PNAME
	MOV C,A		;AND DESIRED PNAME
SSOL4:	JSR PC,.LOADA	;GET TWO CHARS OF DESIRED
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED:  ADD 2^(N-1)
	BLO SSOL2	;PNAME > DESIRED:  UNADD 2^N AND ADD 2^(N-1)
	SWAB B
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED
	BLO SSOL2	;PNAME > DESIRED
	BIT #7777,A	;MORE PNAME TO COMPARE?
	BNE SSOL4	;YES
	TSTB B		;MATCHING NULLS FOUND?
	BEQ SSOL3	;FOUND
	TSTB (D)	;AT END OF STRING, IS IT END OF SYS PNAME
	BNE SSOL2	;NO:  TRY ANOTHER (COUNT AS OVERSHOOT)
SSOL3:	MOV (F),F	;POINTER TO OBLIST ELEMENT
	.IFNZ ENG&FR
	BIT LANG,SOBLST(F)
	BEQ SSOL5
	.ENDC
	BIT #ABRFLG,SOBLST(F)	;IS IT AN ABBRVIATION?
	BEQ .+6
	MOV 2+SOBLST(F),F	;YES, "EXPAND" IT
	ASR F
	MOV F,10(P)	;YES, SAVE F AS OUTPUT
	JMP SRETF

SSOL5:	JMP RETF

SSOL2:	SUB E,F		;UNADD 2^N
	BR SSOL1
	.STITL HASH AND SEARCH USER SUB-OBLIST
HSSL:		;HASH, THEN SEARCH SUB-LIST
		;INPUT:  C POINTS TO LSTR
		;OUTPUT:  IF NOT FOUND, B IS A WORD POINTER
		;	 TO LAST BUCKET ELEMENT.
		;  IF FOUND, B POINTS TO ATOM CELL, AND RETURN SKIPS.
	PUSH A
	SPUSH B		;PTR TO THIS PNAME
	SPUSH C		;PTR TO DESIRED PNAME
	SPUSH D		;NEXT OLE
	SPUSH E		;THIS OLE
	MOV C,A		;PTR TO STRING
	CLR D		;SUM OF WORDS FOR HASHING
HSSLA:	JSR PC,.LOADA	;GET A TWO-LETTER FRAGMENT
	ADD B,D		;ADD IN
	BIT #7777,A	;MORE FRAGMENTS?
	BNE HSSLA	;YES
	MOV D,B		;CREATE SUM OF ALL CHARS
	SWAB B
	ADD D,B		;IN LOWER BYTE (UPPER WON'T HURT)
	CLR A
	DIV #HCC,A
	ASL B
	ADD #UHCT,B
	MOV B,E		;RETURN ADDR OF LAST ELEMENT OF BUCKET IF NOT FOUND
	MOV @B,A	;A POINTS TO FIRST OLE NOW
HSSL1:	BIT #7777,A	;END OF BUCKET?
	BNE HSSLB
	MOV E,6(P)	;YES: NOT-FOUND RETURN:
	JMP RETE	;OUTPUT END-OF-BUCKET POINTER IN B

HSSLB:	MOV A,E		;SAVE PTR TO THIS OLE
	JSR PC,.LOADA	;GET THIS OLE
	MOV A,D		;SAVE PTR TO NEXT ONE
	JSR PC,.LOADB	;GET FIRST NODE OF ATOM STRUCTURE
	JSR PC,CSEQ	;CSEQ COMPARES STRINGS AT (B) AND (C)
	BEQ HSSL2	;NOT EQUAL:  TRY NEXT OLE
	MOV E,A		;EQUAL:
	JSR PC,.LOADA	;OUTPUT ATOM POINTER
	MOV B,6(P)
	JMP SRETE	;SKIP RETURN

HSSL2:	MOV D,A		;NOT FOUND, CHECK NEXT BUCKET ELEMENT
	BIC #LIST,E	;MAKE E A WORD PTR TO FIRST WORD OF PREV. NODE
	ASL E		;IN CASE IT'S THE LAST ONE.
	ASL E
	ADD #NODESP,E
	BR HSSL1
CSEQ:	PUSH A		;COMPARE TWO STRINGS - POINTERS IN B & C
	PUSH B		;SKIP IF EQUAL
	PUSH C		;"NULL" (8-BIT ON) CHARACTERS
	PUSH D		;  DON'T MATCH CORRESPONDING 8-BIT OFF CHARS
	MOV B,D		;SAVE STR 1 PTR
CSEQ1:	BIT #7777,D	;CHECK IF EITHER STRING DONE
	BEQ CSEQ3	;FIRST IS:  IS SECOND?
	BIT #7777,C
	BEQ CSEQ2	;SECOND BUT NOT FIRST:  NOT EQUAL
	MOV D,A
	JSR PC,.LOADA	;GET NEXT NODE OF STR 1: (A) TO A,,B
	MOV A,D	;SAVE POINTER IN D
	JSR PC,.LDP2I	;GET NEXT NODE OF STR 2: (C) TO C,,A
	CMP A,B
	BEQ CSEQ1	;WELL, THESE WORDS MATCH
CSEQ2:	JMP RETD	;STRINGS NOT EQUAL

CSEQ3:	BIT #7777,C	;SEE IF BOTH STRINGS ARE DONE
	BNE CSEQ2	;NOPE, NOT EQUAL
	JMP SRETD	;STRINGS EQUAL
	.STITL MINI SWAPPING
PSWPIN:	BPT
PSWPOT:	BPT
VSWPIN:	BPT
VSWPOT:	BPT
DSVB:	BPT	;DELETE SWAPPED VARIABLE BINDING
	.STITL UTILITY - GRAB NODE ROUTINES
GRBAD2:	SEC	;GRAB A FREE NODE, FILL IT WITH A,,B
			;IF C NOT =0, PUT PTR TO NEW NODE IN WORD 2 OF NODE(C)
			;C ALSO GETS POINTER TO NEW NODE REGARDLESS
	BR .+6
GRBAD:	CLR	C	;SAME AS ABOVE EXCEPT NEW POINTER ALWAYS IN C
GRBAD1:	CLC	;SAME AS ABOVE EXCEPT NEW PTR IN WORD 1
	SPUSH A
	BIC #170000,C
	BEQ GRB2	;C IS ZERO, FORGET STORING NEW NODE PTR
	ROL C
	ROL C
	ADD #NODESP,C	;ELSE MAKE NODE ADDRESS TO STORE AT
GRB2:
;	MOV UNGRAB,A
;	BNE GRB1	;IDLE THEN?
;	JIGGLE
	BIT #MGCF,FLAGS2
	BNE GRB4
	MOV FREE,A
	BNE GRB1
GRB4:	JSR PC,.GCOLL
	MOV FREE,A
	BNE GRB1
	CLR ERPROC	;DISABLE ERRSET IF 0 NODES
	ERROR+NSL	;NO STORAGE LEFT
GRB1:	DEC NNIFSL
	BGE .+4		;NEG NODES LEFT??
	.BUG.
;	CLR UNGRAB
	TST C
	BEQ GRB3
	BIC #170000,A
	BIC #7777,@C
	ADD A,@C
GRB3:	MOV A,C
	JSR PC,.LDP1
	SPUSH A		;CHECK THAT NODE WAS IDLE
	BIC #7777,A
	CMP #IDLE,A
	BEQ .+4
	.BUG.		;GRABBED AN UNIDLE NODE!!!!!
	SPOP A
	BIC #170000,A
	MOV A,FREE
	SPOP A
	JSR PC,.STORE
	RTS PC
	;.STITL UTILITY  -  FREE NODE ROUTINES
.FREE:	SPUSH A	;RETURN NODE IN C TO FREE STORAGE
	SPUSH B
	MOV FREE,A
	BIS #IDLE,A
	CLR B		;MAKE SURE POINTER 2 IS ZERO
	JSR PC,.STORE
	BIC #170000,C
	MOV C,FREE
	INC NNIFSL
	SPOP B
	SPOP A
.FREE1:	RTS PC
FRELST:	BIT #7777,TOPS	;RETURN LIST (TOP-LEVEL ONLY) IN TOPS
			;TO FREE STORAGE
	BEQ .FREE1
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
FRL1:	JSR PC,.LOADC
	JSR PC,.FREE
	BIT #7777,A
	BEQ FRL2
	MOV A,C
	BR FRL1
FRL2:	CLR TOPS
	JMP RETC
