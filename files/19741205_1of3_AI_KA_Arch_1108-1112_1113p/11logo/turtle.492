	FOO==%FNAM2
	VERN==VERN+%FNAM2

	.STITL TURTLE,DISPLAY,RANDOM DEVICES, AND OTHER CRAP

;CONVERT ADDRESS TO DISPLAY PUSHJ
;	ARGUMENT IS AC
.MACR MAKEPJ	F
	ASR	F
	ADD	DRELOC,F
	BIS	#DPUSHJ,F
.ENDM

;CONVERT DISPLAY CONTROLLER ADDRESSES TO REAL WORLD ADDRESSES
;	ARG IS AC
.MACR MAKEAD F
	SUB	DRELOC,F
	ASL	F
.ENDM
	.STITL RANDOM DEVICE CONTROL

.IFNZ AI

ATOD:	JSR PC,G1NARG
	ASH #10.,B
	MOV B,ATODB
	TST ATODB
	BPL .-4
	MOV ATODB,B
	BIC #176000,B
	SUB #1000,B
	JMP R1NARG

BITOUT:	JSR PC,G1NARG
	MOV B,DIGO
BITOU1:	SEZ
	RTS PC

RELAY:	JSR PC,G1NARG
	MOV B,F
	JSR PC,G1NARG
	MOV #1,C
	ASH B,C
	TST F
	BEQ RELAY1
	BIS C,DIGO
	BR BITOU1
RELAY1:	BIC C,DIGO
	BR BITOUT

DEVICE==160106	;THE ADDRESS OF THE BUFFER REGISTER
DEVADD==160104	;THE SELECTOR REGISTER

BOXIN:	JSR PC,G1NARG
	JSR PC,RDBOX	;READ THE BOX
	JMP R1NARG

SWITCH:	JSR PC,G2NARG
	CMP A,#15
	BGT SWTWTA
	TST A
	BLT SWTWTA
	JSR PC,RDBOX	;BOX NUMBER IN B, RETURNS THE BOX IN B
	MOV #1,C	;GET THE BIT
	ASH A,C		;SHIFT THE BIT THE NUMBER OF THE SWITCH
	BIT C,B		;IS THE BIT SET
	BNE .+6		;YES
	JMP RTFALS	;RETURN FALS
	JMP RTTRUE	;RETURN TRUE

RDBOX:	TST B		;IS IT NEGATIVE
	BGE .+4
SWTWTA:	ERROR+WTA	;BAD ARG
	CMP B,#3	;TO LARGE BOX NO.
	BGT SWTWTA
	ASH #10.,B	;THE NUMBER IS SHIFTED 10 PLACES
	MOV B,DEVADD	;TELL IT WHICH BOX TO READ
	CLR DEVICE	;TELL IT TO GO
	TST DEVICE	;DATA IN YET
	BPL .-4		;NOT YET
	MOV DEVICE,B	;GET THE DATA INTO B
	COM B		;THE BITS ARE COMPLEMENTED
	RTS PC
.ENDC


.IF NE HALFLG
;ORBIT HACK--CALL WITH THE NAME OF ARRAY OF DATA
;THE FORMAT FOR THE DATA IS
;NUMBER OF ATTRACTIVE SOURCES
;NUMBER OF INTEGRATION STEPS PER CALL (<50)
;DT
;OBJECT	XPOS
;	YPOS
;	XVEL
;	YVEL
;	XFORCE
;	YFORCE
;	MINIMUM LEGAL RADIUS
;GRAV SOURCE XPOS
;	YPOS
;	DIST FROM OBJECT
;	FIELD CONSTANT
;THIS LAST BLOCK REPEATED FOR EACH SOURCE

;THE ROUTINE UPDATES THE VARIABLES

HALHACK:	SPOPS	A
	JSR	PC,AMAKE5	;B NOW POINTS TO ARRAY HEADER
	MOV	B,C
	CMP	(C)+,(C)+
	CMP	(C)+,#150001	;TYPE=FLOATING   #DIMS=1
	BEQ	.+4
	ERROR+BAT
	CMP	(C)+,(C)+
	MOV	(C)+,A	;ARRAY SIZE
	LDCFD	(C)+,FA
	LDCFD	(C)+,FB
	SETI
	STCFI	FA,D	;#OF ATTRACTORS
	STCFI	FB,B	;#OF INTEGRATION STEPS
	SETL
	TST	B	;POSITIVE?
	BGT	.+4
	ERROR+DOR
	CMP	B,#50.	;NOT TOO BIG (PIGGY)
	BLE	.+4
	ERROR+DOR
	ASL	D
	ASL	D
	ADD	#10.,D	;SIZE ARRAY SHOULD BE
	CMP	A,D
	BGE	.+4
	ERROR+ROB	;ARRAY TOO SMALL
	SUB	#3,D
	ASL	D
	ASL	D
	ADD	C,D	;POINTS TO LAST DATA WORD
	MOV	C,A
	ADD	#32.,A	;POINTS TO XPOS OF FIRST BODY
	PUSH	A
	SPUSH	D
;A NOW POINTS TO XPOS OF FIRST BODY
;B HAS NUMBER OF STEPS PER CALL
;C POINTS TO DT
;D POINTS TO CONSTANT FOR LAST BODY
;NOW COMPUTE THE FORCE ON THE OBJECT

	SETF
HALOP:	MOV	(P),D
	MOV	2(P),A
HALOP1:	LDF	4(C),FB	;POSITION OF OBJECT
	LDF	8.(C),FC
	SUBF	(A)+,FB	;DX
	SUBF	(A)+,FC	;DY
	STF	FC,FD
	MULF	FD,FD	;DY^2
	STF	FB,FA
	MULF	FA,FA	;DX^2
	ADDF	FD,FA
	JSR	PC,HALSQ	;GET SQRT OF FA INTO FD
	STF	FD,(A)+	;RADIAL DISTANCE FROM SOURCE
	CMPF	28.(C),FD	;IS RADIUS LESS THAN 10?
	CFCC
	BGT	HALERR
	MULF	FD,FA
	LDF	(A)+,FD	;FIELD CONSTANT
	DIVF	FA,FD	;K/(R*R^2)
	MULF	FD,FB	;FX=(ABOVE)*DX
	MULF	FD,FC
	ADDF	20.(C),FB
	STF	FB,20.(C)	;INCREMENT FORCE-X
	ADDF	24.(C),FC	;FORCE-Y
	STF	FC,24.(C)
	CMP	A,D
	BLO	HALOP1	;MORE FORCES?

;NOW DO THE INTEGRATION
	MOV	C,E
	LDF	(C),FB	;DT
HALOP2:	LDF	20.(C),FA
	MULF	FB,FA	;FORCE*DT
	ADDF	12.(C),FA	;V_V+A
	STF	FA,12.(C)
	MULF	FB,FA	;V*DT
	ADDF	4(C),FA	;R_R+V*DT
	STF	FA,4(C)
	CMP	C,E
	BHI	HALOP3
	ADD	#4,C	;NOW DO Y COORDINATE
	BR	HALOP2
HALOP3:	MOV	E,C	;RESTORE POINTER TO DT
	CLRF	20.(C)	;CLEAR THE FORCES
	CLRF	24.(C)
	SOB	B,HALOP
	SETD
	CMP	(P)+,(P)+	;FIX THE STACK
	SEZ
	RTS	PC

HALERR:	SETD
	ERROR+RTB
;SQUARE ROOT ROUTINE RETURN ROOT OF FA IN FD

HALSQ:	JSR	PC,PPUSHT
	STF	FB,-(P)	;SAVE FB
	STF	FA,FD
	DIVF	#40400,FD	;START ITER AT A/2
HALSQ1:	STF	FD,FB
	STF	FA,FD
	DIVF	FB,FD	;A/B
	ADDF	FB,FD
	DIVF	#40400,FD	;(B+A/B)/2
	SUBF	FD,FB
	ABSF	FB	;ERROR
	DIVF	FA,FB
	CMPF	#34000,FB	;ERR LESS THAN 2^(-15) ?
	CFCC
	BLT	HALSQ1
	LDF	(P)+,FB
	RTS	PC

.ENDC
	.STITL DISPLAY AND TURTLE

;A  BRIEF DESCRIPTION OF WHAT IS LEFT TO BE DONE TO THIS PROGRAM.


;4)	DECIDING WHAT SNAP AND WIPE REALLY ARE GOING TO DO.
;AT THIS TIME, SNAP OUTPUTS THE ENTIRE SCREEN
;AND WIPE ERASES ONLY TOP LEVEL OCCURRENCES OF THE SNAP



;DISPLAY AND TURTLE COMMANDS
	.IFZ <NDISP!NPLOT>
	DLT==0
	DRT==1
	DFD==2
	DBK==3
	DPD==4
	DPU==5
	.ENDC
.IFNZ DDF
	CURY==4		;USED FOR INDEXING OFF CURX FOR
	CURA==10	;PLOTTER AND DISPLAY
	COSA==14
	SINA==20
	RCURX==24
.ENDC
BACK:	MOV	#"@C,D	;D _ CHAR. TO SEND TO TURTLE
	MOV	#DBK,E	;IN ORDER TO CAUSE 1 STEP OF MOTION
	BR	TURD	;THE TOP BYTE CONTAINS THE CHAR.
LEFT:	MOV	#"BA,D	;IF THE NUMBER OF STEPS IS NEGATIVE
	MOV	#DLT,E
	BR	TURD
RIGHT:	MOV	#"AB,D	;E CONTAINS THE ADDRESS OF THE PARALLEL
	MOV	#DRT,E	;DISPLAY ROUTINE
	BR	TURD
FORWARD:	MOV	#"C@,D
	MOV	#DFD,E
;THE MOVE COMMANDS ARE PROCESSED HERE

TURD:
.IFZ FPPF
	JSR	PC,G1NARG	;B_SINGLE PRECISION NUMBER
.IFF
	JSR PC,G1NUM	;FA_FLOATING NUMBER
	BNE .+4
	ERROR+WTAB
.ENDC
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;DISPLAY, OR REAL TURTLE?
	BEQ	TURD.1
	JMP	(E)		;DISPLAY
	.ENDC
TURD.1:	BIT	#TURTF,DFLAGS
	BNE	TURD.A	;TURTLE
	.IFNZ	NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	TURD.E
	JMP	(E) ;HANDLE PLOTTER COMMAND LIKE DISPLAY
	.ENDC
TURD.E: ERROR+VTD   ;ONLY VALID FOR TURTLE,DSPLY,OR PLTR
TURD.A:
.IFNZ FPPF
	SETI		;IF IT'S A TURTLE CHANGE FLOATING
	STCFI FA,B	;TO AN INTEGER
	SETL
.ENDC
	TST	B
	BGE	TURD.2
	NEG	B	;MAKE NUMBER POSITIVE
	SWAB	D	;AND SWITCH CHARS
;NOW DO THE MOVING
TURD.2:	CMP	E,#DLT	;FOR LEFT OR RIGHT USE FUDGE FACTOR
	BEQ	TURD.0
	CMP	E,#DRT
	BEQ	TURD.0
	BR	TURD.3
TURD.0:	ASL B
	MOV B,A
	MOVB TURF,E	;MULTIPLY BY FIRST BYTE
	MUL E,A
	MOVB TURF+1,E	;DIVIDE BY SECOND
	DIV E,A
TUTE:	BVS TUTER	;OVERFLOW--LOSE.
	MOV A,B
	ASR B
	ADC B		;DIVIDE BY TWO, ROUNDING.
TURD.3:	MOV TURDN,E	;TURTLE DEVICE NUMBER (FOR TYO ROUTINES)
	SUB	#6.,B
	BLT	TURD.5	;NEVER EVEN MAKE IT TO FULL ACCELERATE MODE
	MOV	#10,C
	CLR A		;AGAIN, DIVIDE BY 4 (8)
	DIV #4,A
	MOV	B,F
		;REM.=NUMBER OF STEPS NEEDED BESIDES ACCELERATION
;		AND DECELERATION WHICH CAN'T BE TAKEN IN 8'S
	INC	F	;F_TOTAL NUMBER OF 1 STEPS
	JSR	PC,TUROUT
	ADD	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	MOV A,F	;F _ NUMBER OF 8 STEPS
	INC F
	ADD C,D	;D_CHAR FOR 8 STEPS
	JSR	PC,TUROUT
	SUB	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	SUB	C,D	;D_CHAR FOR 1 STEP
	JSR	PC,TURTYO
	SEZ
TURD.4:	RTS PC

;FOR FEWER THAN 14 STEPS, JUST SEND OUT 1 STEPS
;(IN THE WORS CASE, THIS STUPID ALGORITHM REQUIRES TWICE AS
;MANY CHARS AS THE OPTIMAL ALGORITHM)
TURD.5:	ADD	#6.,B	;RESTORE WHAT WAS SUBTRACTED
	MOV	B,F
	JSR	PC,TUROUT
	BR	TURB.2
TUTER:	ERROR+TGDZ	;TURTLE GETTING DIZZY

;MORE TURTLE COMMANDS

LAMPON:	MOV	#'!,D
	BR	TURB
LAMPOFF:	MOV	#'",D

TURB:	JSR	PC,TURTST
TURB.1:	MOV	TURDN,E
	JSR	PC,TURTYO
TURB.2:	SEZ
	RTS PC


PENDOWN:	MOV	#'0,D
	MOV	#DPD,E
	BR	TURC
PENUP:	MOV	#'8,D
	MOV	#DPU,E

TURC:	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;TURTLE, OR DISPLAY?
	BEQ	TURC.1
	JMP	(E)
	.ENDC
TURC.1:	BIT	#TURTF,DFLAGS
	BNE	TURB.1
	.IFNZ NPLOT
	BIT #PLOTF,DFLAGS	;USING PLOTTER
	BEQ	TURC.2
	JMP (E)
	.ENDC
	
TURC.2: ERROR+VTD  ;ONLY VALID FOR TURTLE,DISPLAY,OR PLOTTER

TURTS1:	MOV	TURDN,E
TURTST:	BIT	#TURTF,DFLAGS
	BEQ	.+4
	RTS	PC
	ERROR+VTU


TOOT:	JSR	PC,G1NARG
	JSR	PC,TURTS1
	MOV	#"( ,D	;TOOT CHAR IN BOTTOM, NULL IN TOP
	MOV B,A
TOOT.1:	DEC	A	;HOW MANY TIMES TO TOOT
	BLT	TURB.2
	JSR	PC,TURTYO	;SHIP OUT TOOT CHAR
	MOV	#3,F	;THEN FOLLOW IT WITH 3 NULLS
	SWAB	D
	JSR	PC,TUROUT
	SWAB	D	;RETURN TOOT CHAR TO BOTTOM
	BR	TOOT.1

;TURTLE OUTPUT
;CALL WITH CHAR IN D, NUMBER OF TIMES IN F
TURO9:	JSR	PC,TURTYO
TUROUT:	MOV USER,B
	TST BRAKE(B)
	BNE TURDOR
	SOB	F,TURO9
TURDOR:	RTS	PC


TURTYO:	SPUSH C
	MOV #TURT,C
	BIS TURDN,C
	JSR PC,TBTYO
	SPOP C
	RTS PC



TOUCH:	PUSH	A
	JSR	PC,TURTS1
	MOV	#'#,D
	MOV USER,F
	MOV UTTY(F),F
	BIT #PTBF,TTYST(F)
	BNE TOUCH2
	JSR	PC,TBTW
TOUCH3:	POP	A
	BIT	A,D
	BEQ	TOUCH1
	JMP	RTFALS
TOUCH1:	JMP	RTTRUE
TOUCH2:	JSR PC,TURTYO	;SEND THE CHARACTER FOR READING SENSORS
	JSR PC,CTYI	;GET A CHARACTER	
	BIC #TIMAGI,TTYST(E)	;PUT IT BACK INTO LINE MODE IN CASE HE WANTS TO BREAK
	BIS #TILIPM,TTYST(E)
	BR TOUCH3	

FTOUCH:	MOV #20,A
	BR	TOUCH
BTOUCH:	MOV	#4,A
	BR	TOUCH
LTOUCH:	MOV	#10,A
	BR	TOUCH
RTOUCH:	MOV	#40,A
	BR	TOUCH
LFTOUC:	MOV #30,A
	BR TOUCH
RFTOUC:	MOV #60,A
	BR TOUCH
LBTOUC:	MOV #14,A
	BR TOUCH
RBTOUC:	MOV #44,A
	BR TOUCH

;LIGHT--RETURN INTENSITY SEEN BY TURTLE EYE
LIGHT:	.IFNZ NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	LIGHT1
	MOV	PLTCHR,B
	BIC	#177774,B	;ONLY 2 SIGNIFICANT BITS
	JMP	R1NARG
	.ENDC
LIGHT1:	JSR	PC,TURTS1	;CHECK TO SEE IF HE HAS A TURTLE
	MOV	#'#,D
	MOV USER,F
	MOV UTTY(F),E
	BIT #PTBF,TTYST(E)
	BNE LIGHT2
	JSR	PC,TBTW
LIGHT3:	MOV	D,B
	BIC	#177700,B	;ONLY 6 SIGNIFICANT BITS
	JMP	R1NARG
LIGHT2:	JSR PC,TURTYO
	JSR PC,CTYI
	BIC #TIMAGI,TTYST(E)
	BIS #TILIPM,TTYST(E)
	BR LIGHT3



;START TURTLE

.IFNZ DDF
ASSTUR:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4

STARTTURTLE:
	CLR A		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTTURTLE:
.ENDC
	JSR	PC,G1NARG	;WHICH TURTLE
	TST	B
	BGE	.+4
STRTT1:	ERROR+ITN	;INVALID TURTLE NUMBER
	DEC	B
	CMP	B,#NTUR-1
	BGT STRTT1
STRTT2:	MOV USER,F
	MOV UTTY(F),E
	BIT #PTBF,TTYST(E)
	BEQ STRTT3
	MOV #TURT,A	;TYPE OF TURTLE
	ADD B,A		;WHICH TURTLE
	JSR PC,TBCHK	;CHECK TO SEE IF HE HAS IT
	BNE .+4
	ERROR+VTU
	MOV B,TURDN	;TURTLE NUMBERR
	MOV STURF,TURF	;USE TURTLE 1'S FUDGE FACTORS
	TST A
	BLT STRTT4
	PUSH B
	JSR PC,KILLT1	;KILL ANOTHER TURTLE
	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
	POP B
	BR STRTT4
STRTT3:	ASL	B	;TURN INTO WORD INDEX
.IFZ DDF
	.IFNZ NDISP
	PUSH	B
	JSR	PC,KILLD1
	POP	B
	.ENDC
	JSR	PC,KILLT1	;KILL TURTLE IF HE ALREADY HAS ONE
	.IFNZ NPLOT
	JSR	PC,KILLPL
	.ENDC
.IFF
	PUSH B
	TST A		;KILL OTHER DEVICS?
	BLT ASTRT1	;NO
.IIF NZ NDISP, JSR PC,KILLD1
.IIF NZ NPLOT, JSR PC,KILLPL
	JSR PC,KILLT1
ASTRT1:	SPOP B
.ENDC
	MOV	TUDN(B),E
	JSR	PC,OPEN1	;TRY TO OPEN IT
	MOV	E,TURDN	;USER VARIABLE
	MOV	STURF(B),TURF	;TURTLE FUDGE FACTOR
STRTT4:	BIC	#<DISPF+PLOTF>,DFLAGS
	BIS	#TURTF,DFLAGS	;SET FLAG FOR CONTROL OF TURTLE
.IIF NZ DDF, BIS #TURTF,DIVOWN	;SET FLAG FOR OWNING TURTLE
	SEZ
	RTS PC

KILLTURTLE:
KILLT1:	MOV USER,E
	MOV UTTY(E),E
.IIF Z DDF,	BIT	#TURTF,DFLAGS
.IIF NZ DDF,	BIT	#TURTF,DIVOWN
	BEQ	KILLT9	;DOESN'T HAVE A TURTLE
	BIT #PTBF,TTYST(E)
	BNE KILLT3
	MOV	TURDN,E
	JSR	PC,CLOSE2
KILLT3:	BIC	#TURTF,DFLAGS
.IIF NZ DDF, BIC #TURTF,DIVOWN
KILLT9:	SEZ
	RTS	PC

NODEV:	.IFNZ NDISP
	JSR	PC,KILLD1
	.ENDC
	JSR	PC,NOMUSIC
	.IFNZ	NPLOT
	JSR	PC,KILLPL
	.ENDC
	JSR	PC,SLAM	;RELEASE ALL DEVICES FOR THIS USER
	MOV #PGRAB,D
	JSR	PC,LCUGRB
	MOV USER,U
	MOV UTTY(U),E
	BIT #PTBF,TTYST(E)
	BNE KILLT3
	RTS	PC

	.IFNZ   NPLOT
;STARTPLOTTER
.IFNZ DDF
ASSTPL:	CLR C		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM C
	BR .+4
STRTPL:	CLR C		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STRTPL:
.ENDC
	MOV	#PLTDVN,E
	JSR	PC,OPEN1
.IFNZ DDF
	TST C		;SHOULD WE KILL OTHER DEVICES?
	BLT STRTP1	;NOPE
.ENDC
	JSR	PC,KILLT1   ;KILL TURTLE IF HE HAS ONE
	BIT	#DISPF,DFLAGS
	BEQ	STRTP1
.IIF NZ NDISP,	JSR	PC,KILLD2   ;KILL DISPLAY IF HE HAS ONE
STRTP1: MOV     #PORBEG,F   ;SETT [0 0 0]
	BIS     #PLOTF,DFLAGS     ;SET PLOTTER FLAG
.IFNZ DDF
	BIC #<DISPF+TURTF>,DFLAGS
	BIS #PLOTF,DIVOWN	;SET FLAG FOR OWNING PLOTTER
.ENDC
ZVAR:	CLR (F)+	;CLEAR USER'S PLOTTER VARIABLES
	CMP #POREND,F
	BNE ZVAR
.IIF NZ DDF,	BIS #PENUF,PLPENP	;SET PENUP FLAG IN PLOTTER 
	BIS     #PENUF,DFLAGS     ;START WITH PEN UP
	JSR	PC,ANGCRP	;INIT SINE AND COSINE
	CLR	B
	CLR	C
	JSR     PC,MTO.02     ;MOVE PLOTTER THERE
ZVAR1:	SEZ
	RTS	PC
;KILLPLOTTER
KILLPL:
	MOV	#PLTDVN,E
	JSR	PC,CLOSE2
.IIF NZ DDF, BIC #PLOTF,DIVOWN
	BIC	#PLOTF,DFLAGS  ;ELIM. PLOTTER FLAG
	BR ZVAR1
	.ENDC
;HERE IS WHERE THE DISPLAY PRIMITIVES START.
.IFNZ NDISP

;STARTDISPLAY
;	INITIALIZE EVERYTHING
;	ALLOCATE DISPLAY BUFFERS
.IFNZ DDF
ASTRDI:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4
STARTDISPLAY:	CLR A	;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTDISPLAY:
.ENDC


;USE THIS PRIMITIVE TO SPECIFY A LARGE DISPLAY
	JSR	PC,G1NARG	;B _ #.  SHOULD BE 0 OR 1


STRTD0:	SPUSH	B	;THE KILLERS CLOBBER B
.IFNZ DDF
	TST A		;KILL OTHER DEVICES?
	BLT ASTRD1	;NO
.ENDC
	JSR	PC,KILLT1	;GET RID OF TURTLE IF NECSSARY
	.IFNZ	NPLOT
	JSR	PC,KILLPL   ;KILL PLOTTER IF HE HAS ONE
	.ENDC
.IFNZ DDF
ASTRD1:	BIT #DISPF,DIVOWN	;DOES HE ALREADY OWN ONE?
	BEQ ASD1	;YES
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLING DISPLAY
ASD1:
.ENDC

	BIT	#DISPF,DFLAGS	;DOES HE HAVE A DISPLAY?
	BEQ	STRTD1	;USER DOESN'T HAVE A DISPLAY YET
	JSR	PC,KILLD2	;KILL HIS PREVIOUS DISPLAY FIRST

STRTD1:	CLR	E	;GET E = USER NUMBER
	MOV	USER,F
	DIV	#L,E	;E _ QUOTIENT
;IS THIS USER A DISPLAY USER?
;I.E. IS THERE AN ACTUAL DISPLAY CONSOLE
;	ASSOCIATED WITH HIM?
	MOVB	DCONS(E),C	;C _ DISPLAY CONSOLE NUMBER
	BGE	.+4
	ERROR+NDU	;ALAS HE ISN'T A DISPLAY USER.

;NOW WE MUST ALLOCATE HIM A DISPLAY BUFFER
;FIRST DETERMINE WHAT SIZE BUFFER HE IS LOOKING FOR.
	SPOP	B
	JSR	PC,SDSIZE	;B _ SIZE (IN BLOCKS)
	JSR	PC,SDFIND	;A _ DISPLAY BUFFER NUMBER. (ERROR IF NO BUFFER)
	MOV	USER,U
	MOV	U,ASDIS(A)
	MOV	A,DISAS(U)	;SET DISPLAY ASSIGN
	JSR	PC,FLUSH	;AND LET RON SET THE MAP FOR THE DISPLAY 
	JSR	PC,RUNME
	JSR	PC,SDREL	;DRELOC _ RELOCATION (VA TO DISPLAY ADDRESSES)

;SET UP HIS DISPLAY PDL POINTER
	MOV	#<<DPDL_-1>&77777>,D
	ADD	DRELOC,D	;DISPLAY ADDRESS OF PDL
	MOV	D,DISPDL(C)

	MOV	#DORBEG,F	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,D	;LAST WORD
SDLOOP:	CLR	(F)+	;ZERO WORD
	CMP	F,D
	BLE	SDLOOP

.IFNZ DDF
	BIC #<PLOTF+TURTF+PENUF>,DFLAGS	;CLEAR VARIOUS FLAGS
	CLR DPENP		;START WITH THE PENDOWN
	BIS #DISPF,DIVOWN	;SET FLAG FOR OWNING DISPLAY
.ENDC
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY


;SET UP TURTLE VARIABLES
	MOV	#TLIST,D
	MOV	D,TUB
	MAKEPJ	D
	MOV	D,PUSHJT

;SET FIRST 2 WORDS OF DLIST
;AND SET THE BUFFER VARIABLES
	MOV	#DLIST,D
	MOV	#<DRSTXY!DPOP>,(D)+
	MOV	PUSHJT,(D)
	MOV	D,STB	;STATIC AREA BOTTOM
	MOV	D,STT	;STATIC AREA TOP

	ASH	#6,B	;B _ LENGTH OF DISPLAY IN BYTES.
			;USE THIS TO CALCULATE WHERE DYNAMIC AREA ENDS
	ADD	#DSLOT,B
	CLR	-(B)	;SET UP DUMMY FREE AREA
	MOV	B,DYT	;DYNAMIC AREA TOP
	CLR	-(B)
	MOV	B,DYB	;DYNAMIC AREA BOTTOM
	MOV	B,DYR	;DYNAMIC AREA ROVING POINTER

;GET DSTAT, A RANDOM GOODIE THAT THE INTERRUPT ROUTINES USE
;TO START UP DISPLAYS
	MOV	C,D
	ASR	D
	SWAB	D
	MOV	D,DSTAT(C)	;CORRECT POSITION TO MUNG NGCSR

;DRAW THE TURTLE
	PUSH	C
	JSR	PC,ANGCRP	;CALCULATE ANGLE CRAP
	JSR	PC,DR.TUR	;DRAW TURTLE
	SPOP	C

;NOW MAKE A PUSHJ TO THE DISPLAY LIST
;AND STUFF IT INTO THE HARDWARE FIRST LOCATION FOR THIS DISPLAY
	MOV	#DLIST,D
	MAKEPJ	D
	MOV	D,DISREL(C)

;AND LAST BUT NOT LEAST
	JSR	PC,NEWSN2	;SET UP FOR SNAPS TO START HERE
	MOV	#DISREL,NGREL	;JUST IN CASE
	SEZ
	RTS	PC
;SDSIZE
;	CALL WITH A NUMBER IN B. (SHOULD BE 0 OR 1 FOR NOW)
;	RETURNS THE SIZE OF DISPLAY (IN BLOCKS)
SDSIZE:	TST	B
	BGE	.+4
	ERROR+IDN
	CMP	B,#1
	BLE	.+4
	ERROR+IDN
	MOVB	DSIZES(B),B	;** IN BLOCKS **
	RTS	PC


;SDREL
;	COMPUTE THE DISPLAY RELOCATION
;	DRELOC = HOW MUCH TO ADD TO A VA/2 IN ORDER
;		TO TURN IT INTO A DISPLAY ADDRESS
SDREL:	MOV	DISAR(A),D	;STARTING BLOCK OF DISPLAY
	SUB	#<DISBTB+<<DISPPG_-6>&1777>>,D	;DISBTB IS DISREL/64
	ASH	#5,D	;SHIFT IT INTO A WORD RELOCATION
	MOV	D,DRELOC	;DRELOC IS A SLOT VARIABLE
	RTS	PC




;SDFIND
;	FIND A DISPLAY OF THE RIGHT SIZE
;	FIRST TRY TO FIND ONE THAT IS EXACTLY THE RIGHT SIZE
;	IF YOU CAN'T THEN FIND ONE THAT IS TOO BIG
;	RETURNS A = DISPLAY BUFFER NUMBER
;	B = SIZE OF THE DISPLAY BUFFER
SDFIND:	MOV	#-1,D
	MOV	NDISPS,A
	DEC	A
	ASL	A

SDFND1:	BLT	SDFND8	;HAVE RUN OUT OF DISLAYS TO TRY
	TST	ASDIS(A)
	BGE	SDFDEC	;IN USE BY SOMEONE ELSE
;THIS ONE IS FREE, BUT CHECK THE SIZE
	CMP	DLENGT(A),B	;B CONTAINS THE DESIRED SIZE
	BLT	SDFDEC	;TOO SMALL
	BGT	.+4
	RTS	PC	;WE WIN. A = DISPLAY NUMBER
	MOV	A,D	;HOLD ONTO THIS A IN CASE WE DON'T FIND
			;ONE EXACTLY THE RIGHT SIZE
SDFDEC:	SUB	#2,A	;DECREMENT A
	BR	SDFND1

;DIDN'T FIND A DISPLAY BUFFER OF EXACTLY THE RIGHT SIZE
;BUT D MAY CONTAIN ONE THAT WAS TOO BIG
SDFND8:	TST	D
	BGE	.+4
	ERROR+NDV	;NO DISPLAY AVAILABLE
	MOV	D,A	;A _ DISPLAY BUFFER NUMBER
	MOVB	DISDR+1(A),B	;B _ ACTUAL SIZE OF THE DISPLAY
	BIC #177400,B
	INC B
	RTS	PC

;KILLDISPLAY
;	USER WANTS TO GIVE UP HIS DISPLAY
KILLDISPLAY:
KILLD1:
.IIF Z DDF,	BIT	#DISPF,DFLAGS
.IIF NZ DDF,	BIT #DISPF,DIVOWN
	BEQ	KILLDR	;USER DOESN'T HAVE DISPLAY
KILLD2:	CLR	A	;GET USER NUMBER
	MOV	USER,B
	MOV	DISAS(B),C	;C _ DISPLAY BUFFER NUMBER
	MOV	#-1,DISAS(B)
	MOV	#-1,ASDIS(C)
	DIV	#L,A
	MOVB	DCONS(A),A
	MOV DSTAT(A),B
	MOV B,NGCSR
	MOV	#-1,DSTAT(A)
	MOV	#DSTOP,DISREL(A)
	BIS #TKSTOP,B
	MOV B,NGCSR
;	JSR	PC,SNZAP	;SET ALL SNAPS TO EMPTY-WORD
	CLR	SNLIST	;CLEAR  SNAPS
.IIF NZ DDF, BIC #DISPF,DIVOWN	;CLEAR DISPLAY FLAG
	BIC	#DISPF,DFLAGS
	JSR	PC,.GCOLL

KILLDR:	RTS	PC
.IFTF
DCHKPL: .IFNZ    NPLOT
	BIT     #PLOTF,DFLAGS      ;USING PLOTTER?
	BEQ	DCHK
	RTS	PC
	.ENDC
DCHK:
.IFF
	ERROR+VTU
.IFT
	BIT	#DISPF,DFLAGS
	BNE	DCHK1
	PUSH	B
	CLR	B	;SPECIFY A SMALL DISPLAY BUFFER
.IFNZ DDF
	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
.ENDC
	JSR	PC,STRTD0	;STARTDISPLAY
	SPOP	B
	RTS	PC
DCHK1:	CMP	NADXY,#20
	BLT	KILLDR	;DON'T BOTHER TRYING TO COMPRESS ADDXY'S
	JSR	PC,DSGC8	;TRY TO COLLAPSE
	BR	KILLDR

.ENDC
TBOX:	JSR PC,NODEV
	MOV #NPTBOX,A
	MOV #PTBOX0,B
TBOX2:	MOV (B),C
	TST C
	BLT TBOX1
	CMP USER,(B)
	BEQ TBOX1
	ADD #5*2,B	;BLOCK IS 5 WORDS LONG
	SOB A,TBOX2
	ERROR+NTB
TBOX1:	MOV USER,(B)+
	CLR E
	CLR A
	INC A
TBOX3:	CMP A,#5
	BEQ TBOX4
	SPUSH A
	SPUSH E
	PRTXT ^\PORT \
	JSR PC,PRDN
	PRTXT ^\: ?\
	JSR PC,QUEST
	SPOP E
	SPOP A
	CMP D,#'P	;IS IT A PLOTTER
	BEQ TPLOT
	CMP D,#'N	;IS IT NULL
	BEQ TNUL
	CMP D,#'C	;IS IT HIS CONSOLE
	BEQ TCON
	CMP D,#'T	;IS IT A TURTLE
	BEQ TTUR
	CMP D,#'M	;IS IT A MUSIC BOX
	BEQ TMUS
	CMP D,#7
	BEQ TBOX6
TMUS:	MOV #PMBOX,(B)+
	INC A
	BR TBOX3
TNUL:	CLR (B)+
	INC A
	BR TBOX3
TCON:	MOV #CONSO,(B)+
	INC A
	BR TBOX3
TTUR:	CMP E,#NTUR
	BLT .+4
	ERROR+ITN
	MOV E,(B)
	BIS #TURT,(B)+
	INC E
	INC A
	BR TBOX3
TPLOT:	MOV #PLOTT,(B)+
	INC A
	BR TBOX3
TBOX4:	MOV USER,U
	MOV UTTY(U),E
	JSR PC,TYIRT
	BIS #PTBF!TIRST!TILIPM,TTYST(E)
	MOV TTYST(E),OTTYST(E)
	MOV #CONSO,C
	JSR PC,TBINIT
	BEQ TBOX5
	SEZ
	RTS PC
TBOX5:	JSR PC,NOTBOX
	ERROR+TDE
TBOX6:	JSR PC,NOTBOX
	ERROR+BRK


NOTBOX:	MOV #NPTBOX,A
	MOV #PTBOX0,B
NTBOX1:	CMP USER,(B)
	BEQ NTBOX2
	ADD #5*2,B
	SOB A,NTBOX1
	SEZ
	RTS PC
NTBOX2:	SPUSH B
	JSR PC,NODEV
	SPOP B
	MOV USER,U
	MOV UTTY(U),E
	BIC #PTBF,TTYST(E)
	MOV #-1,(B)
	SEZ
	RTS PC

.IFNZ DDF

.IFNZ NDISP

CTRDIS:	BIT #DISPF,DIVOWN	;DOES HE OWN A DISPLAY?
	BEQ CTRERR		;NO
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+PLOTF>,DFLAGS
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY
	BIS DPENP,DFLAGS	;SET DISPLAY PEN POSITION
	SEZ
	RTS PC
.ENDC

CTRTUR:	BIT #TURTF,DIVOWN	;DOES HE OWN A TURTLE?
	BNE .+4			;NO,ERROR
CTRERR:	ERROR+VTD
	BIC #<PLOTF+DISPF>,DFLAGS
	BIS #TURTF,DFLAGS	;SET FLAG FOR CONTROLLING TURTLE
	JSR PC,G1NARG		;WHICH TURTLE DOES HE WANT TO CONTROL?
	TST B			;TEST TURTLE NO.
	BGE .+4			;IT'S OKAY SO FAR
CTRER2:	ERROR+ITN		;INVALID TURTLE NUMBER
	DEC B			;TO START TO TURN INTO AN INDEX
	CMP B,#NTUR-1
	BGT CTRER2		;IT WAS TO LARGE
	ASL B			;TURN IT INTO A WORD INDEX
	CMP TURUSE(B),USER	;DOES HE OWN IT?
	BNE CTRERR		;NOPE
	MOV TUDN(B),TURDN	;FOR THE OUTPUT ROUTINES
	MOV STURF(B),TURF
CTRRET:	SEZ
	RTS PC

.IFNZ NPLOT

CTRPLT:	BIT #PLOTF,DIVOWN	;DOES HE OWN THE PLOTTER?
	BEQ CTRERR		;NOPE
	BIT #PLOTF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+DISPF>,DFLAGS
	BIS PLPENP,DFLAGS	;SET PLOTTER PEN POSITION
	BIS #PLOTF,DFLAGS	;SET FLAG FOR CONTROLLING PLOTTER
	SEZ
	RTS PC

.ENDC
.ENDC

.IFNZ <NDISP!NPLOT>


.IFZ FPPF

DBK:	NEG	B
;DISPLAY FORWARD AND BACK
DFD:	MOV	B,C
	CLR	B
	TST	C
	BGE	DFD1	;IF ARG IS NEG,
	COM	B	;SET B = -1
	CLR	A	;CLEAR FLAG
DFD1:	MOV	#CURX,D
	JSR	PC,MULSIN	;PUTS DX IN E,,F
	SDPADD	(D)+,(D)+,E,F	;NEW X
	PUSH	F	;FRACTION PART
	SPUSH	E	;INTEGER PART
	JSR	PC,MULCOS	;DY IS IN E,,F
	SDPADD	(D),(D)+,E,F	;NEW Y
	SPUSH	F
	SPUSH	E
	BR	SETMOV

.IFF

DBK:	NEGF FA
DFD:	
.IFZ DDF
	LDCFD COSA,FB
	MULF FA,FB
	LDCFD CURY,FC
.IFF
	JSR PC,GTCURX		;IS HE CONTROLLING PLOTTER OR DISPLAY?
	LDCFD COSA(F),FB	;COSINE OF ANGLE -> FB
	MULF FA,FB		;DY -> FB
	LDCFD CURY(F),FC	;CURY -> FC
.IFTF
	ADDF FC,FB	;GET NEW Y IN FB
	STCDF FB,-(P)	;PUT NEW Y ON STACK
.IFT
	LDCFD SINA,FB
	MULF FA,FB	;DX IN FB
	LDCFD CURX,FC	;CURRENT X IN FC
.IFF
	LDCFD SINA(F),FB	;SINE OF ANGLE -> FB
	MULF FA,FB		;DX -> FB
	LDCFD (F),FC		;CURX -> FC
.ENDC
	ADDF FC,FB	;GET NEW X IN FB
	STCDF FB,-(P)	;PUT NEW X ON STACK
	BR SETMOV

.ENDC
.IFNZ DDF
	;PUTS THE ADDRESS OF THE CURX OF DISPLAY IN F
	;IF HE OWN A DISPLAY, ELSE PUTS CURX OF PLOTTER IN F
.IFNZ NDISP
GTCURX:	BIT #DISPF,DFLAGS	;DOES HE OWN A DISPLAY?
	BNE DISP		;YES
	MOV #PCURX,F		;PUT ADDRESS OF PCURX IN F
	BR DISP1
DISP:	MOV #DCURX,F		;PUT ADDRESS OF DCURX IN F
DISP1:	RTS PC
.IFF
GTCURX:	MOV #PCURX,F
	RTS PC
.ENDC
.ENDC


.IFZ FPPF


SETX:	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;;NEW X IN B
	CLR	-(SP)	;FRACTION PART OF NEW X
	PUSH	B	;INTEGER PART
	SPUSH	CURY	;NEW Y UNCHANGED
	SPUSH	CURY+2
	BR	SETMOV

SETY:	JSR	PC,DCHKPL
	JSR	PC,G1NARG
	PUSH	CURX	;NEW X UNCHANGED
	SPUSH	CURX+2
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	B	;INTEGER PART OF NEW Y
	BR	SETMOV

SETXY:	JSR	PC,DCHKPL
	JSR	PC,G2NARG
	CLR	-(SP)	;FRATION PART OF NEW X
	PUSH	B	;INTEGER PART
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	A	;INTEGER PART
SETMOV:	JSR	PC,MOVETO
	RTS PC

SETTURTLE:
	JSR	PC,DCHKPL
	MOV	@S,C
	JSR	PC,LD3NUM	;LOAD D,E,F
SETT1:	PUSH	F	;SAVE NEW ANGLE
	JSR	PC,SPOPT	;POP OFF ARG
	CLR	-(SP)	;FRACTION PART OF NEW X
	SPUSH	D	;INTEGER
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	E
	CLR	A	;A FLAG
	JSR	PC,MOVETO	;MOVE TO NEWX,NEWY
	SPOP	B	;NEW HEADING
	JMP	DRT.HD	;SET HEADING



.IFF
SETX:	JSR PC,DCHKPL
.IFZ DDF
	SPUSH CURY+2
	SPUSH CURY
.IFF
	JSR PC,GTCURX
	SPUSH CURY+2(F)	;PUT CURY ON STACK
	SPUSH CURY(F)
.IFTF
	JSR PC,GARG	;PUT NEWX ON STACK
	BR SETMOV
SETY:	JSR PC,DCHKPL
	JSR PC,GARG	;PUT NEW Y ON STACK
.IFT
	SPUSH CURX+2
	SPUSH CURX
.IFF
	JSR PC,GTCURX
	SPUSH 2(F)	;PUT CURX ON STACK
	SPUSH (F)
.ENDC
	BR SETMOV
SETXY:	JSR PC,DCHKPL
	JSR PC,GARG	;PUT Y ON
	JSR PC,GARG	;PUT X ON
SETMOV:	JSR PC,MOVETO
	RTS PC

SETTURTLE:
	MOV @S,C
	JSR PC,.GFLST	;FA <- NEWX
	LDD A,B		;FB <- NEWX
	JSR PC,.GFLST	;FA <- NEWY
	BIT #7777,C	;ANY MORE LIST?
	BEQ SETT1	;NO?!
	JSR PC,.LOADC	;GET POINTER TO ANGLE
	BIT #7777,A	;ANY MORE LIST? (SHOULDN'T BE)
	BNE SETT1	;THERE IS??
	MOV #SNUM,A	;TAKE POINTER AND TRY TO
	JSR PC,CONVER	;CONVERT IT TO A SNUM
	BNE .+4
SETT1:	ERROR+WTA
	SPUSH B		;STORE ANGLE
	STCDF FA,-(P)	;STORE NEWY
	STCDF FB,-(P)	;STORE NEWX
SETT2:	JSR PC,DCHKPL
	CLR A		;SET A FLAG
	JSR PC,MOVETO	;MOVE IT
	SPOP B		;POP ANGLE
	JMP DRT.HD

.GFLST:	BIT #7777,C	;GETS FLOATING NUMBER OUT OF LIST
	BEQ SETT1	;EMPTY LIST
	JSR PC,.LOADC	;GET NODE IN A AND B
	MOV A,C		;GET POINTER TO REST OF LIST IN C
	JSR PC,G1NUMS	;GET FNUM POINTED TO BY B INTO FA
	BEQ SETT1
	RTS PC

GARG:	SPOP FNPDL+4	;SO THAT THE JMP WILL WORK BELOW
	SPUSH A		;STORES REGISTERS AND GETS NUMBER IN FA
	SPUSH B
	SPUSH F
	JSR PC,G1NUM	;FA <- FNUM POINTER TO BY B
	BEQ SETT1
	SPOP F		;RESTORE REGISTERS
	SPOP B
	SPOP A
	STCDF FA,-(P)	;PUT FA ON STACK
	JMP @FNPDL+4	;DOES A RTS PC





.ENDC



;CALL WITH NEWX AND NEWY ON THE STACK




MOVETO:	JSR PC,PPOPT	;INSURE ENOPUGH STACK IS IN CORE
	.IFNZ	NPLOT
.IFNZ NDISP
	BIT	#PLOTF,DFLAGS ;USING PLOTTER?
	BEQ	MTO.09   ;IF NOT,SKIP ALL THIS
.ENDC


.IFZ FPPF

	MOV	2(P),C	;INT OF Y
	MOV	4(P),A	;FRACTION Y
	MOV	6(P),B	;INT OF X
	MOV	10(P),D	;FRACTION X
	ASL	A
	ADC	C	;ROUND Y
	ASL	D
	ADC	B	;ROUND X
	CMP	B,#128.   ;CHECK IF EXCEEDS PLOTTER BOUNDS
	BGE	MTO.03
	CMP	B,#-128.
	BLT	MTO.03
	CMP     C,#128.    ;NOW CHECK Y BOUNDS
	BGE	MTO.03
	CMP	C,#-128.
	BLT	MTO.03
	JSR	PC,MTO.02
	JMP	MTO.R
;SEND OUT PLOTTER CHARACTERS

.IFF

	LDCFD 2(P),FA	;LOAD NEWX
	LDCFD 6(P),FB	;LOAD NEWY
	STF FA,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	STF FB,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	SETI
	STCFI FA,B	;PUT NEWX INTO B
	STCFI FB,C	;PUT NEWY INTO C
	SETL
	ASR B		;ROUND NEWX
	ADC B
	ASR C		;ROUND NEWY
	ADC C
	JSR PC,MTO.02	;MOVE IT
	JMP MTO.R	;STORE AWAY NEWX AND NEWY
.IFZ DDF

CHKPL:	CMPF #42000,FC
	CFCC
	BLT MTO.03
	CMPF #142000,FC
	CFCC
	BGT MTO.03
	RTS PC
.ENDC

.ENDC

MTO.02: MOV	#35,D   ;PRIMING CHARACTER
	MOV	#PLTDVN,E
	SPUSH C
	MOV #PLOTT,C
	JSR	PC,TBTYO   ;SEND TO TTY
	JSR	PC,MTO.04	;SEND NEW X TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTYO
	SPOP B
	JSR	PC,MTO.04   ;SEND NEW Y TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTW
	MOV	D,PLTCHR	;PLOTTER WILL SEND BACK SENSING CHAR
	RTS	PC
MTO.03: ERROR+OOB
MTO.04:	MOV	B,D   ;SEND LOW ORDER 6 BITS
	BIC	#177700,D
	JSR	PC,PLT67
	JSR	PC,TBTYO
	MOV	B,D	;SEND REMAINING 2 BITS
	ASL	D
	ASL	D
	SWAB	D
	BIC	#177774,D
	BIT	#PENUF,DFLAGS   ;SEND PENUP INFO
	BEQ	MTO.05
	BIS	#40,D   ;SET PENUP BIT
MTO.05:	RTS	PC

PLT67:	BIT	#40,D	;SET BIT 6 TO COMP OF BIT 7
	BNE	PLT671
	BIS	#100,D
PLT671:	RTS	PC


.ENDC
.IFNZ NDISP

.IFZ FPPF

MTO.09:	MOV SP,F
	TST	(F)+	;POINT TO ARGS
	MOV	(F)+,B	;INTEGER PART OF NEW Y
	MOV	(F)+,C	;FRACTION PART OF NEW Y
	JSR	PC,CHKBND	;CHECK TO SEE IF IN BOUNDS
	MOV	B,E	;ROUNDED NEWY
	MOV	(F)+,B	;INTEGER PART OF NEW X
	MOV	(F),C	;FRACTION PART OF NEW X
	JSR	PC,CHKBND
	MOV	B,D	;ROUNDED NEWX
;GET D_DX AND E_DY
	MOV	#CURX,F
	ASL	(F)+	;FRACTION OF CURX
	ADC	(F)	;ROUND CURX
	SUB	(F)+,D	;DX
	ASL	(F)+
	ADC	(F)
	SUB	(F),E	;DY

.IFF

MTO.09:	MOV P,F		;SO IT CAN DO POPS W/O DISTURBING THE STACK
	TST (F)+	;TO GET AROUND THE PC
	LDCFD (F)+,FA	;GET NEW X
	STF FA,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
	LDCFD (F)+,FB	;GET NEW Y
	STF FB,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
.IIF Z DDF,	MOV #RCURX,F
.IFNZ DDF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	ADD #RCURX,F	;TO TELL WHERE TO PUT ROUNDED FA AND FB
.ENDC 
	JSR PC,ROUND	;ROUND FA AND FB
	SETF
	SUBF (F)+,FA	;FA <- NEWX - CURX
	SUBF (F)+,FB	;FB <- NEWY - CURY
	SETD
	JSR PC,MOD1K	;PERFORM A MODULAR 32K. (ANY BETTER IDEAS?)
	SETI
	STCFI FA,D	;PUT DX IN D
	STCFI FB,E	;PUT DY IN E
	SETL

.ENDC

	BNE	MTO.1	;CHECK FOR DX=DY=0
	TST	D
	BEQ	MTO.R	;JUST RETURN

MTO.1:	BIT	#PENUF,DFLAGS	;IS PEN UP?
	BNE	MTO.PU	;YES

;THE PEN IS DOWN
	SPUSH	DIREC
	JSR	PC,XYDIR	;CALCULATE DIREC
	JSR	PC,DR.LIN	;AND DRAW LINE!!
	SPOP	DIREC

;RETURN.  SET CURX & CURY TO NEWX & NEWY


.ENDC

.IFZ FPPF

MTO.R:	POP	A	;RETURN ADDRESS
	MOV	#CURY+2,B
	SPOP	(B)	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP	-(B)
	SPOP	-(B)
	SPOP	-(B)
	JMP	(A)

.IFF

MTO.R:	POP A
.IFZ DDF
	MOV #CURX,B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE SET OF VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
.ENDC
	SPOP (B)+	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP (B)+
	SPOP (B)+
	SPOP (B)+
	JSR PC,ROUNDER	;ROUND AND PUT IN RCURX AND RCURY
	SEZ
	JMP (A)		;DOES AN RTS!!?

ROUNDER:	;PUTS ROUNDED CURX AND CURY INTO RCURX AND RCURY
.IFZ DDF
	MOV #CURX,B
	MOV #RCURX,F
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
	ADD #RCURX,F	;MAKE F POINT TO RCURX
.ENDC
	LDCFD (B)+,FA	;FA <-CURX
	LDCFD (B)+,FB	;FB <- CURY
	JSR PC,ROUND	;ROUND FA AND FB
	STCDF FA,(F)+	;RCURX <- ROUNDED CURX
	STCDF FB,(F)+	;RCURY <- ROUNDED CURY
	RTS PC

	;ROUNDS FA AND FB
ROUND:	ADDF #40000,FA	;FA <- FA + 1/2
	STCFI FA,-(P)	;INTEGERIZE FA
	BCS EROOB	;TOO BIG
	LDCIF (P)+,FA	;FA <- INTEGER (FA)
	CFCC		;IS FA > 0?
	BGE .+6		;YES
	SUBF #40200,FA	;FA <- FA - 1 (TO ROUND AWAY FROM 0)
	ADDF #40000,FB	;REPEAT SAME PROCESS FOR FB
	STCFI FB,-(P)
	BCS EROOB
	LDCIF (P)+,FB
	CFCC
	BGE .+6
	SUBF #40200,FB
	RTS PC
EROOB:	CMP (P)+,(P)+	;GET RID OF TRASH ON STACK
	ERROR+OOB

MOD1K:	LDD FB,FC
	MODF #34600,FC	;DIVIDES BY 2^16 (FC <- ONLY FRACTIONAL PART)
	CFCC
	BEQ MODK1	;IT WAS ZERO OR UNDERFLOWED
	MULF #43600,FC	;FRACTION * 2^16
	LDD FC,FB	;PUT IT BACK NOW
MODK1:	LDD FA,FC	;NOW DO IT TO FA
	MODF #34600,FC
	CFCC
	BEQ MODK2
	MULF #43600,FC
	LDD FC,FA
MODK2:	RTS PC

.ENDC

.ENDC
.IFNZ NDISP


;THE PEN IS UP
;PUT ADDX AND ADDY COMMANDS INTO DISPLAY LIST
MTO.PU:	SPUSH	#MTO.R	;SO RTS PC'S BELOW WILL WORK (GROAN !!!)
	MOV	STT,A	;POINTER TO TOP OF STATIC DISPLAY ALLOCATION
	CMP	-(A),#ADDY
	BLO	MTO.AD	;PREVIOUS STUFF NOT ADDS ANYWAY
	CMP	-(A),#ADDY	;IS THE NEXT TO LAST DCODE AN ADD,TOO ?
	BLO	MTO.AD	;NO
	CMP	A,SNABOT	;DON'T COMPRESS ACROSS SNAP BOTTOM
	BLO	MTO.AD	;NO
;THERE ARE TWO ADD COMMANDS IN A ROW
	JSR	PC,MTO.AS	;TAKE CARE OF FIRST ADD
	JSR	PC,MTO.AS	;AND SECOND ADD
	BR	MTO.R1


;MTO.AS ADDS THE DELTA X OF AN ADD COMMAND TO THE NEW DX OR DY
MTO.AS:	CMP	(A),#ADDX	;ADDX IS THE BIGGER OF THE ADDS
	BHIS	.+6
	ADD	(A)+,E	;DY
	RTS	PC
	ADD	(A)+,D
	RTS	PC



;HAVE TO EXPAND STATIC AREA AND PUT IN ADD COMMANDS
MTO.AD:	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

MTO.RM:	MOV	A,STT	;A WAS SET IN STXPND
	MOV	PUSHJT,(A)	;DISPLAY JUMP TO TURTLE
MTO.R1:	BIC	#176000,D	;IN CASE EITHER DX OR DY WERE NEGATIVE
	BIC	#176000,E	;CLEAR THE TOP 6 BITS
	BIS	#ADDY,E	;TURN E INTO ADDY COMMAND
	MOV	E,-(A)	;STORE IN DLIST
	BIS	#ADDX,D	;TURN D INTO ADDX COMMAND
	MOV	D,-(A)	;STORE IN DLIST
	CLR DFBCNT
	RTS	PC

.ENDC
.IFNZ <NDISP!NPLOT>

.IFZ FPPF

DLT:	NEG	B

;DISPLAY RIGHT AND LEFT

DRT:	ADD	CURA,B

.IFF

DLT:	NEGF FA
DRT:	SETI
	STCFI FA,B
	CFCC		;GET ANGLE BACK TO SNUM
	SETL
	BCC .+4		;NUMBER TOO LARGE??, NOPE
	ERROR+TGDZ	;TURTLE GETTING DIZZY
.IFZ DDF
	ADD CURA,B
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE VARIABLES
	ADD CURA(F),B	;B <- NEWA + CURA
.ENDC

.ENDC
DRT.HD:	JSR	PC,MOD360	;SET B=B MOD 360
.IIF Z DDF,	MOV	B,CURA
.IFNZ DDF
	JSR PC,GTCURX
	MOV B,CURA(F)	;MOVE NEWLY COMPUTED ANGLE TO CURA
.ENDC

;DRAW THE TURTLE IF IT'S BEING SHOWN
TURDO:	JSR	PC,ANGCRP	;DO ALL THE ANGLE CRAP.
	.IFNZ	   NPLOT
	BIT     #PLOTF,DFLAGS   ;USING PLOTTER?
	BNE	DRTRET	;YES, SO RETURN
	.ENDC
.IFZ NDISP
	ERROR+VTU
.IFF
	BIT	#HIDETF,DFLAGS	;IS THE TURTLE BEING HIDDEN ?
	BNE	DRTRET	;YES. SO RETURN
;THE TURTLE IS BEING SHOWN. SO DRAW THE TURTLE
	JSR	PC,DR.TUR
.ENDC

DRTRET:	SEZ
	RTS	PC


;SETHEAD
;	LIKE RIGHT, EXCEPT SET CURA TO ARGUMENT
SETHEAD:	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;NUMERIC ARGUMENT IN B
	BR	DRT.HD	;JUMP INTO RIGHT

;WRAPAROUND
.IFNZ NDISP

WRAP:	BIS	#WRAPF,DFLAGS
	BR DRTRET

NOWRAP:	BIC	#WRAPF,DFLAGS
	BR DRTRET

.ENDC

.IFZ FPPF



;HERE
;	OUTPUT A SENTENCE OF CURX,CURY,CURA
HERE:	JSR	PC,DCHKPL
	MOV	#CURX,D
	JSR	PC,PSHINT	;PUSH INTEGER OF CURX ONTO S-PDL
	JSR	PC,PSHINT	;PUSH INTEGER OF CURY
	MOV	(D),B	;CURRENT ANGLE
HERE.1:	JSR	PC,PSHNUM	;PUSH CURRENT ANGLE
HERE.2:	MOV	#3,D	;PUSH 3 ONTO P-PDL
	JMP	SENT.


;XCOR
;	OUTPUT THE X COORDINATE
XCOR:	JSR	PC,DCHKPL
	MOV	#CURX,D
	BR	YCOR1
;YCOR
;	OUTPUT THE Y COORDINATE
YCOR:	JSR	PC,DCHKPL
	MOV	#CURY,D
YCOR1:	JMP	R1INT	;RETURN INTEGER


;HEADING
;	RETURN THE CURRENT ANGLE
HEADING:	JSR	PC,DCHKPL
	MOV	CURA,B
	JMP	R1NARG
	;HOME -- SAME AS SETT [0 0 0]
HOME:	JSR PC,DCHKPL
	JSR PC,SPUSHT
	CLR D
	CLR E
	CLR F
	JMP SETT1

.IFF

HERE:	JSR PC,DCHKPL	;DOES HE OWN DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURX,D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
.ENDC
	JSR PC,WHOPIE	;PUT (F) INTO A NODE, POINTER IN B
	PUSHS B		;STORE POINTER TO FNUMS ON STACK
	JSR PC,WHOPIE	;DO IT AGAIN
	PUSHS B
.IIF Z DDF,	MOV (D),B	;STORE ANGLE (SNUM) ON STACK
.IIF NZ DDF,	MOV (F),B	;PUT ANGLE (SNUM) IN B
	JSR PC,PSHNUM	;PUT SNUM IN B ON S-PDL
	MOV #3,D	;PUSH A FLAG ON	
	JMP SENT.	;CHANGE THE THREE THINGS INTO A SENTENCE

XCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IIF Z DDF,	MOV #CURX,D	;PUT POINTER TO CURRENT X IN D
.IIF NZ DDF,	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	BR YCOR1	;GET NUMBER AND RETURN

YCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURY,D	;PUT POINTER TO CURRENT Y IN D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURY,F	;MAKE F POINT TO CURY
.ENDC
YCOR1:	JSR PC,WHOPIE	;PUT NUMBER INTO A NODE,POINTER RETURNED IN B
	JMP ORTB	;PUT POINTER IN B ON S-PDL

HEADING:JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV CURA,B	;PUT POINTER TO ANGLE IN B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURA,F	;MAKE F POINT TO CURA
	MOV (F),B	;MOVE CURA TO B
.ENDC
	JMP R1NARG	;RETURN B

HOME:	CLR -(P)	;SETTURTLE [0 0 0]
	CLR -(P)
	CLR -(P)
	CLR -(P)
	CLR -(P)
	JMP SETT2	;SET THE TURTLE!

	;TAKES FNUM POINTED TO BY F, AND PUTS IT IN A NODE
	;RETURNS POINTER TO IT IN B
WHOPIE:	SPUSH C
.IFZ DDF
	MOV (D)+,A
	MOV (D)+,B
.IFF
	MOV (F)+,A	;PUT FNUM IN A AND B
	MOV (F)+,B
.ENDC
	JSR PC,GRBAD	;PUT FNUM IN NODE SPACE
	BIS #FNUM,C	;SET APPROPRIATE TYPE
	MOV C,B		;PUT POINTER IN B
	SPOP C
	RTS PC

.ENDC

;PENP
;RETURNS TRUE IF THE PEN IS DOWN
;RETURNS FALSE IF IT IS UP
PENP:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
	BIT #PENUF,DFLAGS	;IS THE PEN UP?
	BNE PENP1	;YES
	JMP RTTRUE	;NO, RETURN TRUE
PENP1:	JMP RTFALS	;YES, RETURN FALSE
.IFNZ NDISP


;	HIDETURTLE
HIDETURTLE:
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY??
	BIS	#HIDETF,DFLAGS	;SET THE HIDETURTLE FLAG
	MOV	#DPOP!DSTOP,@TUB
	BR SHOWT9


;	SHOWTURTLE
SHOWTURTLE:
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
	BIT	#HIDETF,DFLAGS	;IS TURTLE HIDDEN NOW ?
	BEQ	SHOWT9	;NO, IT'S ALREADY BEING SHOWN
;HAVE TO DRAW THE TURTLE
	BIC	#HIDETF,DFLAGS	;CLEAR THE FLAG FIRST
	JSR	PC,DR.TUR
SHOWT9:	SEZ
	RTS PC

.ENDC


;	DISPLAY PENUP
DPU:	BIS	#PENUF,DFLAGS	;SET PEN UP FLAG
.IFNZ DDF
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING A DISPLAY?
	BEQ DPU1	;NO
	BIS #PENUF,DPENP	;SET PEN UP FLAG IN DISPLAY VARIABLES
	BR DPR			;RETURN
DPU1:	BIS #PENUF,PLPENP	;SET PEN UP FLAG IN PLOTTER VARIABLES
.ENDC
DPU2:	SEZ
	RTS PC


	;SAME AS ABOVE BUT CLEARING PEN UP FLAG
;	DISPLAY PENDOWN
DPD:	BIC	#PENUF,DFLAGS	
.IFNZ DDF
	BIT #DISPF,DFLAGS
	BEQ DPD1
	BIC #PENUF,DPENP
	BR DPR
DPD1:	BIC #PENUF,PLPENP
DPR:
.ENDC
	BR DPU2
.ENDC

.IFNZ NDISP
;CLEARSCREEN--WIPE SCREEN AND RESTORE TURTLE TO [0 0 0]
CLEARSCREEN:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
	JSR	PC,WC.1	;WIPE IT CLEAN
	SPUSH DFLAGS
	MOV	#DORBEG,C	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,B	;INCLUDING CURX, CURY AND OTHERS
CSLOOP:	CLR	(C)+
	CMP	C,B
	BLT	CSLOOP

	SPOP DFLAGS
	CLR DFBCNT
	JSR	PC,TURDO	;DO ANGLE CRAP AND DRAW TURTLE IF SHOWN
	MOV	STB,STT
	MOV	PUSHJT,@STB
	JSR	PC,NEWSN2	;RECALCULATE STARTING POINT FOR SNAPS
	SEZ
	RTS PC

.IFZ FPPF

;SNAP

SNAP:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

;FIRST SET UP THE 3 NODE SNAP STRUCTURE ITSELF
	JSR	PC,PSHNUM	;FIRST NUMBER IS DUMMY FOR NOW
.IIF NZ DDF,	MOV	#DCURX,D
.IIF Z DDF,	MOV	#CURX,D
	JSR	PC,GETINT	;INTEGER OF CURX IN B
	SUB	OLDX,B	;TO GET DELTA X
	JSR	PC,PSHNUM	;PUSH ON S-PDL
	JSR	PC,GETINT	;INTEGER OF CURY
	SUB	OLDY,B	;TO GET DELTA-Y
	JSR	PC,PSHNUM
	MOV	#3,D	;NUMBER OF ARGS TO SENTENCE
	JSR	PC,SENT.

.IFF
	;CALCULATES DX AND DY, AND PUTS POINTERS TO THEM ON S-PDL
OLD:	JSR PC,(PC)	;DO THIS TWICE
	SETF
	LDF (D)+,FA	;SECOND TIME IT POINTS TO CURY
	SUBF (F)+,FA	;SECOND TIME POINTS TO OLDY
	STF FA,-(P)	;PUT DX OR DY ON STACK
	SPOP A		;PUT FNUM IN A,,B
	SPOP B
	SETD
	JSR PC,GRBAD	;PUT A,,B IN NODE
	BIS #FNUM,C	;SET TYPE
	SPUSHS C	;PUT POINTER ON S-PDL
	RTS PC


SNAP:	JSR PC,DCHK	;DOES HE OWN ADISPLAY?
	JSR PC,PSHNUM	;PUSH SNAP POINTER
.IIF NZ DDF,	MOV	#DCURX,D	;D POINTS TO CURX
.IIF Z DDF,	MOV	#CURX,D		;DITTO
	MOV #OLDX,F	;E POINTS TO WHERE SNAP IS TAKEN FROM
	JSR PC,OLD	;CALCULATE DX AND DY OF SNAP
	MOV #3,D	;SET FLAG FOR SENTENCE
	JSR PC,SENT.	;MAKE THE THREE THINGS INTO A SENTENCE


.ENDC


;NOW GRAB A NODE FOR THE SNLIST HACKING
	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BNE	SNAP.2
	MOV	#SNUM,A	;FIRST SNAP
	CLR	B	;CREATE SNAP LIST. FIRST NODE IS A DUMMY
	JSR	PC,GRBAD
	BIS	#LIST,C
	MOV	C,SNLIST
SNAP.2:	JSR	PC,.LDP1	;POINTER TO REST OF SNAP LIST
	JSR	PC,GRBAD	;STORE A NODE
	BIS	#LIST,C
	MOV	C,GCP1	;GARBAGE COLLECT PROTECT

;NOW TRANSFER THE DISPLAY CODE (YEAH)
	MOV	SNABOT,D	;BOTTOM OF STUFF TO BE SNAPPED
	JSR	PC,DYXFR	;TRANSFER THE DCODE. SKIP IF SUCCEEDS
	BEQ	SNAP.4	;COULDN'T FIND ENOUGH FREE MEMORY
SNAP.0:	TST	D	;IF 0
	BEQ	SNAP.3	;NO CODE MOVED

;CHECK THAT THIS SNAP WON'T CAUSE DISPLAY PDL OVERFLOW
	TST	-(D)	;POINTER TO SNAP
	CMP	-(D),#<<<DPDLL_-1>&77777>-1>	;DEPTH COUNTER
	BLE	SNAP.1
	CLR	GCP1
	ERROR+STD	;SNAP TOO DEEP

;NOW GO BACK AND PUT THE SNAP ADDRESS IN RIGHT PLACES
SNAP.1:	TST	(D)+	;POINT D TO REF COUNTER
	INC	(D)+	;INC COUNTER THAT SAYS HOW MANY TIMES DISPLAYED
	MOV	GCP1,C	;NOW HACK SNLIST
	MOV	D,A
	JSR	PC,.STP2	;STORE ADDRESS IN 2ND WORD OF NODE
	MOV	C,A	;POINTER TO NODE
	BIC	#170000,A
	BIS	#SNUM,A
	MOV	SNLIST,C
	JSR	PC,.STP1	;STORE NEW NODE POINTER INTO FIRST NODE OF SNLIST

	CLR	GCP1


	MOV	@S,C	;NOW HACK THE SNAP STRUCTURE
	BIC	#170000,C
	BIS	#SNP,C
	MOV	C,@S	;PUT IN RIGHT DATA TYPE
;PUT ADDRESS OF SNAP INTO FIRST OF STRUCTURE
	JSR	PC,.LDP2	;A_POINTER TO FIRST OF STRUCTURE
	MOV	A,C
	CLR	A
	MOV	D,B
	BGE	SNAP.6	;SIGN EXTEND ADDRESS
	COM	A
SNAP.6:	JSR	PC,.STORE	;STORE ADDRESS OF SNAP AS FIRST OF STRUCTURE

;NOW COLLAPSE STATIC AREA AND DISPLAY THE SNAP
	MOV	#SNABOT,A	;MAKE SURE THERE IS ROOM FOR DISPLAY HERE
	JSR	PC,STXPND
	MOV	A,STT
	MAKEPJ	D
	MOV	PUSHJT,(A)
	MOV	D,-(A)
	CLR	-(A)
	CLR DFBCNT
	CLZ
	RTS PC


;SINCE NO DISPLAY CODE WAS MOVED, RETURN EMPTY SNAP
SNAP.3:	MOV	#SNP,@S
	CLR	GCP1
	CLZ
	RTS PC

SNAP.4:	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	SNABOT,D
	JSR	PC,DYXFR	;TRY TO TRANSFER D.CODE AGAIN
	BNE	SNAP.0	;SUCCESS!
SNAP.5:	CLR	GCP1
	ERROR+TML
.IFZ FPPF

;NEWSNAP
;SET UP FOR NEXT SNAP TO START HERE
NEWSNAP:	JSR	PC,DCHK
NEWSN1:
.IIF NZ DDF,	MOV	#DCURX,D	;ENTER HERE AS SUBROUTINE
.IIF Z DDF,	MOV	#CURX,D	;ENTER HERE AS SUBROUTINE
	JSR	PC,GETINT	;GET INTEGER OF CURX IN B
	MOV	B,OLDX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,OLDY

.IFF

NEWSNAP:	JSR PC,DCHK	;DOES HE OWN A DISPLAY?
NEWSN1:	;ENTER HERE AS SUBROUTINE
.IIF NZ DDF,	MOV	#DCURX,D	;GET POINTER TO CURX
.IIF Z DDF,	MOV	#CURX,D		;GET POINTER TO CURX
	MOV #OLDX,B		;GET POINTER TO OLDX
	MOV (D)+,(B)+	;PUT CURX AND CURY INTO OLDX AND OLDY
	MOV (D)+,(B)+
	MOV (D)+,(B)+
	MOV (D)+,(B)+

.ENDC

NEWSN2:	MOV	STT,SNABOT	;RESET SNAP BOTTOM TO TOP OF DISPLAY
	CLR DFBCNT
	SEZ
	RTS	PC	;EITHER RETURN FROM SUBROUTINE , OR JMP NORT

;DISPLAY A SINGLE SNAP

DISPLAY:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP,CURX,CURY
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFZ FPPF

	MOV	E,B
	ADD	CURX+2,B
	CLR	C	;FRACTION PART IS 0 (SEE SNAP)
	JSR	PC,CHKBND	;IS NEW X COR IN BOUNDS?
	MOV	F,B
	ADD	CURY+2,B
	JSR	PC,CHKBND	;IS NEW Y COR IN BOUNDS?

.IFF

	MOV F,B		;PUT POINTER TO DY IN B
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	STF FA,FB	;FB <- DY
	MOV E,B		;PUT POINTER TO DX IN B
	JSR PC,G1NUMS	;FA <- DX
	BNE .+4
DIPSEY:	.BUG.		;NO WAY IT SHOULD FAIL EITHER
.IIF NZ DDF,	MOV #DCURX,B	;PUT POINTER TO CURX IN B
.IIF Z DDF,	MOV #CURX,B
	SETF
	ADDF (B)+,FA	;GET NEW XCOR
	ADDF (B)+,FB	;GET NEW YCOR
	SETD
	STF FA,FD	;CHECK TO SEE IF XCOR IS IN BOUNDS
	JSR PC,CHKBND
	STF FB,FD	;CHECK TO SEE IF YCOR IS IN BOUNDS
	JSR PC,CHKBND

.IFTF

;NOW SEE IF THERE'S ENOUGH ROOM IN THE DISPLAY AREA

	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

;FINALLY, WE CAN PLACE THE PUSHJ TO THE SNAP INTO THE DISPLAY LIST
DISRM:	INC	-2(D)	;INCREMENT THE REF COUNTER OF THE SNAP
	MOV	A,STT	;SET STATIC TOP TO HERE IN DLIST
	MOV	PUSHJT,(A)	;PUT PUSHJ TO TURTLE AT TOP OF DLIST
	MAKEPJ D
	MOV	D,-(A)	;PUT IN THE PUSHJ
	CLR	-(A)	;PRECEDE BY A NOP

;NOW, SET CURX AND CURY
.IFT

	ADD	E,CURX+2	;E HAD DX OF THE SNAP
	ADD	F,CURY+2	;F HAS DY OF THE SNAP
.IFF

.IIF NZ DDF,	MOV #DCURX,B	;B <- POINTER TO CURX
.IIF Z DDF,	MOV #CURX,B
	STCDF FA,(B)+	;PUT NEW XCOR INTO CURX
	STCDF FB,(B)+	;PUT NEW YCOR INTO CURY
	JSR PC,ROUNDER	;ROUND CURX,CURY AND PUT INTO RCURX,RCURY

.ENDC

	CLR DFBCNT
D.RET:	JSR	PC,SPOPT	;POP S
	SEZ
	RTS PC

;WIPE A SNAP

WIPE:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP, X,  Y

	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFNZ FPPF

	MOV F,B		;B <- POINTER TO DY OF SNAP
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	LDD FA,FB	;FB <- DY
	MOV E,B		;B <- POINTER TO DX
	JSR PC,G1NUMS	;FA <- DX
	BEQ DIPSEY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	JSR PC,ROUND	;ROUND FA AND FB
	SETI
	STCFI FA,E	;E <- DX OF THE SNAP
	STCFI FB,F	;F <- DY OF SNAP
	SETL
.ENDC
	BIC	#176000,E	;CLEAR TOP 6 BITS
	BIS	#ADDX,E	;AND TURN INTO ADDX COMMAND
	BIC	#176000,F	;CLEAR TOP 6 BITS
	BIS	#ADDY,F	;TURN INTO ADDY

	MOV	D,B
	TST	-(D)	;POINT D TO SNAP'S REF COUNTER
	MAKEPJ B	;MAKE B INTO DPUSHJ TO SNAP
	MOV	STT,A	;POINTER TO TOP OF DISPLAY LIST
	MOV	STB,C	;POINTER TO BOTTOM OF DLIST

WIPE.L:	CMP	A,C	;ARE WE AT THE BOTTOM YET?
	BLO	D.RET	;YES, SO WE ARE DONE
	CMP	B,-(A)	;IS THE NEXT WORD A PUSHJ?
	BNE	WIPE.L	;NO.  LOOP BACK AND TRY ANOTHER
;YES!  IT IS A PUSHJ
;PUT ADDX AND ADDY COMMANDS INTO DLIST
	INC	NADXY	;NADXY IS ACOUNTER TO TELL WHEN TO COMPRESS
	MOV	F,(A)	;INSERT ADDY MADE FROM DY OF SNAP
	MOV	E,-(A)	;INSERT ADDX MADE FROM DX OF SNAP

	DEC	(D)	;DECREMENT REF COUNTER
	BR	WIPE.L	;AND THEN LOOP BACK TO SEE IF THERE'S ANOTHER
;			PUSHJ TO THIS SNAP


;WIPE THE ENTIRE DISPLAY

WIPECLEAN:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

WC.1:	MOV	STB,A	;POINTER TO BOTTOM OF DISPLAY LIST
	MOV	STT,B	;POINTER TO TOP OF DLIST
	MOV	#100000,E	;SMALLEST DPUSHJ
	MOV	#140000,F	;SMALLEST COMMAND BIGGER THAN PUSHJ

WC.LP:	CMP	B,A	;ARE WE AT BOTTOM YET?
	BLOS	WC.DUN	;YES, WE ARE DONE
	CMP	-(B),E	;IS NEXT WORD DOWN A PUSHJ?
	BLO	WC.LP	;NO, IT'S TOO SMALL
	CMP	(B),F
	BHIS	WC.LP	;NO, IT'S TOO BIG
;THIS WORD IS A PUSHJ
	MOV	(B),D	;MOVE	THE PUSHJ COMMAND INTO D
	MAKEAD D	;TURN INTO PDP-11 ADDRESS
	DEC	-(D)	;DECREMENT SNAP'S REF COUNTER
	BR	WC.LP	;LOOP BACK TO LOOK FOR MORE PUSHJ'S

;NOW PLACE ADDX AND ADDY COMMANDS IN THE DISPLAY LIST
;SO THAT THE TURTLE WILL STAY AT THE SAME PLACE IT WAS BEFORE THE WIPE

.IFZ FPPF

WC.DUN:	MOV	#CURX,D
	JSR	PC,GETINT	;GET INTEGER OF  CURX IN B
	SPUSH	B	;SAVE DX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,E	;PUT DY IN E
	SPOP	D	;PUT DX IN B
.IFF
WC.DUN:
.IIF NZ DDF,	MOV #RDCURX,F	;F <- POINTER TO RCURX
.IIF Z DDF,	MOV #RCURX,F
	LDCFD (F)+,FA	;FA <- RCURX
	LDCFD (F)+,FB	;FB <- RCURY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	SETI
	STCFI FA,D	;F <- RCURX
	STCFI FB,E	;E <- RCURY
	SETL
.ENDC
	MOV	STB,STT
	JSR	PC,MTO.AD	;PUTS THE ADD COMMANDS INTO THE DLIST
	JSR	PC,NEWSN1	;SO THAT SNAPS WILL START HERE

	RTS	PC
.ENDC
.STITL DISPLAY UTILITY ROUTINES

.IFZ FPPF


;CHKBND
;	CHECK BOUNDS.  ERROR IF B IS OFF SCREEN
;	ALSO ROUNDS B,,C
CHKBND:	BIT	#WRAPF,DFLAGS
	BNE	CBRND	;GO AND ROUND
	CMP	B,#200.
	BGE	CBIBIG	;INTEGER PART MAY BE TOO BIG
	CMP	B,#-200.
	BLT	ERROOB	;DUE TO THE FACT THAT FRACTION IS ALWAYS
			;POSITIVE, IF B=-200 THAT GUARANTEES IT IS IN
			;BOUNDS. (I HOPE)
CBRND:	ASL	C
	ADC	B
	RTS	PC
;HERE, THE INTEGER PART IS >= 200.
;SO IF THE FRACTION PART IS NON-ZERO, THAT WILL MEAN THAT THE ENTIRE
;NUMBER IS GREATER THAN 200
CBIBIG:	BGT	ERROOB	;INTEGER>200
	TST	C
	BEQ	CBRND
ERROOB:	ERROR+OOB

.IFF

CHKBND:	BIT #PLOTF,DFLAGS	;IS HE USING PLOTTER?
	BNE CHK1	;YES, IGNORE WRAP FLAG
	BIT #WRAPF,DFLAGS	;IS HE WRAPPING
	BNE CBRND	;YES, DON'T CHECK BOUNDS
CHK1:	CMPF #42110,FD	;IS 200 < FD?
	CFCC
	BLT ERROOB	;YES, ERROR
	CMPF #142110,FD	;IS -200 > FD?
	CFCC
	BGT ERROOB	;YES,ERROR
CBRND:	RTS PC
ERROOB:	ERROR+OOB	;OUT OF BOUNDS

.ENDC
;	CALL WITH D POINTING TO CURX OR CURY.
;	RETURN THE INTEGER OF CURX OR CURY IN B
GETINT:	MOV	(D)+,B	;THE FRACTION PART
	ROL	B
	MOV	(D)+,B	;THE INTEGER PART
	ADC	B	;ROUND
	RTS	PC

.IFNZ NDISP

;STATIC AREA EXPAND.
;	IS THERE ROOM IN STATIC AREA FOR 2 DISPLAY WORDS?
;	RETURN POINTER TO NEW STATIC TOP IN A
STXPND:	PUSH	A
	MOV	@A,A	;ROUTINE IS CALLED WITH ADDRESS OF VARIABLE
	CMP	(A)+,(A)+	;A _ A+4
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN8	;THERE'S ROOM!
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	@(SP)+,A	;AND TRY AGAIN
	CMP	(A)+,(A)+
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN9
	ERROR+TML	;TOO MANY LINES
STXPN8:	TST	(SP)+	;POP OFF A
STXPN9:	RTS	PC

.ENDC


;MOD360
;	OUTPUT B MOD 360 IN B.
;	ALWAYS OUTPUTS A POSITIVE NUMBER
MOD360:
	TST B
	SXT A
	DIV #360.,A	;DIVIDE B BY 360
	TST B		;REM >= 0?
	BGE	M360R
	ADD	#360.,B	;IF REMAINDER WAS NEGATIVE, ADD 360 TO IT
M360R:	RTS	PC


.IFZ FPPF

;MULCOS
;	RETURN A*COSINE OF CURA IN B,,C
MULCOS:	MOV	COSA,F
	BR	MULCS2
;MULSIN
;	RETURN A*SINE OF CURA IN B,,C
MULSIN:	MOV	SINA,F
MULCS2:	CLR	E
	ASL	F	;TURN INTO BOTTOM HALF OF DP NUMBER
	SBC	E	;MAKE E NEG. IF F WAS
	JSR	PC,.DPMUL
	NOP	1
	RTS	PC
.ENDC

;ANGCRP
;	CALCULATE ANGLE CRAP.
;	CALCULATE DIREC, SINA, COSA
ANGCRP:
.IFZ FPPF
	CLR E
.IFZ DDF
	MOV CURA,F	;DIVIDE CURA BY 90.
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	MOV CURA(F),F	;F <- CURX
.ENDC
	DIV #90.,E
	MOV F,C		;THE REMAINDER
	MOV E,F		;THE QUOTIENT
	MOV #90.,E	;THE RIGHT ANGLE
	SUB	C,E	;NOW E = 90.- REMAINDER
	MOV	C,A	;A_REMAINDER
	JSR	PC,SINGET	;D_SIN (A)
	MOV	D,B
	MOV	E,A
	JSR	PC,SINGET
	ASL	F	;F = 0,1,2,3
	ADD	F,PC	;JUMP THROUGH THIS DISPATCH TABLE
	BR	ACR.D
	BR	ACRII	;QUADRANT II
	BR	ACRIII	;QUADRANT III
;FOURTH QUADRANT
	MOV	B,A	;SIN (A)
	MOV	D,B	;SIN (90-A)
	NEG	B	;SINA=-SIN(90-A) IN 4TH QUADRANT
	MOV	A,D	;AND COSA=SIN(A) IN 4TH QUADRANT
	BR	ACR.D

;THE THIRD QUADRANT
ACRIII:	NEG	B	;SINA = -SIN (A) IN 3RD QUADRANT
	NEG	D	;COSA = - SIN (90-A) IN 3RD QUADRANT
	BR	ACR.D

;SECOND QUADRANT
ACRII:	MOV	B,A	;SIN (A)
	MOV	D,B	;SINA = SIN (90-A) IN 2ND QUADRANT
	MOV	A,D
	NEG	D	;COSA = -SIN (A) IN 2ND QUADRANT

;IN THE FIRST QUADRANT
;SINA = SIN (A) AND
;COSA = SIN (90-A)
ACR.D:	MOV	B,SINA
	MOV	D,COSA

;FALLS THROUGH
;FALLS IN

;CLACULATE DIREC FROM STUFF LEFT IN F AND C BY ANGCRP
ANGDIR:	CMP	#45.,C
	ADC	F	;CARRY SET IF C<45
	ASL	F
	ASL	F
	ASL	F
	MOV	F,DIREC
	RTS	PC

;GET SIN (A) INTO D.
;THE SINE TABLE HAS ONLY EVEN ANGLES.  INTERPOLATE ODD ANGLES.
SINGET:	BIT	#1,A	;ODD OR EVEN
	BEQ	AEVEN
	ADD	#<SIN+1>,A	;POINT TO ANGLE AFTER IT
	MOV	(A),D	;SIN (A+1)
	ADD	-(A),D	;PLUS SIN (A-1)
	ROR	D	;DIVIDED BY 2
	RTS	PC
AEVEN:	MOV	SIN(A),D
	RTS	PC

.IFF
	SETI
.IFZ DDF
	LDCIF CURA,FA	;ANGCRP FOR FLOATING DISP
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	LDCIF CURA(F),FA	;FA <- CURA
.ENDC
	SETL
	STF FA,FE	;SAVE ANGLE
	JSR PC,SINDEG	;FA <- SIN (FA)
.IIF Z DDF,	STCDF FA,SINA
.IIF NZ DDF,	STCDF FA,SINA(F)	;SINA <- SINE OF ANGLE
	LDD FE,FA	;GET ANGLE
	JSR PC,COSDEG	;FA <- COS (FA)
.IIF Z DDF,	STCDF FA,COSA
.IIF NZ DDF,	STCDF FA,COSA(F)	;COSA <- COSINE OF ANGLE
	ASL C		;CALCULATE DIRECTION
	ASL C
	MOV C,DIREC
 	RTS PC

SINEF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BNE .+4
	ERROR+WTAB	;WRONG TYPE OF ARG
	JSR PC,SINDEG	;FA <- SINE (FA)
	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT SINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE


COSF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BEQ SINEF+6
	JSR PC,COSDEG	;FA <- COSINE (FA)
	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT COSINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE

SINDEG:	MOV #-1,A
	BR TRIG
COSDEG:	MOV #1,A
TRIG:	MOV #1,B
	TSTF FA
	CFCC
	BGE TRIG1
	NEGF FA
	MUL A,B
TRIG1:	DIVF #41464,FA	;DIVIDE BY 45
	MODD #40200,FA	;SEPERATE FRACTION AND INTEGER
	MODD #37400,FB
	MULF #41000,FB	;MOD 8
	SETI
	STCFI FB,C
	SETL
	ASL C
	ADD C,PC
	BR .TRIG0
	BR .TRIG1
	BR .TRIG2
	BR .TRIG3
	BR .TRIG4
	BR .TRIG5
	BR .TRIG6
	MUL A,B
	BR .TRIG7
.TRIG6:	MUL A,B 
	NEG A
	BR .TRIG0
.TRIG4:	NEG B
	BR .TRIG0
.TRIG3:	NEG B
	MUL A,B
	BR .TRIG7
.TRIG2:	NEG A
	MUL A,B
	BR .TRIG0
.TRIG5:	NEG B
.TRIG1:	NEG A
.TRIG7:	SUBF #40200,FA	;WE WANT 45 - ANGLE
	NEGF FA
.TRIG0:	MULF PI,FA
	MULF #37600,FA	;CONVERT FROM DEGREES TO RADIANS
	LDD FA,FD
	MULF FD,FD
	NEGF FD		;-ANGLE SQUARED INTO FD
	LDCFD #40200,FB	;COUNTING CONSTANT "1"
	STF FB,FF
	TST A
	BLT .TRIG9	;WE WANT SIN
	LDD FB,FA
	CLRF FB
.TRIG9:	LDD FA,FC
	TSTF FD
	CFCC
	BEQ TRIG11
TRIG10:	ADDF FF,FB
	DIVF FB,FC
	ADDF FF,FB
	DIVF FB,FC
	MULF FD,FC
	ADDF FC,FA
	CMPF #41100,FB
	CFCC
	BGE TRIG10
TRIG11:	TST B
	BGE .+4
	NEGF FA
	RTS PC
.ENDC


;XYDIR
;	CALL WITH D=DX, E=DY
;	CALCULATE DIREC BASED ON DX AND DY
XYDIR:	CLR	A	;BUILD INDEX IN A
	TST	D	;IS DX POSITIVE
	BGE	XYDIR1
	NEG	D	;ABSOLUTE VALUE OF DX
	TST	(A)+	;PUT 2 INTO A
XYDIR1:	TST	E	;IS DY POSITIVE
	BGE	XYDIR2
	NEG	E	;ABSOLUTE VALUE OF DY
	INC	A	;INCREMENT INDEX
XYDIR2:	CMP	D,E	;WILL GENERATE CARRY IF D<E
	ROL	A	;PUT CARRY INTO BOTTOM BIT OF INDEX.  AND MULTIPLY REST BY 2
	MOVB	DREC(A),DIREC	;NOW MOVE THE RIGHT THING INTO DIREC
	RTS	PC




.IFNZ NDISP

;DYXFR
;	TRANSFER FROM STATIC AREA TO DYNAMIC AREA
;	THE CODE BEING TRANSFERRED STARTS AT D AND GOES UP TO STT
;	ON RETURN, D POINTS TO THE TRANSFERRED DCODE
;	IF NO CODE WAS TRANSFERRED, THEN D = 0.
;	SKIPS IF THERE'S ROOM FOR TRANSFER
DYXFR:	MOV	STT,E
	SUB	D,E	;LENGTH OF DCODE TO BE MOVED
	BEQ	DYRET	;NOTHING TO BE MOVED
;ALLOCATE STORAGE
;LENGTH OF BLOCK TO BE ALLOCATED IS IN E
DYAL:	ADD	#6,E	;INCREASE LENGTH TO ALLOW FOR REF CNTR, DEPTH CNTR, AND POPJ
	MOV	DYR,B	;INITIALIZE POINTER
	MOV	#1,C	;INITIALIZE FLAG
DYAL1:	MOV	2(B),A	;POINTER TO NEXT FREE BLOCK
	BNE	DYAL2
	DEC	C	;NO NEXT FREE BLOCK--TEST AND SET FLAG
	BNE	DYAL7	;NO MORE ROOM--GO TO EXPAND DY AREA
	MOV	DYB,B	;START AGAIN AT BOTTOM OF LIST
	BR	DYAL1
DYAL2:	MOV	(A),F	;FREE BLOCK FOUND--CHECK LENGTH
	SUB	E,F
	BPL	DYAL4
DYAL3:	MOV	A,B	;BLOCK TOO SHORT--MOVE TO NEXT BLOCK
	BR	DYAL1
DYAL4:	BNE	DYAL5	;BLOCK LONG ENOUGH--IF FILLED EXACTLY
	MOV	2(A),2(B)	;REMOVE BLOCK FROM LIST BY CHANGING POINTERS
DYAL5:	CMP	F,#2	;DONT LEAVE A BLOCK OF LENGTH 2 BYTES
	BEQ	DYAL3
	MOV	F,(A)	;NEW LENGTH OF FREE BLOCK
	MOV	2(B),C	;RESET ROVING POINTER
	BNE	DYAL6	;DONT SET IT TO O
	MOV	DYB,C
DYAL6:	MOV	C,DYR	
	ADD	F,A	;START STORING AT THIS ADDRESS
	BR	DYAL9
DYAL7:	MOV	DYB,A	;ADD NEW BLOCK TO BOTTOM OF LIST
	MOV	2(A),F	;POINTER TO 2ND FREE BLOCK
	SUB	E,A
	CMP	A,STT
	BHI	DYAL8	;THERE IS ENOUGH ROOM IN THE DY AREA
	SEZ
	RTS	PC	;NOT ENOUGH ROOM
DYAL8:	MOV	A,DYB	;NEW BOTTOM OF DY
	MOV	A,DYR	;FIX ROVING POINTER
	MOV	DYB,C	;SET UP NEW LIST BOTTOM
	CLR	(A)+
	MOV	F,(A)+
DYAL9:	SUB	#6,E	;RESTORE LENGTH


;NOW A CONTAINS ADDRESS OF FREE BLOCK
;E CONTAINS NUMBER OF BYTES TO BE TRANSFERRED
;NOW FINALLY YOU GET TO DO THE TRANSFER
;WHILE YOU DO IT, INCREMENT THE REF COUNTER OF ANY PUSHJ'S
DYXFR1:	MOV	#100000,C	;THE CODE FOR DISPLAY PUSHJ
	MOV	#140000,B	;NEXT HIGHER DISPLAY COMMAND
	SPUSH	A	;SAVE POINTER TO DEPTH COUNTER
	CLR	(A)+	;DEPTH_0
	CLR	(A)+	;SET REFERENCE COUNTER TO ZERO
	ASR	E	;E/2 = NUMBER OF WORDS TO BE TRANSFERRED
;PICK UP A WORD.  SEE IF ITS A PUSHJ. AND TRANSFER IT
DYXFR2:	DEC	E	;NUMBER OF WORDS TO BE XFRED
	BLT	DYXFR3
	MOV	(D)+,F	;WORD OF DCODE IN F
	MOV	F,(A)+	;PUT THIS WORD IN ITS NEW PLACE
	CMP	F,C
	BLO	DYXFR2	;NOT A PUSHJ
	CMP	F,B
	BHIS	DYXFR2	;NOT A PUSHJ
;IT IS A PUSHJ
	MAKEAD	F
	INC	-(F)	;INCREMENT THE REF COUNTER
	CMP	-(F),@(SP)	;DEPTH _ MAX (DEPTH OF SUB SNAPS)
	BLE	DYXFR2
	MOV	(F),@(SP)	;DEPTH OF SUB SNAP BIGGEST YET
	BR	DYXFR2	;LOOP BACK

;ALL TRANSFERRING DONE.  END THE BLOCK WITH A POPJ
DYXFR3:	MOV	#DPOPJ,(A)
	SPOP	D	;POINTER TO DEPTH COUNTER
	INC	(D)+
	TST	(D)+	;POINTER TO FIRST D.WORD OF SNAP
	CLZ
	RTS PC	;AND RETURN

;THERE WAS NOTHING TO BE MOVED
DYRET:	CLR	D	;TO SIGNAL THIS FACT
	CLZ
	RTS PC

;DYFREE
;	CALLED DURING GARBAGE COLLECTIONS
;	CALL WITH D POINTING TO REF COUNTER (WORD BEFORE SNAP)
;	FREES THE BLOCK!!
DYFREE:	PUSH	A	;SAVE REGISTERS
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	MOV	#100000,A
	MOV	#140000,B
	MOV	#DPOPJ,C
	JSR	PC,DYF1	;DOES THE FREEING
	JMP	RETF	;RESTORE AC'S AND RETURN TO OUT OF DYFREE

;REAL WORK OF FREEING STARTS HERE.
DYF1:	MOV	D,-(SP)	;SAVE PTR TO 2ND WORD OF BLOCK
	TST	(D)+	;POINT D TO FIRST WORD

;PICK UP EACH WORD OF BLOCK.  IF IT IS A PUSHJ, FREE THAT BLOCK
;CONTINUE UNTIL A POPJ IS REACHED
DYF11:	MOV	(D)+,F	;NEXT WORD
	CMP	F,A
	BLO	DYF11	;NOT PUSHJ OR POPJ
	CMP	F,B
	BHIS	DYF2	;NOT PUSHJ, BUT MAY BE POPJ

;	ITS A PUSHJ
	MAKEAD	F
	DEC	-(F)	;REF COUNTER
	BR DYF11	;LOOK AT NEXT WORD

;IS THE WORD A POPJ
DYF2:	CMP	F,C	;C CONTAINS A POPJ
	BNE	DYF11	;NOT A POPJ.  LOOK AT NEXT WORD
	SPOP	C	;POINTER TO 2ND WORD OF BLOCK
	TST	-(C)	;NOW IT POINTS TO BOTTOM WORD
	SUB	C,D	;LENGTH OF BLOCK
	MOV	D,F


;NOW LINK BLOCK BACK TO FREE CORE
;C/ADDRESS OF BLOCK TO BE LIBERATED
;F CONTAINS LENGTH OF BLOCK

DYLIB:	MOV	DYB,B	;INITIALIZE POINTER TO BOTTOM OF LIST
DYLIB1:	MOV	2(B),A	;NEXT FREE BLOCK
	BEQ	DYLIB3	;AT END OF LIST
	CMP	A,C
	BHI	DYLIB2	;PASSED BLOCK TO BE FREED
	MOV	A,B	;TRY NEXT FREE BLOCK
	BR	DYLIB1
DYLIB2:	MOV	F,D	;CHECK UPPER BOUND
	ADD	C,D	;DO WE COLLAPSE NEW BLOCK WITH NEXT ONE?
	CMP	D,A
	BNE	DYLIB3	;NO
	ADD	(A),F	;YES--NEW LENGTH
	MOV	2(A),2(C)	;NEW POINTER
	CMP	A,DYR	;DID WE JUST SCREW ROVING POINTER?
	BNE	DYLIB4
	MOV	DYB,DYR	;YES--RESET IT
	BR DYLIB4
DYLIB3:	MOV	A,2(C)	;POINTER TO NEXT FREE BLOCK--NO COLLAPSE ON TOP
DYLIB4:	MOV	(B),D	;CHECK LOWER BOUND
	ADD	B,D
	CMP	D,C	;DO WE COLLAPSE WITH BLOCK ON BOTTOM?
	BNE	DYLIB5	;NO
	ADD	F,(B)	;NEW LENGTH OF PREVIOUS BLOCK
	MOV	2(C),2(B)	;NEW POINTER
	BR	DYLIB6
DYLIB5:	MOV	C,2(B)	;POINTER IN PREVIOUS BLOCK--NO COLLAPSE
	MOV	F,(C)	;LENGTH OF BLOCK JUST FREED
DYLIB6:	MOV	C,A	;DID WE JUST FREE BOTTOM BLOCK IN DY?
	SUB	#4,A
	CMP	A,DYB	;NOTE THAT IF CURRENT BLOCK = DYB+4
			;THEN PREVIOUS BLOCK (ADDR IN B) MUST BE DYB
	BNE	DYLIB7	;NO
	ADD	(C),B	;YES--COLLAPSE DY AREA
	CLR	(B)
	MOV	2(C),2(B)	;NEW BOTTOM BLOCK
	MOV	B,DYB
	MOV	B,DYR	;FIX POINTERS
DYLIB7:	RTS	PC


;DSGCF
;	CALLED BY LOGO GARBAGE COLLECTOR WHEN ITS ALL DONE
;	SEE IF EACH SNAP ON THE SNAP LIST WAS MARKED.
;	AND DYFREE THE SNAP IF NOT MARKED AND IT'S REFERENCE COUNTER IS 0

DSGCF:	CLR	F
	BR	DSGC1

DSGC4:	TST	F	;0 IF FIRST TIME THROUGH
	BEQ	DSGC5

;
;CODE FROM DSGC8 - DSGC9 GETS CALLED BY DCHK TO COMPRESS DISPLAY AREA
;
DSGC8:	MOV	STB,A	;COMPRESS ADDX'S AND ADDY'S IN STATIC AREA
	MOV	SNABOT,B	;FIRST DO PART BELOW SNAP BOTTOM
	JSR	PC,ADDSHK
	MOV	C,SNABOT	;C IS NEXT LOCATION TO STORE INTO
	MOV	STT,B	;NOW DO PART ABOVE SNAP BOTTOM
	JSR	PC,ADHK0	;DON'T RECLOBBER C.
	MOV	(A),(C)	;STORE PUSHJ TURTLE, TOO
	MOV	C,STT
	CLR	NADXY

DSGC9:	RTS	PC
DSGC5:	MOV	#<DSGC6-DSGCF1>,F	;NOW CLEAR MARKED BITS
DSGC1:	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BEQ	DSGC8	;OBVIOUSLY DOESN'T HAVE SNAPS

	JSR	PC,.LOADC	;FIRST NODE OF LIST IS DUMMY
DSGC2:	MOV	C,E	;SAVE POINTER TO NODE
DSGC3:	BIT	#7777,A	;LEAVE ADDRESS ONLY
	BEQ	DSGC4	;END OF LIST
	MOV	A,C	;POINTER TO NEXT NODE
	JSR	PC,.LOADC
	ADD	F,PC	;CHOOSE BETWEEN FREEING AND CLEARING

;TRY TO FREE THE SNAP
DSGCF1:	TST	-(B)	;WAS SNAP MARKED?  (B POINTS TO REF COUNT)
	BNE	DSGC2	;EITHER DISPLAYED OR MARKED

;NOT MARKED, AND NOT DISPLAYED ANYWHERE!!
;FREE THIS SNAP
	JSR	PC,.FREE	;CLEAN UP SNLIST
	MOV	E,C	;POINTER TO PREVIOUS NODE OF SNLIST
	JSR	PC,.STP1	;STORE A AS TOP WORD OF PREVIOUS NODE
	MOV	B,D	;POINTER TO SNAP DCODE
	JSR	PC,DYFREE
	BR	DSGC3

DSGC6:	BIC	#100000,-(B)	;CLEAR MARKED BIT
	BR	DSGC3

;ADDS HACK
;	COMPRESS ADDX'S AND ADDY'S STARTING AT LOCATION IN A
;	AND GOING TO LOCATION IN B. (DOESN'T STORE WORD AT LOC IN B)
ADDSHK:	MOV	A,C	;C IS NEXT LOC TO STORE INTO.
ADHK0:	CLR	-(SP)	;FLAG. (NOT IN MIDDLE OF ADD'S)
ADHK1:	CMP	A,B	;ARE WE DONE?
	BHIS	ADFIN	;YES
	MOV	(A)+,D	;NEXT WORD
	CMP	D,#ADDY
	BLO	ADNOT	;NOT AN ADD
	TST	(SP)	;IN MIDDLE OF ADD'S ALREADY ?
	BNE	ADPHS1	;YES
	CLR	E	;NO. THIS IS FIRST ADD
	CLR	F
	INC	(SP)	;SET FLAG
ADPHS1:	CMP	D,#ADDX	;THE BIGGER ADD COMMAND
	BHIS	ADPHSX
;IT IS AN ADDY
	ADD	D,F	;ADD THE DELTA-Y INTO F
	BR	ADHK1	;LOOP BACK
ADPHSX:	ADD	D,E	;ADD THE DELTA-X INTO E
	BR	ADHK1

ADNOT:	TST	(SP)
	BEQ	ADHK2	;NOT END OF ADD'S
	JSR	PC,ADPHSF	;JUST ENDED ADDS.
	CLR	(SP)
ADHK2:	MOV	D,(C)+	;STORE THIS WORD
	BR	ADHK1

ADFIN:	TST	(SP)+	;ALL WORDS PICKED UP
	BEQ	ADHK3
	JSR	PC,ADPHSF	;BUT FIRST FINISH ADDS
ADHK3:	RTS	PC

;ADD PHASE FINISHED.  STORE ADDX E, ADDY F.
ADPHSF:	BIC	#176000,E
	BIC	#176000,F
	BEQ	ADPF1	;DELTA-Y = 0
	BIS	#ADDY,F
	MOV	F,(C)+	;STORE ADDY
ADPF1:	TST	E
	BEQ	ADPF9	;DELTA-X = 0
	BIS	#ADDX,E
	MOV	E,(C)+	;STORE ADDX
ADPF9:	RTS	PC


;MKDC
;	CALLED BY LOGO GARBAGE COLLECTOR DURING MARKING PHASE
;	CALLED WITH B POINTING TO SNAP NODE
MKDC:	TST	SNLIST	;CALLED TO KILL THE DISPLAY?
	BEQ	MKDC.K	;YES
	BIT	#7777,B
	BEQ DSGC9	;EMPTY SNAP
;MARK THE SNAP
	PUSH	A
	SPUSH	B
	JSR	PC,.LOAD	;POINT B TO NODE CONTAINING SNAP ADDR
	TST B
	BEQ MKDC1
	JSR	PC,.LOAD	;B_SNAP ADDRESS
	BIS	#100000,-(B)	;MARK REF COUNTER
MKDC1:	SPOP	B	;RESTORE A AND B
	SPOP	A
	RTS	PC

;CALLED BY KILLDISPLAY
;TURN SNAP INTO EMPTY SNAP
MKDC.K:	SPUSH	A
	SPUSH	B
	SPUSH	C
	MOV	B,C	;POINTER TO DCODE NODE
	CLR	A
	JSR	PC,.STP2
	JMP	RETC



;HERE START THE LINE AND TURTLE DRAWING PROGRAMS

;DR.LIN
;	DRAW A LINE. D=DX, E=DY, OR VICE VERSA.
;	THE DIRECTION CODE FOR THE LINE IS IN DIREC
DR.LIN:	CMP DIREC,ODIREC
	BEQ .+6
	CLR DFBCNT
	JSR	PC,DR.STUP	;SET A=CON, B=AC.
	SPUSH	D
	ADD	STT,D	;D = HOW MANY MORE WORDS IN DLIST
	CMP	D,DYB	;COMPARE TO DY BOTTOM
	BLO	DR.L1	;THERE'S ROOM
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	SPOP	D	;TRY TO FIT LINE AGAIN
	ADD	STT,D
	CMP	D,DYB
	BLO	DR.L2	;THERE'S ROOM!
	ERROR+TML	;TOO MANY LINES

;OKAY, THERE WAS ROOM FOR THE LINE
DR.L1:	TST	(SP)+	;WE HAD PUSHED D UP ABOVE
DR.L2:	MOV	D,STT	;SET STT TO NEW STATIC TOP
	MOV	PUSHJT,(D)	;PUT PUSHJ TURTLE AT TOP
	JSR	PC,DR.ASC	;ASSEMBLE THE DISPLAY CODE
	MOV DIREC,ODIREC
	RTS	PC	;RETURN


;DRAW THE TURTLE
DR.TUR:	PUSH DIREC
	SPUSH DFBCNT
	MOV	#TURSIZ,C	;TURTLE SIZE
.IFZ FPPF
	CLR	B
	JSR	PC,MULCOS	;E,,F _ SIZE * COSA
	ROL	F
	ADC	E	;ROUND
	MOV	E,D
	JSR	PC,MULSIN	;E,,F _ SIZE * SINA
	ROL	F
	ADC	E	;ROUNFD
.IFF
	SETI
	LDCIF C,FA
	SETL
.IIF NZ DDF,	LDCFD DSINA,FB
.IIF Z DDF,	LDCFD SINA,FB
	MULF FA,FB
	ADDF #40000,FB	;ROUND
.IIF NZ DDF,	LDCFD DCOSA,FC
.IIF Z DDF,	LDCFD COSA,FC
	MULF FA,FC
	ADDF #40000,FC
	SETI
	STCFI FB,E
	STCFI FC,D
	SETL
.ENDC

	SPUSH	D
	SPUSH	D
	SUB	E,2(SP)	;NOW SIZE * (COSA - SINA) IS ON STACK
	ADD	E,(SP)	;NOW SIZE * (COSA + SINA) IS ON STACK

	MOV	TUB,TUT	;TUT WILL BE POINTER TO TOP OF TURTLE DLIST SO FAR

;SIDE 1
	ADD	#20,DIREC	;SIDE 1 IS 2*45 DEGREES LEFT OF CURRENT DIRECTION
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 2
	SUB	#30,DIREC	;SIDE 2 IS 3*45 DEGREES RIGHT OF SIDE 1
	MOV	(SP)+,D	;DX IS SIZE * (COSA + SINA)
	MOV	(SP)+,E	;DY IS SIZE * (COSA - SINA)
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 3 HAS THE SAME INCREMENTS AS SIDE 2.
;JUST THE DIRECTION IS DIFFERENT
	MOV	DIREC,B
	SUB	#20,B	;SIDE 3 IS 2*45 DEGREES RIGHT
	BIC	#177707,B	;LEAVE ONLY THE 3 BITS
	SWAB	B	;PUT THE DIREC BITS IN TOP BYTE
	MOV	TUT,C	;POINTS TO WORD ABOVE LAST ONE OF TURTLE DLIST
	MOV	C,A
	SUB	D,C	;SINCE D POINTS TO BOTTOM WORD OF SIDE 2
			;C-D IS NUMBER OF BYTES IN SIDE 2'S DLIST
	ASR	C	;C/2 = NUMBER OF WORDS
DR.TS3:	MOV	(D)+,E	;NEXT WORD OF SIDE 2'S DLIST
	BIC	#34000,E	;CLEAR THE DIRECTION BITS THEREIN
	BIS	B,E	;AND SET THEM FROM THE NEW DIREC IN B
	MOV	E,(A)+	;STORE IN DLIST
	DEC	C	;NUMBER OF WORDS IN SIDE 2'S DLIST
	BGT	DR.TS3	;THERE ARE MORE WORDS

;SIDE 4 IS IDENTICAL TO SIDE 1
;FURTHERMORE, SIDE 1 IS MADE UP OF ONLY ONE WORD
	MOV	@TUB,(A)+	;PUT THE FIRST WORD OF TURTLE INTO TOP WORD
	MOV	#DSTOP!DPOP,(A)

;RESTORE DIREC, THEN RETURN
	SPOP DFBCNT
	POP DIREC
	RTS	PC


;DRAW TURTLE SIDE
;	DRAW ONE SIDE OF THE TURTLE
;	DIREC CONTAINS THE DIRECTION
;	TUT POINTS TO TOP OF TURTLE DISPLAY LIST SO FAR
;	C,D = + OR - DX OR DY
DR.TSD:	BIC	#177707,DIREC	;BITS MAY HAVE BEEN SET BY THE SUBTRACTING
	CLR DFBCNT
	JSR	PC,DR.STUP
	ADD	TUT,D	;D = NEW TOP OF TURTLE
	MOV	D,TUT
	JMP	DR.ASC	;ACTUALLY CREAT THE DISPLAY LIST


;SET UP CON AND AC
;	CALL WITH D,E = + OR - DX OR DY
;	PASSES ON A=FRACTION: MIN (DX/DY,DY/DX)
;		B=ACCUMULATED FRACTION PART SIDEWAYS OF MAIN DIRECT.
;		STARTS AT 1/2
DR.STUP:	TST	D
	BGE	DR.TE	;TEST E
	NEG	D	;MAKE D POSITIVE
;MAKE SURE E IS POSITIVE
DR.TE:	TST	E
	BGE	DR.BIG	;NEXT WE'LL SEE WHICH IS BIGGER
	NEG	E	;MAKE D POSITIVE

;WHICH IS BIGGER
DR.BIG:
	CLR B		;CLEAR LOW WORD OF WHICHEVER NUMBER
	CMP	D,E
	BGT	DR.DBG	;D IS BIGGER
	BEQ	DR.EQ	;THEY ARE THE SAME SIZE

;OTHERWISE, E IS BIGGER
	ASL	E	;SO EAE WON'T OVERFLOW WITH A 16 BIT QUOTIENT
	MOV D,A		;DIVIDE D,,0 BY E
	DIV E,A
	MOV	E,F	;WHICHEVER IS BIGGER IS THE NUMBER OF INCS
	BR	DR.SC4

;THEY ARE THE SAME SIZE
DR.EQ:	MOV	#-1,A	;SET CON = .777...
	MOV	E,F	;NUMBER OF INCS
	BR	DR.SC5

;D IS BIGGER
DR.DBG:	ASL D
	MOV E,A		;DIVIDE E,,0 BY D
	DIV D,A
	MOV	D,F	;NUMBER OF INCS

;NOW PICK UP THE QUOTIENT
DR.SC4:
	ASL	A	;MAKE QUOTIENT 16 BITS
	ASR	F	;SINCE WE DOUBLED IT ABOVE

;NOW SET AC = .1000 = 1/2 IN THIS REPRESENTATION
DR.SC5:	MOV	#100000,B
;FALLS IN!

;CALCULATE THE NEW END POINT OF THE DLIST
;	RETURNS A AND B AS ABOVE
;	C = BIT-POSITION OF LAST BIT OF NEW CODE
;	  (GENERATED BACKWARDS--STORE FROM HERE BACK)
;	D = NUMBER OF MORE WORDS IN DLIST
;	  (WILL BECOME ADDR OF LAST NEW WORD + 2)
;	E = TOP BYTE OF INCR INSTRUCTION, SWAPPED
;	F = # NEW INCREMENTS
DR.NEP:	CLR C		;CLEAR BIT-POSITION
	MOV F,E		;GET # OF INCREMENTS
	SUB DFBCNT,E	;LESS # LEFT OVER
	MOV E,D
	ASH #-3,D	;DIVIDE BY 8
	ASL D
	BIC #177770,E	;REMAINDER IS # BITS IN LAST WORD
	BEQ DR.NE2	;IF 0 THEN = 8 IN PREVIOUS WORD

	MOV #8.,DFBCNT	;ELSE FREE BITS = 8 - # USED
	SUB E,DFBCNT
	TST (D)+	;ADD ONE-WORD FUDGE FACTOR IN THIS CASE
	SPUSH E
	SEC
DR.NE1:	RORB C		;SHIFT FIRST-BIT IN OR RIGHT ONE BIT
	DEC E		;SHIFT IT RIGHT (REMAINDER) PLACES
	BNE DR.NE1
	SPOP E
	BR DR.NE3

;REMAINDER WAS 0:  LAST WORD GETS FILLED UP
DR.NE2:	INC C		;LAST BIT IS LAST IN WORD
	CLR DFBCNT	;NO FREE BITS

DR.NE3:	ADD #DINC_-8,E	;PUT IN "INCREMENT" CODE
	ADD	DIREC,E	;ADD IN THE DIRECTION
	RTS	PC


;ACTUALLY ASSEMBLE THE NEW DISPLAY LIST
;	CALL WITH A=SIDEWAYS/FORWARD, B=1/2 (ACCUM SIDEWAYS),
;	C=FIRST BIT POS., D=POINTER  TO FIRST WORD TO STORE OF DLIST
;	E=TOP HALF OF THE INC MODE INSTRUCTION, F=NUMBER OF INCS
DR.ASC:	SWAB	E	;STUFF IN E WAS IN WRONG HALF
DR.AS0:	ADD	A,B	;CON+AC
	BCC	DR.AS1
	ADD	C,E	;CARRY, SO PUT A 1 INTO DCODE
DR.AS1:	DEC	F	;NUMBER OF INCS
	BLE	DR.ALW	;THIS WAS THE LAST WORD
	CLC
	ROLB	C	;SHIFT BYCNT
	BCC	DR.AS0	;CONTINUE WITH THIS WORD

;THIS WORD DONE
	JSR	PC,DR.SH
	MOV	E,-(D)	;STORE IN DLIST
	BIC	#3777,E	;0 THE COUNT AND BOTTOM BYTE
	MOV	#1,C	;RESET BYCNT
	BR	DR.AS0

;ALL THAT'S LEFT TO DO IS STORE THE BOTTOM WORD OF NEW DLIST
DR.ALW:	MOV -(D),B	;GET WORD TO HOOK
	CLR A		;SET UP BIT TO HOOK FROM
	SEC		;  "
DR.LW1:	ROL A		;  "  OR NEXT BIT TO HOOK FROM
	CLC
	ROLB C		;NEXT BIT TO HOOK INTO
	BCS DR.LW2	;DONE HOOKING
	BIT A,B		;GET BIT
	BEQ DR.LWX
	ADD C,E		;STORE IT
DR.LWX:	CLC		;SET UP FOR ROL A
	BR DR.LW1

DR.LW2:	JSR	PC,DR.SH	;SHOVE TO RIGHT END OF WORD
	MOV	E,(D)	;STORE LAST WORD
	RTS	PC

;SHIFT CODE RIGHT 8 MINUS COUNT TIMES

DR.SH:	PUSH	E
	SWAB E		;GET COUNT OF USED BITS
DR.SH1:	BIC #177770,E	;ISOLATE COUNT
	BEQ	DR.SH2	;DONE
	INC E		;COUNT UP; DONE AT 8 (OR 0)
	CLC
	RORB	(SP)	;MAKE ANOTHER FREE BIT AT LEFT
	BR	DR.SH1
DR.SH2:	POP	E
	RTS	PC

.ENDC
.STITL DISPLAY BUFFERS
CODEND==.
CODENB==<<._-6>&1777>+1
PUREK==<PURE_-11.>&37
HEREK==<._-11.>&37
.IF GT PUREK+16.-HEREK
.IF NZ NDISP
	.=PURE+100000
.ENDC
NCODEB==<<._-6>&1777>-CODENB
.ENDC
.IFNZ NDISP

	DPDL=DSLOT
	TLIST=DPDL+DPDLL
	DLIST=TLIST+TLEN
.ENDC
