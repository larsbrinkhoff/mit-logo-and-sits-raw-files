
.STITL TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI

;TO DO:
;FIX INTERRUPT MACROS
;HARDWARE INITIALIZATION
;MODEM AND ERROR CODE
;SYSTEM CODE
;MULTIPLE DM
;PGEN1
;DING

	VERN==VERN+%FNAM2

NMODEM==1
.STITL TELETYPE MACROS

.MACR TBK
	.BLKW	NLTY
.ENDM
.STITL TELETYPE DISPATCH TABLES--DATA SPACE

;ALL FOLLOWING CODE CAN BE IN DATA SPACE ONLY!!!!!!!!!!


;DISPATCH TABLE FOR SPECIAL INPUT CHARS WITH EFFECT ON TYPEOUT LEVEL
TIICTB:	TOICC	;^C COPY NXT CHAR FROM EDIT TO TYI BUFFER
	TOICD	;^D DELETE NEXT CHAR FROM EDIT BUFFER
	TICG
	TOICM	;^M POSSIBLE END OF LINE
	TOICN	;^N COPY NEXT WD FROM EDIT TO TYI BUFFER
	TOICQ	;^Q JUST ECHO
	TOICR	;^R COPY REST OF EDIT BUFFER TO TYI BUF
	TOICS	;^S SKIP NXT WD IN ED. BUF.
	TOICW	;^W RUB OUT UP TO PREVIOUS WD SEPERATOR
	TOICX	;^X CLARIFY INPUT
	TOICY	;^Y RECOVER PREVIOUS LINE
	TICZ
	TOIRB	;RUBOUT
	TOIOB	;[ INCREMENT LIST COUNT
	TOICB	;] DECREMENT LIST COUNT
	TICB


;DISPATCH TABLE FOR CHARS SPECIAL ON OUTPUT
;(HAVE FOF ON IN DTBL(CHARACTER)
TOOCTB:	TOOCA	;^A PRINTS AS C.R.
	TOOCH	;^H BACKSPACE, DECREMENTS CHARNO
	TOTYOC	;^G PRINTS AS SELF
	TOOCM	;^M PRINTS AS CR, LF
	TOOCI	;^I (TAB) SPACES TO NEXT TAB STOP
	TOTYOC	;^J (LINEFEED) PRINTS AS SELF
	TOTYOC	;^K (VERTICAL TAB) PRINTS AS SELF
	TOTYOC	;^L (FORMFEED) PRINTS AS SELF
.STITL TELETYPE VARIABLES

NLTY==NTTY+<5*NTBOX>	;TBOX +4 DEVICES
NMXTY==NTBOX
NPORTS==NLTY+<20*NDM>-NDMTY	;DON'T DUPLICATE DM11 TTYS

;STANDARD DEVICE REGISTER BITS
%ER==1_15	;ERROR
%RDY==1_7	;READY
%INT==1_6	;INTERRUPT ENABLE
%CRDT==1_2	;CARRIER DETECT
%ENB==1		;ENABLE
%DTRDY==1	;DATA TERMINAL READY

TBKCH:	7	;^G BREAK TO LEVEL 0
TBKCHL:	32	;^Z BREAK TO LEVEL N
LINEL:	60.	;LINE LENGTH

OMXRES=.-NFTBOX
	OMXNUL==OMXRES+1	;RH--RESET CHAR, LH--NULL CHAR
	.BYTE 21,0	;TBOX (DC0)
	.BYTE 0,40	;TURT 1
	.BYTE 0,40	;TU 2
	0	;MBX
	.BYTE 0,21	;DUMMY

TUDN:	ZEPT NTUR,NFTUR+<2*.RPCNT>

	.IFNZ NPLOT
.IIF NZ AI,	PLTDVN=NFTUR+2	;THIS HACK UNTIL WE HOOK 2 CONTROLLERS TO THE SYSTEM
.IIF NZ GUY,	PLTDVN=NFTUR+6	;THIS HACK UNTIL WE HOOK 2 CONTROLLERS TO THE SYSTEM

	.ENDC

;USE TELETYPE TABLE--LOGICAL TTY FOR EACH USER
UTYTB:	ZEPT NTY,NFTY
	ZEPT MNUSRS-1,NFDMTY+<2*.RPCNT>

.IFZ CJR

TYRS:	;RECEIVE VECTORS FOR EACH TTY
	TKS	;CONSOLE TTY
	DC1RS	;DC1
.IIF Z DHON,	ZEPT 20,DM0CSR	;DM11 TTYS
.IIF NZ DHON,	ZEPT 20,DH0SCR
 	DC0RS	;DC0
	ZEPT 4*NMXTY,-1	;PSEUDO TTYS

TYPTYP:		;PHYSCIAL TTY TYPE
	TPMODM==100000	;MODEM
	TPMPX==40000	;MULTIPLEXOR
	TPPTY==20000	;PSEUDO TTY OR MULTIPLEXEE
	TPDM==10000	;DM11 TTY
		;RH=CPS/10.
.IIF NZ AI,	3		;CONSOLE TTY
.IIF NZ GUY,	1
	3		;DC1, MODEM
	ZEPT 20,TPDM!3	;DM11S
	TPMPX!12	;DC0, THORTON BOX
	TPPTY!3		;TURTLE 1
	TPPTY!3		;TURTLE 2
	TPPTY!3		;MUSIC BOX
	TPPTY!3		;DUMMY

TILTTY:		;RH--LOGICAL TTY # OF EACH PHYSICAL TTY
		;-1 IF ILLOGICAL
		;LH--MPXR #, -1 IF NOT MPXED
	ZEPT NTTY,<
	.BYTE 2*.RPCNT,-1		;CONS, DCS, KLS AND DM11 TTYS
	>
	ZEPT 20-NDMTY,-1	;REST OF DMS
	ZEPT NTBOX,<		;THORTON BOXES
	.BYTE NFTBOX+<2*.RPCNT>,-1
	>
	ZEPT 4*NTBOX,<			;LOGICAL DEVICES
	.BYTE NFTUR+<2*.RPCNT>,NFTBOX+<2*<.RPCNT_-2>>
	>

.IFF

PDMAP:	;LOGICAL TTY # OR MPXR OF EACH PHYSICAL DEVICE
	;-1 IF UNASSIGNED

	0	;CONSOLE
	2	;DC
	0	;DC--MPXR 0
	ZEPT NDMTY,4+<2*.RPCNT>	;DM'S
	ZEPT <20*NDM>-NDMTY,-1	;UNUSED DM'S

LDMAP:	;PHYSICAL TTY OR MPXR OF EACH LOGICAL DEVICE OR MPXR

	0	;CONSOLE
	2	;DC
	ZEPT NLTY-2,6+<2*.RPCNT>
	ZEPT 4,NFTBOX	;MPXR 0
	4	;MPXR PHYSICAL DEVICE

PDWORD:	;FOR EACH PHYSICAL TTY

	TPMPX==100000	;MPXR
	TPCON==40000	;CONSOLE
	TPDC==20000î	;DC
	TPKL==10000	;KL
	TPDM==4000	;DM

	TPCON
	TPDC
	TPMPX!TPDC
	ZEPT <20*NDM>,TPDM	;DM'S

LDWORD:
MPWORD:	;FOR EACH LOGICAL DEVICE OR MPXR
	;TPMPX SET UP ABOVE

	TPPTY==40000	;MULTIPLEXEE
	ZEPT NTTY,TPPTY
	ZEPT NTUR,TPPTY
	ZEPT NMBX,TPPTY
	ZEPT NPLOT,TPPTY
	;MULTIPLEXORS
	ZEPT NTBOX,TPMPX

PDRS:	;ADDRESS OF RECEIVE STATUS REGISTER FOR PHYS DEV

	TKS	;CONSOLE
	DC1RS
	DC0RS
.IIF Z DHON,	ZEPT 20,DM0CSR	;DM
.IIF NZ DHON,	ZEPT 20,DH0SCR

.ENDC

TYCKBP:	ZEPT NLTY,TYCKBK+<.RPCNT*10>	;PNTRS TO CLOCK BLOCK
TYCKBK:	ZEPT NLTY,<
	.BLKW 3	;CLOCK BLOCK	(3 WDS FOR EACH MODEM)
	2*.RPCNT	;TTY INDEX (FOR CLOCK LEVEL STUFF)
>


;LOGICAL DEVICE NAME ARRAY
;YOU CAN CALL TYO WITH ONE OF THESE  NAMES
LDEVAR:
	$$TTY
	-1
	$$MUSIC
	MBDN
	$$TUR1
	NFTUR
	$$TUR2
.IFZ GUY
	1	;HOWEVER, WE HAVE A PLOTTER PLUGGED IN NOW
.IFF
	NFTUR+2
.IFT
	$$LIGHT
	NFTUR+6
.ENDC
	$$PLOT
	PLTDVN
	0

;POINTED TO BY LOGICAL DEVICE NAME ARRAY
$$TTY:	TEXT ^/TTY/
$$MUSIC:	TEXT ^/MUSIC/
$$TUR1:	TEXT ^/TUR1/
$$TUR2:	TEXT ^/TUR2/
$$LIGHT:	TEXT ^/LIGHT/
$$PLOT:	TEXT ^/PLOTTER/

TTYU:	TURUSE==.+NFTUR
	ZEPT NLTY,-1	;USER FOR EACH TTY
TIPTTY:	TBK	;FROM TILTTY
MXNUM==TIPTTY+1	;MXPR NUM LH, -1 IF NOT MPXED
TTYTP:	TBK	;TTY TYPE
OTTYST:	.BLKW NLTY
TTYST:	ZEPT NLTY,TIMAGE!TIMAGI	;TTY STATUS
	TICLKQ==100000	;ENTRY ON CLKQ
	TILIPM==40000	;LINE INPUT MODE
	TICVM==20000	;CONVERT CASE MODE
	TIECM==10000	;ECHO MODE (INPUT)
	TIEDM==4000	;EDIT MODE
	TIRBM==2000	;RUBOUT MODE
	TIMAGE==1000	;IMAGE MODE (OUTPUT)
	TIMAGI==400	;INPUT IMAGE MODE
	TOTRAN==200	;CURRENTLY TRANSMITTING
	TIQF==100	;QUOTE NEXT CHAR
	TIBR==40	;BREAK TYPED BUT NOT PROCESSED BY USER
	TIRST==20	;RESET INPUT ON INTERRUPT LEVEL
	PTBF==4
.IIF NZ DPHK,	DPF==10

TIRCV:	ZEPT NLTY,TYRCV	;ADDRESS TO JSR TO WITH RECEIVED CHARACTER

.IIF NZ AI,	TIQSZ==400.
.IIF NZ GUY,	TIQSZ==400.

	;INPUT BUFFER POINTERS
TIBSZ==10.
TIBN:	TBK
TIBI:	ZEPT NLTY,TIBB
TIBO:	ZEPT NLTY,TIBB

	;INPUT Q POINTERS
TTYAR:	TBK
TIQI:	ZEPT NLTY,TIQM	;PNTR TO WHERE NEXT CHAR GOES IN
TIQO:	ZEPT NLTY,TIQM	;PNTR TO WHERE NEXT CHAR COMES OUT
TIQTO:	ZEPT NLTY,TIQM	;PNTR TO WHERE TYO IS PROCESSING
TTYBBL==<<<TIQSZ+TOQSZ+TIBSZ>!77>+1>_-6
TTYDR==<<TTYBBL-1>_8>!6


TITQN:	TBK
TITQ==TIQM+TIQSZ-1

TIEQTN:	TBK
TIQTON:	TBK	;# OF CHARS FOR TYO TO PROCESS
TIQN:	TBK	;# OF CHARS IN INPUT Q
TIBC:	TBK	;# OF UNMATCHED ['S IN TYI BUFFER
MXNCH==TIQN	;DOUBLES AS IMX DEVICE Q

	;EDIT Q PNTRS
TIEQN:	TBK	;# OF CHARS IN EDIT Q
TIEBC:	TBK	;# OF UNMATCHED ['S FROM EDIT BUFFER

TIEQTO:	ZEPT NLTY,TITQ
TIEQO:	ZEPT NLTY,TITQ
TOTSR:	TBK	;ADDR OF TRANSMIT STATUS REGISTER
TOGOC:	ZEPT NLTY,TYGOC	;ADDR OF ROUTINE TO GET OUTPUT CHARS(MXGOC OR TYGOC)
	TOQSZ==100
	;OUTPUT QUEUE POINTERS
TOQI:	ZEPT NLTY,TOQM	;PNTR TO WHERE NEXT CHAR GOES IN
TOQO:	ZEPT NLTY,TOQM	;PNTR TO WHERE NEXT CHAR COMES OUT
TOQN:	TBK	;# OF CHARS IN Q
TOTN==TOQN

CHARNO:	TBK	;# OF CHARS FROM LEFT SIDE OF PAGE
TOPAD:	TBK	;# OF CHARS TO PAD

TOIPC:	TBK	;SAVED PC (FOR ECHO)
TOISVA:	TBK	;SAVED A

TOPC:	TBK	;SAVED PC (FOR OUTPUT)
TOSVC:	TBK	;SAVED C
TOSVD:	TBK	;SAVED D

DMMAX==3	;MAXIMUM # CHARS TO SEND TO EACH DM11 TELETYPE
DMBIT==.-NFDMTY
	ZEPT 20,1_.RPCNT
DMBUF==.-NFDMTY
	ZEPT 20,DMOBUF+<DMMAX*.RPCNT>	;PNTR TO DMOBUF
DHNUMBR==.-NFDMTY
	ZEPT 20,.RPCNT

DMOBUF:	.BLKB DMMAX*16.*NDM	;WHERE DM11 SENDS CHARS FROM
TTP:	0

MXICH==.-MXICMN	;DEVICE FOR EACH IDENTIFIER CHAR
	.BYTE 24,26,30,32
TBCCHR:	.WORD 117,112,105,40

TIANTM:	500.	;TIME TO WAIT FOR CARRIER BEFORE HANGING UP
;TIHGTM:	250.	;TIME TO HANG UP FOR
PURE==<.!17777>+1
.IIF LE PURE-20000,PURE=40000
PUREAR=KDAR+<PURE/10000>
PUREDR=KDDR+<PURE/10000>
	DISPAR=PUREAR+6
	DISPDR=PUREDR+6
	DISPPG==PURE+60000
	DISPAR=PUREAR+6
	DSLOT=DISPPG
	TEMPAR=DISPAR
	TEMPDR=DISPDR
	TEMPPG==DISPPG
TIQM==TEMPPG
TOQM==TIQM+TIQSZ
TIBB==TOQM+TOQSZ
TIQLM==TIQM+TIQSZ
TOQLM==TOQM+TOQSZ
TIBT==TIBB+TIBSZ
	.STITL TELETYPE CODE USER LEVEL
TTYP:	MOV USER,U
	MOV UTTY(U),E
	TST TIBN(E)	;ANY CHARACTERS YET?
	BNE .+6		;YES RETURN TRUE
	JMP RTFALS
	JMP RTTRUE

;CTYI--OUTPUTS (TO LOGO USER) CHAR FROM USERS TTY
CTYI:	MOV	USER,U
	MOV	UTTY(U),E
	BR	UGTYI2

;UGTYI-- TYI N OUTPUTS A CHAR FROM TTY N
UGTYI:	POPS	E	;DEVICE SPEC (NAME OR NUMBER)
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
	JSR	PC,OPEN1
	MOV	USER,U
	CMP	UTTY(U),E
	BNE	UGTYI1	;BR IF NOT USER'S CONSOLE
UGTYI2:	BIS	#TIMAGI,TTYST(E)	;IMAGE INPUT AND OUTPUT
	BIC	#TILIPM,TTYST(E)	;CHAR INPUT MODE
UGTYI1:	JSR	PC,GTYI	;GET CHAR IN D
	MOV	D,B
	JMP	R1NARG

;CTYO--PRINTS CHAR ON USERS TTY
CTYO:	JSR	PC,G1NARG	;B _ CHAR
	MOV	USER,U
	MOV	UTTY(U),E
	BR	TYO1

;UGTYO-- TYO N M SENDS CHAR M TO TTY N. N MAY BE NAME OR NUMBER.
UGTYO:	JSR	PC,G1NARG	;B _ CHAR
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
TYO1:	JSR	PC,OPEN1	;MAKE SURE TTY OK
	MOV	B,D	;CHAR
	BIT	#TIMAGE,TTYST(E)	;IS TTY IN IMAGE MODE?
	BNE	TYO2	;BR IF YES
	BIS	#200,D	;ELSE SPECIFICALLY IMAGE MODE THIS CHAR
TYO2:	JSR	PC,GTYO	;SEND IT
RTSPC:	SEZ
	RTS	PC

;MUTYO -- LIKE TYO, EXCEPT TO MUSIC BOX SPECIFICALLY
;ALSO TAKES VARIABLE ARGS, AND CONVERTS ARGS TO MUSIC BOX NOTES, ETC.
MUTYO:
	EXCH	(P),2(P)
	JSR	PC,REVS
	MOV	#MBDN,E
	JSR	PC,OPEN1
;LOOP,  PLACING EACH CHAR IN TYO BUFFER
	SPOP	C	;NUMBER OF ARGS
	BEQ	RTSPC	;0 ARGS (OH WELL)
MUTLP:	JSR	PC,G1NARG	;B _ CHAR
	MOV	B,A
	JSR	PC,SINGNO	;NORMALIZES MIDDLE C TO 0. CHECKS NOTE IN RANGE.
	MOV	A,D
	JSR	PC,GTYO
	SOB	C,MUTLP
	SEZ
	RTS	PC


;MUCTRL -- SENDS CONTROL TYPE INFO TO MUSIC BOX
MUCTRL:
	MOV	#MBDN,E
	JSR	PC,OPEN1
	JSR	PC,G1NARG	;B _ WHICH CONTROL FUNCTION
	MOV	B,D
	BLT	MUCERR	;NUMBER MUST BE BETWEEN 0,33
	CMP	D,#33.
	BLE	MUC1
MUCERR:	ERROR+WTIB	;INVALID MUSIC BOX CONTROL FUNCTION
;ARG IS DECODED AS FOLLOWS:
;	TOP DIGIT IS SILENCE CONTROL
;	BOTTOM DIGIT IS LOADING CONTROL
;	(NOTE -- BOTH DIGITS SHOULD BE BETWEEN 0,3)
MUC1:	CLR	C
	DIV	#10.,C	;C _ TENS, D _ ONES
	ASH	#4,C	;SHIFT INTO BITS 6,5
	BIC	#177774,D	;LEAVE ONLY BOTTOM 2 BITS
	BIS	C,D
	BIT	#40,D	;BIT 6 MUST NOT EQUAL BIT 7 (GROAN)
	BNE	MUC2	;BR IF BIT 6 = 1
	BIS	#100,D	;ELSE MAKE BIT 7 = 1
MUC2:	MOV	D,MUCWRD	;KEEP CONTROL WORD CURRENT
	JSR	PC,MUCTYO	;SENDS OUT TRAP CHAR, ETC. TOO
	SEZ
	RTS	PC

;CALL WITH CONTROL CHARACTER IN D.
;FIRST TYOS THE MUSIC BOX TRAP CHAR,
;THEN TYOS THE CHAR IN D
;	(NOTE THAT THIS ISN'T A PRIMITIVE)
MUCTYO:	SPUSH	D
	MOV	#MBTRAP,D	;HARDWARE CATCHES THIS
	SPUSH C
	MOV #PMBOX,C
	JSR PC,TBTYO
	SPOP C
	SPOP	D
	JSR	PC,GTYO
	RTS	PC

TBINIT:	SPUSH A
	SPUSH B
	SPUSH D
	SPUSH E
	SPUSH U
	MOV #NPTBOX,A
	MOV #PTBOX0,B
	TST C
	SXT U
	BPL TBINT1
	NEG C
TBINT1:	CMP USER,(B)+
	BEQ TBINT2
	ADD #4*2,B
	SOB A,TBINT1
	BR TBINSZ
TBINT2:	MOV #4,A
	SPUSH B
TBINT3:	CMPB C,(B)
	BEQ TBINT4
	TST (B)+
	SOB A,TBINT3
	SPOP B
TBINSZ:	SPOP U
	SPOP E
	SPOP D
	SPOP B
	SPOP A
	SEZ
	RTS PC
TBINT4:	TST U
	BMI TBINT5
	TST (B)
	BPL TBINT5
	SPOP B
	MOV USER,U
	MOV UTTY(U),E
TBINCZ:	SPOP U
	SPOP D
	SPOP D
	SPOP B
	SPOP A
	CLZ
	RTS PC
TBINT5:	MOV USER,U
	MOV UTTY(U),E
	SPUSH B
	MOV #21,B
	JSR PC,TYO1
	MOV (P),B
	SUB 2(P),B
	MOV TBCCHR(B),B
	JSR PC,TYO1
	SPOP B
	BIS #100000,(B)
	MOV (B),C
	BIC #TBMASK,C
	CMP C,#CONSO
	BNE TBINT6
	MOV OTTYST(E),TTYST(E)
	BIS #TIRST,TTYST(E)
	BR TBINT7	;DESTROY OLD USER
TBINT6:	BIS #TIMAGE,TTYST(E)
TBINT7:	SPOP C
	MOV #4,D
TBINT8:	TST (C)
	BGE TBINT9
	CMP C,B
	BEQ TBINT9	;DONT CLEAR THE ONE WE JUST SET
	BIC #100000,(C)
TBINT9:	TST (C)+
	SOB D,TBINT8
	BR TBINCZ



;UTYCK RETURNS IF VALID TTY, LOOSE OTHERWISE
UTYCK:	CMP	E,#2*NLTY
	BGE	UTYCL	;TOO HIGH TTY #
	BIT	#100001,E
	BNE	UTYCL	;BR IF TTY NEG OR ODD
	TST	TTYU(E)
	BLT	UTYCK1	;NOT IN USE
	CMP	TTYU(E),USER
	BNE	UTYCL1	;BR IF IN USE BY SOMEONE ELSE
UTYCK1:	RTS	PC

UTYCL:	ERROR+TDE	;NOT A VALID TTY #
UTYCL1:	ERROR+DIU	;DEVICE IN USE

MYSPEE:	MOV USER,U
	MOV UTTY(U),E
MYSPE1:	JSR PC,G1NARG
	BIT #TPDM,TYPTYP(E)
	BEQ UTYCL
	CMP #16,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASH #6,B
	MOV B,C
	ASH #4,B
	BIS B,C
	BIS #3,C
	SPL 7
	BIC #17,DH0SCR
	BIS DHNUMB(E),DH0SCR
	MOV C,DH0LPR
	SPL 0
	SEZ
	RTS PC
HISSPE:	JSR PC,CKSST
	JSR PC,G1NARG
	CMP #NLTY,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASL B
	MOV B,E
	BR MYSPE1
;DEVICE NUMBER FROM SPEC
;	CALL WITH POINTER TO EITHER NUMBER OR NAME IN E
;	RETURNS WITH TTY NUMBER IN E , OR ERROR+DNA IF INVALID NAME
DEVNUM:
	PUSH	A
	SPUSH	B
	MOV	#SNUM,A	;IS ARG A NUMBER?
	MOV	E,B
	JSR	PC,CONVERT
	BEQ	DNUM1	;BR IF NOT NUMBER
	MOV	B,E
	ASL	E
	BR	DNUM9

;NOT A NUMBER.  HOPEFULLY THE ARG IS A STRING
DNUM1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BEQ	DNUM8	;BR IF NOT STRING, EITHER
	MOV	B,E
	JSR	PC,DEVNAM
	BEQ	DNUM8	;BR IF NOT VALID NAME
DNUM9:	JMP	RETB	;POP A,B AND RETURN
DNUM8:	PUSHS	E	;POINTER TO THE INVALID NAME
	ERROR+DNA	;INVALID DEVICE NAME


;CALL WITH POINTER TO DEVICE NAME IN E
;RETURNS WITH DEVICE NUMBER IN E IF VALID, AND CLZ'S
DEVNAM:	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	SPUSH	#LDEVAR	;LOGICAL DEVICE NAME ARRAY
DNAM1:	MOV	@(P),C	;POINTER TO NEXT TEXT STRING
	BEQ	DNAM9	;BR IF NO MORE STRINGS
	MOV	4(P),B	;POINTER TO ARG
	JSR	PC,EQ.TXT
	BNE	DNAMEQ	;BR IF ARG = CURRENT TEXT STRING
	ADD	#4,(P)	;POINT TO NEXT STRING POINTER
	BR	DNAM1
DNAMEQ:	ADD	#2,(P)	;POINT TO TTY NUMBER FOR THIS DEVICE
	MOV	@(P)+,E
	BGE	DNAM2	;-1 IS FLAG FOR "TTY".  BR IF NOT "TTY"
	MOV	USER,E
	MOV	UTTY(E),E
DNAM2:	BIT	#1,E	;ODD MEANS THE DEVICE ISN'T ATTACHED
	BNE	DNAM9	;BR IF NOT ATTACHED
	SPOP	F	;RESTORE F
	TST	(P)+	;DON'T RESTORE E !!
	JMP	SRETD	;CLZ RETURN
;NO MORE STRINGS LEFT. IE ARG ISN'T VALID DEVICE NAME
DNAM9:	TST	(P)+	;POP OFF LDEVAR
	JMP	RETF	;RESTORE ALL AC'S AND SEZ RETURN



;OPEN--ASSIGNS TTY TO USER IF VALID TTY #
OPEN:	JSR	PC,G1NARG
	ASL B
	MOV	B,E
OPEN1:	JSR	PC,UTYCK	;RETURN IF VALID TTY
	MOV	USER,TTYU(E)	;ASSIGN TTY TO CURRENT USER
	RTS	PC


;CLOSE--CLOSES TTY IF USER HAS IT OPEN
CLOSE:	POPS	E
	JSR	PC,DEVNUM
	JSR	PC,UTYCK
CLOSE1:	MOV	USER,U
	CMP	E,UTTY(U)
	BEQ	.+10	;BR IF USER'S CONSOLE
CLOSE3:	MOV	#-1,TTYU(E)
	SEZ
CLOSE4:	RTS	PC

;LIKE CLOSE1, EXCEPT ONLY CLOSE IF THIS USER ALREADY HAS IT OPEN
CLOSE2:	CMP	USER,TTYU(E)
	BNE	CLOSE4
	BR	CLOSE3

;SLAM--CLOSES ALL USER TTYS BUT CONSOLE
SLAM:	MOV	#NLTY,A
	CLR	E
SLAM1:	CMP	TTYU(E),USER
	BNE	.+6	;BR IF USER DOESN'T OWN THIS TTY
	JSR	PC,CLOSE1
	TST	(E)+
	SOB	A,SLAM1
	RTS	PC


;TURN CASE CONVERSION ON AND OFF
CASESW:	JSR	PC,G1NARG
	TST	B
	BEQ	CASES1	;BR IF ARG=0
	JSR	PC,TICASE	;CONVERT LOWER TO UPPER CASE ON INPUT
	BR	CASES2
CASES1:	JSR	PC,TINCAS	;DON'T CONVERT CASE
CASES2:	SEZ
	RTS	PC

;TURN ECHOING ON AND OFF
ECHOSW:	JSR	PC,G1NARG
	TST	B
	BEQ	ECHOS1	;BR IF ARG=0
	JSR	PC,TIECH	;ECHO
	BR	CASES2
ECHOS1:	JSR	PC,TINECH	;TURN ECHO OFF
	BR	CASES2


			;I SPACE USER MODE
;GET A CHAR IN D FOR USER'S TTY
TTYI:	JSR	A,TYEUSV	;GET USER & TTY
	JSR	PC,TYIGC	;GET A CHARACTER
	TST	TIQN(E)
	BGT	.+10
	MOV #TIQM,TIQO(E)
	JSR	A,TYEURS	;RESTORE E&U
	RTS	PC

;GET A CHAR FOR TNM IN E
GTYI:	JSR	A,TYUSV	;GET USER IN U
	JSR	PC,TYIGC	;GET A CHAR
	JSR	A,TYURS	;RESTORE U
	RTS	PC

;GET A CHAR FOR TTY, DO RIGHT THING IF NONE AVAILABLE
TYIGC1:	BIT	#TILIPM,TTYST(E)
	BEQ	TYIGC2	;BR IF IN CHAR INPUT MODE
	MOV	TBKCHL,D	;RETURN BREAK CHARACTER
	RTS	PC
TYIGC2:	MOV	#FRTYIC,FLSRES(U)
	JSR	PC,FLUSH	;FLUSH USER WITH FLUSH REASON CHAR TYI WAIT
	TST	BRAKE(U)
	BNE	TYIGC3	;BR IF USER TRYING TO BREAK
	TST TIBN(E)
	BLE	TYIGC2
	JSR	PC,RUNME	;FLUSH REASON CLEARED BY INTERRUPT CODE?
TYIGC:	JSR	PC,TIOQ	;TRY TO GET CHAR FROM INPUT Q
	BEQ	TYIGC1	;BR IF NONE AVAILBLE
	RTS	PC

TYIGC3:	JSR	PC,RUNME
	RTS	PC


;SLINE
;START LINE INPUT
SLINE:	JSR	A,TYEUSV
	BIC	#TIMAGI!TIMAGE!TIRBM!TIQF,TTYST(E)	;CLR MISC FLAGS
	BIS	#TILIPM!TIRST,TTYST(E)	;LINE INPUT MODE, INPUT RESET
	JSR	A,TYEURS
	RTS	PC
			;I SPACE USER MODE

;PUT CHAR IN D INTO USER'S TTY'S OUTPUT BUFFER
TTYO:	JSR	A,TYEUSV	;GET USER & TTY
	BIT #PTBF,TTYST(E)
	BNE TTYO1
	JSR	PC,GTYO	;SEND CHAR
TTYO2:	JSR	A,TYEURS
	RTS	PC

TTYO1:	SPUSH C
	MOV #CONSO,C
	JSR PC,TBTYO
	SPOP C
	BR TTYO2


;PUT CHAR IN D INTO TTY IN E'S BUFFER
TBTYO:
	JSR PC,TBINIT
GTYO:	JSR	A,TYUSV	;GET USER IN U
	TST	TOPC(E)
	BEQ	GTYO3	;BR IF OUTPUT BUFFER NOT FULL
GTYO2:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH	;KEEP FLUSHING TILL ROOM IN OUTPUT Q
	TST	BRAKE(U)	;USER TRYING TO BREAK?
	BNE	GTYO5
	TST	TOPC(E)
	BNE	GTYO2
	JSR	PC,RUNME
GTYO3:	PUSH	C
	JSR	PC,TOTYO	;PUT CHARACTER IN Q
	POP	C
	JSR	PC,TOCINT	;CAUSE OUTPUT INTERRUPT IF NONE PENDING
GTYO4:	JSR	A,TYURS	;RESTORE U
	RTS	PC

GTYO5:	JSR	PC,RUNME
	BR	GTYO4

;SEND CHAR TO MULTIPLEXEE AND WAIT UNTILL IT SENDS CHAR BACK
;RETURN THAT CHAR IN D
MXWT: TBTW:	PUSH	A
	SPUSH	D
	SPUSH	U
	MOV #TIQSZ,A
	MOV	USER,U
MXWT1:	TST	BRAKE(U)
	BNE	MXWT5
	JSR	PC,TIOQ	;EMPTY TURTLE'S INPUT Q (CLOBBERS D)
	BEQ	MXWT2	;Q EMPTY
	SOB	A,MXWT1
	ERROR+HARD	;JUST GOT 200 CHARS OUT OF Q!! RUNNING OPEN?
MXWT2:	MOV	E,D
	MOVB	MXNUM(D),E	;GET MULTIPLEXOR NUMBER
	JSR	PC,MXQLAD	;ADD THIS TTY TO END OF MULTIPLEXOR'S QUEUE
	BEQ	MXWT6	;Q FULL
		;MAKE SURE HE CAN'T BREAK FROM TYO NOW THAT MPXR EXPECTS CHAR
	MOV	D,E
	TST	TOPC(E)
	BEQ	MXWT4
MXWT3:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH
	TST	TOPC(E)
	BNE	MXWT3	;OUTPUT Q STILL FULL
	JSR	PC,RUNME
MXWT4:	POP	U
	SPOP	D
	SPOP	A
	JSR	PC,GTYO	;SEND CHAR
	JSR	PC,GTYI	;GET CHAR BACK
MXWT5:	RTS	PC

MXWT6:	ERROR+TGDZ
			;I SPACE USER MODE

;START SENDING CHARACTERS TO EDIT BUFFER
EDITA:	JSR	A,TYEUSV
	JSR	PC,TYERT	;RESET EDIT BUFFER
	BR	ETYO1

;END SENDING CHARS TO EDIT BUFFER
EDITE:	JSR A,TYEUSV
	JSR PC,FIXBUF
	BIS	#TIEDM,TTYST(E)
	BR	ETYO1

;PUT CHARACTER IN EDIT BUFFER

ETYO:	JSR A,TYEUSV
	CMP TITQN(E),#TIQSZ
	BGE ETYO1
	JSR F,TTYMPI
	MOVB D,@TIQI(E)
	JSR F,TTYMPO
	INC TIEQN(E)
	INC TIQI(E)
	INC TITQN(E)
ETYO1:	JSR A,TYEURS
	RTS PC

FIXBUF:	JSR F,TTYMPI
	MOV TIEQN(E),C
	MOV TIQI(E),A
	MOV #TITQ,B
FXLOOP:	MOVB -(A),-(B)
	DEC TIQI(E)
	DEC TIEQO(E)
	SOB C,FXLOOP
	JSR F,TTYMPO
	RTS PC

				;I SPACE USER MODE

;TURN ON ECHO MODE
TIECH:	JSR	A,TYEUSV
	BIS	#TIECM,TTYST(E)
TIECH1:	JSR	A,TYEURS
	RTS	PC
;TURN OFF ECHO MODE
TINECH:	JSR	A,TYEUSV
	BIC	#TIECM,TTYST(E)
	BR	TIECH1

;TURN ON CASE SWITCH
TICASE:	JSR	A,TYEUSV
	BIS	#TICVM,TTYST(E)
	BR	TIECH1
;TURN OFF CASE SWITCH
TINCAS:	JSR	A,TYEUSV
	BIC	#TICVM,TTYST(E)
	BR	TIECH1


;BREAK HAS BEEN PROCESSED ON USER LEVEL,
;OK TO ACCEPT CHARS AGAIN
BRAKR:	JSR	A,TYEUSV
	JSR	PC,TTYRT
;	BIS	#TIRST,TTYST(E)	;TELL INT ROUTINES TO RESET BUFFERS
;	JSR	PC,TOCINT	;CAUSE INTERRUPT
	BIC	#TIBR,TTYST(E)
	BR	TIECH1

;INTIALIZE USER CONSOLE
UCINIT:	SPUSH	A
	MOV	TYCKBP(E),A
	JSR	PC,CLKQDL	;DELETE ANY CLOCK QUEUE ENTRY
	BIC	#TICLKQ!TIMAGE!TIMAGI,TTYST(E)	;PUT INTO ASCII MODE
	BIS	#TILIPM!TIECM!TICVM,TTYST(E)	;LINE INPUT, CONVERT CASE, ECHO
	SPOP	A
	RTS	PC
			;I SPACE USER MODE
;SAVE U, GET USER INTO U, CALL WITH JSR A
TYUSV:	PUSH	U
	MOV	USER,U
	JMP	(A)
;RESTORE U
TYURS:	TST	(P)+	;THIS POPS A SAVED WITH JSR A CALL
	POP	U
	RTS	A	;RESTORING A SAVED BY CALL TO TYUSV

;GET USER IN U, HIS TTY IN E, SAVE BOTH
TYEUSV:	PUSH	U
	SPUSH	E
	MOV	USER,U
	MOV	UTTY(U),E
	JMP	(A)
;RESTORE
TYEURS:	TST	(P)+
	POP	E
	SPOP	U
	RTS	A
.STITL TELETYPE INPUT INTERRUPT ROUTINES

;BREAK VECTORS POINT TO THESE RECEIVE INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TKBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENRBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,RK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENRBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,RK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;	.ENDC
;>>
;.ENDM

DC0RK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENRBK
DC1RK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENRBK

.IFNZ	NTY+NKLTY+NDCTY+NDPTY
;GENRBK--
;GENERAL RECEIVE BREAK FOR TTYS, TBOXS, ETC.
;CALLED WITH	SPUSH A
;		MOV #TTY INDEX,A
;		JMP GENBRK

GENRBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;TTY
	MOV	TYRS(A),U	;RG ADR
	MOV	(U),D	;RG CONTENTS
	BIT	#%ER,D
	BNE	TGENER	;BR IF ERROR BIT ON
	TST	E
	BMI	GENRB1	;BR IF NOT LOGICAL TTY
	MOV	2(U),D	;CHARACTER
	BIC	#177600,D	;ONLY 7 BITS
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS PHYSICAL DEV.
GENRB1:	JSR	U,ACRES
	SPOP	A
	RTT

TGENER:	JSR	PC,GENER
	BR	GENRB1

;A PNTS TO BLK
;D REG CONTENTS
;U BUF ADDR
GENER:
.IFG	NMODEM
	TST	E
	BMI	GENER5
	BIT	#TPMODM,TTYTP(E)
	BNE	GENER2	;BR IF MODEM
GENER5:
.ENDC
	JSR	PC,DEVER	;PRINT ERROR MESSAGE
	BR	GENER4
.IFG	NMODEM
GENER2:	MOV	TYCKBP(E),A
	BIT	#TICLKQ,TTYST(E)
	BEQ	GENER1
	JSR	PC,CLKQDL	;DELETE ANY PRESENT CLKQ ENTRY
	BIC	#TICLKQ,TTYST(E)
GENER1:	BIS	#%DTRDY,(U)
	BIT	#%CRDT,D
	BNE	GENER4
	JSR	PC,TISANS	;TRY TO HANG UP
.ENDC
GENER4:	CMP	(U)+,(U)
	RTS	PC

;;!!! CHANGE SYS CONSOLE PRINOUT HACK
DEVER:	JSR	A,SPRINT
	BPRTXT	^\DEV ERR \
	JSR	PC,PGEN1
	SPREND
	RTS	PC

PGEN1:	MOV	U,A
	JSR	PC,PRON		;REGISTER ADDR
	PRTXT	^\/  \
	MOV	D,A
	JSR	PC,PRON		;REG CONTENTS
	PRCR
	RTS	PC

.IFG NMODEM
;TISHNG:	;ASSERT DATA TERM RDY IN TIHGTM TICKS
;	MOV	#TIHGTM,(A)
;	MOV	#TIUNHG,4(A)
;	BR	TICKLA

TISANS:	MOV	#TIANTM,(A)	;IF NO CARRIER IN TIANTM TICKS, HANG UP
	MOV	#TIANS,4(A)

TICLKA:	JSR	PC,CLKQAD
	BIS	#TICLKQ,TTYST(E)
	RTS	PC

TIANS:	JSR	B,TICKS
	BIT	#%CRDT,@U
	BNE	TIANS1
	BIC	#%DTRDY,@U
;	JSR	PC,TISHNG
TIANS1:	SPOP	U
	SPOP	E
	SPOP	B
	RTS	PC


;---FOLLOWING RUN AT CLOCK BREAK LEVEL---

TICKS:	SPUSH	E	;TICLKQ START
	SPUSH	U
	MOV	6(A),E		;TTY
	BIT	#TICLKQ,TTYST(E)
	BEQ	TICKS1
	BIC	#TICLKQ,TTYST(E)
	JMP	(B)

TICKS1:	BPT	;HOW DID THIS GET ON CLOCK Q?
	BR	TIANS1

;TIUNHG:	JSR	B,TICKS
;	BIS	#%DTRDY,@U	;TURN DATA TERM RDY ON
;	BR	TIANS1

;	TIANTM AND ;TIHGTM HAVE BEEN MOVED
;	TO THE START OF TYI WITH THE BUFFERS

.ENDC
.ENDC
.IFZ DHON
.IFG NDMTY
DM0RK:	BIC	#200,DM0CSR	;CLEAR DONE BIT
	JSR U,ACSAV	;SAVE ACS
	MOV #DMTT+200,B	;BOTTOM OF TUMBLE TABLE
	MOV #TTP,C	;TUMBLE TABLE POINTER
	;BR DMRK

;DM11 RECEIVE INTERRUPT
DMRK:	BR	DMRK3

DMRK1:	BIC	#120200,@(C)	;CLR CHAR RCVD, PARITY, AND UNUSED BITS
	BIT	#40000,@(C)
	BNE	DMRK2	;BR IF NO STOP RECEIVED
	MOV	(C),E
	MOVB	1(E),E	;GET LINE #
	ADD	#NFDMTY,E	;GET PHYSICAL TTY NUMBER
	MOVB	TILTTY(E),E	;GET LOGICAL NUMBER
	BMI	DMRK2	;BR IF ILLOGICAL
	MOVB	@(C),D	;CHARACTER
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS TTY
DMRK2:	ADD	#2,(C)	;INCREMENT POINTER
	CMP	@C,B
	BLO	DMRK3	;BR IF NOT PAST END OF TABLE
	MOV	B,@C	;RESET POINTER
	SUB	#200,@C
DMRK3:	TST	@(C)
	BMI	DMRK1	;BR IF MORE CHARACTERS
	JSR	U,ACRES	;RESTORE AC'S
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0RK:	JSR U,ACSAV
DM0RK2:	MOV DH0NRC,C	;GET THE CHARACTER
	BGE DM0RK3	;NO CHARACTER
	BIC #110200,C	;CLEAR SILLY BITS
	BIT #60000,C	;IS IT A BREAK?
	BEQ DM0RK1	;NOPE
	BIC #60377,C	;CLEAR CHARACTER AND BREAK BITS
	ADD #7,C	;BREAK
DM0RK1:	MOV C,E		;COPY IT
	SWAB E		;GET LINE NUMBER
	BIC #177760,E	;FLUSH CRAP
	ASL E
	MOVB TILTTY+NFDMTY(E),E	;GET LOGICAL NUMBER
	BMI DM0RK2	;ILLOGICAL
	MOV C,D		;COPY AGAIN
	BIC #177600,D	;JUST THE CHARACTER
	BIT #TIRST,TTYST(E)	;RESET INPUT?
	BEQ .+6
	JSR PC,TYIRT1	;GO RESET IT
	JSR PC,@TIRCV(E)	;GOBBLE CHARACTER INTO BUFFER
	BR DM0RK2		;ANY MORE?
DM0RK3:	JSR U,ACRES
	RTT
.ENDC
.ENDC

;MULTIPLEXOR RECIEVE INTERRUPT
MXRCV:	SPUSH	E
	CMP	D,#'_
	BGT	MXRCV3	;BR IF LOWER CASE
	JSR	PC,MXGTY	;GET INDEX OF LOG DEV THIS CHAR BELONGS TO
	BEQ	MXRCV1	;FAIL, THIS CHAR DOESN'T BELONG TO ANYONE
	JSR PC,TYRCV1
	BR MXRCV1

MXICMN==140
MXICMX==137
MXRCV3:	;CHAR IS LOWER CASE, IDENTIFIES WHERE NEXT CHAR COMES FROM
	CMP	D,#MXICMN	;SMALLEST LEGAL IDENTIFIER
	BLT	MXRCV1
	CMP	D,#MXICMX	;LARGEST LEGAL IDENTIFIER
	BGT	MXRCV1
	MOVB	MXICH(D),E	;GET INDEX OF DEVICE
	JSR	PC,MXQTAD	;ADD TO TOP OF QUEUE
MXRCV1:	SPOP E
MXRCV2:	SEZ
	RTS PC


MXGTY:	;GETS TTY # OF NEXT LOG. DEV. IN MX Q, UPDATES Q,
	;FAILS IF NOTHING IN QUEUE
	TST	MXNCH(E)
	BLE	MXRCV2	;Q EMPTY, FAIL
	SPUSH	D
	JSR F,TTYMPI
	MOV #TIQM,D
	MOVB	(D)+,-(P)	;PUSH INDEX OF FIRST DEV ON Q
MXGTY1:	MOVB	(D)+,-2(D)	;MOVE REST OF Q UP ONE BYTE
	CMP D,#TIQLM
	BLO	MXGTY1
	DEC	MXNCH(E)
	MOVB	(P)+,E		;POP DESIRED INDEX
	JSR F,TTYMPO
	SPOP	D
	CLZ
	RTS PC


;ADD CHAR IN D TO TOP OF MX INPUT Q
MXQTAD:
	CMP TIQN(E),#TIQSZ
	BGE	MXRCV2
	SPUSH	A
	JSR F,TTYMPI
	MOV	MXNCH(E),A
	ADD #TIQLM,A
MXQTA1:	MOVB	(A)+,(A)	;MOVE ENTIRE Q DOWN ONE
	SUB	#2,A
	CMP A,#TIQLM
	BHIS	MXQTA1
	INC	MXNCH(E)
	MOVB D,@TIQI(E)
	JSR F,TTYMPI
	SPOP	A
	CLZ
	RTS PC

;ADD CHAR IN D TO BOTTOM OF MX Q
MXQLAD:
	CMP TIQN(E),#TIQSZ
	BGE	MXRCV2
	SPUSH	A
	MOV #TIQM,A
	JSR F,TTYMPI
	ADD	MXNCH(E),A
	MOVB	D,(A)
	INC	MXNCH(E)
	JSR F,TTYMPO
	SPOP	A
	CLZ
	RTS PC
.STITL TYPEIN--INTERRUPT LEVEL
;TELETYPE RECIEVE
;PROCESS CHAR IN D FOR TTY IN E
;CAN CLOBBER A,U

TYRCV:	BIT #TILIPM,TTYST(E)
	BEQ TYRCV1
	MOV TTYU(E),U
	BLT TYRCV1
	CMP D,#7
	BEQ TYRCV2
	CMP D,#32
	BEQ TYRCV3
TYRCV1:	CMP #TIBSZ,TIBN(E)
	BEQ TYRET
	JSR F,TTYMPI
	MOVB D,@TIBI(E)
	JSR F,TTYMPO
	INC TIBN(E)
	INC TIBI(E)
	CMP #TIBT,TIBI(E)
	BHI TYRET
	MOV #TIBB,TIBI(E)
TYRET:	RTS PC
TYRCV2:	JMP TICG
TYRCV3:	JMP TICZ

TICP:	SPUSH B
	BIT #TIRST,TTYST(E)
	BEQ .+6
	JSR PC,TYIRT1
	JSR F,TTYMPI
	MOV TTYU(E),U
	CMP #FRLINW,FLSRES(U)
	BNE TICP5
TICPLT:	CMP #TIBT,TIBO(E)
	BHI TICP7
	MOV #TIBB,TIBO(E)
TICP7:	MOVB @TIBO(E),D
	INC TIBO(E)
	DEC TIBN(E)
	BIT #TIQF,TTYST(E)
	BEQ TICP4
	BIC #TIQF,TTYST(E)
	BIS #200,D
	BR TICP3
TICP4:	BITB #FSF,DTBL(D)
	BEQ TICP3
	MOVB DTBL2(D),C
	JSR PC,@TIICTB(C)
	BEQ TICPLB
TICP3:	JSR PC,TYINQ
	BEQ TICPRT
TICPLB:	TST TIBN(E)
	BNE TICPLT
TICPRT:	JSR PC,TOCINT
TICP5:	JSR F,TTYMPO
	SPOP B
	RTS PC


;PUT CHAR IN D INTO CONSOLE IN E'S INPUT BUFFER
TYINQ:	BIT	#TICVM,TTYST(E)
	BEQ	TIINQ	;BR IF NOT CONVERTING LOWER TO UPPER CASE
	JSR	PC,TICVLU	;CONVERT
;PUT CHAR IN D INTO TTY IN E'S INPUT BUFFER
TIINQ:
	CMP TIQN(E),#TIQSZ
	BGE	TIINQ1	;BR IF BUFFER FULL
	JSR F,TTYMPI
	MOVB	D,@TIQI(E)	;PUT CHAR IN
	JSR F,TTYMPO
	INC	TIQI(E)	;INC POINTER
	INC	TIQN(E)	;INC COUNTER
	INC	TIQTON(E)	;INC OUTPUT LEVEL COUNTER
	INC TITQN(E)
	CLZ
	RTS PC

TIINQ1:	SEZ
	RTS	PC

;*****TIOQ RUNS AT USER LEVEL ALSO******
;GET A CHAR FROM INPUT QUEUE

TIOQ:	BIT #TILIPM,TTYST(E)
	BNE TIOQ1
	TST TIBN(E)
	BLE TIINQ1
	CMP #TIBT,TIBO(E)
	BHI TIBORT
	MOV #TIBB,TIBO(E)
TIBORT:	JSR F,TTYMPI
	MOVB @TIBO(E),D
	JSR F,TTYMPO
	BIC #177400,D
	INC TIBO(E)
	DEC TIBN(E)
	BIT #TIECM,TTYST(E)
	BEQ TIBRET
	JSR PC,TOTYO
	JSR PC,TOCINT
TIBRET:	CLZ
	RTS PC

TIOQ1:	TST TIEQTN(E)
	BLE TIINQ1
	JSR F,TTYMPI
	MOVB @TIEQTO(E),D
	BIC #177400,D
	JSR F,TTYMPO
	INC TIEQTO(E)
	DEC TIEQTN(E)
	CLZ
	RTS PC



;IF CHAR IN D IS LOWER CASE, CONVERT TO UPPER
TICVLU:	TSTB	D
	BMI	TICVL1	;BR IF QUOTED
	CMP	D,#'_
	BLE	TICVL1	;BR IF UPPER CASE
	CMP	D,#177
	BEQ	TICVL1	;DON'T CASE RUBOUT
	SUB	#40,D
TICVL1:	RTS	PC


;QUOTE NEXT CHAR
TICQ:	BIT	#TIQF,TTYST(E)
	BNE	TICQ1	;BR IF ^Q WAS PREVIOUS CHAR
	BIS	#TIQF,TTYST(E)
	RTS	PC
TICQ1:	BIC	#TIQF,TTYST(E)
	RTS	PC

;RESET TTY
TTYRT:TBREST:	JSR	PC,TYORT	;RESET TYO STUFF
	JSR	PC,TYIRT	;RESET TYI STUFF
	JSR PC,TYBRT
	RTS	PC

;RESET TYPEOUT PNTRS
TYORT:	SPUSH F
	MOVB MXNUM(E),F
	BMI TYORT1
	SUB TOQN(E),TOQN(F)
TYORT1:	SPOP F
	CLR	TOQN(E)
	MOV #TOQM,TOQI(E)
	MOV #TOQM,TOQO(E)
	CLR	TOPC(E)
	CLR	TOIPC(E)
	BIT #PTBF,TTYST(E)
	BNE .+4
	RTS PC
	SPUSH C
	MOV #-CONSO,C
	SPUSH PS
	SPL 7
	JSR PC,TBINIT
	SPOP PS
	SPOP C
	RTS	PC

;*** TYIRT RUNS AT USER LEVEL ALSO ***
;RESET INPUT PNTRS
TYIRT:	BIC	#TIEDM!TIQF!TIRBM,TTYST(E)	;CLR MISC FLAGS
TYIRT1:	BIC	#TIRST,TTYST(E)	;RESET FLAG
	CLR	TIQTON(E)
	CLR	TIQN(E)
	MOV #TIQM,TIQI(E)
	MOV #TIQM,TIQO(E)
	MOV #TIQM,TIQTO(E)
	MOV TIEQN(E),TITQN(E)
	CLR	TIBC(E)
	RTS	PC

;RESET EDIT PNTRS
TYERT:	CLR	TIEQN(E)
	MOV #TITQ,TIEQO(E)
	MOV TIQN(E),TITQN(E)
	RTS	PC

TYBRT:	CLR TIBN(E)
	MOV #TIBB,TIBO(E)
	MOV #TIBB,TIBI(E)
	RTS PC

;BREAK TO LEVEL 0
TICG:	MOV	#1,BRAKE(U)	;SET USER BREAK FLAG
	BR	TIBRK
;BREAK TO LEVEL N
TICZ:	MOV	#-1,BRAKE(U)

;BREAK TO LEVEL 0 OR N
;CALL WITH CONTENTS OF BRAKE IN (P)
TIBRK:	BIS	#TIBR,TTYST(E)
	JSR	PC,TTYRT	;RESET INPUT
	CMP	#FRLINW,FLSRES(U)
	BEQ	TIBRK1	;BR IF FLUSHED WAITING FOR LINE
	BIT	#FRBKBT,FLSRES(U)	;SHOULD I UNHANG HIM ANYHOW?
	BEQ	TIBRK2	;BR IF NO
TIBRK1:	CLR	FLSRES(U)	;UNFLUSH
TIBRK2:	RTS	PC

;INTERRUPT LEVEL BREAKPOINT
;CLOBBER ATICZ/  TIIBPT
TIIBPT:	TST	(P)+
	BPT	
	RTS	PC

;REPLACE ^B WITH %
TICB:	MOV #'%,D
	RTS PC


;*** USER AND INTERRUPT LEVEL ***

;IF NOT TRANSMITTING, CAUSE OUTPUT INTERRUPT
TOCINT:	SPUSH	E
TOCIN4:	BIT	#TPPTY,TTYTP(E)
	BNE	TOCIN3
	BIT	#TOTRAN,TTYST(E)
	BNE	TOCIN2	;BR IF TRANSMITTING
.IFG NDMTY
	BIT	#TPDM,TTYTP(E)
	BEQ	TOCIN1	;BR IF NOT A DM11 TTY
	BIS	#100000,@TOTSR(E)	;SET TRANS INT BIT
	BR	TOCIN2
TOCIN1:
.ENDC
	BIC	#100,@TOTSR(E)	;CLEAR AND SET INTERRUPT ENABLE
	BIS	#100,@TOTSR(E)
TOCIN2:	SPOP	E
	RTS	PC

TOCIN3:	MOVB	MXNUM(E),E
	BR	TOCIN4

.STITL TYPE OUT--INTERRUPT LEVEL

;BREAK VECTORS POINT TO THESE TRANSMIT INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TPBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENTBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,TK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENTBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,TK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;		JMP GENTBK
;	.ENDC
;>>
;.ENDM

DC0TK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENTBK
DC1TK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENTBK

.IFZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DM0CSR,U	;STATUS REGISTER
	MOV #NFDMTY,A	;# OF FIRST TTY
	BR DMTK

;DM11 TRANSMIT BREAK
DMTK:	MOV	(U),D	;REGISTER CONTENTS
	BIT	#60000,D
	BEQ	.+6	;BR IF NO ERRORS
	JSR	PC,DEVER	;PRINT ERRORS ON SYSTEM CONSOLE
	BIC	#160000,(U)	;CLEAR ERROR &TRANS INTERRUPT BITS
	MOV	U,B
	ADD	#2,B	;ADDR OF BUFFER ACTIVE REGISTER
	MOV	A,U	;# OF FIRST TTY
	MOV	#1,A	;BIT FOR LINE BUFFER ACTIVE REGISTER
DMTK2:	BIT	A,(B)
	BNE	DMTK3	;BR IF THIS LINE TRANSMITTING
	MOVB	TILTTY(U),E	;LOGICAL TTY #
	BMI	DMTK3	;BR IF ILLOGICAL
	SPUSH	A
	JSR	PC,TYXMT	;TRANSMIT
	SPOP	A
DMTK3:	TST	(U)+	;INC TTY
	ASL	A	;SHIFT BAR BIT
	BNE	DMTK2	;BR IF MORE TTYS TO CHECK
	JSR	U,ACRES
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DH0SCR,U
	MOV #NFDMTY,A
	MOV (U),D	;GET STATUS OF DH11
	BIT #42000,D	;ANYTHING BAD?
	BEQ .+6		;NOPE
	JSR PC,DEVER	;TELL THE WORLD
	INCB 1(U)	;RESET NXM
	BIC #100000,(U)	;RESET DONE
	MOV U,B
	ADD #12,B	;GET BAR ADDRESS
	MOV A,U
	MOV #1,A
DMTK2:	BIT A,(B)	;THAT LINE TRANSMITING?
	BNE DMTK3	;YES
	MOVB TILTTY(U),E	;GET LOGICAL NUMBER
	BMI DMTK3	;ILLOGICAL
	SPUSH A
	JSR PC,TYXMT	;SEND ANYTHING YOU GOT
	SPOP A
DMTK3:	TST (U)+	;NEXT LINE
	ASL A		;NEXT BAR BIT
	BNE DMTK2	;OUT OF LINES?
	JSR U,ACRES
	RTT
.ENDC
.ENDC

;GENERAL TRANSMIT BREAK
GENTBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;GET LOGICAL TTY #
	BMI	GENTB2	;BR IF ILLOGICAL
	MOV	TOTSR(E),B
	MOV	@B,D	;STATUS REG CONTENTS
	BIT	#%RDY,D
	BEQ	GENTB2	;BR IF NOT RDY, SPURIOUS INTERRUPT
GENTB1:	JSR	PC,TYXMT	;TRANSMIT INT ROUTINE
GENTB2:	JSR	U,ACRES
	SPOP	A
	RTT

;GET NEXT MULTIPLEXOR OUTPUT CHARACTER
;SKIP ONE WORD IF SUCESSFULL
MXGOC:	TST	TOQN(E)
	BLE	MXGOC4	;BR IF NO CHARS TO SEND
	CMP TOQO(E),#TOQM+4
	BLO	.+10	;BR IF OUTPUT PNTR NOT PAST END OF QUEUE
	MOV #TOQM,TOQO(E)
	SPUSH	E
	JSR F,TTYMPI
	MOVB	@TOQO(E),E	;GET NEXT TTY TO SEND STUFF FOR
	JSR F,TTYMPO
	JSR	PC,TOSOP	;START OUTPUT
	BR	.+2	;OUTPUT Q FULL
	JSR	PC,@TOGOC(E)	;GET OUTPUT CHAR
	BR	MXGOC3	;NO CHARS
	SPOP	E
	DEC	TOQN(E)	;DECREMENT MPXRS CHAR COUNT
	BR	.+4
MXGOC1:	SPOP	E
	INC	TOQO(E)	;INC MULTIPLEXOR'S POINTER
MXGOC5:	ADD	#2,@P	;SKIP RETURN
MXGOC2:	RTS	PC

;MULTIPLEXOR HAS CHARS TO SEND, BUT CURRENT MULTIPLEXEE DOESN'T
MXGOC3:	MOVB	OMXNUL(E),D	;RETURN NULL CHAR FOR MULTIPLEXEE
	BR	MXGOC1


;NO CHARACTERS FOR MULTIPLEXOR
MXGOC4:
	CMP TOQO(E),#TOQM
	BEQ MXGOC2
	MOV #TOQM,TOQO(E)
	MOVB	OMXRES(E),D	;SEND MULTIPLEXOR RESET CHARACTER
	BR	MXGOC5

;GET NEXT TTY OUTPUT CHARACTER
;SKIP ONE WD IF SUCCESSFUL
TYGOC:	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC1	;BR IF IN IMAGE MODE (DON'T PAD)
	TSTB	TOPAD(E)
	BGE	TYGOC4	;BR IF SOME PADDING LEFT
TYGOC1:	JSR	PC,TOOQ	;GET CHAR FROM OUTPUT BUFFER
	BR	TYGOC3	;BR IF BUFFER EMPTY
	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC2	;BR IF IN IMAGE MODE
	CMP	D,#15
	BNE	TYGOC2
	MOVB	TTYTP(E),TOPAD(E)	;IF CR, SET UP PADDING
TYGOC2:	ADD	#2,@P	;SKIP RETURN
TYGOC3:	RTS	PC
;SEND PADDING CHAR INSTEAD OF NEXT CHAR FROM QUEUE
TYGOC4:	CLR	D
	DECB	TOPAD(E)	;DEC # OF PADS
	BR	TYGOC2


;REMOVE CHAR FROM CIRCULAR OUTPUT QUEUE AND RETURN IT IN D
;SKIP ONE WORD IF SUCCESSFUL
TOOQ:	TST	TOQN(E)
	BLE	TOOQ2	;BR IF NOTHING IN Q
	JSR F,TTYMPI
	CMP TOQO(E),#TOQLM
	BLO TOOQ1
	MOV #TOQM,TOQO(E)
TOOQ1:	MOVB	@TOQO(E),D	;GET CHAR
	JSR F,TTYMPO
	INC	TOQO(E)	;INC PNTR
	DEC	TOQN(E)	;DEC CHARACTER COUNT
	ADD	#2,@P	;SKIP RETURN
TOOQ2:	RTS	PC

;TTY TRANSMIT INTERRUPT
;FIRST SEND CHARS IN OUTPUT Q
;THEN PROCESS CHARS IN INPUT Q
;CAN CLOBBER A&C
TYXMT:	BIC	#TOTRAN,TTYST(E)	;CLEAR XMT INT PENDING BIT
	BIT	#TIBR,TTYST(E)
	BNE	TYXMT4	;BR IF BREAKING
	JSR	PC,TOSOP	;START OUTPUT
	BR	TYXMT3	;OUTPUT BUFFER FILLED AGAIN
TYXMT1:	JSR	PC,TOPIC	;PROCESS CHARS FROM INPUT BUFFER
TYXMT3:		;ACTUALLY SEND CHARACTERS!!!
.IFG	NDMTY
	BIT	#TPDM,TTYTP(E)
	BNE	TYXMT5	;BR IF DM11 TTY
.ENDC
	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHAR
	BR	TYXMT4	;NONE
	MOV	D,2(B)	;PUT CHAR IN DEVICES OUTPUT BUFFER
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
TYXMT4:	RTS PC

;START OUTPUT
;SKIP RETURN IF OUTPUT BUFFER NOT FULL
TOSOP:
	CMP TOQN(E),#TOQSZ
	BGE	TOSOP2	;BR IF Q FULL
	TST	TOPC(E)	;DID WE EXIT FROM MIDDLE OF PROCESSING CHAR TO OUTPUT Q
	BEQ	TOSOP1	;BR IF NO
	MOV	TOSVC(E),C	;RESTORE MISC AC'S
	MOV	TOSVD(E),D
	SPUSH	TOPC(E)	;LOCATION TO JSR TO
	CLR	TOPC(E)
	JSR	PC,@(P)+	;CALL AS COROUTINE
	BR	TOSOP2	;OUTPUT Q FILLED AGAIN
TOSOP1:	ADD	#2,@P	;SKIP RETURN
TOSOP2:	RTS	PC


.IFG NDMTY
TYXMT5:	JSR	PC,DMSND	;TRANSMIT CHARS TO DM TTY
	RTS	PC

;TRANSMIT CHARS TO DM11 TTY
DMSND:	JSR	F,ACSAV
	CLR	A	;-WD CNT
	MOVB	TILTTY(E),U	;PHYSICAL TTY #
	MOV	DMBUF(U),B	;WHERE CHARS ACTUALLY SENT FROM
.IFZ DHON
	MOV	B,DMCA(U)
.IFF
	BIC #17,DH0SCR
	BIS DHNUMB(U),DH0SCR	;SET LINE NUMBER
	MOV B,DH0CAR	;SET THE ADDRESS
.ENDC
	MOV	#DMMAX,C	;MAX NUM OF CHARS TO SEND
DMSND1:	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHARACTER
	BR	DMSND2	;RETURN HERE IF NO CHARS
	MOVB	D,(B)+	;PUT CHAR IN BUFFER
	DEC	A	;-WD CNT
	DEC	C	;MAX NUM OF CHARS TO SEND
	BGT	DMSND1
DMSND2:	TST	A
	BGE	DMSND3	;BR IF NOTHING TO SEND
.IFZ DHON
	MOV	A,DMWC(U)
	BIS	DMBIT(U),DM0BAR	;TRANSMIT
.IFF
	MOV A,DH0BCR	;SET BYTE COUNT
	BIS DMBIT(U),DH0BAR	;START LINE UP
.ENDC
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
DMSND3:	JSR	F,ACRES
	RTS	PC
.ENDC

;PROCESS CHARS IN INPUT BUFFER
TOPIC1:	INC	TIQTO(E)	;INC CHAR PNTR
	DEC	TIQTON(E)	;DEC CHAR COUNT
	JSR	PC,TOIEC	;ECHO CHAR
TOPIC:	TST	TOPC(E)
	BNE	TOICM4	;IF OUTPUT BUFFER FULL, GO AWAY
	TST	TIQTON(E)
	BLE	TOICM4	;NO CHARS LEFT
	JSR F,TTYMPI
	MOVB	@TIQTO(E),D	;GET NXT CHAR
	JSR F,TTYMPO
	BR TOPIC1

;^M POSSIBLE END OF LINE
TOICM:	BIT	#TILIPM,TTYST(E)
	BEQ	TOICM3	;BR IF NOT IN LINE INPUT MODE
	TST	TIBC(E)
	BGT	TOICM3	;BR IF INSIDE BRACKETS
	INC	TIQTO(E)
	DEC	TIQTON(E)
	JSR	PC,TOIEC	;ECHO CHAR
	JSR PC,TYINQ
	SPUSH	A
	SPUSH	B
	SPUSH	C
	JSR F,TTYMPI
	MOV TIQI(E),A
	MOV #TITQ,B
	INC B
	MOV TIQN(E),C
	MOV C,TIEQN(E)
	MOVB -(A),-(B)
	SOB C,.-2
	JSR F,TTYMPO
	MOV B,TIEQO(E)
	SPOP	C
	SPOP	B
	SPOP	A
	JSR	PC,TYIRT	;RESET INPUT BUFFER
	MOV TIEQN(E),TIEQTN(E)
	MOV TIEQO(E),TIEQTO(E)
	SPUSH	U
	MOV	TTYU(E),U
	CLR	FLSRES(U)	;RUN THE GUY
	SPOP	U
	MOV #TICP5,(P)
	JSR PC,TOCINT
	SEZ
TOICM4:	RTS	PC
TOICM3:	CLZ	;NOT REALLY SPECIAL
	RTS PC

;^Y EDIT PREVIOUS LINE
TOICY:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^Y?
	JSR	PC,TOIECS	;IF NO, JMP HERE, ECHO ^Y
	MOV	#15,D
	JSR	PC,TOIECS	;ECHO CR
	MOV	#'_,D
	JSR	PC,TOIEC	;ECHO _
	BIS	#TIEDM,TTYST(E)	;PUT TTY IN EDIT MODE
	SEZ
	RTS	PC

;^X CLARIFY INPUT
;TYPE CR, REST OF EDIT BUFFER, CR, INPUT BUFFER
TOICX:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^X?
	MOV	#15,D	;NO
	BIT	#TIEDM,TTYST(E)
	BEQ	TOICX2	;BR IF NOT EDITING
	TST	TIEQN(E)
	BLE	TOICX2	;BR IF NOTHING IN EDIT BUFFER
	MOV	TIEQO(E),B
TOICX1:	JSR	PC,TOIECS	;ECHO CHAR IN D (SKIPS LEVEL IF Q FULL)
	JSR F,TTYMPI
	MOVB	(B)+,D	;GET NEXT EDIT CHAR
	JSR F,TTYMPO
	CMP B,#TITQ
	BLO	TOICX1	;BR IF STILL CHARS TO PRINT
	BHI	TOICX5	;BR IF JUST PRINTED LAST CHAR
	CMP	D,#15
	BNE	TOICX1	;LAST CHAR NOT CR, PRINT IT, THEN PRINT CR.
TOICX5:	MOV	#15,D
TOICX2:	TST	TIQN(E)
	BLE	TOICX4
	MOV #TIQM,B
TOICX3:	JSR	PC,TOIECS
	JSR F,TTYMPI
	MOVB	(B)+,D
	JSR F,TTYMPO
	CMP	B,TIQTO(E)
	BLOS	TOICX3	;BR IF MORE INPUT CHARS TO PRINT
TOICX4:	SEZ
	RTS PC


;ECHO CHAR FROM SPECIAL INPUT CHAR SUBR
TOIECS:	SPUSH	A
	JSR	PC,TOIEC	;ECHO
TOIES1:	SPOP	A
	TST	TOPC(E)
	BEQ	TOIECR
	MOV	(P)+,TOIPC(E)	;WHERE TO RETURN TO
	MOV	A,TOISVA(E)	;SAVE AC A
TOIECR:	RTS	PC

;ECHO RUBBED OUT CHAR
TOIRCS:	SPUSH	A
	JSR	PC,TOPRB
	BR	TOIES1

;ENTER SUBR THAT TOIECS EXITED
TOIENT:	TST	TOIPC(E)
	BEQ	TOIEN1
	MOV	TOIPC(E),@P	;RETURN HERE INSTEAD OF CALLING ROUTINE
	CLR	TOIPC(E)
	MOV	TOISVA(E),A
TOIEN1:	RTS	PC

;^C COPIES NEXT CHAR FROM EDIT QUEUE TO TYI QUEUE
TOICC:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
	JSR PC,TOICN4
TOICC1:	SEZ
	RTS PC


;^N COPIES NEXT WORD FROM EDIT TO TYI Q

TOICN:	BIT #TIEDM,TTYST(E)
	BEQ TOICN3
TOICN5:	JSR PC,TOICN4
	BEQ TOICN3
	JSR PC,TOISWS
	BEQ TOICN5
TOICN3:	SEZ
	RTS PC

TOICN4:	JSR PC,TOGED
	BEQ TOICN3
	JSR F,TTYMPI
	MOVB D,@TIQI(E)
	JSR F,TTYMPO
	JSR PC,TIBCK
	INC TIQN(E)
	INC TIQI(E)
	INC TIQTON(E)
	RTS PC

TIBCK:	CMP D,#'[
	BNE .+6
	INC TIBC(E)
	CMP D,#']
	BNE .+6
	DEC TIBC(E)
	CMP D,#'{
	BNE .+6
	INC TIBC(E)
	CMP D,#'}
	BNE .+6
	DEC TIBC(E)
	RTS PC


;^R COPY REST OF EDIT BUFFER TO INPUT BUFFER
TOICR:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
TOICR1:	JSR PC,TOICN4
	BEQ TOICC1
	BR TOICR1



;SKIP IF CHAR IN D IS WD SEPERATOR
TOISWS:	TSTB	D
	BMI	TOISW1	;BR IF QUOTED (HIGH BIT ON)
	BITB	#WSF,DTBL(D)
TOISW1:	RTS PC

;^D DELETES NEXT CHAR FROM EDIT QUEUE
TOICD:	BIT	#TIEDM,TTYST(E)
	BEQ	TOISW1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET NXT EDIT CHAR
	BEQ TOISW1
	JSR PC,TOPRB	;ECHO RUBBED OUT CHAR
TOICD1:	SEZ
	RTS PC


;^S SKIPS NXT WD IN EDIT QUEUE
TOICS:	BIT #TIEDM,TTYST(E)
	BEQ TOICD1
TOICS1:	JSR PC,TOGED
	BEQ TOICD1
	JSR PC,TOPRB
	JSR PC,TOISWS
	BNE TOICD1
	BR TOICS1


;^Q HAD EFFECT ON INPUT, DELETE FROM Q & ECHO
TOICQ:	JSR PC,TICQ
	JSR PC,TOIECS	;ECHO ^Q
	SEZ
	RTS PC
	
;RUBOUT RUBS OUT PREVIOUSLY PROCESSED CHAR
TOIRB:	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
	JSR	PC,TOPRB	;PRINT RUBBED OUT CHAR
	JSR	PC,TOIBCK	;CHECK FOR RUBBED OUT [ OR ]
	JSR PC,TOIOWP	;OVERWRITE RUBBED OUT CHAR
	SEZ
	RTS PC

TOICW2:	BIC	#TIRBM,TTYST(E)	;CLEAR RUB OUT MODE FLAG
	MOV	#15,D	;ECHO A C.R.
	JSR PC,TOIEC
	SEZ
	RTS PC

;^W RUBS OUT PREVIOUS WD
TOICW:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^W?
	JSR	PC,TOIQP	;NO, GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
TOICW1:	JSR	PC,TOIBCK	;CHECK FOR BRACKET
	JSR	PC,TOIRCS	;PRINT CHAR
	JSR	PC,TOIOWP	;BLT OVER CHAR
	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2
	JSR	PC,TOISWS	;SKIP IF WD SEPERATOR
	BEQ	TOICW1
TOICW3:	SEZ
	RTS PC

;[ INCS BRACKET COUNT
TOIOB:	INC TIBC(E)
	BGE	TOICB2
	BPT	;-BRACKETS
	BR TOICB2

;] DECS BRACKET COUNT IF THERE ARE ANY
TOICB:	TST	TIBC(E)
	BLE	TOICW3	;NO BRACKETS, IGNORE
	DEC	TIBC(E)	;DEC COUNT
TOICB2:	CLZ
	RTS PC


;GET PREVIOUS CHARACTER IN INPUT BUFFER AND SKIP
TOIQP:	SPUSH	A
	MOV	TIQTO(E),A	;GET POINTER TO CURRENT CHARACTER
	DEC A
	CMP A,#TIQM
	BLO	TOIQP1	;BR IF NO PREVIOUS CHARACTER
	JSR F,TTYMPI
	MOVB	(A),D
	JSR F,TTYMPO
	SPOP	A
	CLZ
	RTS PC
TOIQP1:
	SPOP	A
	SEZ
	RTS	PC

;CHECK FOR RUBBED OUT [ & ]
TOIBCK:	CMP	D,#'[
	BNE	.+6
	DEC	TIBC(E)	;IF CHAR WAS [, DECREMENT BRACKET COUNT
	CMP	D,#']
	BNE	.+6
	INC	TIBC(E)	;IF RUBBED OUT A ], INC BRACKET COUNT
	CMP D,#'{
	BNE .+6
	DEC TIBC(E)
	CMP D,#'}
	BNE .+6
	INC TIBC(E)
	RTS	PC

;OVERWRITE PREVIOUS CHARACTER
TOIOWP:	DEC TIQTO(E)
	DEC TIQN(E)
	DEC TITQN(E)
	DEC TIQI(E)
	RTS PC

;GET NEXT CHAR FROM EDIT BUFFER INTO D AND SKIP IF SUCCESSFUL
TOGED:	TST	TIEQN(E)
	BLE	TOGED2-2	;BR IF NOTHING LEFT IN EDIT BUFFER
	DEC	TIEQN(E)	;DEC CHAR COUNT
	JSR F,TTYMPI
	MOVB	@TIEQO(E),D	;GET NEXT CHAR
	JSR F,TTYMPO
	INC	TIEQO(E)
	CMP	D,#'[
	BNE	.+6
	INC	TIEBC(E)	;CHAR WAS [
	CMP	D,#']
	BNE	.+6
	DEC	TIEBC(E)	;CHAR WAS ]
	CMP D,#'{
	BNE .+6
	INC TIEBC(E)
	CMP D,#'}
	BNE .+6
	DEC TIEBC(E)
	CMP	D,#15
	BNE	TOGED2	;NOT A CR
	TST	TIEBC(E)	;CR, TEST FOR END OF EDIT LINE
	BGT	TOGED2
	CLR	TIEQN(E)	;EOL, CLR THIS TO BE XTRA CAREFUL
	SEZ
TOGED2:	RTS	PC


;PRINT RUBBED OUT CHAR IN D ON E'S TTY
TOPRB:	BIT	#TIECM,TTYST(E)
	BEQ	TOGED2	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BNE	TOIEC2	;ALREADY IN RUBOUT MODE
	BIS	#TIRBM,TTYST(E)
	BR	TOIEC1	;TYPE OPENING \


;ECHO CHARACTER IN D ON E'S TTY
TOIEC:	BIT	#TIECM,TTYST(E)
	BEQ	TOTYC1	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BEQ	TOIEC2	;ALREADY NOT IN RUBOUT MODE
	BIC	#TIRBM,TTYST(E)
	;PRINT CLOSING \
;PRINT \:
TOIEC1:	MOV	D,C	;SAVE CHAR
	MOV	#'\,D
	JSR	PC,TOCINQ	;PUT \ INTO OUTPUT Q
	JSR	PC,TOEXT	;FILLED UP Q
	MOV	C,D	;RESTORE CHAR
TOIEC2:		;PRINT CHAR IN D

;FALLS THROUGH!!!
;FALLS IN!!!

;PROCESS CHAR IN D INTO TTY IN E'S OUTPUT BUFFER
;IF BUFFER FILLS SAVE ACS C,D,PC AND EXIT
TOTYO:	BIT	#TIMAGE,TTYST(E)
	BEQ	TOTYO1	;BR IF NOT IN IMAGE MODE
TOTYOC:	JSR	PC,TOINQ	;PUT CHAR IN OUTPUT BUFFER
	JSR	PC,TOEXT
	RTS PC

TOTYO1:	MOVB	D,C
	BMI	TOTYOC	;BR IF CHAR HAS IMAGE MODE BIT SET
	BITB	#FOF,DTBL(C)
	BNE	TOTYO3	;BR IF SPECIAL ON OUTPUT
	CMP	D,#40
	BLT	TOTYO4	;BR IF CONTROL CHAR
	JSR	PC,TOCINQ
	JSR	PC,TOEXT
TOTYO2:	JMP	TOCLTO	;CHECK FOR LINE TOO LONG

;SPECIAL ON OUTPUT
TOTYO3:	MOVB	DTBL2(C),C
	JMP	@TOOCTB(C)
;CONTROL CHAR
TOTYO4:	MOV	#'^,D
	JSR	PC,TOCINQ	;PRINT ^
	JSR	PC,TOEXT
	MOV	C,D
	ADD	#100,D
	JSR	PC,TOCINQ	;PRINT CHAR +100
	JSR	PC,TOEXT
	MOV	C,D
	BR	TOTYO2

;OUTPUT BUFFER FULL, SAVE STATE OF WORLD AND RETURN ONE LEVEL UP
TOEXT:	MOV	C,TOSVC(E)
	MOV	D,TOSVD(E)
	MOV	(P)+,TOPC(E)
TOTYC1:	RTS	PC

;^A PRINTS AS CR
TOOCA:	CLR	CHARNO(E)
	MOV	#15,D
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	MOV	#1,D
	RTS	PC

;^H BACKSPACE DECREMENTS CHARNO IF NOT AT BEGINNING OF LINE
TOOCH:	TST	CHARNO(E)
	BLE	TOOCH1
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	DEC CHARNO(E)
TOOCH1:	RTS	PC

;CHECK IF LINE TOO LONG, IF SO PRINT CRLF
TOCLTO:	CMP	CHARNO(E),LINEL
	BLT	TOOCM1	;BR IF NOT TOO LONG
;^M PRINTS AS CR LF
TOOCM:	MOV	D,C	;SAVE D
	CLR	CHARNO(E)	;CLR CHAR COUNT
	MOV	#15,D
	JSR	PC,TOINQ	;PRINT CR
	JSR	PC,TOEXT
	MOV	#12,D
	JSR	PC,TOINQ	;PRINT LINEFEED
	JSR	PC,TOEXT
	MOV	C,D
TOOCM1:	RTS	PC

;^I PRINTS SPACES TILL NEXT TAB STOP
TOOCI:	MOV	D,C
	MOV	#40,D
TOOCI1:	JSR	PC,TOCINQ
	JSR	PC,TOEXT
	BIT	#7,CHARNO(E)
	BNE	TOOCI1
	MOV	C,D
	RTS	PC

;*** INTERRUPT AND USER LEVEL ***

;PUT CHAR IN D INTO TTY IN E'S CIRCULAR OUTPUT QUEUE
;SKIP TWO WORDS IF SUCESSFULL
TOCINQ:	INC	CHARNO(E)
TOINQ:
	CMP TOQN(E),#TOQSZ
	BGE TOINQ2
	CMP TOQI(E),#TOQLM
	BLO TOINQ1
	MOV #TOQM,TOQI(E)
TOINQ1:	JSR F,TTYMPI
	MOVB	D,@TOQI(E)	;PUT CHAR IN BUFFER
	JSR F,TTYMPO
	INC	TOQI(E)
	INC	TOQN(E)	;INC # OF CHARS IN OUTPUT BUFFER
	SPUSH	E
	MOVB	MXNUM(E),E	;GET THIS TTY'S MULTIPLEXOR
	BMI	TOINQ4	;BR IF NOT PSEUDO OR MULTIPLEXED TTY
	INC	TOQN(E)	;INC MULTIPLEXOR'S CHARACTER COUNT
TOINQ4:	SPOP	E
	CMP TOQN(E),#TOQSZ
	BGE	TOINQ3	;BR IF Q FILLED NOW
	ADD	#4,@P	;SKIP RETURN TO SUCESS
TOINQ3:	RTS	PC

TOINQ2:	BPT	;TRIED TO PUT CHAR IN OUTPUT Q WHEN ALREADY FULL
	RTS	PC	;RETURN TO FAILURE
.STITL TELETYPE INITIALIZATION CODE
;INITIALIZATION CODE
TINIT:
;DECIDE WHICH PORTS TO USE & SET UP LOGICAL VARIABLES
	MOV	#NPORTS,A
	CLR	B	;INDEX TO PHYS TABLES
TINIT1:	MOVB	TILTTY(B),C	;LOGICAL INDEX
	BMI	TINIT2	;NOT LOGICAL
	MOVB	B,TIPTTY(C)	;PHYS TTY #
	MOVB	TILTTY+1(B),TIPTTY+1(C)	;MPXR #
	MOV	TYPTYP(B),TTYTP(C)
	MOV	TYRS(B),TOTSR(C)	;RCV RG ADDR
	BIT	#TPDM,TTYTP(C)
	BNE	.+10	;BR IF DM11
	ADD	#4,TOTSR(C)	;TRANS RG ADDR
	BIT	#TPMPX,TTYTP(C)
	BEQ	TINIT2	;BR IF NOT MPXR
	MOV	#MXRCV,TIRCV(C)	;RCV DISPATCH ADDR
	MOV	#MXGOC,TOGOC(C)	;TRANS DISPATCH ADDR
	SPUSH	A
	SPUSH	B
	MOV	#4,A	;# OF MPXED DEVICES
	MOV #TOQM,D
	MOV C,E
	JSR F,TTYMPI
TINIT4:	TST	(B)+
	MOVB	TILTTY(B),(D)+	;PUT #'S OF MULTIPLEXEES IN OUTPUT Q
	SOB	A,TINIT4
	JSR F,TTYMPO
	SPOP	B
	SPOP	A
TINIT2:	TST	(B)+
	SOB	A,TINIT1

;DECIDE WHICH ARE USER TTYS
	MOV	NUSERS,A
	MOV	#UTYTB,B
	CLR	E
	CLR	U
TINIT3:	MOV	(B)+,E	;INDEX OF NEXT USER TTY
	TST	TTYU(E)
	BMI	.+4
	BPT	;ALREADY BELONGS TO A USER
	MOV	U,TTYU(E)
	MOV	E,UTTY(U)
	JSR	PC,TTYRT	;RESET (INITITALIZE) BUFFERS
	JSR	PC,UCINIT	;INITIALIZE CONSOLE VARIABLES
	ADD	#LUBLK,U
	SOB	A,TINIT3
	MOV	#SYSIDX,TTYU+NFTBOX	;MAKE SYS TBOX USER
	MOV	#TTYI,ITYI	;SET UP NEW USER TYI &TYO ADDRS
	MOV	#TTYO,ITYO
	JSR	PC,TINITH	;INIT HARDWARE
	JMP	NEXTUS
TTYMPI:	SPUSH TEMPAR
	SPUSH TEMPDR
	MOV #TTYDR,TEMPDR
	MOV TTYAR(E),TEMPAR
	SPUSH F
	MOV 4(P),F
	RTS PC

TTYMPO:	TST (P)+
	SPOP TEMPDR
	SPOP TEMPAR
	RTS F

;DON'T FORGET TBOXES
;HARDWARE INITIALIZATION
TINITH:	
.IFNZ NTY
	MOV	#100,TKS	;CONSOLE TTY
	MOV	#100,TPS
.ENDC
.IFNZ AI
	MOV	#111,DC0RS
	MOV	#113,DC0TS
.ENDC
.IFNZ GUY
	MOV #131,DC0RS
	MOV #133,DC0TS
.ENDC
	MOV	OMXRES+DC0TBN,DC0TB	;SLIGHT KLUGE, RESET TBOX
	MOV	#101,DC1RS
	MOV	#501,DC1TS	;FOR VOICE BOX(RJL)
.IFZ DHON
	MOV	#DMCA+NFDMTY,DM0TBR
	MOV	#DMTT,TTP
	MOV	#10101,DM0CSR
.IFF
	MOV #20,A	;SET ALL LINES TO 300 BAUD
	CLR DH0SCR	;START AT ZERO
TINITX:	.IIF NZ AI,	MOV #16722,DH0LPR
.IIF NZ GUY,	MOV #6326,DH0LPR
	INC DH0SCR
	SOB A,TINITX
	CLR DH0SSR	;INTERUPT ON > 0 CHARS
	MOV #30100,DH0SCR
.ENDC
	RTS	PC

;CROCKS

DMSQ:TI2Q:	RTS	PC

DC0SND:TB0SND:
	BPT
	RTS	PC

