	.TITLE "SALVAGER" FOR THE SITS FILE SYSTEM
	.STITL PARAMETERS
	.ABS

;WHEN INITING THE FIXED HEAD DISK
;RUG WANTS BLOCKS 0,4-23, AND 54-217
;LOGO WANTS 500-1777 FOR SWAPPING


BEE==0

	A=%0
	B=%1
	C=%2
	D=%3
	E=%4
	F=%5
	P=%6
	PC=%7
	.XCREF A,B,C,D,E,F,P,PC

	DISKWR==3
	DISKRD==5
	DISKWC==7
	WCERR==1

	TBUFLN==100

	SWB=177570	;DATA SWITCHES

	FBASE1=40000
	FEND1=FBASE1+4000
	NDIR=50000
	NDEND=NDIR+1776
	NDIR1=NDIR+2000
	DBITS1=60000
	DBITS2=DBITS1+20000
	DIR=DBITS2+20000
	FBASE=DIR+2000	;1 BLOCK
	FEND==FBASE+4000
	DSKBUF=FEND
	DBEND=DSKBUF+1776	;HERE BE FILE LENGTHS

	RKER=177402	;MOVING HEAD DISK REGS
	RKCS=177404
	RKWC=177406
	RKBA=177410
	RKDA=177412

	PLATR1==20000

	DSKS=177460	;FIXED HEAD DISK REGS
	DSKWC=177462
	DSKCA=177464
	DSKA=177466
	DSKAE=177470
	DSKDBR=177472

	NRETRY==3

;STACK FRAME OFFSETS
	FFBCKP==0	;BY DEFINITION; POINTS TO PREV. STACK FRAME
	FENTRP==FFBCKP+2	;ORIG. ADDR OF THIS ENTRY; FOR ALFORD
	FNXNTRY==FENTRP+2	;NEXT ENTRY OF PUSHED DIRECTORY
	FDDESC==FNXNTRY+2	;DESCRIPTOR OFFSET IN THIS ENTRY
	FDBYTES==FDDESC+2	;DESCRIPTOR LENGTH
	FNDBLN==FDBYTES+2	;NO. OF CORRESPONDING BLOCK ON NEW DISK
	FENTRY==FNDBLN+2	;START OF ACTUAL ENTRY

;ENTRY TYPE FIELDS
	TYPFLD==300	;TYPE OF ENTRY
	LENFLD==77	;LENGTH OF ENTRY, IN WORDS

;ENTRY TYPES (TIMES 2 FOR DISPATCHING)
;A TYPE AS SEEN HERE, * 40, = A TYPE AS IN TYPE FIELD
	HEADER==0
	LINK==2
	FILE==4
	DIREC==6
	ALFORQ==10	;CHECK-ALPHA.-ORDER, OR SKIP-NAME-&-VN
	BITS==12	;CHECK BITS FOR THIS ENTRY'S DISK BLOCKS

;FLAGS
	VNF==200	;VERSION NUMBER FOR THIS FILE
	ACCF==100	;ACCESS INFO EXISTS
	WRDLFT==40	;WORD LEFT IN FILE OR DIRECTORY;
			;WORD HOLDS TOTAL BYTES LEFT
	BYTLFT==20	;1 BYTE LEFT IN FILE OR DIR
	NODELF==10	;DON'T DELETE THIS FILE (DIR)

;DESCRIPTOR BYTE TYPES
	DTYPEF==300	;TYPE-OF-DESCRIPTOR-BYTE FIELD
	DTSKP==0	;SKIP N AND GRAB 1 BLOCK
	DTCNT==100	;GRAB N+1 BLOCKS
	DTSADR==200	;GRAB N+1 BLOCKS STARTING AT X (SET ADDR)
	DTSKCT==300	;SKIP N1 AND GRAB N2+1 BLOCKS
	DTCNTF==77	;FOR FIRST THREE TYPES, THE N FIELD
	DTSCSK==70	;FOR SKIP/COUNT, THE SKIP FIELD N1
	DTSCCT==7	; "      "    , THE COUNT FIELD N2
	.STITL MACROS
.MACRO	FPUSH X
	.XLIST
	MOV X,(F)+
	.LIST
.ENDM

.MACRO	PUSH X
	.XLIST
	MOV X,-(P)
	.LIST
.ENDM

.MACRO	POP X
	.XLIST
	MOV (P)+,X
	.LIST
.ENDM

.MACRO	TEXT X
	.XLIST
	.ASCII /X/
	.BYTE 0
	.EVEN
	.LIST
.ENDM

.MACRO	TYPEIT X
	.XLIST
	JSR F,TXTYPE
	TEXT ^/X/
	.LIST
.ENDM

.MACRO	ERROR X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/ERROR--'X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	ENTERR X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/ERROR--ENTRY /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	TYPEIT ^/X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	BUG X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/BUG--'X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	MSG X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	FLTEXT X
	.XLIST
	.IRPC XC,^/X/
	.IFNZ .LENGTH ^/X/,-<.IRPCN+1>
		.LIST
		.BYTE ''XC
		.XLIST
	.IFF
		.LIST
		.BYTE 200+''XC
		.XLIST
	.ENDC
	.ENDM
	.LIST
.ENDM
	.STITL SET TRAP VECTORS TO HALT
.=0
.REPT 100
.XLIST
.+2
HALT
.LIST
.ENDR
	.STITL VARIABLES AND THINGS
	.=2000
WORLD:	0	;DUMMY FOR RUG.  THE EDGE OF THE WORLD.
CHECKD:	0	;CHECK HAS BEEN DONE
NFBLKP:	4603	;LAST USED BLOCK ON NEW DISK
NFBKNO:	0	;CURRENT BLOCK ON NEW DISK TO WRITE ONTO
NDISK:	0	;NEW DISK POSITION
NEXTF1:	0	;NEXTF BUT FOR NEW DISK
FBKP1:	0	;FBACKP FOR NEW DISK
NNTRYP:	0	;ENTRYP FOR NEW DISK
NDBLKN:	0	;NEW DISK CURRENT BLOCK NO.
NXBKNO:	0	;POINTER TO BLOCK NO. STACK
MXBKNO:	0	;MAX FOR STACK POINTER
NXDSC:	0	;NEXT TEMP POSITION FOR DESCRIPTOR ENTRY
DSCEOF:	0	;END OF DISK DESCRIPTOR FILE
TOFIND:	0	;ADDR OF ENTRY NAME TO BE FOUND

DIREND:	0	;END OF DIRECTORY (AS SET BY LOADIR)
FBACKP:	0	;POINTS TO PARENT ENTRY OF THIS DIRECTORY
NEXTF:	0	;POINTS TO NEXT AVAILABLE F-STACK FRAME
ENTRYP:	0	;POINTS TO CURRENT ENTRY IN CURRENT DIRECTORY
NXNTRY:	0	;TO NEXT ENTRY IN CURR. DIR.
ETYPE:	0	;TYPE * 2 OF THIS ENTRY
NBYTES:	0	;LENGTH OF ENTRY
FLAGS:	0	;RANDOM FLAGS IN ENTRY
DDESCR:	0	;OFFSET OF DISC BLOCK DESCRIPTOR
DBYTES:	0	;LENGTH OF DESCRIPTOR
DSCEND:	0	;POINTS TO END OF DESCRIPTOR
		;(CAN BE FOUND BY FTYPE)

VN:	0	;SLOT FOR VERSION NUMBER, IN ALFORD.
OENTRY:	0	;PTS TO PREV. ENTRY IN CURR. DIR., FOR ALPH. ORD.
OTYPE:	0	;IS IT A HEADER ENTRY
OFLAGS:	0	;HAS IT A VERSION NUMBER
OVN:	0	;ITS VERSION NUMBER

BITFND:	0	;BIT FOUND SET IN BITTABLE 2 BY CKBIT2
BITLIM:	0	;FIRST !BYTE! AFTER END OF BIT TABLE
BITSAT:	0	;HOW MUCH OF BIT TABLE YOU'VE TRANSFERRED SO FAR
DIRCNG:	0	;HAS THE DIRECTORY BEEN MODIFIED
DISKIO:	0	;DIRECTION OF TRANSFER (DISKRD OR DISKWR)
BLOKNO:	0	;BLOCK NUMBER OF CURRENT DISK BLOCK
BLKLIM:	0	;FIRST BLOCK NO. NOT ON DISK
RNG01F:	.BYTE 0	;FLAGS FOR BCOMP, TO MANAGE GROUPING OF BITS
RNG10F:	.BYTE 0	; THAT DISAGREE IN OLD AND NEW BIT TABLES.
		;0 = NO SEQUENCE, 1 = SINGLETON,
		;2 = SEQ OPEN, BE SURE TO CLOSE IT
RANYBQ:	0	;STAYS 0 IF NO BAD BITS SEEN.
WCHDSK:	0	;WHICH PLATTER: 0=FIXED  20000=REMOVABLE
BLOKDO:	0	;WHAT TO DO WHEN DMARCH SAYS "BLOCK # N"
RETRYS:	0	;# RETRYS LEFT BEFORE COMPLAINT
RETRYV:	0	;# VERIFY RETRYS "    "
DSKERR:	0	;DISK ERROR WORD
ERNTRYP:0	;POINTS TO LAST STACKED ENTRY VISITED BY BACKTRACE
BKFBKP:	0	;BACKTRACE'S STACK POINTER AS IT TRACES BACK

NCHR:	0	;NUMBER OF CHARS IN TYPEIN BUFFER
TBUFPT:	0	;PTR INTO BUFFER: FILLING AND EMPTYING
RUBING:	0	;NON-0 MEANS RUBBING OUT CHARS


TRNSLE:	-1000	;TRANSFER LENGTH
DOWHAT:	0	;ADDRESS OF DISPATCH TABLE FOR ENTRY TYPES

CPTAB1:	RTSPC	;DISPATCH TABLE FOR PASS 1 OF COPY. (DIRECTORIES ARE COPIED)
	RTSPC
	RTSPC
	CP1DIR
	SKNMVN
	RTSPC

CPTAB2:	RTSPC	;DISPATCH TABLE FOR PASS 2. (FILES ARE COPIED)
	RTSPC
	CPFIL
	CP2DIR
	SKNMVN
	RTSPC

CKTAB1:	CKHEAD	;DISPATCH TABLE FOR PASS 1 (FIND SHARED BLOCKS)
	CKLINK
	CKFILE
	CKDIR
	ALFORD	;YES, CHECK ALPHABETICAL ORDER
	SETB12	;SET BIT TABLE 1, "OVERFLOW" TO TABLE 2

CKTAB2:	C2HEAD	;DISPATCH TABLE FOR PASS 2 (MARK FILES SHARING BLOCKS)
	C2LINK
	C2FILE
	C2DIR
	SKNMVN	;JUST SKIP NAME AND VERSION NUMBER
	CKBIT2	;SET DON'T DELETE FLAG IF TABLE 2 SET


LOADX:	LODSKP
	LODCNT
	LODSAD
	LODSC

RTSPC:	RTS PC

BITSE:	FLTEXT ^/BITS/	;NAME OF BIT TABLE FILE
DESCRE:	FLTEXT ^/DESCR/	;NAME OF DISK DESCRIPTOR FILE
	.EVEN

TBUF:	.=.+TBUFLN
	0	;JUST IN CASE
	.STITL !THE! !SALVAGER!!!
SALV:	RESET		;INIT THE BUSS
	MOV #WORLD,P	;INIT THE STACK POINTER
	CLR CHECKD	;ASSERT MUST-CHECK-BEFORE-DELETE
	JSR PC,ITYI	;INIT THE TYI

	TYPEIT ^/_SALV /	;_ MAKES A CRLF
	MOV #%FNAM2,B
	JSR PC,DECOUT
SALV2:	TYPEIT ^/_*/
SALV5:	TST CHECKD	;HAVE WE CHECKED?
	BGT SALV3	;YES, WE CAN DELETE THEN
	CLR CHECKD	;(CHECKD FLAG NEG OR ZERO, MAKE IT ZERO)
	JSR PC,TYI1
	CMP #'D,A	;DELETE ANYWAY!
	BEQ DELETQ	;"DO YOU INSIST?"
SALV4:	CMP #'U-100,A	;CTL-U
	BNE .+6
	JMP CPYUP
	CMP #'D-100,A
	BNE .+6
	JMP CPYDN
	CMP #'I,A
	BEQ INIT0
	CMP #'C,A
	BEQ CHECK0
	CMP #'F,A	;FIXED HEAD BLOCK 0 INIT
	BEQ FXB0I0
	CMP #'R,A
	BEQ FLCOPY
	SUB #'0,A	;IS IT A NUMBER?
	BLT SALVQ	;NOPE, NOT THAT EITHER
	CMP #'9-'0,A	;MAYBE
	BLE SALVQ	;NOPE
	ASH #13.,A	;PUT IT INTO THE RIGHT PLACE
	MOV A,WCHDSK	;SET THE VARIABLE
	BR SALV5
SALVQ:	TYPEIT ^/ ?/
	BR SALV2

FLCOPY:	JMP FLCOP1


SALV3:	JSR PC,TYI1
	CMP #'D,A
	BEQ DELET0
	BR SALV4

FXB0I0:	TYPEIT ^/IXED HEAD DISK BLOCK 0 INIT_SURE? /
	JSR PC,TYI1
	CMP #' ,A
	BEQ GOFXB0
	CMP #'Y,A
	BNE SALVQ
GOFXB0:	JSR PC,CRLF
	JMP FXINIT

INIT0:	TYPEIT ^/NIT_SURE?/
	JSR PC,TYI1
	CMP #' ,A
	BEQ GOINIT
	CMP #'Y,A
	BNE SALVQ
GOINIT:	JSR PC,CRLF
	JMP INITD

CHECK1:	TYPEIT ^/_C/
CHECK0:	TYPEIT ^/HECK_/
	JMP CHECK

DELETQ:	TYPEIT ^/ELETE_/
	TYPEIT ^/CHECK FIRST? /
	JSR PC,TYI1
	CMP #'Y,A
	BEQ CHECK1
	CMP #'N,A
SALVQ1:	BNE SALVQ
	TYPEIT ^/_YOU ARE WARNED._/
	JMP DELETE

DELET0:	TYPEIT ^/ELETE_/
	JMP DELETE

FLCOP1:	TYPEIT ^/_FILE COPY UP OR DOWN?_?/
	JSR PC,TYI1
	CMP #'U,A
	BEQ COPYUP
	CMP #'D,A
	BNE SALVQ1
	TYPEIT ^/OWN_/
	CLR NDISK
	MOV #PLATR1,WCHDSK
	JMP FILCPY
COPYUP:	TYPEIT ^/P_/
	MOV #PLATR1,NDISK
	CLR WCHDSK
	JMP FILCPY

DELETE:	TYPEIT ^/_DELETE DOESN'T EXIST YET. SORRY._/
	CLR CHECKD
	JMP SALV2

	.STITL WRITE OUT AN INITIAL BLOCK 0 ON FIXED HEAD DISK.
FXINIT:	MOV #FHIDIZ,A
	MOV #<FHIDIR+1000-FHIDIZ>,B
	CLR (A)+	;CLEAR REST OF BLOCK 0 IMAGE
	SOB B,.-2

	MOV #NRETRY,RETRYS
FXBLK1:	MOV #400,DSKS	;CLEAR DISK
	MOV #DSKAE,A
	CLR (A)
	CLR -(A)	;WRITE BLOCK 0
	MOV #FHIDIR,-(A)
	MOV #-400,-(A)	;WITH IMAGE
	MOV #DISKWR,-(A)	;DO IT

FXWAIT:	TST (A)		;ERROR?
	BLT FXLOS
	TSTB (A)	;DONE?
	BGE FXWAIT
	JMP SALV2	;ALL DONE, THIS DISK CAN'T WRITE-CHECK.

FXLOS:	DEC RETRYS
	BGT FXBLK1	;TRY N TIMES
	TYPEIT ^/FIXED HEAD INIT FAILED:_  DSKS = /
	MOV DSKS,B
	JSR PC,OCTOUT
	TYPEIT ^/_  DSKAE = /
	MOV DSKAE,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	BPT
	BR .-2
	.STITL COPY DISK IN FILE FORMAT

NDSKWR:	MOV #DSKBUF,B	;BLOCK TO WRITE IS IN DSKBUF
NDKWR1:	PUSH BLOKNO	;SAVE OLD BLOKNO
	PUSH WCHDSK	;SAVE OLD DISK
	MOV NDISK,WCHDSK	;MOV DISK TO WRITE ON TO WCHDSK
	MOV A,BLOKNO	;MOVE BLOCK TO WRITE ON INTO BLOKNO
	JSR PC,DSKWR1	;DO THE WRITE
	POP WCHDSK	;RESTORE OLD DISK
	POP BLOKNO	;RESOTORE ALD BLOCK NO
	RTS PC

NDSKRD:	MOV #DSKBUF,B	;BLOCK IS READ INTO DSKBUF
NDKRD1:	PUSH BLOKNO	;SAVE OLD BLOCK NO.
	PUSH WCHDSK	;SAVE OLD DISK
	MOV NDISK,WCHDSK	;NDISK IS THE DISK TO READ FROM
	MOV A,BLOKNO	;A CONTAINS BLOCK NO. TO BE READ
	JSR PC,DSKRED	;READ THE BLOCK
	POP WCHDSK	;RESTORE THE WORLD
	POP BLOKNO
	RTS PC


FILCPY:	MOV #DBITS1,A
	MOV #20000,B
	CLR (A)+
	SOB B,.-2
	MOV #FBASE1,F	;SET UP THE NEW DISKS FILE STACK
	MOV F,NEXTF1
	MOV F,FBKP1
	MOV #46,B
	MOV B,BLOKNO
	JSR PC,BTSET
	MOV #DIR,B
	MOV #-1,BLKLIM
	JSR PC,DSKRED	;READ THE ROOT DIRECTORY OFF THE DISK TO BE COPIED
	MOV #46,A
	MOV #NDIR,B
	JSR PC,NDKRD1	;READ THE ROOT DIRECTORY OFF THE NEW DISK
	MOVB NDIR+1,FLAGS
	MOV #NDIR+2000,B
	JSR PC,FNDEOF	;FIND THE END OF THE NEW DISKS FILE
	MOV B,DIREND
	MOV #NDIR,ENTRYP
	MOV #BITSE,TOFIND	;FIND THE BIT TABLE OF THE NEW DISK
	JSR PC,FIND
	MOV NBYTES,A
	ROR A
	MOVB DIR,C
	BIC #-LENFLD-1,C
	ROL C
	ADD #DIR,C
	MOV ENTRYP,B
	MOV (B)+,(C)+
	SOB A,.-2
	PUSH C
	JSR PC,FOUNDE
	MOV #BTSET1,BLOKDO
	JSR PC,EDMARCH
	MOV #NDIR,ENTRYP
	MOV #DESCRE,TOFIND
	JSR PC,FIND
	MOV NBYTES,A
	ROR A
	MOV ENTRYP,B
	POP C
	MOV (B)+,(C)+
	SOB A,.-2
	PUSH C
	JSR PC,FOUNDE
	JSR PC,EDMARCH
	MOV #DIR+2000,B
	POP C
	SUB C,B
	MOV B,DIR+1776
	MOV #46,A
	MOV #DIR,B
	JSR PC,NDKWR1
	PUSH WCHDSK
	MOV NDISK,WCHDSK
	MOV #DIR+2000,B
	JSR PC,FNDEOF
	MOV B,DIREND
	JSR PC,DESRF
	MOV #DBITS1,A
	MOV #DBITS2,B
	MOV #10000,C
	BIS (B)+,(A)+
	SOB C,.-2
	MOV #DBITS2,B
	MOV #10000,C
	CLR (B)+
	SOB C,.-2
	POP WCHDSK
	MOV #46,A
	MOV #NDIR,B
	JSR PC,NDKRD1
	MOV #NDIR,ENTRYP
	MOV #NDIR+2000,DIREND
	JSR PC,GTDATA
	JSR PC,NPUSHD
	JSR PC,CHECK2
	MOV #CPTAB1,DOWHAT
	MOV #46,NDBLKN
	JSR PC,DOROOT
	TYPEIT ^/DIRECTORIES COPIED!!_/
	MOV #46,A
	MOV A,NDBLKN
	MOV #NDIR,B
	JSR PC,NDKRD1
	MOV #CPTAB2,DOWHAT
	JSR PC,DOROOT
	TYPEIT ^/FILES COPIED!!/
	MOV NDISK,WCHDSK
	MOV #46,BLOKDO
	JSR PC,DSKRED
	MOV #DIR+2000,B
	MOVB DIR+1,FLAGS
	JSR PC,FNDEOF
	MOV #BITSE,TOFIND
	JSR PC,FINDE
	MOV #FSTBLK,BLOKDO
	JSR PC,EDMARCH
	MOV DSKBUF,A
	MOV A,BLKLIM
	DEC A
	ASH #-3,A
	INC A
	BIC #160000,A
	MOV A,BITLIM
	MOV #BITSWR,BLOKDO
	JSR PC,BITSIO
	JMP SALV2



	.STITL CHECK THE FILE SYSTEM
CHECK2:	MOV #FBASE,F
	MOV F,NEXTF
	MOV F,FBACKP
	MOV F,ERNTRYP
	MOV #-1,BLKLIM	;ALLOW ANY BLOCK # TILL YOU GET THE BIT TABLE
	MOV #DIR,B	;LOAD ROOT STARTING HERE
	MOV #46,BLOKNO
	JSR PC,DSKRED	;GET FIRST BLOCK OF HEADER
	MOVB DIR+1,FLAGS	;GET ROOT HEADER FLAGS
	MOV #DIR+2000,B	;FIND END OF ROOT
	JSR PC,FNDEOF
	MOV B,DIREND
	MOV #DIR,ENTRYP
	JSR PC,TYPEWD
	JSR PC,SKPNAM
	JSR PC,SKIPVN
	JSR PC,SKPACC
	JSR PC,ATDESC	;ALL SET TO STACK

	JSR PC,PSHDIR	;SET UP BASE OF F-STACK

	MOV #-1,BLKLIM	;ALLOW ANY BLOCK #
	JSR PC,LOADIR	;GET WHOLE ROOT DIRECTORY


	MOV #BITSE,TOFIND
	JSR PC,FINDE	;FIND BITS FILE
	BEQ CKSYS1
	ERROR ^/NO BITS FILE/
CKSYS1:	MOV #FSTBLK,BLOKDO
	JSR PC,EDMARCH
	MOV DSKBUF,BLKLIM	;FIRST WORD OF FILE IS DISK LENGTH

DESRF:	MOV #DESCRE,TOFIND
	JSR PC,FINDE	;FIND DISK DESCRIPTOR FILE
	BEQ CKSYS4
	ERROR ^/NO DISK DESCRIPTOR/
CKSYS4:	JSR PC,L1BLKF	;LOAD 1-BLOCK FILE
	MOV B,DSCEOF	;L1BLKF RETURNS EOF ADDR IN B

	MOV #DSKBUF+2,E	;START AFTER BASE YEAR
	MOV #2,D	;2 SWAP AREAS
SRES1:	MOV (E)+,BLOKNO ;AREA STARTING AT BLOCK NO.
	MOV (E)+,C	;SO MANY BLOCKS
	BEQ SRES3	;NO BLOCKS
SRES2:	JSR PC,BTADR	;SET BIT FOR ONE BLOCK
	BISB A,DBITS2(B)
	INC BLOKNO
	SOB C,SRES2
SRES3:	SOB D,SRES1

SRES4:	CMP E,DSCEOF	;RESERVED BLOCKS WORDS TO END OF FILE
	BNE CKIT1	;EOF: BIT TABLE ALL SET!
	RTS PC
CKIT1:	BLO SRES5
	ERROR ^/DISK DESCRIPTOR EOF OUT OF SYNC?/
SRES5:	MOV (E)+,B	;WORD OFFSET IN BIT TABLE
	MOV (E)+,A	;MASK OF RESERVED BLOCKS
	BIS A,DBITS2(B)	;SET WHOLE WORD
	BR SRES4


CHECK:	MOV #DBITS1,A	;CLEAR BOTH BIT TABLES
	MOV #20000,B	;2*4K WORDS
	CLR (A)+
	SOB B,.-2
	JSR PC,CHECK2
	TYPEIT ^\CHECKING DISK \
	MOV #DIR,B
	JSR PC,NAMOUT
	JSR PC,CRLF
CKIT:	MOV #CKTAB1,DOWHAT	;CHECK THE WORLD PASS 1!
	JSR PC,DOROOT
	MOV #DBITS2,A	;GET ALL THE USED BLOCKS -> TABLE 1
	MOV #DBITS1,B
	MOV #10000,C	;EACH TABLE 4K WORDS LONG
	BIS (A)+,(B)+	;.OR. TABLE 2 INTO TABLE 1
	SOB C,.-2

	MOV #CKTAB2,DOWHAT	;CHECK FOR SHARED BLOCKS!
	JSR PC,DOROOT
			;FINALLY:
		;1:  COMPARE BIT TABLE 1 WITH DISK.
	MOV BLKLIM,A	;GET LENGTH OF BIT TABLE IN BYTES
	DEC A		;(JUST FOR DMARCHING)
	ASH #-3,A
	INC A		;FIRST BYTE AFTER BIT TABLE
	BIC #160000,A	;CLEAR SIGN EXTEND
	MOV A,BITLIM

	MOV #BITSE,TOFIND
	JSR PC,FINDE

	MOV #BITSRD,BLOKDO
	JSR PC,BITSIO	;READ IN THE BIT TABLE INTO TABLE 2

	CLR RANYBQ
	CLR C		;DO THE COMPARE: STOP WHEN BLOCK NO. = BLKLIM
	CLR RNG01F	;ASSERT NO 0->1 OR 1->0 (CLRS BOTH FLAGS)
	MOV #DBITS1,D
	MOV #DBITS2,E

BCOMP1:	MOV (D),A
	MOV (E),B
	BIC (E)+,A	;GET DBITS1 - 2: MARKING A "FREE" BLOCK
	BIC (D)+,B	;GET DBITS2 - 1: MARKED BUT NOT FOUND

	MOV #20,F
BCOMP2:	ASHC #-1,A	;RIGHT SHIFT ONE BOTH
	BCC .+10
	JSR PC,BAD10	;FOUND A 2-1 (1 -> 0)
	BR BCOMP4

	TST B
	BGE .+10
	JSR PC,BAD01	;FOUND A 1-2 (0 -> 1) BAD NEWS
	BR BCOMP4

	JSR PC,BCGOOD

BCOMP4:	INC C		;COUNT THE BLOCK
	CMP C,BLKLIM	;EXIT IF ALL BLOCKS DONE ON DISK
	BHIS BCOMP3
	SOB F,BCOMP2
	BR BCOMP1

BCOMP3:	JSR PC,BCGOOD
	TYPEIT ^/_DISK /
	MOV #FBASE+FENTRY,B
	JSR PC,NAMOUT
	TYPEIT ^/ REFRESHED_/
	TST RANYBQ	;CHANGED ANY BITS?
	BEQ CKSYSX
	TYPEIT ^/WRITE BIT TABLE?  /
	JSR PC,TYI1
	CMP #'Y,A
	BEQ .+6		;DO IT
NWRITE:	BPT		;NO GOOD
	BR .-2
WRITEB:	JSR PC,CRLF

		;2:  STORE TABLE 1 AS NEW BIT TABLE
	MOV #BITSWR,BLOKDO
	JSR PC,BITSIO	;WRITE OUT NEW BIT TABLE


	TYPEIT ^/WRITTEN_/
CKSYSX:	CLR CHECKD	;WON'T BECOME > 0 [UNLESS NO ERRORS--FUTURE]
	JMP SALV2
;GIVEN A LAST-CHAR-FLAGGED STRING IN (A)+,
;FIND A FILE WITH THAT NAME.
FINDE:	MOV #DIR,ENTRYP
FINDE1:	JSR PC,FIND
	BEQ FOUNDE
FIND1:	RTS PC

FIND:	JSR PC,TYPEWD
	MOV TOFIND,C
	JSR PC,CMPNAM
	BEQ FIND1
	CMP NXNTRY,DIREND
	BEQ NFOUND
	BLO FINDE2
	ENTERR ^/ OVERSHOT DIRECTORY END/
	BPT
FINDE2:	MOV NXNTRY,ENTRYP
	BR FIND

FOUNDE:	JSR PC,SKIPVN
	JSR PC,SKPACC
	JSR PC,ATDESC
	SEZ
	RTS PC

NFOUND:	CLZ
	RTS PC

FILLEN:	MOV #CNTBKN,BLOKDO
	CLR A
	CLR B
	JSR PC,EDMARCH
	MOV A,B
	RTS PC

CNTBKN:	INC A
	RTS PC




LENFIL:	MOV #CNTBLK,BLOKDO
	CLR A
	CLR B
	JSR PC,EDMARCH
	TST B		;B HOLDS NO. BLOCKS
	BNE .+4
	RTS PC		;LENGTH OF 0-BLOCK FILE IS 0
	DEC B
	PUSH B

	DEC BLOKNO
	MOV #DSKBUF,B
	JSR PC,DSKRED	;LOAD LAST BLOCK
	MOV #DSKBUF+2000,B
	JSR PC,FNDEOF	;FIND EOF IN THAT BLOCK
	BVC LENFL2
	ENTERR ^/ BAD LENGTH FILE/
LENFL2:	SUB #DSKBUF,B	;LENGTH OF LAST BLOCK
	CLR A
	ASHC #6,A
	ADD (P)+,A
	ASHC #-6,A
	RTS PC

CNTBLK:	INC B		;COUNT A BLOCK
	RTS PC
	;DMARCH ROUTINE TO GET THE FIRST BLOCK OF A FILE
FSTBLK:	MOV #DSKBUF,B
	JSR PC,DSKRED
	ADD #6,P	;CROCK!!!
			;POP OUT OF FSTBLK, DOBLOK, @LOADX(B), DMARCH
	RTS PC		;BACK TO JSR PC,DMARCH


L1BLKF:	MOV #L1BLK,BLOKDO	;LOAD A ONE-BLOCK FILE
	JSR PC,EDMARCH
	MOV #DSKBUF+2000,B
	JSR PC,FNDEOF
	RTS PC		;B POINTS TO END OF FILE

L1BLK:	MOV #ER1BLK,BLOKDO
	MOV #DSKBUF,B
	JSR PC,DSKRED
	RTS PC

ER1BLK:	ERROR ^/DESCR FILE TOO LONG/
	BPT
	BR .-2
BITSIO:	JSR PC,EDMARCH	;CALLED BEFORE AND AFTER BCOMP
	CMP BITSAT,BITLIM	;TO I/O THE BIT TABLE
	BLO .+4
	RTS PC
	ERROR ^/BIT TABLE TOO SHORT/
	RTS PC


BITSRD:	MOV #DSKBUF,B	;READ IN FIRST BLOCK OF BIT TABLE
	JSR PC,DSKRED

	PUSH C
	MOV #777,C	;BLT 1000-1 WORDS
	MOV #DSKBUF+2,A	;SKIPPING BLKLIM WORD
	MOV #DBITS2,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #1776,BITSAT	;WE'VE READ IN THIS MANY BYTES
	MOV #BITSR2,BLOKDO	;NEXT BLOCK, DO THIS
	RTS PC

BITSR2:	CMP BITSAT,BITLIM	;READ IN NEXT BLOCK IF NOT OVERSHOT
	BLO BITSR3
	ERROR ^/BIT TABLE TOO LONG/

BITSR3:	MOV #DSKBUF,B
	JSR PC,DSKRED

	PUSH C
	MOV #1000,C	;BLT 1000 WORDS
	MOV #DSKBUF,A
	MOV #DBITS2,B
	ADD BITSAT,B	;TO CURRENT PLACE IN BIT TABLE 2
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	ADD #2000,BITSAT	;WE READ IN THIS MANY MORE BYTES
	RTS PC

BITSWR:	MOV BLKLIM,DSKBUF	;WRITE FIRST BLOCK OF BIT TABLE:
				;FIRST WORD IS # BLOCKS ON DISK
	PUSH C
	MOV #777,C
	MOV #DBITS1,A	;BLT TABLE 1 TO DSKBUF+2, 1000-1 WORDS
	MOV #DSKBUF+2,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #DSKBUF,B
	JSR PC,DSKWRT	;WRITE THE BLOCK

	MOV #1776,BITSAT	;THIS MANY BYTES TRANSFERED
	MOV #BITSW2,BLOKDO	;DO THIS TO NEXT BLOCK
	RTS PC

BITSW2:	CMP BITSAT,BITLIM	;WRITE NEXT BLOCK UNLESS OVERSHOT
	BLO BITSW3
	ERROR ^/BIT TABLE TOO LONG/

BITSW3:	PUSH C
	MOV #1000,C	;NOW BLT 1000 MORE WORDSG OUT
	MOV #DBITS1,A
	ADD BITSAT,A	;FROM WHERE YOU LEFT OFF
	MOV #DSKBUF,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #DSKBUF,B
	JSR PC,DSKWRT	;WRITE THE BLOCK

	ADD #2000,BITSAT	;YOU'VE DONE THIS MANY MORE BYTES NOW
	RTS PC
	;COMPLAIN ABOUT OLD BIT TABLE
BAD01:	JSR PC,CLOS10
	JSR PC,OPEN01
	DEC CHECKD	;WORLD MUST CHECK OUT BEFORE YOU CAN DELETE
	RTS PC

BAD10:	JSR PC,CLOS01
	JSR PC,OPEN10
	DEC CHECKD	;DITTO
	RTS PC

BCGOOD:	JSR PC,CLOS01
	JSR PC,CLOS10
	RTS PC


OPEN01:	TSTB RNG01F	;IS THIS RANGE ALREADY OPEN?
	BNE OPN01B
	JSR PC,BBFOUN
	JSR PC,RNGEDG	;NO, TYPE ITS OPENING NUMBER
	INCB RNG01F	;ASSERT JUST OPENED
	RTS PC
OPN01B:	CMPB #2,RNG01F
	BGE .+6
	INCB RNG01F	;ASSERT LONG RANGE
	RTS PC		;(OR ALREADY LONG RANGE)

OPEN10:	TSTB RNG10F	;IS THIS RANGE OPEN?
	BNE OPN10B
	JSR PC,BBFOUN	;BAD BIT FOUND: SET RANYBQ ("ANY BADBIT?")
	JSR PC,TAB	;NO, GO TO 1->0 COLUMNL
	JSR PC,RNGEDG	;AND TYPE ITS OPENING NUMBER
	INCB RNG10F	;ASSERT NOW JUST OPENED
	RTS PC
OPN10B:	CMPB #2,RNG10F
	BGE .+6
	INCB RNG10F	;NEW LONG RANGE
	RTS PC

BBFOUN:	TST RANYBQ	;FIRST BAD BIT?
	BEQ .+4
	RTS PC		;NO
	TYPEIT ^/_0 -> 1  1 -> 0_/
	INC RANYBQ	;NO MORE FIRST BAD BITS.
	RTS PC

CLOS01:	DECB RNG01F	;IS THIS RANGE MORE THAN 1 LONG?
	BLE CLS01B	;NO, JUST CLEAR IT.
	TST RANYBQ
	BNE .+4
	BPT		;SHOULDN'T CLOSE IF NOT OPENED!!
	TYPEIT ^/  TO_/	;ELSE STATE IT'S A LONG RANGE
	DEC C
	JSR PC,RNGEDG	;AND IT ENDS 1 BEFORE HERE
	INC C
CLS01B:	CLRB RNG01F	;AND CLEAR IT
	RTS PC

CLOS10:	DECB RNG10F	;IS THIS RANGE MORE THAN JUST BEGUN?
	BLE CLS10B	;NO, JUST CLEAR ITL
	TST RANYBQ
	BNE .+4
	BPT		;NOT IF NOT OPENED!
	JSR PC,TAB	;ELSE (IN 1->0 COLUMN)
	TYPEIT ^/  TO_/	;STATE IT'S A LONG RANGE
	JSR PC,TAB
	DEC C
	JSR PC,RNGEDG	;AND IT ENDS 1 BEFORE HERE
	INC C
CLS10B:	CLRB RNG10F	;AND CLEAR IT
	RTS PC


TAB:	TYPEIT ^/        /	;6 SPACES + 2 FOR MARGIN
	RTS PC

RNGEDG:	PUSH A
	PUSH B
	MOV C,B		;TYPE OUT BLOCK NUMBER IN C
	JSR PC,OCTOUT	;(MAY BE DIDDLED)
	JSR PC,CRLF
	POP B
	POP A
	RTS PC
	.STITL CRUNCH A DIRECTORY
DOROOT:	JSR PC,DODIRA	;DO THE DIRECTORY AS USUAL
	MOV DOWHAT,A	;EXCEPT WHEN IT COROUTINES BACK
			;AFTER DOING THE HEADER,
	JSR PC,@BITS(A)	;ALSO SET/CHECK THE HEADER'S BLOCK BITS.
	JSR PC,@(P)+	;NOW RETURN TO DODIRA
	RTS PC		;AND WHEN IT RETURNS, YOU'RE ALL DONE.

DODIR:	JSR PC,DODIRA	;DO THE DIRECTORY
	JSR PC,@(P)+	;DOING NOTHING EXTRA AFTER THE HEADER
	RTS PC		;AND DONE

DODIRA:	JSR PC,LOADIR	;USES PUSHED ENTRY ON F-STACK,
			;SETS DIREND
	MOV #DIR,ENTRYP
	JSR PC,TYPEWD	;SETS E,TYPE,NBYTES,NXNTRY,FLAGS,DSCEND
	CMP #HEADER,ETYPE	;HEADER ENTRY?
	BEQ DODIR1
	ENTERR ^/ FIRST BUT NOT HEADER/	;BUT PRETEND IT IS
DODIR1:	MOV DOWHAT,A
	JSR PC,@(A)	;PROCESS THE HEADER
	JSR PC,@(P)+	;COROUTINE WITH NEXT LEVEL UP--
			;ASK TO DO AFTER THE HEADER.

DOENTRY::	CMP NXNTRY,DIREND
	BEQ DODONE	;HIT END OF DIRECTORY
	BLO DOENT3
	ENTERR ^/ OVERSHOT DIRECTORY END/
	BPT
	BR .-2

DOENT3:	MOV ENTRYP,OENTRY	;SAVE LAST ENTRY POINTER
	JSR PC,TYPEWD	;GET LAST ENTRY'S TYPE AND FLAGS AGAIN!
	MOV ETYPE,OTYPE	;SAVE THEM
	MOV FLAGS,OFLAGS

	MOV NXNTRY,ENTRYP	;NOW FOR NEXT ENTRY!!
	JSR PC,TYPEWD
	CMP #HEADER,ETYPE
	BNE DOENT2	;CAN'T HAVE TWO HEADERS
	ENTERR ^/ IS 2ND HEADER ENTRY/
	BR DODONE	;PRETEND END OF DIR
DOENT2:	MOV DOWHAT,A	;CHECK ALPHABETICAL ORDER (ON PASS 1)
	JSR PC,@ALFORQ(A)	;ALWAYS SKIPS NAME AND VERSION NUMBER
	JSR PC,SKPACC
	MOV DOWHAT,A
	ADD ETYPE,A	;DISPATCH ON TYPE OF ENTRY
	JSR PC,@(A)	;PROCESS THIS ENTRY
	BR DOENTRY

DODONE:	JSR PC,PUTDIR	;IF DIRECTORY MODIFIED, REWRITE IT.
	RTS PC
	.STITL PASS 1 CRUNCH-ENTRY ROUTINES
CKHEAD:	MOV FBACKP,D	;GET OWN DIRECTORY ENTRY (ON STACK)
	MOV D,C
	ADD #FENTRY+2,C	;GET NAME FROM ENTRY
	JSR PC,CMPNAM	;(COMPARE NAMES IN (C)++ AND (E)++)
	BEQ CKHED1
	ENTERR ^/: HEADER DOES NOT HAVE DIRECTORY'S NAME/
CKHED1:	JSR PC,SKIPVN
	JSR PC,SKPACC

	JSR PC,ATDESC	;SET DDESCR (=OFFSET), DBYTES FOR HEADER DESCR
			;(DESCRIBES PARENT)
	BVC .+4
	RTS PC		;GIVE UP IF ATDESC DOES
	MOV (D),D	;GO TO PARENT'S DIR ENTRY (TWO UP IN STACK)
	MOV D,C
	ADD #FENTRY,C	;GO TO START OF ENTRY
	ADD FDDESC(D),C	;AND TO START OF DESCRIPTOR
	MOV DBYTES,A	;DESCRIPTOR LENGTH FOR HEADER
	MOV FDBYTES(D),B	;AND PARENT
	BEQ PDONE
	TST A
	BEQ HDONE
CMPDSC:	CMPB (C)+,(E)+
	BNE DSCERR	;AS LONG AS > 0 CHARS EXPECTED ON BOTH
	DEC B
	BEQ PDONE
	SOB A,CMPDSC
HDONE:	TSTB (C)+	;HEADER DONE, PARENT NOT; PAR. CHAR MUST BE 0
	BNE DSCERR
	DEC B		;AND ONLY ONE SUCH EXTRA CHAR.
	BEQ CKHWIN
DSCERR:	ERROR ^/HEADER DESCR DOESN'T DESCRIBE PARENT./
	RTS PC

PDONE:	DEC A		;PARENT DONE, DON'T KNOW ABOUT HEADER:
	BEQ CKHWIN	;IT'S DONE, TOO.
	TSTB (E)+	;MORE HEADER:  SAME THING AS HDONE.
	BNE DSCERR
	DEC A
	BNE DSCERR

CKHWIN:	RTS PC

C2HEAD:	JSR PC,SKPNAM
	JSR PC,SKIPVN
	JSR PC,SKPACC
	JSR PC,ATDESC
	RTS PC
C2LINK:
CKLINK:	ENTERR ^/ IS A LINK; FEATURE NOT IMPLEMENTED/
	RTS PC

C2FILE:
CKFILE:	JSR PC,ATDESC	;SET DDESCR AND DBYTES FOR DESCRIPTOR
	BVC .+4
	RTS PC		;GIVE UP IF ATDESC DOES
	JSR PC,LENFIL	;CHECK FOR REASONABLE LENGTH OF FILE
	MOV DOWHAT,A
	JSR PC,@BITS(A)	;SET BITS IN TABLE 1; IF SET, SET TABLE 2
	RTS PC		;ALL DONE!!

C2DIR:
CKDIR:	JSR PC,ATDESC	;DDESCR AND DBYTES
	BVC .+4
	RTS PC		;GIVE UP IF ATDESC DOES
	MOV DOWHAT,A
	JSR PC,@BITS(A)	;SET BITS
	JSR PC,PUTDIR	;REWRITE DIRECTORY IF MODIFIED
	JSR PC,PSHDIR	;PUSH THIS ENTRY ONTO THE F-STACK
	JSR PC,DODIR	;CRUNCH THE DIRECTORY
	JSR PC,POPDIR	;POP ENTRY
	JSR PC,LOADIR	;RELOAD CURRENT DIRECTORY
	RTS PC



CP1DIR:	JSR PC,ATDESC
	BVC .+4
	RTS PC
	JSR PC,PSHDIR
	MOV #NDIR,ENTRYP
	MOVB NDIR+1,FLAGS
	MOV #NDIR+2000,B
	JSR PC,FNDEOF
	MOV B,DIREND
	JSR PC,TYPEWD
	JSR PC,CRENT	;CREATE ENTRY IN CURRENT DIRECTORY IN NDIR
	MOV NDBLKN,A
	MOV #NDIR,B
	JSR PC,NDKWR1
	JSR PC,GTDATA
	JSR PC,NPUSHD
	JSR PC,CRDIR	;CREATE NEW DIRECTORY IN NDIR
	JSR PC,DODIR
	MOV NDBLKN,A
	MOV #NDIR,B
	JSR PC,NDKWR1
	JSR PC,NPOPDR
	MOV #NDIR,B
	MOV NDBLKN,A
	JSR PC,NDKRD1
	JSR PC,POPDIR
	JSR PC,LOADIR
	RTS PC

CRENT:	MOV FBACKP,F
	MOV DIREND,E
	MOV FDDESC(F),D
	ADD #FENTRY,F
	CMP #46,NDBLKN
	BEQ CRENT1
CRENT2:	MOVB (F)+,(E)+
	SOB D,.-2
	MOV #1,D
	JSR PC,GRBLK
	SUB DIREND,E
	ROR E
	BCC CRENT3
	ERROR ^/ODD NO. OF BYTES AT DESC/
CRENT3:	BICB #LENFLD,@DIREND
	BISB E,@DIREND
	ROL E
	SUB E,NDEND
	MOV DIREND,ENTRYP
	ADD E,DIREND
	CLR @DIREND
	RTS PC

CRENT1:	MOV NXNTRY,ENTRYP
	MOV F,C
	ADD #2,C
	JSR PC,ALFSRT
	MOV DIREND,A
	SUB ENTRYP,A
	ASR A
	PUSH A
	BEQ CRENT4
	MOV DIREND,E
	MOV #NDEND,B
	MOV -(E),-(B)
	SOB A,.-2
CRENT4:	PUSH B
	MOV ENTRYP,E
	MOVB (F)+,(E)+
	SOB D,.-2
	MOV #1,D
	JSR PC,GRBLK
	MOV E,B
	SUB ENTRYP,B
	ASR B
	BIC #LENFLD,@ENTRYP
	BIS B,@ENTRYP
	POP B
	POP A
	BEQ CRENT5
	MOV (B)+,(E)+
	SOB A,.-2
CRENT5:	CMP E,#NDIR+2000
	BLO CRENT6
	ERROR ^/DIRECTORY OVERFLOW/
CRENT6:	MOV #NDIR+2000,NDEND
	SUB E,NDEND
	CLR (E)
	MOV E,DIREND
	RTS PC


GRBLK:	MOV #NDIR+2000,NXDSC
	MOV NFBLKP,B
	CLR BLOKNO
	CLR C
	PUSH E
	JSR PC,GRBCNT
	POP D
	PUSH E
	SUB D,E
	MOV #BTSET1,BLOKDO
	JSR PC,DMARCH
	POP E
	BIT #1,E
	BEQ GRBLK1
	MOVB #0,(E)+
GRBLK1:	RTS PC

DISTGT:	CLR A
DIST1:	INC A
	JSR PC,BTSTST
	BNE DIST1
	RTS PC

CRDSC:	PUSH E
	PUSH B
	MOV #NDIR1,E
	MOV B,BLOKNO
	MOV A,B
	JSR PC,GRBDSC
	MOV E,B
	SUB #NDIR1,B
	MOV NXDSC,A
	MOVB -(E),-(A)
	SOB B,.-2
	MOV A,NXDSC
	POP B
	INC B
	POP E
	CLR BLOKNO
	JSR PC,GRBCNT
	MOV NXDSC,A
	MOV #NDIR1+2000,B
	SUB A,B
	MOVB (A)+,(E)+
	SOB B,.-2
	RTS PC


GRBSKP:	JSR PC,DISTGT
	JSR PC,CRDSC
	RTS PC


GBCNT:	PUSH C
	BIC #177700,C
	SUB C,(P)
	ADD C,BLOKNO
	INC BLOKNO
	ADD #DTCNT,C
	MOVB C,(E)+
	POP C
	RTS PC

GBSKP:	BIC #177700,B
	ADD B,BLOKNO
	ADD #DTSKP,B
	MOVB B,(E)+
	CLR B
	DEC C
	RTS PC


GRBCNT:	DEC B
	JSR PC,BTSTST
	BEQ GRBCN1
	TST C
	BEQ GRBCNT
	BR GRBSKP
GRBCN1:	INC C
	SOB D,GRBCNT
	MOV B,NFBLKP
GRBDSC:	PUSH #GRBRET
GRBDS1:	DEC C
	TST B
	BEQ GBCNT
	CMP B,#10
	BLT GBSKCN
	CMP B,#100
	BLT GBSKP
	BR GBSADR
GRBRET:	TST C
	BGT GRBDSC
	RTS PC


GBSADR:	ADD BLOKNO,B
	MOV B,BLOKNO
	PUSH C
	BIC #177700,C
	ADD C,BLOKNO
	INC BLOKNO
	SUB C,(P)
	ADD #DTSADR,C
	MOVB C,(E)+
	MOVB B,(E)+
	SWAB B
	MOVB B,(E)+
	CLR B
	POP C
	RTS PC

GBSKCN:	PUSH C
	BIC #177770,C
	ADD C,BLOKNO
	INC BLOKNO
	SUB C,(P)
	ADD #DTSKCT,C
	ADD B,BLOKNO
	ASH #3,B
	BIC #177707,B
	ADD B,C
	MOVB C,(E)+
	CLR B
	POP C
	RTS PC


CRDIR:	MOV FBKP1,F
	MOV #NDIR,E
	MOV FDDESC(F),D
	PUSH F
	ADD #FENTRY,F
	MOVB (F)+,(E)+
	SOB D,.-2
	POP F
	MOV (F),F
	MOV FDBYTES (F),D
	MOV FDDESC(F),B
	ADD #FENTRY,F
	ADD B,F
	MOVB (F)+,(E)+
	SOB D,.-2
	CLRB NDIR
	MOV NFBLKP,NDBLKN
	MOV #2000,NDEND
	BIT #1,E
	BEQ CRDIR1
	MOVB #0,(E)+
CRDIR1:	CLR (E)
	SUB #NDIR,E
	ROR E
	BISB E,NDIR
	ROL E
	SUB E,NDEND
	RTS PC



CP2DIR:	JSR PC,ATDESC
	BVC .+4
	RTS PC
	JSR PC,PSHDIR
	MOVB NDIR+1,FLAGS
	MOV #NDIR+2000,B
	JSR PC,FNDEOF
	MOV B,DIREND
	MOV ENTRYP,TOFIND
	ADD #2,TOFIND
	MOV #NDIR,ENTRYP
	JSR PC,FINDE1
	BEQ CP2DI1
	BUG ^/DIRECTORY NOT FOUND ON SECOND PASS/
CP2DI1:	JSR PC,NLDIR
	JSR PC,DODIR
	JSR PC,POPDIR
	MOV NDBLKN,A
	MOV #NDIR,B
	JSR PC,NDKRD1
	JSR PC,LOADIR
	RTS PC

NLDIR:	PUSH WCHDSK
	MOV NDISK,WCHDSK
	MOV #NLDIR1,BLOKDO
	MOV DBYTES,E
	MOV E,A
	MOV DDESCR,D
	ADD ENTRYP,D
	MOV #NDIR1,B
	MOVB (D)+,(B)+
	SOB A,.-2
	MOV #NDIR1,D
	JSR PC,DMARCH
	POP WCHDSK
	RTS PC

NLDIR1:	MOV #ER1BLK,BLOKDO
	MOV #NDIR,B
	MOV BLOKNO,NDBLKN
	JSR PC,DSKRED
	RTS PC

CKROOT:	MOV #BITSE,C
	MOV ENTRYP,E
	ADD #2,E
	PUSH E
	JSR PC,CMPNAM
	BEQ CKROT1
	MOV #DESCRE,C
	MOV (P),E
	JSR PC,CMPNAM
	BEQ CKROT1
	POP E
	RTS PC
CKROT1:	POP E
	TST (P)+	;DESTROY RETURN ADDRESS
	POP DIREND
	POP ENTRYP
	POP NXNTRY
	RTS PC		;BACK TO DOENTRY



CPFIL:	JSR PC,ATDESC
	BVC .+4
	RTS PC
	PUSH NXNTRY
	PUSH ENTRYP
	PUSH DIREND
	CMP #46,NDBLKN
	BNE CPFIL5
	JSR PC,CKROOT
CPFIL5:	JSR PC,FILLEN
	CMP #3000,B
	BGT CPFIL1
	ERROR ^/FILE TO LONG (> 300 BLOCKS)/
CPFIL1:	PUSH ENTRYP
	PUSH DDESCR
	PUSH B
	MOV #NDIR,ENTRYP
	MOV #NDIR+2000,B
	MOVB NDIR+1,FLAGS
	JSR PC,FNDEOF
	MOV B,DIREND
	JSR PC,TYPEWD
	MOV NXNTRY,ENTRYP
	MOV 4(P),C
	ADD #2,C
	JSR PC,ALFSRT
	POP D		;BLOCK COUNT FOR FILE
	POP B		;OLD DDESCR IN B
	POP C		;IS OLD ENTRYP
	MOV DIREND,A
	SUB ENTRYP,A
	ASR A
	PUSH A
	BEQ CPFIL4
	MOV DIREND,E
	MOV #NDEND,F
	MOV -(E),-(F)
	SOB A,.-2
CPFIL4:	PUSH F
	MOV ENTRYP,E
	MOVB (C)+,(E)+
	SOB B,.-2
	JSR PC,GRBLK
	MOV #-1,(E)+
	MOV #-1,(E)+
	MOV E,B
	SUB ENTRYP,B
	ASR B
	BIC #LENFLD,@ENTRYP
	BIS B,@ENTRYP
	POP F
	POP A
	BEQ CPFIL3
	MOV (F)+,(E)+
	SOB A,.-2
CPFIL3:	CMP E,#NDIR+2000
	BLT CPFIL2
	ERROR ^/DIRECTORY OVERFLOW/
CPFIL2:	MOV #NDIR+2000,NDEND
	SUB E,NDEND
	CLR (E)
	MOV NDBLKN,A
	MOV #NDIR,B
	JSR PC,NDKWR1
	MOV #NDIR+2000,DIREND
	SUB NDEND,DIREND
	JSR PC,GTDATA
	MOV #NDIR1,NXBKNO
	MOV #LSTBLK,BLOKDO
	JSR PC,EDMARCH
	MOV NXBKNO,MXBKNO
	POP DIREND
	POP ENTRYP
	POP NXNTRY
	JSR PC,GTDATA
	MOV #NDIR1,NXBKNO
	MOV #TRNSBK,BLOKDO
	JSR PC,EDMARCH
	RTS PC

LSTBLK:	MOV BLOKNO,@NXBKNO
	ADD #2,NXBKNO
	CMP NXBKNO,#DBITS1
	BEQ .+4
	RTS PC
	ERROR ^/OVERPUSH ON BLOCK LISTING/
	BPT
	BR .-2


TRNSBK:	MOV #DSKBUF,B
	JSR PC,DSKRED
	MOV @NXBKNO,A
	ADD #2,NXBKNO
	CMP NXBKNO,MXBKNO
	BLOS TRNS1
	ERROR ^/OVERPOP ON BLOCK LISTING/
TRNS1:	JSR PC,NDSKWR
	RTS PC




GTDATA:	JSR PC,TYPEWD
	JSR PC,SKPNAM
	JSR PC,SKIPVN
	JSR PC,SKPACC
	JSR PC,ATDESC
	RTS PC



	.STITL WALK-THROUGH-AN-ENTRY ROUTINES
TYPEWD:	;GIVEN AN ENTRYP, GETS TYPE, NBYTES, NXNTRY, FLAGS, AND DSCEND
	;AND SETS E POINTING TO THE FIRST CHAR OF THE NAME.

	MOV ENTRYP,E
	MOVB (E),A
	BIC #-TYPFLD-1,A
	ASH #-5,A
	MOV A,ETYPE	;GET TYPE * 2

	MOVB (E)+,A
	BIC #-LENFLD-1,A
	ROL A		;WORD COUNT TO BYTE COUNT
	MOV A,NBYTES

	ADD ENTRYP,A
	CMP A,DIREND
	BLOS TYPEW2
	ENTERR ^/ OVERFLOWS DIRECTORY/
	MOV DIREND,A	;MAKE NXNTRY = DIREND
TYPEW2:	MOV A,NXNTRY

	CMP #FILE,ETYPE
	BNE .+4
	CMP -(A),-(A)	;FILE ENTRIES HAVE DATE & TIME AT END
	MOV A,DSCEND	;POINTS TO END OF DESCRIPTOR

	MOVB (E)+,A	;GET FLAGS BYTES
	MOV A,FLAGS
	BITB #WRDLFT,A	;DON'T ALLOW BOTH WORD AND BYTE LEFT
	BNE .+4
	RTS PC
	BITB #BYTLFT,A
	BNE .+4
	RTS PC
	ENTERR ^/: BOTH WORD & BYTE LEFT/
	RTS PC

SKPNAM:	JSR PC,EBYTE	;GET BYTE OF ENTRY
	BVS NAMERR	;COMPLAIN ON ENTRY OVERFLOW
	TSTB A		;IS THE CHAR FLAGGED?
	BGE SKPNAM	;SKIP TO NEGATIVE BYTE (LAST OF NAME)
	RTS PC

CMPNAM:	JSR PC,EBYTE
	BVS NAMERR
	CMPB (C)+,A
	BNE CMPNMF	;MISMATCH
	TSTB A
	BGE CMPNAM	;200 BIT ENDED BOTH NAMES
	SEZ
	RTS PC		;RETURN WITH Z-BIT SET
CMPNMF:	TSTB A
	BLT .+6
	JSR PC,SKPNAM
	CLZ
	RTS PC
NAMERR:	ENTERR ^/: NAME OVERFLOWS ENTRY/
	CLZ
	RTS PC

ALFCMP:	JSR PC,EBYTE
	TSTB (C)
	BLT ALFCM1
	CMPB (C)+,A
	BEQ ALFCMP
	RTS PC
ALFCM1:	BICB #200,A
	MOVB (C),B
	BICB #200,B
	CMPB B,A
	RTS PC



SKIPVN:	BIT #VNF,FLAGS	;VERSION NUMBER EXISTS?
	BNE .+4
	RTS PC
	JSR PC,EBYTE
	BVS SKPVNE
	JSR PC,EBYTE
	BVC SKPVN1
SKPVNE:	ENTERR ^/: VN OVERFLOWS ENTRY/
SKPVN1:	RTS PC

SKPACC:	BIT #ACCF,FLAGS	;ACCESS SHOULD NOT APPEAR AT FIRST
	BNE .+4
	RTS PC
	ENTERR ^/: ACCESS CODES FOUND/
SKPAC2:	JSR PC,EBYTE	;GOOD ACCESS CODES COME IN THREES
	BVS SKPACE
	JSR PC,EBYTE
	BVS SKPACE
	JSR PC,EBYTE
	BVS SKPACE
	TSTB A	;NEG. THIRD BYTE IS LAST TRIPLET
	BGE SKPAC2
	RTS PC
SKPACE:	ENTERR ^/: ACCESS OVERFLOWS ENTRY/
	RTS PC

ATDESC:	MOV E,DDESCR
	SUB ENTRYP,DDESCR	;GET OFFSET OF DESCRIPTOR IN ENTRY
	MOV DSCEND,DBYTES
	SUB E,DBYTES	;AND LENGTH OF DESCRIPTOR
	BLE .+4
	RTS PC
	ENTERR ^/: NO ROOM FOR DESCRIPTOR/
	SEV
	RTS PC

EBYTE:	MOVB (E)+,A	;GET A BYTE OF ENTRY
	CMP DSCEND,E	;COMPLAIN ON OVERFLOW
	BHIS .+4
	SEV
	RTS PC
	;THIS ENTRY MUST FOLLOW THE LAST IN ALPHABETICAL ORDER


ALFSR1:	POP C
	MOV NXNTRY,ENTRYP
ALFSRT:	CMP ENTRYP,DIREND
	BEQ ALFSR2
	JSR PC,TYPEWD
	MOV ENTRYP,OENTRYP
	PUSH C
	JSR PC,ALFCMP
	BGT ALFSR1
	POP C
ALFSR2:	RTS PC



ALFORD:	CMP #HEADER,OTYPE ;DON'T COMPARE IF LAST ENTRY WAS HEADER
	BNE ALFOR1	;OTHERWISE DO COMPARE
SKNMVN:
AOSKNM:	JSR PC,SKPNAM
AOSKVN:	JSR PC,SKIPVN	;JUST SKIP NAME AND VERSION NUMBER
	RTS PC

ALFOR1:	MOV OENTRY,A	;LAST NAME TO THE STARTING LINE
	TST (A)+	;(SKIP TYPE AND FLAGS)
ALFOR2:	MOVB (A),B
	BIC #177600,B
	MOVB (E),C
	BIC #177600,C
	CMP B,C
	BLE ALFOR3	;CHAR OF OLD =< CHAR OF NEW?
	JSR PC,ALFORE	;NO, OUT OF ORDER
	BR AOSKNM	;SKIP NAME AND VN
ALFOR3:	BLT AOSKNM	;OLD DEFINITELY < NEW: SKIP NAME AND VN
	TSTB (A)+	;LAST CHAR OF OLD?
	BLT ALFOR4	;YES, MAY BE GOOD
	TSTB (E)+	;LAST OF NEW?
	BGE ALFOR2	;NO, KEEP CHECKING.
ALFOE1:	JSR PC,ALFORE	;YES, NO GOOD
	BR AOSKVN	;NAME IS SKIPPED

ALFOR4:	TSTB (E)+	;LAST OF OLD SEEN: LAST OF NEW?
	BGE AOSKNM	;NO, ORDER OK; SKIP NAME AND VN.
;NAMES EQUAL: CHECK VERSION NUMBERS
	BIT #VNF,FLAGS	;NEW HAS VN?
	BEQ ALFOE1	;NO, NO GOOD: NAMES = OR >.
	BIT #VNF,OFLAGS	;OLD HAS?
	BEQ AOSKVN	;NO, ORDER OK.
;BOTH HAVE VERSION NUMBERS
	MOVB (A)+,OVN
	MOVB (A)+,OVN+1
	MOVB (E)+,VN
	MOVB (E)+,VN+1
	CMP OVN,VN
	BGE .+4		;OLD >= NEW NO GOOD
	RTS PC
	JSR PC,ALFORE
	RTS PC

ALFORE:	ENTERR ^/ OUT OF ORDER/
	RTS PC
	.STITL PUSH AND POP DIRECTORY STACK
PSHDIR:	MOV NEXTF,F	;GET NEXT SLOT
	MOV FBACKP,(F)	;SAVE BACK POINTER FROM HERE
	MOV F,FBACKP	;AND BACK POINTER TO HERE
	TST (F)+
	FPUSH ENTRYP	;FOR ALPHABETIZING
	FPUSH NXNTRY	;WHEN DONE WITH THIS DIRECTORY ENTRY
	FPUSH DDESCR	;OFFSET OF DESCRIPTOR IN SAVED ENTRY
	FPUSH DBYTES	;LENGTH OF DESCRIPTOR
	FPUSH NDBLKN		;FOR NOW, WILL BE CORRESPONDING BLOCK
			;ON OTHER DSK
	MOV ENTRYP,E
	MOV NBYTES,A
	ROR A		;PUSH ENTRY BY WORDS
	BCC PSHDR2
	ENTERR ^/: NBYTES WAS ODD?!?/
	BPT
	BR .-2
PSHDR2:	FPUSH (E)+	;NEXT WORD OF ENTRY
	SOB A,PSHDR2
	CMP F,#FEND-100
	BHIS .+10
	MOV F,NEXTF	;NEXT SLOT IS AFTER THE ENTRY
	RTS PC
	ERROR ^/OVERPUSH/
	BPT
	RTS PC


NPUSHD:	MOV NEXTF1,F	;GET NEXT SLOT
	MOV FBKP1,(F)	;SAVE BACK POINTER FROM HERE
	MOV F,FBKP1	;AND BACK POINTER TO HERE
	TST (F)+
	FPUSH ENTRYP	;FOR ALPHABETIZING
	FPUSH NXNTRY	;WHEN DONE WITH THIS DIRECTORY ENTRY
	FPUSH DDESCR	;OFFSET OF DESCRIPTOR IN SAVED ENTRY
	FPUSH DBYTES	;LENGTH OF DESCRIPTOR
	FPUSH NDBLKN		;FOR NOW, WILL BE CORRESPONDING BLOCK
			;ON OTHER DSK
	MOV ENTRYP,E
	MOV NBYTES,A
	ROR A		;PUSH ENTRY BY WORDS
	BCC NPSHDR
	ENTERR ^/: NBYTES WAS ODD?!?/
	BPT
	BR .-2
NPSHDR:	FPUSH (E)+	;NEXT WORD OF ENTRY
	SOB A,NPSHDR
	CMP F,#FEND-100
	BHIS .+10
	MOV F,NEXTF1	;NEXT SLOT IS AFTER THE ENTRY
	RTS PC
	ERROR ^/OVERPUSH/
	BPT
	RTS PC

NPOPDR:	CMP #FBASE1,FBKP1
	BLO NPPDR2
	BUG ^/OVERPOP?/
NPPDR2:	MOV FBKP1,F	;ENTRY IS POPPED
	MOV F,NEXTF1	;FREE POPPED SLOT
	MOV (F),FBKP1	;STEAL BACK POINTER OUT OF POPPED ENTRY
	MOV FNDBLN(F),NDBLKN
	RTS PC		;I THINK ALL THE REST PUSHED HAS BEEN USED.

POPDIR:	CMP #FBASE,FBACKP
	BLO POPDR2
	BUG ^/OVERPOP?/
POPDR2:	MOV FBACKP,F	;ENTRY IS POPPED
	MOV F,NEXTF	;FREE POPPED SLOT
	MOV (F),FBACKP	;STEAL BACK POINTER OUT OF POPPED ENTRY
	CMP F,ERNTRYP	;POPPED BACK TO ERRORSTUMP?
	BHI POPDR4	;ERRORSTUMP STILL BELOW YOU
	BEQ POPDR3	;SAW OFF ERRORLIMB AS YOU CLIMB BACK.
	BUG ^/ERRORLIMB LEFT HANGING??/
POPDR3:	MOV FBACKP,ERNTRYP	;MOVE IT DOWN THE STACK
POPDR4:	MOV FENTRP(F),ENTRYP	;GET OLD ENTRYP FOR ALPHABETICALS
	MOV FNXNTRY(F),NXNTRY	;AND NEXT ENTRYP
	MOV FNDBLN(F),NDBLKN
	RTS PC		;I THINK ALL THE REST PUSHED HAS BEEN USED.
	.STITL DISK-BLOCK FUNNIES (LOAD/REWRITE, SET/CHECK BIT TABLE)
;ALWAYS DO LOADIR, PUTDIR IN MATCHED PAIRS:
;LOADIR (DODIR)
;PUTDIR  (CKDIR.1)
; LOADIR (DODIR)
; PUTDIR (DODONE)
;LOADIR  (CKDIR.2)
;PUTDIR (DODONE)
;ETC.
;NOT NESTED PAIRS.  PUT THE DIR WHENEVER YOU'RE ABOUT TO LOAD ANOTHER
;AS AT CKDIR AND DODONE.
;THIS MAKES DIRCNG ACT PROPERLY AT PUTDIR.

PUTDIR:	TST DIRCNG	;REWRITE DIRECTORY IF MODIFIED
	BNE .+4
	RTS PC

	TYPEIT ^/REWRITING DIR /
	PUSH A
	JSR PC,BACKTR
	JSR PC,CRLF
	POP A

	MOV #DIRBLW,BLOKDO	;REWRITE DIRECTORY
	JSR PC,IODIR
	CLR DIREND
	RTS PC

LOADIR:	CLR DIRCNG	;USED IN NEXT PUTDIR
	MOV #DIRBLR,BLOKDO	;LOAD A DIRECTORY
	JSR PC,IODIR
	RTS PC

IODIR:				;FOR EACH BLOCK, LOAD OR PUT IT.
	MOV FBACKP,E	;GET DESCRIPTOR FROM PUSHED ENTRY
	MOV E,D		;SETUP DESCRIPTOR
	ADD #FENTRY,D
	ADD FDDESC(E),D
	MOV FDBYTES(E),E
	JSR PC,DMARCH	;CRUNCH DESCRIPTOR!!

	PUSH FLAGS
	MOV FBACKP,E
	ADD #FENTRY+1,E	;USE PUSHED DIRECTORY'S FLAGS
	MOVB (E),FLAGS

	MOV #DIR+2000,B	;GET START OF NEXT BLOCK
	JSR PC,FNDEOF
	MOV B,DIREND	;REAL END OF FILE (DIRECTORY)
	POP FLAGS
	RTS PC

FNDEOF:	BITB #BYTLFT,FLAGS	;IF BYTE LEFT, MINUS 1 FROM LAST ADDR
	BEQ FNDEO2
	DEC B
	BITB #WRDLFT,FLAGS
	BNE EOFERR	;NOT BOTH WORD AND BYTE LEFT!
	RTS PC
FNDEO2:	BITB #WRDLFT,FLAGS	;IF WORD LEFT,
	BNE .+4
	RTS PC
	CMP #2000,-2(B)
	BLO EOFERR
	CMP #2,-2(B)
	BHI EOFERR
	SUB -2(B),B	;SUBTRACT IT (# BYTES LEFT) FROM LAST ADDR
	RTS PC
EOFERR:	SEV
	RTS PC


SETB12:	;SET BITS IN BIT TABLE 1;
	;IF ONE ALREADY SET, SET IT IN BIT TABLE 2.
	MOV #BTS12,BLOKDO	;DO THIS FOR EACH BLOCK
	JSR PC,EDMARCH
	RTS PC

CKBIT2:	;CHECK BIT TABLE 2; IF ONE SET, RETURN NOT-EQUAL
	MOV #BTT2,BLOKDO	;FOR EACH BLOCK
	CLR BITFND	;IF ZERO ON RETURN, FILE OK.
	JSR PC,EDMARCH
	MOV ENTRYP,A
	INC A		;SET UP TO MUNG REAL FLAG BYTE
	TST BITFND
	BNE CKBIT3
	BITB #NODELF,(A)	;NO SHARED BLOCKS: CAREFUL-CLEAR NODELF
	BNE .+4
	RTS PC		;ALREADY CLEAR, DONE
	BICB #NODELF,(A)	;ELSE CLEAR IT AND SAY DIR. MODIFIED
	INC DIRCNG
	TYPEIT ^/ENTRY /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	TYPEIT ^/ NO LONGER SHARES BLOCKS, IS DELETABLE_/
	RTS PC
CKBIT3:	BITB #NODELF,(A)  ;SHARED BLOCKS: SET DON'T DELETE THEM FLAG
	BEQ .+4
	RTS PC		;ALREADY SET
	BISB #NODELF,(A)
	INC DIRCNG	;DIRECTORY CHANGED
	RTS PC
EDMARCH: MOV ENTRYP,D
	ADD DDESCR,D
	MOV DBYTES,E
	JSR PC,DMARCH	;DMARCH THIS ENTRY
	RTS PC

;DMARCH NEEDS (WHAT TO DO WITH EACH BLOCK) IN BLOKDO,
;	(ADDR OF DISK BLOCKS DESCRIPTOR) IN D,
;	AND (# BYTES OF DESCR) IN E.
DMARCH:	CLR BLOKNO
DNEXT:	MOVB (D)+,C	;BYTE OF DESCRIPTOR
	MOV C,B
	BIC #-DTYPEF-1,B
	ASH #-5,B
	JSR PC,@LOADX(B)	;CRUNCH DESCR BYTE
	SOB E,DNEXT
	RTS PC

;LOADX DISPATCHES TO THESE 4 ROUTINES
LODSKP:	BIC #-DTCNTF-1,C	;GET COUNT FIELD FOR SKIP
	BNE .+4		;"SKIP 0" = .BYTE 0; NO-OP, SPECIAL CASE.
	RTS PC
	ADD C,BLOKNO	;SKIP N BLOCKS
	JSR PC,DOBLOK	;CRUNCH ONE BLOCK
	RTS PC

LODCNT:	BIC #-DTCNTF-1,C	;GET COUNT FIELD
	INC C		;GET N+1 BLOCKS
LODCT2:	JSR PC,DOBLOK	;CRUNCH ONE BLOCK AFTER ANOTHER
	SOB C,LODCT2	;UNTIL N+1
	RTS PC

LODSAD:	CMP #3,E	;THREE BYTES LEFT?
	BGT LSADER	;NO, COMPLAIN
	MOVB (D)+,BLOKNO	;FROM NEXT TWO BYTES,
	MOVB (D)+,BLOKNO+1	;SET UP BLOCK NUMBER
	SUB #2,E
	BR LODCNT	;AND CRUNCH N+1 BLOCKS (N IN FIRST BYTE)
LSADER:	ENTERR ^/(?): NO ROOM FOR DESC. SET-ADDR/
	RTS PC

LODSC:	MOV C,B
	BIC #-DTSCSK-1,B
	ASH #-3,B	;SKIP N1 BLOCKS
	ADD B,BLOKNO
	BIC #-DTSCCT-1,C	;AND CRUNCH ONLY N2+1 BLOCKS
	BR LODCNT

DOBLOK:	CMP BLOKNO,BLKLIM	;IS IT ON THE DISK?
	BHIS DOBLER
	JSR PC,@BLOKDO
	INC BLOKNO
	RTS PC

DOBLER:	JSR PC,ERRORX
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ NOT ON DISK; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	RTS PC

ENTOUT:	TYPEIT ^/ENTRY = /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	RTS PC
RFBLK:	CMP #DISKWC,DISKIO
	BEQ RFBLK1
	MOV TRNSLE,DSKWC	;THE TRANSFER LENGTH
	MOV B,DSKCA	;THE BUSS ADRESS
	CLR A
	MOV BLOKNO,B
	ASHC #9.,A	;GET THE EXTENSION BITS
	MOV B,DSKA	;THE DISK ADRESS
	MOV A,DSKAE	;THE EXTENSION BITS
	MOV DISKIO,DSKS	;THE FUNCTION
	TSTB DSKS
	BGE .-4
RFBLK1:	POP B
	POP A
	TST DSKS
	BLT DBERR
	RTS PC


DBLERR:	ERROR ^/DIRECTORY TOO LONG/
	RTS PC
DIRBLR:	MOV #DBLERR,BLOKDO	;DIR'S ARE ONE BLOCK
	MOV #DIR,B
DSKRED:	MOV #DISKRD,DISKIO
DSKBLK:	MOV #NRETRY,RETRYS
DSKBL1:	MOV BLOKNO,SWB
	PUSH A
	PUSH B
	TST WCHDSK	;IS IT A RK11 DISK
	BMI RFBLK	;NOPE
	MOV TRNSLE,RKWC	;TRANSFER LENGTH
	MOV B,RKBA	;CORE ADDR
	MOV BLOKNO,B	;GET DISK ADDR
	ASL B		;DOUBLE IT:  2 SECTORS/BLOCK
	CLR A
	DIV #12.,A	;12 SECTORS/TRACK-SURFACE
	ASH #4,A
	ADD A,B		;ALL DONE FOR FIXED PLATTER
	ADD WCHDSK,B
	MOV B,RKDA	;DISK ADDR
	MOV DISKIO,RKCS	;START TRANSFER
	TSTB RKCS
	BGE .-4		;WAIT
	POP B
	POP A
	TST RKCS
	BLT DBERR
	RTS PC

DBERR:	DEC RETRYS
	BGT DSKBL1
DBERR2:	SUB #2,P	;CREATE A CELL
	PUSH A
	PUSH B
	TYPEIT ^/DISK /
	MOV WCHDSK,B
	ASH #-13.,B
	BIC #177770,B
	JSR PC,OCTOUT
	TYPEIT ^/ ERROR ACCESSING BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TST WCHDSK
	BMI DBERR3
	TYPEIT ^/_RKER = /
	MOV RKER,B
DBERR4:	MOV #1,RKCS	;POWER CLEAR THE DISK
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/(I)GNORE, (T)RY AGAIN OR (R)EWRITE_?/
	JSR PC,TYI1	;GET A CHAR
	MOV A,4(P)	;THE CELL CREATED ABOVE
	POP B
	POP A
	CMP #'I,(P)
	BNE .+6
	MOV #RTSPC,(P)
	CMP #'T,(P)
	BNE .+6
	MOV #DBERR5,(P)
	CMP #'R,(P)
	BNE .+6
	MOV #DSKWRT,(P)
	BITB #177,1(P)
	BEQ .+4
	JMP @(P)+
	BPT
	BR .-2


DBERR5:	CMP #DISKWC,DISKIO
	BEQ .+6
	JMP DSKBLK
	MOV #DISKWR,DISKIO
	JSR PC,DSKBLK
	MOV #DISKWC,DISKIO
	JMP DSKBLK


DBERR3:	SUB #2,P	;CREATE A WORK CELL
	PUSH A
	PUSH B
	TYPEIT ^/_DAE=/
	MOV DSKAE,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/DCS=/
	MOV DSKS,B
	BR DBERR4


DIRBLW:	MOV #DBLERR,BLOKDO
	MOV #DIR,B
DSKWRT:	PUSH A
	PUSH B
	TYPEIT ^/WRITING BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	POP B
	POP A
	MOV #3,RETRYV
DSKWR1:	MOV #DISKWR,DISKIO
	JSR PC,DSKBLK
	MOV #DISKWC,DISKIO
	JSR PC,DSKBLK
	BVS .+4
	RTS PC
	DEC RETRYV
	BGT DSKWR1
	JMP DBERR2

DBFRED:	PUSH BLOKNO
	MOV B,BLOKNO
	MOV #DSKBUF,B
	JSR PC,DSKRED
	POP BLOKNO
	RTS PC

DBFWRT:	PUSH BLOKNO
	MOV B,BLOKNO
	MOV #DSKBUF,B
	JSR PC,DSKWRT
	POP BLOKNO
	RTS PC

BREAD:	JSR PC,DBFRED	;THIS IS WHERE TO $G IN RUG;
	BPT 		;SET B TO BLOKNO FIRST.

BWRITE:	JSR PC,DBFWRT	;(SIM)
	BPT
BTADR:	MOV BLOKNO,B	;BLOKNO -> BIT TABLE BYTE OFFSET, BIT IN BYTE
BTADR1:	PUSH B
	BIC #177770,B
	MOV #1,A
	ASH B,A		;BIT IN BYTE
	POP B
	ASH #-3,B
	BIC #160000,B	;BYTE OFFSET
	RTS PC

BTSET1:	JSR PC,BTADR
	BISB A,DBITS1(B)
	RTS PC


BTSTST:	PUSH B
	JSR PC,BTADR1
	BITB A,DBITS1(B)
	BEQ BTST1
	POP B
	CLZ
	RTS PC
BTST1:	POP B
	SEZ
	RTS PC


BTSET:	PUSH B
	JSR PC,BTADR1
	BISB A,DBITS1(B)
	POP B
	RTS PC


BTS12:	;BIT TABLE SET
	JSR PC,BTADR
	BITB A,DBITS1(B)  ;1 CLEAR?
	BEQ BTS0.
	BISB A,DBITS2(B)  ;NO,SET 2
	RTS PC		;DONE
BTS0.:	BITB A,DBITS2(B)  ;1 CLEAR: 2 SET?
	BNE BTS01
	BISB A,DBITS1(B)  ;NO, JUST SET 1
	RTS PC
BTS01:	JSR PC,ERRORX	;1 CLEAR, 2 SET: RESERVED BLOCK
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ RESERVED; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	RTS PC

BTT2:	;BIT TABLE 2 TEST
	JSR PC,BTADR
	BITB A,DBITS2(B)  ;2 SET?
	BNE .+4
	RTS PC		;NO, GOOD
	JSR PC,ERRORX	;FILE HAS SHARED BLOCK.
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ SHARED; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	INC BITFND
	RTS PC
	.STITL ERROR ROUTINES
ERRORX:	DEC CHECKD	;WORLD MUST BE CLEAN TO DO A DELETE
	PUSH A
	JSR PC,ERFROM	;TYPE ADDRESS OF ERROR CALL
	POP A
	JSR PC,@(P)+	;CALL BACK TO TYPE ERROR MESSAGE
	PUSH A
	JSR PC,CRLF
	JSR PC,BACKTR	;PRINT BACK TRACE OF DIRECTORY TREE
	.IFZ 1
	TYPEIT ^/_GO ON?  /
	JSR PC,TYI1
	CMP #15,A
	BEQ ERRX1
	CMP #'Y,A
	BNE ERRX2
	.ENDC
	JSR PC,CRLF
ERRX1:	POP A
	RTS PC
ERRX2:	BPT
	JMP SALV

TXTYPE:	PUSH A
TXTYP2:	MOVB (F)+,A	;TYPE MESSAGE
	BEQ TXTYP3
	CMP #'_,A
	BNE .+6
	MOV #15,A	;PRINT CRLF FOR _
	JSR PC,TYPE
	BR TXTYP2
TXTYP3:	INC F		;RETURN-ADDR IS TO AFTER STRING
	BIC #1,F
	POP A
	RTS F


BACKTR:	TYPEIT ^/IN DIR /
	CMP #FBASE,NEXTF
	BNE BKTR0
	TYPEIT ^/(NIL)/
	RTS PC		;NO BACKTRACE
BKTR0:	PUSH B
	MOV #FBACKP,BKFBKP  
BKTR1:	MOV @BKFBKP,B	;CLIMB DOWN TREE TO A BRANCH YOU'VE SEEN BEFORE
	MOV B,BKFBKP
	ADD #FENTRY,B
	JSR PC,NAMOUT	;TYPE DIRECTORY NAME
	CMP BKFBKP,ERNTRYP	;FOUND OLD ERRORSTUMP?
	BEQ BKTR2
	MOV #'<,A	;NO, KEEP GOING
	JSR PC,TYPE
	BR BKTR1
BKTR2:	MOV FBACKP,ERNTRYP	;YES, DONE; MAKE THIS THE ERRORTWIG.
	POP B	  ;;;WHEN POPDIR POPS THE ERRORLIMB IT SAWS IT OFF.
	RTS PC


ERFROM:	PUSH B
	MOV 6(P),B	;GET ERROR RETURN ADDRESS:  A PUSH A,
			;ANOTHER JSR AND A PUSH B ARE ON TOP OF IT NOW
	SUB #4,B	;GET REAL JSR PC,ERRORX ADDR.
	JSR PC,OCTOUT
	MOV #' ,A
	JSR PC,TYPE
	POP B
	RTS PC

OCTOUT:	PUSH C
	MOV #6,C
	CLR A
	ASHC #1,A	;FIRST DIGIT IS TOP BIT
OCOLUP:	ADD #'0,A
	JSR PC,TYPE
	CLR A
	ASHC #3,A
	SOB C,OCOLUP	;PRINT 6 DIGITS
	POP C
	RTS PC


DECOUT:	PUSH C
	CLR C		;0 DIGITS SO FAR
	TST B
	BEQ DECOT0	;TYPE 0
DECOT1:	INC C		;NEXT DIGIT:
	CLR A
	DIV #10.,A
	PUSH B		;PUSH REMAINDER
	MOV A,B		;# 10'S TO B
	BNE DECOT1	;UNTIL NO 10'S
DECOT2:	POP A		;POP A REMAINDER
	ADD #'0,A	;ENCODE IT
	JSR PC,TYPE
	SOB C,DECOT2	;TYPE ALL THE REMAINDERS
	POP C
	RTS PC

DECOT0:	MOV #'0,A	;TYPE '0
	JSR PC,TYPE
	POP C
	RTS PC


NAMOUT:	PUSH C
	PUSH (B)+	;SAVE FLAGS WORD
	MOV #16.,C	;CURTAIL AFTER 16 LETTERS
NAMOU2:	MOVB (B)+,A
	JSR PC,TYPE
	TSTB A
	BLT NAMOU3
	SOB C,NAMOU2
	TYPEIT ^/.../	;NAME CURTAILED
	BR NAMOU4	;DON'T LOOK FOR VN

NAMOU3:	BIT #VNF_8.,(P)	;HAVE WE A VERSION NO. TO PRINT?
	BEQ NAMOU4
	TYPEIT ^/ #/	;YES
	MOVB (B)+,(P)	;GET IT (CAN USE OLD TEMP)
	MOVB (B)+,1(P)	;(IN A CROCKY WAY)
	POP B
	JSR PC,DECOUT	;(TYPE NUMBER)
	BR NAMOU5

NAMOU4:	POP C
NAMOU5:	POP C
	RTS PC
	.STITL INITIALIZE THE DISK
ROTMID:.BYTE DIREC*40+2,WRDLFT		;RUG'S POINT DIRECTORY
	FLTEXT ^/./
	.BYTE DTSKP+45
	.EVEN

	.BYTE FILE*40+6,0	;BITS FILE IS IN WHOLE BLOCKS
	FLTEXT ^/BITS/
	.BYTE DTSKP+47,0
	.WORD -1,-1		;DATE & TIME

	.BYTE FILE*40+6,WRDLFT	;DISK DESCRIPTOR FILE
	FLTEXT ^/DESCR/
	.BYTE DTSKP+50
	.WORD -1,-1		;DATE & TIME
ROTEND:
CPYUP:	TYPEIT ^/_MASS COPY UP? /
	JSR PC,TYI1
	CMP #'Y,A
	BEQ .+6
	JMP SALVQ
	MOV #PLATR1,NDISK
	CLR WCHDSK
	JMP BACKUP

CPYDN:	TYPEIT ^/_MASS COPY DOWN? /
	JSR PC,TYI1
	CMP #'Y,A
	BEQ .+6
	JMP SALVQ
	MOV #PLATR1,WCHDSK
	CLR NDISK
	JMP BACKUP
BACKUP:	MOV #-14000,TRNSLE	;LENGTH OF A CYLINDER
	MOV #203.,E	;NUMBER OF CYLINDERS ON A DISK
	CLR BLOKNO	;START AT BLOCK 0
BCKUP1:	MOV #DSKBUF,B	;WHERE TO PUT DATA
	JSR PC,DSKRED	;READ A CYLINDER
	MOV BLOKNO,A	;WHERE TO PUT IT
	JSR PC,NDSKWR	;WRITE IT ON THE OTHER DISK
	ADD #12.,BLOKNO	;GET THE NEXT CYLINDER
	SOB E,BCKUP1	;DO IT FOR ALL THE CYLINDERS
	MOV #-1000,TRNSLE	;RESTORE THE BLOCK LENGTH
	JMP SALV2
INITD:	MOV #-1,BLKLIM
	MOV #DBITS1,A
	MOV #20000,B
	CLR (A)+	;CLEAR 2*4K WORDS (BOTH BIT TABLES)
	SOB B,.-2
	MOV #740,DBITS1+4	;MARK BLOCKS 45-50
	MOV #4604,BLKLIM	;NO. BLOCKS ON DISK
	TST WCHDSK	;IS IT THE FIXED DISK
	BPL XDESCR	;NOPE
	MOV #2000,BLKLIM
XDESCR:	JSR PC,CLRBUF
	MOV #DSKBUF,D

BASEYR:	TYPEIT ^/_BASE YEAR:  /
	JSR PC,ITYI	;RESET TYI BUFFER
	JSR PC,DECIN
	BEQ BASEYX	;NO NUMBER TYPED IN--NO GOOD
	CMP #15,A	;FOLLOWING CHAR = CR?
	BNE BASEYX
	MOV B,(D)+	;# IS BASE YEAR
	BR AREA1
BASEYX:	TYPEIT ^/ ?/	;BAD SYNTAX
	BR BASEYR

AREA1:	JSR PC,AREAN
	TYPEIT ^/1/	;BACK FOR "SWAP AREA 1:  "
	JSR PC,@(P)+	;CONTINUE
	BVS AREA1	;BAD SYNTAX:  "?" ALREADY TYPED
	BNE AREA2	;# BLOCKS = 0?
	CMP (D)+,(D)+	;YES, JUST CR TYPED: SKIP AREA 2
	BR RESRVD

AREA2:	JSR PC,AREAN
	TYPEIT ^/2/	;BACK FOR "SWAP AREA 2:  "
	JSR PC,@(P)+	;CONTINUE
	BVS AREA2
RESRVD:	TYPEIT ^/_RESERVED:  /
	JSR PC,ITYI

	JSR PC,RANGIN
	BVS RSRVX1	;BAD RANGE SYNTAX
	CMP #15,A	;CR AFTER FIRST RANGE?
	BEQ RSRVCR
	CMP #',,A	;COMMA AFTER FIRST RANGE?
	BNE RSRVX1	;MUST BE ONE OR THE OTHER
	TST B
	BEQ RSRVX1	;NO RANGE FOLLOWED BY COMMA NO GOOD
	JSR PC,SETMSK	;SET BITS AND MAKE OFFSET/MASK FOR THIS RANGE
	BR RESRVC

RSRVCR:	TST B
	BEQ DESCWR	;NO RANGE ON LINE -> ALL DONE.
	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVD	;ANOTHER LINE OF "RESERVED:  "

RSRVX1:	TYPEIT ^/ ?/	;LINE SYNTAX  NO GOOD
	BR RESRVD	;TRY LINE AGAIN


RESRVC:		;AFTER A COMMA:
	JSR PC,RANGIN
	BVS RSRVX2	;BAD RANGE SYNTAX
	TST B
	BEQ RSRVX2	;AFTER A COMMA YOU MUST HAVE A RANGE
	CMP #15,A
	BEQ RSVCR2	;ENDED WITH CR
	CMP #',,A
	BNE RSRVX2	;MUST HAVE EITHER THAT OR COMMA
	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVC	;ANOTHER RANGE ON THIS LINE

RSVCR2:	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVD	;ANOTHER LINE

RSRVX2:	TYPEIT ^/ ?_BAD SYNTAX AFTER COMMA/
	BR RESRVD	;TRY LINE AGAIN


DESCWR:	MOV #DSKBUF+2000,C	;FIND # BYTES FREE
	SUB D,C
	MOV C,DBEND

	MOV #50,B
	JSR PC,DBFWRT	;WRITE BLOCK 50:  DESCR FILE DONE
XBITS:	JSR PC,CLRBUF
	MOV BLKLIM,DSKBUF	;NO. BLOCKS ON DISK
	MOV #777,C		;BLT 1000-1 WORDS INTO DSKBUF+2
	MOV #DBITS1,A
	MOV #DSKBUF+2,B
	MOV (A)+,(B)+
	SOB C,.-2
	MOV #47,B	;WRITE THIS FILE
	JSR PC,DBFWRT	;STILL ONLY ALLOW 17760 BLOCKS ON DISK

XROOT:	JSR PC,CLRBUF
	MOV #DSKBUF+1,B
	MOVB #WRDLFT,(B)+	;ROOT HAS WORD LEFT FOR LENGTH
	JSR PC,GETNAM		;GET NAME OF DISK
	MOVB #DTSKP+46,(B)+	;1 BLOCK AT 46
	INC B			;.EVEN
	BIC #1,B
	MOV B,A			;GET LENGTH OF ROOT HEADER ENTRY
	SUB #DSKBUF,A
	ASR A
	ADD #HEADER*40,A	;NOT REALLY NEEDED.
	MOVB A,DSKBUF	;HEADER LENGTH BYTE

	MOV #ROTMID,A
	MOV #<ROTEND-ROTMID>/2,C
	MOV (A)+,(B)+	;FILL IN POINT, BITS AND DESCR ENTRIES (FIXED)
	SOB C,.-2

	MOV #DSKBUF+2000,A
	SUB B,A		;NO. BYTES LEFT IN ROOT
	MOV A,DBEND	;TO LAST WORD OF ROOT

	MOV #46,B
	JSR PC,DBFWRT

XPOINT:	JSR PC,CLRBUF		;DO RUG'S . DIRECTORY
	MOV #<WRDLFT*400>+<HEADER*40>+2,DSKBUF
	MOV #<'.+200 +<<DTSKP+46>*400>>,DSKBUF+2
	MOV #1774,DSKBUF+1776
	MOV #45,B
	JSR PC,DBFWRT
INITDX:	BPT
	BPT		;ALL DONE
CLRBUF:	MOV #DSKBUF,A
	MOV #1000,B	;512 WORD IN BUFFER
	CLR (A)+
	SOB B,.-2
	RTS PC

GETNAM:	TYPEIT ^/_DISK NAME:  /
	JSR PC,ITYI
GETNM2:	JSR PC,TYI
	CMPB #15,A	;CR ENDS NAME
	BEQ GETNMR
	MOVB A,(B)+	;NEXT CHAR OF HEADER ENTRY
	BR GETNM2
GETNMR:	MOV #12,A	;ECHO CRLF
	JSR PC,TYPE
	TSTB -(B)	;FLAG PREVIOUS CHAR AS LAST CHAR OF NAME
	BISB #200,(B)+
	RTS PC
DECIN:	CLR B		;Z IF NO DIGITS TYPED;
	JSR PC,DECDIG	;# IN B, END CHAR IN A
	BNE DECIN2
	SEZ		;NO NUMBER
	RTS PC
DECIN2:	JSR PC,DECDIG
	BNE DECIN2
	CLZ		;NON-DIGIT SEEN
	RTS PC

DECDIG:	JSR PC,TYI	;Z IF NOT DIGIT;
	CMP #'0,A	;CHAR IN A, ACCUM'ED # IN B
	BGT DECDGX
	CMP #'9,A
	BLT DECDGX
	SUB #'0,A
	MUL #10.,B
	ADD A,B
	CLZ		;THIS WAS A DIGIT
	RTS PC
DECDGX:	SEZ
	RTS PC		;NOT A DIGIT


RANGIN:			;GET A RANGE, C = STARTING BLOCK, B = # BLOCKS
			;SET V IF BAD SYNTAX
	JSR PC,OCTIN
	BEQ RANGE0	;NO RANGE
	MOV B,C		;FIRST BLOCK OF GROUP GOES IN C
	CMP #'-,A	;ONE BLOCK OR GROUP?
	BEQ RANGI2
	MOV #1,B	;JUST ONE NUMBER- LENGTH OF GROUP IS 1
	RTS PC
RANGE0:	CLR B		;NO RANGE:
	CLR C
	RTS PC		;FIRST NUMBER NOT TYPED--B=0 IS FLAG

RANGI2:	JSR PC,OCTIN	;GET LAST BLOCK NUMBER
	BEQ RANGIX	;BAD SYNTAX--NO END #
	SUB C,B		;MAKE B NUMBER OF BLOCKS
	INC B		;FROM FIRST AND LAST BLOCKS
	BLT RANGIX	;FIRST MUST NOT BE > LAST
	RTS PC
RANGIX:	SEV		;BAD RANGE SYNTAX
	RTS PC


OCTIN:	CLR B		;Z IF NO DIGITS; # IN B, BREAK CHAR IN A
	JSR PC,OCTDIG
	BNE OCTIN2
	SEZ		;NO NUMBER
	RTS PC
OCTIN2:	JSR PC,OCTDIG
	BNE OCTIN2
	CLZ		;NON-DIGIT SEEN
	RTS PC

OCTDIG:	JSR PC,TYI	;Z IF NOT A DIGIT;
	CMP #'0,A	;CHAR IN A, ACCUM'ED # IN B
	BGT OCTDGX
	CMP #'7,A
	BLT OCTDGX
	SUB #'0,A
	ASH #3,B
	ADD A,B
	CLZ		;WE GOT A DIGIT
	RTS PC
OCTDGX:	SEZ		;NOT A DIGIT
	RTS PC
AREAN:	TYPEIT ^/_SWAP AREA /
	JSR PC,@(P)+	;GO BACK TO TYPE SWAP AREA #
	TYPEIT ^/:  /	;HELLO AGAIN
	JSR PC,ITYI
	JSR PC,RANGIN
	BVS AREANX	;BAD RANGE SYNTAX
	CMP #15,A	;MUST BE CR AFTER RANGE
	BNE AREANX
	JSR PC,SETAREA	;SET RANGE IN BIT TABLE AND DESCR FILE
	RTS PC		;IF B = 0 BLOCKS IT WAS JUST CR;
			;Z IS SET AND CALLER WILL GO TO RESRVD.
AREANX:	TYPEIT ^/ ?/	;SYNTAX BAD
	SEV
	RTS PC


SETAREA: MOV C,(D)+	;GIVEN A GROUP OF BLOCK, FIRST ONE IN C,
	MOV B,(D)+	;# OF BLOCKS IN B, PUT THEM IN DESCR AND
	BNE .+4		;SET THEIR BITS IN DBITS1
	RTS PC		;BUT IF B = 0 DON'T BOTHER
	MOV C,BLOKNO
	MOV B,C		;GOOD PLACE FOR COUNTER

SETAR2:	CMP BLOKNO,BLKLIM
	BHIS NDISKX	;BLOCK FELL OFF DISK:  FATAL ERROR
	JSR PC,BTADR	;BLOKNO -> BIT IN A, BYTE OFFSET IN B
	BITB A,DBITS1(B)
	BEQ .+6
	JSR PC,BALRES	;BLOCK ALREADY RESERVED
	BISB A,DBITS1(B)	;RESERVE THE BLOCK
	INC BLOKNO	;LOOP TO NEXT BLOCK
	SOB C,SETAR2	;COUNT OUT # OF BLOCKS
	RTS PC
SETMSK:	MOV C,BLOKNO	;GIVEN A GROUP OF BLOCKS, SET UP OFFSET/MASK PAIRS
	MOV B,C		;IN DESCR AND RESERVE THE BLOCKS IN DBITS1
	BR SETMS3	;THERE SHOULD BE NO B=0 CASES

SETMS2:	BIT #17,BLOKNO	;RUNNING INTO NEW MASK WORD?
	BNE SETMS4
	TST (D)+	;YES, BE DONE WITH OLD ONE,
SETMS3:	JSR PC,OFFSET	;MAKE NEW OFFSET WORD
SETMS4:	CMP BLOKNO,BLKLIM
	BHIS NDISKX	;BLOCK FELL OFF DISK--FATAL ERROR
	JSR PC,BTADR	;BLOKNO -> BIT IN A, BYTE OFFSET IN B
	BITB A,DBITS1(B)	;BLOCK RESERVED?
	BEQ .+6
	JSR PC,BALRES	;"BLOCK N ALREADY RESERVED"
	BISB A,DBITS1(B)	;RESERVE THE BLOCK
	BIT #10,BLOKNO	;ODD BYTE?
	BEQ .+4
	SWAB A		;IF ODD TEN THEN PUT IN ODD BYTE
	BIS A,(D)	;SET NEW BIT IN MASK

	INC BLOKNO
	SOB C,SETMS2
	TST (D)+	;END LAST MASK WORD
	CMP D,#DBEND
	BHI DESCRX	;DESCR OVERFLOW--FATAL
	RTS PC


OFFSET:	CMP D,#DBEND
	BHIS DESCRX	;DESCR FILE OVERFLOW--FATAL ERROR
	MOV BLOKNO,A
	ASH #-3,A	;BLOCK # -> BYTE OFFSET
	BIC #1,A	;-> WORD OFFSET IN BIT TABLE
	MOV A,(D)+	;MAKES OFFSET WORD OF DESCR FILE
	RTS PC

DESCRX:	TYPEIT ^/_DESCR FILE OVERFLOWED_/
	HALT		;INITD NO GOOD
	BR .-2



BALRES:	PUSH A		;BLOCK ALREADY RESERVED
	PUSH B
	TYPEIT ^/_BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ ALREADY RESERVED_/
	POP B
	POP A
	RTS PC


NDISKX:	TYPEIT ^/_BLOCK NOT ON DISK_/
	HALT		;INITD NO GOOD
	.STITL TYI & TYO
CRLF:	MOV #15,A
	JSR PC,TYPE
	RTS PC

ECHO:	TST RUBING	;RUBBING OUT CHARS?
	BEQ TYPE
	PUSH A		;YES, LEAVE RUBBING MODE
	MOV #'\,A
	JSR PC,TYPE
	CLR RUBING
	POP A

TYPE:	TSTB %TPS
	BPL TYPE
	MOVB A,%TPB
	CMP #15,A
	BEQ .+4
	RTS PC
	PUSH A
	MOV #12,A
	JSR PC,TYPE
	CLR A
	JSR PC,TYPE
	JSR PC,TYPE
	POP A
	RTS PC

TYI1:	TSTB %TKS
	BPL TYI1
	MOVB %TKB,A
	BIC #177600,A
	CMP #'G-100,A	;BELL?
	BEQ TYIRUG
	CMP #'Z-100,A	;^Z?
	BEQ TYIRUG
	CMP #'A+40,A
	BGT TYI2
	CMP #'Z+40,A
	BLT TYI2
	SUB #40,A
TYI2:	CMP #177,A	;RUBOUT?
	BNE .+6
	SEV
	RTS PC		;IF RUBOUT THEN 1) SET V 2) DON'T ECHO
	JSR PC,ECHO	;ECHO
	RTS PC
TYIRUG:	BPT
	BR TYI1

ITYI:	CLR NCHR
	RTS PC

TYI:	DEC NCHR	;ONE LESS CHAR TO READ
	BLT TYLINE	;IF IT'S THERE
	MOVB @TBUFPT,A	;THEN HERE IT IS
	INC TBUFPT
	RTS PC

TYLINE:	CLR NCHR	;OUT OF CHARS: GET A NEW LINE
	CLR RUBING	;NOT RUBBING OUT
	MOV #TBUF,TBUFPT	;READ INTO BUFFER
TYLIN2:	CMP #TBUFLN,NCHR	;ROOM IN BUFFER?
	BLOS LINERR
	JSR PC,TYI1	;GET A CHAR
	BVS TYLRBO	;RUBOUT
	MOVB A,@TBUFPT	;STORE CHAR
	INC TBUFPT
	INC NCHR	;ONE MORE CHAR IN BUFFER
	CMP #15,A	;CR?
	BNE TYLIN2	;NO, KEEP LISTENING
	MOV #TBUF,TBUFPT  ;YES, BUFFER READY: FEED HIM THE FIRST CHAR
	BR TYI

TYLRBO:	DEC NCHR	;RUB IT OUT: ONE LESS CHAR
	BLT TYLINE	;NO CHARS TO RUB OUT: RESET LINE
	DEC TBUFPT
	TST RUBING	;ALREADY IN RUBBING MODE?
	BNE TYLRB2	;YES
	MOV #'\,A
	JSR PC,TYPE
	INC RUBING
TYLRB2:	MOVB @TBUFPT,A	;TYPE RUBBED OUT CHAR
	JSR PC,TYPE
	TST NCHR	;FIRST CHAR RUBBED OUT?
	BNE TYLIN2	;NO, DONE WITH RUBOUT
	MOV #'\,A	;YES, CLOSE RUBBING MODE
	JSR PC,TYPE
	BR TYLINE

LINERR:	TYPEIT ^/ ?_TYI BUFFER FULL, TRY IT ALL OVER/
	BPT
	JMP SALV2


PATLOC:
PATCH:	.=.+400

;*************
;FIXED HEAD DISK BLOCK 0 BOOTSTRAP FOR LOGO AND RUG
;
FHIDIR:	MOV #DSKAE,B
	CLR (B)
	MOV #4000,-(B)
	MOV #120000,-(B)
	MOV #160000,-(B)
	MOV #DISKRD,-(B)
	TSTB (B)
	BPL .-2
	CMP #177000,@#SWB
	BEQ .+6
	JMP @#120000	;CLEAR SWITCHES TO GET RUG
	JMP @#120002	;LEAVE SWITCHES UP FOR LOGO
FHIDIZ:
;*************

.END SALV
