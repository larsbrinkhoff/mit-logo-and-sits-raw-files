	TITLE	INPALX
	.MLLIT=1

;VARIABLE PARAMETERS.

IFNDEF TENEX,TENEX==0
IFNDEF ITS,ITS==1-TENEX		;ASSEMBLE FOR CORRECT OP SYSTEM


	PAGSIZ==54.		; NUMBER OF LINES ON A PAGE
	CORINC==2000		; CORE INCREMENT
	SPL==	4		; SYMBOLS PER LINE (SYMBOL TABLE LISTING)
	SPLTTY==3		; SYMBOLS PER LINE (TTY)
	ARADIX==8.		; ASSEMBLER RADIX
	DATLEN==350.		; DATA BLOCK LENGTH
	CPW==	6		; CHARACTERS PER WORD
	WPB==	10		; MACRO BLOCK SIZE
	CPL==	120.		; CHARACTERS PER LINE
	PDPLEN==300		; PUSH-DOWN POINTER LENGTH
	LSTBSZ==400		;LISTING BUFFER SIZE.
	SRCBSZ==2000		;SOURCE BUFFER SIZE.
IFN TENEX,SRCBSZ==1777
	TTIBSZ==30		;COMMAND BUFFER SIZE.
	SRCPSZ==8		;LENGTH OF .INSRT PDL.


;ACCUMULATOR ASSIGNMENTS

	N=	0		; ACCUMULATION OF SIXBIT SYMBOL, SCRATCH
	A=	1		; SYMBOL VALUE AND FLAGS SET BY SRCH.  SCRATCH
	B=	2		; SCRATCH
	C=	3		; SCRATCH
	W=	4		; CODE TO BE GENERATED.  LH - TYPE,  RH - VALUE
	L=	5		; LOCATION COUNTER
	R6=	6		; SCRATCH
	S=	7		; SYMBOL TABLE SEARCH INDEX
	V=	10		; EXPRESSION OR TERM VALUE, SCRATCH
	T1=	11		; SCRATCH
	MP=	12		; MACRO STORAGE BYTE POINTER
	IP=	13		; LINE BUFFER BYTE POINTER
	I=	14		; CURRENT CHARACTER (ASCII)
	AF=	15		; LH - ASSEMBLER FLAGS,  RH - ERROR FLAGS
	F=	16		; EXEC FLAGS
	P=	17		; PUSH-DOWN POINTER


	SETCHA=	LDB I,IP	;RESTORE LAST CHAR READ.
	CALL=	PUSHJ P,
	RET=	POPJ P,
	ERRUUO=	1^9		;ERROR IN PASS 2 ONLY.
	ERRUU1=	2^9		;ERROR IN EITHER PASS.
	ORM=	IORM

.XCREF A,B,CALL,RET
;FLAG REGISTERS

				; F - LH

	LSTBIT==000001		;1 - WE'RE MAKING A LISTING.
	BINBIT==000002		;1 - WE'RE MAKING A BINARY.
	CSWBIT==000004		;1 - MAKE CREF-TYPE LISTING.
	DSWBIT==000010		; 1 - /D, JOB DISOWNED.
	MSWBIT==000020		; 1- SUPRESS MACRO LISTING
	NSWBIT==000040		; 1- SUPRESS ERRORS ON TTY
	RSWBIT==000100		; 1- REPRODUCE SOURCE
	TTYBIT==000200		; 1- LISTING IS ON TTY
	PSWBIT==000400		;1 - BINARY ON PTP:
	SYMBIT==001000		;1 - SUPPRESS SYM TAB IN BINARY.
	LSWBIT==002000		;1 - FORCE LISTING.
	NULBIT==004000		;1 - NO OUTPUT FILES GIVEN (NO "_").
	BSWBIT==010000		;1 - SUPPRESS BINARY.
	ESWBIT==020000		;1 - /E, FORCE ERROR FILE OUTPUT.
	ERRBIT==040000		;1 - ERROR FILE OPEN.
	ERQBIT==100000		;1 - ERROR FILE SPEC'D (BUT NOT NEC. OPEN YET)

				; F - RH

	ARWBIT==000001		; 1- LEFT ARROW SEEN
	INSBIT==000002		; 1- READING FILENAME DURING .INSRT .
	CHRBIT==000004		; 1- RFILE RE-READS LAST CHAR (USED IN .INSRT)
	INFBIT==000010		; 1- VALID INFORMATION SEEN
	FFBIT==000020		; 1- FORM-FEED SEEN
	ENDBIT==000400		; 1- END OF ALL INPUT FILES
	HDRBIT==040000		; 1- TIME FOR NEW LISTING PAGE


				; AF - LH

	INDFLG==000002		;@ WAS SEEN IN ADDRESS.
	SRCFLG==000004		;HAVE READ WHOLE LINE, BUT NOT LISTED.
	LINFLG==000010		; 1- SUPPRESS LISTING OF LINE
	ENDFLG==000020		; 1- END OF SOURCE ENCOUNTERED
	RSWFLG==000040		; 1- LINE TO BE SUPPRESSED IN REDUCTION
	TTYFLG==000100		; 1- TTY MODE LISTING FORMAT
	CONFLG==000200		; 1- CONCATENATION CHARACTER SEEN
	ASZFLG==000400		; 1 FOR ASCIZ, 0 FOR ASCII PSEUDOOP
	ROKFLG==001000		; 1- REGISTER "OK" FLAG
	REGFLG==002000		; 1- REGISTER FLAG
	HKLFLG==004000		; 1- HALF KILLED SYMBOL BEING DEFINED
	TTMFLG==010000		; 1- .TTYMAC IN PROGRESS
	P1F==	400000		; 1- PASS 1 IN PROGRESS

;IN RH.
ERRU==	000040		;SOME SYM WAS UNDEFINED.
ERRP1==	000001		;LIST THIS LINE ON TTY (^D IN ERROR UUO).

;SYMBOL FLAGS, USU. IN A (ALONG WITH VALUE).
LBLSYM==001000		;LABEL
MDLSYM==002000		;MULTIPLY DEFINED LABEL FLAG
REGSYM==004000		;REGISTER
UNDSYM==010000		;UNDEFINED SYMBOL FLAG
HKLSYM==020000		;HALF KILLED SYMBOL
SUPSYM==040000		;DON'T OUTPUT THIS SYMBOL.
NCRSYM==100000		;DON'T CREF THIS SYM.
;MISCELLANEOUS PARAMETERS
IFN ITS,[

;CHANNEL NAMES.

	TTO==	0
	BIN==	1
	LST==	2
	SRC==	3
	TTI==	4
	ERRC==	5
	CMDC==	6
	ERR==	7
]
; CREF FLAG CHARACTERS

	CRFLIN==35
	CRFSYM==36
	CRFMAC==34
	CRFOPC==33

	CRR==15
	LF==12
	TAB==11
	SPACE==40
	RUBOUT==177
	FF==14
	INDBIT=="@


DEFINE	POINT	A,B,C
B+<A!._30>+<44-IRPS X,,C
<X!.+1>TERMIN >_36 TERMIN

DEFINE	PHASE	A
	OFFSET	A-.
TERMIN

DEFINE	DEPHASE
	OFFSET	0
TERMIN

IFN TENEX,[
.DECREL
.INSRT SYS:TENEX DEFS
.TNXDF

CORTOP=377777		;NO HAIRY CORE ALLOCATION YET

DEFINE CLOSK FILE
	MOVEI A,FILE
	CALL CLOSEK
TERMIN
]
;NEW MACROS

DEFINE	SAVE	$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
IRP X,,[$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12]
IFSN X,,	PUSH	P,X
TERMIN
TERMIN

DEFINE	REST	$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
IRP X,,[$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12]
IFSN X,,	POP	P,X
TERMIN
TERMIN

DEFINE	ERROR1	ADDR,MSG
IFSN MSG,,  ERRUU1 [<010000,,ADDR> ? ASCIZ\MSG\]
IFSE MSG,,  ERRUU1 [ASCIZ\ADDR\]
TERMIN

DEFINE	ERROR	ADDR,MSG
IFSN MSG,,  ERRUUO [<010000,,ADDR> ? ASCIZ\MSG\]
IFSE MSG,,  ERRUUO [ASCIZ\ADDR\]
TERMIN

;RESTART READING FROM A (IN LINBUF).
DEFINE	RESCAN	A/
	MOVEI	IP,GCHI
	HRRM	IP,GETCHA
	MOVE	IP,A
TERMIN

DEFINE	NEWLIN	X
	JUMPN	B,X
	SAVE	B
	MOVEI	B,^M
	CALL	X
	MOVEI	B,^J
	PUSH	P,[POPBJ]
TERMIN

IFN ITS,[
;ASSEMBLE A "NEW SYSTEM CALL" WITH NAME A, ARGS B.
DEFINE	SYSCAL	A,B
	.CALL	[SETZ ? SIXBIT/A/ ? B ((SETZ))]
	.VALUE
TERMIN

DEFINE SYSCL	A,B
	.CALL	[SETZ ? SIXBIT/A/ ? B ((SETZ))]
TERMIN

;OUTPUT CHAR IN B TO FILE X.
DEFINE	UNIOB	X
	.IOT	X,B
TERMIN

;INPUT CHAR FROM FILE X INTO B.
DEFINE	UNIIB	X
	.IOT	X,B
TERMIN

;X IS CHANNEL, B HAS BP, C HAS MINUS # BYTES.
;Y IS # BYTES/WD, OR NULL FOR 1.
DEFINE	OUTBFR	X,Y
IFNB Y,	IDIVI	C,Y
	HRLI	B,(C)
	.IOT	X,B
TERMIN

BUG==.VALUE
]

IFN TENEX,[
DEFINE	UNIOB	B
	SAVE	A
	MOVE	A,X!JFN
	BOUT
	REST	A
TERMIN

DEFINE	UNIIB	X
	EXCH	A,B
	MOVE	A,X!JFN
	BIN
	EXCH	A,B
TERMIN
DEFINE	OUTBFR	X,Y
	MOVE A,X!JFN
	SOUT
TERMIN

BUG==HALTF
]
;IMPURE AREA

LOC	41
	JSR	UUOH
IFN ITS,TSINT		;ITS INT HANDLER.

IFN TENEX,LOC 200	;JUST IN CASE OF PA1050
LOCTR:	L,,0		;@LOCTR GIVES .+OFFSET .
SYMPNT:	S,,JOBFFI		;POINTER TO SYMBOL TABLE MNEMONIC
VALPNT:	S,,-1			;POINTER TO SYMBOL TABLE VALUE
JOBREL:	0			;MEMORY BOUND.
CRFINS:	JFCL\CALL CRFOUT	;INSN TO CREF SYM IN N, VAL IN A.
CRFIND:	JFCL\CALL CRFODF	;CREF FOR DEFINING OCCURRENCE.

ARGRET:	0		;ADRESS OF RTN FOR ARGC TO CALL,
	RET		;JSR ARGRET  TO SET COROUTINE START ADDRESS.
ARGTRM:	0		;TEMP. USED BY ARGC ROUTINES.

BZCOR:				;BEGINNING OF CORE TO BE INITIALIZED TO ZERO

SYMLEN:	0		;LENGTH OF SYMBOL TABLE
SYMAOB:	0		;AOBJN PTR -> SYM. TAB.
MACTOP:	0		;TOP OF MACRO STORAGE
MACPDP:	0		;MACRO PDL POINTER.
MACBPT:	0		;POINTS TO BOTTOM OF MACRO PDL FRAME.
MACLVL:	0		;MACRO NESTING LEVEL
MACXIT:	0	;ADDR OF ROUTINE TO CALL WHEN FINISH READING STRING.
		;CALL THERE+1 FOR .MEXIT TO AVOID DOING MORE PASSES.
		;WILL BE MACEND, REPEND, AIRPON OR AIRPCN .
ARGLST:	BLOCK	65.	;;HOLD MACRO ARG NAMES DURING DEFINITION READING.

MWPNTR:	BLOCK	1	;MACRO WRITE POINTER
NEXT:	BLOCK	1	;GARBAGE COLLECTION CHAIN
%RPCNT:	0		;VALUE OF .RPCNT .
%IRPCN:	0		;VALUE OF .IRPCNT .
%NARG:	0		;%NARG PSEUDO SYM, # ARGS TO INNERMOST MACRO CALL.

SYMBEG:	BLOCK	1		;POINTER TO START OF SYMBOL FOR RESCAN PURPOSES

LINBUF:	BLOCK	CPL/5+1		;SOURCE LINE BUFFER
LINIP:	0			;LAST FILLED PLACE IN LINBUF.


LODADR:	BLOCK	1		;LOAD ADDRESS
CURADR:	BLOCK	1		;CURRENT DATA BLOCK ADDRESS
BYTCNT:	BLOCK	1		;BYTE COUNT
CHKSUM:	BLOCK	1		;CHECK SUM
DATBBL:	0?0			; 1,0 (BEG. OF BLOCK) GO HERE.
	0?0			;BLOCK LENGTH HERE
	0?0			;1ST ADDR HERE.
DATBLK:	BLOCK	DATLEN		;DATA BLOCK
INSCNT:	0		;# INSTRUCTIONS ASSEMBLED.
INSLEN:	0		;# WDS IN INSTRUCTIONS (FOR AVG LENGTH)
RUNTIM:	0		;RUN TIME AT START OF THIS COMMAND.
DATTIM:	BLOCK 6		;DATE & TIME AS ASCIZ STRING.
PAGNUM:	0		;PAGE NUMBER IN SRC.
PAGTOT:	0		;PAGE NUM. IN LISTING.
PAGEXT:	0		;PAGE EXTENSION
ERRCNT:	0		;ERROR COUNT
NONFTL:	0	;-1 AT FINIS2 IF NO FATAL ERROR
		;(SO OK TO RENAME BIN,LST FILES)

RFILN:	0		;ACCUMULATE FILENAMES IN THIS BLOCK.
XESAVE:	0		;FN1 GOES HERE.
EXTSAV:	0		;2ND NAME GOES HERE.
RFILSN:	BLOCK	2	;SNAME, ACCESS PTR GO HERE.

RFILN1=XESAVE
RFILN2=EXTSAV

RFILP:	0		;0 IF NULL FILSPEC.
RFILNC:	0

%FNAM2:	0		;DECIMAL VAL OF 2ND NAME OF SRC.

CEXT:			;CODE EXTENSION BLOCK
CEXT1:	0		;   BYTES 3&4 OF CODE
CEXT2:	0		;   BYTES 5&6 OF CODE

OFFST:	0		;0 OF 1, FOR CEXT1 OR CEXT2

LLABN:	0		;MOST RECENTLY DEFINED LABEL'S NAME,
LLABV:	0		;  VALUE.
VALREQ:	0		;UNDEF. SYM. IS ERROR IF >0.
CTLCF:	0		;COMMAND TERM. BY ^C, EXIT WHEN DONE.
CTLSF:	0		;SET => TYPEOUT SUPPRESSED BY ^S.
SRCEOF:	0		;SET IF INTERNALLY DETECTED EOF.
STRTLC:	0		;START ADDR PUT HERE BY .END .
LINPOS:	0		;LSTSIX, ERROCT COUNT CHARS.

HSWCNT:	0	;NUMBER OF TIMES /H OCCURRED.
LSWCNT:	-1	;# OF /L'S IN CMD STRING, + 1 ON PASS 2, - 1.
		;LINES ARE LISTED IFF THIS WORD IS >0.
		;SET TO 0 IF LISTING CAUSED EVEN IF NO /L WAS GIVEN.
LSWCN1:	-1	;COUNT IS ACCUMULATED HERE, THEN PUT IN LSWCNT
		;CMD STRING IS READ SEVERAL TIMES. THIS AVOIDS
		;COUNTING EACH /L EACH TIME.
%ABSAD:	0	;#0 => GENERATE "@#FOO" FOR "FOO".

SRCCNT:	0		;NUM. INPUT FILES OPENED SO FAR, -1 . (INCLUDES THOSE WHICH HAVE BEEN CLOSED)
SRCNUM:	0		;# INPUT FILES OPENED BEFORE THE CURRENT ONE.
SRCERR:	0		;WHAT SRCNUM HELD AT TIME OF LAST ERROR MESSAGE.
SRCDPH:	0		;DEPTH IN .INSRT FILES, 0 IN OUTER LEVEL.
SRCBPT:	0		;B.P. (ASCII) TO START OF BUFFER FOR CURRENT SRC FILE.
SRCBND:	0		;B.P. TO A ^C AFTER END OF LAST SRC BUFFERFULL.
SRCPNT:	0		;BP FOR ILDBING FROM SRC BUFFER.
SRCTTY:	0		;-1 => SRC FILE IS TTY.
TTICSV:	0			;SAVE TTICNT HERE AFTER READING CMD .

TTICNT:	0
TTIPNT:	0
TTIBUF:	BLOCK	TTIBSZ

BINCNT:	0	
BINPNT:	0	

LSTCNT:	0	
LSTPNT:	0	
LSTBUF:	BLOCK	LSTBSZ

SRCBUF:	BLOCK	SRCBSZ
	0

LINCNT:	0		;POS. IN LISTING PAGE.
SLNCNT:	0		;POS. IN SOURCE PAGE, -1 .

TITBUF:	BLOCK 20	;TITLE, IN ASCIZ.
STITBF:	BLOCK 20	;SUBTITLE, IN ASCIZ.
TSLWRD:	0		;SUPPRESS LISTING IF NOT 0.
NOCREF:	0		;SUPPRESS CREF OUTPUT FOR SYMBOL USE.

EZCOR:

CCLFLG:	0		;FLAG ENTERED AT START + 1
MSNAME:	0			;INITIAL SNAME.

SRCJFN:	-TENEX+IFN ITS,SRC
SRCMOD:	2	;BLOCK ASCII INPUT.

CMDCJF:	-TENEX+IFN ITS,CMDC
CMDCMO:	0	;UNIT ASCII INPUT.
CMDFIL:	0	;CMD FILE NESTING LEVEL.
CMDPDL:	BLOCK 20	;IN TENEX VERSION, USED TO SAVE CMDCJF FOR PUSHED CMD FILES.

IRPS X,,DEV FN1 FN2 SNM TNM JFN MOD
X==.IRPCN
TERMIN

LSTDEV:	0	;LST FILE NAMES.
LSTFN1:	0
LSTFN2:	0
LSTSNM:	0
	'LSTOUT
LSTJFN:	-TENEX+IFN ITS,LST
LSTMOD:	3	;BLOCK ASCII OUTPUT.

ERRDEV:	0	;ERROR OUTPUT FILE NAMES.
ERRFN1:	0
ERRFN2:	0
ERRSNM:	0
	'ERROUT
ERRJFN:	-TENEX+IFN ITS,ERR
ERRMOD:	1	;UNIT ASCII OUT.

BINDEV:	0	;BINARY OUTPUT FILE NAMES.
BINFN1:	0
BINFN2:	0
BINSNM:	0
	'BINOUT	;TEMP. FN2 TO USE.
BINJFN:	-TENEX+IFN ITS,BIN
BINMOD:	7	;BLOCK IMAGE OUT.

IFN TENEX,[
TTIJFN:	0		;JFNS FOR THE VARIOUS FILES
TTOJFN:	0

STRTMP:	BLOCK 40		;SCRATCH FOR STRING CONVERSION
PSIACA:	0		;AC A DURING PSI

TIMDIV:	0		;DIVISOR FOR SECONDS FOR TIME JSYSES
JBLOCK:	BLOCK 11	;LONG FORM GTJFN BLOCK
JBKSTR:	BLOCK 100	;STRING STORAGE FOR 7-BIT JFN ARGS
JBKSTE=.-1
JBKSPT:	BLOCK 1		;POINTER INTO STRING STORAGE

LEVTAB:	PIPC1	;WHERE TO STORE LVL 1 PC.
	0
	0
CHNTAB:	1,,PSICO	;^O INT. CHNL, LVL 1, CALL PSICO.
	REPEAT 35,0
CHNMSK:	SETZ
PIPC1:	0
]		;END TENEX STORAGE

NODEFN:	0		;SYMBOL NOT TO BE DEFINED.

PDL:	BLOCK	PDPLEN

PAT:
PATCH:	BLOCK	100
PALX11:	TDZA A,A		;CLEAR CCL ENTRY FLAG
CCLX11:	SETO A,			;SET CCL ENTRY FLAG
	MOVEM A,CCLFLG		;STORE FOR LATER CHECKS
	MOVE	P,[-PDPLEN,,PDL-1]
IFN ITS,[
	.FDELE	[SIXBIT/   DSK_INPALBINOUT       /]
	JFCL
	.FDELE	[SIXBIT/   DSK_INPALLSTOUT       /]
	JFCL			;DELETE ANY WORTHLESS OUTPUT FILES.
	.FDELE	[SIXBIT/   DSK_INPALERROUT       /]
	JFCL
	.OPEN	TTI,[SIXBIT/   TTY/]
	.VALUE
	.OPEN	TTO,[SIXBIT/  !TTY/]
	.VALUE
]
	MOVE	0,[.FNAM1]	;IDENTIFY SELF.
	CALL	TTOSIX
	MOVEI	B," 		;SPACE
	CALL	TYO
	MOVE	0,[.FNAM2]
	CALL	TTOSIX
RESTRT:
IFN TENEX,[
	RESET			;CLEAR SYSTEM STUFF, FILES,...
	MOVEI A,100		;INITIAL TTI AND TTO JFNS
	MOVEM A,TTIJFN
	MOVEI A,101
	MOVEM A,TTOJFN
IRPS X,,[SRCJFN,BINJFN,LSTJFN,ERRJFN,CRFJFN]
	SETOM X
TERMIN
]
IFN ITS,[
	.IOPDL
	SKIPE	MSNAME		;PUT OUR REMEMBERED DEFAULT INTO SYSTEM VAR IN CASE FOO^S .
	.SUSET	[.SSNAM,,MSNAME]
	SETZB	A,B		;DON'T LOOK FOR ^S NOW.
	.SETM2	A,
	SYSCAL	TTYGET,[1000,,TTI ? 2000,,A ? 2000,,A ? 2000,,A]
	SYSCAL	TTYSET,[1000,,TTI ? [222020,,202020] ? [232020,,222220] ? A]
]
	MOVE	P,[-PDPLEN,,PDL-1]
	SETZB	F,AF		;CLEAR ALL FLAGS
	MOVE	N,[XWD BZCOR,BZCOR+1]
	SETZB	A,BZCOR
	BLT	N,EZCOR-1
IFN TENEX,[
	SETO A,			;CLEAR MAP OF SCRATCH PGS
	MOVE B,[400000,,<JOBFFJ/1000>]
	PMAP
	ADDI B,1
	TRNN B,400
	JRST .-3
]
IFN ITS,[
	.CORE	JOBFFJ_-10.
	.VALUE
]
	MOVEI	B,JOBFFJ-1
	MOVEM	B,JOBREL
	MOVE	[JOBFFI,,JOBFFI+1]
	SETZM	JOBFFI
	BLT	0,(B)
	CALL	TTYCR
IFN ITS,[
	.SUSET	[.ROPTIO,,I]
	TLNN	I,40000	;IF SUPERIOR MAY HAVE CMD FOR US, READ IT.
	 JRST	RESTR1
	.BREAK	12,[5,,TTIBUF]	;IF DDT STRING, READ IT.
	SKIPN	TTIBUF
	JRST	RESTR1
	SETOM	CTLCF		;CAUSE EXIT AFTER EXECUTION,
	MOVE	IP,[440700,,TTIBUF]
	MOVEM	IP,TTIPNT	;SET UP POINTER,
	ILDB	I,IP
	CAIE	I,^M
	AOJA	A,.-2		;COUNT CHARS.
	MOVEM	A,TTICNT
	.BREAK 12,[SETZ [0](5)]	;FLUSH CMD STRING.
	JRST	RESTR9
RESTR1:	]			;END IFN ITS
	CALL	TTILIN		;NO DDT CMD STRING, READ COMMAND.
IFN ITS,RESTR9:	.SUSET	[.RSNAM,,MSNAME]
	SKIPN	N,TTICNT	;SAVE NUM CHARS FOR PASS 2.
	 JRST	FINIS5		;NULL COMMAND, EXIT OR RESTART.
	MOVE	N,TTICNT
	MOVEM	N,TTICSV

;FALLS THRU.
	CALL	GETDAT		;PUT ASCII DATE & TIME INTO DATTIM.
;SEE WHETHER COMMAND CONTAINS UNQUOTED "_".
;ALSO, COUNT THE /L'S AND /H'S IN THE CMD STRING,
;AND SET THE BITS FOR ALL OTHER SWITCHES EXCEPT /T.
	SETOM	LSWCN1
	SAVE	TTICNT
	SAVE	TTIPNT
TSTAR0:	CALL	RFILE		;READ ALL FILENAMES.
	TRZN	F,ENDBIT	;UNTIL END OF CMD STRING.
	JRST	TSTAR0
	TLZ	AF,TTYFLG	;CANCEL /T SWITCH.
	TRZN	F,ARWBIT	;IF SAW NO ARROW,
	TLO	F,NULBIT	;SAY SO.
	REST	TTIPNT
	REST	TTICNT
	MOVE	A,LSWCN1	;SAVE # OF /L'S WERE REMAINING PASSES
	MOVEM	A,LSWCNT	;THRU CMD STRING WON'T CHANGE IT.
	MOVEI	A,2_10.		;GET HASH TABLE SIZE.
	LSH	A,@HSWCNT
	SUBI	A,1
	MOVEM	A,SYMLEN	;STORE IT.
	MOVNM	A,SYMAOB	;STORE AOBJN PTR.
	HRLZS	SYMAOB
	MOVEI	B,JOBFFI+1(A)	;ADDR OF TABLE OF 2ND WDS OF STES.
	HRRM	B,VALPNT
	ADDI	B,(A)		;ADDR OF WD AFTER ITS END.
	MOVEM	B,MACTOP	;MACRO STORAGE STARTS THERE.
	ADDI	B,100
IFN ITS,[
	LSH	B,-10.
	.CORE	1(B)
	.VALUE
	.SUSET	[.RMEMT,,JOBREL]
	.SUSET	[.SMASK,,[200000]]	;PDL OVFLO.
	.SUSET	[.SMSK2,,[1_TTI]]
]
IFN TENEX,[
	MOVEM	B,JOBREL
	MOVEI	A,400000		;THIS FORK
	CIS			;CLEAR INTERRUPTS IN PROGRES,, ETC.
	MOVE	B,[LEVTAB,,CHNTAB] ;POINTERS TO INTERRUPT PARAMS
	SIR			;SET INTERRUPT VECTOR
	EIR			;TURN THEM ON
	MOVE	B,CHNMSK	;AND MASK FOR CHANNELS ON
	AIC
	MOVSI	A,17		;ASSIGN CONTROL O TO CHANNEL 0
	ATI
]

;PUT INITIAL SYMBOLS INTO HASH TABLE.
	MOVE	B,[-INILEN,,INITAB]
INIT0:	MOVE	N,(B)		;GET, HASH NAME.
	CALL	SRCH
	 JFCL
	AOBJN	B,.+1
	MOVE	A,(B)		;GET, STORE VALUE.
	MOVEM	A,@VALPNT
	MOVEM	N,@SYMPNT
	AOBJN	B,INIT0
	MOVE	B,MSNAME	;DEFAULT SNAME.
	MOVEM	B,RFILSN
	CALL	GETBIN		;INITIALIZE THE BINARY FILE
	CALL	GETLST		;INITIALIZE THE LISTING FILE
	CALL	GETERR		;   ERROR FILE.
	TLO	AF,P1F		;MUST SAY PASS 1 BEFORE CALL INIPAS.
	CALL	INIPAS
	CALL	GETSRC		;INITIALIZE THE SOURCE FILE
	MOVEI	S,BINDEV
	TLNE	F,BINBIT	;IF SHOULD OPEN BINARY, DO IT NOW.
	 CALL	OINIT
	MOVEI	S,LSTDEV
	TLNE	F,LSTBIT
	TLNE	F,TTYBIT
	CAIA
	 CALL	OINIT
	MOVEI	S,ERRDEV
	TLNE	F,ERQBIT	;OPEN ERR FILE IF WANTED.
	 CALL	OINIT		;(DON'T SET ERRBIT TILL ERR FILE OPENED
	TLNE	F,ERQBIT	;SO ERRORS OPENING SRC, BIN, LST DON'T GET IOCERR
	 TLO	F,ERRBIT	;TRYING TO PUT ERR MSG IN ERR FILE)
IFN ITS,[
	TLNE	F,DSWBIT	;IF SAID TO DISOWN SELF, DO IT.
	CALL	INITD
]
	CALL	ASSEMB		;CALL THE ASSEMBLER
	CALL	ERRFCR		;TURN ON TTY OUTPUT, SKIP A LINE
	SKIPN	A,ERRCNT	;TEST ERRORS, LOAD A
	JRST	NOERRS
	CALL	ERRDEC		;PRINT NUM. ERRS.
	MOVEI	A,[ASCIZ/ ERRORS DETECTED/]
	CALL	ERRSTR
	CALL	ERR2CR
NOERRS:	SKIPN	ERRCNT		;DON'T CREATE AN ERROR FILE IF NONE YET.
	TLZ	F,ERRBIT
	MOVE	A,INSLEN	;GET AVERAGE INSN LENGTH.
	JUMPE	A,FINIS1	;(NO MESSAGE IF NO INSNS)
	IMULI	A,10.
	IDIV	A,INSCNT
	IDIVI	A,10.		;WANT THE 1ST FRACTIONAL DIGIT.
	SAVE	B
	CALL	ERRDEC		;TYPE INTEGER PART.
	MOVEI	B,".
	CALL	ERROUT
	REST	A
	CALL	ERRDEC		;TYPE FRACTIONAL DIGIT.
	MOVEI	A,[ASCIZ/ WDS AVG INSN LENGTH/]
	CALL	ERRSTR
	CALL	ERR2CR
FINIS1:
IFN ITS,[
	.SUSET	[.RRUNT,,A]	;CURRENT RUNTIME.
	SUB	A,RUNTIM	;DEDUCT STARTING TIME
	IDIVI	A,10000.	;CONVERT TO SECONDS.
	IMULI	A,4069.
	IDIVI	A,100000.
	ADDI	A,1
]
IFN TENEX,[
	MOVEI A,400000		;RUN TIME OF THIS FORK
	RUNTM
	SUB A,RUNTIM		;MINUS WHEN STARTED ASSY
	IDIV A,TIMDIV		;CONVERT TO SECONDS
	SKIPE A+1		;ROUND
	ADDI A,1
]
	CALL	ERRDEC		;PRINT NUM. SECONDS.
	MOVEI	A,[ASCIZ / SECONDS RUN-TIME/]
	CALL	ERRSTR
	CALL	ERRCR
	SETOM	NONFTL		;ASSEMBLY FINISHED, OK TO RENAME BIN, LST.

;COME HERE IF ENCOUNTER FATAL ERROR. (EG TOO MANY SYMS)
FINIS2:	MOVEI	S,ERRDEV	;RENAME ERR FILE (IF ANY) IN ANY CASE.
	CALL	OCLOS1
	MOVEI	S,SRCJFN-JFN
	CALL	ICLOSE		;CLOSE SRC FILE.
	CALL	BINCLS		;CLOSE BINARY, WRITE LAST BUFFER.
	TLNN	F,TTYBIT
	TLNN	F,LSTBIT	;IF HAVE LST FILE,
	JRST	FINIS5
	CALL	LSTCLS		;FINISH LAST BLOCK OF LISTING
FINIS5:
IFN ITS,.LOGOUT			;...IF DISOWNED.
	SKIPN	CTLCF		;EXIT IF SHOULD,
	JRST	RESTRT		;ELSE NEW CMD STRING.
	JRST	TSEXIT

IFN ITS,[
;DISOWN SELF, DON'T DO TTY I-O.
INITD:	.OPEN	TTI,[SIXBIT/   NUL/]
	.VALUE			;PREVENT "TTY" IO FROM HANGING.
	.OPEN	TTO,[SIXBIT/  !NUL/]
	.VALUE
	.VALUE	[ASCIZ/:DISOWN /]	;GIVE BACK TTY.
	RET
]
;FILE INITIALIZATION

;INITIALIZE A BINARY FILE, DEFAULTING DEV TO DSK, FN2 TO BIN.
;IF /P IS GIVEN, ALWAYS WRITE TO PTP IN 8-BIT MODE.
;ELSE IF NULL FILSPEC, NO BIN.

GETBIN:	CALL	RFIL0
	TLNN	F,PSWBIT+NULBIT+SYMBIT	;/P OR /S OR NO "_"
	SKIPE	RFILP		;OR NONNULL BIN SPEC
	TLNE	F,BSWBIT	;AND IF /B NOT GIVEN,
	RET
	MOVE	B,[RFILN,,BINDEV]	;MAKE BIN FILE.
	BLT	B,BINSNM	;COPY NAMES.
	SKIPN	B,BINFN2
	MOVSI	B,'BIN
	MOVEM	B,BINFN2	;DEFAULT THE FN2, AND THE DEV.
	MOVSI	B,'DSK
	TLNE	F,PSWBIT
	MOVSI	B,'PTP
	SKIPN	BINDEV
	MOVEM	B,BINDEV
	TLNE	F,PSWBIT	;/P MEANS NO SYMS.
	TLO	F,SYMBIT
	TLO	F,BINBIT	;INDIC. HAVE BIN.
	MOVEI	B,1+DATLEN
	MOVEM	B,BINCNT	;BUFFER EMPTY.
	MOVE	B,[444400,,DATBLK]
	MOVEM	B,BINPNT
	RET

;INITIALIZE A LISTING FILE
;IF ARWBIT OR ENDBIT, DOESN'T ACTUALLY READ ANYTHING.
;IF ON TTY, SETS TTYBIT.

GETLST:	CALL	RFILL		;READ FILE NAME, SET FOR INPUT.
	SKIPGE	LSWCNT		;IF AT LEAST 1 /L APPEARED,
	TLNE	F,RSWBIT+CSWBIT	;OR /R OR /C,
	JRST	.+3
	SKIPN	RFILP		;OR NONNULL LST SPEC => WRITE LST.
	RET
	SKIPGE	LSWCNT		;IF NO /L'S IN CMD, SAY THERE WAS 1.
	 SETZM	LSWCNT		;(LIST ON PASS 2 ONLY)
	MOVS	B,RFILN		;FULL WORD DEVICE NAME
	CAIE	B,'TTY
	JRST	GETLS1
	TLO	F,TTYBIT+LSTBIT
	JRST	ERRTTY		;TEST FOR RUNNING DISOWNED.

GETLS1:	MOVE	B,[RFILN,,LSTDEV]
	BLT	B,LSTSNM	;COPY NAMES FROM SPEC.
	MOVSI	B,'DSK
	SKIPN	LSTDEV
	MOVEM	B,LSTDEV

IFN ITS,	MOVE	B,[SIXBIT/LIST/]
IFN TENEX,	MOVSI	B,'LST
		TLNE	F,CSWBIT	;DEFAULT FN2 TO LIST,
IFN ITS,	MOVE	B,[SIXBIT/CREF/]	;OR CREF IF /C.
IFN TENEX,	MOVSI	B,'CRF
		SKIPN	LSTFN2
		MOVEM	B,LSTFN2

	TLO	F,LSTBIT	;ELSE INDICATE HAVE LISTING.
	MOVEI	B,1+5*LSTBSZ
	MOVEM	B,LSTCNT	;BUFFER EMPTY.
	MOVE	B,[440700,,LSTBUF]
	MOVEM	B,LSTPNT
	RET

GETERR:	CALL	RFILL		;READ IN NAMES.
	TLNE	F,DSWBIT+NSWBIT+ESWBIT ;IF WON'T HAVE ERRORS ON TTY,
	JRST	.+3		;OR /E WAS GIVEN,
	SKIPN	RFILP		;OR HAD ERR SPEC,
	RET
	MOVE	B,[RFILN,,ERRDEV]
	BLT	B,ERRSNM	;COPY NAMES FOR LATER RENAME.
	MOVSI	B,'DSK
	SKIPN	ERRDEV
	MOVEM	B,ERRDEV
	MOVE	B,[SIXBIT/ERRORS/]
	SKIPN	ERRFN2
	MOVEM	B,ERRFN2
	TLO	F,ERQBIT	;SAY WE'RE MAKING AN ERROR FILE.
	RET

IFN TENEX,[
OINIT:	MOVEI A,[SIXBIT /^PAL11ERR         /]
	CALL JBKINI
	MOVEI A,JBLOCK+2
	SKIPE C,DEV(S)
	CALL JBKSIX
	MOVEI	A,JBLOCK+4
	SKIPE C,TNM(S)
	CALL JBKSIX
	MOVSI A,400000
	MOVEM A,JBLOCK
	MOVEI A,JBLOCK
	MOVEI B,0
	GTJFN
	  JRST OPENLB
	MOVEM A,JFN(S)
	LDB B,[020100,,MOD(S)]
	MOVE B,[070000,,100000 ? 100000,,100000](B)
	OPENF
]
IFN ITS,[
OINIT:	SYSCL	OPEN,[JFN(S) ? DEV(S) ? [SIXBIT/_INPAL/]
		 TNM(S) ? SNM(S) ? 4000,,MOD(S)]
]
	 JRST	OPENLB
	RET
;INITIALIZE A SOURCE FILE
;READS THE FILENAMES FROM THE COMMAND BUFFER,
;DEFAULTING DEVICE, SNAME AND FN1 TO THOSE PREVIOUSLY USED,
;DEFAULTING FN2 TO '>' .
;OPENS THE FILE AND SAVES REAL FN1 AND FN2 FOR PRINTING ON LISTING.

GETSRC:	SAVE	N,A
	CALL	RFILE		;READ FILE NAME.
;ENTER HERE FOR .INSRT AFTER PUSHING SRC INFO ON MACPDL.
GETINS:	SAVE	S
IFN ITS,	MOVSI	B,(SIXBIT/>/)
IFN TENEX,	MOVSI B,'P11
	SKIPN	RFILN2		;DEFAULT 2ND NAME.
	MOVEM	B,RFILN2
	SETZM	SRCEOF		;HAVEN'T SEEN .EOT IN THIS FILE.
	SETZM	SRCTTY		;ASSUME THIS FILE ISN'T THE TTY.
	MOVS	B,RFILN		;DON'T REOPEN TTY! (WOULD .RESET)
	CAIN	B,(SIXBIT/TTY/)
	JRST	GETSR1
	MOVEI	S,SRCJFN-JFN
	CALL	IINIT		;OPEN SRC FILE.
	 JRST	GETSX1		;FAILED.
GETSR1:	SKIPE	SRCDPH		;IF THIS IS PART OF .INSRT, LIST THE LINE WITH THE PSEUDO.
	CALL	ENDLF
	SKIPN	RFILN1		;IF DEV HAS NO NAMES,
	MOVEM	N,RFILN1	;STORE SPECIFIED NAME.
	MOVE	N,RFILN1
	SKIPN	LSTFN1		;DEFAULT LST, BIN, ERR FN1'S TO SRC'S.
	MOVEM	N,LSTFN1
	SKIPN	BINFN1
	MOVEM	N,BINFN1
	SKIPN	ERRFN1
	MOVEM	N,ERRFN1
	AOS	B,SRCCNT	;SRCNUM IDENTIFIES THIS SRC FILE.
	MOVEM	B,SRCNUM
	MOVE	B,SRCBPT	;SAVE PTR TO START OF BUFFER.
	MOVEM	B,SRCPNT
	MOVEM	B,SRCBND	;SAY BUFFER EMPTY.
	MOVEI	B,^C
	IDPB	B,SRCBND
	SETOB	B,PAGEXT	;NOW STARTING PAGE 1.
	MOVNM	B,PAGNUM
	SETZM	SLNCNT		;LINE 1.
	TRO	F,HDRBIT	;START PAGE IN LISTING
IFN ITS,[
	MOVE	B,[440600,,RFILN2]
	SETZ	0,		;ACCUM. %FNAM2 IN 0.
FNAM2A:	ILDB	A,B
	CAIL	A,'0		;IGNORE NON-DIGITS.
	CAILE	A,'9
	JRST	FNAM2B
	IMULI	0,10.		;READ IN DIGITS AS DECIMAL NUM.
	ADDI	0,-'0(A)
FNAM2B:	TLNE	B,770000	;READ TILL END OF WD.
	JRST	FNAM2A
	MOVEM	0,%FNAM2	;SET VALUE OF %FNAM2.
]
IFN TENEX,[	;USE FILE VERSION # AS %FNAM2.
	SAVE	C
	MOVE	A,SRCJFN
	MOVE	B,[1,,7]	;READ THE VERSION #.
	MOVEI	C,%FNAM2	;INTO %FNAM2.
	GTFDB
	HLRZS	%FNAM2		;VERSION RETURNED IN LH.
	REST	C
]
	REST	S,A,0
	MOVS	B,RFILN
	CAIE	B,'TTY	;IF SRC IS TTY,
	RET
	SETOM	SRCTTY		;SPECIAL STUFF FOR INPUT.
ERRTTY:	TLNN	F,DSWBIT	;IF WILL BE DISOWNED, CAN'T USE TTY.
	RET
	CALL	ERRFCR
	MOVEI	A,[ASCIZ/USE TTY WHILE DISOWNED?/]
	JRST	CMDERR

;.INSRT PSEUDO - PUSH INTO FILE WHOSE NAME FOLLOWS THE PSEUDO.
AINSRT:	MOVE	A,SRCDPH	;DON'T ALLOW PUSH TOO DEEP.
	CAIL	A,SRCPSZ
	 ERROR1	ENDL,.INSRT PDL OV
	SAVE	F,RFILN,RFILN1,RFILN2,RFILSN
	MOVSI	B,'DSK		;DON'T CLOBBER CMD-STRING NAME DEFAULTS,
	MOVEM	B,RFILN		;DEFAULT THIS FILE'S DEV TO DSK.
	TRO	F,INSBIT+CHRBIT	;TELL RFILE TO READ FROM ASSEMBLY INPUT.
	CALL	RFILE		;READ NAME OF FILE TO INSERT.
	SETCHAR
	TRZA	F,INSBIT	;MOVE TO END OF LINE .INSRT'S ON.
AINSR1:	CALL	@GETCHA
	CAIE	I,^J
	JRST	AINSR1
	HRRZ	B,MACPDP	;PUSH OUTER FILE'S NAMES ONTO MACPDL.
IFN TENEX,[PUSH	B,SRCJFN
	SETOM	SRCJFN]
	REST	1(B),2(B),3(B),4(B),F
	MOVEI	B,4(B)
IRPS X,,SLNCNT PAGEXT PAGNUM SRCTTY SRCBPT SRCPNT SRCBND SRCNUM MP
	PUSH	B,X
TERMIN
	HRRM	B,MACPDP	;SAVE ALL INFO ON CURRENT SRC FILE
	SETZ	MP,		;PUSH OUT OF ANY MACRO CALL.
	AOS	B,SRCDPH	;ONE .INSRT LEVEL DEEPER NOW.
	ADDI	B,200(B)
IFN ITS,[.IOPUS	SRC,
	SYSCAL	CORBLK,[(SETZ 1000) ? 1000,,-1 ? 1000,,(B) ? 1000,,400001]
	SYSCAL	CORBLK,[(SETZ 1000) ? 1000,,-1 ? 1000,,1(B) ? 1000,,-1 ? 1000,,0]
;THOSE CALLS GET FRESH PAGE # 200+2N, SHARE PAGE 0 AS PAGE 200+2N+1.
]
	LSH	B,10.		;ADDR OF START OF FRESH PAGE.
	HRRM	B,SRCBPT	;THAT PAGE IS BUFFER FOR THIS SRC FILE.
	CALL	GCHSE0		;GET CHARS FROM SRC FILE (NOT FROM MACROS, ETC)
	SAVE	N,A
	JRST	GETINS		;NOW GO OPEN INSERTED FILE.

GETSX1:	SKIPN	SRCDPH		;INPUT OPEN FAILED:
	 JRST	OPENL		;NOT IN .INSRT => FATAL.
	MOVSI	B,'TTY		;IN .INSRT, CHANGE DEV. TO TTY:
	MOVEM	B,RFILN
	ERROR1	[.INSRT OPEN FAILED, TTY: INSERTED INSTEAD:]
	JRST	GETSR1

IINIT:
IFN ITS,[
	SYSCL	OPEN,[JFN(S) ? 4000,,MOD(S) ? RFILN ? RFILN1 ? RFILN2 ? RFILSN]
	 RET
	HRLZ	B,JFN(S)
	HRRI	B,RFILN
	MOVE	N,RFILN1	;SAVE IN CASE NON-DIR-DEV.
	.RCHST	B,		;GET REAL FN1, FN2.
	HRLZS	RFILN
]
IFN TENEX,[
	SAVE A,B
	CLOSE JFN(S)
	MOVEI A,RFILN1
	CALL JBKINI
	MOVEI A,JBLOCK+2
	SKIPE C,RFILN
	CALL JBKSIX
	MOVSI A,100000		;OLD FILE, INPUT
	MOVEM A,JBLOCK
	MOVEI A,JBLOCK
	MOVEI B,0
	GTJFN
	 JRST POPCA	;CANT GET JFN OF SOURCE
	MOVEM A,JFN(S)
	MOVE B,[070000,,200000]	;READ, ASCII
	OPENF
	 JRST POPCA
	REST B,A
]
	JRST POPJ1
;READ IN A COMMAND, PROCESSING RUBOUTS, PROMPTING WITH "*".
TTILIN:	MOVEI	B,"*
	SETZM	CTLSF
	CALL	TYO

TTILN:	SETZM	CTLSF
	SETZM	TTICNT		;NO CHARS READ YET.
	MOVE	B,[440700,,TTIBUF]
	SKIPE	SRCTTY
	HRR	B,SRCBPT
	TLNE	AF,TTMFLG	;FOR .TTYMAC, READ INTO LINBUF.
	HRRI	B,LINBUF
	MOVEM	B,TTIPNT
TTILUP:	UNIIB	TTI
	CAIN	B,^_
	 MOVEI	B,^M
	CAIN	B,^M
	JRST	TTICR		;^M MEANS ALL READ.
IFN TENEX,CAIE	B,^A
	CAIN	B,177
	JRST	TTIRUB
	CAIE	B,^Z
	CAIN	B,^C
	JRST	TTICTC		;^C - END LINE, CAUSE EXIT.
IFN TENEX,CAIE	B,^Q
	CAIN	B,^U
	JRST	TTIRU2		;^U - CANCEL COMMAND.
	IDPB	B,TTIPNT	;NORMAL CHAR.
	AOS	TTICNT
	JRST	TTILUP

TTICTC:	CALL	TTYCR
	TLNE	AF,TTMFLG
	 RET
	SETOM	SRCEOF		;IF TTY IS SRC, EOF.
	SKIPN	SRCTTY
	SETOM	CTLCF		;IF THIS IS CMD STR, EXIT AFTERWARDS.
TTICR:	TLNN	AF,TTMFLG
	SKIPE	SRCTTY
	RET
	MOVE	B,[440700,,TTIBUF]
	MOVEM	B,TTIPNT	;SET UP FOR REMOVAL OF CHARS.
	RET

TTIRUB:	SOSGE	TTICNT		;IF NO CHAR TO RUB, RETRY.
	JRST	TTIRU2
	LDB	B,TTIPNT
	CALL	TYO		;PRINT DELETED CHARACTER
	MOVSI	B,070000
	ADD	B,TTIPNT
	JUMPGE	B,TTIRU1	;IF STILL IN SAME WD.
	MOVEI	B,-1(B)		;ELSE, MOVE TO END OF PREV. WD.
	HRLI	B,010700
TTIRU1:	MOVEM	B,TTIPNT
	JRST	TTILUP

TTIRU2:	CALL	TTYCR		;RUBOUT WITH EMPTY BUFFER.
	SOS	(P)
	RET			;RE-CALL TTILIN OR TTILN.
;READ IN THE LST OR ERR FILE NAMES.
RFILL:	SETZM	RFILP		;LST: 0 IF ARW OR NUL, 1 ELSE.
	CAIA
RFIL0:	SETOM	RFILP		;BIN: 0 IF SPEC EXISTS & IS EMPTY.
	SETZM	RFILN		;CAUSE DEFAULTING OF DEV, FN1, FN2 INDIVIDUALLY.
	SETZM	RFILN1
	SETZM	RFILN2
	TLNN	F,NULBIT	;EXIT IF NO MORE OUTPUT SPECS.
	TRNE	F,ARWBIT
	RET
	SETZM	RFILP

RFILE:	SAVE	V		;B.P. INTO NAME GOES IN T0.
	SETZM	RFILN2		;FORCE DEFAULTING OF FN2.
RFNAM0:	MOVEI	B,RFXCTB	;COUNT HOW MANY NAMES SO FAR.
	MOVEM	B,RFILNC
RFNAME:	SETZ	0,		;GET NEXT NAME; RESET NAME, B.P.
	MOVE	V,[440600,,0]
RFLOOP:	CALL	TTICHR		;READ A CHAR.
	TRNN	F,INSBIT	;COMMA ORDINARY CHAR. IN .INSRT .
	CAIE	B,",
	CAIN	B,^M
	JRST	RFSPAC		;", , ^M TERMINATE SPEC.
	TRNN	F,INSBIT	;_ ALSO ORDINARY IN .INSRT .
	CAIE	B,"_
	CAIN	B," 
	JRST	RFSPAC		;THESE ALSO.
	CAIN	B,":
	JRST	RFCOL		;COLON SETS DEV.
	CAIN	B,";
	JRST	RFSEM		;SEMI SETS SNAME.
IFN TENEX,[
	CAIN B,".
	TRNE F,INSBIT		;DOT IN FILE NAME IS SAME AS SPACE
	SKIPA
	JRST RFSPAC
]
	TRNE	F,INSBIT	;NO COMMAND FILES OR SWITCHES IN .INSRT'S.
	 JRST	RFLOO1
	CAIN	B,"@
	JRST	RFATSN		;@ -- USE CMD FILE.
	CAIN	B,"/
	JRST	RFSPAC		;SLASH ENDS NAME.
RFLOO1:	CAIN	B,^R		;^R - RESET FILENAME COUNTER.
	 JRST	RFSPAC
	CAIN	B,^Q		;^Q - QUOTE NEXT CHAR.
	CALL	TTICHR
	MOVEI	B,-40(B)	;NORMAL - CONV. TO SIXBIT.
	TLNE	V,770000	;PUT IN NAME IF ROOM LEFT.
	IDPB	B,V
	JRST	RFLOOP

RFXCTB:	MOVEM	0,RFILN+1		;TABLE EXECUTED BELOW
	MOVEM	0,RFILN2
	MOVEM	0,RFILN
	MOVEM	0,RFILSN
	SKIPA
DEFINE	SWITCH	A,D
	CAIN	B,"A
	HRROI V,D
TERMIN			;MACRO TO HANDLE NORMAL SWITCH.

RFCOL:	SKIPE	0
	MOVEM	0,RFILN
	SETOM	RFILP		;INDICATE NOT NULL.
	JRST	RFNAME

RFSEM:	SKIPE	0
	MOVEM	0,RFILSN	;SIMILAR BUT SET SNAME INSTEAD.
	SETOM	RFILP
	JRST	RFNAME

RFSPAC:	JUMPE	0,RFSPA0	;IF NAME WAS READ,
	XCT	@RFILNC		;STORE IT,
	AOS	RFILNC		;COUNT NAMES SO FAR.
	SETOM	RFILP		;SAY NON-NULL SPEC.
RFSPA0:	CAIN	B,^R		;^R - RESET FILENAME COUNTER.
	 JRST	RFNAM0
IFN TENEX,	CAIE B,".
	CAIN	B,40
	JRST	RFNAME		;SPACE -- GET ANOTHER NAME.
	CAIE	B,"/
	JRST	RFSPA1		;SLASH -- READ A SWITCH
	CALL	TTICHR
	SETZ	V,
	SWITCH	B,BSWBIT	;/B - SUPPRESS BINARY.
	SWITCH	C,CSWBIT	;/C - CREF LISTING.
IFN ITS,SWITCH	D,DSWBIT+NSWBIT	;/D - DISOWN SELF.
	SWITCH	E,ESWBIT	;/E - FORCE ERROR FILE OUTPUT.
	CAIN	B,"H		;/H - DOUBLE SYMTAB SIZE.
	 JRST	[AOS HSWCNT ? JRST RFNAME]
	CAIN	B,"L		;/L - ONCE => LIST, TWICE => BOTH PASSES.
	 JRST	[AOS LSWCN1 ? JRST RFNAME]
	SWITCH	M,MSWBIT	;/M - NO MACRO LISTING.
	SWITCH	N,NSWBIT	;/N - NO ERROR MSGS ON TTY.
	SWITCH	P,PSWBIT	;/P - BINARY ON PTP:.
	SWITCH	R,RSWBIT	;/R - REPRODUCE SOURCE IN LISTING.
	SWITCH	S,SYMBIT	;/S - NO SYMS IN BINARY.
	CAIE	B,"T		;/T - COMPLEMENT TTY-TYPE LISTING.
	JUMPE	V,ERRSW		;IF INVALID SWITCH.
	TLO	F,(V)
	TRNN	V,-1		;HANDLE /T SPECIALLY.
	TLC	AF,TTYFLG
	JRST	RFNAME		;SWITCH DONE, READ ANOTHER NAME.

RFSPA1:	CAIN	B,"_
	TRO	F,ARWBIT	;_ -- SAY SAW AN _.
	CAIN	B,"_	;IF THIS SPEC WAS THE LAST OUTPUT SPEC,
	 SETOM	RFILP	;ASSUME NON-NULL.
	CAIN	B,^M
	TRO	F,ENDBIT
POPVJ:	REST	V
	RET
;COME AFTER READING AN "@";  READ IN CMD FILE NAME, OPEN IT.
IFE TENEX,[			;NOT IMPLEMENTED YET
RFATSN:	SAVE	RFILP,RFILNC,N,S,RFILSN
	MOVSI	B,-3
RFATS0:	SAVE	RFILN(B)	;SAVE, ZERO FILEAMES.
	SETZM	RFILN(B)
	AOBJN	B,RFATS0
	CALL	RFILE		;READ CMD FILE NAMES.
	MOVEI	B,(SIXBIT/CMD/)
	SKIPN	RFILN2
	MOVSM	B,RFILN2	;DEFAULT THE FN2.
	MOVSI	B,'DSK
	SKIPN	RFILN
	MOVEM	B,RFILN		;DEFAULT THE DEV.
	SKIPE	B,CMDFIL	;IF ALREADY INSIDE CMD FILE,
IFN TENEX,[CALL [MOVE N,CMDCJF
		MOVEM N,CMDPDL(B) ;REMEMBER JFN OF OUTER CMD FILE.
		RET]]
IFN ITS,.IOPUS	CMDC,		;SAVE IT.
	AOS	CMDFIL
	MOVEI	S,CMDCJF-JFN
	CALL	IINIT		;INIT. INPUT FILE ON(OR PUT) CHNL IN CMDJFN
	 CALL	OPENL
	REST	RFILN2,RFILN1,RFILN,RFILSN,S,N,RFILNC,RFILP
	MOVEI	B," 		;SPACE BEFORE CMD FILE.
	TRZ	F,ENDBIT	;IN CASE CR AFTER CMD FILE SPEC.
	JRST	RFSPAC
]
;GET NEXT CMD STRING CHAR.
TTICHR:	TRZE	F,CHRBIT	;CHRBIT => RE-READ LAST SOURCE CHAR.
	 JRST	[LDB B,IP ? JRST TTILC]
	TRNE	F,INSBIT	;IF READING FILENAME FOR .INSRT,
	 JRST	[CALL	@GETCHA	;READ FROM ASSEMBLY INPUT,
		 MOVEI	B,(I)
		 JRST	TTILC]
	SKIPE	CMDFIL		;IF NO CMD FILE, GET FROM COMMAND BUF
	JRST	TTICH1
	SOSGE	TTICNT		;IF NO CHARS LEFT,
	SKIPA	B,[^M]		;SAY EOL.
	ILDB	B,TTIPNT	;ELSE GET NEXT CHAR FROM BUFFER.
TTILC:	CAIL	B,140		;CONVERT LOWER CASE TO UPPER.
	SUBI	B,40
	RET

TTICH1:	UNIIB	CMDC		;READ FROM CMD FILE INTO B.
	CAIL	B,140		;LOWER CASE TO UPPER.
	SUBI	B,40
	CAIE	B,^J		;TREAT ^M, ^J IN FILES AS SPACES.
	CAIN	B,^M
	MOVEI	B," 
	CAIN	B,^L
	JRST	TTICH2		;^L ENDS CMD FILE.
	CAIE	B,^C
	JUMPGE	B,CPOPJ
TTICH2:	SAVE	A,B,S		;EOF IN CMD FILE, POP OUT OF IT.
	MOVEI	S,CMDCJF-JFN
	CALL	ICLOSE		;CLOSE INPUT ON CHNL IN CMDCJFN
	SOSE	B,CMDFIL
IFN ITS,.IOPOP	CMDC,		;ANOTHER CMD FILE OUTSIDE, POP IT.
IFN TENEX,[CALL	[MOVE B,CMDPDL(B)
		MOVEM B,CMDCJFN	;RESTORE CMD JFN TO THAT OF OUTER FILE.
		RET]]
	REST	S,B,A
	MOVEI	B," 		;PUT SPACE AFTER CMD FILE.
	RET
;I/O ROUTINES

LSTSP:	MOVEI	B," 
	JRST	LSTOUT
LSTCR:	TDZA	B,B
LSTTAB:	MOVEI	B,11
LSTOUT:	TRZE	F,HDRBIT	;START NEW PAGE IF WAS REQUESTED.
	CALL	HEADER
LSTSRC:	NEWLIN	LSTDMP		;TURN ^@ INTO ^M^J.
LSTDMP:	TLNE	F,TTYBIT	;IF LISTING ON TTY,
	JRST	LSTDM0		;WRITE ON IT INSTEAD.
	SOSG	LSTCNT		;DECREMENT ITEM COUNT
	CALL	LIST1		;EMPTY ENTIRE BUFFER
	IDPB	B,LSTPNT	;STORE THE CHARACTER
LSTDM1:	CAIE	B,^J		;IF LF,
	RET
	SOSG	LINCNT		;COUNT 1 LINE IN PAGE.
	TRO	F,HDRBIT
	RET

LSTDM0:	CALL	TYO
	JRST	LSTDM1

LIST1:	SAVE	A,B,C,W
	HRRZ	C,LSTCNT
	SUBI	C,5*LSTBSZ	;-<# CHARS TO OUTPUT>
	MOVE	B,[440700,,LSTBUF]
	MOVEM	B,LSTPNT
	OUTBFR	LST,5
	MOVEI	A,5*LSTBSZ
	MOVEM	A,LSTCNT
	REST	W
	JRST	POPCBA

LSTCLS:	SOS	LSTCNT		;LIST1 ASSUMES LSTCNT SOS'S ONCE TOO MANNY.
IFN ITS,[
	MOVE	A,LSTCNT
	IDIVI	A,5
	MOVEI	C,3
LSTCL1:	SOJL	B,LSTCL2
	SOS	LSTCNT
	IDPB	C,LSTPNT
	JRST	LSTCL1
LSTCL2:	]
	SKIPL	LSTPNT		;IF ANYTHING WAS EVER OUTPUT,
	 CALL	LIST1		;WE HAVE A PARTIAL BUFFER TO WRITE OUT.
	MOVEI	S,LSTDEV
	JRST	OCLOSE		;CLOSE FILE (MAYBE RENAME)
;START NEW PAGE IN LISTING.
HEADER:	SAVE	F,0,A,B
	TLO	F,NSWBIT	;DON'T OUTPUT TO TTY
	TLZ	F,ERRBIT	;  OR ERROR FILE.
	MOVEI	B,14		;OUTPUT A FORM FEED
	CALL	LSTDMP
	MOVEI	B,PAGSIZ+3	;RESET LINE COUNTER REGISTER
	MOVEM	B,LINCNT
	TLNE	F,RSWBIT	;NO HEADERS IF OUTPUTTING SOURCE.
	JRST	HEADE2
	CALL	LSTTAB
	MOVE	N,[440700,,TITBUF]
	CALL	LSTSTR		;LIST THE TITLE.
	CAME	N,[350700,,TITBUF]
	CALL	LSTTAB		;AND TAB IF TITLE NONNULL.
	MOVE	N,[SIXBIT/INPALX/]
	CALL	LSTSIX
	CALL	LSTSP
	MOVE	N,[.FNAM2]	;PRINT VERSION NO.
	CALL	LSTSIX
	CALL	LSTTAB
	MOVE	N,[440700,,DATTIM]
	CALL	LSTSTR
PPAGE==[440700,,[ASCIZ/	PAGE /]]
	MOVE	N,PPAGE
	CALL	LSTSTR		;PRINT '	PAGE '
	AOS	A,PAGTOT	;PRINT LISTING PAGE'S NUMBER.
	CALL	ERRDEC
	CALL	LSTCR
	CALL	LSTTAB
	CALL	LSTFIL		;PRINT SRC FILE'S NAME
	MOVE	N,PPAGE
	CALL	LSTSTR		;PRINT '	PAGE '
	MOVE	A,PAGNUM	;AND SRC PAGE'S NUMBER.
	CALL	ERRDEC
	AOSN	A,PAGEXT
	JRST	HEADE1
	MOVEI	B,".		;HANDLE CONTINUATION PAGES' NUMBERS.
	CALL	LSTDMP
	CALL	ERRDEC
HEADE1:	CALL	LSTSP
	CALL	LSTTAB
	MOVE	0,[440700,,STITBF]
	CALL	LSTSTR		;LIST SUBTITLE.
	CALL	ERR2CR
HEADE2:	REST	B,A,0,F
	RET

;OUTPUT ASCIZ STRING <- BP IN N TO LST.
LSTSTR:	ILDB	B,N
	JUMPE	B,CPOPJ
	CALL	LSTDMP
	JRST	LSTSTR

TTYOUT:	NEWLIN	TYO		;TURN ^@ INTO ^M^J.
TYO:
TTYDMP:	UNIOB	TTO
	RET

TTYCR:	SAVE	B
	MOVEI	B,^M
	CALL	TYO
	MOVEI	B,^J
	CALL	TYO
	JRST	POPBJ

;OUTPUT SIXBIT WD IN N TO TTY.
TTOSIX:	SAVE	B
TTOSI1:	SETZ	A,
	ROTC	N,6
	JUMPE	A,POPBJ
	MOVEI	B,40(A)
	CALL	TYO
	JRST	TTOSI1
;GET CHAR FROM SOURCE FILE.
GCHS:	ILDB	I,SRCPNT
	CAIGE	I,^M		;IF ORD. CHAR,
	JRST	GCHS0
GCHR1:	IDPB	I,IP		;SAVE FOR RESCAN, LISTING.
	MOVEM	IP,LINIP
	CAMN	IP,[010700,,LINBUF+CPL/5]
	CALL	GCHSEL		;IF FULL, LIST NEXT TIME.
	RET

GCHS0:	CAIN	I,^J
	JRST	GCHSLF
	CAIN	I,^L		;HANDLE SPECIAL CHARS.
	JRST	GCHSFF
	CAIE	I,^C		;ONLY ^C, ^J, ^L REALLY SPECIAL.
	JRST	GCHR1
	MOVE	I,SRCPNT	;^C - AT END OF BUFFER?
	CAMN	I,SRCBND
	JRST	GCHBUF		;YES, READ NEXT BUFFER.
	JRST	GCHEOF		;NO,  THIS IS EOF.

GCHSFF:	AOS	PAGNUM		;FF - INCREM SOURCE PAGE.
	SETOM	PAGEXT
	SETZM	SLNCNT		;1ST LINE THEREOF.
GCHMFF:	TRO	F,HDRBIT	;NEW LISTING PAGE.
	JRST	@GETCHA		;SKIP FF, GET ANOTHER CHAR.

;LF - INCREM SOURCE LINE NUM, SAY HAVE WHOLE LINE.
GCHSLF:	AOS	SLNCNT
GCHMLF:	CALL	GCHSEL
	JRST	GCHR1		;STORE CHAR AS USUAL.
;READ NEXT SOURCE BUFFER.
GCHBUF:	SKIPE	SRCEOF		;IF INTERNAL EOF,
	JRST	GCHEOF		;GET NEXT FILE.
	SKIPE	SRCTTY
	JRST	GCHTTY		;IF FROM TTY, HANDLE RUBOUTS.
IFN ITS,[
	HRRZ	I,SRCBPT	;ADDR OF START OF BUFFER.
	HRLI	I,-SRCBSZ	;AOBJN -> BUFFER.
	.IOT	SRC,I		;READ IN BUFFERFULL.
	HLRZ	I,I
	MOVEI	I,SRCBSZ(I)	;NUM. WDS READ.
	JUMPE	I,GCHEOF		;NONE READ MEANS EOF.
	ADD	I,SRCBPT
	MOVEM	I,SRCBND	;POINT AFTER LAST WD READ.
]
IFN TENEX,[
	SAVE A,B,C
	MOVE A,SRCJFN
	HRRO B,SRCBPT
	MOVNI C,5*SRCBSZ
	SIN
	MOVEM B,SRCBND
	MOVEI I,SRCBSZ*5(C)
	REST C,B,A
	JUMPE I,GCHEOF
]
GCHBF1:	MOVEI	I,^C
	IDPB	I,SRCBND	;PUT ^C AFTER BUFFER.
GCHBF2:	MOVE	I,SRCBPT
	MOVEM	I,SRCPNT
	JRST	GCHS		;GO READ 1ST OF CHARS READ.

;READ SOURCE LINE FROM TTY.
GCHTTY:	SAVE	TTIPNT,TTICNT	;TTILIN WILL CLOBBER THESE.
	CALL	TTILN
	MOVEI	I,^M
	IDPB	I,TTIPNT
	MOVEI	I,^J
	IDPB	I,TTIPNT	;TERMINATE LINE PROPERLY.
	MOVE	I,TTIPNT
	MOVEM	I,SRCBND	;REMEMBER END OF BUFFER.
	REST	TTICNT,TTIPNT
	JRST	GCHBF1		;SET UP SRCPNT, READ 1ST CHAR.

GCHEOF:
	SKIPN	SRCDPH		;IF EOF IN .INSRT FILE,
	 JRST	GCHEO1
IFN ITS,[
	LDB	I,[121000,,SRCBPT]	;FLUSH THE FILE'S BUFFER.
	SYSCAL	CORBLK,[1000,, ? 1000,,-1 ? I]
	.IOPOP	SRC,
]
IFN TENEX,[
	SAVE	A,B,C,S
	SETO	A,		;INDICATE DELETE PAGE,
	LDB	B,[111100,,SRCBPT]	;GET PAGE #,
	HRLI	B,4^5		;SAY IN SELF.
	SETZ	C,
	PMAP			;DELETE THE 2 PAGES USED FOR A BUFFER.
	AOS	B
	PMAP
	MOVEI	S,SRCJFN-JFN
	CALL	ICLOSE		;RELEASE THE JFN OF FILE JUST ENDED.
	REST	S,C,B,A
]
	HRRO	I,MACPDP	;GET SRCPDL PTR, -1 IN LH SO NO PDLOV
IRPS X,,[MP SRCNUM SRCBND SRCPNT SRCBPT SRCTTY PAGNUM PAGEXT SLNCNT
RFILN RFILN1 RFILN2 RFILSN]
	POP	I,X
TERMIN
IFN TENEX,POP	I,SRCJFN
	HRRM	I,MACPDP
	TRO	F,HDRBIT	;NEW PAGE IN LISTING.
	SOS	SRCDPH		;EXITED 1 .INSRT FILE.
	SETZM	SRCEOF
	CALL	GCHSET		;MIGHT BE POPPING INTO MACRO.
	JRST	@GETCHA		;TRY AGAIN TO READ CHAR.

GCHEO1:	TRNE	F,ENDBIT	;CRR SEEN BY COMMAND SCANNER?
	JRST	GCHSND		;NO, NO END STMT.
	CALL	GETSRC		;GET THE NEXT SOURCE FILE
	JRST	GCHBUF

;COME HERE ON EOF OF LAST SRC FILE.
GCHSND:	ERROR1	NO END STMT
	TLO	AF,ENDFLG	;MAKE THIS LAST LINE OF PASS.
	MOVEI	I,^J
	JRST	GCHSLF		;MAKE THIS LAST CHAR OF LINE.
;GET CHAR FROM MACRO.
GCHM:	ILDB	I,MP
GCHM1:	CAIL	I,^K
	JRST	GCHR1		;<15, ORD. CHAR, JUST STORE & GO.
	JUMPE	I,GCHMNL	;^@ - GO TO NEXT BLOCK.
	CAIN	I,^J
	JRST	GCHMLF		;^J - HAVE WHOLE LINE.
	CAIE	I,^C
	JRST	GCHR1		;ALL BUT ^C NORMAL CHARS.
	CALL	READMB		;^C - SPECIAL CODE FOLLOWS.
	TRZE	I,100		;IF >= 100,
	JRST	GETDS		; MEANS SUBSTITUTE A MACRO ARG.
	CALL	@GCHMT-1(I)	;ELSE MEANS POP THIS STRING.
	JRST	@GETCHA	;AFTER TERMINATING, GET NEXT CHAR.

GCHMT:	PHASE	1
QUEMAC::@MACXIT		;^C^A - END READING STRING (REPEAT, IRP OR MACRO)
QUEARG::DSEND		;^C^B - END MACRO ARG.
	DEPHASE

GCHMNL:	HRR	MP,(MP)	;^@ - TRACE LINK TO NEXT BLOCK.
	LDB	I,MP
	JRST	GCHM1


;GET CHAR WHILE RESCANNING.
GCHI:	CAMN	IP,LINIP
	JRST	GCHI0
	ILDB	I,IP
	RET
GCHI0:	CALL	GCHSET		;DONE REREADING, CHOSE NEW SOURCE,
	SETCHAR
	CAIE	I,^J		;RESET GCHL IF NEC.
	CAMN	IP,[010700,,LINBUF+CPL/5]
	CALL	GCHSEL
	JRST	GETCHR		;GET CHAR FROM IT.

GCHSET:	MOVEI	I,GCHM		;IF MP>0 USE GCHM
	JUMPN	MP,GCHSE1
GCHSE0:	MOVEI	I,GCHS		;ELSE READ FROM SRC.
GCHSE1:	HRRM	I,GETCHA
	RET
;START NEW LINE, READ 1ST CHAR.
GETLIN:	MOVE	IP,LINPNT
	MOVEM	IP,LINIP	;RE-START BUFFER.

;READ 1 CHAR INTO I.  IMPURE!!
GETCHR:
GETCHA:	JRST	GCHS		;OR GCHM, GCHI, GCHL .

GCHL:	SAVE	A,B
	CALL	ENDLA		;DECIDE WHETHER TO LIST.
	TRNE	AF,ERRP1	;IF WERE ERRORS,
	MOVEI	A,ERROUT	; PRINT ON TTY.
	CALL	LOTAB		;IN TTY FMT LISTING, 2 TABS.
	CALL	(A)
	TLNN	AF,TTYFLG
	CALL	(A)		;NORMAL FMT, 2 MORE.
	TLNN	AF,TTYFLG
	CALL	(A)
	MOVE	I,LINPNT
	ILDB	B,I		;FETCH & LIST
	CALL	(A)
	CAME	I,LINIP		;TILL LAST CHAR.
	JRST	.-3
	CAIN	B,^J		;IF DIDN'T END W/ CRLF,
	JRST	GETCH3
	MOVEI	B,^M		;OUTPUT CRLF ANYWAY.
	CALL	(A)
	MOVEI	B,^J
	CALL	(A)
GETCH3:	REST	B,A
	CALL	GCHSET		;RESTORE SOURCE.
	JRST	GETLIN		;RESTART BUFFER, FETCH.

;SET TO LIST LINE WHERN FETCH NEXT CHAR.
GCHSEL:	TLO	AF,SRCFLG
	MOVEI	IP,GCHL
	HRRM	IP,GETCHA
	MOVE	IP,LINIP
	RET
;ROUTINE TO OUTPUT RELOCATABLE BINARY


BINOUT:				;BINARY OUTPUT
	ANDI	B,377		;MASK TO 8 BITS
SYMOUT:	TLNE	F,PSWBIT
	JRST	BINPPB
	SOSG	BINCNT
	CALL	BINDMP
	IDPB	B,BINPNT
	RET

BINPPB:	UNIOB	BIN
	RET

BINDMP:	SAVE	A,B,C
	MOVE	C,BINCNT
	SUBI	C,DATLEN	;-<# WDS TO OUTPUT>
	MOVE	B,[444400,,DATBLK]
	MOVEM	B,BINPNT
	OUTBFR	BIN
	MOVEI	A,DATLEN
	MOVEM	A,BINCNT	;BUFFER NOW EMPTY.
POPCBA:	REST	C
POPBAJ:	REST	B
POPAJ:	REST	A
	RET

;CLOSE BINARY FILE.
BINCLS:	TLZN	F,BINBIT	;NO MORE BIN OPEN.
	RET
	TLNE	F,PSWBIT	;DON'T .IOT IF UNIT MODE.
	JRST	BINCL1
	MOVE	B,BINCNT	;(NOTHING EVER PUT IN BIN BUFFER =>
	CAIN	B,1+DATLEN	;DON'T TRY TO WRITE IT OUT.
	 JRST	BINCL1		;PREVENTS IOCERR IF NO BIN FILE)
	SETZ	B,		;OUTPUT A ZERO TO MAKE SURE
	CALL	BINOUT		;LOADERS WILL SEE EOF.
	SOS	BINCNT		;(SYMOUT DOES THIS SO I WILL)
	CALL	BINDMP		;OUTPUT PARTIAL BUFFER.
BINCL1:	MOVEI	S,BINDEV
	SETZ	N,
	JRST	OCLOSE		;CLOSE, MAYBE RENAME.

IFN ITS,[
OCLOSE:	SKIPE	NONFTL		;DON'T RENAME BIN, LST AFTER FATAL ERROR.
OCLOS1:	SYSCL	RENMWO,[JFN(S) ? FN1(S) ? FN2(S)]
	 JFCL
ICLOSE:	SYSCAL	CLOSE,[JFN(S)]
	RET
]
IFN TENEX,[
OCLOSE:	SKIPE NONFTL
OCLOS1:	CALL	ORENM
ICLOSE:
CLOSER:	SKIPGE A,JFN(S)
	RET
	GTSTS
	JUMPGE B,CLOSR1
	CLOSF
	  JFCL
	JRST CLOSR2
CLOSR1:	RLJFN
	  JFCL
CLOSR2:	SETOM JFN(S)
	RET

CLOSEK:	SKIPGE 0(A)
	RET
	MOVE A,(A)
	HRLI A,400000
	CLOSF
	  JFCL
	RET

ORENM:	SKIPGE A,JFN(S)
	RET
	DVCHR
	TLNN B,100000
	 RET
	CLOSK JFN(S)
	MOVEI A,FN1(S)
	CALL JBKINI
	MOVEI A,JBLOCK+2
	SKIPE C,DEV(S)
	CALL JBKSIX
	MOVSI A,600000
	MOVEM A,JBLOCK
	MOVEI A,JBLOCK
	MOVEI B,0
	GTJFN
	  JRST RNMXXX
	MOVE B,A
	MOVE A,JFN(S)
	RNAMF
	  JRST RNMXXX
	MOVEM B,JFN(S)
	RET

RNMXXX:	HRROI A,[ASCIZ /
? FILE RENAME ERROR.
/]
	PSOUT
	RET

JBKINI:	PUSH P,A
	MOVEI A,JBKSTR
	MOVEM A,JBKSPT
	SETZM JBLOCK
	MOVE A,[JBLOCK,,JBLOCK+1]
	BLT A,JBLOCK+10
	MOVE A,[377777,,377777]
	MOVEM A,JBLOCK+1
	MOVEI A,JBLOCK+4	;NAME
	CALL JBKINS
	MOVEI A,JBLOCK+5	;EXT
	CALL JBKINS
	MOVEI A,JBLOCK+3	;USER
	CALL JBKINS
	JRST POPAJ

JBKINS:	AOS C,-1(P)
	SKIPN C,-1(C)
	RET
JBKSIX:	MOVE B,JBKSPT		;CALLED HERE, A/ DSP ADDR, B/ SIXBIT

	HRLI B,440700
	MOVEM B,0(A)
	MOVE A,B
	AOS JBKSPT
	AOS JBKSPT
	MOVEI B,0
	LSHC B,6
	ADDI B,40
	IDPB B,A
	JUMPN C,.-4
	MOVEI B,0
	IDPB B,A
	RET
]
ERRTMS:	CALL	ERRFCR
	MOVEI	A,[ASCIZ/TOO MANY SYMBOLS/]
	JRST	CMDERR

ERRSW:	SAVE	B		;SAVE BAD SWITCH.
	CALL	ERRFCR		;TURN ON TYPEOUT AND CRLF.
	MOVEI	B,"/
	CALL	ERROUT
	REST	B
	CALL	ERROUT		;PRINT THE SWITCH.
	MOVEI	A,[ASCIZ / IS A BAD SWITCH/]
CMDERR:	CALL	ERRSTR
	CALL	ERRCR
CMDER0:	SETZM	CTLCF		;ERROR - GIVE USER ANOTHER CHANCE.
IFN ITS,	.RESET	TTI,
IFN TENEX,[	MOVE A,TTIJFN
	CFIBF
]
	JRST	FINIS2

;COME HERE AFTER FAILING OUTPUT OPEN.
OPENLB:	HRLI	B,(S)
	HRRI	B,RFILN
	BLT	B,RFILSN
OPENL:	CALL	ERRFCR
	CALL	LSTFIL		;PRINT NAME OF LOSING FILE.
	MOVEI	B,^I
	CALL	ERROUT
	TRO	F,ENDBIT	;PREVENT ERRTF MESSAGE.
IFN ITS,[
	.OPEN	ERRC,OPENLF
	.VALUE
OPENL0:	.IOT	ERRC,B
	CAIN	B,^L
	JRST	CMDER0
	CALL	ERROUT
	JRST	OPENL0

OPENLF:	SIXBIT/   ERR/
	1?0
]

IFN TENEX,[
	MOVEI	B,400000
	MOVEI	A,101
	MOVEI	C,0
	ERSTR
	 JFCL
	 JFCL
	JRST	CMDER0
]
;ERROR UUO.
UERROR:	TLNE	AF,P1F		;DO NOTHING ON PASS 1.
	JRST	UUOXIT
;ERROR1 UUO.
UERR1:	CALL	ERRFIL		;PRINT FILENAMES IF NEC.
	AOS	ERRCNT		;TALLY ERROR.
	SAVE	N		;HAS SYM. BEING USED, MAYBE.
	MOVE	N,LLABN
	SKIPN	LLABN		;IF DEFINED A LABEL,
	JRST	UERR2
	CALL	LSTSIX		;PRINT . REL. TO IT.
	MOVN	A,LLABV
	ADD	A,L
	ANDI	A,177777
	JUMPE	A,UERR3		;JUST LABEL IF DISP=0.
	MOVEI	B,"+
	CALL	ERROUT		;AS LABEL+DISP.
	AOS	LINPOS
	CALL	ERROCT
UERR3:	MOVE	N,LINPOS	;MOVE TO POS. 16.
	CAIGE	N,10
UERR2:	CALL	ERRTAB		;NO LABEL, JUST PRINT 2 TABS.
	CALL	ERRTAB
	REST	N
	MOVEI	A,(L)
	CALL	ERROCT		;PRINT LOC. CTR.
	CALL	ERRTAB
	MOVE	A,PAGNUM
	CALL	ERRDEC		;PAGE, LINE NUMBERS.
	CALL	ERRTAB
	MOVE	A,SLNCNT
	AOJ	A,
	CALL	ERRDEC
	CALL	ERRTAB
	HRRZ	A,40
	CALL	ERRSTR		;PRINT ERROR MESSAGE.
	CALL	ERRCR
	JRST	UUOXIT

ERRFCR:	SETZM	CTLSF	;TURN ON TYPEOUT AND CRLF.
	TLZA	F,NSWBIT
ERR2CR:	CALL	ERRCR
ERRCR:	TDZA	B,B
ERRSP:	MOVEI	B," 

;OUTPUT CHAR IN B AS PART OF ERROR MSG (TO LST, MAYBE TO TTY).
ERROUT:	NEWLIN	ERROU1
ERROU1:	TLNE	F,ERRBIT	;OUTPUT TO ERR FILE IF ANY.
	CALL	ERROU2
	TLNN	F,NSWBIT+TTYBIT	;IF LST IS TTY OR ERROR MSGS SUPPR,
	CALL	TYO		; DON'T OUTPUT TO TTY.
	TLNN	F,LSTBIT	;OUTPUT TO LST IF HAVE ONE.
	RET
	JRST	LSTOUT

ERROU2:	UNIOB	ERR
	RET
;DECIMAL PRINT.
ERRDEC:	SKIPA	B,[10.]		;SET RADIX 10.
ERROCT:	MOVEI	B,10		;OR 8.
	MOVEM	B,ERRRDX'	;SAVE IT.
ERROC1:	IDIV	A,ERRRDX
	HRLM	B,(P)		;SAVE NEXT DIGIT.
	SKIPE	A
	CALL	ERROC1
	HLRZ	B,(P)		;GET DIGITS IN REVERSE ORDER.
	ADDI	B,"0
	AOS	LINPOS
	JRST	ERROUT

;PRINT A TAB.
ERRTAB:	MOVEI	B,^I
	JRST	ERROUT

;PRINT ERROR MESSAGE.
ERRSTR:	HRLI	A,440700
ERRMS1:	ILDB	B,A
	CAIG	B,^H		;CTL CHARS ARE SPECIAL.
	JRST	ERRMS2
	CALL	ERROUT
	JRST	ERRMS1
ERRMS2:	XCT	ERRMST(B)
	JRST	ERRMS1

;TABLE OF ACTIONS ON CHARS 0 THRU 8.
ERRMST:	RET			;END OF ASCIZ.
	CALL	LSTSIX		;PRINT SYMBOL'S NAME.
	JRST	ERRMSB		;^B - SET RETURN ADDR.
	JFCL
	TRO	AF,ERRP1		;^D - FORCE LISTING OF LINE.

ERRMSB:	HRRZ	B,(A)		;SET RET ADDR FROM RH OF WD IN STRING.
	HRRM	B,-4(P)
	TLZ	A,77^4		;SKIP CHARS LEFT IN WD.
	JRST	ERRMS1

;TYPE NAME OF CURRENT INPUT FILE ON TTY.
ERRFIL:	SAVE	F,0
	TLZ	F,LSTBIT	;SO LSTFIL WON'T WRITE TO LST.
	MOVE	N,SRCNUM	;GET # OF FILE OF LAST ERROR.
	CAMN	N,SRCERR	;IF PREV. ERROR WAS IN OTHER FILE,
	JRST	ERRFI1
	MOVEM	N,SRCERR	;SAY LAST ERROR WAS IN THIS FILE.
	MOVE	0,[SIXBIT/FILE/]
	CALL	LSTSIX		;PRINT "FILE" AND FILE'S NAME.
	CALL	ERRTAB
	CALL	LSTFIL
	CALL	ERRCR
ERRFI1:	REST	0,F		;ELSE DO NOTHING.
	RET
;PRINT NAME OF CURRENT FILE ON LST, TTY, ERR.
LSTFIL:	MOVE	N,RFILN
	CAMN	N,[SIXBIT/DSK/]
	JRST	LSTFI1
	CALL	LSTSIX		;PRINT DEV IF NOT DSK.
	MOVEI	B,":
	CALL	ERROUT
	JRST	LSTFI2

LSTFI1:	IFN ITS,[
	MOVE	0,RFILSN	;IS DSK - PRINT SNAME
	CALL	LSTSIX
	MOVEI	B,";
	CALL	ERROUT
]
LSTFI2:	MOVE	0,RFILN1
	CALL	LSTSIX		;PRINT 1ST NAME.
	CALL	ERRSP
	MOVE	0,RFILN2
	JRST	LSTSIX		;, 2ND NAME.

;OUTPUT WD IN 0 AS SIXBIT TO LST, TTO, ERR.
LSTSIX:	SAVE	R6
	SETZM	LINPOS
	MOVSI	R6,440600
LSTSI1:	ILDB	B,R6
	JUMPE	B,POPR6J
	ADDI	B," 
	CALL	ERROUT
	AOS	LINPOS		;COUNT CHARS PRINTED.
	TLNE	R6,770000
	JRST	LSTSI1
POPR6J:	REST	R6
	RET

IFN TENEX,[
GETDAT:	GTAD
	MOVE	B,A		;INTERNAL TENEX FMT TIME AND DATE.
	HRROI	A,DATTIM	;INTO ASCII IN DATTIM.
	SETZ	C,
	ODTIM
	MOVEI	A,400000
	RUNTM			;GET RUNTIME THIS FORK.
	MOVEM	A,RUNTIM
	MOVEM	A,TIMDIV
	RET

TSEXIT:	RESET
	HALTF
]

IFN ITS,[
GETDAT:	MOVE	C,[440700,,DATTIM]
	.RDATE	N,		;DATE AS SIXBIT/YYMMDD/
	ROT	N,14		;NOW SIXBIT/MMDDYY/
	MOVEI	B,"/		;CHAR. TO SEPARATE NUMBERS WITH.
	CALL	GETDA1		;OUTPUT INTO DATTIM.
	MOVEI	B,40
	IDPB	B,C		;2 SPACES.
	IDPB	B,C
	.RTIME	N,		;SIXBIT/HHMMSS/
	MOVEI	B,":		;CHAR. FOR SEPARATOR.
	CALL	GETDA1
	.SUSET	[.RRUNT,,RUNTIM]
	RET

GETDA1:	MOVEI	I,6		;# CHARS TO GET OUT OF N.
GETDA2:	SETZ	A,
	ROTC	N,6		;NEXT CHAR. TO A.
	ADDI	A,40
	IDPB	A,C
	SOJE	I,CPOPJ		;AFTER 6TH, DONE.
	TRNE	I,1
	 JRST	GETDA2
	IDPB	B,C		;AFTER 2ND AND 4TH, SEPARATOR.
	JRST	GETDA2

TSEXIT:	.BREAK	16,140000
]
ASSEMB:				;ASSEMBLER PROPER
	TLNE	F,TTYBIT	;TELETYPE?
	TLC	AF,TTYFLG	;  YES, TOGGLE BIT FOR LISTING
	CALL	LINE		;GO DO PASS ONE.
	TLZ	AF,P1F		;RESET TO PASS 2
	AOS	VALREQ		;NORMALLY NEED VALUES.
	SETZM	TSLWRD
	SETZM	STITBF
	MOVEI	B,1		;DEFAULT START ADDR IS 1.
	MOVEM	B,STRTLC
	TRZ	F,ENDBIT+FFBIT+ARWBIT
	MOVE	B,[440700,,TTIBUF]
	MOVEM	B,TTIPNT	;RESTART CMD STRING SCAN.
	MOVE	B,TTICSV
	MOVEM	B,TTICNT
	MOVE	B,MSNAME	;SET DEFAULT SNAME TO USER'S.
	MOVEM	B,RFILSN	;FOR THE 1ST INPUT FILE.
	SAVE	F
SETP2A:	TDNE	F,[NULBIT,,ARWBIT]
	JRST	SETP2B		;READ PAST OUTPUT SPECS.
	CALL	RFILE
	JRST	SETP2A
SETP2B:	REST	F
	AOS	LSWCNT		;LIST LINES NOW EVEN IF ONLY ONE /L.
	CALL	INIPAS
	CALL	GETSRC		;READ IN SRC FILE'S NAME, OPEN & INIT.
	CALL	BLKINI		;INITIALIZE BINARY OUTPUT BLOCK
	CALL	LINE		;CALL THE ASSEMBLER (PASS TWO)
	CALL	COMPRS
	TLNE	F,BINBIT
	CALL	DUMP2		;OUTPUT END BLOCK, SYMTAB TO BIN.
	TLNE	F,LSTBIT	;LISTING?
	CALL	SYMTB		;  YES, OUTPUT THE SYMBOL TABLE
	RET

INIPAS:	MOVEI	B,GCHS		;INIT. GETCHA TO GET FROM SRC.
	HRRM	B,GETCHA
	HLLZS	LOCTR		;CLEAR OFFSET.
	MOVE	B,[004400,,MACPDL-1]
	MOVEM	B,MACPDP	;INIT. MACRO PDL.
	SETZM	MACBPT
	SETZB	L,LLABN		;CLEAR LOCATION COUNTER
	SETZB	W,MP
	MOVSI	B,'DSK
	MOVEM	B,RFILN		;DEFAULT DEV. FOR 1ST SRC FILE.
	SETZM	SRCDPH		;NOT IN .INSRT FILE.
	SETOM	SRCCNT		;NOW READING 0TH SRC FILE.
	SETZM	SRCERR		;PRETEND HAD HAD ERROR IN THAT FILE.
	MOVE	B,[440700,,SRCBUF]
	MOVEM	B,SRCBPT	;B.P. TO OUTER LEVEL SRC BUFFER.
	TLZ	AF,SRCFLG+LINFLG+RSWFLG
	MOVEI	B,(CALL)
	TLNE	F,CSWBIT	;CREF IF /C AND PASS 2.
	TLNE	AF,P1F
	MOVEI	B,(JFCL)
	HRLM	B,CRFINS
	HRLM	B,CRFIND
	RET
LINE:	CALL	GETLIN
	CALL	STMNT		;PROCESS IT.
	TLZN	AF,ENDFLG	;TEST FOR END STATEMENT
	JRST	LINE		;GET THE NEXT LINE
	TRNN	F,ENDBIT	;IF FILSPECS REMAIN...
	ERROR1	EXTRA INPUT FILES
	RET			;END OF PASS


LINPNT:	440700,,LINBUF	;POINTER TO START OF LINE
TYPPNT:	221100,,1	;OP TYPE POINTER

ENDLR:	TLNE	F,RSWBIT	;SUPPRESS IF /R
	TLO	AF,RSWFLG	;SET LOCAL FLAG

ENDL:				;END OF LINE PROCESSOR
	CAIA
ENDL0:	CALL	GETCHR		;MOVE TILL EOL.
	CAIE	I,^J
	JRST	ENDL0

ENDLF:				;ENDL FIN
	HLRZ	B,W		;GET TYPE
	XCT	ENDLT2(B)	;EVEN LOCATION TEST
	ERROR1	WORD AT ODD ADDR.
	CALL	ENDLA		;DECIDE WHETHER TO LIST.

	TRNE	AF,ERRP1	;IF WAS ^D IN ERROR,
	MOVEI	A,ERROUT	; LIST ON TTY.
	CAIN	A,CPOPJ		;IF WOULDN'T LIST ANYWAY, SKIP WORK.
	JRST	ENDL11
	TLNN	F,RSWBIT	;/R => DON'T LIST OCTAL.
	CALL	PRNTA		;LIST THE OCTAL
	SETZ	B,
	TLNN	AF,SRCFLG	;IF HAVE FULL SRC LINE,
	JRST	ENDL10
	TLNN	F,RSWBIT
	CALL	LOTAB		; LIST IT.
	SKIPA	C,LINPNT	;GET SET TO PRINT LINE
ENDL9:	CALL	0(A)		;LIST A CHARACTER
	ILDB	B,C		;GET ANOTHER CHARACTER
	CAIE	B,^J
	JRST	ENDL9
ENDL10:	CALL	0(A)			;END,LIST CR/LF
	TLNN	F,RSWBIT
	CALL	PRNTB		;LIST EXTENSION LINE, IF ANY

ENDL11:	HLRZ	B,W		;GET TYPE
	XCT	ENDLT3(B)	;UPDATE LOCATION COUNTER
	 CALL	DUMP		;OUTPUT WDS IF NEC.
	ANDI	L,177777
	SETZB	W,CEXT1		;ZERO ARGUMENT
	SETZM	CEXT2		;  AND EXTENSIONS
	TRZ	AF,-1
	TLNE	AF,SRCFLG	;IF LISTED LINE, FLUSH CALL TO GCHL.
	CALL	[MOVE	IP,LINPNT	;RESET LINE BUFFER PTR
		 MOVEM	IP,LINIP	;TO BEG. OF BUFFER.
		 JRST	GCHSET]		;GETCHR SHOULDN'T TRY TO LIST LINE.
	TLZ	AF,LINFLG+RSWFLG+SRCFLG
	RET
ENDLT2:	PHASE	0
	CAIA
CL1:	CAIA			; ASSIGNMENT
CL2:	CAIA			; .=
CL3:	CAIA			; XXXXXX
CL4:	CAIA			;    XXX
CL5:	CAIA			; .END
CL6:	CAIA			; XXXXXX XXXXXX
CL7:	CAIA			; XXXXXX XXXXXX XXXXXX
	DEPHASE


ENDLT3:
	PHASE	0
	CAIA
CL1:	CAIA			; ASSIGNMENT
CL2:	SKIPA	L,W		; .=
CL3:	MOVSI	R6,-1		; XXXXXX
CL4:	MOVSI	R6,-1		;    XXX
CL5:	CAIA			; .END
CL6:	MOVSI	R6,-2		; XXXXXX XXXXXX
CL7:	MOVSI	R6,-3		; XXXXXX XXXXXX XXXXXX
	DEPHASE

;DECIDE WHETHER TO LIST.
ENDLA:	MOVEI	A,CPOPJ		;ASSUME DON'T LIST.
	SKIPN	TSLWRD		;MUST NOT BE .XLISTED,
	TLNN	F,LSTBIT	;MUST HAVE LISTING.
	RET
	TLNE	F,MSWBIT	;IF /M, MUSTN'T BE IN MACRO.
	JUMPN	MP,CPOPJ
	SKIPLE	LSWCNT		;NO /L, OR ONLY 1 /L AND PASS 1, => NO LIST.
	TLNE	AF,LINFLG+RSWFLG	;MUST BE NON-SUPPRESSED.
	RET
	MOVEI	A,LSTOUT	;OK, LIST.
	SKIPN	NOCREF
	TLNN	F,CSWBIT	;IF /C,
	RET
	MOVEI	B,CRFLIN	;INDICATE REAL LINE COMING UP.
	JRST	LSTOUT
STMNT:				;STATEMENT PROCESSOR
	SETZM	OFFST		;CLEAR ADDRESS OFFSET
	CALL	GETSYM		;TRY FOR SYMBOL
	 JRST	STMNT2		;  NO
	CAIN	I,":		;LABEL?
	JRST	LABEL		;  YES
	CAIN	I,"=		;ASSIGNMENT?
	JRST	ASGMT		;  YES
	CALL	SRCH
	 JRST	STMNT3		;TREAT AS EXPRESSION
	XCT	CRFINS
	MOVEI	W,(A)
	LDB	B,TYPPNT	;FOUND, GET TYPE
	JRST	@STMNJT(B)	;GO TO ROUTINE.

STMNJT:	PHASE	0
	STMNT3
NPOP::	STMNT3		;VALUE-RETURNING PSEUDOS.
PSOP::	JRST	0(A)	;PSEUDO-OP, GO TO ROUTINE
CNOP::	JRST	CONDIT	;CONDITIONAL
	IRPS X,,BG OP SC UN BC TR RT FL ML FS
	X!OP::	P!X!OP
	TERMIN
SPOP::	SPOPTB(A)	;MARK, SOB.
MAOP::	JRST	CALLM	;MACROS.
INOP::	JRST	PINOP	;%FNAM2 .
	DEPHASE

SPOPTB:	.VALUE		;NO SPECIAL INSN HAS CODE 0.
	JRST PMARK
	JRST PSOB

STMNT2:	CAIE	I,".		;LOC TYPE STATEMENT?
	JRST	STMNT4		;  NO
	CALL	GETNB		;POSSIBLY, GET NEXT NON-BLANK
	CAIE	I,"=
	JRST	STMNT3		;  NO
	CALL	GETCHR		;YES, BYPASS CHAR
	AOS	VALREQ		;UNDEFS SYMS ARE ERRORS.
	CALL	EXPRF		;EVALUATE THE EXPRESSION
	 ERROR1	NO VALUE AFTER ".="
	SOS	VALREQ
	SUB	V,LOCTR		;UN-OFFSET.
	LDB	W,[2000,,V]	;GET VALUE
	HRLI	W,CL2		;SET CLASS
	JRST	ENDL		;LIST AND EXIT

STMNT3:	RESCAN	SYMBEG
	SETCHAR			;RESET CHARACTER
STMNT4:	CALL	EXPRF		;GET AN EXPRESSION
	SKIPA			;  NO SOAP
	JRST	WORDF		;  YES, EXIT THROUGH "WORD"
	CAIN	I,",		;IS THERE A COMMA?
	JRST	WORDD		;YES, PROCESS A WORD OF ZERO.
	JRST	ENDL		;NO-EXIT NULL

LABEL:	CALL	GETCHR		;PASS BY THE COLON.
	CAIN	I,":
	TLOA	AF,HKLFLG	;ANOTHER COLON => .5KILL, PASS BY.
	TLZA	AF,HKLFLG
	CALL	GETCHR
	CALL	SRCH		;SEARCH USER TABLE
	JFCL
	MOVEI	B,@LOCTR	;GET POINT + OFFSET.
	TLNE	A,UNDSYM+SUPSYM	;OK TO DEFINE IF UNDEF.
	JRST	LABEL4
	TLNN	AF,P1F
	JRST	LABEL3		;PASS 2, JUST CHECK.
	LDB	W,TYPPNT
	JUMPN	W,[ERROR1 LABEL7,	IS RESERVED
		  ]
	CAIN	B,(A)		;ELSE ERROR IF NEW VALUE #OLD.
	TLNE	A,REGSYM+MDLSYM	;OR ALREADY HAD ONE.
	JRST	LABEL9

LABEL4:	HRRI	A,(B)		;GET LOC + OFFSET.
	TLZ	A,-1-NCRSYM	;DON'T CLEAR NO-CREF BIT.
	TLO	A,LBLSYM	;SET LABEL FLAG.
	TLZE	AF,HKLFLG	;IS THIS SYMBOL HALF KILLED?
	TLO	A,HKLSYM	;YES, SAY SO IN IT'S VALUE
	MOVEM	N,LLABN		;REMEMBER LAST LABEL DEFINED.
	HRRZM	A,LLABV
LABEL5:	CALL	INSRT		;DEFINE IT.
	JRST	STMNT		;EXIT.

;COME HERE FOR LABEL IN PASS 2 .
LABEL3:	TLNN	A,LBLSYM
	ERROR	LABEL4,	WASN'T A LABEL
	TLNE	A,MDLSYM
	ERROR	LABEL6,	MULT DEF LABEL
	CAIE	B,0(A)
	ERROR	LABEL6,	OUT OF PHASE
	MOVEM	N,LLABN		;REMEMBER LAST LABEL.
	HRRZM	A,LLABV
LABEL6:	XCT	CRFIND		;SAY IT'S BEING DEFINED.
	JRST	STMNT

;PASS 1 MULT DEF SYMS.
LABEL9:	ERROR1		LABEL ALREADY DEFINED
LABEL7:	TLO	A,MDLSYM	;SAY THIS SYM IS MUL DEF.
	JRST	LABEL5
ASGMT:				;ASSIGNMENT PROCESSOR
	PUSH	P,N		;STACK SYMBOL
	CALL	GETCHR		;BYPASS "=
	CAIN	I,"=		;== IS HALF KILLED
	TLOA	AF,HKLFLG
	TLZA	AF,HKLFLG
	CALL	GETCHR		;BYPASS SECOND =
	CALL	EXPR		;  EVAL EXPRESSION.
	 ERROR1	NULL VALUE IN ASGMT TO 
ASGMT0:	LDB	W,[POINT 16,V,35,]	;GET EXPRESSION VALUE.
	HRLI	W,CL1			;SET CLASS.
	POP	P,N		;GET SYMBOL
	CALL	SRCH		;SEARCH USER TABLE.
	 JFCL
	LDB	B,TYPPNT	;IF OLD VALUE A MACRO,
	CAIN	B,MAOP
	 CALL	REMMAC		;GIVE BACK STORAGE.
	CAIN	B,INOP
	 JRST	ASGMT5		;SETTING INDIR. OPS SPECIAL.
	TLNN	A,LBLSYM	;  LABEL?
	JRST	ASGMT1		;   NO
	MOVEI	B,(W)
	TLNN	AF,REGFLG	;ERROR IF NEW VALUE NOT = OLD.
	CAIE	B,(A)
	TLO	A,MDLSYM
ASGMT1:	TLNN	A,MDLSYM	;MUL DEF?
	JRST	ASGMT2		; NO
	ERROR1		LABEL BEING REDEFINED
	TLZ	A,UNDSYM	;   AND MAKE IT DEFINED
ASGMT4:	TLZE	AF,HKLFLG	;.5KILL IF NEC.
	TLO	A,HKLSYM
	XCT	CRFIND		;INDIC. BEING DEFINED.
	CALL	INSRT		;DEFINE SYMBOL AND EXIT.
	JRST	ENDL

ASGMT2:	TLZ	A,#NCRSYM#LBLSYM
	TLNE	AF,REGFLG	;REGISTER EXPRESSION?
	TLOA	A,REGSYM	;YES--FLAG AND TEST MAGNITUDE.
	TLZA	A,REGSYM	;NO--RESET AND SKIP TEST.
	CAIG	V,7		;YES--OUT OF RANGE?
	JRST	ASGMT3		;NO.
	ERRUU1	REGMES
	SETZ	V,		;CLEAR VALUE
ASGMT3:	TRNE	AF,ERRU		;ANY UNDEFINED ERRORS?
	TLO	A,UNDSYM	;YES, SET FLAG
	HRR	A,V		;GET VALUE
	JRST	ASGMT4		;GO INSERT IT.

ASGMT5:	DPB	W,[2000+A,,]	;SET IND. OP'S WORD.
	XCT	CRFIND
	JRST	ENDL
PBGOP:				;PROCESS BASIC GROUP OPS
	CALL	AEXP		;GET FIRST ARGUMENT
PSCOP1:	LSH	V,6		;ADJUST SOURCE
	ORM	V,W		;MERGE INTO BASIC
	SKIPE	CEXT1		;SKIP IF REGISTER TYPE
	AOS	OFFST		;FLAG SECOND FIELD
PRADDR:	CALL	PSOB3		;BYPASS COMMA, ERROR IF NONE.
	CALL	AEXP		;(UNARY OPS COME HERE) GET LAST ARG.
PRTOP2:	IOR	W,V		;MERGE INTO BASIC CODE
POPOP:				;PROCESS OPERATE OP
OPXIT:	AOS	INSCNT		;1 MORE INSTRUCTION.
	AOS	INSLEN		;UPDATE TOTAL LENGTH OF INSTRUCTIONS.
	HRLI	W,CL3		;ASSUME 1 WORD
	SKIPN	CEXT1		;TRUE?
	JRST	ENDL		;  YES, LIST AND EXIT
	AOS	INSLEN
	HRLI	W,CL6		;NO, ASSUME TWO
	SKIPN	CEXT2		;TRUE?
	JRST	ENDL
	AOS	INSLEN
	HRLI	W,CL7		;NO, SET FOR THREE
	JRST	ENDL		;LIST AND EXIT

PFSOP:	SKIPA	A,[3]		;FLOATING AC-TO-MEM, AC IS 0 TO 3.
	MOVEI	A,7		;JSR, AC IS 0 TO 7.
	CALL	REGEX1		;READ IN THE AC, CHECK IN BOUNDS.
	JRST	PSCOP1

PMARK:	MOVEI	W,6400		;REPLACE SPECIAL-INSN-COSE BY VALUE OF INSN.
	CALL	EXPRF		;READ ARG,
	 SETZ	V,
	TRZE	V,777700	;IT MUST FIT IN 6 BITS.
	 ERROR	MARK INSN ARG TOO LARGE
	JRST	PRTOP2

PFLOP:	CALL EXPRF
	 ERROR NULL ARGUMENT TO RST
	TRNE V,777707
	 ERROR BAD ARGUMENT TO RST
	JRST PRTOP2

PUNOP:	CALL EXPRF
	 ERROR NULL ARG TO INP
	TRNE V,777770
	 ERROR BAD ARG TO INP
	LSH V,1
	JRST PRTOP2

PSCOP:	CALL EXPRF
	 ERROR NULL ARG TO OUT
	TRNE V,777740
	 ERROR BAD ARG TO OUT
	TRNN V,30
	 ERROR BAD ARG TO OUT
	LSH V,1
	JRST PRTOP2

PMLOP:	CALL EXPRF
	 ERROR NULL IMMEDIATE ARG?
	TRNE V,777400
	 ERROR BAD IMMEDIATE ARG
	HRROM V,CEXT1
	JRST OPXIT
PSOB:	MOVEI	W,77000		;VALUE OF INSN, FOR PRTOP2.
	CALL	REGEXP		;READ # OF AC TO DECREMENT.
	LSH	V,6
	IORI	W,(V)		;PUT INTO INSN.
	CALL	PSOB3		;PASS COMMA, ERROR IF NONE.
	CALL	EXPRF		;READ ADDRESS TO BRANCH TO,
	 JRST	PBCOP2		;(ERROR IF NO ADDRESS)
	SUBI	V,@LOCTR	;GET OFFSET FROM CURRENT ADDR.,
	SUBI	V,2
	MOVNS	V			;BEFORE ".", NEGATE.
	ROT	V,-1
	ANDCMI	V,700000
	TDNN	V,[-100]	;ERROR IF WON'T FIT IN 6 BIT FIELD.
	 JRST	PRTOP2
	JRST	PBCOP2

PSOB3:	CAIE	I,",
	ERROR1	CPOPJ,MISSING COMMA
	JRST	GETCHR		;SKIP THE COMMA

PTROP:				;PROCESS TRAP/EMT OPS
	CALL	EXPRF		;GET EXPRESSION
	SETZ	V,		;NULL RETURN. ASSUME ZERO.
	TRZE	V,777400	;VALUE TOO BIG?
	 ERROR	TRAP/EMT CODE TO LARGE
	JRST	PRTOP2

PINOP:	HRRZ	W,(W)		;INDIRECT OP.
	JRST	POPOP

PBCOP:				;PROCESS BRANCH ON CONDITION
	CALL	EXPRF		;EVALUATE EXPRESSION
	JRST	PBCOP2		;  NULL, ERROR
	LDB B,[1000,,V]
	HRROM B,CEXT1
	LDB B,[100600,,V]
	HRROM B,CEXT2
	TRNN V,740000
	JRST OPXIT
PBCOP2:	SETZB	V,W		;  YES, SET TO A HALT.
	ERROR	BRANCH OUT OF RANGE
	JRST	OPXIT

PRTOP:				;PROCESS RETURN JUMP
PRTOP1:	CALL	REGEXP		;GET A REGISTER EXPRESSION
	JRST	PRTOP2
;EXPRESSION HANDLERS

AEXP:				;"A EXPRESSION EVALUATOR
AEXP01:	SETZ	V,
	CALL	SETNB		;GET A NON-BLANK
	CAIN	I,"#
	JRST	AEXP02
	CAIN	I,"(
	JRST	AEXP06
	CAIN	I,"-
	JRST	AEXP07
	CAIN	I,"@
	TLOA	AF,INDFLG	;IF INDIR., SAY SO.
	JRST	AEXP10		;NO UNARIES, PROCESS BASIC EXPRESSION
	CALL	GETCHR		;SKIP TH "@"
	JRST	AEXP01		;GO READ ADDR.


AEXP02:				; #
	CALL	GETCHR		;BYPASS UNARY OP
	CALL	EXPRF		;EVALUATE EXPRESSION
	 ERROR1	NULL EXP. IN INSN.
AEXP21:	MOVE	B,OFFST
	HRROM	V,CEXT(B)	;STORE ADDRESS
	MOVEI	V,27		;(PC)+ MODE.
	JRST	AEXPXT

AEXP05:	CAILE	V,7		;ANY OVERFLOW?
	ERRUU1	REGMES		;OVERFLOW.
AEXPXT:	TLZE	AF,INDFLG	;IF WAS @,
	TRO	V,10		;MAKE INDIRECT.
	RET

AEXP06:				; (
	CALL	AEXP20		;EVALUATE PARENTHESES
	SETZ	A,		;ZERO IN CASE OF INDEX
	CAIE	I,"+		;FINAL "+ SEEN?
	JRST	AEXP13		;  NO, GO SEE IF (R) OR @(R)?
	CALL	GETNB
	TRO	V,20
	JRST	AEXPXT

AEXP13:	TLCN	AF,INDFLG
	JRST	AEXP05		;NO-REGISTER MODE
	MOVE	A,OFFST		;YES, SAME AS @0(REG)
	HLROM	A,CEXT(A)	;STORE THE 0 .
	ADDI	V,70
	RET

AEXP07:				; -(
	MOVEM	IP,SYMBEG	;SAVE POINTER IN CASE OF FAILURE
	CALL	GETNB		;GET THE NEXT NON-BLANK
	CAIE	I,"(		;PARENTHESIS?
	JRST	AEXP09		;  NO, TREAT AS EXPRESSION
	CALL	AEXP20		;YES, EVALUATE
	TRO	V,40		;SET BITS
	JRST	AEXPXT
AEXP09:				; -( FAILURE
	RESCAN	SYMBEG		;GET POINTER TO "-
	SETCHAR			;RESTORE CHARACTER
AEXP10:				; NO UNARIES
	CALL	EXPR		;EVALUATE EXPRESSION
	 ERROR1	NULL IMMED. OPERAND
	CAIN	I,"(		;ANOTHER EXPRESSION?
	JRST	AEXP11		;  YES, BRANCH
	TLNE	AF,REGFLG	;REGISTER EXPRESSION?
	JRST	AEXP05		;  YES, TREAT AS %
	SKIPE	%ABSAD		;IF USER WANTS ABSOLUTE ADDRESSING,
	 JRST	[TLOE AF,INDFLG	;GIVE HIM @#FOO INSTEAD OF FOO.
		  JRST .+1	;BUT CAN'T DO THAT IF ALREADY INDIRECT.
		 JRST AEXP21]
	SUBI	V,@LOCTR	;DECREMENT BY CLC
	HRROI	A,-4(V)		;ASSUME FIRST ADDRESS FIELD
	SKIPE	B,OFFST		;TRUE?
	HRROI	A,-6(V)		;  NO, TREAT AS SECOND FIELD
	MOVEM	A,CEXT(B)	;SET VALUE
	MOVEI	V,67
	JRST	AEXPXT

AEXP11:				; E1(E2)
	TLNE	AF,REGFLG	;REGISTER EXPRESSION?
	 ERRUU1	REGMES
	MOVE	B,OFFST
	HRROM	V,CEXT(B)	;SAVE DISPLACEMENT.
	CALL	AEXP20		;GET REGISTER NUM.
	IORI	V,60		;SET INDEXED MODE.
	JRST	AEXPXT


AEXP20:				;()
	CALL	GETCHR		;BYPASS PAREN
	CALL	REGEXP		;EVALUATE REGISTER EXPRESSION
	CAIE	I,")		;PROPER DELIMITER
	 ERROR1	SETNB,MISSING )
	JRST	GETNB		;BYPASS THE ")".

;READ IN A REGISTER NUMBER.
REGEXP:	MOVEI	A,7		;NORMALLY 7 IS LARGEST LEGAL REG. #.
REGEX1:	HRLM	A,(P)		;CALL HERE IF SOME OTHER LARGEST LEGAL.
	CALL	EXPR		;EVALUATE EXPRESSION
	 ERRUUO	REGMES		;ERROR IF NULL.
	HLRZ	A,(P)
	CAIG	V,(A)		;ARE WE WITHIN BOUNDS?
	RET
	ERRUUO	REGMES		;NO, ERROR.
	SETZ	V,		;SET VALUE TO ZERO
	RET

REGMES:	ASCIZ/BAD REGISTER NUMBER/
EXPR:				;EXPRESSION PROCESSOR, REGISTER ALLOWED
	TLOA	AF,ROKFLG	;ALLOW REGISTER TYPE SYMBOLS

EXPRF:				;EXPRESSION FIN, NO REGISTERS ALLOWED
	TLZ	AF,ROKFLG	;PRECLUDE REGISTER
	CALL	EXPRRC		;REALLY READ EXPR.
	 CAIA
	AOS	(P)		;WE SKIP IF EXPRRC DID.
	CAIE	I,">
	 RET
	ERROR1	UNMATCHED >
	JRST	GETNB

EXPRRC:	TLZ	AF,REGFLG	;RESET ACTUAL FLAG
	CALL	EXPRT		;GET THE FIRST TERM
	 RET			;  NULL, EXIT
EXPRF1:	LDB	B,C4PNTR	;MAP CHARACTER USING COLUMN 4
EXPRF2:	XCT	EXPRJT(B)	;EXECUTE TABLE
	CALL	GETCHR
	PUSH	P,A		;STACK INSTRUCTION
	PUSH	P,V		;STACK CURRENT VALUE
	CALL	EXPRT		;GET THE NEXT EXPRESSION TERM
	 ERROR1 NO TERM AFTER OPERATOR
	POP	P,N		;GET PREVIOUS VALUE
	POP	P,A		;  AND OPERATOR
	TRNE	N,100000	;EXTEND SIGN IF NEGATIVE
	TDO	N,[-1,,700000]
	TRNE	V,100000
	TDO	V,[-1,,700000]
	XCT	A		;EXECUTE INSTRUCTION
	LDB	V,[POINT 16,0,35,]	;RETURN TRIMMED RESULT IN V
	JRST	EXPRF1		;RECYCLE


EXPRJT:				;EXPRESSION JUMP TABLE
	PHASE	0
	ERROR1	CPOPJ1,BAD CHAR IN EXP.
EXND:	JRST	CPOPJ1
EXTM:	ERROR1	CPOPJ1,CONSECUTIVE TERMS
EXPL:	MOVSI	A,(ADDI N,0(V))	; +
EXML:	MOVSI	A,(IMULI N,(V))
EXMI:	MOVSI	A,(SUBI N,0(V))	; -
EXDV:	MOVE	A,[IDIV N,V]
EXOR:	MOVSI	A,(IORI N,0(V))	; !
EXAN:	MOVSI	A,(ANDI N,0(V))	; &
EXLA:	MOVSI	A,(LSH N,(V))
	DEPHASE
EXPRT:	TDZA	V,V
TERM0:	CALL	GETCHR
	LDB	B,CPNTRM
	JRST	@TERMT1(B)

TERMT1:	PHASE	0
	CPOPJ		;CHARS. THAT FORCE NULL TERMS.
TERMSP:	TERM0		;SPACES, + => SKIP CHAR.
TERMDG:	TERM1		;DIGIT => READ NUMBER.
TERMSY:	TERMS		;ALPHABETIC => READ SYMBOL.
TERMOB:	TERME		;< => READ EXPR.
TERMMI:	TERMM		;- => READ & NEGATE TERM.
TERMQ1:	TERMQ		;' => READ 1 ASCII CHAR.
TERMQ2:	TERMDQ		;" => READ 2 ASCII CHARS.
	DEPHASE

TERME:	CALL	GETCHR		;SKIP THE "<"
	PUSH	P,AF		;SAVE REGFLG, ROKFLG.
	TLO	AF,ROKFLG	;REG'NESS OK (WILL FORGET IT ANYWAY).
	CALL	EXPRRC
	 SETZ	V,		;IF EXPR NULL.
	TLZ	AF,REGFLG+ROKFLG	;RESTORE THESE FLAGS.
	POP	P,A
	AND	A,[REGFLG+ROKFLG,,]
	IOR	AF,A
	CAIE	I,">
	 ERROR1	UNMATCHED <
	CAIN	I,">
	 CALL	GETCHR		;SKIP THE >.
	JRST	NUMXIT

TERM1:	SETZ	T1,
TERM2:	IMULI	V,10		;ACCUMULATE OCTAL.
	ADDI	V,-"0(I)
	IMULI	T1,10.		;ACCUMULATE DECIMAL.
	ADDI	T1,-"0(I)
	CALL	GETCHR		;GET NEXT CHARACTER
	CAIL	I,"0		;IS IT IN RANGE?
	CAILE	I,"9
	JRST	NUMXA		;NO, TEST FOR END OF NUM.
	JRST	TERM2		;DO IT AGAIN.

NUMXA:	CAIE	I,".		;IS CHAR A ".?
	JRST	NUMXIT		;NO, OCTAL.
	CALL	GETCHR		;YES, GET PAST CHAR.
	MOVE	V,T1		;GET DECIMAL NUMBER.
NUMXIT:	TDZE	V,[-200000]	;MASK TO 16 BITS, ANY OVERFLOW?
	ERROR1	NUMERIC OVERFLOW
	AOS	0(P)		;SET FOR SKIP-EXIT
	JRST	SETNB		;RETURN NON-BLANK
ROKTST:				;REGISTER "OK" TEST
	TLNN	AF,ROKFLG	;REGISTER ALLOWED?
	ERROR	REGISTER IN BAD CONTEXT
	TLO	AF,REGFLG	;SET FLAG
	RET

TERMPE:	MOVEI	V,@LOCTR	;TERM IS "." -- GET CURRENT LOCATION COUNTER
	ANDI	V,177777
	CALL	GETCHR		;MOVE PAST CHARACTER
	JRST	NUMXIT		;EXIT NUMERIC


TERMDQ:	CALL	GETCHR		;STARTS WITH " -- GET THE NEXT CHARACTER
	MOVE	V,I		;MOVE TO EXPRESSION AC
	CALL	GETCHR		;GET THE NEXT CHAR
	LSH	I,8		;MOVE OVER ONE
	CAIA			;SKIP AND FALL THROUGH
TERMQ:				;"'
	CALL	GETCHR		;GET THE NEXT CHARACTER
	TRO	V,(I)		;MERGE/PLACE CHARACTER IN 10
	CALL	GETCHR
	JRST	NUMXIT		;EXIT NUMERIC

TERMM:	CALL	GETCHR		;PASS BY THE "-".
	CALL	EXPRT
	 JFCL
	MOVN	V,V		;READ, NEGATE TERM.
	ANDI	V,177777
	JRST	CPOPJ1

TERMS:	CALL	GETSYM
	 JRST	TERMPE		;IF NOT SYMBOL, MUST BE ".".
	AOS	(P)
	CALL	SRCH
	 JRST	EXPRT2		;NO STE, SAY IS UNDEF MAYBE?
	XCT	CRFINS
	TLNE	A,UNDSYM	;IF UNDEF, MAYBE IS ERROR.
	 JRST	EXPRT3
	LDB	B,TYPPNT	;YES, GET TYPE
	LDB	V,[POINT 16,A,35,]	;OK, GET VALUE
	XCT	EXPRTT(B)	;DISPATCH ON TABLE
	RET
	JRST	ROKTST		;IF XCT SKIPS, IS REG SYM.

EXPRT2:	MOVSI	A,UNDSYM	;NOT IN SYMBOL TABLE, FLAG AS UNDEFINED
	CALL	INSRT
	XCT	CRFINS
EXPRT3:	SKIPE	VALREQ
	ERROR1		UNDEFINED
	TRO	AF,ERRU
	RET

EXPRTT:	PHASE 0
	TLNN	A,REGSYM	;NORMAL SYMBOL.
	CALL	(A)		;VALUE-RETURNING PSEUDO.
REPEAT 2,ERROR1	PSEUDO-OP IN BAD CONTEXT.
REPEAT MAOP-CNOP-1,JFCL		;MACHINE INSNS.
	ERROR1	MACRO NAME IN BAD CONTEXT.
INOP::	HRRZ	V,(A)		;PSEUDO-SYMBOL.
	DEPHASE
;SYMBOL/CHARACTER HANDLERS

GETSYM:				;GET A SYMBOL
	MOVSI	C,440600	;SET POINTER
	TDZA	N,N		;CLEAR AC AND SKIP
GETSY1:	CALL	GETCHR		;GET NEXT CHARACTER
	MOVEM	IP,SYMBEG	;SAVE START IN CASE OF FAIL
	LDB	B,ANPNTR	;MAP CHARACTER TYPE
	XCT	GETSY3(B)	;EXECUTE TABLE
GETSY2:	SUBI	I,40		;VALID, CONVERT TO SIXBIT
GETSY6:	CAME	C,[0600,,]	;ARE WE FULL?
	IDPB	I,C		;  NO, STORE CHARACTER
GETSY5:	CALL	GETCHR		;GET THE NEXT INPUT CHARACTER
	LDB	B,ANPNTR	;MAPE CHARACTER TYPE
	XCT	GETSY4(B)	;EXECUTE TABLE
	CAME	N,[SIXBIT /./];FINISHED, WAS IT A DOT?
	JRST	CPOPJ1		;  NO, VALID.  EXIT +1
	RESCAN	SYMBEG		;  YES, RESET CHARACTER POINTER
	SETCHAR			;  AND CHARACTER
	SETZ	N,		;CLEAR AC
CPOPJ:	RET


GETSY3:				;FIRST CHARACTER TABLE
	PHASE	0
	RET			;NOTHING CHARACTER, EXIT NULL
.TAB::	JRST	GETSY1		;SPACE OR TAB, BYPASS
.ALP::	JFCL			;ALPHA, FALL THROUGH
.NUM::	RET			;NUMERIC, EXIT NULL
.DOT::	JFCL			;DOT, FALL THROUGH, TEST LATER
.TRM::	RET			;TERMINATOR, EXIT NULL
.LOW::	SUBI	I,40		;LOWER CASE, TO UPPER.
	DEPHASE


GETSY4:				;SUCCEEDING CHARACTERS
	PHASE	0
	JFCL
	CALL	GETNB		;SPACE OR TAB, BYPASS AND FALL THROUGH
	JRST	GETSY2		;ALPHA, RECYCLE
	JRST	GETSY2		;NUMERIC, DITTO
	JRST	GETSY2		;DOT, DITTO
	JFCL			;TERMINATOR, FALL THROUGH
.LOW::	JRST	GETSY6
	DEPHASE

POPJ1:
CPOPJ1:	AOS	(P)
	RET

SETNB:	SETCHAR			;SET CHARACTER IN I
	CAIA
GETNB:	CALL	GETCHR
	CAIE	I,SPACE		;IF SPACE
	CAIN	I,TAB		;  OR TAB;
	JRST	GETNB		;  BYPASS
	RET			;OTHERWISE EXIT
;PSEUDO-OPS

AEND:				;"END" PSEUDO-OP
	TLO	AF,ENDFLG	;FLAG "END SEEN"
	CALL	EXPRF		;EVALUATE THE ADDRESS
	MOVEI	V,1		;  NULL, FORCE ODD VECTOR
	MOVEM	V,STRTLC	;SAVE START ADDR.
	MOVEI	W,(V)		;SET VALUE FOR ENDL.
	HRLI	W,CL5		;FLAG AS .END
	JRST	ENDL		;LIST AND EXIT

AIFF:: AIFT:: AIFTF::
OPCERR:	ERROR1		AT TOP LEVEL
	JRST	ENDL		;FLAG ERROR, LIST, AND EXIT

AEVEN:	MOVEI	W,1(L)		;.EVEN - MOVE UP TO NEXT EVEN ADDR.
	TRZ	W,1
	JRST	LOCSL

AODD:	MOVEI	W,(L)		;GET CURRENT LOC. CTR,
	TRO	W,1		;MOVE UP TO ODD ADDR,
LOCSL:	ANDI	W,177777
	HRLI	W,CL2		;LISTING-CLASS IS LOC CTR SETTING,
	JRST	ENDL

;COPY REST OF LINE TO TTY AND TITBUF (ASCIZ).
ATITLE:	MOVE	A,[440700,,TITBUF]
	CALL	SETNB
ATITL1:	CAIN	I,^M
	SETZ	I,
	IDPB	I,A
	JUMPE	I,ATITL2
	MOVE	B,I
	CALL	TTYDMP
	CALL	GETCHR
	JRST	ATITL1
ATITL2:	CALL	TTYCR
	JRST	ENDL

;.STITL - COPY REST OF LINE TO STITBF (ASCIZ).
ASBTTL:				;DEC'S NAME FOR SUBTITLE
ASTITL:	MOVE	A,[440700,,STITBF]
	CALL	SETNB	;GET FIRST NON-BLANK(WELL...)
ASTIT1:	CAIN	I,^M
	SETZ	I,
	IDPB	I,A
	JUMPE	I,ENDL
	CALL	GETCHR
	JRST	ASTIT1

;.LIST - DECREMENT LISTING SUPPRESS COUNT UNLESS IT'S 0.
ALIST:	SOSL	TSLWRD
	TLOA	AF,LINFLG
	SETZM	TSLWRD
	JRST	ENDL

;INCREM. LISTING SUPPR COUNT.
ANLIST:
AXLIST:	AOS	TSLWRD
	JRST	ENDL

RAD50:	CALL	SETNB	;GET FIRST NON-BLANK
	PUSH P,I	;SAVE DELIMITER
	MOVSI W,CL3	;FLAG WORD TO BE OUTPUT
RAD501:	CALL	GRAD50	;GET ONE RAD50 CHARACTER
	MOVSI W,CL3	;NOW COMMITED TO OUTPUT SOMETHING
	IMULI B,3100	;PUT IT IN IT'S PLACE
	ADD W,B
	CALL	GRAD50
	IMULI B,50	;THIS ONE TOO
	ADD W,B
	CALL	GRAD50
	ADD W,B
	CALL	ENDLF	;OUTPUT A WORD
	JRST RAD501	;AND TRY FOR MORE

GRAD50:	CALL	GETCHR
	CAMN I,-1(P)	;IS IT THE DELIMITER?
	JRST RAD50T	;YES
	LDB	B,SQPNTR	;GET SQUOZE FOR CHAR.
	JUMPN	B,CPOPJ		;A SQUOZE CHAR, OK.
	CAIN	I,40		;SPACE ALSO OK (FOR 0)
	 RET

RAD50E:	ERROR	.RAD50: BAD CHAR.
	JRST	.+2
RAD50T:	CALL	GETCHR
	SKIPE	W		;DO WE HAVE SOMETHING TO OUTPUT?
	CALL	ENDLF		;YES, DO SO
	SUB	P,[2,,2]	;UNSCREW THE STACK.
	JRST	ENDL

;.ASCII /STRING/
AASCIZ:	TLOA	AF,ASZFLG	;FLAG TO PUT ON NULL
AASCII:	TLZ	AF,ASZFLG	;NO TERMINATING NULL
	CALL	SETNB		;GET FIRST NON-BLANK
	PUSH	P,I		;STACK TERMINATOR
AASCI1:	CALL	GETCHR		;GET NEXT CHARACTER
	CAMN	I,0(P)		;TERMINATOR?
	JRST	AASCI4		;  YES
	MOVEI	W,0(I)		;PLACE IN AC4
	HRLI	W,CL4		;SET CLASS
	CALL	ENDLF		;PRINT AND DUMP IT
	JRST	AASCI1		;RECYCLE

AASCI4:	MOVSI	W,CL4		;ZERO DATUM (RH)
	TLNE	AF,ASZFLG
	CALL	ENDLF		;OUTPUT IT IF ASCIZ
	SETZ	W,
	CALL	GETCHR		;NORMAL TERMINATION, BYPASS TERMINATOR
	POP	P,N		;FLUSH TERMINATOR FROM STACK
	JRST	ENDL		;EXIT

;.BYTE BYTE1,BYTE2,BYTE3
ABYTE:	CALL	EXPRF		;EVALUATE EXPRESSION
	SETZ	V,		;NULL, ASSUME 0
	TDCN	V,[177400]	;OVERFLOW?
	JRST	.+3		;  NO.
				;HIGH BITS ARE NOW COMPLEMENTED.
	TDZE	V,[-400]	;MASK TO 8 BITS.
				;ANY OVERFLOW
	ERROR	BYTE TOO LARGE
	LDB	W,[POINT 8,V,35,]	;SET CODE
	HRLI	W,CL4		;SET CLASS
	CAIE	I,",		;ANY MORE
	JRST	ENDL		;  NO, EXIT
	CALL	ENDLF		;YES, DUMP THIS ITEM
	CALL	GETCHR		;BYPASS COMMA
	JRST	ABYTE		;GET ANOTHER ITEM

AWORD:	CALL	EXPRF		;.WORD -- EVALUATE EXPRESSION
WORDD:	SETZ	V,		;  NULL, ASSUME 0
WORDF:	MOVE	W,V		;GET VALUE
	HRLI	W,CL3		;SET CLASS
	CAIE	I,",		;END OF STRING?
	JRST	ENDL		;  YES, LIST AND EXIT
	CALL	ENDLF		;NO, LIST THIS WORD
	CALL	GETCHR		;BYPASS COMMA
	JRST	AWORD		;RE-CYCLE

ABLKW:	CALL	EXPRF		;.BLKW, READ # WDS SPACE TO LEAVE.
	 MOVEI	V,1		;ASSUME 1 IF NO ARG.
	LSH	V,1		;# BYTES SPACE.
	MOVEI	W,(L)
	ADDI	W,1		;BUT 1ST MOVE UP TO EVEN ADDR.
	TRZ	W,1
	JRST	ABLKB1

ABLKB:	CALL	EXPRF		;.BLKB, READ # BYTES SPACE.
	 MOVEI	V,1
	MOVEI	W,(L)
ABLKB1:	ADDI	W,(V)		;W _ NEW LOC. CTR.
	JRST	LOCSL
; .OFFSET -- SET OFFSET.
AOFFSE:	CALL	EXPRF		;READ IN VALUE,
	SETZ	V,		;OR 0 IF NONE,
	HRRM	V,LOCTR		;STORE AS OFFSET,
	MOVEI	W,(V)		;SET UP VALUE OF LINE.
	HRLI	W,CL1
	JRST	ENDL

AREM:				;DEC'S NAME FOR SAME THING
AMSG:	SOS	ERRCNT		;DON'T COUNT AN ERROR.
AERROR:	CAIA
	CALL	GETCHR		;FETCH TILL EOL.
	CAIE	I,^M
	JRST	.-2
	SETZ	I,
	DPB	I,IP		;MAKE LINBUF ASCIZ.
	ERRUU1	LINBUF		;ISSUE ERROR MSG.
	TLO	AF,LINFLG
	JRST	ENDL

;PRINT OUT MESSAGE BETWEEN DELIMITERS
APRINT:	CALL	SETNB
	PUSH	P,I
APRIN1:	CALL	GETCHR
	CAMN	I,(P)
	JRST	APRIN2
	MOVE	B,I
	CALL	TTYDMP
	TLNE	F,ERRBIT	;IF ERR FILE OPEN, OUTPUT TO IT.
	CALL	ERROU2
	JRST	APRIN1
APRIN2:	POP	P,I
	JRST	ENDL

;.EOT - FORCE EOF (SKIP REST OF FILE)
AEOT:	CALL	ENDLR		;FINISH LINE FROM CURRENT FILE.
	MOVE	A,SRCPNT	;PUT ^C IN BUFFER.
	MOVEI	B,^C
	IDPB	B,A
	RET

;.EJECT - NEW PAGE IN LISTING.
APAGE:
AEJECT:	TRO	F,HDRBIT	;FORCE NEW PAGE.
	TLO	AF,LINFLG	;DON'T LIST THIS LINE.
	JRST	ENDL

;.XCREF - SET DON'T-CREF BITS OF SPECIFIED SYMBOLS.
AXCREF:	CALL	GETSYM
	 ERROR1	ENDL,WHAT SYMBOL? - .XCREF
	CALL	SRCH		;FIND STE.
	 JFCL
	TLO	A,NCRSYM
	CALL	INSRT
	CAIE	I,",		;IF FOLLOWED BY COMMA, GET ANOTHER SYMBOL.
	JRST	ENDL
	CALL	GETCHR		;PASS COMMA
	JRST	AXCREF
;HANDLE REPEATS

REPEA0:				;"REPEAT" PSEUDO-OP
	AOS	VALREQ		;INSIST SYMS DEFINED.
	CALL	EXPRF		;EVALUATE EXPRESSION
	 ERROR1	.REPT: NULL ARG
	SOS	VALREQ
	MOVEI	W,(V)
	HRLI	W,CL1		;LIST VALUE
	TRNN	V,100000
	CAIN	V,0		;IF LESS THAN OR EQUAL TO ZERO,
	JRST	UNSCON		;  JUST LIST
	PUSH	P,V		;STACK EXPRESSION
	CALL	ENDLR		;LIST LINE
	CALL	GETBLK		;INIT. WRITING OF BODY AS STRING.
	PUSH	P,MWPNTR	;SAVE STARTING BLOCK ADDRESS
	SETZ	S,		;ZERO LEVEL COUNT
REPEA1:	CALL	GETLIN
	CALL	GETSYM		;TEST THE FIRST SYMBOL
	 JRST	REPEA2		;  NON-SYMBOLIC
	CAMN	N,.REPTX
	AOJA	S,REPEA2	;  INCREMENT AND BRANCH
	CAMN	N,.ENDRX
	SOJL	S,REPEA3	;  DECREMENT AND BRANCH IF END
REPEA2:	RESCAN	LINPNT		;POINT TO START OF LINE
REPEA4:	CALL	GETCHR		;GET THE NEXT CHARACTER
	CALL	WCIMT		;WRITE INTO STRING
	CAIE	I,^J		;KEEP GOING TILL EOL.
	JRST	REPEA4
	CALL	ENDLR		;LIST THE LINE
	TLNN	AF,ENDFLG	;SKIP IF EOF SEEN
	JRST	REPEA1		;TRY THE NEXT LINE
	ERROR1	.ENDR MISSING

REPEA3:	CALL	ENDLR		;TERMINATION, LIST LINE
	MOVEI	I,QUEMAC	;END, SET TO CLOSE
	CALL	WTIMT		;WRITE FLAG AND "REPEAT END"
	REST	A,V		;STRING'S ADDR, # TIMES TO REPEAT.
	IDPB	MP,MACPDP	;PUSH ON MACRO PDL, OUTER MACRO-READ-POINTER,
	MOVEI	B,REPEND	;WHEN FINISH READING BODY EACH TIME,
	EXCH	B,MACXIT	;REPEND IS PLACE TO CALL.
	IDPB	B,MACPDP	;SAVE OUTER STRING'S EXIT ROUTINE ADDR.
	MOVE	B,%RPCNT	;(SAVE OUTER .REPT'S .RPCNT OVER THIS ONE)
	IDPB	B,MACPDP
	IDPB	A,MACPDP	;BP -> START OF REPEAT-BODY-BLOCK.
	IDPB	V,MACPDP	;# REPETITIONS YET TO BE DONE.
	SETOM	%RPCNT		;PASS # 0 COMING UP.
	MOVEI	T1,GCHM		;NOW READING FROM MACRO-STRING.
	HRRM	T1,GETCHA

;FALLS THROUGH.
;COME HERE TO START NEXT PASS THRU .REPT OR POP OUT OF IT.
;MAY BE CALLED FROM GCHM SO DON'T CLOBBER ACS.
REPEND:	CAIA			;CALL HERE AFTER PASS THRU REPEAT.
	 SETZM	@MACPDP		;CALL HERE FROM .MEXIT, PRETEND 0 PASSES TO GO.
	HRRO	I,MACPDP
	SOSL	(I)		;1 LESS PASS STILL UNDONE,
	 JRST	REPEN1		 ;STIIL AT LEAST 1.
	SAVE	A
	SUBI	I,1		;NONE LEFT, DISCARD THE -1 ON MACPDL TOP.
	POP	I,A
	CALL	REMMAC		;FREE THE BLOCKS CONTAINING .REPT'S BODY.
	POP	I,%RPCNT	;UNBIND .RPCNT.
	POP	I,MACXIT	;UNBIND END-OF-STRING EXIT RTN.
	POP	I,MP		;UNBIND INPUT STREAM.
	HRRM	I,MACPDP	;MAKE PDL PTR -> BELOW WHAT WE POPPED.
	REST	A
	JUMPE	MP,GCHSE0	;MAYBE POPPED INTO A FILE,
	RET			;MAYBE INTO MACRO OR REPT, ETC.

REPEN1:	AOS	%RPCNT		;STARTING NEXT PASS,
	MOVE	MP,-1(I)	;RESTART READING FROM BEGINNING,
	RET

;COME HERE FOR .REPT WITH COUNT OF 0.
UNSCON:	CALL	ENDLR		;LIST THE LINE
UNSCO1:	CALL	GETLIN
	CALL	GETSYM		;CHECK THE FIRST SYMBOL
	 JRST	UNSCO2		;  NON-SYMBOLIC, LIST
	CAMN	N,.ENDRX	;"ENDR"?
	JRST	ENDLR		;  YES, LIST AND EXIT
	CAME	N,.REPTX	;NESTED?
	JRST	UNSCO2		;  NO
	CALL	UNSCO2		;YES, RECURSE
	JRST	UNSCO1		;BACK TO NORMAL

UNSCO2:	SETZ	I,
	TLNE	AF,ENDFLG	;EOF SEEN?
	JRST	ENDL		;  YES, EXIT
	CALL	ENDLR		;NO, LIST THE LINE
	JRST	UNSCO1		;TRY AGAIN
;.IF PSEUDO-OP:
;  .IF <COND-NAME> <ARGS (OPTIONAL, DEPENDS ON CONDITION)>
;    <BODY>
;   .ENDC
AIF:	CALL	CNT		;PROCESS CONDITION, SKIP IF TRUE.
	 JRST	UNCOND		;FAILED, SKIP BODY.
	JRST	STCOND		;PROCESS THE BODY.

;.IIF <CONDIT> <ARGS>, <STMT>
AIIF:	CALL	CNT		;PROCESS CONDITION AND ARGS AND COMMA.
	 JRST	ENDLR		;FALSE, JUST LIST LINE.
	JRST	STMNT		;HANDLE REST OF LINE.

;.LIF <CONDITION>
; <SINGLE-LINE-OF-BODY>
ALIF:	CALL	CNT		;READ IN AND TEST CONDITION,
	 CALL	ENDLR		;SKIP NEXT LINE IF CONDITION FAILS.
	JRST	ENDLR

;HANDLE OLD-STYLE CONDITIONALS BY TRANSLATING TO NEW STYLE.
CONDIT:	MOVE	N,CONDTB(A)	;GET NEW CONDITION NAME
	CALL	CNT0		;TEST IN USUAL WAY.
	JRST	UNCOND		;NOT SATISFIED
STCOND:	PUSH	P,[SIXBIT/.IFF/]
	PUSH	P,[SIXBIT/.IFT/]
STCON0:	CALL	ENDLR		;SATISFIED CONDITIONAL
STCON1:	CALL	GETLIN
	CALL	GETSYM		;LOOK AT 1ST SYMBOL ON LINE.
	 JRST	STCON2		;NO SYMBOL FOUND.
	CAMN	N,.ENDCX	;IF .ENDC SEEN
	JRST	CONDX1		;THEN END OF CONDITIONAL
STCON2:	TLNE	AF,ENDFLG	;EOF => EXIT CONDITIONAL. DON'T CALL
	 JRST	POP2J		;ENDLR SINCE OUR CALLER WILL. (WOULD GET 2 "NO END" MSGS)
	CAME	N,(P)		;IF NEXT PART WANTS CONDIT THE WAY IT WAS
	CAMN	N,[SIXBIT/.IFTF/]
	 JRST	STCON0		;OR DOESN'T CARE, GO ON ASSEMBLING.
	CAMN	N,-1(P)		;IF NEXT PART WANTED COND. THE OTHER WAY,
	 JRST	UNCON0		;START SKIPPING OVER IT.
	RESCAN	SYMBEG		;BACK UP
	SETCHAR			;IN ORDER TO
	CALL	STMNT		;EXECUTE LINE
	JRST	STCON1

;COME HERE FOR FALSE CONDITIONAL.
UNCOND:	PUSH	P,[SIXBIT/.IFT/]
	PUSH	P,[SIXBIT/.IFF/]
UNCON0:	PUSH	P,[0]		;THIS WD IS LEVEL CNTR.
UNCON4:	CALL	ENDLR		;UNSATISFIED CONDITIONAL
UNCON1:	CALL	GETLIN
	CALL	GETSYM		;GET SOMETHING
	 JRST	UNCON2		;NO SYMBOL
	CAMN	N,.ENDCX
	JRST	[SOSL (P)	;DOWN ONE CONDITIONAL LEVEL.
		 JRST UNCON2	;STILL NOT AT BOTTOM.
		 JRST CONDXT]	;TERMINATED THIS CONDITIONAL.
	CAMN	N,[SIXBIT/.IF/]
	 JRST	UNCON5		;ENTERING AN INNER CONDITIONAL.
	SKIPE	(P)		;IF NOT WITHIN INNER CONDITIONALS,
	 JRST	UNCON3
	CAME	N,[SIXBIT/.IFTF/]
	CAMN	N,-1(P)		;IF WANT COND. THE WAY IT WAS,
	 JRST	[POP P,A ? JRST STCON0]	;START ASEMBLING STUFF.
UNCON3:	CALL	SRCH
	 JRST	UNCON2
	HLRZ	N,A
	CAIN	N,CNOP		;IS IT A CONDITIONAL?
UNCON5:	AOS	(P)		;YES, INCREM. DEPTH IN CONDITIONALS.
UNCON2:	MOVEI	I,0
	TLNN	AF,ENDFLG
	JRST	UNCON4		;UNLESS HIT END, LIST LINE & DO NEXT.
POP3J:	SUB	P,[1,,1]
POP2J:	SUB	P,[2,,2]
	RET

CONDXT:	SUB	P,[1,,1]	;POP THE LEVEL COUNT.
CONDX1:	SUB	P,[2,,2]	;POP .IFT AND .IFF .
	JRST	ENDLR

CONDTB:	PHASE	0
$IF1:: SIXBIT/P1/  ?  $IF2:: SIXBIT/P2/
IRPS X,,DF NDF B NB G GE L LE NZ Z
$IF!X::	SIXBIT/X/
TERMIN	DEPHASE ;PARALLEL TABLES: CNTTB0 HAS CONDITION NAMES (SIXBIT) IN NUMERICAL ORDER,
;CNTTB1 HAS CORRESPONDING ACTIONS.

CNTTB0:
IRP X,,[B=B,DF=DF,DIF=DIF,E N,EQ N,G LE,GE L,GT LE
IDN#DIF,L GE,LE G,LT GE,NB#B,NDF#DF,NE E,NG G,NL L
NZ E,P1=P1,P2#P1,Z N]
IRPS Y,Z,X
IFE .IRPCN,[SIXBIT/Y/	;COND. NAME IN FIRST TABLE.
IF2 [	CNTTM1==V		;DEFAULT IS >0, FOR ARITH COND.
	IFSE Z,=,CNTTM1==SETZ	;= => TRUE, CALL RTN.
	IFSE Z,#,CNTTM1==TRN	;# => REVERSED, CALL RTN.
]]
IFN .IRPCN,[IF2 [	.=.+CNTTB1-CNTTB0-1	;MOVE TO 2ND TABLE.
	CNTTM1+IFL CNTTM1,[CNT!Y]+IFGE CNTTM1,SKIP!Y
	.=.+CNTTB0-CNTTB1	;MOVE BACK TO 1ST TABLE.]]
TERMIN TERMIN

IF1 [CNTTBL==0
REPEAT 10.,IFE CNTTBL,IFGE 1_.RPCNT-.+CNTTB0,  CNTTBL==.RPCNT
]	;(NOW CNTTBL HAS LOG BASE 2 OF TABLE SIZE, ROUNDED UP.)

CNTTB1==CNTTB0+1_CNTTBL		;MAKE TABLE SIZE NEXT POWER OF 2.
REPEAT CNTTB1-., 377777,,-1	;FILL OUT 1ST TABLE WITH LARGEST POSITIVE NUM.
CNTTB1:	BLOCK	CNTTB1-CNTTB0	;MAKE 2ND TABLE SAME SIZE AS FIRST.

;COME HERE TO READ IN THE CONDITION OF A NEW CONDITIONAL,
;SKIP-RETURN IFF CONDITION IS TRUE.
;LEAVE INPUT STREAM BEFORE BODY OF CONDITIONAL.
CNT:	CALL	GETSYM		;READ IN CONDITION-TYPE.
	 ERROR1	CPOPJ,CONDITION MISSING
CNT0:	SETZ	A,		;A IS PTR INTO TABLES FOR BINARY-SEARCHING.
REPEAT CNTTBL,[		;CNTTB0(A) WILL HOLD AONDITION NAME; CNTTB1(A), ACTION.
	CAML	N,CNTTB0+1_<CNTTBL-.RPCNT-1>(A)
	ADDI	A,1_<CNTTBL-.RPCNT-1>
]
	CAME	N,CNTTB0(A)	;IS THE COND-NAME ACTUALLY IN TABLE?
	 ERROR1	CPOPJ,BAD CONDITION NAME
	SKIPGE	V,CNTTB1(A)	;IF ACTION POSITIVE, IT IS SKIP-INSTRUCTION,
	 JRST	CNTSPC		;ELSE IT IS ADDR OF RTN, GO CALL IT.
	SAVE	V
	CALL	EXPRF		;ACTION IS INSN => ARITHMETIC COND, READ NUMBER.
	 ERROR1	NO ARG IN CONDITIONAL
	LDB	W,[2000,,V]	;PREPARE TO LIST VALUE OF ARG ALONG WITH CONDITIONAL.
	HRLI	W,CL1
	LSH	V,24		;MOVE VALUE'S SIGN INTO BIT 4.9 FOR TEST.
	REST	A		;RESTORE THE TEST INSN (A SKIP!X)
	XCT	A
	AOS	(P)
	JRST CNTCMA

;COME HERE FOR SPECIAL CONDITIONALS.
CNTSPC:	TLNN	V,200000	;BIT 4.8 OFF => TRUE CONDITION.
	 JRST	[CALL (V) ? RET ? JRST POPJ1]
	CALL	(V)		;BIT 4.8 => REVERSE THE TEST.
	AOS	(P)
	RET
;RTN FOR .IF DIF & .IF IDN, READS 2 MACRO-ARGS, SKIPS IF DIFFERENT
CNTDIF:	CALL	ARGINI		;INIT. THE FIRST ARG.
	 ERROR1	POPAJ,NO ARG IN CONDITIONAL
		 ;(RETURN NON-SKIPPING FROM CNT)
	CALL	GETBLK		;PREPARE TO COPY 1ST ARG INTO MACRO-STORAGE.
	SAVE	MWPNTR,MWPNTR
		 ;WILL ILDB -1(P) TO RE-READ ARG, USE (P) TO FREE IT AFTER.
CNTDI1:	CALL	ARGC		;GET NEXT CHAR TO WRITE IN STRING.
	 JRST	CNTDI0		;NO MORE CHARS.
	CALL	WCIMT
	JRST	CNTDI1

CNTDI0:	MOVEI	I,^C
	CALL	WCIMT		;TERMINATE STRING WITH ^C.
	CALL	ARGINI		;START READING 2ND ARG.
	 JRST	CNTDI3		;NO ARG SAME AS NULL ARG.
CNTDI2:	CALL	ARGC
	JRST	CNTDI3		;AT END OF 2ND, SEE IF END OF 1ST.
	ILDB	A,-1(P)		;GET CHAR OF 1ST,
	CAIN	A,(I)
	 JRST	CNTDI2		;THE SAME SO FAR.
CNTDI4:	CALL	ARGC		;THEY'RE DIFFERENT, SKIP REST OF 2ND ARG.
	 JRST	CNTDI5
	JRST	CNTDI4

CNTDI3:	ILDB	A,-1(P)
	CAIE	A,^C		;SKIP-RETURN IF 1ST ARG LONGER THAN 2ND, NOT EQUAL.
CNTDI5:	AOS	-2(P)
	REST	A		;GET THE OTHER SAVED COPY OF MWPNTR,
	CALL	REMMAC		;FREE 1ST ARG'S STRING STG.
	JRST	POPAJ

;RTN FOR .IF B & .IF NB, READ 1 ARG & SKIP IF BLANK.
CNTB:	CALL	ARGINI
	 JRST	POPJ1		;NO ARG COUNTS AS BLANK.
	CALL	ARGC
	 JRST	POPJ1		;ARG NULL => BLANK.
CNTB0:	CALL	ARGC		;CAN'T BE BLANK, SKIP THE ARG
	RET			;RETURN FAILURE.
	JRST	CNTB0

;RTN FOR .IF 1 & .IF 2, SKIP IF PASS 1.
CNTP1:	TLNE	AF,P1F
	AOS	(P)
	JRST CNTCMA

;RTN FOR .IF DF & .IF NDF, SKIP IF ALL SYMS IN ARG ARE DEF.
CNTDF:	SAVE	VALREQ
	SETZM	VALREQ		;DON'T WANT ERROR MSG ON UNDEF SYM!
	CALL	EXPRF		;READ THE ARG,
	 JFCL
	REST	VALREQ
	TRZN	AF,ERRU		;SKIP UNLESS SAW UNDEF SYM.
	 AOS	(P)
CNTCMA:	CAIE I,",
	RET
	JRST @GETCHA
;.IRP DUMMY,<ARG1,ARG2,ARG3>
AIRP:	MOVEI	S,IRPORD	;INDICATE ORDINARY .IRP .
	JRST	AIRP0

;.IRPC DUMMY,STRING
AIRPC:	MOVEI	S,IRPCHR

AIRP0:	CALL	GETBLK	;GET START OF .IRP ARGS BLOCK.
	CALL	GETSYM		;READ DUMMY SYMBOL NAME.
	 ERROR1	[[SETO N, ? JRST .+1]]INVALID IRP
	CALL	PSOB3		;PASS COMMA, ERROR IF NONE.
	SAVE	MWPNTR
	MOVEM	N,ARGLST	;PRETEND THAT DUMMY IS 1ST MACRO ARG.
	SETZM	ARGLST+1	;AND ONLY 1 ARG. (WILL READ IN BODY AS MACRO-DEF.)
	AOS	MWPNTR		;1ST WD -> BEFORE START OF ARGLIST OR STRING.
	AOS	MWPNTR		;ARG BLOCK+1 - BP. -> AFTER LAST ARGN.
	JRST	@.(S)
PHASE 1
IRPORD::AIRP1
IRPCHR::[SETZ	I,		;MAKE A 1-CHAR-LONG MACRO ACTUAL,
	CALL	WCIMT		;EACH PASS THRU .IRPC WILL PUT THE NEXT
	CALL	WTARGT		;CHAR OF THE STRING INTO THIS ACTUAL.
	MOVE	I,[250000,,1]
	ADDM	I,MWPNTR	;BYPASS REST OF THIS WORD (3RD WD IN BLOCK).
	JRST	AIRP1]
DEPHASE
AIRP1:	MOVE	I,MWPNTR	;PUT BP TO START OF ARGS
	MOVEM	I,@(P)		;INTO BLOCK'S 1ST WORD.
	CAIN	S,IRPORD	;.IRP, PUT TERMINATOR BEFORE 1ST ARG.
	CALL	WTARGT
	CALL	ARGINI		;INIT. READING OF STRING OR ARGLIST.
	 JRST	AIRP4		 ;THERE IS NO ARGLIST.
AIRP2:	CALL	ARGC		;GET NEXT ARG CHARS_ACTER,
	 JRST	AIRP3		 ;NO MORE CHARS.
	CALL	WCIMT		;WRITE IT IN .IRP ARGS BLPCK.
	CAIN	I,",		;IN .IRP, REPLACE A COMMA
	CAIE	S,IRPORD
	 JRST	AIRP2
	MOVEI	I,^C		;WITH A TERMINATOR QUEARG.
	DPB	I,MWPNTR
	MOVEI	I,QUEARG
	CALL	WCIMT
	JRST	AIRP2
AIRP3:	CAIN	S,IRPORD	;.IRP, FOLLOW ARGS BY TERMINATOR.
	CALL	WTARGT
AIRP4:	MOVE	A,MWPNTR
	MOVE	B,(P)
	MOVEM	A,1(B)		;STORE PTR TO END IN 2ND WD OF BLOCK.
	CALL	ENDLR		;LIST THE LINE THE .IRP IS ON.
	SAVE	S
	CALL	[CALL	GETBLK	;START IRP-BODY BLOCK.
		 SAVE	MWPNTR, [1]	;SAVE THEM SINCE DEF00 DOES.
		 SETZ	S,	;.MACR - .ENDM LEVEL COUNT.
		 MOVEI	A,3	;3 WDS SPECIAL AT START OF BLOCK.
		 ADDM	A,MWPNTR
		 JRST	DEF03]	;GO READ IN BODY OF IRP.
	SAVE	A
	CALL	ENDLR
	REST	A,S,B
	MOVEM	B,2(A)		;-> IRP BODY BLOCK RET. IN A.
	MOVE	C,MACBPT	;ALL IS READ IN, NOW PUSH MACRO PDL.
	IDPB	C,MACPDP	;SAVE OLD MACBPT.
	MOVE	C,%IRPCN	;SAVE OUTER .IRPCN .
	IDPB	C,MACPDP
	MOVE	C,AIRPXT-1(S)	;GET ADDR OF APPROPRIATE END-OF-STRING RTN.
	EXCH	C,MACXIT	;CALL IT WHEN FINISH EACH PASS.
	IDPB	C,MACPDP	;SAVE OUTER STRING'S EOS RTN.
	IDPB	MP,MACPDP	;SAVE OUTER MACRO PTR.
	IDPB	A,MACPDP	;SAVE PTR -> "MACRO DEF"
	IDPB	A,MACPDP	;MAKE SPACE FOR THIS INVOCATION'S SAVED READ PTR.
	MOVE	C,MACPDP	;(WHICH WILL BE STORED BY AIRPND)
	MOVEM	C,MACBPT	;MACBPT POINTS TO THAT WORD.
	ADDI	B,2
	HRLI	B,440700	;COME UP WITH THE "MACRO ARG" B.P.
	IDPB	B,MACPDP
	MOVEI	B,1
	IDPB	B,MACPDP	;STORE "# MACRO ARGS"
	MOVE	MP,(C)
	SETOM	%IRPCN
	CALL	GCHSET
	JRST	@MACXIT		;PRETEND -1'TH PASS THRU IRP JUST ENDED.

AIRPXT:	PHASE	1
IRPORD::AIRPON		;END-OF-PASS RTN FOR .IRP,
IRPCHR::AIRPCN		; FOR .IRPC .
	DEPHASE
;COME HERE AFTER END OF PASS THRU .IRP .
AIRPON:	CAIA			;CALL HERE AFTER PASS,
	 JRST	AIRPX		;CALL HERE FROM .MEXIT
	CALL	AIRPND		;SET READ PTR TO START OF IRP BODY.
	SAVE	A,B
	MOVE	A,MACBPT
AIRPO1:	ILDB	B,1(A)	;MOVE THRU LAST PASS'S IRP ACTUAL
	PUSHJ	P,AIRPO9	;MOVE TO NEXT BLOCK IF NEC.
	CAIE	B,^C		;UNTIL GET TO TERMINATOR.
	 JRST	AIRPO1
	ILDB	B,1(A)		;MOVE OVER TERMINATOR, NOW -> NEXT IRP ACTUAL.
	PUSHJ	P,AIRPO9
	MOVE	B,1(A)
	CAME	B,1(I)		;BUT MAYBE WE POINT TO LAST TERMINATOR?
	 JRST	POPBAJ		 ;NO, THERE'S ANOTHER IRP ACTUAL, DO NEXT PASS.
	REST	B		;YES, POP THE IRP STUFF OF MACPDL.
AIRPC1:	MOVE	A,I
	CALL	REMMAC		;FREE UP THE IRP ARGS BLOCK.
	MOVE	I,MACBPT
	MOVE	A,-1(I)
	CALL	REMMAC		;FREE THE IRP BODY BLOCK.
	MOVE	MP,-2(I)	;RESTORE THE SAVED MACRO READ PTR AND MACXIT AND MACBPT.
	MOVE	A,-3(I)
	MOVEM	A,MACXIT
	MOVE	A,-4(I)
	MOVEM	A,%IRPCN
	MOVE	A,-5(I)
	MOVEM	A,MACBPT
	MOVNI	A,8
	ADDM	A,MACPDP	;FLUSH THE WDS FROM THE STACK.
	CALL	GCHSET
	JRST	POPAJ

AIRPO9:	JUMPN	B,CPOPJ	;DO NOTHING UNLESS AT END OF MACRO-BLOCK.
	MOVE	B,@1(A)		;ELSE GET ADDR OF NEXT BLOCK,
	HRRM	B,1(A)		;MAKE BP. -> IT.
	LDB	B,1(A)		;GET NEXT CHAR FROM THAT BLOCK.
	RET

AIRPX:	CALL	AIRPND		;.MEXIT IN IRP; SET UP POINTERS,
	SAVE	A
	JRST	AIRPC1		;GO POP OFF MACPDL.

;COME HERE AFTER END OF PASS THRU .IRPC .
AIRPCN:	CAIA			;CALL HERE AT END OF PASS.
	 JRST	AIRPX		;CALL HERE FROM .MEXIT .
	CALL	AIRPND		;SET READ PTR TO START OF IRP BODY.
	SAVE	A
	MOVE	A,(I)		;GET BP INTO STRING TO IRPC ON.
	CAMN	A,1(I)		;IF -> LAST CHAR, THERE ARE NO MORE,
	 JRST	AIRPC1		 ;GO POP OUT OF THE IRP.
	ILDB	A,(I)		;ELSE GET THE NEXT CHAR.
	DPB	A,[350700,,2(I)]	;PUT IT IN THE PHONY MACRO ACTUAL.
	JRST	POPAJ

;COMMON RTN FOR END OF PASS THRU ANY IRP.
;SET THE MACRO READ PTR (IN MP AND `MACBPT) -> START OF IRP BODY.
;LEAVE I -> IRP ARGS BLOCK.
AIRPND:	AOS	%IRPCN
	MOVE	I,MACBPT
	MOVE	MP,-1(I)	;-> IRP BODY BLOCK.
	HRLI	MP,440700
	ADDI	MP,3		;BP -> START OF TEXT OF IRP BODY.
	MOVEM	MP,@MACBPT
	MOVE	I,-1(MP)	;-> IRP ARGS BLOCK.
	RET

;MACRO ARG READING COROUTINES.
;CALL HERE TO INIT. READING OF MACRO ARG (FROM ASSEMBLY INPUT PATH)
ARGINI:	SETCHAR
	LDB	B,C1PNTR
	CAIN	B,MACR		;1ST CHAR IS CR OR ;, NO ARG.
	 RET
	AOS	(P)		;ELSE THERE IS AN ARG.
	CAIN	I,"\		;\ - ARG IS EVALUATED & CONVERTED TO BASE 8.
	 JRST	ARGBS
	CAIN	I,"<		;< - ARG IS BRACKETED WITH < & >.
	 JRST	ARGLT
	CAIE	I,"^		;ARG IS ORDINARY UNLESS STARTS WITH ^ .
	 JRST	ARG1
	CALL	@GETCHA		;ARG USES DELIMITERS, READ THE DELIMITER.
	MOVEM	I,ARGTRM	;SAVE IT.
	JSR	ARGRET		;RETURN, ARGC CALLS AT .+1 .

	CALL	@GETCHA
	CAME	I,ARGTRM	;WAS THIS CHAR THE DELIMITER?
	 JRST	POPJ1		;NO, IT'S PART OF THE ARG.
ARGEN1:	CALL	@GETCHA
ARGEND:	LDB	B,C1PNTR	;MOVE PAST THE ARGUMENT.
	XCT	.+1(B)
PHASE	0
	ERROR1	ARGEN1,BAD MACRO-TYPE ARG
MASP::	JRST	ARGEN1		;PASS SPACES.   ^- PASS MOST CHARS BUT ERROR.
MACM::	JRST	@GETCHA		;COMMA, STOP ON NEXT CHAR.
MACR::	RET			;CR OR ;, STOP ON IT SO NEXT ARGINI WILL SEE IT.
DEPHASE

ARGBS:	CALL	@GETCHA		;ARG IS \<EXPR> -- READ 1ST CHAR OF EXPR.
	SAVE	S
	CALL	EXPRF
	 ERROR1 NO EXPR. AFTER BACKSLASH.
	REST	S
	MOVEM	V,ARGTRM	;SAVE VALUE OF ARG IN RH,
	MOVE	V,[220300,,ARGTRM]
ARGBS0:	HLLM	V,ARGTRM	;PUT LH OF BP INTO RH, IN LH.
	ILDB	A,V
	JUMPN	A,ARGBS1	;THEN MOVE BP PAST LEADING ZEROS.
	TLNE	V,77^4		;BUT DON'T MOVE PAST LAST DIGIT.
	 JRST	ARGBS0		;CAN PASS IT, UPDATE LH(ARGTRM)
ARGBS1:	JSR	ARGRET
;COME HERE FROM ARGC
	HLLZ	I,ARGTRM	;LH OF ARGTRM SAYS WHICH FIELD IN WORD,
	HRRI	I,ARGTRM	;THE WORD IS ARGTRM (THE RH, WHICH HAS VALUE OF ARG)
	TLNN	I,77^4		;USED ALL 6 OCTAL DIGITS?
	 JRST	[SETCHAR ? JRST ARGEND]	;YES, PASS END OF ARG.
	IBP	ARGTRM
	ILDB	I,I		;GET THE NEXT OCTAL DIGIT.
	ADDI	I,"0
	JRST	POPJ1

ARGLT:	SETZM	ARGTRM		;ARG IS BRACKETED, ARGTRM COUNTS ANGLE-BRACKET LEVEL.
	JSR	ARGRET
	CALL	@GETCHA
	CAIN	I,"<
	 AOS	ARGTRM		;< - GO UP ONE LEVEL.
	CAIN	I,">
	 SOSL	ARGTRM		;> - DOWN 1 LEVEL, MAYBE END ARG.
	JRST	POPJ1		;ORDINARY CHAR IS IN ARG.
	JRST	ARGEN1		;FOUND THE MATCHING >.

;HANDLE AN ORDINARY ARG.
ARG1:	JSR	ARGRET		;THE 1ST CHAR OF ARG WAS READ ALREADY.
	SETCHAR
ARG2:	LDB	B,C1PNTR
	XCT	ARG1TB(B)	;SPACES, COMMA, CR AND ; SPECIAL.
	MOVEM	IP,SYMBEG	;IT WAS A SPACE, CHECK FORWARD
	CALL	GETNB		;IF 1ST NONSPACE IS ;,
	CAIN	I,";
	 RET			;IGNORE THE SPACE, STOP ON THE ;.
	RESCAN	SYMBEG		;SPACES NOT BEFORE ;'S ARE ORDINARY CHARS.
	SETCHAR
ARG3:	AOS	(P)
	JSR	ARGRET		;EVERY CHAR. AFTER THE 1ST HAS TO BE READ.
	CALL	@GETCHA
	JRST	ARG2		;BUT TREAT THEM THE SAME WAY.

ARG1TB:	PHASE	0
	JRST	ARG3		;ORDINARY CHAR, RETURN IT.
MASP::	JFCL			;SPACE, FALL THRU INTO SPECIAL RTN.
MACM::	JRST	@GETCHA		;COMMA, PASS IT & END OF ARG.
MACR::	RET			;CR OR ;, END OF ARG BUT STOP ON IT.
DEPHASE

;CALL HERE TO READ NEXT CHARACTER OF MACRO-ARG.
;SKIPS => CHAR IS IN I .
;ELSE ARG HAS ENDED, CALL ARGINI TO START NEXT ARG.
ARGC:	JRST	@ARGRET
;.TTYMAC ENTRY TO MACRO HANDLER
ATTYMA:	TLO	AF,TTMFLG	;WE ARE NOW DOING A .TTYMAC
	MOVNI	N,2		;LOOK LIKE DEFINING STRANGE MACRO
	CALL	GETBLK
	CALL	DEF00		;READ IN THE DEFINITION.
	SAVE	A		;REMEMBER ITS ADDRESS.
	CALL	ENDLR		;LIST LINE WITH .ENDM .
	SAVE	TTIPNT,TTICNT
	CALL	TTILN		;READ ARGS FROM TTY.
	MOVEI	B,^M		;PUT CRLF AFTER LINE READ.
	IDPB	B,TTIPNT
	MOVEI	B,^J
	IDPB	B,TTIPNT
	MOVE	B,TTIPNT	;REMEMBER LAST FILLED SLOT IN LINBUF.
	MOVEM	B,LINIP
	REST	TTICNT,TTIPNT
	RESCAN	<[350700,,LINBUF]>
	TLZ	AF,TTMFLG
	REST	A		;ENDLR DESTROTED A.
	SETCHAR
	JRST	CALLM		;NOW EXPAND MACRO WITH ARGS FROM TTY.

;.MACR PSEUDOOP.
AMACRO:
AMACR:	CALL	DEFIN0		;READ IN THE DEFINITION,
	JRST	ENDLR		;LIST THE LAST LINE & EXIT.

DEFIN0:	CALL	GETBLK		;OK, GET A BLOCK FROM STORAGE
	CALL	GETSYM		;GET MACRO'S NAME
	 ERROR1	DEFERR,DEFINE WHAT NAME?
DEF00:	CALL	SRCH		;SEE IF ALREADY DEFINED
	 SETZ	A,		;  NOT IN TABLE
	TLNE	A,LBLSYM
	 ERROR1	DEFERR,	LABEL MADE MACRO?
	LDB	B,TYPPNT	;GET OP TYPE
	CAIE	B,MAOP		;MACRO?
	TLZA	A,-1-NCRSYM	;NO, PRETEND NOT FOUND.
	CALL	DECMAC		;  YES, DECREMENT REFERENCE
	HRRZ	A,MWPNTR	;GET POINTER TO START OF BLOCK
	HRLI	A,MAOP		;FLAG MACRO
	XCT	CRFIND		;INDIC. BEING DEFINED.
	CALL	INSRT		;INSERT IN SYMBOL TABLE
	PUSH	P,MWPNTR	;STACK POINTER TO START OF BLOCK
	MOVEI	A,2
	ADDM	A,MWPNTR	;MOVE PAST REFERENCE LEVEL AND ARG COUNT
	TDZA	S,S		;INIT ARG COUNT
DEF01:	CALL	GETCHR		;MOVE PAST COMMA
	CALL	GETSYM		;GET AN ARG
	 JRST	DEF02		;  NOT THERE
	MOVEM	N,ARGLST(S)	;STORE IN LIST
	ADDI	S,1		;BUMP POINTER
	CAIN	I,",		;ANY MORE?
	JRST	DEF01		;  YES

DEF02:	PUSH	P,S		;STACK ARG COUNT
	SETZM	ARGLST(S)	;MARK END
	CALL	ENDLR		;LIST THE LINE
	SETZ	S,		;INIT LEVEL COUNT
DEF03:	CALL	GETLIN
	CALL	GETSYM		;TEST THE FIRST SYMBOL
	 JRST	DEF04
	CAME	N,[SIXBIT/.IRP/]
	CAMN	N,[SIXBIT/.IRPC/]
	 AOJA	S,DEF04
	CAME	N,.TTYMX
	CAMN	N,.MACRX	;MACRO DEF - INCREM LEVEL COUNT.
	AOJA	S,DEF04
	CAMN	N,.MACRY
	AOJA	S,DEF04
	CAMN	N,.ENDMX	;END OF DEF - DECREM COUNT.
	SOJL	S,DEF13		;END IF MINUS

DEF04:	RESCAN	LINPNT		;SET TO START OF LINE
DEF05:	CALL	GETCHR		;GET THE NEXT CHARACTER
DEF06:	CAIE	I,"'		;CONCATENATION CHARACTER?
	JRST	DEF06C		;  NO, BRANCH AROUND
DEF06A:	CALL	GETCHR		;YES, GET THE NEXT CHARACTER
	CAIE	I,"'		;MULTIPLE?
	JRST	DEF06B		;  NO
	CALL	WCIMT		;YES, SAVE ONLY ONE
	JRST	DEF06A		;TEST FOR MORE

DEF06B:	TLO	AF,CONFLG	;FLAG THE CONCATENATION CHARACTER
DEF06C:	LDB	B,ANPNTR	;MAP
	XCT	DEFT1(B)	;EXECUTE TABLE
	CALL	WCIMT		;WRITE IN TREE
	JRST	DEF05		;TRY FOR ANOTHER

DEF15:	SUBI	I,40		;LOWER CASE LETTER STARTS A SYMBOL.
DEF07:	SETZ	N,		;POSSIBLE ARGUMENT
	MOVSI	C,440600
	MOVEM	IP,SYMBEG	;SAVE START JUST IN CASE
DEF08:	SUBI	I,40		;CONVERT TO SIXBIT
DEF14:	CAME	C,[POINT 6,N,35,]	;ROOM TO STORE?
	IDPB	I,C		;  YES, DO SO
	CALL	GETCHR		;GET THE NEXT CHARACTER
	LDB	B,ANPNTR	;MAP
	XCT	DEFT2(B)	;EXECUTE TABLE
	SETZ	B,		;INIT SEARCH INDEX
DEF09:	SKIPN	ARGLST(B)	;TEST FOR END
	JRST	DEF10		;  YES
	CAME	N,ARGLST(B)	;NO, HAVE WE A MATCH?
	AOJA	B,DEF09		;  NO,TRY THE NEXT SLOT
	TLZ	AF,CONFLG	;REMOVE POSSIBLE CONCATENATION CHARACTER
	MOVEI	I,101(B)	;SET DUMMY SYMBOL POINTER
	CALL	WTIMT		;WRITE IN TREE
	SETCHAR			;SED CHARACTER
	CAIN	I,"'		;CONCATENATION CHARACTER?
	JRST	DEF05		;  YES, BYPASS IT
	JRST	DEF06		;  NO, PROCESS IT
DEF10:	RESCAN	SYMBEG		;MISSED, RESET POINTER
	SETCHAR			;RESET CHARACTER
DEF11:	LDB	B,ANPNTR	;MAP
	XCT	DEFT3(B)	;EXECUTE TABLE
	CALL	WCIMT		;OK, WRITE IN TREE
	CALL	GETCHR		;GET NEXT CHAR
	JRST	DEF11		;TEST IT

DEF12:	CALL	WCIMT		;WRITE IT OUT
	CAIE	I,^J		;IF FINISHED LINE,
	JRST	DEF05
	CALL	ENDLR		;LIST IT
	TLNN	AF,ENDFLG	;SKIP IF EOF SEEN
	JRST	DEF03		;GET THE NEXT LINE

DEF13:	MOVEI	I,QUEMAC	;FINISHED, SET "END OF MACRO DEFINITION"
	CALL	WTIMT		;WRITE IT, WITH QUE, IN TREE
	POP	P,B		;RETRIEVE COUNT
	POP	P,A		;  AND POINTER TO START OF BLOCK
	SETZM	0(A)		;ZERO LEVEL COUNT
	HRRZM	B,1(A)		;STORE ARG COUNT IN SECOND RUNG
	SETCHAR			;RESTORE LAST CHARACTER
	RET

DEFERR:	MOVNI	N,1		;SKIP DEFN. BY DEFINING ______.
	JRST	DEF00

DEFT1:	PHASE	0
	JRST	DEF12
.TAB::	JFCL
.ALP::	JRST	DEF07
.NUM::	JRST	DEF07
.DOT::	JRST	DEF07
.TRM::	JRST	DEF12
.LOW::	JRST	DEF15
	DEPHASE


DEFT2:
	PHASE	0
	JFCL
.TAB::	JFCL
.ALP::	JRST	DEF08
.NUM::	JRST	DEF08
.DOT::	JRST	DEF08
.TRM::	JFCL
.LOW::	JRST	DEF14
	DEPHASE

DEFT3:	PHASE	0
	JRST	DEF06
.TAB::	JRST	DEF06
.ALP::	JFCL
.NUM::	JFCL
.DOT::	JFCL
.TRM::	JRST	DEF06
.LOW::	JFCL
	DEPHASE
;MACRO PDL FRAME FORMAT:
;WD 1	PREVIOUS MACBPT, OR 0 IN LOWEST FRAME.
;WD 2	PREVIOUS %NARG.
;WD 3	PREVIOUS MACXIT.
;WD 4	PREVIOUS READ POINTER (MP)
;WD 5	PTR TO 1ST BLOCK OF MACRO.
;WD 6	READ PTR IN MACRO SAVED AROUND DUMMY SYMBOL. MACBPT PTS HERE.
;WD 7	B.P. TO START OF 1ST ARG, ETC. FOR ALL ARGS.
;LAST	NUMBER OF ARGS. MACPDP POINTS HERE.
CALLM:	AOS	(A)		;INCR. REF. COUNT IN MACRO.
	MOVN	S,1(A)		;MAX. NUM. ARGS.
	HRLZS	S		;GET "AOBJN PTR" TO ARGUMENT.
	SAVE	A		;REMEMBER MACRO BODY ADDR.
	JUMPE	S,MAC50		;TEST FOR NO ARGS
	CALL	SETNB		;RESTORE LAST CHARACTER
	CALL	GETBLK		;BLOCK TO STORE ARGS IN.

MAC20:	CALL	ARGINI		;START READING MACRO-TYPE ARG FROM INPUT STREAM.
	 JRST	MAC50		;NO MORE ARGS, FINISH UP.
	SAVE	MWPNTR
MAC21:	CALL	ARGC		;GET NEXT CHAR OF ARG,
	 JRST	MAC40		 ;(NO MORE CHARS IN ARG)
	CALL	WCIMT		;WRITE CHAR IN MACRO-CALL-BLOCK.
	JRST	MAC21

MAC40:	CALL	WTARGT		;TERMINATE ARG.
	AOBJN	S,MAC20		;BRANCH IF MORE ARGS WANTED.

MAC50:	CALL	ENDLR		;FINISH READING LINE FROM OLD SOURCE.
	MOVE B,MACBPT	;NOW PUSH THE NEW FRAME ON MACRO PDL:
	IDPB	B,MACPDP	;OLD MACBPT.
	MOVE	B,%NARG
	IDPB	B,MACPDP	;OLD %NARG
	MOVEI	B,MACEND
	EXCH	B,MACXIT
	IDPB	B,MACPDP	;OLD MACXIT
	IDPB	MP,MACPDP	;OLD MACRO READ PTR.
	AOS	MACPDP		;WILL FILL IN PTR TO MACRO BODY LATER.
	AOS	A,MACPDP	;NEEDN'T STORE WD 6 ( IT HAS MEANING
	MOVEM	A,MACBPT	;ONLY WHILE READING DUMMIES)
	MOVEI	B,(P)
	SUBI	B,-1(S)		;ADDR OF 1ST ARG B.P. ON THE STACK.
	AOS	MACPDP		;PLACE FOR 1ST ARG B.P. TO GO.
	MOVSS	B
	HRR	B,MACPDP	;BLT PTR
	ANDI	S,-1		;# OF ARGS ACTUALLY READ = # WDS PUSHED.
	ADDM	S,MACPDP	;ADDR OF LAST WD OF FRAME
	BLT	B,@MACPDP	;(BLT'S 1 WD MORE THAN NECESSARY)
	HRRZM	S,@MACPDP	;SAVE # ARGS IN LAST WD.
	HRLI	S,(S)		;# ARGS,,# ARGS
	SUB	P,S		;POP ARG B.P.'S OFF STACK.
	REST	MP		;ADDR OF MACRO BODY.
	MOVEM	MP,-1(A)	;SAVE IN WD 5 OF FRAME. (A STILL HAS MACBPT)
	HRLI	MP,440700	;GET B.P. TO ILDB TEXT OF MACRO.
	ADDI	MP,2
	AOS	MACLVL
	JRST	GCHSET
;COME HERE AFTER READING ENTIRE MACRO. CALLED FROM GCHM SO DON'T CLOBBER ACS.
MACEND:	JFCL			;.MEXIT WILL CALL HERE+1
	MOVE	I,@MACPDP	;GET NUM. ARGS.
	SOS	A,MACBPT	;-> WD 3, -> MACRO.
	MOVEM	A,MACPDP
	MOVE	A,2(A)		;GET PTR -> 1ST ARG (IF ANY ARGS)
	CAIE	I,0		;IF WERE ARGS, FLUSH CALL-BLOCK.
	CALL	REMMAC		;FLUSH BLOCK HOLDING THEM.
	MOVE	A,MACPDP
	SUBI	A,5
	MOVEM	A,MACPDP	;FLUSH REMAINING WDS.
IRPS X,,MACBPT %NARG MACXIT
	MOVE	B,1+.IRPCN(A)
	MOVEM	B,X
TERMIN
	MOVE	MP,4(A)
	MOVE	A,5(A)
	CALL	DECMAC		;SOS MACRO REF-COUNT, MAYBE FREE.
	SOS	MACLVL		;DECREMENT MACRO LEVEL COUNT
	JUMPE	MP,GCHSE0	;IF POPPED TO FILE, RESET GETCHA .
	RET

;.MEXIT - POP OUT OF INNERMOST REPEAT, IRP OR MACRO.
AMEXIT:	JUMPE	MP,[ERROR1 ENDLR,.MEXIT IN FILE
]
	CALL	ENDLR		;LIST THE LINE WITH THE .MEXIT ON IT.
	MOVE	A,MACXIT	;GET ADDR OF RTN TO END 1 PASS THRU INNERMOST STRING,
	JRST	1(A)		;CALL 1 INSN AFTER TO END ALL PASSES THRU IT.

;.NCHR SYM,ARG  SAME AS  SYM==.LENGT ARG
ANCHR:	JSP	A,ANCHR1
;.LENGT - TAKES ARG LIKE MACRO, RETURNS # CHARS IN IT.
ALENGT:	SETZ	V,
	CALL	ARGINI		;INIT. READING OF ARG.
	 RET			;NO ARG, RETURN 0.
ALENG1:	CALL	ARGC		;READ NEXT CHAR.
	 RET			;NO MORE, RETURN # COUNTED.
	AOJA	V,ALENG1

;.NTYPE SYM,ARG  SAME AS  SYM==.ADRMD ARG
ANTYPE:	JSP	A,ANCHR1
;.ADRMD ARG,  RETURNS ADDRESSING MODE OF ARG
;(EG RETURNS 64 FOR INDEX OF R4)
AADRMD:	SAVE	CEXT,OFFST	;DON'T CLOBBER INSN ARG BEING READ.
	CALL	AEXP
	REST	OFFST,CEXT
	JRST	CNTCMA		;RETURN WHAT AEXP RETURNED.

ANARG:	JSP	A,ANCHR1	;.NARG SYM  SAME AS  SYM==%NARG .
	MOVE	V,%NARG
	RET

ANCHR1:	SAVE	A		;REMEMBER ADDR OF RTN TO GET VALUE,
	CALL	GETSYM		;READ NAME OF SYM TO ASSIGN.
	 JFCL
	CALL	PSOB3		;PASS COMMA, ERROR IF NONE.
	EXCH	N,(P)		;PUT NAME ON STACK FOR ASGMT0.
	CALL	@N		;CALL RTN TO READ OTHER ARGS, RETURN VALUE IN V.
	TLO	AF,HKLFLG
	JRST	ASGMT0	;ASSIGN SYM, HALF-KILLED.
;MACRO STORAGE HANDLERS

WTARGT:	MOVEI	I,QUEARG		;TERMINATE ARG.

WTIMT:				;WRITE TWO CHARACTERS IN MACRO TREE
	PUSH	P,I		;STACK CURRENT CHARACTER
	MOVEI	I,^C		;SET FLAG CHARACTER
	CALL	WCIMT		;WRITE IT
	POP	P,I		;RESTORE CHARCTER AND FALL THROUGH

WCIMT:				;WRITE CHARACTER IN MACRO TREE
	TLZE	AF,CONFLG	;CONCATENATION CHARACTER PENDING?
	JRST	WCIMT2		;  YES, WRITE IT OUT
	IBP	MWPNTR		;POINT TO ACTUAL WORD
	SKIPN	@MWPNTR		;END OF BLOCK?
	JRST	WCIMT1		;  YES, GET ANOTHER
	DPB	I,MWPNTR	;NO, STORE BYTE
	RET

WCIMT1:	PUSH	P,MWPNTR	;NEAD A NEW BLOCK, SAVE CURRENT POINTER
	CALL	GETBLK		;GET IT
	HRRZ	T1,MWPNTR	;GET START OF NEW BLOCK
	EXCH	T1,0(P)		;EXCHANGE WITH POINTER TO LAST
	POP	P,0(T1)		;STORE VECTOR
	JRST	WCIMT		;TRY AGAIN

WCIMT2:	PUSH	P,I		;STACK CURRENT CHARACTER
	MOVEI	I,"'
	CALL	WCIMT		;WRITE CONCATENATION CHARACTER
	POP	P,I		;RESTORE CHARACTER
	JRST	WCIMT		;CONTINUE

GETBLK:				;GET A BLOCK FOR MACRO STORAGE
	SKIPE	T1,NEXT		;ANY REMNANTS OF GARBAGE COLLECTION?
	JRST	GETBL1		;  YES, RE-USE
	PUSH	P,S		;  NO, SAVE REGISTER
	MOVEI	S,WPB
	ADDB	S,MACTOP	;UPDATE FREE LOCATION POINTER
	CAML	S,JOBREL	;ANY ROOM?
	CALL	GETCOR		;  NO, GET MORE CORE
	MOVEI	T1,-<WPB-1>(S)	;POINT TO START OF BLOCK
	POP	P,S		;RESTORE
	SETZM	WPB-1(T1)	;CLEAR VECTOR
GETBL1:	HRLI	T1,440700	;FORM BYTE POINTER
	MOVEM	T1,MWPNTR	;SET NEW BYTE POINTER
	HRLI	T1,-<WPB-1>	;GET SET TO INITIALIZE BLOCK
	SETOM	0(T1)		;CLEAR ENDRY
	AOBJN	T1,.-1		;SET ALL EXCEPT LAST TO -1
	PUSH	P,0(T1)		;GET TOP
	POP	P,NEXT		;SET FOR NEXT BLOCK
	SETZM	0(T1)		;CLEAR LAST WORD
	RET
READMB:				;READ MACRO BYTE
	ILDB	I,MP		;GET CHARACTER
	JUMPN	I,CPOPJ		;EXIT IF NON-NULL
	MOVE	MP,0(MP)	;END OF BLOCK, GET LINK
	HRLI	MP,440700	;SET ASCII BYTE POINTER
	JRST	READMB		;TRY AGAIN

GETDS:				;GET DUMMY SYMBOL
	ANDI	I,37
	CAMLE	I,@MACPDP	;GOT THAT MANY ARGS?
	JRST	GCHM		;NO, ARG IS NULL.
	ADD	I,MACBPT	;ELSE INDEX INTO FRAME,
	MOVEM	MP,@MACBPT	;SAVE PTR IN MACRO ITSELF IN WD 4.
	MOVE	MP,(I)		;READ FROM DS.
	JRST	GCHM		;GET 1ST CHAR OF ARG.


DSEND:				;DUMMY SYMBOL END
	MOVE	MP,@MACBPT	;RESTORE READ PTR FROM WD 4.
	RET

DECMAC:				;DECREMENT MACRO STORAGE
	SOSL	0(A)		;TEST FOR END
	RET			;  NO, EXIT

REMMAC:				;REMOVE MACRO STORAGE
	PUSH	P,A		;SAVE POINTER
	HRLS	A		;SAVE CURRENT POINTER
	HRR	A,WPB-1(A)	;GET NEXT LINK
	TRNE	A,-1		;TEST FOR END (NULL)
	JRST	.-3		;  NO
	HLRZS	A		;YES, GET RETURN POINTER
	HRL	A,NEXT		;GET CURRENT START OF CHAIN
	HLRM	A,WPB-1(A)	;STORE AT TOP
	POP	P,A		;RESTORE BORROWED REGISTER
	HRRZM	A,NEXT		;SET NEW START
	RET
;LISTING ROYTINES

PRNTA:				;PRINT BASIC LINE OCTAL
	HLRZ	R6,W		;GET CLASS TYPE
	TLNE	AF,TTYFLG	;TELETYPE (DOUBLE LINE)?
	JRST	PRNTA1		;  YES, BRANCH
	CALL	LOTAB		;LIST A TAB
	HLRZ	C,PRNTAT(R6)	;TEST FOR LEFT HALF
	CALL	0(C)	;PROCESS
	CALL	LOTAB		;OUTPUT TAB
	HRRZ	C,PRNTAT(R6)	;GET RIGHT HALF
	CALL	0(C)	;PROCESS
	CALL	LOTAB
	HLRZ	C,PRNTBT(R6)	;GET NEXT ITEM
	SKIPE	C		;SKIP IF NULL
	CALL	0(C)
	CALL	LOTAB
	HRRZ	C,PRNTBT(R6)
	SKIPE	C		;SKIP IF NULL
	CALL	0(C)	;PROCESS
	RET

PRNTA1:				;TELETYPE LINE 1
	CALL	LOSP
	CALL	LOSP
	HLRZ	C,PRNTAT(R6)
	CALL	PRNTA2
	CALL	LOSP
	HRRZ	C,PRNTAT(R6)
PRNTA2:	CAIE	C,CPOPJ
	JRST	0(C)
	MOVEI	C,6
	CALL	LOSP		;OUTPUT 6 SPACES
	SOJG	C,.-1
	RET


PRNTAT:
	PHASE	0
	XWD	CPOPJ,	CPOPJ
	XWD	CPOPJ,	LOBAS	; ASSIGNMENT
	XWD	CPOPJ,	LOBAS	; .=
	XWD	LOLOC,	LOBAS	; XXXXXX
	XWD	LOLOC,	LOLOB	;    XXX
	XWD	CPOPJ,	LOHOW	; .END
	XWD	LOLOC,	LOBAS	; XXXXXX XXXXXX
	XWD	LOLOC,	LOBAS	; XXXXXX XXXXXX XXXXXX
	DEPHASE
PRNTB:				;PRINT EXTENSION LINE OCTAL
	HLRZ	R6,W		;GET CLASS
	TLNE	AF,TTYFLG	;IF NON-TELETYPE
	SKIPN	PRNTBT(R6)	;  OR NON-MULTIPLE WORD
	RET			;  EXIT
	MOVEI	C,5		;SET FOR 5 SPACES
	CALL	LOSP		;LIST THEM
	SOJG	C,.-1
	HLRZ	C,PRNTBT(R6)	;GET OP
	CALL	0(C)	;LIST FIRST WORD
	HRRZ	C,PRNTBT(R6)	;GET RIGHT HALF
	JUMPE	C,PRNTB1	;BRANCH IF NULL
	CALL	LOSP		;LIST ANOTHER SPACE
	CALL	0(C)	;PROCESS CODE
PRNTB1:	MOVEI	B,0
	JRST	0(A)		;LIST CR AND EXIT

PRNTBT:
	PHASE	0
	0
	0			; ASSIGNMENT
	0			; .=
	0			; XXXXXX
	0			;    XXX
	0			; .END
	XWD	LOHOW,	0	; XXXXXX XXXXXX
	XWD	LOHOW,	LOLOW	; XXXXXX XXXXXX XXXXXX
	DEPHASE
LOTAB:	MOVEI	B,TAB
	JRST	0(A)

LOSP:	MOVEI	B,SPACE
	JRST	0(A)

LOLOC:	LDB	V,[POINT 16,L,35,]
	JRST	PRNTWD			;PRINT LOCATION

LOBAS:	LDB	V,[POINT 8,W,35,]
	JRST	PRNTBY			;PRINT BASIC

LOHOW:	LDB	V,[POINT 8,CEXT1,35,]
	JRST	PRNTBY			;PRINT HIGH ORDER WORD

LOHOB:	LDB	V,[POINT  8,CEXT1,35,]
	JRST	PRNTBY			;PRINT HIGH ORDER BYTE

LOLOW:	LDB	V,[POINT 8,CEXT2,35,]
	JRST	PRNTBY			;PRINT LOW ORDER WORD

LOLOB:	LDB	V,[POINT  8,W,35,]
	JRST	PRNTBY			;PRINT LOW ORDER BYTE


PRNTBY:	SKIPA	C,[POINT 3,V,26,]
PRNTWD:	MOVE	C,[POINT 3,V,17,]
	ILDB	B,C
	ADDI	B,"0		;CONVERT TO ASCII
	CALL	0(A)		;LIST
	TLNE	C,770000
	JRST	PRNTWD+1
	RET
;OUTPUT END BLOCK, SYMBOLS.
DUMP2:	CALL	BLKDMP		;DUMP CURRENT BUFFER
	MOVE	C,[140300,,[1060]]	;OUTPUT END BLOCK:
DUMP4:	ILDB	B,C		;GET NEXT CONSTANT BYTE,
	ADDM	B,CHKSUM
	CALL	BINOUT		;OUTPUT IT,
	TLNE	C,770000	;DO ALL 4.
	JRST	DUMP4
	LDB	B,[001000,,STRTLC]
	ADDM	B,CHKSUM	;NEXT, 2 BYTES OF START ADDR.
	CALL	BINOUT
	LDB	B,[101000,,STRTLC]
	ADDM	B,CHKSUM
	CALL	BINOUT
	MOVN	B,CHKSUM	;GET CHECKSUM.
	CALL	BINOUT		; PUNCH IT.
	TLNE	F,SYMBIT
	RET
	MOVEI	B,2		;TO MAKE STALLMAN HAPPY
	CALL	SYMOUT		;OUTPUT A 2 BEFORE THE SYMBOLS
	MOVN	S,SYMLEN	;GET AOBJN PTR -> SYMTAB
	HRLZ	S,S
DUMP3:	SKIPN	B,@SYMPNT	;GET NAME.
	 RET			;0 => AT END.
	CALL	SYMOUT
	MOVE	B,@VALPNT
	ANDI	B,177777	;DON'T LET HIGH BITS CONFUSE 11SIM.
	CALL	SYMOUT		;WRITE VALUE, TOO.
	AOBJN	S,DUMP3
	RET

;OUTPUT OCTAL IF NEC, INCREM L .
DUMP:	HLRO	B,R6		;-NUM BYTES.
	TLNE	F,BINBIT
	TLNE	AF,P1F
	JRST	DUMP9		;IF NOT MAKING BIN, JUST INCR. L.
	MOVE	A,BYTCNT
	CAIGE	A,DATLEN(B)	;IF NOT ENOUGH ROOM
	CAME	L,CURADR	;OR PROFRAM BREAK,
	CALL	BLKDMP		;START NEW BLOCK.
	SUB	L,B		;INCREM L .
	MOVEM	L,CURADR
DUMP8:	LDB	B,DUMPT(R6)	;GET, OUTPUT BYTE.
	AOS	A,BYTCNT	;COUNT BYTES IN BLOCK.
	MOVEM	B,DATBLK-1(A)
	AOBJN	R6,DUMP8
	RET

DUMP9:	SUBI	L,(B)
	RET

DUMPT:	POINT	8,W,35	
	POINT	8,CEXT1,35	
	POINT	8,CEXT2,35
;OUTPUT THE BLOCK WHICH HAS GROWN IN DATBLK.
BLKDMP:	SKIPN	BYTCNT		;IF NO BLOCK, JUST RE-INIT.
	JRST	BLKINI
BLKD0:	SAVE	A,B
	MOVEI	A,1
	MOVEM	A,DATBBL	;SET UP 1ST WD.
	MOVEI	A,6
	ADDM	A,BYTCNT	;GET TOTAL BLOCK LENGTH.
	MOVSI	A,-4		;GET LENGTH, ADDR AS BYTES:
BLKD1:	LDB	B,BLKDMT(A)
	MOVEM	B,DATBBL+2(A)
	AOBJN	A,BLKD1
	MOVNS	BYTCNT
	HRLZ	A,BYTCNT	;-<LENGTH>,,0
	SETZ	B,		;GET -<SUM OF WDS>
BLKD2:	SUB	B,DATBBL(A)
	AOBJN	A,BLKD2
	DPB	B,[001000+A,,DATBBL]	;STORE AS CHECKSUM.
IFN TENEX,[
	SAVE	C
	SOS	C,BYTCNT
	MOVE	B,[444400,,DATBBL]
	MOVE	A,BINJFN
	SOUT
	REST	C
]
IFN ITS,[
	HRLZ	A,BYTCNT
	ADD	A,[-1,,DATBBL]
	TLNE	F,PSWBIT	;IF UNIT MODE, SPECIAL.
	JRST	BLKD3
	.IOT	BIN,A
	JRST	BLKD4

BLKD3:	.IOT	BIN,(A)		;OUTPUT 1 BY 1.
	AOBJN	A,BLKD3
]
BLKD4:	REST	B,A

BLKINI:				;CODE BLOCK INITIALIZATION
	MOVEM	L,LODADR	;SET STARTING ADDRESS
	MOVEM	L,CURADR	;SAVE CURRENT ADDRESS
	SETZM	BYTCNT		;CLEAR BYTE COUNT
	SETZM	CHKSUM		;  AND CHECK-SUM
	RET


BLKDMT:				;BLOCK DUMP TABLE
	POINT	8,BYTCNT,35
	POINT	8,BYTCNT,27
	POINT	8,LODADR,35
	POINT	8,LODADR,27

IFN ITS,[
TSINT:	0 ? 0
	SKIPL	TSINT		;ONLY ENABLED 1ST WD INT IS PDL OV.
	.VALUE	[ASCIZ/:PDL OV
/]
	SAVE	A		;2ND WD INT, CHECK FOR ^S.
	MOVEI	A,TTI
	.ITYIC	A,		;A _ INT. CHARACTER.
	 JRST	TSINT1		;NONE, DO NOTHING.
	CAIE	A,^S
	 JRST	TSINT1
	SETCMM	CTLSF		;COMPLEMENT TYPEOUT SWITCH.
	SKIPE	CTLSF		;IF JUST TURNED TYPEOUT OFF,, FLUSH ALL.
	 .RESET	TTO,
TSINT1:	REST	A
	.DISMI	TSINT+1
]

IFN TENEX,[
PSICO:	MOVEM A,PSIACA		;^O INTERRUPT. SAVE AC A
	MOVE A,TTOJFN
	CFOBF			;CLEAR OUTPUT BUFFER
	SETCMM CTLSF		;COMPLEMENTS FLAG
	MOVE A,PSIACA
	DEBRK
]
GETCOR:				;GET CORE
	PUSH	P,N		;GET A COULPLE OF WORKING REGISTERS
	PUSH	P,A
IFN ITS,[
	LDB	A,[121000,,JOBREL]
	SYSCAL	CORBLK,[1000,,400000 ? 1000,,-1
		   1000,,(A) ? 1000,,400001]
]
	MOVEI	A,CORINC	;UPDATE POINTERS
	ADDM	A,JOBREL
POPANJ:	POP	P,A		;RESTORE REGISTERS
POPNJ:	POP	P,N
	RET

UUOH:	0
	SAVE	UUOH
	SAVE	A,B,C
	LDB	B,[331100,,40]
	CAIG	B,UUOMAX
	JUMPN	B,@UUODIS-1(B)
ILLUUO:	BUG
UUOXIT:	REST	C,B,A,UUOH
	JRST	2,@UUOH

UUODIS:	UERROR
	UERR1

UUOMAX==2
CRFOUT:				;OUTPUT WORD TO CREF
	CALL	CRFOU0		;OUT TYPE CHAR, SYMBOL.
	MOVEI	B,CRFSYM	;INDIC. NON-DEFINITION OCCURRENCE.
	JRST	LSTDMP

;CREF FOR DEFINING OCCURRENCE.
CRFODF:	CALL	CRFOU0		;OUTPUT TYPE, SYMBOL.
	MOVEI	B,CRFOPC	;INDIC. DEFINING OCCURRENCE.
	JRST	LSTDMP

CRFOU0:	SKIPN	NOCREF		;IS %XCREF 0?
	TLNE	A,NCRSYM
	JRST	POPBJ
	LDB	B,[221100,,A]
	HRRZ	B,CRFTBL(B)	;GET PROPER FLAG
	CALL	LSTDMP		;LIST CREF TYPE
	MOVSI	C,440600
CRFOU1:	ILDB	B,C		;GET A SIXBIT CHARACTER
	JUMPE	B,CPOPJ		;BRANCH IF END
	ADDI	B,40		;CONVERT TO SIXBIT
	CALL	LSTDMP		;LIST IT
	TLNE	C,770000	;END OF WORD?
	JRST	CRFOU1		;  NO, GET ANOTHER
	RET

POPBJ:	REST	B
	RET

CRFTBL:	PHASE	0
	MOVEI	B,CRFSYM
NPOP::	CRFOPC
PSOP::	MOVEI	B,CRFOPC
CNOP::	MOVEI	B,CRFOPC
BGOP::	MOVEI	B,CRFOPC	;BASIC GROUP
OPOP::	MOVEI	B,CRFOPC	;OPERATE GROUP
SCOP::	MOVEI	B,CRFOPC
UNOP::	MOVEI	B,CRFOPC	;UNARY OP
BCOP::	MOVEI	B,CRFOPC	;BRANCH ON CONDITION OP
TROP::	MOVEI	B,CRFOPC	;TRAP OP
RTOP::	MOVEI	B,CRFOPC
FLOP::	CRFOPC
MLOP::	CRFOPC
FSOP::	CRFOPC
SPOP::	CRFOPC	;SPECIAL OPS (MARK, SOB)
MAOP::	MOVEI	B,CRFMAC
INOP::	MOVEI	B,CRFSYM	;PSEUDO-SYMS.
	DEPHASE
INSRT:				;INSERT ITEM IN SYMBOL TABLE
	CAMN	N,NODEFN	;BREAK ON DEFINING TEST SYMBOL.
	.VALUE
	MOVEM	N,@SYMPNT	;STORE SYMBOL
	MOVEM	A,@VALPNT	;STORE VALUE
	RET

;SEARCH SYMBOL TABLE.
SRCH:	MOVM	R6,N
	IDIV	R6,SYMLEN
	HRLI	S,(S)		;MAKE AOBJN PTR STARTING AT HCODE.
	ADD	S,SYMAOB
SRCH1:	SKIPN	R6,JOBFFI(S)	;0 => NOT FOND.
	 JRST	SRCH3
	CAMN	N,R6
	 JRST	SRCH2		;IF FOUND.
SRCHCT:	AOBJN	S,SRCH1		;SEARCH TILL TABLE'S END.
	AOBJN	S,SRCH1		;(IN CASE WANT TO CLOBBER PREV. INSN).
	MOVE	S,SYMAOB	;NOW SEARCH FROM FRONT.
SRCH4:	SKIPN	R6,JOBFFI(S)
	 JRST	SRCH3
	CAMN	R6,N
	 JRST	SRCH2
	AOBJN	S,SRCH4
	JRST	ERRTMS		;SYM. TAB. FULL.

SRCH2:	MOVE	A,@VALPNT	;IF FOUND.
	AOS	(P)
	RET

SRCH3:	MOVSI	A,UNDSYM	;NOT FOUND, SAY UNDEF.
	RET
;COMPRESS SYMBOL TABLE, ELIMINATING UNUSED ENTRIES,
;PREDEFINED SYMS AND MACROS, THEN RESET SYMLEN.
COMPRS:	MOVN	S,SYMLEN
	HRLZI	S,(S)		;AOBJN PTR -> SYM. TAB.
	MOVEI	L,JOBFFI	;RE-INSERT THRU L & V.
	HRRZ	V,VALPNT
COMPR0:	SKIPN	A,@SYMPNT	;IF NAME IS 0, SKIP IT.
	JRST	COMPR1
	MOVE	B,@VALPNT
	TLNE	B,SUPSYM+777	;IF MACRO, OP OR PREDEF, SKIP SYMBOL.
	JRST	COMPR1
	MOVEM	A,(L)		;ELSE PUT BACK LOWER IN SYM. TAB.
	MOVEM	B,(V)
	AOJ	L,		;INCREM. RE-INSERTION PTR.
	AOJ	V,
COMPR1:	AOBJN	S,COMPR0
	SUBI	L,JOBFFI	;NUM. SYMS RE-INSERTED.
	MOVEM	L,SYMLEN
	MOVNM	L,SYMAOB
	HRLZS	SYMAOB
	RET

;SORT SYMTAB INTO ALPHABETICAL ORDER.
SORT:	SKIPN	B,SYMLEN
	RET
SORT1:	AOS	B		;SORT OVER SMALLER INTERVALS.
	LSH	B,-1
SORT0:	MOVN	S,SYMLEN
	ADD	S,B
	MOVSI	S,(S)
	MOVEI	L,JOBFFI(B)
	HRRZ	V,VALPNT
	SUBI	V,JOBFFI
	HRLI	V,L
SORT3:	MOVE	A,JOBFFI(S)
	CAMG	A,(L)		;IF EARLIER IS LARGER,
	AOJA	L,SORT2
	EXCH	A,(L)		;SWITCH THE STE'S.
	MOVEM	A,JOBFFI(S)
	MOVE	A,@V
	EXCH	A,@VALPNT
	MOVEM	A,@V
	TLO	L,400000	;SAY DID SOMETHING THIS PASS.
	AOJ	L,
SORT2:	AOBJN	S,SORT3
	TLZE	L,400000	;IF DID SOMETHING, TRY AGAIN.
	JRST	SORT0
	CAIE	B,1
	JRST	SORT1		;ELSE TRY SHORTER SPACING.
	RET
SYMTB:	CALL	SORT			;LIST THE SYMBOL TABLE
	MOVE	S,[[ASCIZ /***SYMBOL TABLE***      /],,STITBF]
	BLT	S,STITBF+5
	MOVE	S,[STITBF+6,,STITBF+7]
	SETZM	STITBF+6
	BLT	S,STITBF+20
	SETZ	S,		;INITIALIZE POINTER

SYMTB1:	SETOM	PAGEXT		;MOVE TO NEXT INTEGER PAGE.
	TRO	F,HDRBIT	;FLAG NEW PAGE
	MOVEI	C,PAGSIZ-2	;SET LINE COUNT

SYMTB2:	SKIPE	@SYMPNT
	CAML	S,SYMLEN	;END REACHED?
	RET			;  YES, EXIT
	MOVE	R6,S		;SAVE CURRENT POINTER
	MOVEI	V,SPL		;SET "SYMBOLS PER LINE"
	TLNE	F,TTYBIT	;TTY?
	MOVEI	V,SPLTTY	;  YES, REDUCE

SYMTB3:	SKIPE	@SYMPNT
	CAML	S,SYMLEN
	JRST	SYMTB4
	CALL	LSTSTE		;LIST SYMBOL TABLE ENTRY
	ADDI	S,PAGSIZ-2
	SOJG	V,SYMTB3	;TEST FOR MORE ITEMS ON LINE
	SUBI	S,PAGSIZ-3

SYMTB4:	CALL	LSTCR		;END OF LINE, LIST CR/LF
	SOJLE	C,SYMTB1	;BRANCH IF END OF PAGE
	MOVEI	S,1(R6)
	JRST	SYMTB2		;OK, PROCESS ANOTHER

LSTSTE:				;LIST SYMBOL TABLE ENTRY
	CALL	LSTTAB		;LEAD OFF WITH TAB
	MOVE	A,[440600,,@SYMPNT]	;SIXBIT PTR TO SYMBOL NAME.
LSTST1:	ILDB	B,A		;GET A CHARACTER
	JUMPE	B,LSTST2	;DON'T LIST TRAILING BLANKS
	ADDI	B,40		;CONVERT TO ASCII
	CALL	LSTOUT		;LIST CHARACTER
	TLNE	A,770000	;ANY MORE CHARACTERS?
	JRST	LSTST1		;  YES
LSTST2:	CALL	LSTTAB
	MOVE	A,[POINT 3,@VALPNT,17,]	;SET HEX POINTER
LSTST3:	ILDB	B,A		;GET OCTAL CHARACTER
	ADDI	B,"0		;CONVERT TO ASCII
	CALL	LSTOUT		;LIST IT
	TLNE	A,770000	;ANY MORE BYTES?
	JRST	LSTST3		;  YES
	MOVE	A,@VALPNT	;PICK UP VALUE POINTER
	MOVEI	B,"R
	TLNE	A,REGSYM	;REGISTER SYMBOL?
	CALL	LSTOUT		;YES, LIST IT
	MOVEI	B,"U
	TLNE	A,UNDSYM	;UNDEFINED?
	CALL	LSTOUT		;YES, LIST IT
	MOVEI	B,"H		;FOR HALF KILLED
	TLNE	A,HKLSYM
	CALL	LSTOUT
	JRST	LSTTAB		;OUTPUT A TAB AND EXIT
;PERMANENT SYMBOL TABLE

INITAB:
DEFINE OPS B,A
IRPS X,,[A]
IFE .IRPCN&1,	SIXBIT /X/
IFN .IRPCN&1,	B,,X
TERMIN TERMIN

LDOP==OPOP
JMOP==BCOP
INPOP==UNOP
OUOP==SCOP
RSOP==FLOP
IMOP==MLOP

N==0
IRPC R,,[ABCDEHL]
M==0
SIXBIT /L!R!M/
LDOP,,307+N_3

SIXBIT /LM!R/
LDOP,,370+N

SIXBIT /L!R!I/
IMOP,,6+N_3

IRPC X,,[ABCDEHL]
SIXBIT /L!R!!X/
LDOP,,300+N_3+M
M==M+1
TERMIN
N==N+1
TERMIN

IRPC R,[BCDEHL]
SIXBIT /DC!R/
LDOP,,<.IRPCN+1>_3

SIXBIT /IN!R/
LDOP,,1+<.IRPCN+1>_3
TERMIN

IRPS OP,,[AD AC SU SB ND XR OR CP]
N==0
IRPC R,,[ABCDEHLM]
SIXBIT /OP!!R/
LDOP,,200+N_3+.IRPCN
TERMIN
SIXBIT /OP!I/
IMOP,,204+N_3
N==N+1
TERMIN

IRPC C,,[CZSP]
SIXBIT /JF!C/
JMOP,,100+.IRPCN_3

SIXBIT /JT!C/
JMOP,,140+.IRPCN_3

SIXBIT /CF!C/
JMOP,,102+.IRPCN_3

SIXBIT /CT!C/
JMOP,,142+.IRPCN_3

SIXBIT /RF!C/
LDOP,,3+.IRPCN_3

SIXBIT /RT!C/
LDOP,,43+.IRPCN_3
TERMIN

SIXBIT /LMI/
IMOP,,76

SIXBIT /RET/
LDOP,,7

SIXBIT /INP/
INPOP,,101

SIXBIT /OUT/
OUOP,,101

SIXBIT /HLT/
LDOP,,0

OPS LDOP,[RLC 2,RRC 12,RAL 22,RAR 32]
OPS JMOP,[JMP 104,CAL 106]
OPS INOP,[%FNAM2 %FNAM2,%. L,%OFFSE LOCTR,%XCREF NOCREF
%XLIST TSLWRD,.RPCNT %RPCNT,.IRPCN %IRPCN,%NARG %NARG,%ABSAD %ABSAD]

OPS NPOP,[.LENGT ALENGT,.ADRMD AADRMD]

.ENDCX:	OPS PSOP,.ENDC OPCERR

.ENDMX:	OPS PSOP,.ENDM OPCERR

.ENDRX:	OPS PSOP,.ENDR OPCERR

.MACRX:	OPS PSOP,.MACR AMACR

.MACRY:	OPS PSOP,.MACRO AMACRO

.REPTX:	OPS PSOP,.REPT REPEA0

.TTYMX:	OPS PSOP,.TTYMA ATTYMA

IRPS X,,[NLIST PAGE XCREF EJECT END LIST XLIST EVEN ODD BLKB BLKW
INSRT EOT OFFSE IRP IRPC MEXIT IF IIF LIF IFF IFT IFTF NARG NTYPE NCHR
MSG REM ERROR PRINT TITLE STITL SBTTL WORD BYTE ASCII ASCIZ]
	SIXBIT /.!X/
	PSOP,,A!X
TERMIN

IRP X,,[1,2,B,NB,DF,NDF,G,GE,L,LE,Z,NZ]
	SIXBIT/.IF!X/
	CNOP,,$IF!X
TERMIN
INILEN==.-INITAB
;CHARACTER DISPATCH ROUTINES

C1PNTR:	420200+I,,CHJTBL
C4PNTR:	360400+I,,CHJTBL
ANPNTR:	330300+I,,CHJTBL
CPNTRM:	300300+I,,CHJTBL
SQPNTR:	230500,,CHJTBL(I)	;SQUOZE CODE FOR CHAR, OR 0.

DEFINE	XBYTE	$1,$2,$3,$4,$5
	.WALGN
	$1+0?$2+0?$3+0?$4+0?$5+0
TERMIN

CHJTBL:	.BYTE	2,4,3,3,5

	XBYTE	MACR,    ,.TRM,    	;
	XBYTE	    ,    ,    ,    	;
	XBYTE	    ,    ,    ,    	;
	XBYTE	MACR,    ,.TRM,    	;
	XBYTE	    ,    ,    ,    	;
	XBYTE	    ,    ,    ,    	;
	XBYTE	    ,    ,    ,    	;
	XBYTE	    ,    ,    ,    	;

	XBYTE	    ,    ,    ,    	;
	XBYTE	MASP,    ,.TAB,TERMSP	; TAB
	XBYTE	MACR,EXND,.TRM,    	; LF
	XBYTE	    ,    ,    ,    	;
	XBYTE	    ,    ,    ,    	; FF
	XBYTE	MACR,EXND,.TRM,    	; CR

REPEAT 22,XBYTE

	XBYTE	MASP,    ,.TAB,TERMSP	; SPACE
	XBYTE	    ,EXOR,.TRM,    	; !
	XBYTE	    ,EXTM,.TRM,TERMQ2	; "
	XBYTE	    ,    ,.TRM,    	; #
	XBYTE	    ,EXTM,.ALP,TERMSY,33; $
	XBYTE	    ,EXTM,.ALP,TERMSY,35; %
	XBYTE	    ,EXAN,.TRM,    	; &
	XBYTE	    ,EXTM,.TRM,TERMQ1	; '

	XBYTE	    ,EXND,.TRM,    	; (
	XBYTE	    ,EXND,.TRM,    	; )
	XBYTE	    ,EXML,.TRM,    	; *
	XBYTE	    ,EXPL,.TRM,TERMSP	; +
	XBYTE	MACM,EXND,.TRM,    	; ,
	XBYTE	    ,EXMI,.TRM,TERMMI	; -
	XBYTE	    ,EXTM,.DOT,TERMSY,34; .
	XBYTE	    ,EXDV,.TRM,    	; /

REPEAT 12,XBYTE	    ,EXTM,.NUM,TERMDG,.RPCNT+36	;DIGITS.

	XBYTE	    ,    ,.TRM,    	; :
	XBYTE	MACR,EXND,.TRM,    	; ;
	XBYTE	    ,EXTM,.TRM,TERMOB	; <
	XBYTE	    ,    ,.TRM,    	; =
	XBYTE	    ,EXND,.TRM,    	; >
	XBYTE	    ,    ,    ,    	; ?
	XBYTE	    ,    ,.TRM,    	; @

REPEAT 32,XBYTE	    ,EXTM,.ALP,TERMSY,.RPCNT+1	;LETTERS

	XBYTE	    ,    ,    ,    	; [
	XBYTE	    ,    ,    ,    	; \
	XBYTE	    ,    ,    ,    	; ]
	XBYTE	    ,    ,    ,    	; ^
	XBYTE	    ,EXLA,.TRM,    	; _
	XBYTE				;LOWER CASE @.
REPEAT 32,XBYTE	    ,EXTM,.LOW,TERMSY,.RPCNT+1	;LOWER CASE LETTERS.
REPEAT 5,XBYTE				;FUNNY LOWER CASE CHARS.

	.BYTE
IFN .-CHJTBL-200,.ERR CHJTBL WRONG # ENTRIES.


	CONSTA
	VARIAB

MACPDL:	BLOCK	1000		;MACRO PDL.

JOBFFI:

LOC	.+300+INILEN+PDPLEN
JOBFFJ=	2000+<.&-2000>

;.5KILL ALL SMALL SYMBOLS EXCEPT REGS.
IRP X,,[EXDV,EXLA,EXAN,EXOR,EXML,EXPL,EXMI,EXTM,EXND
MACR,MASP,MACM,CL1,CL2,CL3,CL4,CL5,CL6,CL7
QUEARG,QUEMAC,TAB,FF,CRR,SPACE,INDBIT,RUBOUT
TERMSP,TERMDG,TERMSY,TERMMI,TERMOB,TERMQ1,TERMQ2]
	X==X
TERMIN

	END	PALX11
