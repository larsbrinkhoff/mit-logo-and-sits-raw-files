.ABS
VERN==%FNAM2
%COMPAT==0		;SUPRESS INCOMPATABLE OP-CODE MESSAGES
NTKDIS==5
NTVS==0
NTVCHN==0
.INSRT SITS;SITMAC >
;FLASK ^/1=> TVS, 0=> NONE/,TVS
TVS==1
.IFNZ TVS
NTVS==32.
NTVCHN==4
.ENDC
	.SBTTL INTERNAL REGISTER DEFINITIONS
;MEMORY SEGMENTATION UNIT
SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
USRISD=177600
USRDSD=177620
USRISA=177640
USRDSA=177660
SUPISD=172200
SUPDSD=172220
SUPISA=172240
SUPDSA=172260
KERISD=172300
KERDSD=172320
KERISA=172340
KERDSA=172360

;SEGMENTATION REGISTER DEFINITION
SEGNRA==100000		;SEGMENTATION NON RESIDENT ABORT
SEGSLE==40000		;SEGMENT LENGTH ERROR
SEGRVI==20000		;READ ONLY VIOLATION
SEGTRP==10000		;SEGMENTATION TRAP
SEGPMO==177637		;PAGE MODE THAT CAUSED TRAP
SEGKER==0		;KERNEL MODE
SEGUSR==140		;USER MODE
SEGPNO==177741		;THE PAGE NO. MASK

;CONSOLE SWITCHES AND DISPLAY
CDISP=177570
CSWR=177570

;PROGRAM INTERUPT REQUEST REGISTER
PIRQ=177772

;STACK LIMIT REGISTER
STKLIM=177774

;PROCESSOR STATUS
PS=177776

;START OF PARITY REGISTERS
PARCSR=172100

RUGST==157000		;RUG STARTING LOCATION
;KERNAL MAP REGISTERS
I0AR=KERISA
I1AR=I0AR+2
I2AR=I1AR+2
I3AR=I2AR+2
I4AR=I3AR+2
I5AR=I4AR+2
I6AR=I5AR+2
I7AR=I6AR+2
RUGIAR=I6AR

I0DR=KERISD
I1DR=I0DR+2
I2DR=I1DR+2
I3DR=I2DR+2
I4DR=I3DR+2
I5DR=I4DR+2
I6DR=I5DR+2
I7DR=I6DR+2
RUGIDR=I6DR

VAR0AR=KERDSA
VAR1AR=VAR0AR+2
VAR2AR=VAR1AR+2
ITM0AR=VAR2AR+2
ITM1AR=ITM0AR+2
ITM2AR=ITM1AR+2
RUGDAR=ITM2AR+2
IOAR=RUGDAR+2

VAR0DR=KERDSD
VAR1DR=VAR0DR+2
VAR2DR=VAR1DR+2
ITM0DR=VAR2DR+2
ITM1DR=ITM0DR+2
ITM2DR=ITM1DR+2
RUGDDR=ITM2DR+2
IODR=RUGDDR+2

;INTERNAL TRAP VECTORS
BEBRV=4
ILLBRV=10
BPTBRV=14
IOTBRV=20
PWFBRV=24
EMTBRV=30
TRPBRV=34
PARBRV=114
PIRBRV=240
FPPBRV=244
SEGBRV=250
	.SBTTL DEVICE DEFINITIONS
;RF11 FIXED HEAD DISK
RFCS=177460	;CONTROL AND STATUS
RFWC=177462	;WORD COUNT
RFBA=177464	;BUSS ADDRESS
RFDA=177466	;DISK ADDRESS (LOW PART)
RFDAE=177470	;HIGH PART OF ADDRESS AND ERROR REGISTER
RFBRV=204

;RK11 MOVING HEAD DISK
RKDS=177400	;DRIVE STATUS REGISTER
RKER=177402	;ERROR REGISTER
RKCS=177404	;CONTROL AND STATUS REGISTER
RKWC=177406	;WORD COUNT
RKBA=177410	;BUSS ADDRESS
RKDA=177412	;DISK ADDRESS
RKBRV=220

;CONSOLE TELETYPE
;BREAK LEVEL 4
TKBRV=60	;CONSOLE KEYBOARD BREAK VECTOR
TKS=177560	;CONSOLE KEYBOARD STATUS
TKB=177562	;CONSOLE KEYBOARD DATA
TPBRV=64	;CONSOLE PRINTER BREAK VECTOR
TPS=177564	;CONSOLE PRINTER STATUS
TPB=177566	;CONSOLE PRINTER DATA


;PROGRAMMABLE CLOCK KW11-P
PCCS=172540	;CONTROL AND STATUS
PCCB=172542	;COUNT SET BUFFER
PCCN=172544	;COUNTER
PCBRV=104	;INTERUPT VECTOR

;LINE FEQUENCY CLOCK KW11-L
LCCS=177546	;CONTROL AND STATUS
LCBRV=100	;INTERUPT VECTOR

;TK DISPLAY
NGCSR=164040	;CONTROL AND STATUS
NGREL=164042	;RELOCATION

;PAPER TAPE PUNCH AND READER
PTRSR=177550	;PAPER TAPE READER STATUS
PTRBR=177552	;PAPER TAPE READER BUFFER
PTPSR=177554	;PAPER TAPE PUNCH STATUS
PTPBR=177556	;PAPER TAPE PUNCH BUFFER
PTRBRV=70	;VECTOR FOR READER
PTPBRV=74	;VECTOR FOR PUNCH
.SBTTL MACROS FOR DEFINING VARIOUS THINGS

;MACRO TO INITIALIZE DEFINITION OF SOME RANDOM THING
.MACRO DTHING
FOO==0
.ENDM

;MACRO TO DEFINE A WORD FOR SOME RANDOM THING
.MACRO DWORD A,B
.IIF P1,.IIF DF A,.ERROR A ALREADY DEFINED
A==FOO
.IF NB B
.IIF P1,.IIF DF B,.ERROR B ALREADY DEFINED
B==FOO+1
.ENDC
FOO==FOO+2
.ENDM

;MACRO TO INIT THE DEFINITION OF RANDOM FLAGS
.MACRO DFLAGS
BAR==1
.ENDM

;MACRO TO DEFINE A RANDOM FLAG BIT
.MACRO DFLAG FLAG
.IIF P1,.IIF DF FLAG,.ERROR FLAG ALREADY DEFINED
.IIF Z BAR,.ERROR FLAG TOO MANY FLAGS
FLAG==BAR
BAR==BAR_1
.ENDM

;MACRO TO ADD SOMETHING TO A REMOTE MACRO
.MACRO ADDMAC MAC,STUFF
MAC <
.MACRO MAC A,B,C
A>,<STUFF>,<B
C
.ENDM>
.ENDM

;MACRO FOR THE INITLS TABLE
.MACRO INITSL A,B,C
A
INITLS:
B
C
.ENDM

;MACRO FOR STORAGE ALLOCATION OF LIST SPACE
.MACRO LSTSTO A,B,C
A
LISTST:
B
C
.ENDM

.MACRO ALSTM FREENM,TABNAM,LENGTH,NUM
ADDMAC LSTSTO,<FREENM:	0
.IIF NB TABNAM,TABNAM:
.BLKB LENGTH*NUM
AILSTM FREENM,NUM,LENGTH>
.ENDM

.MACRO AILSTM FREENM,NUM,LENGTH
ADDMAC INITSL,<ILIST FREENM+2,FREENM,NUM,LENGTH>
.ENDM

;MACRO TO DEFINE A LIST STORAGE AREA
.MACRO ILISTS FREENM,TABNAM,NUM
ALSTM FREENM,TABNAM,\FOO,NUM
.ENDM

.MACRO ILIST AD,FREE,NUM,LEN
WORDS <AD+LEN,FREE,NUM-2,LEN>
.ENDM

	.SBTTL SYSTEM PARAMETERS

;GENERALIZED ITEM POINTER DEFINITION
GIPBIT==100000	;SET IF IT IS A GENERALIZED ITEM POINTER
GIPSPR==40000	;BIT SET IF UPT IS IN A SPHERE
GIPITM==176000	;MASK FOR ITEM INDEX
GIPUPT==141777	;MASK FOR UPT NUMBER (IN SPHERE)
GIPFUP==140000	;MASK FOR FLOATING UPT TABLE OFFSET

;FOR THE ITEM LIST
NITEMS==255.	;MAXIMUM NUMBER OF ITEMS
NITMBL==8.	;MAXIMUM NUMBER OF BLOCKS ALLOCATED TO ITEM STROAGE
NITMPS==10	;MAXIMUM DEPTH OF ITEM PUSHES
NITALS==NITMBL*64.	;NUMBER OF FREE STROAGE NODES
		;CURRENTLY ALLOCATED FOR THE WORST CASE
;DEFINITION OF AN ITEM TABLE ENTRY
DTHING
DWORD ITLINK	;LINK WORD FOR FREE ENTRIES
ITMADR==ITLINK	;WHERE THE ADDRES OF THE ITEM IS KEPT
DWORD ITACCS,ITLNGT	;ACCESS CODE, LENGTH
ILISTS ITMFRE,ITMTAB,NITEMS
ITMTEL==FOO
ITACCD==6	;ITEM ACCESS CODE (READ-WRITE NO TRAP)
FOO==4
ILISTS ITMAFR,,NITALS	;FREE STORAGE NODES
;ADDRESSES OF THE ITEM SLOTS
ITM0AD==<ITM0AR-KERDSA>_12.
ITM1AD==<ITM1AR-KERDSA>_12.
ITM2AD==<ITM2AR-KERDSA>_12.

;PROCESS AND USER PARAMETERS
NPROSS==80.	;MAXIMUM NUMBER OF PROCESSES AND USERS
PRPDLL==96.	;LENGTH OF THE PDL FOR THE PROCESS
PIT2PL==10	;LENGTH OF ITEM 2 PDL IN PROCESS
;DEFINITION OF A PROCESS TABLE ENTRY
PRSTEL==16	;LENGTH OF A PROCESS TABLE ENTRY
PRTFRD==0	;FORWARD POINTER
PRTBCK==2	;BACK POINTER
PRTPPT==4	;PROCESS POINTER (OR TO ITEM IF USER)
PRTUPT==6	;USER POINTER (-1 FOR USER)
PRTJTM==10	;JTMU
PRTPRI==12	;HIS PRIORITY
PRTTIM==14	;TIME IN HALF-SECS THIS PROCESS PUT ON THIS QUEUE

;SPHERE PARAMTERS
MNCLSE==200	;MAXIMUM NUMBER OF C-LIST ENTRIES
NCLSEB==10	;NUMBER OF C-LIST ENTRIES PER BLOCK
CLSELN==12	;LENGTH OF A C-LIST ENTRY (NOTE THAT THE LENGTH OF A BLOCK=NCLSEB*CLSELN, WHATEVER IT IS)
;DEFINITION OF A C-LIST ENTRY
CLSETY==0	;TYPE
CLSEPI==2	;PRIMARY ITEM FOR ENTRY
CLSESI==4	;SECONDARY ITEM FOR ENTRY
CLSEM0==6	;FIRST RANDOM WORD FOR ENTRY
CLSEM1==10	;SECOND RANDOM WORD
;THESE ARE FOR THE .RDMAP CALL
.PLENM==177770	;MASK FOR THE LENGTH OF THE PAGE
.PACCM==174377	;MASK FOR THE ACCESS
.PDEI==100000	;BIT FOR DATA = I PAGE
.PABS==40000	;BIT FOR ABSOLUTE PAGE
.PFIL==2000	;BIT FOR FILE PAGE


	;FOR THE TELETYPE ITEM
TITQ==TOQM-1
TIQSZ==350.
TIBSZ==50.
TOQSZ==64.
TIBT==TIQM
TIQLM==TOQM
TOQLM==TOQM+TOQSZ

;FOR THE QUE ITEM
QUESZ==64	;THE SIZE OF THE QUE

;FOR THE PAPER TAPE ITEMS
PTRSZ==120.
PTPSZ==120.
;FOR THE LOCKED SWITCH LISTS
NLCKBL==NPROSS/2	;A GUESS
DTHING
DWORD LCKLNK	;THE LINK
DWORD LCKTIT	;TYPE AND ITEM
DWORD LCKWD1	;WORD ONE OF LOCK DATA
DWORD LCKWD2	;WORD TWO
ILISTS LCKFRE,,NLCKBL

;MISC SYSTEM PARAMETERS
LTIMEL==15.	;NUMBER OF TICKS BETWEEN CHECKING LONG FLUSHES
STIMEL==5.	;NUMBER OF TICKS BETWEEN SHORT FLUSH CHECKS
JTMUUT==6	;NUMBER OF TICKS BETWEEN JTMU UPDATES
JTMUAC==40	;ADDITIVE CONSTANT
JTMUDC==4	;DECAY CONSTANT
CLKL==1		;LEVEL CLOCK RUNS AT
CLKPIR==1_<CLKL+10>	;BIT FOR PIRQ
DMRL==3		;LEVEL THE MIDDLE LEVEL DISK ROUTINES RUN AT
DMRPIR==1_<DMRL+10>	;MIDDLE LEVEL DISK PIRQ BIT
IPRIOR==4	;PRIORITY TO SET A NEWLY CREATED PROCESS TO
IQUANT==4	;INTIAL QUANTUM
	.SBTTL DEFINITIONS FOR VARIOUS TYPES OF ITEMS
;MACROS TO DEFINE ITEMS WITH

;THE START DEFINING ITEM MACRO
	.MACRO SITEMD SYM
FOO==2
ITMTFO==ITMTFO+1
SYM==ITMTFO
	.ENDM

;THE DEFINE SYMBOL MACRO
;IF SECOND ARG IS PRESENT, IT IS HOW MUCH SPACE TO RESERVE, IN BYTES
	.MACRO DITMS SYM,SIZE
.IIF P1,.IIF DF SYM,.ERROR SYM ALREADY DEFININED
SYM==FOO
	.IIF B SIZE,FOO==FOO+2
	.IIF NB SIZE,FOO==FOO+<SIZE>
	.ENDM

;THE DEFINE FLAG WORD MACRO
;SPACE IS RESERVED FOR THE FLAG WORD, AND FLAGS ARE DEFIND
;SEQUENTIALLY FROM THE RIGHT TO THE LEFT 
	.MACRO DFWORD SYM,BITS
FOOBAR==0
SYM==FOO
FOO==FOO+2
	.IRP X,<BITS>
X==1_FOOBAR
FOOBAR==FOOBAR+1
	.ENDM
	.ENDM

;THE DEFINE ITEM SIZE MACRO
;DEFINES A SYMBOL AS THE SIZE OF THE ITEM DEFINED SO FAR
	.MACRO DITMSZ SYM
SYM==FOO_-6
	.ENDM
ITMTFO==0	;THE TYPE OF THE LAST ITEM DEFINED
ITTYPE==0	;FOR ALL ITEMS, THE FIRST WORD IS THE TYPE
;DEFINITION OF A PROCESS ITEM
SITEMD ITPROC
;THE NEXT THREE SHOULD NOT BE MOVED
;WITHOUT MOVING THE COORESPONDING THREE IN THE USER DEFINITION
DITMS PRSREF		;REFERENCE COUNT
DITMS PPRTPT		;POINTER TO PROCESS TABLE
DITMS PQBIT		;THE QUEUE BIT
DITMS PTUSED,4		;TIME USED BY THIS PROCESS IN HALF-TICKS
DITMS PRSID1		;PROCESS ID LOW PART
DITMS PRSID2		;PROCESS ID HIGH PART
DITMS PFAULT		;IF NON-ZERO, WHAT KIND OF FAULT
DITMS PERRW		;ERROR WORD FOR SYSTEM CALLS
DITMS PERRAD		;SYSTEM ADDRES WHERE ERRRO TRAP HAPPENED FROM
DITMS PSPHRP		;POINTER TO SPHERE
DITMS PSPHCP		;CIRCULAR POINTER TO OTHER PROCESSES IN SPHERE
DITMS PLCKSL		;END OF THE LOCKED SWITCH LIST
DITMS PUPDLO		;OFFSET OF USER'S PDL IF CALL COMPLETES
DITMS PITM2P,PIT2PL	;PROCESS'S ITEM2 PDL
DITMS PITM2C		;COUNT OF ITEMS ON ITEM2 PDL
DITMS PUREGS,14		;THE USER'S REGISTER'S
DITMS PUP		;THE USER'S PDL POINTER
DITMS PUPC		;THE USER'S PC
DITMS PUPS		;THE USER'S PROCESSOR STATUS
DITMS PSREGS,14		;THE SYSTEM'S REGISTERS
DITMS PSP		;THE SYSTEM'S PDL POINTER
DITMS PSPC		;THE SYSTEM'S PC
DITMS PPDL,PRPDLL	;THE PROCESS'S PDL
DFWORD PFLAGS,<PFALTB,PFAILB,PFPFLG,PACSVF,PPCLSR>	;PROCESS FLAG WORD
DITMS PSTOPC		;STOP COUNT
DFWORD PSTOP,<PSPHSB,PSUPSB>	;STOP WORD
;PSPHSB INDICATES THE SPHERE HAS STOPPED THE PROCESS
;PSUPSB INDICATES SOME OTHER SUPERIOR PROCESS HAS STOPPED IT
DITMSZ PRSLNF		;SIZE WITH NO FLOATING POINT
DITMS PFPPRG,24.*2	;FLOATING POINT REGISTERS
DITMS PFPPS		;FLOATING POINT STATUS
DITMS PFEC		;FLOATING EXCEPTION CODE
DITMS PFEAP		;FLOATING EXCEPTION ADDRESS POINTER
DITMSZ PRSLFP		;LENGTH WITH FLOATING POINT

;DEFINITION OF A USER ITEM
SITEMD ITUSER
;THE NEXT THREE SHOULD NOT BE MOVED (SEE PROCESS)
DITMS USRREF		;THE REFERENCE COUNT
DITMS UPRTPT		;POINTER INTO PROCESS TABLE
DITMS UQBIT		;THE QUEUE BIT (HAD BETTER BE USER QUEUE)
DITMS UTUSED,4		;TIME USED BY THIS USER
DITMS USRNAM,10.	;USER NAME
DITMSZ USRLEN		;LENGTH OF A USER ITEM



;DEFINITION OF A SPHERE ITEM
SITEMD ITSPHR
;THE NEXT THREE SHOULD NOT BE MOVED (SEE USER)
DITMS SPHREF		;REFERENCE COUNT
DITMS SPRTPT		;THE SPHERE PROCESS TABLE POINTER
DITMS SQBIT		;THE QUEUE BIT (BETTER BE SPHERE QUE)
DITMS SCLSLK		;SPHERE C-LIST LOCK (CONTAINS THE ITEM NO. OF THE PROCESS THAT
			;LOCKED IT
DFWORD SFLAG,<ENFLT1,ENFLT2,FAULT1,FAULT2,FAULT3>	;ENABLE FAULTS ONE AND TWO
			;AND SAY WHETHER FAULT OR NOT
DITMS STTFG1		;TELETYPE FLAG WORD 1
DITMS STTFG2		;TTY FLAG WORD 2
DITMS SMTTY		;ITEM NO. OF MASTER TTY ITEM
DITMS SIFTTY		;ITEM NO. OF INFERIOR TTY SPHERE
DITMS SPHPRP		;POINTER TO FIRST PORCESS
DITMS SUSRPT		;POINTER TO USER ITEM RESPONSIBLE FOR THIS SPHERE
DITMS SMSSPT		;POINTER TO MASTER SPHERE OF THIS SPHERE
DITMS SCLSEP		;POINTER TO FIRST UNUSED LOCATION, RELATIVE TO ITEM
DITMS SUPTS,16.*UPTLEN	;THE UPT ENTRIES
DITMS SCLSTT,MNCLSE/NCLSEB	;THE INDEX OFFSETS TO THE C-LIST
DITMS SICLST,NCLSEB*CLSELN*2	;START WITH 2 BLOCKS OF C-LIST
DITMSZ SPHLEN

;DEFINITION OF A TELETYPE ITEM
SITEMD ITTTY
DITMS TTYREF	;REFERENCE COUNTER FOR TTY
DITMS TTITM	;ITEM THAT CURRENTLY OWNS THIS TTY
DITMS TTLTTY	;THE LOGICAL TTY NO. ASSOCIATED WITH THIS ITEM
DITMS TTYU	;USER NUMBER OF THE OWNER OF THIS TTY
DFWORD TTYST1,<TIRST,TIQF,TOTRAN,TIMAGI,TIMAGO,TIRBM,TIEDM,TIECM,TICVM,TILIPM,TORST,TERST,TICTM,TICTF,TMORM,TMORF>
;STATUS OF TTY - FIRST WORD
.TIRST==TIRST	;=> RESET THE TTY ON NEXT INPUT BREAK
.TIQF==TIQF	;=> SUPER QUOTE THE NEXT CHARACTER
.TOTRN==TOTRAN	;=> CURRENTLY TRANSMITTING
.TIMGI==TIMAGI	;=> INPUT IMAGE MODE
.TIMGO==TIMAGO	;=> OUTPUT IMAGE MODE
.TIRBM==TIRBM	;=> IN RUBOUT MODE
.TIEDM==TIEDM	;=> IN EDIT MODE
.TIECM==TIECM	;=> IN ECHO MODE
.TICVM==TICVM	;=> CONVERT FROM LOWER TO UPPER CASE MODE
.TLIPM==TILIPM	;=> LOGO INPUT MODE
.TORST==TORST	;=> RESET THE TTY ON NEXT OUTPUT BREAK
.TERST==TERST	;=> RESET THE TTY EDIT BUFFER ON THE NEXT OUTPUT COMMMAND
.TICTM==TICTM	;=> CONTROLIFY MODE
.TICTF==TICTF	;=> CONTROLIFY THE NEXT CHAR FLAG
.TMORM==TMORM	;=> ENABLE MORE PROCESSING
.TMORF==TMORF	;=> MORE BREAK TRIGGERED
DFWORD TTYST2,<TSCRL,TOEDM>
;TTY STATUS, SECOND WORD
.TSCRL==TSCRL	;=> SCROLL MODE. IF ZERO THEN WRAP MODE IS ASSUMED
.TOEDM==TOEDM	;=> MEANS THAT THE BYTE OUTPUT WILL GO TO THE EDIT BUFFER
DITMS TOTSR	;ADDR OF TRANSMIT STATUS REGISTER
DITMS TIBI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN INPUT BUFFER
DITMS TIBO	;  "     "    "     "    "  COMES OUT  "   "     "
DITMS TIBN	;NUMBER OF CHAR. IN INPUT BUFFER
DITMS TIQI	;POINTER TO WHERE NEXT CHAR GOES IN, IN INPUT QUE
DITMS TIQO	;    "    "   "     "    " COMES OUT  "   "    "
DITMS TIQN	;NUMBER OF CHAR. IN INPUT QUE
DITMS TOQI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN OUTPUT QUE
DITMS TOQO	;   "     "   "    "    "   COMES OUT  "    "     "
DITMS TOQN	;NUMBER OF CHAR. IN OUTPUT QUE
DITMS TIEQO	;POINTER TO WHERE NEXT CHAR COMES OUT, IN OUTPUT QUE
DITMS TIEQN	;NUMBER OF CHARACTERS IN EDIT QUE
DITMS TIBC	;NUMBER OF UNMATCHED LEFT BRACKETS IN INPUT QUE
DITMS TIEBC	;   "   "       "      "      "     "   "    "
DITMS TIQTO	;POINTER TO WHERE ECHO IS PROCESSING
DITMS TIQTON	;NUMBER OF CHAR THAT ECHO STILL HAS TO PROCESS
DITMS TIEQTN	;NUMBER OF CHAR THAT RDSTR HAS TO PROCESS
DITMS TIEQTO	;POINTER TO WHERE RDSTR IS PROCESSING
DITMS TITQN	;TOTAL NUMBER OF CHAR IN INPUT/EDIT QUE
DITMS TOPAD	;NUMBER OF CHAR LEFT TO SEND PAD
DITMS TOIPC	;SAVED PC FOR ECHO
DITMS TOISVA	;SAVED A FOR ECHO
DITMS TOPC	;SAVED PC FOR OUTPUT
DITMS TOSVC	;SAVED C FOR OUTPUT
DITMS TOSVD	;SAVED D FOR OUTPUT
DITMS CHARNO	;NUMBER OF CHAR PRINTED FROM LEFT EDGE OF PAGE
DITMS LINENO	;NUMBER OF LINES FROM TOP OF SCREEN
DITMS TLAST	;THE LAST CHAR TYPED
DITMS LINEL	;THE LENGTH OF A LINE
.IFNZ NTVS
DITMS TVCRLN	;BYTE ADDRESS OF THE CURSOR IN BUFFER
DITMS TVSCRL	;ADDRESS IN 64 BIT CHUNKS OF SCROLL START
DITMS TVLINE	;THE LINE NUMBER OF THE CURSOR (CHAR LINE NUMBER)
DITMS TVHIGH	;THE NUMBER OF CHAR LINES ON A SCREEN
DITMS TVFONT	;THE FONT NUMBER OF THIS TV
DITMS TVST	;TV STATUS (CONTENTS OF TVCNSL)
DITMS TVCUR	;INTERRUPT LEVEL CURSOR POSITION
DITMS TVBUF	;THE NUMBER OF THE TV BUFFER FOR THIS TV
DITMS TVNLSC	;THE NUMBER OF LINES TO SCROLL
DITMS TVHBIT	;THE HORIZONTAL BIT POSITION ON THE CURRENT LINE OF CURSOR
DITMS TVLCNT	;THE NUMBER OF LINES IN A CHAR - 1, USED BY BLINK FOR TVWC
DITMS TVMSK1	;THE LEFT SIDE OF THE CURSOR MASK
DITMS TVMSK2	;THE RIGHT SIDE OF THE CURSOR MASK, IN CASE CURSOR CROSSES WORD
DITMS TVSHCT	;SHIFT COUNT FOR THE CURSOR POSITION
DITMS TVCRSN	;BYTE ADDRESS OF THE BEGINNING OF LINE, LIKE TVCRLN
DITMS TVOFFL	;TOP LINE IN WRAP MODE, WHERE THE CURSOR GOES FROM BOTTOM
.ENDC
DITMS TIBB,TIBSZ	;INPUT BUFFER
DITMS TIQM,TIQSZ	;INPUT QUE
DITMS TOQM,TOQSZ	;OUTPUT QUE
DITMSZ TTYLEN

;DEFINITION OF A QUE ITEM
SITEMD ITQUE	;QUE ITEM
DITMS QUEREF	;REFERENCE COUNT OF THE ITEM
DITMS QUEENO	;NO OF ENTRIES IN QUE
DITMS QUECNT	;NO OF PEOPLE ON QUE
DITMS QUENUM	;THE NUMBER OF PEOPLE WHO CAN LOCK QUE
DITMS QUEQUE,QUESZ	;THE QUE
DITMSZ QUELEN
;DEFINITION OF A MASTER FILE ITEM
SITEMD ITMF		;TOP BYTE IS COUNT OF CAP WITH LOCK ON MFI
DITMS MFFREF		;REFERENCE COUNT INCREMENTED BY INFERIOR MFI'S
			;AND FA CAPS
DITMS MFPBRF		;REFERENCE COUNT INCREMENTED BY FPBS
DITMS MFELN		;ACTUAL LENGTH OF THE ITEM IN BYTES
DITMS MFIDLN		;NUMBER OF BLOCKS CURRENTLY ALLOCATED TO DIRECTORY
DITMS MFIUCF		;BYTES IN DIRECORY NOT COMMITED TO EXITANT MFI'S
DITMS MFDISK		;DISK THE FILE/DIRECTORY IS ON
DITMS MFDLNK		;LINK TO OTHER OPEN FILES ON THIS DISK
DITMS MFIUPT		;SLOT FOR SYSTEM TO STORE FUPT
DITMS MFIPB		;FIRST IN LIST OF LINKED FPBS
DITMS MFIFNO		;FILE NUMBER IN DIRECTORY
DITMS MFBAKP		;ITEM NUMBER OF PARENT MFI IF A FILE
DITMS MFLAGW		;BOTTOM BYTE IS LOGICAL DSK #
MFDMTB==100000		;DIRECTORY EMPTY BIT
.FALNK==100000		;USER REQUEST FOR A LINK
			;BIT SET IF DIRECTORY
.FADIR==40000		;USER REQUEST FOR DIRECTORY
			;WRITE TO SOURCE (SAME AS FPTWSB)
.FAWSB==20000		;USER REQUEST FOR WRITE TO SOURCE
			;ROOT DIR. BIT
.FARUT==10000		;USER REQUEST FOR ROOT DIRECTORY
			;LOCKED BY USER BIT
.FALOK==4000		;USER REQUEST TO LOCK MFI
MFEBMB==2000		;ENTRY BEEN MUNGED
MFIBEB==1000		;MFI BEING ENLARGED BIT
MFOPNB==400		;FILE BEING OPENED BIT
MFDWDB==200		;DELETE WHEN DONE BIT
MFTMPF==100		;TEMPORARY FILE
MFELEN==FOO		;EXACT LEGNTH IN BYTES OF OVERHEAD
DITMS MFENHD		;ENTRY HEADER
DITMS MFVERN
DITMS MFPGNO		;EOF PAGE NUMBER
DITMS MFBYTP		;EOF BYTE POINTER
DITMS MFDATE		;FILE DATE
DITMS MFTIME		;AND TIME
DITMS MFNAME		;START OF NAME IF NO ACCESS CODES
DITMS MFDUM,12		;SPACE TO INTIALLY ALLOCATE FOR ENTRY
MFPARE==0		;BITS IN ENTRY HEADER FLAG WORD
MFDIRE==1000
MFFILE==2000
;TYPE 3000 IS UNUSED
MFSLFE==4000
MFLNKE==5000
;TYPES 14 AND 16 ARE UNUSED

MFEOFB==100000		;SET IF EOF DATE AND TIME WORDS EXIST
MFACCB==40000		;SET IF ACCESS CODE EXIST
			;BIT 20000 IS UNUSED
MFSHRB==10000		;SET IF BLOCKS SHARED WITH OTHER FILE
			;BITS 7000 ARE USED BY ENTRY TYPES
MFLSTB==400		;SET IF EOF WORD POINTS TO EXISTING BLOCK
DITMSZ MFLEN

;DEFINITION OF CORE LINK ITEM, (WHEN A PAGE, IT LOOKS THE SAME)
SITEMD ITCL
DITMS CLREF		;THE REFERENCE COUNT
DITMS CLCONP		;POINTER TO THE CONSUMER
DITMS CLCNT		;THE AMOUNT OF VALID DATA IN ITEM
DITMS CLNUM		;THE NUMBER OF SLOTS IN THE BUFFER
DITMS CLDATI		;POINTER TO DATA IN
DITMS CLDATO		;POINTER TO DATA OUT
CLDATL==FOO		;THE LENGTH OF THE DATA WORDS



;DEFINITION OF A FONT ITEM
SITEMD ITFNT
DITMS FNTREF		;NOT REALLY USED FOR ANYTHING
DITMS FNWIDE		;WIDTH OF THIS FONT
DITMS FNHIGH		;HEIGHT OF THIS FONT
DITMS FNTEND		;POINTER TO THE END OF THE FONT
DITMS FNTLCL		;THE NUMBER OF TV LINES IN ONE CHAR LINE
DITMS FNMSK		;A RIGHT ADJUSTED MASK FOR CHARS IN THIS FONT
;THE SYSTEM COMPUTES THE NEXT 2 VARIABLES WHEN THE ITEM IS CREATED
DITMS FNLINE		;THE NUMBER OF CHAR LINES THAT FIT ON A SCREEN
DITMS FLFINC		;NUMBER OF BYTES IN ONE CHAR LINE
DITMS FNREM		;THE NUMBER OF BYTES AFTER LAST SCREEN LINE. MAY BE NEGATIVE.
DITMS FNLINL		;THE NUMBER OF CHARS PER LINE
DITMS FNLSC		;THE NUMBER OF LINES TO SCROLL
;VARIOUS PRECOMPUTED VARIABLES GO HERE
FOO==40			;THE DISPATCH TABLE ALWAYS STARTS AT 40
DITMS FNTPNT,400	;AND IS 128. WORDS LONG

;DEFINITION OF THE PAPER TAPE READER ITEM
SITEMD ITPTR
DITMS PTRREF		;REFERENCE COUNT
DITMS PTRDAI		;POINTER TO WHERE DATA GOES IN
DITMS PTRDAO		;POINTER TO WHERE DATA COMES OUT
DITMS PTRNO		;NUMBER OF BYTES IN BUFFER
DITMS PTRBUF,PTRSZ	;BUFFER FOR PAPER TAPE READER
PTREND==FOO		;TOP OF BUFFER
DITMSZ PTRLEN

;DEFINITION OF THE PAPER TAPE PUNCH ITEM
SITEMD ITPTP
DITMS PTPREF		;REFERENCE COUNT
DITMS PTPDAI		;POINTER TO WHERE DATA GOES IN
DITMS PTPDAO		;POINTER TO WHERE DATA COMES OUT
DITMS PTPNO		;NUMBER OF BYTES
DITMS PTPBUF,PTPSZ	;BUFFER FOR DATA
PTPEND==FOO		;TOP OF THE BUFFER
DITMSZ PTPLEN

.SBTTL MACROS FOR GENERATING CODE

.MACRO BUGC COND,CONTIN
.IF B CONTIN
	B'COND .+4
	BPT
.IFF
	B'COND .+10
	BPT
	JMP CONTIN
.ENDC
.ENDM

.MACRO FAULT TYPE
	TRAP+TYPE
.ENDM

.MACRO LBRLEM ADDR,COND,A,Q
	.IF IDN COND,A
	B'Q .+6
	JMP ADDR
	.ENDC
	.IF IDN COND,Q
	B'A .+6
	JMP ADDR
	.ENDC
.ENDM


.MACRO LBR COND,ADDR
	.IF1
	  .IFDF ADDR
	     .IFGE ADDR-.+376
	      .=.+2
	     .IFF
	      .=.+6
	      .IIF B COND,.=.-2
	     .ENDC
	  .IFF
	   .=.+6
	   .IIF B COND,.=.-2
	  .ENDC
	.IFF
	 LBRCSW==0
	  .IFLE ADDR-.
	     .IFGE ADDR-.+376
	      LBRCSW==1
	        .IF NB COND
	         B'COND ADDR
	        .IFF
	         BR ADDR
	        .ENDC
	     .ENDC
	  .ENDC
	  .IFZ LBRCSW
	     .IIF B COND,JMP ADDR
	     LBRLEM ADDR,COND,EQ,NE
	     LBRLEM ADDR,COND,LT,GE
	     LBRLEM ADDR,COND,LE,GT
	     LBRLEM ADDR,COND,HIS,LO
	     LBRLEM ADDR,COND,LOS,HI
	     LBRLEM ADDR,COND,CS,CC
	     LBRLEM ADDR,COND,VS,VC
	  .ENDC
	.ENDC
.ENDM
;MACRO TO DO A BUG CHECK IN THE "NATURAL DIRECTION"
;THAT IS, IF THE CONDITION IS TRUE, BPT
.MACRO NBUGC COND
	RBRPP4 COND
	BPT
.ENDM

;MACRO TO BRANCH TO .+4 (PP4) ON THE OPPISITE OF THE SUPPLIED CONDITON
.MACRO RBRPP4 COND
	BRO .+4,COND,EQ,NE
	BRO .+4,COND,LT,GE
	BRO .+4,COND,LE,GT
	BRO .+4,COND,HIS,LO
	BRO .+4,COND,LOS,HI
	BRO .+4,COND,CS,CC
	BRO .+4,COND,VS,VC
.ENDM

;MACRO TO GENERATE BRANCH OF OPPISTIE CONDITION
.MACRO BRO ADDR,COND,A,Q
.IIF IDN COND,A,	B'Q ADDR
.IIF IDN COND,Q,	B'A ADDR
.ENDM

	.SBTTL TRAP VECTORS
	.MACRO TRAPV DEV,PRI
.=DEV'BRV
.IIF P2,.IIF NDF DEV'BRK,DEV'BRK==0
	DEV'BRK
.IIF NB PRI,	PRI_5
.IIF B PRI,	200
.ENDM
	.=0
	BPT
	.=4
	.REPT 77
	.+2
	BPT
	.ENDR

;TRAP VECTORS FOR INTERNAL DEVICES
TRAPV BE	;BUSS ERRORS
TRAPV ILL	;ILLEGAL INSTRUCTIONS
TRAPV BPT	;BREAKPOINTS
TRAPV IOT	;IOT
TRAPV PWF,7	;POWER FAILURE
TRAPV EMT	;EMT
TRAPV TRP	;TRAP
TRAPV PAR	;PARITY ERROR
TRAPV PIR,7	;PROGRAMMED INTERUPT
TRAPV FPP	;FLOATING POINT ERROR
TRAPV SEG	;SEGMENTATION ABORT OR TRAP

;TRAP VECTORS FOR OTHER DEVICES
TRAPV RF,5	;FIXED HEAD DISK
TRAPV RK,5	;MOVING HEAD DISK
TRAPV LC,6	;LINE CLOCK
TRAPV PC,6	;PROGRAMABLE CLOCK
TRAPV TK	;CONSOLE KEYBOARD
TRAPV TP	;CONSOLE PRINTER 
TRAPV PTR,4	;PAPER TAPE READER
TRAPV PTP,4	;PAPER TAPE PUNCH

;USER SYMBOLS FOR TRAP FAULTS
.IRP X,<BE,ILL,BPT,IOT,EMT,TRP,FPP,SLE,RDO,NXM>
.'X'TF==1+.IRPCN
.ENDM
.SBTTL ERROR DEFINITIONS
;MACRO TO GENERATE A CONDITIONAL ERROR TRAP
.MACRO ERRORC COND,ERR,F1,F2
	RBRPP4 COND
	ERROR ERR,F1,F2
.ENDM

;MACRO TO GENERATE AN ERROR TRAP
.MACRO ERROR ERR,F1,F2
ERRCOD==.E'ERR!TRPZBT
	EFLAG F1
	EFLAG F2
	TRAP ERRCOD
.ENDM

;MACRO TO HELP OUT ERROR
.MACRO EFLAG FLAG
.IIF IDN FLAG,SZ,ERRCOD==ERRCOD!TRPZBT
.IIF IDN FLAG,CZ,ERRCOD==ERRCOD&<-TRPZBT-1>
.IIF IDN FLAG,SV,ERRCOD==ERRCOD!TRPVBT
.IIF IDN FLAG,CV,ERRCOD==ERRCOD&<-TRPVBT-1>
.ENDM

TRPZBT==200
TRPVBT==100

;MACRO TO ASSIGN AN ERROR SYMBOL
.MACRO ERDEF CODE
.E'CODE==FOO
FOO==FOO+1
.ENDM

FOO==1

ERDEF NIT	;NO ITEM AVAILABLE
ERDEF BCT	;BAD CAPABILITY TYPE
ERDEF BCN	;BAD CAPABILITY NUMBER
ERDEF BAC	;BAD ACCESS
ERDEF BPN	;BAD PAGE NUMBER
ERDEF SYS	;CALL MAY ONLY BE EXECUTED BY SYSSPR
ERDEF BAD	;BAD ARGUMENTS TO CALL
ERDEF NSS	;NO SWAP SPACE LEFT
ERDEF BFUN	;BAD FUNCTION
ERDEF FNTL	;FILE NAME TOO LONG
ERDEF NIS	;NO ITEM SPACE AVAILABLE
ERDEF FNF	;FILE NOT FOUND
ERDEF BFN	;BAD FILE NAME
ERDEF APEF	;ACCESS PAST END OF FILE
ERDEF RPEF	;ATTEMPT TO READ PAST END OF FILE
	.=400
	.SBTTL SYSTEM VARIABLES AND TABLES

	.BLKW 200	;FOR THE SYSTEM PDL
PDL:
PARREG:	.BLKW 20	;FOR THE REAL PARITY REGISTERS

ABSLD:
.OFFSET 160000-.
ABSLOD:	MOV #ABLDPD,P	;REINIT THE PDL POINTER
	CLR D
	MOV #20000,E
	CLR (D)+
	SOB E,.-2
	CLR ABSCNT
	;C IS CHECKSUM
	;D IS CORE ADDRESS
	;E IS BYTE COUNT
ABSLOP:	CLR C
	JSR PC,GBYTE
	CMPB #1,A	;IS IT THE START OF A BLOCK?
	BNE ABSLOP	;NO, TRY AGAIN
	JSR PC,GBYTE
	TST A
	BNE ABSLOP	;SHOULD BE A ZERO NEXT
	JSR PC,GWORD	;GET THE COUNT
	MOV A,E		;SAVE IT
	JSR PC,GWORD	;GET THE ADDRESS
	MOV A,D
	ADD E,A		;CHECK THAT WE AREN'T OVERLOADING
	CMP #40000,A
	BHI .+4		;MUST BE UNDER 8K
	BPT
	CMP #6,E	;IS IT THE START BLOCK?
	BEQ ABSSRT	;YUP
	SUB #6,E	;THAT MANY ALREADY LOADED
ABSLP1:	JSR PC,GBYTE
	MOVB A,(D)+
	SOB E,ABSLP1
	JSR PC,GBYTE	;THE CHECKSUM
	TSTB C
	BEQ ABSLOP	;CHECKSUM GOOD
	BPT		;BAD CHECKSUM
ABSSRT:	JSR PC,GBYTE	;GET CHECKSUM
	TSTB C
	BEQ .+4
	BPT		;BAD CHECKSUM
	CMP -(P),-(P)	;EXTRA WORDS
	SAVE <SYSFCP>
	BIS #.DELCP,(P)	;DELETE CAPABILITY TO FILE
	$INVOK
	JMP (D)

GBYTE:	DEC ABSCNT
	BLT GBYTE1
	MOVB @ABSPNT,A
	INC ABSPNT
	ADD A,C
	RTS PC
GBYTE1:	MOV #2000,ABSCNT	;A BARFER LOAD
	MOV #ABSBRF,ABSPNT
	SAVE <#ABSBRF,#-2000,SYSFCP>
	$BLKI
	BR GBYTE

GWORD:	JSR PC,GBYTE
	SAVE A
	JSR PC,GBYTE
	MOVB A,1(P)
	REST A
	RTS PC
SYSFCP:	0
ABSPNT:	0
ABSCNT:	0
	.BLKW 10	;ROOM FOR THE PDL
ABLDPD::
ABSBRF:
ABSEND==.
.OFFSET 0
SSTATS::	;THE SYSTEM STATUS BLOCK
	VERN	;SYSTEM VERSION
TIME:	.BLKW 2	;TIME IN 60TH'S SINCE SYS START
SVCSR:	0	;THE CONSOLE SWITCHES
LOOKSW:	0	;NON-ZERO=>PAY ATTENTION TO SWITCHES
NSTATS==<.-SSTATS>/2
MFITST:	.FARUT!0		;DATA BLOCK TO MAKE ROOT DIR
	BYTES <'R,'O,'O,'T,0,46,0>
.EVEN
MFIBIT:	ASCIZ <BITS>
MFISYS:	ASCIZ <. SYSSPR>
MFIDSC:	ASCIZ <DESCR>
	.EVEN
PATCH:
PAT:	.BLKW 140
SYSJPD:		;THE SYSTEM JOB'S PDL
BMT:	BYTES <1,2,4,10,20,40,100,200>	;BIT MARK TABLE
	;FOR MARKING BIT TABLES, THE NTH ENTRY IS THE NTH BIT
INITSW:	-1	;ZERO AFTER EXITING INIT CODE
PRUNNG:	-1	;ITEM # OF RUNNING PROCESS, NEG=> IN SYSTEM
			;(THIS IS NOT SET TO -1 BY INTERUPT ROUTINES)
USRMOD:	-1	;IF A PROCESS IS RUNNING, NON-ZERO=> IN SYSTEM CODE
			;0=>IN USER'S CODE
SYSSPR:	-1	;ITEM NUMBER OF THE SYSTEM SPHERE
CURUSR:	-1	;PROCESS BLOCK INDEX OF THE RUNNING PROCESS'S USER
CURSPH:	-1	;ITEM INDEX OF SPHERE OF THE RUNNING PROCESS
NEWPRI:	.BLKW 2	;PROCESS ID OF NEXT PROCESS TO BE CREATED
STPSVP:	0	;SAVED P WHEN WE WENT TO START A PROCESS (FOR ERROR RECOVERY)
BPCLSR:	0	;NON-ZERO WHEN IN PROCESS OF PCLSRING THE GUY GETTING UNLOCKED
QUANT:	0	;NUMBER OF TICKS BEFORE THE RUNNING PROCESS SHOULD BE STOPPED
PQUANT:	IQUANT	;QUANTUM TO GIVE A PROCESS WHEN YOU START IT
WQUANT:	IQUANT*2	;SAME, BUT FOR WINNERS
TUSED:	0	;TIME THE PROCESS HAS USED SINCE LAST STARTED
STIMER:	0	;TIME TILL NEXT CHECK OF SHORT FLUSHES
LTIMER:	0	;TIME TILL NEXT CHECK OF LONG FLUSES
JTMUUP:	JTMUUT	;NUMBER OF TICKS TILL NEXT UPDATE OF JTMUS
RUGVEC:	0		;STORING PLACE FOR RUG'S VECTOR
RUGSTA:	0		;DITTO FOR RUG'S STATUS
;SAVED VALUES FROM THE SEGMENTER
PSSR0:	0
PSSR1:	0
PSSR2:	0
PIRDIS:	WORDS <PIRLOS,STOPPR,PIRLOS,DMRBRK,PIRLOS,PIRLOS,PIRLOS,PIRLOS>	;THE PIR DISPATCH
PIRBIT:	WORDS <0,1000,2000,4000,10000,20000,40000,100000>	;THE PIR BITS
	;LOCK TABLES AND DEFINTIONS
.MACRO LCKDEF A,B
A==FOO
B
FOO==FOO+2000
.ENDM
FOO==0
;LOCK DISPATCH TABLE
LCKDIS:	LCKDEF FOO,LSPERR	;THE ZERO LOCK SHOULD NOT OCCUR
	LCKDEF LONOFF,LSPONF	;ON/OFF LOCK
				;WORD 1 IS ABS ADDR OR OFFSET INTO ITEM
				;WORD 2 CONTAINS BIT(S) LOCKED IN WORD
	LCKDEF LPCLRT,LSPPCL	;RUN ROUTINE IF PCLSRED
				;WORD 1 IS ADDRESS OF ROUTINE
	LCKDEF LCKRTN,LSPRTN	;RUN ROUTINE WHEEVER UNLOCKED
				;WORD 1 IS ROUTINE ADDRESS
	LCKDEF LCKDEC,LSPDEC	;DECREMENT WORD WHEN UNLOCKED
				;WORD 1 IS ABS ADDR OR OFFSET INTO ITEM
				;WORD 2 IF NON-ZERO IS ADDR OF ROUTINE
				;TO RUN IF DEC RESULTS IN ZERO BYTE
	LCKDEF LCKULN,LSPULN	;UNLINK NODE ON PCLOSER
				;WORD 1 IS POINTER TO NODE
				;WORD 2 POINTS TO FREE POINTER OF LIST TO RETURN IT TO
				;BE CAREFUL, NO OTHER PROCESSING IS DONE OTHER THAN FREEING NODE!
;EMT DISPACTCH TABLES
.MACRO EMTD NAME
.IF NB NAME
M'NAME==FOO
.'NAME==FOO+EMT
$'NAME==FOO+200+EMT
	E'NAME
.IFF
	BADEMT
.ENDC
FOO==FOO+1
.ENDM

FOO==0
;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
EMTDIS:
	EMTD NOOP	;NOP CALL
	EMTD FORK
	EMTD POOFF
	EMTD SLEEP
	EMTD SINK
	EMTD FLOAT
	EMTD INVOK
	EMTD QULK
	EMTD QUNLK
	EMTD TTGIV
	EMTD TTGET
	EMTD WRDI
	EMTD WRDO
	EMTD BYTI
	EMTD BYTO
	EMTD BLKI
	EMTD BLKO
	EMTD MAP
	EMTD ALLOC
	EMTD CRUSR
	EMTD RDMAP
	EMTD FONT
	EMTD SSTAT
	EMTD VIDSW
EMTHGH==FOO
.MACRO CLSTYD X
.'X'CAP==FOO
.=IVKCTB+<2*FOO>
	CAPR'X
.IRP Y,<CCPR,CPY,DEL,GIV,TAK>
.=.+CAPHGH-2
	Y''X
.ENDM
.IIF P1,CAPHGH==CAPHGH+2
.=IVKCTB+<CAPHGH*6>
FOO==FOO+1
.ENDM
.IIF P1,CAPHGH==0
FOO==0

;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
IVKCTB:
CLSTYD XX	;THE ZERO CAPABILITY SHOULD NOT EXIST

CLSTYD CC	;CREATE CAPABILITY
;NO DATA WORDS

CLSTYD MS	;MASTER SPHERE
;FIRST ITEM IS THE SPHERE
;SECOND IS SPHERE (IF ANY) IN CIRCULAR LIST OF SPHERES HAVING SHPERE
;CAPABILITY TO THIS SPHERE
;FIRST MISC IS FAULT ENTRY ADDRESS
;SECOND MISC IS C-LIST NUMBER (IF ANY) FOR CIRCULAR LIST
;BITS ARE:
.SPFES==400	;SURPRESS ENTERS THROUGH HERE
.SPCLC==1000	;ALLOW COPY FROM C-LIST
.SPCLD==2000	;ALLOW DELETE FROM C-LIST
.SPCRR==4000	;ALLOW CORE READ
.SPCRW==10000	;ALLOW CORE WRITE
.SPCRE==20000	;ALLOW CORE EXECUTE
	;THESE FLAGS ARE FOR EMAP, DIFFERENT NAMES, SAME FUNCTION
	.CRPRI==2000	;PRIVATE PAGE
	.CRRD==.SPCRR
	.CRWRT==.SPCRW
	.CREX==.SPCRE
.SPCAD==40000	;ALLOW C-LIST APPEND
MSPCBT==.SPCAD!.SPCLC!.SPCLD!.SPCRR!.SPCRW!.SPCRE	;ALL SET IN SPHERE

CLSTYD SP	;SPHERE (NON-MASTER I.E. COPY OF MASTER)
;SAME PROPERTIES AS MASTER SPHERE, EXCEPT SOME BITS MAY NOT BE SET
;AND THERE IS NO ENTRY ADDRESS
;HERE ARE THE FUNCTIONS FOR THE .SPCAP AND .MSCAP INVOK'S
.SPPTT==0	;PUT THE PROCESS INTO SPHERE
.SPCLR==1	;READ THE C-LIST

CLSTYD PR	;PROCESS CAPABILITY
;WORDS ARE ASSIGNED AS IN MASTER SPHERE AND ENTER ADDRESS IS STARTING ADDRESS
;BITS ARE:
.PRWRA==10000	;ALLOW WRITING OF INFORMATION

CLSTYD TT	;TELETYPE CAPABILITY (NO DATA WORDS)
;FLAGS ARE
.TTYO==10000	;ALLOW OUTPUT TO TTY
.TTYI==20000		;ALLOW INPUT FROM TTY

CLSTYD FA	;FILE ACCESS CAPABILITY
FAMFI==2	;FIRST WORD IS MFI PTR
FAFPN==4	;SECOND IS FILE PAGE NUMBER
FAUPT==6	;THIRD IS GIP FOR FUPT
FAFBP==10	;FOURTH IS BYTE PTR IN FILE PAGE (SEE 2ND WORD)

.FAEOFB==1000	;SET IF THE POINTER IS IN THE LAST BLOCK OF THE FILE
.FAWD==2000	;SET IF FIRST BYTE OF DKWDO IS WRITTEN
.FARD==4000	;FILE READ ACCESS
.FAWT==10000	;FILE WRITE ACCESS
.FAAP==20000	;FILE APPEND ACCESS
.FAAC==40000	;ACCESS CODES ACCESS
.FALB==100000	;LOCK BIT

CLSTYD QU	;THE QUE CAPABILITY
		;NO FLAGS

CLSTYD CL	;CORE LINK CAPABILIY
;FIRST ITEM IS GIP TO THE BUFFER
;FLAGS ARE
.CLCONS==400	;I AM THE CONSUMER FLAG

CLSTYD DS	;DISPLAY CAPABILITY
;IT HAS AN ITEM IF IT IS A TV DISPLAY, THE ITEM WORD IS 0 IF TV.
;THE FIRST MISCELLANEOUS WORD IS THE INDEX OF THE DISPLAY. FOR
;TK DISPLAYS, THIS NUMBER IS THE WORD INDEX INTO THE TKD TABLES.
;FOR TV DISPLAYS, IT IS STILL A WORD INDEX, AND SINCE THE TV TABLES
;ARE BYTE TABLES, THE NUMBER MUST BE DIVIDED BY 2 AND HAVE NFTVDS
;SUBTRACTED FROM IT BEFORE USE.

CLSTYD TR	;PAPER TAPE READER
;NO FLAGS, ITEM IS THE PTR ITEM

CLSTYD TP	;PAPER TAPE PUNCH
;NO FLAGS, ITEM IS PTP ITEM
	;DISPATCH TABLES
CCTAB=IVKCTB+CAPHGH	;THE CREATE CAPABILITY TABLE
CPYTAB=CCTAB+CAPHGH	;THE COPY CAPABILIY TABLE
DELTAB=CPYTAB+CAPHGH	;THE DELETE TABLE
GIVTAB=DELTAB+CAPHGH	;THE GIVE AWAY TABLE
TAKTAB=GIVTAB+CAPHGH
	;GENERAL FUNCTIONS FOR INVOKE
.MACRO GENFUN NAME
	NAME'CAP
	.'NAME'CP==400*<200+FOO>
	FOO==FOO+1
.ENDM

FOO==0
GENDIS:	GENFUN DEL	;DELETE THE CAPABLITY
	GENFUN CPY	;COPY THE CAPABILITY
	GENFUN GIV	;GIVE THE CAPABILIITY AWAY
	GENFUN TAK	;TAKE THE CAPABILITY (GIMMEE,GIMMEE)
GENHGH==FOO*2

;THIS IS THE DISPATCH TABLE FOR I-O DEVICES

.IRP OP,<WDI,WDO,BTI,BTO,BKI,BKO>	;INITIALZE TABLES FOR THESE TRANSFER TYPES
OP'TAB:
.IRP DEV,<DK,TT,CL,TR,TP>
DEV'IDX==.IRPCN
	DEV''OP
.ENDM
.ENDM

;THESE ARE THE TABLES FOR THE PROCESS INVOK
.MACRO PRINVK FUN,CNT
.PR'FUN==FOO
.IFB CNT
FOO==FOO+1
PR'FUN
.IFF
FOO==FOO+CNT
.REPT CNT
PR'FUN
.ENDR
.ENDC
.ENDM

FOO==0
PRIVTB:	PRINVK REG,8	;8 REGISTERS
	PRINVK PSW	;PROGRAM STATUS WORD
	PRINVK FREG,6	;6 FLOATING POINT REGISTERS
	PRINVK FPST	;FLOATING POINT STATUS WORD
	PRINVK FPEN	;ENABLE FLOATING POINT
	PRINVK STOP	;THE STOP WORD OF THE PROCESS
	PRINVK ERR	;THE ERROR WORD
	PRINVK FAUL	;THE FAULT WORD (OR WORDS)
PRHGH==FOO*2
.PRRD==0		;THE READ FUNCTION
.PRWRT==40		;THE WRITE FUNCTION

;FOR THE TTY INVOK
.MACRO TTIVK FNC
.'FNC==NTTFNC
FNC
NTTFNC==NTTFNC+1
.ENDM

.TTWRT==40
.TTIBK==400		;TTY I/O FLAG SPECIFING AN INPUT TYPE BREAK
.TTMBK==10000		;TTY FLAG SPECIFYING A MORE BREAK
.TTWD==40000		;FLAG SAYING THAT FIRST BYTE DONE ON WORD OUTS
.TTEDM==1000		;SAYING THAT THIS OUTPUT IS TO GO TO THE EDIT BUFFER

NTTFNC==0
;THESE FUNCTIONS WRITE IF THE .TTWRT BIT IS SET AND READ OTHERWISE
TTIVTB:	TTIVK TTMOV	;MOVE INTO TTY STATUS WORD (ALWAYS WRITE)
	TTIVK TTBIS	;BIS INTO TTY STATUS (ALWAYS WRITE)
	TTIVK TTBIC	;BIC INTO TTY STATUS (ALWAYS WRITE)
	TTIVK TTRD	;READ THE TTY STATUS (ALWAYS READ)
	TTIVK TTCNO	;READ OR SET THE CHARNO VARIABLE 
	TTIVK TVATC	;ATTACH A DISPLAY BUFFER TO A TTY
	TTIVK TVCL	;CLEAR THE SCREEN
	TTIVK TTBRK	;READ THE LAST BREAK CHAR TYPED, HANG IF NONE
	TTIVK TVREV	;REVERSE WHITE AND BLACK ON SCREEN
	TTIVK TTMV2	;SET TTYST2
	TTIVK TTSPD	;SET THE SPEED AND LINE PARAMETERS (DH11 ONLY)
	TTIVK TTTYP	;RETURN THE TYPE OF THE TTY TO THE USER
	TTIVK TVFNT	;CHANGE THE FONT OF THE TV TTY
	TTIVK TTBS2	;BIS INTO TTY STATUS 2
	TTIVK TTBC2	;BIC INTO TTY STATUS 2
	TTIVK TVSET	;READ OR SET TVLINE AND TVCUR
	TTIVK TVOFF	;READ OR SET TVOFFL
	TTIVK TVRFN	;READ CHAR WIDTH IN BITS AND LINE HEIGHT IN TVLINES

.MACRO TDSIVK FUNCTION
	.WORD FUNCTION
.'FUNCTION==TVDSIM+100
TVDSIM==TVDSIM+1
.ENDM

TVDSIM==0
;TV DISPLAY INVOKES
TVDSIT:	TDSIVK TVDSRC		;READ THE CURSOR
	TDSIVK TVDSSC		;SET THE CURSOR
	TDSIVK TVDSNL		;DRAW A NULL LINE
	TDSIVK TVDSIL		;IOR A LINE
	TDSIVK TVDSXL		;XOR A LINE
	TDSIVK TVDSCL		;CLEAR A BLOCK OF THE SCREEN

;VIDEO SWITCH MODES
.VIABS==0	;ABSOLUTE MODE
.VILOT==1	;LOGICAL TTY NUMBER MODE
.VILOD==2	;LOGICAL DISPLAY NUMBER MODE
.VICAM==3	;CAPABILITY MODE
;INITALIZE TABLES

;FOR THE ITEM TABLE
.IRPC X,<012>
ITEM'X:		-1		;ITEM CURRENTLY IN PAGE ITM0
ITM'X'A:	ITM'X'AD	;ADDRESS OF ITEM IN ITEM'X
ITM'X'D:	0		;PUSH DEPTH
ITM'X'P:	ITM'X'PD	;PDL POINTER FOR ITM'X
	.BLKW NITMPS		;PDL FOR ITM'X'
ITM'X'PD::
.ENDM

ITMATB:	.BLKW 200	;ITEM ALLOCATE TABLE (ONE WORD PER SIZE)
			;THESE POINT INTO ITMALS
ITMBAL:	.BLKW 1		;ITEM BLOCK STORAGE ALLOCATE LOCK
INITM1::		;INITIALIZE FOLLOWING AREA TO -1
ITMBNF:	.BLKW NITMBL	;NUMBER OF BLOCKS FREE IN THIS BIG BLOCK
ITMBST:	.BLKW NITMBL	;ADDRESS OF FIRST BLOCK OF THIS BIG BLOCK
ITMBTP:	.BLKW NITMBL	;POINTERS TO BEGGININGS OF BIT TABLES
	.BLKW 1		;THIS IS THE BACKWARDS-SEARCHING FENCE FOR THE 1ST BIT TABLE
ITMBIT:	.BLKW 11*NITMBL	;8 WORD BIT TABLE FOR EACH BIG BLOCK
				;AND A FENCE BETWEEN THE BLOCKS
EINTM1::	;END OF STUFF TO INIT TO -1
;TABLES AND SYMBOLS FOR THE FILE SYSTEM

;MACRO TO DEFINE FILE ACCESS CAPABILITY FUNCTIONS
.MACRO MFADCF SYMBOL
.FA'SYMBOL==FOO
MFA'SYMBOL
FOO==FOO+1000
.ENDM
FOO==0
FATAB:
MFADCF CF			;CLEAR FLAGS
MFADCF RE			;RETURN EOF WORDS
MFADCF SP			;SET POINTER
MFADCF RP			;RETURN POINTER
MFADCF DL			;DELETE ENTRY
MFADCF AD			;ADD ENTRY
MFADCF MU			;MUTATE CAPABILITY
MFADCF MB			;SET UP BIT TABLE FOR ROOT DIR
MFADCF RI			;RETURN INFORMATION ABOUT THE FILE
MFADCF DI			;RETURN INFORMAITON ABOUT THE DISK
;MFADCF PA			;APPEND THIS PAGE TO THE FILE
MFAHGH==<FOO-1000>/400

;STUFF FOR GROVELING THROUGH DESCRIPTORS
MFBLTB:	MFBSKP	;SKIP AND GRAB ONE
	MFBGET	;GET LOTS
	MFBSET	;SET ADDRESS AND GRAB LOTS
	MFBSKG	;SKIP SOME, GRAB SOME
ENTPNT:	0	;POINTER INTO MFI
ENTEND:	0	;END OF MFI ENTRY
ENTCNT:	0	;COUNT FOR COUNT TYPES
.SBTTL PROCESS QUEUES
	;FOR THE PROCESS TABLE
;MACRO FOR DEFINING A QUEUE
.MACRO DEFQ NAME
NAME'Q:	.BLKW 2
NAME'QB==1_FOO
	1_FOO
FOO==FOO+1
.ENDM
QLEN==6		;THE LENGTH OF A QUEUE POINTER
QBIT==4		;POSITION OF QUEUE BIT WITHIN THE POINTER
FOO==0		;INITALIZE THE QUEUE NUMBER
FIRSTQ==.
DEFQ WIN	;GUYS WHO ARE REAL WINNERS
DEFQ ACT	;GUYS WHO ARE MODERATE WINNERS
DEFQ DOR	;MODERATE WINNERS WHO ARE HUNG
DEFQ RUN	;GUYS WHO WANT TO RUN BUT ARE LOSERS
DEFQ IACT	;GUYS WHO ARE HUNG AND ARE LOSERS
DEFQ STOP	;GUYS WHO ARE STOPPED
DEFQ USER	;FOR CONFORMITY, USERS ARE KEPT HERE
DEFQ SPHR	;FOR CONFORMITY SPHERES ARE KEPT HERE
NQS==FOO
PFREEQ:	WORDS <PRSTAB,0,0>	;FREE PROCESS BLOCKS LIST POINTER
FOO==PRSTAB+PRSTEL
FOOBAR==PFREEQ
PRSTAB:	.REPT NPROSS
	FOO
	FOOBAR
FOO==FOO+PRSTEL
FOOBAR==.-4
	.=.+PRSTEL-4
	.ENDR
	WORDS <0,FOOBAR>
	.BLKB PRSTEL-2	;THE LAST PROCESS BLOCK MUST GO HERE

DTHING		;THE PROCESS ACTIVATE BLOCKS
DWORD ACTLNK	;LINK WORD
DWORD ACTITM	;PROCESS ITEM
DWORD ACTPI1	;ID WORD 1
DWORD ACTPI2	;ID WORD 2
ILISTS ACTFRE,,10.	;TEN OUGHT TO BE PLENTY
ACTLST:	0	;LIST TO ACTIVATE
PTRITM:	0		;PAPER TAPE READER ITEM NO.
PTPITM:	0		;PAPER TAPE PUNCH ITEM NO.

.SBTTL RANDOM DISK PARAMETERS
NRRKD==2	;NUMBER OF REGULAR RK11S
NRFD==0		;NUMBER OF RF11 DISKS

NDISKS==NRRKD+NRFD	;TOTAL NUMBER OF DISKS

NSWPA==NDISKS	;MAX NUMBER OF DISK SWAP AREAS

MNRTY==10.	;NUMBER OF TIMES TO RETRY OPERATION

NDRQBL==25.	;NUMBER OF LOW LEVEL DISK REQUEST BLOCKS TO ALLOCATE

;LOW LEVEL DISK REQUEST BLOCKS
DTHING
DWORD DRQLNK	;LINK WORD
DWORD DRQDNO	;DISK NUMBER
DWORD DRQHCA,DRQFUN	;HIGH CORE ADDRESS,,FUNCTION (ALSO GETS ERROR BIT)
DRQFER==100000	;INT ROUTINES SET THIS BIT TO INDICATE ERROR
DWORD DRQCA	;CORE ADDRESS (LOW PART)
DWORD DRQDA	;DISK BLOCK ADDRESS
DWORD DRQWC	;WORD COUNT
DWORD DRQABL	;PAGE REQUEST BLOCK TO ACTIVATE
ILISTS DSKRFL,,NDRQBL	;ALLOCATE NDRQBL OF THESE BLOCKS

;MIDDLE LEVEL DISK REQUEST BLOCKS
DTHING
DWORD DMRLNK
DWORD DMRPBP	;PAGE BLOCK POINTER
DWORD DMRPWK	;ITEM OF PROCESS TO WAKE UP
DWORD DMRPW1	;ID WORD 1 OF PROCESS TO WAKE UP
DWORD DMRPW2	;ID WORD 2 OF PROCESS TO WAKE UP
DWORD DMRFUN	;FUNCTION
DWORD DMRDRC	;COUNT OF DISK REQUESTS ENTERED FOR THIS BLOCK
DWORD DMRPBB	;PB BIT(S) TO CLEAR ON COMPLETION OF REQUESTS
ILISTS DMRPNT,,10.	;ONLY 10 OF THESE=> MAX OF 10 PAGES MOVING AT ONCE
.SBTTL CORE DATA STRUCTURE DEFINITIONS

;DEFINITION OF A PAGE BLOCK
DTHING
DWORD PBFLAG	;WORD OF RANDOM FLAGS, USED AS LINK IN FREE LIST
DFLAGS
DFLAG PBZERO	;THIS PAGE WANTS TO BE ZERO
DFLAG PBWCHK	;THIS PAGE SHOULD ALWAYS BE WRITE-CHECKED
DFLAG PBVAS	;PAGE IS VALID AT SOURCE
DFLAG PBVASS	;PAGE IS VALID AT SWAP SPACE
DFLAG PBVACR	;PAGE IS VALID AT CORE
DFLAG PBFILE	;PAGE IS A FILE PAGE
DFLAG PBSTS	;PAGE SHOULD BE SWAPPED TO SOURCE
DFLAG PBDISK	;PAGE HAS DISK TRANSFER(S) PENDING
DFLAG PBLOCK	;HANDS OFF!
DFLAG PBERR	;PAGE IN ERROR DUE TO DISK LOSSAGE
DWORD PBGIP	;GIP IN TH ECIRC LIST OF GIPS FOR THIS PAGE
DWORD PBCAR	;CORE ADDRESS, ZERO=>OUT
DWORD PBRAN,PBLEN	;RANDOM (START AND DISK #),,LENGTH
PBSTRT==177770	;MASK FOR START
PBDSKM==177407	;MASK FOR DISK
PBDISS==2	;DISK SHIFT (LOW ORDER BIT OF DISK IS 0)
DWORD PBDA	;START OF SWAP AREA ADDRESS
DWORD PBAUSR	;NUMBER OF ACTIVE USERS OF THIS PAGE
ILISTS PBFREL,,50.	;ALLOW FOR 50 DIFFERENT PAGES TO EXIST
;THE FOLLOWING IS THE EXTENSION OF PAGE BLOCKS TO FILE PAGE BLOCKS
DWORD PBSDSK	;THE DISK THE SOURCE IS ON
DWORD PBSDA	;THE SOURCE DISK ADDRESSES (8 OF THEM)
FOO==PBSDA+20	;ALLOCATE THEM
DWORD PBFLEN	;LENGTH OF PAGE IN BLOCKS
DWORD PBFLNK	;LINK BETWEEN PBS FOR THIS FILE
DWORD PBFPNO	;PAGE NUMBER IN FILE THAT THIS FPB IS FOR 
DWORD PBMFIP	;POINTER BACK TO MFI FOR THIS FPB
ILISTS FPBFRE,,25.	;ALLOW FOR 25 FILE PAGES

;DEFINITION OF A UPT OR FUPT
DTHING
DWORD UPTFLG,UPTSTL	;FLAGS, START AND LENGTH
DFLAGS
DFLAG UPTEXB		;THIS PAGE EXISTS!
DFLAG UPTABS		;ABSOLUTE PAGE
DFLAG UPTEXD		;EXPAND DOWN
DFLAG UPTRDO		;READ ONLY
DFLAG UPTEXO		;EXECUTE ONLY
DFLAG UPTIED		;I=D, THIS SET IN THE I SPACE PAGE
DFLAG UPTDEI		;D=I, THIS SET IN THE DATA PAGE
UPTLMS==177770		;LENGTH
UPTSMS==177617		;START
UPTSSH==4		;SHIFT FOR START
DWORD UPTPBP		;POINTER TO PAGE BLOCK (AR OF ABS PAGE)
DWORD UPTGIP		;CIRCULAR LIST POINTER (DR OF ABS PAGE)
UPTLEN==FOO		;LENGTH OF UPT
;FOR FUPTS ALSO HAVE:
DWORD FUPTPR		;POINTER TO PROCESS THAT CURRENTLY "OWNS" THIS FUPT
ILISTS FUPTFR,,25.	;ALLOCATE 25 FUPTS
.SBTTL DISK RANDOM STORAGE
DSKPS:	0	;PDL POINTER SAVE FOR ERROR CHECK
DSKPSV:	0	;PDL POINTER SAVE FOR MAIN PROG PDL POINTER
DSKP:	DPDL-14	;PDL POINTER FOR DISK ROUTINES
	.BLKW 50	;DPL STORAGE FOR DISK
DPDL:	DSTART	;CAREFULLY INITED PDL

DSKRQ:	0	;POINTER TO LIST OF PENDING REQUESTS
DRQDL:	0	;POINTER TO LIST OF DONE REQUESTS
DRQFCN:	NDRQBL	;NUMBER OF FREE DISK REQUEST BLOCKS
DMRLST:	0	;MIDDLE LEVEL DISK REQUEST LIST

DISKER:	.BLKW NDISKS	;ERRORS ON EACH DISK
DSKOFS:	.REPT NRRKD
	.RPCNT_13.
	.ENDR
DSKRQS:			;SERVICE ROUTINES FOR THE VARIOUS DISKS
	.REPT NRRKD
	RKDSKS
	.ENDR

DSKREA==0	;READ
DSKWRT==2	;WRITE
DSKWCH==4	;IF THIS BIT IS SET, WRITE-CHECK AFTER READ OR WRITE
DKWCH==10	;THE INDEX OF THE WRITE CHECK FUNCTION

RKFUN:	105	;READ
	103	;WRITE
	105	;READ W DSKWCH SET
	103	;WRITE W DSKWCH SET
	107	;WRITE CHECK

NRETRY:	0		;NUMBER OF DISK RETRYS BEFORE GIVIN GUP
DERBL:	.BLKW 10	;PLACE WHERE THE LAST ERROR IS STORED
CURDSK:	RKCS		;CS OF THE CURRENTLY RUNNING DISK
MFBITS:	.BLKW NDISKS	;FUPTS OF BIT TABLES
MFFREE:	.BLKW NDISKS	;COUNT OF FREE BLOCKS
MFBLNK:	.BLKW NDISKS	;LINK THROUGH MFI'S ACTIVE ON THIS DISK

;FILE NAME BLOCKS
FNBNML==20.	;MAX CHARS IN A FILE NAME
DTHING
DWORD FNBFNE	;END OF THE FILE NAME IN THE USER
DWORD FNBVER	;VERSION NUMBER OF THE FILE NAME
DWORD FNBFNO	;NUMBER O FFILE IN DIR
DWORD FNBFNL	;LENGTH OF FILE NAME
DWORD FNBFN	;ACTUAL FILE NAME
FOO==FNBFN+FNBNML	;ALLOCATE ENOGUH SPACE FOR FILE NAME
ILISTS FNBFRE,,4	;SHOULDN'T NEED VERY MANY
.SBTTL RANDOM STORAGE FOR SWAP AREA INFO
SWPBPT:	SWPBIT		;POINTERS TO THE SWAP AREA BITS TABLES
	.BLKW NSWPA
SWPBDK:	.BLKW NSWPA	;DISK NUMBER FOR THIS SWAP AREA
SWPBDA:	.BLKW NSWPA	;BEGGINING DISK ADDRESS FOR THIS SWAP AREA
SWPEDA:	.BLKW NSWPA	;ENDING DISK ADDRESS FOR THIS SWAP AREA
SWPFCN:	.BLKW NSWPA	;NUMBER OF FREE SWAP BLOCKS IN THIS SWAP AREA
SWPBIT:	.BLKW 105	;ACTUAL SWAPPING BIT TABLES
SWPBTE::		;END OF BIT TABLES

BITS:	WORDS <1,2,4,10,20,40,100,200>
	WORDS <400,1000,2000,4000,10000,20000,40000,100000>

BITSST:	WORDS <0,1,3,7,17,37,77,177,777,1777>
	WORDS <3777,7777,17777,37777,77777,177777>

MNCBLK==124.*2		;MAX NUMBER OF BLOCKS OF CORE TO WORRY ABOUT
.SBTTL RANDOM STORAGE FOR CORE INFORMATION
DFLAGS
DFLAG CSTFRB		;INDICATES BLOCK IS FREE
DFLAG CSTSYB		;INDICATES BLOCK USED BY SYSTEM
DFLAG CSTBEB		;THE BLOCK EXISTS BIT
CST:	.BLKW MNCBLK	;CORE STATUS TABLE
	0		;MAKE SURE THE TABLE HAS AN END
CSTPB:	.BLKW MNCBLK	;PB POINTERS FOR CORE USED BY PBS
FREECR:	0		;AMOUNT OF CORE THAT IS FREE
CST1FR:	CST+<FSTFRB*2>	;POINTER TO FIRST FREE CST ENTRY
CST1NS:	CST+<FSTFRB*2>	;POINTER TO FIRST NON-SYSTEM CST ENTRY
CSTTOP:	0		;POINTER TO LAST REAL WORD IN CST
USRCOR:	0		;AMOUNT OF CORE NOT USED BY SYSTEM
LOGJAM:	0		;TIMES WHEN THERE WAS NOT ENOUGH CONGIOUS SPACE
			;TO PUT SOME SIZE PAGE, BUT THERE WAS MORE THAN
			;6K ACTUALLY FREE
NOFIT:	0		;NUMBER OF TIMES A PAGE COULDN'T FIT IN CORE
			;WHEN THERE WAS ENOUGH FREE
HSECNT:	30.		;60THS TILL TIME TO INC HSECS
HSECS:	0		;TIME IN .5 SECS, FOR SWAP DESICIONS
LTPSTA:	0		;LAST TIME PROCESS STARTED (IN .5 SEC)
ACTCHK:	0		;FLAG TO INDICATE CHECKING FOR ACTIVATING PROSSES
ACORE:	0		;AMOUNT OF CORE POTENITIALLY NEEDED BY ACTIVE PROCESSES
PBSWPO:	.BLKW 20.	;PAGES WHICH MAY BE SWAPPED OUT
PBSWOE:	0		;DUMMY END ENTRY
NPBSWO:	0		;NUMBER OF PBS ON SWAP OUT LIST
KERSBT:	.BLKB 16.*3	;KERNAL, NON-EX AND SUPER
	.REPT 16.	;USER
	.BYTE 1		;SEGBRK LEGAL ON ALL PAGES
	.ENDR
.IRPC X,<012>
ITM'X'KB==KERSBT+<<ITM'X'AR-I0AR>/2>	;BYTE FOR A PARTICULAR PAGE
.ENDM
.SBTTL ASSEMBLE THE STUFF GENEATED BY THE REMOTE MACROS
LSTSTO	;STORAGE FOR THE LISTS
INITSL	;INIT TABLE FOR THE LISTS
0
;DISPLAY VARIABLES
;AND PARAMTERS
.IFNZ NTKDIS
DISMAL==2
DISBIG==4
TKDLEN:	WORDS <DISMAL,DISMAL,DISMAL,DISMAL,DISBIG>
.IIF NE .-TKDLEN-<2*NTKDIS>,.ERROR BAD TKDLEN TABLE LENGTH
TKDITM:	.BLKW 8.	;THE ITEMS FOR THE DISPLAYS
TKDOWN:	.BLKW 8.	;IF DISPLAY OWNED
TKDPDA:	0		;PDL ADDRESS
TKDPDL:	0		;THE ITEM FOR THE DISPLAY PDLS
TKRELS:	0		;THE RELOCATION REGISTER FOR THE DISPLAY
TKDRUN:	WORDS <-1,-1,-1,-1,-1,-1,-1,-1>	;THE RUN FLAGS
TKDPDP:	WORDS <40,130,220,310,400,470,560,650>	;PDL POINTERS FOR EACH DISPLAY
DPUSHJ==100000
DSTOP==140400
TKRUN==4000
TKGO==10000
TKSTOP==20000
.ENDC

.IFNZ NTVS
NFTVDS==NTKDIS		;THE FIRST TV IS THE ONE AFTER THE TK DISPLAYS

;THIS TABLE CONTAINS THE REFERENCE COUNTS FOR EACH OF THE TVS. THE BUFFER
;FOR A TV SHOULD BE RELEASED WHEN THE REFERENCE COUNT REACHES ZERO. THE
;REFERENCE COUNT CAN BE INCREMENTED FOR EACH TTY ITEM WHICH REFERS TO
;THIS TV AND FOR EACH DISPLAY CAPABILITY TO THE TV.
TVDSRF:
.REPT NTVS
.BYTE 0
.ENDR

;TVDSBF CONTAINS THE BUFFER NUMBER OF EACH TV. THIS NUMBER IS -1 WHEN
;THERE IS NO BUFFER ALLOCATED TO A PARTICULAR TV.
TVDSBF:
.REPT NTVS
.BYTE -1
.ENDR

;TVBUFF SHOWS WHICH BUFFERS HAVE BEEN ALLOCATED. IF THE VALUE IS -1,
;THEN THE BUFFER IS FREE.  OTHERWISE, IT CONTAINS THE NUMBER OF THE
;TV WHICH USES THIS BUFFER.
TVBUFF:
.REPT NTVCHN
.BYTE -1
.ENDR
.ENDC


;TV DISPLAY CURSOR (OR TURTLE) VARIABLES
;Y POSITIONS
TVDSCY:	.REPT NTVCHN
	.WORD 0
	.ENDR

	;X POSITIONS
TVDSCX:	.REPT NTVCHN
	.WORD 0
	.ENDR

;FONT TABLE CONTAINS THE ITEM OF EACH FONT
NFONTS==2		;INITIALLY, THERE CAN BE TWO FONTS
FNTITM:	.BLKW NFONTS
ACLRP:	ACLRB
ACLRB:	.BLKW 20
ACLRBE::
.INSRT STYI >
.SBTTL DISK INTERUPT LEVEL ROUTINES

;ALL DISK INTERUPTS COME HERE-ONLY ONE DISK CAN BE ACTIVE AT A TIME
;IN THIS SCHEME.
RKBRK:RFBRK:
DSKBRK:	JSR F,ACSAV	;COMPLETE THE SAVE OF THE CURRENT CONTEXT
	MOV P,DSKPSV	;SAVE A POINTER TO THE "FRAME"
	MOV DSKP,P	;POINT TO DISK CONTEXT FRAME
	MOV P,DSKPS	;SAVE FOR ERROR CHECKING
	JSR F,ACRES	;RESTORE DISK CONTEXT
	RTS PC		;AND CONTINUE IT

;THIS IS THE ROUTINE TO CALL TO RETURN TO NORMAL CONTEXT UNTIL NEXT INTERUPT

DFLUSH:	CMP DSKP,DSKPS	;CHECK THAT STACK DIDN'T OVERFLOW
	NBUGC NE
	JSR F,ACSAV	;SAVE THE DISK LEVEL CONTEXT
	MOV P,DSKP	;AND THE FRAME POINTER
	MOV DSKPSV,P	;PREPARE TO RESTORE REGULAR CONTEXT
	JSR F,ACRES	;RETORE REGISTERS
	RTT		;RETORE PS AND PC


;MAIN DISK SERVICE LOOP
;PICKS UP REQUESTS FROM THE DSKRQ LIST AND SERVICES THEM
;BY CALLING SERVICE ROUTINE FOR PROPER DISK

DSTART:	MOV DSKRQ,A	;GET FIRST NODE ON LIST
	BNE DSKRQP	;GOT ONE, GO PROCESS IT
	CLR @CURDSK	;NO REQUEST, CLEAR CS OF CURRENT DISK
	JSR PC,DFLUSH	;AND RETURN CONTROL
	BR DSTART	;GO TRY AGAIN

;REALLY PROCESS A REQUEST
DSKRQP:	MOV (A),DSKRQ	;TAKE THE BLOCK OFF THE LIST
	CLR (A)		;AND CLEAR ITS LINK POINTER
	MOV #MNRTY,NRETRY	;NUMBER OF TIMES TO TRY BEFORE YOU GIVE UP
DSKRQR:	MOVB DRQDNO(A),B	;GET THE DISK NUMBER
	MOVB DRQFUN(A),D	;AND THE FUNCTION
	JSR PC,@DSKRQS(B)	;RUN THE SERVICE ROUTINE
	BNE DSKRQD	;ERROR ON TRANSFER?
	DEC NRETRY	;HAVE WE EXHUASTED RETRY COUNT?
	BGE DSKRQR	;IF NOT, GO RETRY
	BIS #DRQFER,DRQHCA(A)	;SET THE TRANSFER ERROR BIT
DSKRQD:	MOV #DRQDL,B	;ADDRESS OF BEG OF THE DONE LIST
	JSR PC,BLISTE	;GET TO END OF LIST IN B
	MOV A,(B)	;PUT THIS ONE ON THE END OF THE LIST
	BIS #DMRPIR,PIRQ	;CAUSE A MIDDLE LEVEL INTERUPT
	BR DSTART	;AND TRY FOR ANOTHER

;SEARCH TO THE END OF THE LIST POINTED TO BY B
;LEAVE THE POINTER IN B POINTING TO THE LINK WORD
;OF THE NODE ON THE END OF THE LIST
BLISTE:	TST (B)		;IS THIS THE LAST NODE
	BEQ BLIST1	;YUP
	MOV (B),B	;GO TO NEXT NODE
	BR BLISTE
BLIST1:	RTS PC
;ENTER HERE TO WRITE-CHECK THE FUNCTION YOU JUST PERFORMED
RKDSKW:	MOV #DKWCH,D	;CHANGE FUNCTION TO WRITE CHECK

;THE DISK SERVICE ROUTINE FOR REGULAR TYPE RK11 DISKS
RKDSKS:	MOV #RKCS,CURDSK	;THE RK11 IS THE CURRENT DISK
	MOV #RKDA,C	;POINTER TO THE DISK REGISTERS
	CLR E		;FOR THE DIVIDE
	MOV DRQDA(A),F	;GET THE DISK ADDRESS
	ASL F		;CONVERT TO 256 WORD BLOCKS
	DIV #12.,E	;CONVERT TO CYLENDIR AND SECTOR ADDRESSES
	ASH #4,E	;PUT THE CYLENDER ADDRESS IN THE RIGHT PLACE
	BIS F,E		;AND THE SECTOR ADDRESS
	BIS DSKOFS(B),E	;THE DISK NUMBER TOO
	MOV E,(C)	;ALL THAT JUST FOR THE DISK ADDRESS
	MOV DRQCA(A),-(C)	;CORE ADDRESS IS SIMPLE
	MOV DRQWC(A),-(C)	;SO IS WORD COUNT
	MOV DRQHCA(A),E	;HIGH CORE ADDRESS IS HARDER
	ASH #4,E	;PUT IT IN THE RIGHT PLACE
	BIS RKFUN(D),E	;AND BIS IN THE FUNCTION
	MOV E,-(C)	;START UP THE DISK!
RKDSWT:	JSR PC,DFLUSH	;WAIT FOR TH ENEXT INTERUPT
	TSTB (C)	;IS THE DISK REALLY DONE?
	BGE RKDSWT	;NOPE, KEEP WAITING
	TST (C)		;WAS THERE AN ERROR?
	BLT RKDSKE	;BRANCH IF THERE WAS
	BIT #DSKWCH,D	;AM I SUPOSED TO WRITE CHECK THIS FUNCTION?
	BNE RKDSKW	;YUP, GO CALL YOURSELF
	CLZ		;FINISHED SUCESSFULLY
	RTS PC

;GOT AN ERROR ON THE RK11
RKDSKE:	INC DISKER(B)	;INC NUMBER OF ERRORS ON THIS DISK
	MOV #DERBL,C	;THE DISK ERROR RECORDING BLOCK
	MOV #RKDS,D	;THE REGISTERS OF THE RK11
	MOV #6,E	;ALL 6 OF THEM
	MOV (D)+,(C)+	;GET COPYIED
	SOB E,.-2
	MOV #17,RKCS	;RESET THE DRIVE
	MOV #1,RKCS	;AND THE CONTROL
	TSTB RKCS	;MAKE SURE ITS READY
	BGE .-4
	SEZ		;RETURN AN ERROR
	RTS PC
.SBTTL LOW LEVEL MAIN PROGRAM LEVEL DISK ROUTINES

;GET A LOW LEVEL DISK REQUEST BLOCK AND LEAVE IT'S INDEX IN C
GRQBLK:	MOV DSKRFL,C	;TRY TO GET A BLOCK
	NBUGC EQ		;MUST BE ONE THERE!
	MOV (C),DSKRFL	;LINK IT OUT OF LIST
	RTS PC

;PUT A LOW LEVEL DISK REQUEST BLOCK ONTO THE REQUEST LIST
;POINT TO REQUEST ARRIVES IN C
ADDRQ:	SAVE B		;RANDOM REG
	MOV #DSKRQ,B	;LIST OF REQUESTS
	JSR PC,BLISTE	;GET TO THE END OF THE LIST
	CLR (C)		;MAKE SURE NEW GUY DOESN'T POINT ANYWHERE
	MOV C,(B)	;CLOBBER NEW GUY ONTO END
	BIS #100,@CURDSK	;WAKE UP THE DISK IF IT NEEDS IT
	REST B
	RTS PC
.SBTTL MIDDLE LEVEL DISK ROUTINES
;REQUEST A MIDDLE LEVEL DISK TRANSFER AND WAIT FOR ITS COMPLETION
;ENTER WITHT THE POINTER TO THE PAGE BLOCK IN B
;AND THE FUNCTION IN E
DMRWT:	JSR PC,DMRBGT	;TRY TO PLACE THE REQUEST
	BNE DMRWT1	;IF SUCCESS, CONTINUE
	JSR PC,SFLUSH	;WAIT A SEC
	JSR PC,RUNME	;NOT LONG
	BR DMRWT	;AND TRY AGAIN
DMRWT1:	JSR PC,PBWAIT	;WAIT FOR THE TRANSFER TO BE DONE
	RTS PC		;AND RETURN


;REQUEST A MIDDLE LEVEL PAGE VALIDATION DISK TRANSFER
;ENTER WITH THE POINTER TO THE PAGE BLOCK IN B
;AND THE FUNTION IN E
DMRBGT:	SAVE A
	SPL 7		;TO PREVENT THE DISK ROUTINES FROM SCREWING US
	MOV DMRPNT,A	;TRY TO GET A DISK REQUEST BLOCK
	BNE DMRBG1	;GOT ONE
	REST A
	SPL 0
	SEZ		;FAILED
	RTS PC
DMRBG1:	MOV (A),DMRPNT	;TAKE IT OFF THE FREE LIST
	SPL 0		;OUT OF DANGER
	CLR (A)		;DON'T POINT LIKE THAT, IT'S IMPOLITE!
	BIS #PBDISK,PBFLAG(B)	;DISK TRANSFER PENDING FOR THIS PAGE
	MOV B,DMRPBP(A)	;THIS IS THE PAGE TO OPERATE ON
	MOV PRUNNG,DMRPWK(A)	;THE ITEM OF THE PROCESS TO WAKE UP
	SAVE B		;GET A REGISTER
	MOV ITM0A,B	;ASSUME THE CURRENT PROCESS IS IN ITEM0
	MOV PRSID1(B),DMRPW1(A)	;PROCESS ID WORD 1
	MOV PRSID2(B),DMRPW2(A)	;PROCESS ID WORD 2
	MOV E,DMRFUN(A)	;SET IN THE FUNCTION
	CLR DMRDRC(A)	;NO REQUESTS ENTERED FOR HIM YET
	CLR DMRPBB(A)	;AND NO BITS TO CLEAR
	MOV #DMRLST,B	;NOW FIND THE END OF THE REQUEST LIST
	JSR PC,BLISTE
	MOV A,(B)	;AND TACK THE REQUEST ON THERE
	REST <B,A>
	BIS #DMRPIR,PIRQ	;CAUSE A MIDDLE LEVEL INTERUPT
	CLZ		;INDICATE REQUEST PLACED
	RTS PC

;WAIT FOR A PAGE BLOCK TO NO LONGER HAVE A DISK REQUEST PENDING
;THE PAGE BLOCK INDEX IS IN B
PBWAIT:	JSR PC,SFLUSH	;HANG (ASSUMPTION IS WE WILL ALWAYS HAVE TO WAIT SOME)
	BIT #PBDISK,PBFLAG(B)	;DONE YET?
	BNE PBWAIT	;BR IF NOT
	JSR PC,RUNME
PBWAI1:	RTS PC

;WAIT FOR A PAGE TO BE HACKABLE
;I.E. PBDISK AND PBLOCK CLEAR
PBULWT:	BIT #PBDISK!PBLOCK,PBFLAG(B)	;IS IT UNLOCKED NOW?
	BEQ PBWAI1	;YES, JUST RETURN
PBULW1:	JSR PC,SFLUSH	;WAIT A LITTLE WHILE
	BIT #PBDISK!PBLOCK,PBFLAG(B)	;NOW?
	BNE PBULW1	;NOT YET
	JSR PC,RUNME	;MAYBE NOW
	BR PBULWT	;TRY AGAIN
;ROUTINE CALLED BY THE PIRQ ROUTINE
DMRBRK:	JSR F,ACSAV	;SAVE MAIN PROG ACS
DMRBR1:	BIC #DMRPIR,PIRQ	;PREVENT UNNESSARY INTERUPTS
	MOV DRQDL,A	;ANYHTING ON LIST OF DONE REQUESTS?
	BEQ DMRBR2	;NOPE
	MOV DSKRFL,F	;POINTER TO FREE BLOCKS
	MOV A,DSKRFL	;LIST BEING FREED IS NOW AT FRONT OF FREELIST
DMRBR3:	INC DRQFCN	;ONE MORE FREE ONE
	JSR PC,DRQDNE	;GO CLEAN UP FOR THIS REQUEST
	SPL 7		;I VANT TO BE ALONE
	TST (A)		;IS THERE ANOTHER DONE ONE?
	BEQ DMRBR4	;NOPE
	SPL DMRL	;BACK TO NORMAL
	MOV (A),A	;GET NEXT ONE
	BR DMRBR3	;AND PROCESS IT
DMRBR4:	MOV F,(A)	;TACK OLD FREE LIST ON END OF NEW
	CLR DRQDL	;ALL DONE ONES PROCESSED
	SPL DMRL	;AND GO BACK TO NORMAL
DMRBR2:	CMP #8.,DRQFCN	;ARE THERE AT LEAST 8 BLOCKS FREE?
	BGE DMRBR9	;EXIT TO WAIT FOR MORE BLOCKS FREE
	MOV DMRLST,A	;GET FIRST REQUEST
	BEQ DMRBR9	;NO REQUESTS
	MOV (A),DMRLST	;TAKE IT OFF THE LIST
	MOV DMRPBP(A),B	;GET POINTER TO PAGE BLOCK
	BIT DMRFUN(A),PBFLAG(B)	;IS WHAT WE WNAT ALREADY TRUE?
	BNE DMRBR8	;YUP, IGNORE THE REQUEST
	CLR F		;TO BUILD UP THE FUNCTION IN
	BIT #PBWCHK,PBFLAG(B)	;ARE WE SUPPOSED TO BE CAREFU WITH THIS PAGE?
	BEQ .+6		;NO, NO WRITE CHECK
	BIS #DSKWCH,F	;SET THE WRITE CHECK BIT
	BIT #PBVACR,DMRFUN(A)	;VALIDATE IN CORE?
	BNE DMRBVC	;YES, GO DO IT
	BIT #PBVACR,PBFLAG(B)	;IT BETTER BE VALID IN CORE!
	NBUGC EQ
	BIS #DSKWRT,F	;FUNCTION WILL BE A WRITE TO DISK
	BIS DMRFUN(A),PBFLAG(B)	;AND THIS INDICATES THAT THE TRUE WILL
				;EVENTUALLY BE THAT THE REQUEST HAS BEEN GRANTED
				;THUS IF THE PAGE IS MODIFIED IN CORE AFTER WE
				;START TO WRITE IT OUT, THE WRITE WILL HAVE BEEN
				;A NO-OP, WHICH IS THE RIGHT THING
	BIT #PBVASS,DMRFUN(A)	;WANT TO VALIDATE AT SWAP SPACE?
	BNE DMRBVW		;GO DO IT
	BIT #PBVAS,DMRFUN(A)	;VALIDATE AT SOURCE?
	BNE DMRBVS		;GO DO THAT
	BPT			;NO FUNCTION????
	
;COME HERE FOR A REQUEST THAT NEEDS NO ACTION
DMRBR8:	BIC #PBDISK,PBFLAG(B)	;DISK TRANSFER "DONE"
	JSR PC,ACTDMR		;ACTIVATE PROCESS THAT MADE THIS REQUEST (THE TURKEY)
	MOV DMRPNT,(A)		;PUT REQUEST
	MOV A,DMRPNT		;ONTO FREE LIST
	BR DMRBR2		;AND TRY TO FIND SOMEONE WHO IS MORE OF A WINNER

;COME HERE WHEN WE THINK WE'RE ALL DONE
DMRBR9:	BIT #DMRPIR,PIRQ	;IS SOMEONE TRING TO WAKE US UP?
	BNE DMRBR1		;SIGH GO FIND OUT WHAT HE WANTS
	JSR F,ACRES
	REST A
	RTT

;COME HERE TO TRY TO VALIDATE THE PAGE IN CORE
DMRBVC:	BIS #DSKREA,F		;WE WANT TO READ FROM THE DISK
	MOV #PBVACR,DMRPBB(A)	;WILL SET THE VALID IN CORE BIT WHEN DONE
	BIT #PBVASS,PBFLAG(B)	;IS IT VALID ON SWAP SPACE?
	BNE DMRBVW		;GO GET IT FROM SWAP SPACE
	BIT #PBVAS,PBFLAG(B)	;IS IT VALID AT SOURCE?
	BNE DMRBVS		;GO GET IT FROM SOURCE
	BPT			;NOT VALID ANYWHERE????

;COME HERE TO DO A TRANSFER TO OR FROM SWAP SPACE
;DEPENDING ON THE FUNCTION THAT IS IN F
DMRBVW:	BIT #PBSTS,PBFLAG(B)	;IS IT A SWAP TO SOURCE PAGE?
	BNE DMRBVS	;YUP
	JSR PC,GRQBLK	;GET A REQUEST BLOCK
	MOVB F,DRQFUN(C)	;STORE AWAY THE FUNCTION
	CLR E		;FOR THE ASHC
	MOV PBCAR(B),F	;THE CORE ADDRESS IN 512 WORD BLOCKS
	ASHC #10.,E	;MAKE INTO A BYTE ADDRESS
	MOVB E,DRQHCA(C)	;SET THE HIGH PART OF THE ADDRESS
	MOV F,DRQCA(C)	;SET THE LOW PART
	MOVB PBRAN(B),E	;GET DISK #
	BIC #PBDSKM,E	;CLEAR CRAP
	ASH #-PBDISS,E	;SHIFT INTO PLACE
	MOV E,DRQDNO(C)	;SET IN THE DISK NUMBER
	MOV PBDA(B),E	;GET THE STARTING DISK ADDRESS
	MOVB PBRAN(B),F	;NOW NEED THE START
	BIC #PBSTRT,F	;TO GET TO THE RIGHT PLACE IN THE SWAP SPACE
	ADD F,E		;THIS SHOULD BE IT
	MOV E,DRQDA(C)	;PUT IT INTO THE BLOCK
	MOVB PBLEN(B),E	;GET THE LENGTH
	INC E		;CONVERT 0 TO 1
	ASH #8.,E	;CONVERT TO WORDS
	NEG E		;WORD COUNT ONLY A DISK COULD LOVE
	MOV E,DRQWC(C)	;SO GIVE IT TO A DISK
	MOV A,DRQABL(C)	;ACTIVE ME ON YOUR COMPLETION
	INC DMRDRC(A)	;NUMBER OF REQUESTS MADE FOR THIS REQUEST
	JSR PC,ADDRQ	;MAKE THE REQUEST
	BR DMRBR2

;COME HERE TO READ OR WRITE SOURCE
;DEPENDING ON FUNCTION IN F
DMRBVS:	BIT #PBFILE,PBFLAG(B)	;BETTER BE A FILE PAGE
	NBUGC EQ
	SAVE F		;SAVE THE FUNCTION
	CLR E		;TO COMUTE CORE ADDRESS
	MOV PBCAR(B),F	;HAVE TO SHIFT IT
	ASHC #10.,E	;TO MAKE IT INTO BYTES
	SAVE <E,F>	;SAVE IT ON THE STACK
	MOV B,D		;COPY THE PB POINTER
	ADD #PBSDA,D	;POINT TO FIRST DISK ADDRESS
	MOVB PBRAN(B),E	;TO GET START
	BIC #PBSTRT,E	;CLEAR CRAP
	ASL E		;BITES
	ADD E,D		;BLOCK TO REALLY START WITH
	MOVB PBLEN(B),E	;NUMBER OF BLOCKS WE WANT
DRBVS3:	JSR PC,GRQBLK	;GET A BLOCK TO MAKE THE REQUEST WITH
	INC DMRDRC(A)	;NUBER OF REQUESTS FOR THIS REQUEST
	MOV A,DRQABL(C)	;ACTIVATE ME ON YOUR COMPELETION
	MOVB 4(P),DRQFUN(C)	;GET BACK THE FUNCTION
	MOVB 2(P),DRQHCA(C)	;THE HIGH CORE ADDRESS
	MOV (P),DRQCA(C)	;AND THE LOW CORE ADDRESS
	ADD #2000,(P)		;INC CORE ADDRESS
	ADC 2(P)		;TO NEXT BLOCK
	MOVB PBSDSK(B),DRQDNO(C)	;THE DISK #
	CLR DRQWC(C)	;NOW COMPUTE TRANSFER LENGTH
	MOV (D),DRQDA(C)	;GET STARTING DISK ADDRESS
DRBVS2:	MOV (D)+,F		;INTO F ALSO
	CMP #-1,F		;MAKE SURE NOT NON-EX BLOCK
	NBUGC EQ
	ADD #-1000,DRQWC(C)	;ONE MORE BLOCK
	DEC E			;ONE MORE BLOCK READY TO GO
	BLT DRBVS1		;THAT'S ALL WE WANT
	CMP F,(D)		;IS THE NEXT BLOCK RIGHT AFTER THIS ONE?
	BEQ DRBVS2		;YUP, GOBBLE IT ON THIS TRANSFER
	JSR PC,ADDRQ		;HAVE TO SPLIT TRANSFER
	BR DRBVS3		;GO TAKE ANOTHER CRACK AT IT
DRBVS1:	JSR PC,ADDRQ		;ADD THE LAST REQUEST
	ADD #6,P		;FLUSH CRAP FROM STACK
	JMP DMRBR2		;DONE WITH THIS ONE
;COME HERE TO CLEAN UP FOR EACH DISK REQUEST THAT FINISHES
;MUST CHECK IF ALL REQUESTS ARE DONE, AND FINISH THE GUY UP IF THEY ARE
;THE REQUEST BLOCK IS POINTED TO BY A
DRQDNE:	MOV DRQABL(A),B		;MIDDLE LEVEL BLOCK TO ACTIVATE
	MOV DMRPBP(B),C		;POINTER TO PAGE BLOCK
	BIT #DRQFER,DRQHCA(A)	;WAS THERE A HARD ERROR?
	BEQ DRQDN1		;NOPE
	BIS #PBERR,PBFLAG(B)	;FLAG ERROR FOR MAIN PROGRAM
	BPT			;UGH
DRQDN1:	DEC DMRDRC(B)		;ONE LESS REQUEST PENDING
	BNE DRQDN2		;BUT MORE STILL THERE
	SAVE A			;THIS GUY IS ALL DONE, FINISH HIM OFF
	MOV B,A			;ACTDMR EXPECTS ARG IN A
	JSR PC,ACTDMR		;THIS GUY IS A WINNER, RUN HIM QUICK
	REST A
	BIS DMRPBB(B),PBFLAG(C)	;SET ANY BITS YOU NEED TO
	BIC #PBDISK,PBFLAG(C)	;AND INDICATE DISK OP IS DONE
	MOV DMRPNT,(B)		;PUT THE FREE LIST
	MOV B,DMRPNT		;BACK TOGETHER
DRQDN2:	RTS PC

ACTDMR:	JSR F,ACSAV		;GROSS OUT
	MOV DMRPW1(A),B		;ID WORD 1
	MOV DMRPW2(A),C		;ID WORD 2
	MOV DMRPWK(A),A		;PROCESS ITEM
	JSR PC,PRSWAK		;GO PUT IT ON THE WAKEUP LIST
	JSR F,ACRES
	RTS PC
.SBTTL MAIN PROGRAM LEVEL PAGE VALIDATION ROUTINES

;VALIDATE THE PAGE WHOSE PB IS IN B IN CORE
;THE ASSUMPTION IS THAT THE PAGE IS EITHER PBZERO OR
;IS VALID ON SWAP OR SOURCE
;ALSO, THE PAGE MUST HAV ECORE ASSIGNED TO IT
VALCOR:	JSR F,ACSAV	;SO WE DON'T HAVE TO WORRY
	BIT #PBVACR!PBDISK,PBFLAG(B)	;IS SOMETHING FISHY?
	NBUGC NE
	BIT #PBZERO,PBFLAG(B)	;SHOULD IT BE ZEROED?
	BEQ VALCO3	;NOPE, GO SWAP IT IN INSTEAD
	BIC #PBZERO,PBFLAG(B)	;WE GO THIS WAY BUT ONCE....
				;NOW WE PROCEED TO PLAY WITH ITEM2
				;IN A FUNNY WAY TO CLEAR THE PAGE
	MOV #-1,A	;FIRST WE DO A FAKE PUSH
	JSR PC,ITM2PL
	MOV PBCAR(B),A	;GET THE REAL CORE ADDRESS
	NBUGC EQ	;WHICH BETTER BE NON-ZERO
	ASH #4,A	;MAKE IT IN 32 WORD BLOCKS
	MOV #ITM2AD,C	;POINT TO ITEM2
	MOVB PBLEN(B),D	;GET THE LENGTH
	INC D		;0=>1
	ASH #9.,D	;CONVERT TO WORDS
	SPL 7		;PREVENT INT LEVEL FROM GETTIGN CONFUSED
	MOV A,ITM2AR	;POINT TO PAGE
	MOV #77406,ITM2DR	;MAXIMAL LENGTH PAGE
	CLR (C)+	;CLEAR A WORD
	SOB D,.-2
	SPL 0		;INTS OK NOW
	JSR PC,ITM2PO
	BIS #PBVACR,PBFLAG(B)	;NOW VALID IN CORE
	BIC #PBVAS!PBVASS,PBFLAG(B)	;NOT VALID ON SOURCE OR SWAP SPACE
VALCO1:	JSR F,ACRES
	RTS PC

VALCO5:	JSR PC,RUNME	;TRY AGAIN FOR BLOCK

;COME HERE TO TRY TO ENTER REQUEST TO VALIDATE PAGE IN CORE
VALCO3:	MOV PBFLAG(B),F	;SAVE FOR THE LOCK FLAG
	MOV #PBVACR,E	;REQUEST TO VALIDATE IN CORE
	JSR PC,DMRBGT	;TRY TO ENTER REQUEST
	BNE VALCO2	;BR IF YOU WON
VALCO4:	JSR PC,SFLUSH	;WAIT....
	BIT #PBLOCK,F	;IF IT WAS LOCKED WHEN I STARTED
	BNE VALCO5	;THEN IT DAMN WELL BETTER BE ME WHO HAS IT LOCKED!
	BIT #PBLOCK!PBVACR,PBFLAG(B)	;SOMEONE ELSE BRINGING IT IN?
	BEQ VALCO5
	BIT #PBLOCK!PBDISK,PBFLAG(B)	;WAIT FOR IT TO SETTLE DOWN?
	BNE VALCO4
	JSR PC,RUNME	;SOMEONE ELSE WAS KIND ENOUGH TO BRING IT IN
	BR VALCO1	;I CAN RETURN
VALCO2:	JSR PC,PBWAIT	;WAIT FOR THE DISK TO WIN
	BR VALCO1	;DONE!
;VALIDATE PAGE ON SWAP SPACE
;THE PAGE MUST BE VALID IN CORE WHEN THE ROUTINE IS ENTERED
;A PB POINTER TO THE PAGE IS IN B
VALSWP:	BIT #PBSTS,PBFLAG(B)	;IS IT A SWAP TO SOURCE PAGE?
	BNE PBVLSR	;YES, VALIDATE AT SOURCE INSTEAD
	JSR F,ACSAV	;BETTER SAFE THAN...
VALSW5:	BIT #PBVASS,PBFLAG(B)	;IS PAGE ALREADY VALID ON SWAP SPACE?
	BNE VALCO1	;RETURN IF ALREADY VALID
	BIT #PBVACR,PBFLAG(A)	;IT BETTER BE VALID IN CORE!
	NBUGC EQ

;COME HERE TO ENTER THE REQUEST TO VALIDATE THE PAGE ON SWAP SPACE
VALSW1:	MOV PBFLAG(B),F	;SAVE THE LOCKED FLAG
	MOV #PBVASS,E	;REQUEST VALIDATION OF PAGE ON SWAP SPACE
	BIT #PBFILE,PBFLAG(B)	;IS THIS A FILE PAGE?
	BNE .+6		;YES
	BIS #PBVAS,E	;SWAP SPACE IS SOURCE
	JSR PC,DMRBGT	;GO TRY TO REQUEST IT
	BNE VALCO1	;BRANCH IF YOU WIN, WE'RE DONE
VALSW2:	JSR PC,SFLUSH	;WAIT FOR CONDITIONS TO IMPROVE
	BIT #PBLOCK,F	;HAVE I GOT THE PAGE LOCKED?
	BNE VALSW4	;BR IF I'VE GOT IT
	BIT #PBLOCK,PBFLAG(B)	;SOMEONE ELSE GOT IT LOCKED?
	BNE VALSW2	;BR TO WAIT FOR UNLOCKED
VALSW4:	JSR PC,RUNME	;TRY AGAIN
	BR VALSW5

;VALIDATE A PAGE BLOCK ON SOURCE
PBVLSR:	JSR F,ACSAV	;SAVE THE RESGISTERS
	BR VALS5	;JUMP IN AFTER GIP CONVERT


;VALIDATE PAGE AT SOURCE
;THE PAGE MUST BE VALID IN CORE WHEN ROUTINE IS ENTERED
;A GIP TO TH PAGE IS IN B
VALSRC:	JSR F,ACSAV	;BETTER SAFE THAN...
	JSR PC,GIPPB	;CONVERT GIP TO PB
VALS5:	BIT #PBVAS,PBFLAG(B)	;IS PAGE ALREADY VALID ON SOURCE
	BNE VALCO1	;RETURN IF ALREADY VALID
	BIT #PBVACR,PBFLAG(A)	;IT BETTER BE VALID IN CORE!
	NBUGC EQ

;COME HERE TO ENTER THE REQUEST TO VALIDATE THE PAGE ON SAP SPACE
VALS1:	MOV PBFLAG(B),F	;SAVE THE LOCKED FLAG
	MOV #PBVAS,E	;REQUEST VALIDATION OF PAGE ON SAP SPACE
	JSR PC,DMRBGT	;GO TRY TO REQUEST IT
	BNE VALCO1	;BRANCH IF YOU WIN, WE'RE DONE
VALS2:	JSR PC,SFLUSH	;WAIT FOR CONDITIONS TO IMPROVE
	BIT #PBLOCK,F	;HAVE I GOT THE PAGE LOCKED?
	BNE VALS4	;BR IF I'VE GOT IT
	BIT #PBLOCK,PBFLAG(B)	;SOMEONE ELSE GOT IT LOCKED?
	BNE VALS2	;BR TO WAIT FOR UNLOCKED
VALS4:	JSR PC,RUNME	;TRY AGAIN
	BR VALS5
.SBTTL SWAP SPACE ALLOCATE/DEALLOCATE ROUTINES
;FIND SWAP SPACE FOR THE PB IN B
;AND CLOBBER THE PB TO REFLECT IT
FINSWP:	JSR F,ACSAV
	MOV B,F		;SAVE AWAY THE PB POINTER SO IT IS EASY TO GET LATER
	CLR C		;INDEX TO BIT TABLE POINTERS
FINSW1:	MOV SWPBPT+2(C),B	;HAVE WE EXHAUSTED SPACE TO SEARCH?
	BEQ FINSW8	;YUP, YOU LOSE
	MOV SWPBPT(C),A	;POINT TO BEG OF THIS TABLE	
	TST (C)+	;GO TO THE NEXT ONE
	TST SWPFCN-2(C)	;ARE THERE ANY FREE ONES?
	BEQ FINSW1	;NO, TRY FOR THE NEXT ONE
	JSR PC,FINBIT	;TRY TO FIND A FREE BIT
	BEQ FINSW1	;LOSEY LOSEY
	DEC SWPFCN-2(C)	;ONE LESS FREE ONE
	ASH #3,B	;FROM 4K => 512
	ADD SWPBDA-2(C),B	;GET THE REAL DISK ADDRESS
	MOV B,PBDA(F)	;SET IN THE DISK ADDRESS	
	BIC #PBVASS!PBSTS,PBFLAG(F)	;SHOULD NOT BE SWAPPED TO SOURCE, NOT VALID AT SWAP SPACE
	MOV SWPBDK-2(C),D	;GET THE DISK
	ASH #PBDISS,D	;PUT IT IN THE RIGHT PLACE
	BISB D,PBRAN(F)	;SET IT IN
	JSR F,ACRES
	CLZ
	RTS PC

FINSW8:	JSR F,ACRES
	SEZ
	RTS PC

;FIND A FREE BIT IN A RANDOM BT TABLE AND SET IT
;CALL WITH START OF TABLE IN A, END IN B
;SEZ IF CAN'T FIND ONE
;IF YOU WIN, A GETS THE POINTER TO TH WORD AND B GETS THE BIT NUMBER
FINBIT:	SAVE <C,A>
FINBI1:	CMP A,B		;OFF THE END OF THE TABLE
	BHIS FINBI7	;YUP, NO BITS FOR YOU
	CMP #-1,(A)+	;ANY FREE BITS IN THIS WORD?
	BEQ FINBI1	;NOPE, TRY THE NEXT
	CLR B		;CLEAR A COUNTER
	MOV -(A),C	;GET THE WORD IN QUESTION
FINBI2:	ROR C		;GET THE LOW ORDER BIT
	BCC FINBI3	;IF CARRY IS CLEAR, THATS THE ONE WE WANT
	SOB B,FINBI2	;CHUCKLE
;WE NEVER (I HOPE) FALL THROUGH THE SOB
FINBI3:	NEG B		;MAY HAVE SAVED SOME CYCLES WITH THIS TRICK
	ASL B		;GET A WORD INDEX
	BIS BITS(B),(A)	;SET THE RIGHT BIT
	ASR B		;ADJUST BACK
	SUB (P),A	;OFFSET FROM START OF TABLE
	ASH #4,A	;MULITPLIED BY 16
	ADD A,B		;GIVES BIT NUMBER IN TABLE
	REST <A,C>
	CLZ		;WIN
	RTS PC

FINBI7:	REST <A,C>
	SEZ		;LOSE
	RTS PC

;FREE THE SWAP AREA USED BY THE PB IN B
PBSFRE:	BIT #PBSTS,PBFLAG(B)	;DOES IT HAVE SWAP SPACE?
	BNE PBSFR3	;NO SPACE, DON'T FREE IT!
	JSR F,ACSAV
	CLR C		;POINTER TO THE BIT TABLE TABLES
	MOVB PBRAN(B),A	;GET THE DISK NUMBER
	BIC #PBDSKM,A	;MASK THE DISK # OFF
	ASH #-PBDISS,A	;SHIFT IT TO A REASNABLE SPOT
	MOV PBDA(B),E	;MAKE THE DISK ADDRESS EASY TO GET AT
PBSFR1:	CMP A,SWPBDK(C)	;IS IT MAYBE IN THIS BIT TABLE?
	BNE PBSFR2	;NOPE
	CMP E,SWPBDA(C)	;IS IT AFTER THE START	
	BLO PBSFR2	;NOPE (???)
	CMP E,SWPEDA(C)	;BUT BEFORE THE END
	BHIS PBSFR2	;NO
	SUB SWPBDA(C),E	;MAKE IT RELATIVE TO THIS TABLE
	MOV E,F		;NOW HAVE 2 COPIES
	ASH #-6,E	;GET THE WORD NUMBER
	BIC #160001,E	;EXTRA CRAP
	ASH #-2,F		;THE BIT NUMBER
	BIC #177741,F	;LIKEWISE
	ADD SWPBPT(C),E	;POINT
	BIC BITS(F),(E)	;CLEAR THE RIGHT BIT
	INC SWPFCN(C)	;ONE MORE FREE
	CLR PBDA(B)	;MAKE SURE HE DOESN'T USE IT AGAIN!
	JSR F,ACRES
PBSFR3:	RTS PC

PBSFR2:	TST (C)+	;GO TO THE NEXT BIT TABLE
	TST SWPBPT+2(C)	;MAKE SURE IT ISN'T NON-EX
	BNE PBSFR1	;WIN
	BPT		;LOSE

;ALLOCATE SWAP SPACE
;THIS CALL MAY ONLY BE EXECUTED BY THE SYSSPR
;THE 3 ARGS ON THE STACK ARE THE SIZE OF THESWAP SPACE
;IN BLOCKS, THE BLOCK ADDRESS OF THE START OF SWAP SPACE
;AND THE DISK NUMBER THAT THIS SWAP SPACE IS ON
;THE CALL IS EXECUTED ONCE FOR EACH SWAP SPACE TO BE ALLOCATED
EALLOC:	CMP CURSPH,SYSSPR	;IS THIS THE SYSSPR
	ERRORC NE,SYS
	JSR PC,RETNSW	;GET THE DISK NUMBER
	MOV A,E		;STORE IT AWAY
	JSR PC,RETNSW	;GET THE NUMBER OF BLOCKS
	MOV A,F		;AND SAVE IT
	ASH #-3,F	;CONVERT TO 4K BLOCKS
	JSR PC,RETNSW	;FINNALLY, GET THE START
	MOV #NSWPA,D	;NUMBER OF SWAP SPACES POSSIBLE
	CLR C		;POINTER INTO SWAP SPACE TABLES
EALLO1:	TST SWPBPT+2(C)	;IS THIS SPACE FREE?
			;IF IT IS, NEXT SPACE BEGGINING=0
	BEQ EALLO3	;FOUND A FREE SPACE
	TST (C)+	;TRY THE NEXT
	SOB D,EALLO1	;UNLESS WE RUN OUT
	ERROR BAD	;SYSSPR WAS BAD, SLAP ITS WRIST
EALLO3:	MOV E,SWPBDK(C)	;SAVE THE DISK NUMBER
	MOV F,SWPFCN(C)	;SAVE COUNT OF FREE SWAP SPACES
	MOV A,SWPBDA(C)	;AND SAVE THAT AS THE START
	MOV SWPBPT(C),D	;GET THE POINTER TO THIS BIT TABLE
EALLO4:	CLR (D)+	;16 FREE BITS
	SUB #20,F	;ALLOCATE 16 SWAP SPACES
	BGT EALLO4	;MORE
	BEQ EALLO6	;A FULL WORD OF BITS
	MOV #100000,E	;GET A BIT
	INC F		;CAUSE ONE BIT IS ALREADY SET
	ASH F,E		;SET THE BITS IN THE HIGH PART OF THE WORD
	BIS E,-(D)	;PUT THEM IN THE WORD WE JUST CLEARED
EALLO6:	TST (D)+	;GO TO THE FIRST FREE WORD
	CMP D,#SWPBTE	;HIGHER THAN THE END OF THE TABLE?
	NBUGC HIS
	MOV D,SWPBPT+2(C)	;SET THE START OF THE NEXT TABL
	JMP ERETCZ	;WIN
.SBTTL SWAP IN/OUT AND ITEM SPACE ALLOCATE
;SWAP OUT PAGE WHOSE PB IS IN B
SWPPAG:	JSR PC,PCLCHK	;CHECK IF I SHOULD PCLOSER MYSELF
	SAVE B
	MOV PBGIP(B),B	;CONVERT PB TO GIP
	JSR PC,PAGPCL	;PCLOSER EVERYONE WHO MIGHT DEPEND ON THIS PAGE
	REST B		;GET BACK PB
	JSR PC,PCLCLR	;I DON'T WANT TO BE PCLOSERED!
SWPPA3:	BIT #PBLOCK!PBDISK,PBFLAG(B)	;SHOULDN'T BE DISKING OR LOCKED
	BEQ SWPPA1	;NOT, GO SWAP IT OUT
SWPPA2:	JSR PC,SFLUSH	;WE'LL HAVE TO WAIT FOR IT TO SETTLE DOWN
	BIT #PBLOCK!PBDISK,PBFLAG(B)	;HAPPY?
	BNE SWPPA2	;NO, WAIT SOME MORE
	JSR PC,RUNME	;LOOKS HAPPY
	BR SWPPA3
SWPPA1:	JSR PC,PBLCK	;NOW I LOCK IT!
	JSR PC,VALSWP	;VALIDATE ON SWAP SPACE
	JSR PC,LSWPOP	;POP SWITCH, UNLOCKING BLOCK
	JSR PC,PBCFRE	;FREE THE CORE IT TOOK
	RTS PC


;GET CORE TO EXPAND ITEM SPACE
;CALL WITH DESIRED AMOUNT OF COORE IN A
ITMSEX:	JSR F,ACSAV
	INC A		;0=1
ITMSE1:	MOV CST1NS,C	;POINT TO FIRST NON-SYSTEM BLOCK
ITMSE6:	MOV A,D		;COPY FOR SOB
	MOV C,E		;COPY START OF SPACE BEING GOBBLED
ITMSE2:	BIT #CSTFRB,(C)+	;IS THIS BLOCK FREE?
	BEQ ITMSE4	;NOPE, HAVE TO FREE IT
	SOB D,ITMSE2	;CHECK ALL THE BLOCKS WE WANT TO GOBBLE
	SUB A,FREECR	;THAT MUCH LESS FREE CORE TOO
	SUB A,USRCOR	;THIS MUCH WILL BE STOLEN FROM USERS
	NBUGC LE	;SYSTEM HAS ZERO OR NEGATIVE CORE FOR USERS!
	MOV E,C		;POINT TO START AGAIN, THEY ARE ALL FREEE
	SUB #CST,E	;CONVERT
	ASR E		;TO BLOCK NUMBER
	MOV E,2(P)	;RETURN THE START IN B FOR THE USER
ITMSE3:	BIT #CSTFRB,(C)	;IS IT REALLY FREE?
	NBUGC EQ
	BIS #CSTSYB,(C)	;USED BY SYSTEM
	BIC #CSTFRB,(C)+	;AND NO LONGER FREE
	CMP C,CST1FR	;IS THIS THE FIRST FREE BLOCK?
	BNE .+10
	ADD #2,CST1FR	;NOT ANY MORE
	SOB A,ITMSE3	;FOR ALL THE BLOCKS
	JSR F,ACRES
	RTS PC
ITMSE4:	TST -(C)	;BACK TO BLOCK THAT ISN'T FREE
	BIT #CSTSYB,(C)	;IS THIS BLOCK ALREADY USED BY THE SYSTEM?
	BNE ITMSE5	;YES, WE'LL IGNORE IT
	MOV CSTPB-CST(C),B	;WHO IS THAT, ANYWAY
	JSR PC,SWPPAG	;OUT WITH HIM!
	BR ITMSE1	;GO TRY IT ALL AGAIN
ITMSE5:	TST (C)+	;GO HIGHER
	CMP C,CSTTOP	;OFF THE TOP?
	NBUGC HIS	;UGH RAN OFF TOP
	BR ITMSE6	;TRY AGAIN

.SBTTL SEGMENT BREAK ROUTINES
SEGBRK:	MOV SSR0,PSSR0	;COPY INTO PSEUDO SEGMENT REGISTERS
	MOV SSR1,PSSR1
	MOV SSR2,PSSR2
	BIC #174000,SSR0	;RESUME MONITORING
	MOV PSSR2,(P)	;GET THE PC WHERE THE INSTRUCTION STARTED
	BIT #200,PSSR0	;DID THE INSTRUCTION COMPLETE?
	NBUGC NE	;STRANGE, I DON'T THINK THIS SHOULD HAPPEN
	BIT #140000,2(P)	;WAS IT FROM KERNAL MODE?
	BEQ SEGKR	;YES, GO PROCESS IT LIKE A SUBROUTINE CALL
	MOV PC,USRMOD	;FROM USER MODE, TREAT LIKE A SSYTEM CAL
	JSR F,SPCPSP	;SAVE THE PS, PC AND P POINTER OF TH EUSER
	JSR PC,PACSAV	;AND HIS ACS
	MOV ITM0A,A	;POINT TO THE PROCESS BLOCK
	ADD #PUREGS,A	;POINT TO SAVED REGISTERS
	JSR PC,ACFIX	;FIX UP THE USERS REGISTERS
	JSR PC,PAGIN	;SWAP IN THE PAGE
	MOV ITM0A,B	;POINT TO THE PROCESS
	JSR PC,PACRES	;RESTORE USERS REGISTERS
	SAVE PUP(B)	;GET USERS P POINTER
	MTPI P		;RESTORE IT
	SAVE <PUPS(B),PUPC(B)>	;TO RETURN TO USER MODE
	JMP EMTRE3	;FINISH THE RETURN TO USER MODE

SEGKR:	CLR -(P)	;SAVE A 0 VALUE FOR P
	JSR F,ACSAV	;SAVE THE REST OF THE KERNAL REGISTERS
	MOV PSSR0,A	;GET SEGMENTER STATUS
	ASR A		;SHIFT
	BIC #177700,A	;GET THE PAGE NUMBER THAT WE FAULTED ON
	TSTB KERSBT(A)	;IS IT OK TO FAULT ON THIS PAGE FROM KERNAL?
	NBUGC EQ	;NO, UGH
	BGT SEGKR1	;YES, IT IS A USER PAGE
	BIT #SEGNRA,PSSR0	;THE ONLY LEGAL KERNAL PAGE TRAP
	NBUGC EQ	;IS NON-RESIDENT
SEGKR1:	MOV P,A		;A POINTER TO THE KERNAL REGISTERS
	JSR PC,ACFIX	;FIX THEM UP
	JSR F,ACRES	;GET BACK THE FIXED UP ACS
	TST (P)		;DOES KERNAL P NEED FIXING?
	NBUGC LT	;CAN'T WIN IF NEED TO ADD TO IT
	ADD (P),P	;CORRECT THE P STACK (REMOVE THINGS PUSHED)
	TST (P)+	;AND FLUSH THE DUMMY P VALUE
	JSR F,ACSAV	;SAVE THE CORRECTED ACS ON THE CORRECTED STACK	
	JSR PC,PAGIN	;TRY TO SWAP IN THE PAGE
	JSR F,ACRES	;RESTORE THE KERNAL REGISTERS
	RTT		;RETURN FROM THIS "SUBROUTINE"
;FIX UP THE REGISTER SET POINTED TO BY A
ACFIX:	MOV #2,F	;DO IT TWICE
	MOV PSSR1,E	;GET THE CORRECTION VALUES
ACFIX1:	MOVB E,B	;GET ONE OF THEM
	BEQ ACFIX3	;ZERO, ALL DONE
	BIC #177770,B	;WHCIH REGISTER?
	CMP #7,B	;NEVER FIX UP THE PC
	BEQ ACFIX2	;SSR2 TAKES CARE OF THAT
	ASL B		;WORD INDEX
	MOVB E,C	;GET THE AMOUNT(SIGN EXTENDED)
	ASH #-3,C	;THEN FLUSH THE REGISTER # AND SIGN EXTEND MORE
	ADD A,B		;POINT TO THE STORED REGISTER VALUE
	SUB C,(B)	;CORRECT IT
ACFIX2:	SWAB E		;FOR THE SECOND ONE
	SOB F,ACFIX1	;DO IT AGAIN
ACFIX3:	RTS PC

;SWAP IN THE PAGE THAT WE FAULTED ON, OR GIVE THE USER AN ERROR
;IF THE FAULT WAS NOT NON-RESIDENT OR THE PAGE IS NON-EX
PAGIN:	MOV PSSR0,A	;GET STATUS
	BIT #SEGNRA,A	;NON-RESIDENT?
	BEQ PAGERR	;NO, ERROR ON THE PART OF THE USER
	ASR A		;CONVERT TO PAGE NUM
	BIT #60,A	;IS IT A KERNAL PAGE?
	BEQ PAGIN1	;YES, BETTER BE ITEM2
	BIC #177760,A	;GET PAGE NUMBER
	MOV A,B		;COPY IT
	MUL #UPTLEN,B	;MAKE A POINTER
	ADD ITM1A,B	;INTO THE SPHERE'S
	ADD #SUPTS,B	;UPTS
	TST (B)		;DOES THE PAGE EXIST?
	BEQ PAGACV	;NXM ERRROR
	MOV UPTPBP(B),B	;GET THE PB TO SWAP IN
	JSR PC,SAVAWB	;SAVE THE W BITS
	JSR PC,PBSWPI	;GO DO IT
	JMP MAPRES	;RESTORE THE MAP WITH THE NEW PAGE

PAGIN1:	BIC #177700,A	;CLEAR CRAP
	CMP #<<ITM2AR-I0AR>/2>,A	;IS IT ITEM2?
	NBUGC NE
	MOV ITEM2,B	;GET THE ITEM
	JSR PC,SWPIN	;SWAP IT IN
	MOV ITEM2,A	;NOW
	JMP ITM2LD	;RELOAD IT

PAGERR:	MOV ITM0A,A	;THE PROCESS
	ROL A		;TST SOME BITS
	ROL A		;CHECK THE SLE BIT
	BCS PAGSLE	;ITS SET
	ROL A		;CHECK THE WRITE VIOLATION BIT
	BCS PAGRDO	;READ ONLY PAGE
	ROL A		;CHECK THE TRAP MEM-MANAGEMENT
	NBUGC CC		;IF IT ISN'T THIS DONT KNOW WHAT IS GOING ON

PAGSLE:	MOV #100000+.SLETF,PFAULT(A)	;SEGMENT LENGTH ERROR
SEGFLT:	CMP (P)+,(P)+	;POP OFF SSR0,SSR1, AND RETURN ADDRESS
	JMP CFAULT	;HE LOSES
PAGRDO:	MOV #100000+.RDOTF,PFAULT(A)	;READ ONLY FAULT
	BR SEGFLT	;FAULT HIM
PAGACV:	MOV #100000+.NXMTF,PFAULT(A)	;NON EXISTANT MEMORY FAULT
	BR SEGFLT
;SWAP IN THE PAGE POINTED TO BY THE GIP IN B
SWPIN:	JSR F,ACSAV
	JSR PC,UPTPLD	;GET THE UPT FOR THE PAGE
	MOV UPTPBP(B),B	;GET THE POINTER TO THE PAGE BLOCK
	JSR PC,ITM2PO	;PUSHED BY UPTPLD
	JSR PC,PBSWPI	;SWAP IN THE PAGE
	JSR F,ACRES
	RTS PC

;SWPA IN THE PAGE REPRESENTED BY THE PB IN B
;THIS ROUTINE TAKES CARE OF MAKING SPACE IN CORE BY SWAPPING
;OUT PAGES AND/OR DEACTIVATING OTHER USERS AS NEEDED
PBSWPI:	BIT #PBVACR,PBFLAG(B)	;IS IT ALREADY IN CORE?
	BNE PBSWP1		;YES, NOTHING TO DO
	JSR PC,FINPAG		;TRY TO FIND A PLACE TO PUT IT
	BEQ PBSWP2		;UGH, HAVE TO WORK FOR OUR CORE
	JSR PC,VALCOR		;SWAP IT IN	
	BR PBSWPI		;AND WE SHOULD BE ALL SET
PBSWP1:	RTS PC
PBSWP2:	JSR PC,CRFREE		;GO OFF TO FREE SOME CORE
	BR PBSWPI		;AND TRY AGAIN
.SBTTL SWAP SCHEDULING ROUTINES
;THE PROCESS IN ITEM0 IS ABOUT TO BE MOVED TO THE QUQUE IN B
;IF THE PAGES THE PROCESS USES SHOULD BE ACTIVIATED OR DEACTIVATED
;THIS ROUTINE WILL DO IT
PRSAOD:	JSR F,ACSAV	;GORSS
	MOV ITM0A,A	;POINT TO PROCESS
	BIT #WINQB!ACTQB!DORQB,PQBIT(A)	;ARE THE PAGES ACTIVE NOW?
	BEQ PRSAC1	;NO, GO SEE IF WE SHOULD ACTIVATE
	BIT #WINQB!ACTQB!DORQB,QBIT(B)	;ARE WE GOING TO AN ACTIVE QUQE?
	BNE PRSAO1	;YES, DO NOTHING
	MOV #PBDACT,F	;MUST DEATIVATE PAGES
	BR PRSAO2	;GO DO IT

PRSAC1:	BIT #RUNQB!IACTQB!STOPQB,QBIT(B)	;ARE WE GOING TO AN INACTIVE QUQE?
	BNE PRSAO1	;YES, DO NOTHING
	MOV #PBACT,F	;NO, ACTIVATE THE PAGES
PRSAO2:	MOV PPRTPT(A),B	;GET POINTER TO PROCESS TABLE ENTRY
	MOV HSECS,PRTTIM(B)	;TIME THAT THIS PROCESS WENT ONTO THIS QUQUE
	MOV PSPHRP(A),A	;GET THE SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	ADD #SUPTS,A	;POINT TO THE UPTS
	MOV #16.,D	;PROCESS ALL 16 OF THEM
PRSAO3:	TST (A)		;DOES IT EXIST?
	BEQ PRSAO4	;NO, IGNORE IT
	BIT #UPTABS,(A)	;IS IT AN ABSOLUTE PAGE?
	BNE PRSAO4	;YES, LEAVE IT ALONE
	MOV UPTPBP(A),B	;GET ITS PAGE BLOCK
	NBUGC EQ	;BETTER BE ONE!
	JSR PC,(F)	;CALL APPROPRIATE ROUTINE
PRSAO4:	ADD #UPTLEN,A	;NEXT
	SOB D,PRSAO3
	JSR PC,ITM1PO
PRSAO1:	JSR F,ACRES
	RTS PC

PBDACT:	DEC PBAUSR(B)	;ONE LESS ACTIVE PROCESS USING THIS PAGE
	NBUGC LT
	BNE PBDAC2	;ALREADY NON-ZERO
	SAVE A
	MOVB PBLEN(B),A	;GET THE LENTGH OF THE PAGE BEING DEATIVATED
	SUB A,ACORE	;THAT MUCH LESS ACTIVE CORE
	BIT #PBVACR,PBFLAG(B)	;IS IT VALID IN CORE?
	BEQ PBDAC3	;NO, DON'T PUT ON SWAP OUT LIST
	MOV #PBSWPO,A	;SIMPLE LINEAR SWAP OUT LIST
	TST (A)+	;LOOK FOR A FREE ENTRY
	BNE .-2
	CMP #PBSWOE,A	;DID WE GET TOT THE END?
	NBUGC EQ	;OOPS, TRYING TO PUT TOO MANY PAGES ON SWAP OUT LIST
	MOV B,-(A)	;PUT IT ON THE LIST
	INC NPBSWO	;ONE MORE PAGE TO BE SWAPPED OUT
PBDAC3:	REST A
	RTS PC
PBDAC2:
;ACTIVATE PAGE POINTED TO BY B
PBACT:	TST PBAUSR(B)	;IS IT ALREADY ACTIVE?
	BNE PBACT1	;YUP, NOTHING TO DO
	SAVE <A,C>
	MOVB PBLEN(B),A	;LENGTH OF PAGE BEING ACTIVATED
	ADD A,ACORE	;MORE ACTIVE CORE
	MOV #PBSWPO,A	;IS IT ON SWAP OUT LIST?
PBACT2:	CMP B,(A)+	;THIS ONE?
	BEQ PBACT3	;YUP, SAVE HIM
	CMP #PBSWOE,A	;AT END OF LIST?
	BNE PBACT2	;NOT YET
PBACT4:	REST <C,A>
PBACT1:	INC PBAUSR(B)	;ONE MORE ACTIVE USER OF THIS PAGE
	RTS PC
PBACT3:	CLR -(A)	;SAVE IT FROM BEING SWAPPED OUT
	DEC NPBSWO
	BR PBACT4
;FREE UP SOME CORE, MOVING PROCESSES FROM DORMANT TO INACTIVE OR
;ACTIVE TO RUNNING AS NEEDED
CRFREE:	JSR F,ACSAV
CRFRE1:	CMP #NDRQBL-4,DRQFCN	;ARE THERE MANY ACTIVE DISK TRANSFERS?
	BLT CRFRE3	;NO, LETS DO SOME
CRFRE2:	JSR PC,SFLUSH	;WAIT FOR THINGS TO CALM DOWN
	CMP #NDRQBL-4,DRQFCN	;HAVE THEY?
	BGE CRFRE2	;NOPE
	JSR PC,RUNME	;MAYBE NOW THERE WILL BE ROOM
	CMP #8,FREECR	;IS THERE AT LEAST 4K?
	BLE CRFRE9	;YES, ASSUME THERE MIGHT BE ENOUGH FREE
CRFRE3:	TST NPBSWO	;ANY PAGES WAITING TO BE SWAPPED OUT?
	BEQ CRFRE4	;NO, BETTER MAKE SOME
	MOV #PBSWPO,A	;POINT TO THE SWAP OUT LIST
	MOV (A)+,B	;LOOK FOR A NON-ZERO ENTRY
	BEQ .-2
	CMP #PBSWOE,A	;WITHIN THE TABLE?
	NBUGC LOS	;UGH
	DEC NPBSWO	;ONE LESS ENTRY
	CLR -(A)	;FLUSH IT
	JSR PC,SWPPAG	;SWAP IT OUT
CRFRE9:	JSR F,ACRES	;MAYBE NOW THERE WILL BE SPACE
	RTS PC
CRFRE4:	CMP #12.,FREECR	;IS THERE MORE THAN 6K FREE?
	BLE CRFRE7	;THEN THINGS ARE IN BAD SHAPE
	MOV #DORQ,A	;SEE IF ANYONE ON THE DORMANT QUEUE
	MOV #IACTQ,E	;WOULD LIKE TO BECOME INACTIVE
	JSR PC,CRFREL
	BNE CRFRE3	;GOT ONE, GO SWAP OUT A PAGE OF HIS
	MOV #ACTQ,A	;HAVE TO REMOVE AN ACTIVE USER
	MOV #RUNQ,E	;TO THE RUNQ
	JSR PC,CRFREL
	BNE CRFRE3	;GOT ONE, GO SWAP
	BR CRFRE2	;UGH BLETCH!!!!!!

CRFRE7:	INC LOGJAM	;ANOTHER DAY, ANOTHER LOGJAM
	MOV CST1FR,A	;POINT TO FIRST FREE BLOCK
	ADD #CSTPB-CST+2,A	;POINT IN PB TABLES
	MOV (A)+,B	;GET A PB
	BEQ .-2		;NONE THERE
	JSR PC,SWPPAG	;SWAP THE THING OUT!
	BR CRFRE9

CRFREL:	JSR PC,GLQTIM	;GET THE GUY LONGEST ON THE QUEUE
	TST A		;ANYONE ON?
	BEQ CRFRL1	;NOPE
	MOV E,B		;MOVE HIM TO A LESS FAVORED POSITION
	JSR PC,PRSAOD	;DEACTIVATE HIS PAGES
	JSR PC,TQUEUE	;AND MOVE HIM
	CLZ
CRFRL1:	RTS PC
.SBTTL RANDOM UTILITIES FOR MUNGING WITH CORE TABLES
;CONVERT THE GIP IN B TO A PAGE BLOCK POINTER IN B
GIPPB:	SAVE A
	MOV #-1,A
	JSR PC,ITM1PL	;DO A DUMMY PUSH
	TST B		;MAKE SURE WE HAVE A GIP
	NBUGC GT		;WHATCH OUT FOR REAL ITEMS
	BIT #GIPSPR,B	;IS IT A SPHERE GIP?
	BEQ GIPPB1	;NOPE
	MOV B,A		;COPY IT
	BIC #GIPITM,A	;GET THE ITEM PART
	ASH #2,A	;MAKE IT A REAL ITEM INDEX
	JSR PC,ITM1LD	;LOAD IT UP
	ADD #SUPTS,A	;POINT INTO UPTS
	BIC #GIPUPT,B	;GET THE UPT #
	ASH #-10.,B	;INTO THE RIGHT PLACE
	MUL #UPTLEN,B	;MAKE IT AN INDEX
	ADD A,B		;REAL POINTER
GIPPB1:	BIC #GIPBIT,B	;CLEAR THE EXTRA BIT
	MOV UPTPBP(B),B	;GET THE PAGE BLOCK POINTER
	JSR PC,ITM1PO
	REST A
	RTS PC

;GET A FILE PAGE BLOCK, SETTING THE LENGTH TO WHAT
;IS IN B. RETRUN POINTER TO PAGE BLOCK IN B
;SET PBFILE BUT NOT PBZERO
;SWAP SPACE IS NOT ALLOCATED
;WILL HANG FOREVER FOR PB IF NONE AVAILABLE
FPBGET:	SAVE <A,B>
	MOV #FPBFRE,B	;POINTER TO FILE PAGE BLOCKS
	JSR PC,FREEGT		;GET ONE
	MOV #PBFILE!PBVAS!PBSTS,PBFLAG(A)	;INDICATE IT IS A FILE BLOCK
	BR PBGET1		;GO JOIN NORMAL PB GETTING

;GET A REGULAR PAGE BLOCK, ARGS AND RETURNS
;JUST LIKE FPBGET, EXCEPT IT SETS PBZERO AND NOT PBFILE
PBGET:	SAVE <A,B>
	MOV #PBFREL,B	;POINTER TO REGULAR FREE LIST
	JSR PC,FREEGT	;GET THE BLOCK
	MOV #PBZERO,PBFLAG(A)	;ZERO BLOCK ON FIRST SWAP IN
PBGET1:	JSR PC,FREELK	;MAKE A LOCK THAT WILL PUT IT BACK ON THE FREE LIST
	MOVB (P)+,PBLEN(A)	;POP THE LENGTH OFF THE STACK
	CLRB PBRAN(A)	;CLEAR THE RANDOM BYTE
	CLR PBAUSR(A)	;NO ACTIVE USERS (???)
	CLR PBGIP(A)	;DOESN'T POINT AT GIP
	MOV A,B		;COPY POINTER TO THE PB
	REST A
	RTS PC

;LOCK THE "LOCKED" BIT IN THE PB POINTED TO BY B
;TO BE UNLOCKED WHENEVER SWITCH IS POPED
PBLCK:	SAVE <A,B,C>
PBLCK1:	BIT #PBDISK,(B)	;DISKING?
	BEQ PBLCK3	;NOPE
PBLCK2:	JSR PC,SFLUSH
	BIT #PBDISK,(B)	;STILL DISKING?
	BNE PBLCK2
	JSR PC,RUNME	;TRY AGAIN
	BR PBLCK1
PBLCK3:	MOV B,A		;POINTER TO PB FLAG WORD
	MOV #PBLOCK,B	;BIT TO LOCK
	CLR C		;NO ITEM
	JSR PC,LCKASW	;LOCK IT
	REST <C,B,A>
	RTS PC

;GET A NODE OUT OF A STANDARD FREE LIST
;B CONTAINS POINTER TO FREE POINTER
;ON RETURN A CONTAINS POINTER TO GOBBLED NODE
;ROUTINE WILL HANG FOREVER WAITING FOR NODE
FREEGT:	TST (B)		;ANY FREE ONES?
	BNE FREEG2	;YES, GO GOBBLE
FREEG1:	JSR PC,SFLUSH	;WAIT A LITTLE
	TST (B)		;ANY?
	BEQ FREEG1	;NOPE
	JSR PC,RUNME	;HOPE ITS STILL THERE WHEN I GET BACK
	BR FREEGT	;TRY AGAIN
FREEG2:	MOV (B),A	;THE FREE ONE
	MOV (A),(B)	;FREE POINTER NOW POINTS AT NEXT FREE
	RTS PC

;LOCK A STANDARD NODE OFF A FREE LIST
;NO PROCESSING IS DONE ON PCLOSERING EXCPET FREEING THE
;NODE, SO BE CAREFUL HOW YOU USE THIS!
;ON ENTRY, A POINTS TO THE NODE AND B POINTS
;TO THE FREE POINTER FOR THIS TYPE OF NODE
FREELK:	SAVE <A,B>
	MOV #LCKULN,A	;AN UNLINK TYPE OF LOCK
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV (P),LCKWD2(A)	;LOCK WORD 2 POINTS TO THE FREE POINTER
	MOV 2(P),LCKWD1(A)	;WORD ONE POINTS TOT EH NODE
	REST <B,A>
	RTS PC

;THIS CROCK WILL FREE A LOCKED LIST NODE IF YOU FAIL IN
;SOME WAY OTHER THAN PCLOSERING BY PRETENDING TO PCLOSER
;FOR THE TOP SWITCH
FRELSE:	MOV PC,BPCLSR	;SAY WE ARE PCLOSERING
	JSR PC,LSWPOP	;POP THE SWITCH
	CLR BPCLSR	;PREVIOUS STATEMENTS ARE NOW INOOPERATIVE
			;(WE LIED)
	RTS PC
.SBTTL CORE HACKING ROUTINES
;INTIAL MAP-SETTING ROUTINE
;CLOBBERS MOST AC'S, INTENDED TO BE RUN ONLY AT ITIALIZE TIME
;OR AFTER A POWER FAIL RESTART
MAPSET:	MOV #I0AR,A	;FIRST WE'LL SET UP A STRAIGHT MAP
	CLR B		;I AND D SPACE THE SAME AND MAPPED DIRECTLY
	MOV #8.,C	;FROM VIRTUAL CORE TO PHYSICAL
MAPST1:	MOV #77406,VAR0DR-I0AR(A)	;DATA SPACE 4K SEGEMNET
	MOV #77406,I0DR-I0AR(A)		;INSTRUCTION SPACE 4K SEGMENT
	MOV B,VAR0AR-I0AR(A)		;VIRTUAL MAPPED DIRECTLY TO PHYSICAL
	MOV B,(A)+			;FOR BOTH INST AND DATA SPACE
	ADD #200,B	;4K WORTH
	SOB C,MAPST1	;DO FORR 8 SEGMENTS
	;NOW WE'LL HACK THE SPEECAIL THINGS
	MOV #7600,IOAR	;MAP USUAL I/O SPACE TO REAL I/O SPACE
;THE FOLLOWING THING IS THE DR FOR THE RUG PAGES (UGH!)
FOO==<<200-<<RUGIDR-I0DR+2>*100>+<<RUGST_-6>&1777>>_8.>+16
	MOV #FOO,RUGIDR	;SPECIAL RUG SEGMENT
	MOV #FOO,RUGDDR	;MAP 156000-157776 VIRTUAL TO SAME PHYSICAL
	MOV #VAR2DR,A	;NOW FLUSH UNUSED VARIABLE PAGE AND 3 ITEM PAGES
	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)
	MOV #I7DR,A
	CLR (A)		;FLUSH HIGH INSTRUCTION PAGE
	TST -(A)	;DON'T CLOBBER RUG PAGE
	MOV #120000,B	;FIRST LOCATION IN A PAGE BEFORE RUG PAGE
MAPST2:	CMP #LSTILC,B	;LAST INSTRUCTION LOCATION
	BHI MAPST3	;IF THERE IS SOMETHING THERE, WE'RE DONE
	CLR -(A)	;NO ONE THERE, FLUSH IT
	SUB #20000,B	;NEXT PAGE DOWN
	BR MAPST2
MAPST3:	MOV #7,SSR3	;ENABLE I AND D FOR ALL MAPS
	MOV #1,SSR0	;THERE WE GO!!
	RTS PC
;MAP RESTORE ROUTINE
;CLOBBERS NO REGISTERS
;EXPECTS THE SPHERE TO RESTORE IN ITEM1
;DOES NOT RESTORE IF CURSPH IS SAME AS ITEM1
MAPRES:	CMP CURSPH,ITEM1	;IS IT ALREADY LOADED?
	BEQ MAPRE9		;YES
	CMP #-1,CURSPH	;IS THERE A SPHERE MAPPED IN?
	NBUGC NE	;UGH, THAT MEANS HIS W BITS DIDN'T GET COPIED OUT!
	MOV ITEM1,CURSPH
MAPRE1:	JSR F,ACSAV	;THIS IS THE ENTRY POINT FOR RESTORING THE MAP EVERY TIME
	MOV #20,A	;FOR ALL PAGES
	MOV #USRISD,B	;ALL DR'S
	CLR (B)+	;MAKE NON-EX
	SOB A,.-2
	MOV ITM1A,A	;POINTER TO THE ITEM
	ADD #SUPTS,A	;GET POINTER TO UPTS FOR SPHERE
	CLR B		;POINT TO USER MAP
	MOV #20,C	;NUMBER OF SEGMENTS TO LOAD
MAPRE2:	CLR USRISD(B)		;CLEAR OUT THE OLD REGISTER
	TST (A)		;DOES THE PAGE EXIST?
	BEQ MAPRE3	;NO PAGE HERE
MAPRE7:	BIT #UPTABS,(A)	;IS IT AN ABS PAGE?
	BNE MAPRE8	;YUP, GO LOAD IT
	BIT #UPTDEI,(A)	;IS IT THE DATA PART OF A D=I ?
	BNE MAPRE3	;YUP, GO IGNORE IT
	MOV UPTPBP(A),D	;GET A POINTER TO THE PAGE BLOCK
	BEQ MAPRE3	;NO PB=>NO PAGE
	BIT #PBVACR,PBFLAG(D)	;IS THE PAGE IN CORE?
	BEQ MAPRE3	;NOPE, IGNORE IT
	BIT #PBLOCK!PBDISK,PBFLAG(D)	;LOCKED OR IN DISK TRANSFER?	
	BNE MAPRE3	;IF SO, IGNORE IT
	MOVB UPTSTL(A),E	;GET THE UPT START AND LENGTH
	BIC #UPTSMS,E	;CLEAR OFF CRAP
	ASH #-UPTSSH,E	;SHIFT TO GET # OF START BLOCK
	MOVB PBRAN(D),F	;TO GET PB START
	BIC #PBSTRT,F	;IT IS IN BLOCKS
	SUB F,E		;GETS HOW FAR PAST PB START UPT START IS
	ADD PBCAR(D),E	;WHICH TELLS US WHAT TO ADD TO THE CORE ADDRESS
	ASH #4,E	;32.=512.
	BIT #UPTEXD,(A)	;IF IT IS EXPAND DOWN
	NBUGC NE	;WE HAVE TO DO SPECIAL STUFF
	MOV E,USRISA(B)	;LOAD THE AR
	MOVB UPTSTL(A),E	;NOW TO GET THE START TO USE
	BIC #UPTLMS,E	;GET THE START
	ASH #12.,E	;GET INTO DR FORMAT
	BIS #17_8.,E	;FIX FOR THE SEGMENTER
	MOV #4,F	;READ/WRITE TRAP (TRAP IS NOT ENABLED THOUGH)
	BIT #UPTRDO,(A)	;IS IT READ-ONLY?
	BEQ .+6		;NO, READ-WRITE
	MOV #1,F	;READ-ONLY, TRAP
	BIS F,E		;SET INTO DR WORD
	MOV E,USRISD(B)	;SET INTO THE DR
MAPRE6:	BIT #UPTIED,(A)	;IS THIS TH EI SPACE HALF OF AN I=D?
	BEQ MAPRE3
	MOV USRISD(B),USRDSD(B)	;COPY THE DR
	MOV USRISA(B),USRDSA(B)	;COPY THE AR
MAPRE3:	TST (B)+	;NEXT
	ADD #UPTLEN,A
	DEC C
	BEQ .+6
	JMP MAPRE2
	JSR F,ACRES
MAPRE9:	RTS PC

MAPRE8:	MOV UPTPBP(A),USRISA(B)	;PB POINTER IS THE AR
	MOV UPTGIP(A),USRISD(B)	;GIP POINTER IS THE DR
	BR MAPRE6		;CHECK FOR I=D
;THE MEMORY TABLE INITIALIZER
;CLOBBERS ALL REGISTERS
MEMTST:	MOV #20,ITM0AR	;FIRST FIND HOW MUCH MEMORY
	MOV #6,ITM0DR	;LENGTH 1 PAGE
	SAVE BEBRV	;SAVE THE BUSS ERROR VECTOR
	MOV #MEMTS1,BEBRV	;TRAP BACK TO THE ROUTINE
	MOV #MNCBLK,A		;THE MOST WE WILL PAY ATTENTION TO
	MOV #CST,B
MEMTS2:	TST ITM0AD	;CAUSE BUSS ERROR IF NXM
	ADD #20,ITM0AR	;INCREMENT BY 512 WORDS
	MOV #CSTBEB!CSTSYB,(B)+	;SAY IT EXISTS AND SYSTEM USING IT
	SOB A,MEMTS2	;TRY AGAIN UNLESS WE HAVE ENOUGH
	MOV B,CSTTOP
	BR MEMTS3
MEMTS1:	SPL 0
	MOV B,CSTTOP
	CMP (P)+,(P)+	;FLUSH THE TRAP
	MOV #CSTSYB,(B)+	;SAY THE SYSTEM IS USING NON-EX CORE
	SOB A,.-4
MEMTS3:	REST BEBRV
	MOV ITM0AR,B
	SUB #20+<<RUGIAR-I0AR>+2>*100,B	;CONVERT TO AMOUNT ABOVE RUG
	NBUGC LE		;IS THERE ENOGUH FOR RUG
	ASH #-4,B	;CONVERT TO 512 WORD BLOCKS
	MOV #<<RUGIAR-I0AR>+2>*4,A	;FIRST BLOCK AFTER RUG
.IIF NZ NTKDIS,JSR PC,DISALC
	ASL A		;CONVERT TO
	ADD #CST,A	;INDEX IN TO THE CST
	MOV B,FREECR	;AMOUNT OF FREE CORE
MEMAL1:	BIC #CSTSYB,(A)	;NOT USED BY SYSTEM
	BIS #CSTFRB,(A)+	;AND FREE
	SOB B,MEMAL1

	MOV #CST+<FSTFRB*2>,A	;POINT TO FIRST FREE CST ENTRY
	MOV #<<<RUGST-LSTILC>_-10.>>&77,B	;NUMBER FREE BEFORE RUG
	ADD B,FREECR
	MOV FREECR,USRCOR	;ALL FREE CORE IS CURRENTLY USER CORE
MEMAL2:	BIC #CSTSYB,(A)
	BIS #CSTFRB,(A)+	;FREE BLOCK, NOT USED BY SYSTEM
	SOB B,MEMAL2
	RTS PC
.IFNZ NTKDIS
;DISPLAY ALLOCATION ROUTINE
;ENTER WITH PLACE TO START ALLOCATING IN A
;NUMBER OF BLOCKS FREE IN B
;RETURN WITH A POINTING PAST WHAT WE HAVE ALLOCATED
;AND B HAVING WHAT WE HAVE ALLOCATED REMOVED
DISALC:	CMP #100,A	;THE DISPLAYS MUST START
	BGT .+4		;BELOW 32K
	BPT		;SO WE CAN SET THE RELOCATION PROPERLY
	MOV A,C		;SAVE START
	ASH #10.,C	;CONVERT TO WORD ADDRESS
	MOV C,TKRELS	;AND SAVE AS THE RELOCATION
	MOV C,NGREL	;ALSO SET RELOCATION
	MOV #1,C	;LENGTH ONE BLOCK
	JSR PC,ITMFAK	;FAKE UP AN ITEM
	MOV D,TKDPDL	;THE PDL AND START VECTOR ITEM
	MOV ITMTAB(D),TKDPDA	;SAVE THE START IN A CONVEINET PLACE
	CLR E		;THE ONE WE ARE ALLOCATING
	MOV #NTKDIS,F
DISAL1:	MOV TKDLEN(E),C	;LENGTH FOR THIS ONE
	JSR PC,ITMFAK	;FAKE UP AN ITEM
	MOV D,TKDITM(E)	;SAVE THE ITEM FOR THIS DISPLAY BUFFER
	TST (E)+
	SOB F,DISAL1
	SAVE <A>
	MOV TKDPDL,A	;THE PDLS AND START WORDS
	JSR PC,ITM2LD
	MOV #8.,C
DISAL2:	MOV #DSTOP,(A)+	;STOP ALL DISPLAYS
	SOB C,DISAL2
	REST <A>
	RTS PC

;FAKE UP AN ITEM
ITMFAK:	SAVE <C>
	MOV ITMFRE,D	;THE ITEM LIST
	MOV (D),ITMFRE	;TAKE THIS ITEM
	ASH #4,C	;MAKE LENGHT INTO 32. WORD BLOCKS
	DEC C		;CAUSE OF WAY SEGMENTS WORK
	MOVB C,ITLNGT(D)	;SET LENGHT
	MOVB #ITACCD,ITACCS(D)	;AND ACCESS
	MOV A,C		;COPY START
	ASH #4,C	;MAKE IT INTO 32. WORD BLOCKS
	MOV C,(D)	;SET THE ADDRESS INTO THE ITEM
	SUB #ITMTAB,D	;MAKE IT INTO AN ITEM NUMBER
	REST <C>	;RESTORE LENGHT IN 512. WORD BLOCKS
	ADD C,A		;NEXT PLACE TO ALLOCATE
	SUB C,B		;STUFF WE'VE USED
	BGT .+4		;MAKE SURE WE DON'T RUN OUT
	BPT		;OOOOPS!
	RTS PC
.ENDC
;TRY TO FIND A NUMBER OF CONTIGOUS BLOCKS LARGE ENOUGH FOR THE PAGE
;REPRESENTED BY THE PB POINTED TO BY B
;ON SUCESS, CLOBBER THE CAR OF THE PAGE TO THE RIGHT THING
;AND UNFREE THE CORE IN CST AND CSTPB
FINPAG:	JSR F,ACSAV	;MIGHT AS WELL SAVE THEM ALL...
	MOVB PBLEN(B),A	;HOW LONG DO WE NEED?
	INC A		;0=1
	CMP A,FREECR	;DO WE HAVE THAT MUCH ALL TOGETHER?
	BGT FINPA8	;NO WAY TO WIN
	MOV CST1FR,C	;POINT TO CST ENTRY OF FIRST FREE BLOCK
	MOV #CSTFRB,E	;A COMMONLY USED CONSTANT
	MOV CSTTOP,F	;GENERATE NUMBER OF TIMES TO TRY
	SUB C,F		;DEIFFERENCE OF TOP AND FIRST FREE
	ASR F		;WORDS
FINPA1:	MOV A,D		;COPY THE LENGTH
	BIT E,(C)+	;THIS ONE FREE?
	BNE FINPA3	;GOT ONE
FINPA4:	SOB F,FINPA1	;KEEP TRYING
	BR FINPA8	;NO GOOD

FINPA3:	MOV C,B		;SAVE POINT TO START OF BLOCK+2
	DEC D		;GOT ONE BLOCK, IS THAT ENOUGH?
	BEQ FINPA9	;YUP, WIN
FINPA5:	BIT E,(C)+	;IS NEXT ONE FREE?
	BEQ FINPA4	;NO, HAVE TO TRY ANOTHER PAGE
	DEC D		;ONE MORE, ENOUGH?
	BEQ FINPA9	;YUP
	SOB F,FINPA5	;KEEP TRYING
	INC NOFIT	;INCREMENT NUMBER OF TIMES THAT A PAGE WOULDN'T FIT
FINPA8:	JSR F,ACRES	;NO LUCK, GIVE UP
	SEZ
	RTS PC

FINPA9:	MOV B,F		;GET BACK THE POINTER TO THE START+2
	TST -(F)	;BACK UP TOT HE REAL ENTRY
	MOV F,C		;COPY IT
	MOV A,D		;AND THE LENGTH
FINPA6:	MOV B,CSTPB-CST(C)	;THIS PAGE OCCUPIES THIS BLOCK
	BIC E,(C)+	;BLOCK IS NO LONGER FREE
	SOB D,FINPA6
	SUB A,FREECR	;TAKE THIS AWAY FROM FREE CORE
	BNE FINP10	;SOMETHING STILL FREE
	MOV CSTTOP,CST1FR	;TOP IS FIRST FREE, IS NOTHING
	BR FINPA7

FINP10:	CMP F,CST1FR	;IS THIS WHAT USED TO BE FIRST FREE?
	BNE FINPA7	;NOPE
	BIT E,(C)+	;IS THIS FREE?
	BEQ .-2		;LOOP UNTIL WE FIND THE FIRST FREE BLOCK
	TST -(C)	;OVERSHOT	
	MOV C,CST1FR	;REPLACE WITH NEW FIRST FREE
FINPA7:	SUB #CST,F	;GET THE BLOCK NUMBER
	ASR F
	MOV 2(P),B	;GET BACK POINTER TO THE PB
	MOV F,PBCAR(B)	;AND PUT TI INTO THE PB
	JSR F,ACRES
	CLZ
	RTS PC

;FREE THE BLOCKS BELONGING TO THE PAGE BLOCK POINTED TO BY B
PBCFRE:	SAVE <A,C>
	BIT #PBDISK!PBLOCK,PBFLAG(B)	;BETTER NOT BE LOCKED OR DISKING
	NBUGC NE
	BIC #PBVACR,PBFLAG(B)	;NO LONGER VALID IN CORE
	MOVB PBLEN(B),A		;GET THE LENGTH
	INC A			;0=1
	MOV PBCAR(B),C		;GET THE START
	BEQ PBCFR2		;SOMEONE ELSE ALREADY FREED HIS CORE
	CLR PBCAR(B)		;NO LONGER VALID
	ASL C			;CONVERT TO A WORD INDEX
	ADD #CST,C		;POINTER INTO CST
	CMP C,CST1FR		;IS THIS BEFORE THE FIRST FREE?
	BHI .+6			;NO
	MOV C,CST1FR		;NOW THIS IS FIRST FREE
PBCFR1:	BIS #CSTFRB,(C)	;FREE THE BLOCK
	CLR CSTPB-CST(C)		;DOESN'T BELONG TO ANYONE
	TST (C)+		;NEXT
	SOB A,PBCFR1		;AS MANY TIMES AS NEEDED
PBCFR2:	REST <C,A>
	RTS PC
.SBTTL FUPT HACKING ROUTINES
;GET A FUPT THAT POINTS AT A PB THAT REPRESENTS (B) BLOCKS OF FREE CORE
;ON EXIT, A CONTAINS A GIP TO THE NEW PAGE AND B POINTS TO THE PB
;Z IS SET IF NO SWAP SPACE IS AVAILABLE
;A SWITCH IS PUSHED THAT WILL DELETE THE PAGE IF PCLOSERED
FRCRGT:	JSR PC,PBGET	;GET A PAGE BLOCK
	JSR PC,FUPTGT	;GET A FUPT AND POINT IT AT THE PB
	JSR PC,FINSWP	;TRY TO FIND SWAP SPACE FOR IT
	BEQ FRCRG1	;CAN'T
	JSR PC,LSWPOP	;POP LOCK FOR FUPT
	JSR PC,LSWPOP	;POP LOCK FOR PB
	SAVE <B,A>	;NOW TO LOCK FPT A DIFFERENT WAY
	MOV #LPCLRT,A	;RUN ROUTINE ON PCLOSER
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV #FUPTFL,LCKWD1(A)	;ROUTINE
	MOV (P),LCKWD2(A)	;FUPT POINTER
	REST <A,B>
	CLZ
	RTS PC
FRCRG1:	JSR PC,FRELSE	;FLUSH THE FUPT
	JSR PC,FRELSE	;FLUSH THE PB
	SEZ
	RTS PC

;GET A FUPT TO POINT TO THE PB POINTED TO BY B
;COPY THE LENGTH FROM THE PB INTO THE FUPT
FUPTGT:	SAVE <C,B>
	MOV #FUPTFR,B	;FREE POINTER FOR FUPTS
	JSR PC,FREEGT	;GET ONE
	JSR PC,FREELK	;LOCK IT
	MOV (P),B	;POINTER TO THE PB
	MOV B,UPTPBP(A)	;POINT FPT AT IT
	CLR FUPTPR(A)	;THE THING CURRENTLY IS NOT LOCKED BY A PROCESS
	MOV #UPTEXB,UPTFLG(A)	;INIT THE FLAGS
	MOVB PBLEN(B),UPTSTL(A)	;INIT THE LENGTH AND START
	TST PBGIP(B)	;DOES THIS PB POINT TO OTHER UPTS?
	BEQ FUPTG1	;NO, EASY CASE
	MOV PBGIP(B),B	;FIRST ONE IT POINTS TO IN CIRC LIST
	JSR PC,UPTPLD	;PUSH AND LOAD 
	MOV UPTGIP(B),UPTGIP(A)	;POINT  NEW ONE TO 2ND IN LIST
	BIS #GIPBIT,A	;MAKE A A VALID GIP
	MOV A,UPTGIP(A)	;POINT FIRST IN LIST AT NEW ONE
	JSR PC,ITM2PO	;RESTORE ITEM2
FUPTG2:	REST <B,C>
	RTS PC
FUPTG1:	MOV A,C		;COPY POINTER TO NEW FUPT
	BIS #GIPBIT,A	;MAKE A VALID GIP
	MOV A,PBGIP(B)	;POINT THE PB AT IT
	MOV A,UPTGIP(C)	;AND POINT IT AT ITSELF
	BR FUPTG2

;THIS PCLOSER ROUTINE FLUSHS A FUPT ASSUMMING IT HAS NO CIRCLAR LIST
;AND THE PAGE DOESN'T NEED TO BE SWAPPED BACK TO SOURCE
FUPTFL:	MOV LCKWD2(B),B	;GET THE GIP
	BIC #GIPBIT,B	;CONVERT TO FUPT POINTER
	SAVE B		;WE'LL NEED IT OCCASIONALLY
	MOV UPTPBP(B),B	;POINT TO THE PB
	JSR PC,PBSFRE	;FREE THE SWAP SPACE
	MOV PBFREL,A	;POINT TO ONES FREE NOW
	MOV B,PBFREL	;NEW FREE ONE
	MOV A,(B)	;INTO LIST
	REST B		;GET FUPT POINTER BACK
	MOV FUPTFR,A	;ONES FREE NOW
	MOV B,FUPTFR	;NEW ONE
	MOV A,(B)	;INTO LIST
	RTS PC

;MAKES A GENERALIZED ITEM POINTER, B CONTAINS UPT NO, C CONTAINS SPHERE NO.
;THEN DELETES UPT, BY FALLING INTO UPTDL
SUPTDL:	ASH #10.,B		;SET THE UPT NO. IN THE CORRECT BITS
	BIS C,B			;SET IN THE ITEM NO.
	BIS #GIPBIT!GIPSPR,B	;SAY IT IS A GIP AND IN A SPHERE
;FALL INTO UPTDL
;THIS ROUTINE FLUSHS A UPT THAT MIGHT HAVE A CIRCULAR LIST
;AND THAT MIGHT POINT AT CORE THAT IS NOT VALID AT SOURCE
;NEEDLESS TO SAY, IT MIGHT HANG
;THE UPT IS POINTED TO BY B, WHICH MIGHT GET CLOBBERED
UPTDL:	SAVE B		;SAVE THE ACTUAL GIP
	JSR PC,UPTPLD	;LOAD UP THE UPT
	SAVE B		;SAVE THE POINTER TO THE UPT
	BIT #UPTABS,(B)	;ABSOLUTE PAGE?
	BNE UPTDL7	;YUP, EASY
UPTDL4:	MOV UPTPBP(B),B	;GET ITS PB POINTER
	BIT #PBFILE,PBFLAG(B)	;IS IT A FILE PB?
	BEQ UPTDL1	;NO, WE'RE SAFE
	BIT #PBVAS,PBFLAG(B)	;IS IT VALID AT SOURCE?
	BNE UPTDL1	;YES, WE'RE SAFE
	MOV 2(P),B	;GET BACK GIP POINTER TO IT
	JSR PC,SWPIN	;SWAP IT IN
	JSR PC,VALSRC	;VALIDATE IT AT THE SOURCE
	BR UPTDL4	;DOUBLE CHECK
UPTDL1:	MOV (P),B	;GET BACK THE ADDRESS
	CMP 2(P),UPTGIP(B)	;DOES IT POINT TO ITSELF?
	BEQ UPTDL8	;YES, EASY CASE
	JSR F,ACSAV
	CLR E		;NO BITS SET YET
	SAVE <UPTGIP(B),UPTGIP(B)>	;TWO COPIES OF WHAT IT POINTS TO	
UPTDL2:	MOV (P),B	;GET THE NEXT POINTER
	JSR PC,UPTLD	;LOAD IT
	MOV UPTGIP(B),(P)	;GET THE NEW NEXT

	MOVB UPTSTL(B),C	;GET START AND LENGTH
	BLT UPTD.1	;NOT SET UP YET FOR THIS GUY
	MOV C,D		;COPY IT
	BIC #UPTLMS,D	;GET LENGTH
	BIC #UPTSMS,C	;AND START
	ASH #-UPTSSH,D	;SHIFT START
	INC C		;0=>1
	BISB BMT(D),E	;SET BIT FOR THIS BLOCK
	SOB C,.-4	;GO FOR THE WHOLE LENGTH
UPTD.1:	CMP 6(P),(P)	;IS THE NEXT THING THE THING WE STARTED WITH?
	BNE UPTDL2	;NOPE, KEEP TRING
	MOV 2(P),UPTGIP(B)	;THIS UPT POINTS AT WHAT WE WANT TO FLUSH
				;2(P) IS WHAT THE THING WE ARE FLUSHING POINTS TO
				;THUS, THIS INST FLUSHES THE UPT WE WANT TO FLUSH
	MOV UPTPBP(B),B	;GET POINTER TO THE PB
	TST E		;WERE THERE ANY BLOCKS MAPPED IN?
	BNE UPTD.2	;YUP, GO CHECK THEM OUT
	MOV #-1,D	;NEW START AND LENGTH
	BR UPTD.4	;GO FILL IT IN
UPTD.2:	CLR C		;ACCUMULATE STARTT
UPTD.3:	BITB BMT(C),E	;THIS BIT ON?
	BNE UPTD.6	;YUP, WE HAVE THE START
	INC C		;ONE MORE
	BR UPTD.3
UPTD.6:	MOV #7,D	;NOW FROM THE OTHER END
UPTD.7:	BITB BMT(D),E	;THIS ONE HERE?
	BNE .+4	;YUP
	SOB D,UPTD.7	;KEEP TRYING
	SUB C,D		;CONVERT END TO LENGTH
	CMPB D,PBLEN(B)	;SAME LENGTH AS BEFORE?
	BNE UPTD.4	;NO, NEED TO FLUSH FROM CORE
	MOVB PBRAN(B),E	;GET THE START
	BIC #PBSTRT,E
	CMP C,E		;STARTS THE SAME?
	BEQ UPTD.5	;YUP, NO NEED TO CHANGE
UPTD.4:	JSR PC,PBCFLS	;FLUSH THE PB'S CORE
	MOVB D,PBLEN(B)	;SET THE LENGTH
	BICB #7,PBRAN(B)	;FLUSH OLD START
	BISB C,PBRAN(B)	;SET IN NEW START
UPTD.5:	JSR F,ACRES
	CMP (P)+,(P)+	;FLUSH DUMMIES FROM STACK
UPTDL7:	REST B		;GET BACK ORRIGINAL ADDRESS
	BIT #GIPSPR,(P)	;IS IT A SPHERE UPT?
	BNE UPTDL3	;GO HANDLE THAT
;COME HERE FOR FUPT
	SAVE FUPTFR	;LINK INTO
	MOV B,FUPTFR	;THE FREE LIST
UPTDL5:	REST (B)	;THE FUPT
	REST B		;GET BACK THE NOW USLESS GIP
	JSR PC,ITM2PO	;RESTORE ITEM 2
	RTS PC
UPTDL3:	CLR -(P)	;TO CLOBBER UPT WHEN DONE
	BIT #UPTDEI,(B)	;IS IT A D=I PAGE?
	BEQ UPTDL0	;NO
	BIC #UPTIED,8.*UPTLEN(B)	;DELETE CORESPONDING BIT INI PAGE
	BR UPTDL5
UPTDL0:	BIT #UPTIED,(B)	;IS IT THE I HALF?
	BEQ UPTDL5	;NOPE
	BIC #UPTDEI,-8.*UPTLEN(B)	;DELETE COORESPONDING BIT
	BR UPTDL5

UPTDL8:	MOV (P),B	;GET POINTER TO FUPT
	MOV UPTPBP(B),B	;GET POINTER TO PB
	BIT #PBFILE,PBFLAG(B)	;IS IT A FILE PAGE?
	BEQ UPTDL6		;NO, NOTHING SPECIAL THEN
	JSR PC,MFIPBD	;DELETEING A PB FROM AN MFI
UPTDL6:	JSR PC,PBCFRE	;FREE THE CORE
UPTDL9:	JSR PC,PBSFRE	;FREE THE SWAP SPACE
	SAVE PBFREL	;LINK THE OLD FREE LIST
	MOV B,PBFREL	;AND THE NEW FREE NODE
	REST (B)	;TOGETHER
	BR UPTDL7	;AND FINISH UP
;PC LOSER ROUTINE TO CLOBBER A FUPTPR BACK TO ZERO
PRPFIX:	MOV LCKWD2(B),A	;GET POINTER TO FUPT
	CMP ITEM0,FUPTPR(A)	;DO I HAVE IT LOCKED?
	NBUGC NE	;UGH, I SHOULDN'T BE UNLOCKING IT!
	CLR FUPTPR(A)	;UNLOCK
	RTS PC

;SET THE FUPTPR OF AN FUPT
;HANG UNTIL IT IS ZERO, THEN SET IT TO RUNNING PROCESS
;WITH A ROUTINE TO RUN WHEN THE LOCK IS POPED
FUPTLK:	JSR F,ACSAV
	BIC #GIPBIT,B	;CONVERT TO CORE ADDRESS
FUPTL3:	TST FUPTPR(B)	;ALREADY LOCKED?
	BEQ FUPTL1
	CMP PRUNNG,FUPTPR(B)	;AM I THE GUY WHO HAS IT LOCKED?
	BEQ FUPTL4	;WIN, JUST RETURN
FUPTL2:	JSR PC,SFLUSH	;WAIT
	TST FUPTPR(B)	;TRY AGAIN
	BNE FUPTL2
	JSR PC,RUNME
	BR FUPTL3
FUPTL1:	MOV ITEM0,FUPTPR(B)	;SAY I USE THIS FUPT
	MOV B,F		;SAVE POINTER TO IT
	MOV #LCKRTN,A	;RUN THIS ROUTINE WHEN UNLOCKED
	CLR B		;SAY THERE IS NO ITEM
	JSR PC,LOCKSW	;LOCK A SWITCH
	MOV #PRPFIX,LCKWD1(A)	;PUT IN THE ROUTINE TO RUN
	MOV F,LCKWD2(A)	;POINTER TO THE FUPT TO FIX
FUPTL4:	JSR F,ACRES
	RTS PC
;ROUTINE TO FIX UP A PB TO BE A SPECIFIED START AND LENGTH
;CALL WITH PB POINTER IN B, DESIRED START IN C
;DESIRED LENGTH IN D
;ROUTINNE RETURNS WITH Z SET IF NOT ALL THE REQUESTED
;BLOCKS EXIST IN A FILE PAGE
PBSETU:	JSR F,ACSAV
	CMPB #-1,PBLEN(B)	;IS THE PAGE NOT SET UP?
	BEQ PBSET3	;THEN JUST SET IT
	JSR PC,PBLONG	;GET THE NEEDED START AND LENGTH
			;AND THE CURENT START AND LENGTH
	BEQ PBSET1	;NOT ALL BLOCKS OF FILE PAGE EXIST
	CMP C,E		;IS NEEDED START = EXISTING?
	BNE PBSET2	;NO, NEED TO WORK
	CMP D,F		;IS NEEDED LENGTH EQUAL ALSO?
	BNE PBSET2	;OH WELL...
	JSR F,ACRES	;NOTHING TO DO
	CLZ
	RTS PC

PBSET2:	BIT #PBVAS,PBFLAG(B)	;IS IT VALID AT SOURCE?
	BNE PBSET3	;YES, WE CAN CLOBBER THE PAGE
	JSR PC,PBVLSR	;VALIDATE THE PAGE AT SOURCE
	JSR F,ACRES
	BR PBSETU	;GO TRY IT ALL AGAIN
PBSET3:	JSR PC,PBCFLS	;FLUSH THE CORE
PBSET4:	MOVB C,PBLEN(B)	;SET EH NEW LENGTH
	BICB #7,PBRAN(B)	;CLEAR OLD START
	BISB D,PBRAN(B)	;SET IN NEW LENGTH
	JSR F,ACRES
	CLZ
	RTS PC
PBSET1:	JSR F,ACRES
	SEZ
	RTS PC
;FLUSH CORE USED BY THE B IN B, PCLOSERING AS NEEDED
PBCFLS:	BIT #PBVACR,PBFLAG(B)	;IS THE PAGE IN CORE?
	BEQ PBCFL1	;NO, DON'T NEED TO WORRY
	SAVE B		;SAVE THE PB POINTER
	MOV PBGIP(B),B	;GET A GIP FOR IT
	JSR PC,PAGPCL	;PCLOSER ANYONE WHO MIGHT HACK THIS PAGE
	JSR PC,PCLCLR	;I DON'T WANT TO BE PCLOSERED BY THIS!
	REST B		;GET BACK PB POINTER
	JSR PC,PBCFRE	;FREE THE CORE IT USED
PBCFL1:	RTS PC

;DO LENGTH COMPARISIONS FOR NEW AND OLD PB STARTS AND LENGTHS
;CALL WITH PB POINTER IN B, NEW START AND LENGTH IN C AND D
;RETURNS WITH NEEDED START AND LENGTH IN C AND D AND CURRENT
;START AND LENGTH IN E AND F
;RETURNS WITH Z SET IF SOME BLOCKS IN THE NEEDED PAGE ARE NON-EX
PBLONG:	SAVE A
	ADD C,D		;CONVERT LENGTH TO LAST BLOCK #
	MOV PBLEN(B),F	;GET CURRENT LENGTH
	MOV PBRAN(B),E	;AND CURENT START
	BIC #PBSTRT,E
	ADD F,E		;;CONVERT TO END BLOCK
	CMP C,E		;IS NEW START LESS THAN OLD START?
	BLT PBLON1	;YES, NEED TO EXPAND PAGE DOWN
	MOV E,C		;THIS WILL BE THE REQUIRED START
	CMP F,D		;IS NEW END PAST OLD END?
	BLT PBLON2	;YES, NEED TO EXPAND UP
	MOV F,D		;OLD ONE IS HIGH ENOUGH
PBLON3:	SUB C,D	;CONVERT BACK TO LENGTH
	SUB E,F		;LIKEWISE
	REST A
	CLZ
	RTS PC

PBLON1:	CMP F,D		;IS NEW END PAST OLD END?
	BLT PBLON2	;YES, USE NEW
	MOV F,D		;NO, USE OLD
PBLON2:	BIT #PBFILE,PBFLAG(B)	;IS THIS A FILE PAGE?
	BEQ PBLON3	;NO, WE'RE DONE
	MOV B,A		;COPY PB POINTER
	ADD #PBSDA,A	;POINT AT SOURCE ADDRESSES
	ADD C,A		;POINT AT
	ADD C,A		;FIRST ONE WE REFERENCE
	SAVE D		;SAVE END POINTER
	SUB C,D		;CONVERT TO LENGTH
PBLON5:	CMP #-1,(A)+	;NON-EX BLOCK?
	BEQ PBLON4	;YOU CAN'T MAP THAT IN!
	DEC D		;DONE ALL?
	BGE PBLON5	;NOT YET
	REST D		;MADE IT THROUGH OK
	BR PBLON3
PBLON4:	REST <D,A>
	SEZ		;TRYIED TO MAP IN NON-EX BLOCK
	RTS PC

	.SBTTL ITEM TABLE ROUTINES
.IIF NZ ITMADR!ITLINK,.ERROR NO, IT WON'T WORK WITH ITLINK OR ITADDR NON-ZERO
;CREATE AN ITEM OF SPECIFIED SIZE
;THE SIZE IS PUT INTO A; THE ITEM'S INDEX RETURNS IN B
;THE Z BIT IS SET IF THE ITEM CANNOT BE CREATED; OTHERWISE, IT IS CLEARED
;THIS MAKES NO ATTEMPT TO COMPRESS EXISTING ITEMS TO PRODUCE CONTIGOUS FREE SAPCE
;THAT FEATURE IS OF SOMEWHAT QUESTIONALBE VALUE, BUT MIGHT BE ADDED LATER
CRITEM:	CMP #200,A	;CHECK THAT NO ONE ASKS FOR A BLOCK>4K
	BUGC GT
	MOV ITMFRE,B	;ATTEMPT TO GET A FREE ITEM
	BEQ CRITM1	;NO MORE AVAILABLE, GO LOSE
	SAVE <C,D>
CRITM8:
;	TSTB ITACCS(B)	;IS THIS ITEM TABLE ENTRY REALLY FREE?
;	BUGC EQ		;OOPS!!
	MOV A,C		;GET THE LENGTH
	ASL C		;CONVERT IT TO AN INDEX
	ADD #ITMATB,C	;INTO THE ALLOCATE TABLE
	CLR D		;FOR THE LEFTOVER COUNT
CRITM3:	TST (C)+	;IS THERE A FREE ITEM BLOCK OF THIS SIZE?
	BNE CRITM2	;YES, GO USE IT
	TST (D)+	;ONE MORE TO FREE WHEN WE FINALLY FIND
			;A BLOCK BIGGER THAN WHAT WE REALLY WANTED
	CMP #ITMATB+400,C	;ARE WE ALREADY OFF THE TOP?
	BNE CRITM3	;NOPE, NOT YET
;IF WE GET HERE WE HAVE TO ALLOCATE A NEW BIG BLOCK
	TST ITMBAL	;IS SOMEONE ELSE ALREADY ALLOCATING?
	BEQ CRIT11	;NO, GO LOCK THE SWTICH
CRIT13:	JSR PC,SFLUSH	;WAIT FOR THE OTHER GUY TO BE DONE
	TST ITMBAL	;DONE YET?
	BNE CRIT13	;NOPE
	JSR PC,RUNME	;DONE, NOW  SEE IF HE LEFT ENGOUGH FOR US
CRIT16:	MOV ITMFRE,B	;HAVE TO GET ANOTHER ITEM
	BEQ CRIT12	;MAYBE OTHER PEOPLE TOOK THEM ALL
	BR CRITM8	;NOPE
CRIT11:	SAVE A		;LOCK SWTCH SO NO ONE ELSE GETS TO THIS CODE
	MOV #ITMBAL,A
	MOV #-1,B	;USE ALL THE BITS
	CLR C		;THE SWITCH IS INOT IN AN ITEM
	JSR PC,LCKASW	;IN CASE WE HANG WAITING FOR A BLOCK
	MOV #NITMBL,B	;FIND A FREE ITEM BLOCK SLOT
	MOV #ITMBST,C
CRIT10:	TST (C)+	;NEGATIVE INDICATES FREE
	BLT CRITM9	;FOUND ONE!
	SOB B,CRIT10	;KEEP TRYING
	JSR PC,LSWPOP	;LOSE, NO SPACE TO PUT ANOTHER BLOCK
	REST A
CRIT12:	REST <D,C>
CRITM1:	SEZ		;INDICATE FAILURE
	RTS PC
;NO, THIS ISN'T THE END OF THE ROUTINE!
CRITM2:	MOV (B),ITMFRE	;NOW THE ITEM POINTED TO BY THIS ONE IS
			;THE BEGINNING OF THE FREE LIST
	MOVB A,ITLNGT(B)	;SET IN THE LENGTH
	MOVB #ITACCD,ITACCS(B)	;AND THE ACCESS CODE
	SAVE <E,F>
	MOV -(C),E	;GET A POINTER TO THE NODE FOR THE FREE BLOCK
	MOV (E),(C)	;SPLICE OUT THIS NODE
	MOV 2(E),F	;ADDRESS OF THE BLOCK
	MOV F,(B)	;PUT IT AWAY IN THE ITEM
	MOV F,C		;COPY IT
	BIC #170000,F	;GET THE ADDRESS PART
	SAVE F		;AND SAVE IT FOR LATER
	TST D		;IS THERE ANY LEFTOVER?
	BEQ CRITM4	;NO, JUST GO FREE THE NODE
	TST -(D)	;CORRECT D, IT'S OVERENTHUSIASTIC
	MOV ITMATB(D),(E)	;PUT THE NODE INTO THE LIST FOR THE LEFTOVER SIZE
	MOV E,ITMATB(D)		;THERE!
	ADD A,2(E)	;ADD THE AMOUNT USED TO THE ADDRESS
	INC 2(E)	;SINCE ZERO IS ONE(?)
	BR CRITM5	;NOW GO USE WHAT WE GOT
CRITM4:	MOV ITMAFR,(E)	;LINK IT BACK TO THE FREE LIST
	MOV E,ITMAFR
	CLR 2(E)
CRITM5:	JSR PC,BITSET	;GRAB THE BLOCKS WE WANT
	TST (P)+	;FLUSH THE ADDRESS FROM THE STACK
	SUB #ITMTAB,B
	REST <F,E,D,C>
	CLZ
	RTS PC
CRITM9:	MOV (P),A	;GET LENGTH OF THING WE'RE ALLOCATING
	ASH #-4,A	;CHANGE TO 512 WORD BLOCKS
	CMP #3,A	;IS IT BIGGER THAN 2K?
	BLE .+6		;IF SO, USE IT
	MOV #3,A	;OTHERWISE, TRY FOR 2K
	JSR PC,ITMSEX	;EXPAND ITEM SPACE
	ASH #4,A	;CONVERT BACK TO 32 WORD UNITS
	ASH #4,B	;CONVERT TO AN AR-STYLE
	BIS #17,A	;CONVERT TO DR-STYLE
	JSR PC,LSWPOP
;DONE ALLOCATING CORE
	MOV B,-(C)	;B GETS THE ADDRESS
	SUB #ITMBST,C	;UN-RELATIVE IT
	MOV A,ITMBNF(C)	;A GETS THE NUMBER OF BLOCKS GOBBLED
	MOV ITMAFR,D	;GET AN ALLOCATE NODE
	BUGC NE		;THERE SHOULD ALWAYS BE ONE AVAILABLE
	MOV (D),ITMAFR	;SPLICE IT OUT OF THE FREE LIST
	SAVE C		;SAVE FOR LATER
	ASH #11.,C	;PUT IT INTO THE HIGH FOUR BITS
	ADD B,C		;COMBINE THE BLOCK ADDRESS AND THE BIG BLOCK NUMBER
	MOV C,2(D)	;AND SAVE IT IN THE NODE
	ASL A		;CONVERT SIZE OF BLOCK TO WORD OFFSET
	MOV ITMATB(A),(D)	;SPLICE THIS NODE
	MOV D,ITMATB(A)	;INTO LIST FOR THIS SIZE
	ASR A		;RESTORE A
	REST C		;GET THE INDEX INTO THE BLOCK VARIABLES
	MOV ITMBTP(C),C	;ADDRESS OF THE BIT TABLE FOR THIS BLOCK
	MOV C,D		;COPY POINTER TO BIT TABLE
	MOV #8.,B	;THERE ARE 8 WORDS
CRIT14:	MOV #-1,(C)+	;FIRST, SET ALL BLOCKS AS USED
	SOB B,CRIT14	;DO 8 TIMES
	INC A		;0 IS ONE BLOCK!
	ASH #-4,A	;COVERT TO 512 WORD BLOCKS
CRIT15:	CLR (D)+	;THERE WILL ALWAYS BE AT LEAST ONE
	SOB A,CRIT15	;DO UP TO 8 TIMES
	REST A
	JMP CRIT16	;NOW GO TRY THE WHOLE THING AGAIN!
;DELETE THE ITEM WHOSE ITEM NUMBER IS IN A
;A GETS CLOBBERED
;THIS MAKES NO ATTEMPT TO RETURN AN EMPTY BIG BLOCK
;THAT FEATURE SHOULD BE ADDED AS SOON AS POSSIBLE (PROBABLY) 
DLITEM:	JSR F,ACSAV
	CLR -(P)	;SAVE A STACK WORD FOR TEMP
	ADD #ITMTAB,A	;RELOCATE INDEX TO BE ACTUAL ADDRESS
	TSTB ITACCS(A)	;IS THIS ITEM FOR REAL?
	BUGC NE		;OOPS!
	MOV (A),E	;GET THE ADDRESS AND BLOCK # OF THE ITEM
	MOVB ITLNGT(A),(P)	;SAVE THE LENGTH ON THE STACK
	MOV ITMFRE,(A)	;PUT THE NEWLY-FREED NODE ON THE HEAD OF THE
	CLRB ITACCS(A)	;MARK IT AS FREE
	MOV A,ITMFRE	;FREE LIST. IT WON'T BE FREE LONG!
	INC (P)		;CORRECT FOR OFFSET
	MOV (P),F
	MOV E,A
	JSR PC,BITCLR	;CLEAR THE BITS OF THE BLOCK WE ARE FREEING
	MOV #-1,C	;NOW SEE IF THE SPACE BEFORE THE BLOCK IS FREE
	DEC E		;LOOK BEFORE THE BLOCK
	JSR PC,CNTFRE	;GO SEE IF THERE'S ANYTHING WE CAN FREE
	MOV E,F		;SAVE THE REAL BEGGING ADDRESS
	ADD (P),E	;GO TO THE END OF THE SO-FAR FREE BLOCK
	MOV #1,C	;NOW SEARCH FORWARD
	JSR PC,CNTFRE	;GO SEE IF ANYTHING THERE AND FREE WHATEVER YOU FIND
	MOV F,C		;GET THE REAL BEGGINING OF THE BLOCK
	JSR PC,BLKFRE	;FREE THE BLOCK WE HAVE FOUND
	TST (P)+	;FLUSH THE COUNT FROM THE STACK
	JSR F,ACRES
	RTS PC
;EXPAND OR CONTRACT ITEM WHOSE INDEX IS IN B
;TO THE SIZE IN A
;CLEAR Z IF SUCCESSFUL, OTHERWISE SET Z
EXITEM:	JSR F,ACSAV
EXITM4:	TSTB ITACCS+ITMTAB(B)	;IS THIS ITEM FOR REAL?
	BUGC NE		;OOOPS!
	CMPB A,ITLNGT+ITMTAB(B)	;WHAT IS THE RELATION OF THE DESIRED LENGTH
				;TO THE CURRENT LENGHT?
	BGT EXITM2	;NEED TO ADD MORE TO THE ITEM
	BEQ EXITM1	;THE ITEM IS ALREADY THE DESIRED LENGTH
			;GET HERE TO REMOVE EXTRA STUFF FROM ITEM
	MOVB ITLNGT+ITMTAB(B),F	;GET THE CURRENT LENGTH
	SUB A,F		;DIFFERENCE BETWEEN CURRENT AND DESIRED
	SAVE F		;SAVE THE NUMBER OF BLOCKS TO BE FREED
	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF THE ITEM
	MOVB A,ITLNGT+ITMTAB(B)	;SET THE NEW LENGTH INTO THE ITEM
	ADD A,E		;GET TO THE END OF THE DESIRED PART
	INC E		;CORRECT IT
	MOV E,A		;MAKE THE ROUTINE HAPPY
	JSR PC,BITCLR	;CLEAR THE NEWLY FREED AREA
	MOV E,F		;SAVE THE ADDRESS OF THE BLOCK WE ARE ABOUT TO FREE
	ADD (P),E	;END OF AREA WE KNOW TO BE FREE
	MOV #1,C	;SEARCH FORWARD
	JSR PC,CNTFRE	;LOOK FOR FREE BLOCKS AND FREE THOSE YOU FIND
	MOV F,C		;PUT ADDRESS OF BLOCK INTO THE RIGHT PLACE
	JSR PC,BLKFRE	;PUT FREE BLOCKS ON FREE LIST
	TST (P)+	;GET RID OF COUNT ON PDL
EXITM1:	JSR F,ACRES
	CLZ
	RTS PC
;CONTINUED NEXT WEEK (ACTUALLY, NEXT PAGE)
;GET HERE IF MORE SPACE NEEDED FOR ITEM
EXITM2:	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF START OF ITEM
	MOVB ITLNGT+ITMTAB(B),A	;GET CURRENT SIZE
	ADD A,E		;TO GET END OF CURRENT BLOCK
	INC E		;CORRECT IT
	MOV E,D		;NOW FIND WHICH BLOCK
	ASH #-11.,D
	BIC #177741,D	;WORD INDEX
	MOV #1,C	;NOW SEARCH FORWARD FOR FREE BLOCKS
	JSR PC,CNTBLK
	BLT EXITM3	;FORGET THIS IF THERE AREN'T ANY
	MOV (P),C	;GET THE DESIRED COUNT
	INC A		;CORRECT THE AMOUNT FOUND
	SUB A,C		;C=AMOUNT NEEDED-EXTRA FOUND
	MOVB ITLNGT+ITMTAB(B),F	;THE AMOUNT WE ALREADY HAVE
	CMP C,F		;WILL THE TOTAL BE ENOUGH?
	BGT EXITM3	;NO, FORGET IT
	ADD A,F		;YES, WHAT IS THAT TOTAL?
	MOVB F,ITLNGT+ITMTAB(B)	;THAT IS THE NEW ITEM LENGTH
	MOV A,F		;SAVE THE NUMBER OF BLOCKS WE ARE STEALING
	DEC A		;UNCORRECT IT
	JSR PC,FINDEL	;DELETE IT FROM THE FREE LIST
	MOV F,A		;GET THE COUNT BACK
	MOV E,C		;MAKE THE ROUTINE HAPPY
	SAVE E		;HAPPY!!??
	JSR PC,BITSET	;INDICATE THOSE BLOCKS IN USE
	TST (P)+	;GET RID OF THE GARBAGE
	MOV (P),A	;NOW, HOW MUCH DID WE REALLY WANT?
	MOV 2(P),B	;FOR WHAT ITEM?
	BR EXITM4	;GO FLUSH ANY EXTRA WE TOOK
;GET HERE IF THE BLOCK CAN'T BE EXPANDED NICELY
EXITM3:	MOV (P),A	;GET THE DESIRED SIZE
	JSR PC,CRITEM	;GET AN ITEM OF THE RIGHT SIZE
	BNE EXITM6	;GOT IT, GO USE IT
	JSR F,ACRES	;LOSE, RESTORE AC'S AND GET OUT
	SEZ
	RTS PC
;TO BE CONTINUED (NEXT PAGE)
EXITM6:	MOV B,A		;LOAD THE NEW ITEM INTO THE MAP
	JSR PC,ITM0PL	;PUSH AND LOAD
	MOV A,C		;SAVE THE ADDRESS IT WAS LOADED AT
	MOV 2(P),D	;THE ITEM WE WANT TO EXPAND (COPY)
	MOV D,A		;LOAD IT INTO THE MAP TOO
	JSR PC,ITM1PL	;PUSH AND LOAD
	MOVB ITLNGT+ITMTAB(D),F	;GET THE LENGTH OF THE OLD THING
	INC F		;CORRECT IT
	ASH #5,F	;CONVERT TO WORDS
	MOV (A)+,(C)+	;COPY THE BLOCK
	SOB F,.-2
	JSR PC,ITM0PO	;POP ITEM0
	JSR PC,ITM1PO	;POP ITEM1
	MOV B,A		;SAVE THE NEW ITEM INDEX
	ADD #ITMTAB,D	;MAKE AN ACTUAL ADDRESS
	ADD #ITMTAB,B
	MOV #ITMTEL/2,F	;NUMBER OF WORDS TO EXCAHNGE
EXITM5:	MOV (B),E
	MOV (D),(B)+
	MOV E,(D)+
	SOB F,EXITM5	;EXCAHNGE OLD AND NEW ITEMS
	JSR PC,DLITEM	;DELETE THE NEW ITEM SLOT WITH THE OLD ITEM CONTENTS!!
	BR EXITM1	;RETURN SUCESSFULLY, IF SOMEWHAT WEARILY


;CLEAR ITEM WHOSE INDEX IS IN B
;IT'S LENGTH IS IN A. IT IS ALSO LOADED INTO ITEM0
;AND ITEM0'S PDL IS PUSHED. A IS CLOBBERED TO THE ADDRESS OF THE ITEM
CLITEM:	SAVE C		;FOR THE WORD COUNT
	MOV A,C		;THE BLOCK COUNT
	INC C		;CORRECTED
	ASH #5,C	;CONVERT TO WORDS
	MOV B,A		;THE ITEM TO CLEAR
	JSR PC,ITM0PL	;GETS LOADED
	ADD C,A		;POINT A TO THE END OF THE ITEM
	ADD C,A		;SINCE C IS A WORD COUNT
	CLR -(A)	;CLEAR TE ITEM, CORRECTING A
	SOB C,.-2	;CLEAR ALL THE WORDS
	REST C
	RTS PC
;SET THE BITS IN THE ITEM BLOCK BIT TABLE
;THE STARTING ADDRESS IS EXPECTED IN C AND 2(P)
;THE COUNT OF BLOCKS (UNCORRECTED) IS EXPECTED IN A (IT SHOULD NOT BE -1)
;CLOBBERS C,D,E AND F
BITSET:	ASH #-11.,C	;GET THE BIG BLOCK NUMBER
	BIC #177741,C
	DEC ITMBNF(C)	;CORRECT FOR 0=1
	SUB A,ITMBNF(C)	;THAT MANY FEWER BLOCKS AVAILABLE
	MOV 2(P),E	;GET THE ADDRESS BACK
	BIC #170000,E	;CLEAR BIG BLOCK BITS
	MOV A,D		;AND A COUNT WE CAN MUNGE
	SUB ITMBST(C),E	;CONVERT TO BLOCK WITHIN BIG BLOCK
	ASHC #-3.,E	;FIGURE IT OUT YOURSELF
	ASH #-13.,F
	BIC #177770,F
	ADD ITMBTP(C),E	;MAKE IT POINT INTO THE BIT TABLE
	INC D		;SINCE 0=1
BITST1:	BISB BMT(F),(E)	;SET THE BIT
	INC F		;CHANGE THE BIT NUMBER
	BIT #7,F	;HAVE WE JUMPED A BYTE?
	BNE BITST2	;NOT YET
	CLR F		;NEW BIT NUMBER
	INC E		;AND NEW BYTE NUMBER
BITST2:	SOB D,BITST1	;DO FOR HOWEVER MANY LITTLE BLOCKS
	RTS PC
;CLEAR BITS IN THE BIT TABLE FOR THE ITEM BLOCK
;EXPECTS THE STARTING ADDRESS IN A AND THE COUNT (CORRECTED) IN F
;CLOBBERS A,B,D AND F
BITCLR:	MOV A,D		;COPY IT
	ASH #-11.,D	;TO GET THE BLOCK #
	BIC #177741,D	;CLEAR BITS THAT MAY BE SET BY ASH
	BIC #170000,A	;GET RID OF THE BLOCK NUMBER
	SUB ITMBST(D),A	;AND MAKE RELATIVE TO START OF BLOCK
	ASHC #-3,A	;KNOCK THE BIT ADDRESS OFF THE END
	ASH #-13.,B	;AND PUT IT IN IT'S PLACE
	BIC #177770,B	;OH FOR A LSH!
	ADD ITMBTP(D),A	;ADDRESS IN THE BIT TABLE
	ADD F,ITMBNF(D)	;MORE FREE SPACE!
;THIS IS WHERE THE RETURN BIG BLOCK STUFF SHOULD GO
BITCL1:	BICB BMT(B),(A)	;THIS BLOCK NOW FREE
	INC B		;GO TO NEXT BIT ADDRESS
	BIT #7,B	;TO NEXT BYTE?
	BNE BITCL2	;NOT YET
	CLR B		;ZEROTH BIT
	INC A		;IN THE NEXT BYTE
BITCL2:	SOB F,BITCL1	;CLEAR UNTIL DEAD
	RTS PC
;PUT AN ENTRY ON THE APPROPRIATE FREE LIST FOR THE BLOCK WE HAVE FREED
;EXPECTS THE COUNT (CORRECTED) ON 2(P), THE ADDESS OF THE BLOCK IN C
;CLOBBERS A AND B
BLKFRE:	MOV 2(P),A	;AND IT'S LENGTH
	DEC A		;SIGH
	ASL A		;CONVERT THE LENGTH INTO A WORD INDEX
	ADD #ITMATB,A	;NOW, THE ADDRESS IN THE ALLOCATE TABLE
	MOV ITMAFR,B	;GET THE FIRST FREE ALLOCATE NODE
	BUGC NE		;WE SHOULD NEVER RUN OUT OF THESE!
	MOV (B),ITMAFR	;SPLICE IT OUT
	MOV (A),(B)	;SPLICE INTO THE LIST FOR THIS SIZE BLOCK
	MOV B,(A)	;AND FIX THE POINTER TO THE LIST
	MOV C,2(B)	;FINALLY, THE LOCATION OF THE NEWLY FREED BLOCK
	RTS PC


;THIS ROUTINE IS SPECIAL FOR DLITEM
;IT FINDS FREE SPACE A TACKS IT ON TO EXISTING FREE SPACE
;NOTE THAT THE WORD AT 2(P) IS EXPECTED TO CONTAIN THE COUNT
;OF BLOCKS THAT HAVE BEEN FOUND TO BE FREE
;CLOBBERS A AND B ADDS THE NUMBER OF BLOCKS IT FINDS TO 2(P)
CNTFRE:	JSR PC,CNTBLK	;AND IF SO, HOW MUCH?
	BLT CNTFR1	;NONE FREE THERE!
	ADD A,2(P)	;SOME THERE, ADD TO PREVIOUS AMOUNT
	INC 2(P)	;SIGH
FINDEL:	JSR PC,FINBLK	;FIND THE BLOCK THAT IS FREE
DELBLK:	MOV (A),(B)	;SPLICE THE NODE OUT OF THE LIST
	MOV ITMAFR,(A)	;AND PUT THE FREED NODE ON THE FREE LIST
	MOV A,ITMAFR	;NEW START OF FREE LIST
CNTFR1:	RTS PC
;FIND A BLOCK OF A PARTICULAR SIZE THAT BEGINS AT A CERTAIN LOCATION
;SIZE IN A
;LOCATION IN E
;POINTER TO NODE IS RETURNED IN A
;POINTER TO PREVIOUS NODE IS RETURNED IN B
;(IT IS A BUG FOR THERE TO BE NO SUCH BLOCK!!!)
FINBLK:	ASL A		;CONVERT THIS INTO A POINTER
	ADD #ITMATB,A	;INTO THE ALLOCATE VECTOR
FINBL1:	MOV A,B		;THE OLD ONE
	MOV (A),A	;THE ONE IT POINTS TO
	BUGC NE		;MUST BE THERE!!
	CMP 2(A),E	;IS THIS THE ONE?
	BNE FINBL1		;NOPE
	RTS PC		;YES, WE'RE ALL SET
;FIND HOW MANY BLOCKS ARE FREE STARTING AT A GIVEN BLOCK AND
;LOOKING IN A GIVEN DIRETION
;E CONTAINS THE ABSOULUTE BLOCK NUMBER
;D CONTIANS THE INDEX OF THE BLOCK IT IS IN
;C CONTAINS THE DIRECTION (1=> FORWARD, -1=> BACKWARDS)
;A GETS -1 OR THE LENGTH OF WHAT'S FOUND
;CONDITON CODES ARE SET BY TST A, I.E. N IS CLEAR IF ANYTHING FOUND
;E GETS THE ADDRESS OF THE FIRST BLOCK IN THE CHUNK
CNTBLK:	SAVE <F,B,E>
	MOV #-1,A	;THE INTIAL COUNT
	BIC #170000,E	;GET RID OF BLOCK #
	SUB ITMBST(D),E	;MAKE IT RELATIVE TO START OF BLOCK
	BLT CNTBL2	;NO BLOCKS BEFORE BLOCK!
	ASHC #-4,E	;GET THE BIT NUMBER
	ASH #-12.,F	;AND THE WORD NUMBER
	BIC #177760,F	;MAKE SURE THE BIT NUMBER IS RIGHT
	ASL E		;MAKE A WORD ADDRESS
	MOV #1,B	;THE FIRST BIT
	ASH F,B		;SHIFT BY THE BIT NUMBER
	ADD ITMBTP(D),E	;THE REAL BIT TABLE ADDRESS
CNTBL1:	BIT B,(E)	;IS THIS ONE FREE?
	BNE CNTBL2	;THEN WE'RE DONE
	INC A		;ANOTHER ONE FREE
		;SHIFT ONE WAY OR THE OTHER
	CLC		;CLEAR THE WAY FOR THE ROTATES
	TST C		;WHICH WAY?
	BLT CNTBL4	;RIGHT
	ROL B		;LEFT
	BR CNTBL5
CNTBL4:	ROR B		;RIGHT
CNTBL5:	BNE CNTBL1	;NOT DONE WITH WORD YET
	ADD C,E		;ADJUST ADDRESS
	ADD C,E		;IT IS A WORD ADDRESS
	MOV #1,B	;RESET THE BIT
	TST C		;UNLESS WE ARE LOOKING BACKWARDS
	BGT CNTBL1	;NOPE, FORWARDS
	MOV #100000,B	;OOPS, BACKWARDS
	BR CNTBL1
CNTBL2:	REST E
	TST C		;THIS IS OK FOR FORWARDS SEARCH
	BGT CNTBL3
	SUB A,E		;BUT MUST BE CORRECTED FOR BACKWARD
CNTBL3:	REST <B,F>
	TST A		;TO SET THE CONDITION CODES
	RTS PC
.SBTTL .RDMAP AND .MAP
;.RDMAP => READ THE MAP OF A SPHERE INTO THE USERS CORE.
;FIRST ARGUMENT IS THE SPHERE CAPABILITY OF THE MAP TO READ
;SECOND ARGUMENT IS A POINTER INTO THE USERS CORE, WHERE TO PUT
;MAP INFO.  IT RETURNS 16 WORDS IN THE FOLLOWING FORMAT.
;BOTTOM 3 BITS ARE THE LENGTH OF THE PAGE., THE TOP BIT IS D=I, NEXT IS ABS
;NEXT IS FILE PAGE BIT.
ERDMAP:	JSR PC,RETNSW		;GET THE SPHERE CAPABILITY
	MOV A,B			;COPY IT
	BIC #177400,B		;CLEAR THE EXTRA BITS
	MOV ITM1A,A		;THE CURRENT SPHERE
	JSR PC,GCLSTA		;FIND THE CPABILITY
	BEQ RDMAP1		;FAILED
	ADD A,B			;POINT TO THE CAPABILITY DIRECTLY
	CMPB (B),#.MSCAP	;IS IT A MS CAPABILITY
	BEQ RDMAP2		;YES, EVERYTHING IS OKAY
	CMPB (B),#.SPCAP	;IS IT A SPHERE CAPABILITY
	BEQ RDMAP2		;YES, IT IS OKAY SO FAR
RDMAP1:	JMP ERETSZ		;FAILED
RDMAP2:	BIT #.SPCRR!.SPCRW,(B)	;DOES HE HAVE ACCESS
	BEQ RDMAP1		;NO
	MOV 2(B),A		;THE SPHERE TO READ THE MAP FROM
	JSR PC,ITM2LD		;LOAD IT UP
	JSR PC,RETNSW		;GET THE POINTER INTO HIS CORE
	MOV #20,B		;THE NUMBER OF WORDS WE ARE RETURNING
	MOV A,C			;COPY IT
RDMAP3:	MFPD (A)		;MAKE SURE ALL THE WORDS ARE WRITABLE
	MTPD (A)+
	SOB B,RDMAP3
	MOV ITM2A,A		;POINTER TO THE UPTS
	MOV #20,B		;NUMBER OF THEM
	ADD #SUPTS,A		;POINT TO THE UPT'S DIRECTLY
RDMAP4:	MOV (A),D		;THE REFERENCED ENTRY
	BPT			;HERE NEED TO TRANSLATE NEW FORMAT INTO USER FRMAT
RDMAP5:	SAVE D			;THE INFO WORD
	MTPD (C)+		;RETURN IT TO HIM	
	ADD #UPTLEN,A		;POINT TO THE NEXT ONE
	SOB B,RDMAP4		;DO ALL THE PAGES
	JMP ERETCZ		;DONE
;.MAP
;CREATE A PAGE FOR A SPHERE,
;THE FIRST BYTE IS THE SPHERE CAPABILITY TO THE DESTINATION SPHERE
;THE SECOND IS THE ACCESS INFO (READ, WRITE, AND PRIVATE OR PUBLIC COPY)
;THE THIRD IS THE SOURCE OF THE PAGE
;(FILE ACCESS CAP. OR SPHERE CAP, -1 FOR FRESH PAGE, -2 FOR ABSOLUTE PAGE,
;OR -3 FOR JUST DELETE THIS PAGE)
;THE FOURTH IS THE UPT NO. OF THE PAGE TO CREATE
;(0-7 UPT NO. IS I SPACE, 10-17 IS D-SPACE, 20-27 IS I=D SPACE)
;THE FIFTH AND SIXTH ARE THE PAGE NO. IN SOURCE (IF FILE)
;THE SEVENTH IS THE START OF THE PAGE (IN 512. WORD BLOCKS)
;THE EIGHTH IS THE LENGTH-1"  "    "    "  "   "      " 
;IF IT IS A REQUEST FOR A PUBLIC PAGE, AND IT IS PART OF A FILE AND HE
;IS ASKING FOR WRITE ACCESS, CLEAR THE BYTE AND WORD LEFT FLAGS IN MFI
;IF IT IS ANOTHER SPHERE, AND IT IS A REQUEST FOR A PUBLIC PAGE, AND HE
;IS ASKING FOR WRITE ACCESS, EXPAND THE PAGE, AND LINK THE UPT'S TOGETHER
EMAP:	SUB #10,P	;MAKE 4 STORAGE CELLS
	MOV P,D		;GET POINTER TO THE STORAGE
	MOV #4,B	;THE NUMBER OF ARGS
EMAP1:	JSR PC,RETNSW	;GET THE SPHERE CAP AND FLAGS
	MOV A,(D)+	;SAVE IT
	SOB B,EMAP1
	MOV (P),B	;THE SPHERE CAP
	BIC #177400,B	;CLEAR THE EXTRA BITS
	MOV ITM1A,A	;THE ADDRESS OF THE ITEM
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	ERRORC EQ,BCN
	ADD B,A		;MAKE A POINT TO THE SPHERE CAP
	MOV (A),B	;GET THE TYPE AND FLAGS
	ERRORC EQ,BCN
	CMPB B,#.SPCAP	;IS IT A SPHERE CAPABILITY
	BEQ EMAP3	;YES
	CMPB B,#.MSCAP	;IS IT A MASTER SPHERE CAPABILITY
	BEQ EMAP3	;YES
	ERROR BCT	;BAD CAPABILITY TYPE
EMAP3:	BIT #.SPCRW,B	;IS HE ALLOWED TO MODIFY THE CORE MAP?
	ERRORC EQ,BAC	;BAD ACCESS
	MOVB 3(P),B	;THE UPT NO.
	CMP B,#30	;IS IT A LEGAL PAGE
	ERRORC HIS,BPN	;BAD PAGE NUMBER
	CMP B,#20	;IS IT I=D
	BLT .+6		;NO
	SUB #10,B	;MAKE IT POINT TO THE D PAGE
	ASH #10.,B	;SET IT INTO CORRECT PLACE
	MOV CLSEPI(A),F	;THE SPHERE AFFECTED
	ASH #-2,F	;ITEMS ARE MULTIPLES OF 4
	BIS B,F		;MAKE A GIP
	BIS #GIPSPR!GIPBIT,F
	MOV F,B		;GIP TO THE UPT TO DELETE
	CMPB 2(P),#-4	;IS IT A PAGE EXPAND REQUEST?
	LBR EQ,PAGEXP	;YES
	BITB #20,3(P)	;IS IT I=D
	BEQ EMAP4	;NO JUST DELETE CURRENT PAGE
	JSR PC,UPTDL	;DELETE IT
	SUB #<10_10.>,F	;MAKE IT POINT TO THE I UPT
	MOV F,B		;COPY IT AGAIN

EMAP4:	JSR PC,UPTDL	;DELETE THE UPT
	MOVB 2(P),B	;THE SOURCE
	CMP B,#-3	;IS IT REQUEST FOR JUST FLUSHING PAGE
	LBR EQ,EMAPRT	;JUST RETURN
	MOV (P),A	;THE ACCESS
	BIC #377,A	;CLEAR THE LOW BYTE
	CLR E		;IN CASE THERE IS NO ACCESS
	BIT #.CRRD,A	;ASKING FOR READ ACCESS
	BEQ .+6		;NO,
	MOV #UPTRDO!UPTEXB,E	;SAY READ ONLY ACCESS
	BIT #.CRWRT,A	;ASKING FOR WRITE ACCESS
	BEQ .+6		;NO
	MOV #UPTEXB,E	;SAY WRITE ACCESS
	BIT #.CREX,A	;ASKING FOR EXECUTE ONLY ACCESS
	BEQ EMAP5	;NO
	CMPB 3(P),#10	;BETTER BE AN I SPACE PAGE
	ERRORC LT,BAC	;BAD ACCESS
EMAP5:	TSTB B
	BGE EMAP6	;ITS A CAPABILITY
	MOVB 6(P),D	;THE START
	ERRORC LT,BAD	;BAD: NEGATIVE START
	MOVB 7(P),C	;THE LENGTH OF THE BLOCK TO CREATE
	ERRORC LT,BAD	;NO NEGATIVE LENGTHS
	ADD C,D		;GET THE SUM OF THE LENGTH AND START
	ERRORC VS,BAD	;OVER FLOW
	CMP D,#10	;IS THE SUM OF THE START AND LENGTH OVER 10
	ERRORC GE,BAD	;YES, LOSE LOSE
	CMP B,#-1	;IS IT A REQUEST FOR A FRESH PAGE
	LBR EQ,MAPFRS	;YES
	CMP B,#-2	;IS IT REQUEST FOR ABSOLUTE PAGE
	BEQ MAPABS	;GET AN ABSOLUTE PAGE
	ERROR BFUN
EMAP6:	MOV ITM1A,A	;GET THE ADDRESS
	JSR PC,GCLSTA	;GET THE OFFSET OF THE CAPABILITY
	ERRORC EQ,BCN	;COULDN'T GET IT
	ADD B,A		;MAKE A POINT DIRECTLY TO IT
	MOV (A),B	;THE FLAGS WORD OF THE CAPABILITY
	ERRORC EQ,BCN	;NO CAPABILITY
	CMPB B,#.FACAP	;IS IT A FILE ACCESS CAPABILITY
	BEQ MAPFIL	;YES
	CMPB B,#.DSCAP	;IS IT A DISPLAY CAPABILITY
	LBR EQ,MAPDS	;YES
	CMPB B,#.SPCAP	;IS IT A SPHERE
	BEQ MAPSPR	;YES
	CMPB B,#.MSCAP	;IS IT A MASTER SPHERE
	ERROR BCT
MAPSPR:	CMP 4(P),#17	;IS HE ASKING FOR A LEGAL PAGE?
	ERRORC HI,BAD	;NO	
	MOV 2(A),A	;GET THE SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	ADD #SUPTS,A	;POINT TO THE FIRST UPTS
	MOV 4(P),D	;THE PAGE NO.
	MUL #UPTLEN,D	;GET THE LENGTH OF THE OFFSET
	ADD D,A		;POINT TO THE UPT IN SPHERE
	MOV F,B		;POINTER TO PAGE TO CREATE
	JSR PC,UPTPLD	;LOAD IT UP
	MOV #UPTLEN/2,C	;THE LENGTH IN WORDS
	MOV B,D		;COPY POINTER TO UPT
	MOV (A)+,(D)+	;COPY UPT
	SOB C,.-2
	BIC #UPTDEI!UPTIED,-UPTLEN(D)	;DONT WANT THE NEW PAGE D=I UNLESS HE ASKS
	MOV -UPTLEN+UPTGIP(A),-UPTLEN+UPTGIP(D)
	MOV F,-UPTLEN+UPTGIP(A)	;MAKE COPIED POINT TO THE COPY
	JSR PC,ITM1PO	;POP THE SPHERE WE COPIED
MAPSP1:	JMP MAPFR2	;TAKE CARE OF I=D, ETC.	
MPSPRI:	BPT
MAPABS:	BIT #UPTRDO,E	;HAD BETTER BE READ ONLY
	ERRORC EQ,BAC
	CMP C,#7
	ERRORC HI,BAD
	SWAB C		;GET IT INTO THE RIGHT BITS
	ASH #4,C
	BIS #1,C		;SET IN ACCESS
	MOV 4(P),A	;THE START IN 512. WORDS BLOCKS
	CMP #256.,A	;HIGHER THAN THE HIGHEST BLOCK?
	ERRORC LOS,BAD
	ASH #4,A	;PUT IT INTO THE CORRECT BITS
	MOV F,B
	JSR PC,UPTPLD	;LOAD THE UPT
	MOV #UPTABS!UPTEXB!UPTRDO,(B)+
	MOV A,(B)+	;SET IN UPTAR
	MOV C,(B)+	;SET IN UPTDR
	JMP MAPFR2	;CHECK FOR I=D, ETC.
	

;HERE SET UP THE DISPLAY'S PAGES AS ABSOLUTE PAGES
MAPDS:	MOV 2(A),C	;THE ITEM OF THE DISPLAY
	MOV F,B		;THE PLACE TO PUT IT
	JSR PC,UPTPLD	;LOAD IT UP
	MOV B,D		;COPY POINTER TO UPT
	MOV #UPTABS!UPTEXB,(D)+
	MOV ITMTAB(C),(D)+	;SET IN THE AR
	MOV ITMTAB+ITACCS(C),(D)	;SET IN THE DR
	BIC #17,(D)	;CLEAR THE ACCESS
	MOV #6,C	;READ ONLY
	BIS E,-4(D)	;FOR THE RECORD, SET THIS
	MOV #1,C	;THIS WILL BE THE ACCESS
MAPDS1:	JMP MAPFR2	;TAKE CARE OF D=I ETC.
;A POINTS TO THE FA CAP.
;F IS GIP TO THE UPT TO CREATE
;E HAS ACCESS REQUESTED
;ASSUMES THE POSITION OF THE READ WRITE ACCESS BITS IS SAME IN SPHERE AND FA CAP
MAPFIL:	BPT		;HAVEN'T HACKED THIS YET
.IFZ 105
	SAVE <E,F>
	MOVB 13(P),E		;THE LENGTH
	BGE MAPFL4		;ORDINARY LENGTH
	CMP E,#-1		;IS IT A REQUEST FOR ALL THE BLOCKS ON THE PAGE
	BEQ MAPFL4		;YES, IT IS OKAY
	ADD #4+10,P		;POP OFF THE ARGUMENTS AND PUSHED E AND F
	JMP ERETSZ		;LOSE
MAPFL4:	MOVB 12(P),C		;THE START
	SWAB C
	ASL C
	ASL C			;MAKE IT INTO A BYTE COUNT
	SAVE C			;FAKE A CAP
	CLRB (P)		;CLEAR LOW BITS
	CLR -(P)		;NO FUPT YET
	MOVB 14(P),-(P)		;GET THE PAGE NUMBER
	CLRB 1(P)		;CLEAR THE TOP BYTE
	SAVE <FAMFI(A),(A)>	;COPY REST OF CAPABILITY
	MOV P,D			;POINTER TO CAPABILITY
	BIT #.CRPRI,16(P)	;IS THIS REQEST FOR PRIVATE PAGE
	BEQ MAPPUB		;NO JUST MAKE IT A PUBLIC PAGE
	MOV FAMFI(A),A
	JSR PC,ITM2LD		;LOAD MFI
	JSR PC,MFMFPT		;MAKE SURE THERE IS AN FPT FOR THAT PAGE
	LBR EQ,MAPFL1		;FAILED
	ADD #12,P		;POP OFF FAKE CAPABILITY
	MOVB 13(P),B		;THE LENGTH
	JSR PC,SWPAL		;ALLOCATE SWAP SPACE
	LBR EQ,MAPNSS		;NO SWAP SPACE
	MOV #LPCLRT,A		;RUN A ROUTINE IF PCLOSERED
	MOV B,C			;SAVE THE SWAP SPACE
	CLR B			;NO ITEM
	JSR PC,LOCKSW		;GET A SWITCH
	MOV #MFPCL4,LCKWD1(A)	;RUN A ROUTINE TO DEALLOCATE SWAP SPACE IF PCLOSERED
	MOV C,LCKWD2(A)		;THE SWAP ADDRESS
MAPPR1:	MOV PFPTFR,A		;GET A PFPT
	BNE MAPPR2		;GOT ONE
	MOV #PFPTFR,A		;POINTER TO FREE LST
	JSR PC,MFLUSH		;WAIT FOR ONE TO APPEAR
	BR MAPPR1
MAPPR2:	MOV (A),PFPTFR		;LINK IT OUT
	MOV C,PFPSWA(A)		;SET IN THE SWAP ADDRESS
	SEC			;TO SET THE TOP BIT
	ROR E			;MAKE IT INTO A FPT POINTER
	MOV E,PFPPTR(A)		;SET IN THE FPT POINTER
	ASL E			;GET IT BACK INTO A ABSOLUTE ADDRESS
	INC FPTREF(E)		;ONE MORE PFPT
	SEC
	ROR A			;CHANGE PFPT POINTER TO LOOK LIKE FPT POINTER
	MOV A,D			;SAVE IT
	MOV FPTMFI(E),A		;THE MFI
	JSR PC,ITM2LD		;LOAD IT UP
	INC MFREF(A)		;INCREMENT THE REFERENCE COUNT
	MOVB 13(P),C		;THE LENGTH
	BGE MAPPR3		;SPECIAL PROCESSING IF NEGATIVE
	ADD #FPTSRC+20,E
	MOV #7,C		;COUNT OF BLOCKS EXISTING ON FIRST PAGE
	TST -(E)		;NOW BACK UP LOOKING FOR EXISTING BLOCK
	BNE .+4
	SOB C,.-4		;KEEP BACKING UP
MAPPR3:	REST <F,E>		;THE ACCESS AND POINTER TO WHO IT BELONGS
	SAVE D			;MAPSSP EXPECTS THE SWAP ADDRESS ON THE STACK
	JMP MAPSS1		;SET UP THE UPT, WITH THE PFPT POINTER AS SWAP ADDRESS

MAPPUB:	CLR F			;DONT WANT IT SWAPPED IN PARTICULARLY
	JSR PC,DKURIO		;GET THE CREATE A FUPT FOR IT
				;(CREATES IT WITH THE MAXIMUM ACCESS)
	BEQ MAPFL1		;ANY DISK ROUTINE ERRORS?
	MOV FAMFI(D),A		;POINTER TO MFI
	JSR PC,ITM2PL		;LOAD IT UP
	INC MFREF(A)		;INCREMENT MFI'S REFERENCE COUNT
	MOV FAUPT(D),B		;THE FUPT POINTER
	ADD #10,P		;POP OFF THE CAPABILITY
	MOV B,(P)		;FANCY SAVE OF B
	JSR PC,UPTLD		;LOAD IT UP, BETTER BE A FUPT
	MOV B,D			;COPY POINTER TO FUPT
	MOV 2(P),B		;POINTER TO THE UPT TO CREATE
	JSR PC,UPTLD		;MAKE B POINT TO IT
	SAVE B			;SAVE POINTER TO IT
	MOV #UPTLEN/2,C		;NUMBER OF WORDS IN UPT
	MOV (D)+,(B)+		;COPY THE UPT
	SOB C,.-2
	MOV 2(P),B		;POINTER TO THE FUPT
	JSR PC,UNLNK		;UNLINK THE UPT
	MOV 2(P),D		;THE FUPT POINTER
	ADD #<100000+FUPTTB>,D	;MAKE IT ABSOLUTE

	MOV FUPTFR,(D)		;LINK IT ONTO FREE LIST
	MOV D,FUPTFR
	REST (P)		;CRUNCH FUPT POINTER
	TST C			;ARE THERE ANY LEFT
	BNE MAPFL2		;YES, JUST LINK THIS ONE IN
	REST B			;GET BACK POINTER TO THE UPT
	MOV (P),UPTCLP(B)	;MAKE IT POINT TO ITSELF
	BR MAPFL3		;DONE FIXING IT UP
MAPFL2:	MOV C,B			;A UPT IN THE CIRCULAR LIST
	JSR PC,UPTPLD		;LOAD IT UP
	MOV UPTCLP(B),D		;GET THE THING IT POINT TO
	MOV 2(P),UPTCLP(B)		;MAKE IT POINT TO THE NEW UPT
	JSR PC,ITM2PO		;POP THE ITEM
	REST B			;POINTER TO THE UPT CREATED
	MOV D,UPTCLP(B)		;CIRCULAR LIST ALL SET UP
MAPFL3:	MOV UPTFPT(B),E		;THE FPT POINTER
	ASL E			;MAKE IT ABSOLUTE
	MOV (P),FPTUPT(E)	;SET IN THE NEW UPT POINTER
	REST <F,E>
	BR MAPFR2		;TAKE CARE OF IT IF IT IS D=I
MAPFL1:	ADD #12+10+4,P	;POP OFF CAPABILITY,E,F, AND ARGUMENTS
	JMP ERETSZ	;LOSER
MAPNSS:	ADD #10,P	;POP OFF ARGS
	MOV #.FANSS,ITM0AD+PERRW	;NO SWAP SPACE
	JMP ERETSZ	;FAILED
.ENDC

MAPFRS:	MOV C,B		;THE SIZE OF THE PAGE
	JSR PC,PBGET	;GET A PAGE BLOCK FOR THE NEW PAGE
	JSR PC,FINSWP	;TRY TO FIND SOME SWAP SPACE FOR IT
	BNE MAPFR1	;GOT SOME
	JSR PC,FRELSE	;FREE THE PB, WE LOST
	ERROR NSS	;NO SWAP SPACE
MAPFR1:	SAVE B		;SAVE POINTER TO PB
	MOV F,B		;THE GIP TO THE PAGE BEING CREATED
	JSR PC,UPTPLD	;LOAD IT UP
	MOV #UPTEXB,(B)	;FLAGS
	REST A
	MOVB PBLEN(A),UPTSTL(B)	;COPY THE LENGTH
	MOV A,UPTPBP(B)	;GET THE PB POINTER
	MOV F,UPTGIP(B)	;POINT TO YOURSELF
MAPFR2:	BIS E,(B)	;SET IN THE ACCESS
	MOVB 3(P),C	;GET THE PAGE NO. AGAIN
	CMP C,#20	;IS IT A D=I PAGE
	BLT MAPFR1	;NOPE
	MOV B,D		;COPY POINTER TO UPT
	MOV B,E		;AND A POINTER TO THE DATA HALF
	ADD #<UPTLEN*10>,E	;INTO THE SECOND HALF
	MOV #UPTLEN/2,C	;THE LENGTH OF THE UPT
	MOV (D)+,(E)+	;COPY THE UPT ENTRY
	SOB C,.-2	;COPY ALL THE WORDS
	SUB #UPTLEN,E	;MAKE IT POINT AT THE NEW ONE AGAIN
	BIS #UPTIED,(B)	;ON THIS HALF, DATA=I	
	BIS #UPTDEI,(E)	;AND ON THIS HALF, THE OPPISTIE
	MOV F,A		;COPY GIP TO DATA HALF
	BIS #20000,F	;MAKE IT POINT TO THE TOP HALF
	MOV F,UPTGIP(B)	;POINT FIRST HALF AT SECOND
	JSR PC,ITM2PO	;POP THE SPHERE
EMAPRT:	ADD #10,P	;POP OFF THE ARGUMENTS
	BIC #GIPITM,F	;CLEAR ALL BUT THE SPHERE NO.
	ASH #2,F	;SHIFT ITEM NUMBER
	CMP F,CURSPH	;DID WE CHANGE THIS SPHERE'S PAGES?
	BNE MAPFR3	;NO DON'T WORRY ABOUT IT
EMAPR1:	JSR PC,SAVAWB	;SAVE CURRENT A&W BITS
	JSR PC,MAPRES	;MAKE SURE HIS MAP GETS MODIFIED IMMEDIATELY
MAPFR3:	JMP ERETCZ	;SUCESS

PAGEXP:	BPT		;HAVEN'T GOTTEN THIS FIXED YET
.IFZ 105
	CMPB #20,3(P)	;I=D
	BGT PAGEX1	;NO
	SUB #<10_10.>,F	;TURN IT TO POINT TO I PAGE
	MOV F,B		;GET THE GIP
	JSR PC,UPTLD	;LOAD IT UP
	BIT #UPTDEI,(B)	;IS IT D=I PAGE
	BNE PAGEX2	;YES, EVERYTHING IS FINE
EXPFAL:	JMP BADEMT	;FAIL MISERABLY
PAGEX1:	MOV F,B		;THE GIP TO THE PAGE
	JSR PC,UPTLD	;LOAD IT
	BIT #UPTDEI,(B)	;IS IT D=I
	BNE EXPFAL	;YES THIS FAILES
PAGEX2:	TST UPTFPT(B)	;IS IT SWAP PAGE
	BMI EXPFAL	;THIS SHOULD BE CHANGED LATER TO EXPAND FILE PAGES
	MOVB 6(P),C	;THE START
	BLT EXPFAL	;NEGATIVE (BLETCH)
	MOVB 7(P),D	;GET THE LENGTH
	BLT EXPFAL	;NEGATIVE?
	ADD C,D		;GET COMBINED START AND LENGTH
	CMP D,#10	;IS IT TO LARGE
	BGE EXPFAL	;FAILED
	SAVE D		;SAVE TOTAL END
	MOV UPTAR(B),C	;GET THE MASTER LENGTH AND START
	MOV C,D		;COPY IT
	BIC #UPMSSW,C	;CLEAR EXTRA BITS
	BIC #UPMLSW,D	;DITTO FOR LENGTH
	SWAB D		;INTO THE RIGHT BITS
	ASH #-4,D
	ADD C,D		;GET THE TOTAL END
	CMP D,(P)+	;IS MASTER END LESS THAN THE NEW END?
	BLT PAGEX5	;YES, NEED NEW SWAP SPACE
	CMPB C,6(P)	;IS MASTER START < NEW START
	BLE PAGEX3	;YES, NO NEED TO CHANGE SWAP AREA
	BIT #UPTLSB,UPTFPT(B)	;IS IT ALREADY LARGE SWAP AREA?
	BNE PAGEX3	;YES, CURRENT SWAP AREA IS LARGE ENOUGH
PAGEX5:	SAVE UPTFPT(B)	;THE SWAP SPACE TO FREE
	JSR PC,SWPAL	;ALLOCATE SWAP SPACE
	MOV #LPCLRT,A	;RUN ROUTINE TO FREE SWAP SPACE IF PCLOSERED
	SAVE B		;THE SWAP SPACE POINTER
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;LOCK A SWITCH
	MOV #MFPCL4,LCKWD1(A)	;FREE THE SWAP SPACE
	MOV (P),LCKWD2(A)	;THE SWAP SPACE TO FREE
	MOV F,B		;GET POINTER TO PAGE
	JSR PC,SWPIN	;SWAP IT IN
	;DROPS INTO NEXT PAGE
	;FALLS IN FROM PREVIOUS PAGE
PAGEX4:	JSR PC,UPTLD	;LOAD THE UPT
	MOV (P),UPTFPT(B)	;UPDATE SWAP POINTER
	MOV UPTCLP(B),B	;THE NEXT UPT
	CMP B,F		;IS IT THE FIRST UPT?
	BNE PAGEX4	;NO TRY NEXT ONE
	TST (P)+	;POP OFF THE SWAP ADDRESS
	JSR PC,UPTLD	;LOAD IT UP
	BIS #UPTWON,(B)	;SAY THAT IS WAS WRITTEN ON (NEW SWAP SPACE, SO SHOULD BE SWAPPED OUT)
	REST B		;GET BACK THE OLD SWAP SPACE
	JSR PC,DSWPAL	;FREE OLD SWAP SPACE
;HERE WE HAVE THE CORRECT SWAP SPACE (WHATEVER THAT IS)
PAGEX3:	MOV F,B		;THE GIP
	JSR PC,SWPOT	;SWAP IT OUT (SO THAT NEW LENGTH FITS INTO CORE
	JSR PC,UPTLD	;LOAD IT UP
	MOVB 6(P),A	;THE START
	MOVB 7(P),C	;THE LENGTH
	ASH #4,C	;INTO THE CORRECT BITS
	BIS A,C		;SET IN THE START
	SWAB C		;THE NEW START AND LENGTH FOR THIS UPT
	BIC #73400,(B)	;CLEAR THE OLD START AND LENGTH
	BIS C,(B)	;SET IN THE NEW
	MOV F,C		;THE GIP TO UPT JUST CHANGED
	JSR PC,SWPCAL	;CALCULATE NEW MASTER LENGTH AND START
	CMPB #20,3(P)	;IS IT I=D
	BGT PAGEX6	;NO
	MOV C,B		;GET POINTER TO PAGE
	JSR PC,UPTLD	;LOAD IT UP
	MOV UPTLEN*10(B),C	;GET THE D SPACE BITS
	BIC #-1-360,C	;CLEAR ALL BUT THEM
	BIS C,(B)	;NO SET THEM INTO I PAGE
	MOV #UPTLEN/2,C	;GET THE LENGTH OF UT
	MOV (B)+,<UPTLEN*10>-2(B)	;COPY IT UP
	SOB C,.-4	;ALL THE WORDS
PAGEX6:	ADD #10,P	;POP OFF JUNK
	JMP EMAPR1	;SUCESS
.ENDC
	.STITL FILE ACCESS CAPABILITY ROUTINES, CREATE FA CAP
CCPRFA:	JSR PC,GETWRD	;GET THE FLAG WORD FROM THE USER
	BIT #.FARUT,A	;DOES HE WANT A ROOT DIR?
	BNE CCFA.1	;GO TRY FOR THAT
	MOV A,C
	MOV #0,D		;FOR NOW, ALL TEMP FILES ON DISK 0
	JSR PC,CRDMFL	;CREATE A DUMMY MFI
	MOV #MFDWDB!MFTMPF,MFLAGW(C)	;SAY IT IS DELETE WHEN DONE AND TEMPORARY
	MOV #MFFILE!MFEOFB+<MFNAME-MFENHD+1>,MFENHD(C)	;SAY IT IS A FILE WITH NO BLOCK AT THE EOF, TIME AND DATE EXIST, DUMMY LENGTH
	JSR PC,LSWPOP		;WON'T GET PCLOSERED
	MOV A,B			;COPY ITEM POINTER
	MOV #.FAEOF!.FARD!.FAWT!.FAAP!.FAAC!.FACAP,A	;GIVE HIM ALL PERRMISSIONS
	CLR C
	CLZ
	RTS PC	

;COME HERE TO CREATE A ROOT DIRECTORY
CCFA.1:	BIC #177701,A		;WHCIHC DISK DOES HE WANT?
	TST MFBLNK(A)		;THAT ONE ALREADY EXIST?
	ERRORC NE,BAD		;YES, BAD DISK 
	MOV A,D			;COPY DISK NUMBER
	JSR PC,CRDMFL		;GET A MFI
	MOV #MFOPNB!.FADIR!.FAWSB!.FARUT,MFLAGW(C)	;NOT DONE OPENING, DIRECTORY, ROOT DIRECTORY, WRITE TO SOURCE
	MOV #MFDIRE!MFLSTB!MFEOFB+<MFNAME-MFENHD+2>,MFENHD(C)	;DIRECTORY, EOF POINTS TO EXISTING BLOCK, TIME AND DATE EXIST, LENGTH OF DUMMY
	MOVB #46,MFNAME+1(C)	;SKIP 46 (GETS YOU TO THE ROOT)
	JSR PC,DIRENT		;THIS CONVERTS THE DUMMY MFI TO THE REAL THING
	JSR PC,LSWPOP
	MOV A,B			;COPY ITEM NUMBER
	MOV #.FADIR!.FARD!.FAAP!.FAAC!.FACAP,A	;MOST PRIVILIGES, BUT NOT WRITE
	CLR C
	CLZ
	RTS PC

;CREATE A DUMMY MFI FOR TEMP FILES AND ROOT DIRECTORIES
CRDMFL:	JSR PC,CRMFI	;GET AN MFI
	ERRORC EQ,NIS	;NO ITEM SPACE AVAILABLE FOR IT
	MOV ITM2A,C	;POINT TO THE NEW MFI
	MOV #377,MFNAME(C)		;NAME IS RUBOUT
	MOV D,MFDISK(C)	;SET THE DISK # IN TH EMFI
	MOV MFBLNK(D),MFDLNK(C)	;LINK THE NEW MFI
	MOV A,MFBLNK(D)		;INTO THE LIST FOR THIS DISK
	RTS PC
.SBTTL FILE CAPABILITY ROUTINES- RANDOM INVOKES
CAPRFA:	REST <B,E,F>
	MOV A,D		;OTHER PEOPLE EXPECT THIS HERE
	SWAB B
	BIC #177401,B
	CMP B,#MFAHGH
	LBR GT,CAPRC2
	JMP @FATAB(B)

MFARE:	MOV FAMFI(D),A			;RETURN EOF POINTER
	JSR PC,ITM2LD
	MOV MFPGNO(A),E
	CLR F
	ASHC #-3,E
	ADD MFBYTP(A),F
	MOV F,B
	JSR PC,GIVPSW
	MOV E,B
	JSR PC,GIVPSW
	BR MFARTN

MFACF:	BIC #<-.FARD-.FAWT-.FAAP-.FAAC>-1,E	;CLEAR ACESS FLAGS
	BIC E,(D)
	BR MFARTN

MFASP:	MOV F,FAFBP(D)			;SET FILE POINTER
	BIC #160000,FAFBP(D)
	ASHC #3,E
	MOV E,FAFPN(D)
	BPT		;HERE, BIS THE RIGHT BITS IN THE FLAGS
	BR MFARTN

MFARP:	MOV FAFPN(D),A			;RETURN POINTER
	CLR B
	ASHC #-3,A
	ADD FAFBP(D),B
	JSR PC,GIVPSW
	MOV A,B
	JSR PC,GIVPSW
MFARTN:	JMP ERETCZ

;RETURN INFO ABOUT TH EDISK A FILE IS ON
MFADI:	MOV FAMFI(D),A	;GET THE MFI
	JSR PC,ITM2LD	;LOAD IT UP
	MOV MFDISK(A),B	;THE DISK NUMBER
	JSR PC,GIVPSW	;BACK TO THE USER
	MOV MFFREE(B),B	;NUMBER OF FREE BLOCKS
	JSR PC,GIVPSW
	BR MFARTN

;SET UP BIT TABLE FOR THE DISK THE BIT TABLE FILE IS ON
MFAMB:	MOV FAMFI(D),A	;GET THE MFI
	JSR PC,ITM2LD	;LOAD IT UP
	MOV MFDISK(A),D	;GET DISK NUMBER
	MOV MFBYTP(A),F	;GET LENGHT IN BYTES
	DEC F		;MAKE 2000=1777
	ASH #-10.,F	;CONVERT TO BLOCKS
	CLR E		;START AT 0
	MOV ITEM2,A	;GET MFI AGAIN
	JSR PC,MAKFPG	;MAKE A FUPT FOR THE BIT TABLE
	NBUGC EQ	;FAILED?
	MOV C,A		;COPY THE UPT POINTER
	JSR PC,ITM2LD	;LOAD THE BIT TABLE
	MOV (A)+,B	;NUMBER OF BLOCKS ON EMPTY DISK
	CLR MFFREE(D)	;NUMBER OF FREE BLOCKS
	MOV C,MFBITS(D)	;SAVE MFI OF BIT TABLE
MFAMB1:	MOV #16.,C	;NUMBER OF BITS/WORD
	MOV (A)+,E	;GET A WORD OF BITS
MFAMB2:	ROR E		;GET A BIT TO TEST
	BCS .+6		;NOT FREE
	INC MFFREE(D)	;ONE MORE FREE
	DEC B		;PAST TOTAL BLOCKS?
	BEQ MFAMB3	;YUP
	SOB C,MFAMB2	;DO WHOLE WORD
	BR MFAMB1	;DO NEXT WORD
MFAMB3:	JMP ERETCZ	;RETURN

.SBTTL FILE ACCESS CAP ROUTINES-MUTATE

MFAMU:	JSR PC,MAKFNB	;MAKE UP A FILE NAME BLOCK
	BNE MFAMU1	;JSUT RETURN IF NOTHING THERE
	JMP ERETCZ
MFAMU1:	SAVE A		;SAVE POINTER TO THE NEW FNB
	MOV FAMFI(D),A	;GET POINTER TO MFI	
	JSR PC,ITM2LD
	BIT #.FADIR,MFLAGW(A)	;IS IT A DIRECTORY?
	ERRORC EQ,BAC	;BAD CAPABILITY
	MOV MFDISK(A),E	;THE DISK NUMBER
	JSR PC,CRMFI	;CREATE AN MFI IN CASE WE NEED IT
	ERRORC EQ,NIS	;NO ITEM SAPCE AVAILABLE
	SAVE A		;SAVE POINTER TO THE NEW MFI
	MOV ITM2A,C	;POINTER INTO MFI
	MOV E,MFDISK(C)	;THE DISK NUMBER	
	MOV MFBLNK(E),MFDLNK(C)	;PUT THE NEW MFI
	MOV A,MFBLNK(E)	;ONTO THE LIST FOR THIS DISK
	MOV FAMFI(D),A	;GET BACK THE MFI
	JSR PC,ITM2LD
	MOV ITEM2,A	;POINTER TO THE MFI
	MOV 2(P),B	;GET BACK POINTER TO THE FNB
	JSR PC,DIRSER	;LOOK THE THING UP IN THE DIRECTORY
	ERRORC EQ,FNF	;FILE NOT FOUND IN DIR
	SAVE B		;SAVE POINTER INTO DIRECTORY
	MOV 4(P),A	;POINTER TO THE FNB IN A
	SAVE FNBFNO(A)	;GET NUMBER IN DIR, AS DETERMINED BY DIRSER
	MOV ITEM2,B	;POINTER TO DIRECTORY
	MOV C,FNBVER(A)	;SAVE AWAY THE EXACT VERSION NUMBER
	JSR PC,MFISER	;SEARCH TROUGH THE MFIS FOR EXACT MATCH
			;NOTE THAT THE DISK NUMBER IS STILL IN E...
	BEQ MFAMU2	;NONE FOUND, MUST CREATE NEW MFI
	REST <E,B>		;GET BACK USELESS POINTER
	MOV A,(P)	;SAVE INDEX OF PROPER MFI
	JSR PC,ITM2LD	;LOAD UP THE MFI WE FOUND TO BE THE RIGHT THING
	CMP E,MFIFNO(A)	;IS NUMBER IN DIR THE SAME?
	NBUGC NE	;UGH!
	INC MFFREF(A)	;THERE IS ONE MORE CAP TO IT
	JSR PC,LSWPOP	;DON'T NEED TO LOCK DIR ANY MORE
	JSR PC,FRELSE	;FREE UP THE UNNEEDED MFI
	BR MFAMU3	;GO DO THE COMMON STUFF

MFAMU2:	REST <E,B>	;GET BACK POINTER INTO DIR
	SAVE D		;SAVE POINTER TO CAP
	MOV (B),D	;GET HEADER WORD FROM DIR
	MOV 2(P),A	;GET INDEX OF THE MFI
	JSR PC,MFIEXP	;SEE IF MFI NEEDS EXPANDING
	MOV E,MFIFNO(A)	;THE FILE NUMBER IN DIR, OBTAINED ABOVE
	ADD #MFENHD,A	;POINT TO THE ENTRY PART OF THE MFI
	ASR D		;CHANGE TO A COUNT
	MOV (B)+,(A)+	;COPY FROM DIR
	SOB D,.-2
	JSR PC,ITM1PO	;FLUSH MFI FROM THERE
	MOV 2(P),A	;THE MFI AGAIN....	
	JSR PC,ITM2LD
	MOV MFENHD(A),F	;GET HEADER WORD AGAIN
	REST D
	BIC #170777,F	;GET THE TYPE OF THE NEW ENTRY
	CMP #MFDIRE,F	;IS IT A DIRECTORY?
	BNE MFAMU4	;NOPE, WE CAN RELAX
	MOV (P),A	;GET THE MFI INDEX BACK
	JSR PC,DIRENT	;GO DO THE MAGIC FOR THE DIRECTORY	

MFAMU4:	JSR PC,LSWPOP	;FLUSH LOCK ON DIRECTROY
	JSR PC,LSWPOP	;LOCK LOCK ON MFI WITHOUT DELETEING IT
MFAMU3:	REST FAMFI(D)	;PUT INDEX OF PROPER MFI INTO CAP
	CLR FAFPN(D)	;RESET POINTER
	CLR FAFBP(D)	;TO BEGGINING OF FILE
	BIS #.FAEOF,(D)	;SAY THAT WE ARE IN THE EOF BLOCK (EVEN THOUGH IT MIGHT NOT BE TRUE)
	REST A		;GET BACK POINTER TO FNB
	JSR PC,MFAERT	;GO GET E FROM FNB, FLUSH FNB, RETURN POINTER TO USER, ETC
	BR MFAMU	;NOW GO AROUND AGAIN FOR THE NEXT NAME

MFAERT:	MOV FNBFNE(A),E	;GET WHAT USER'S POINTER SHOULD GET CLOBBERED TO
	MOV ITM0A,A	;POINT TO OUR PROCESS BLOCK
	MOV PUP(A),C	;USER'S PDL POINTER
	ADD #2,C	;WANT TO CLOBBER HIS SECOND ARGUMENT
	SAVE E		;TO SEND TO THE USER
	MTPD (C)	;GIVE IT BACK TO HIM
	JSR PC,LSWPOP	;FLUSH FNB
	TST PLCKSL(A)	;FOR DEBUGGING, CHECK THERE ARE NO LOCKED SWITCHES
	NBUGC NE
	CLZ
	RTS PC
.SBTTL FILE CAPABILITIES-DIRECTORY HACKING


;SEARCH THE DIRECTORY POINTED TO BY THE MFI IN A FOR THE FILE POINTED
;TO BY THE FNB IN B
;RETURN IN A A POINTER TO WHERE WE SHOULD PUT A NEW FILE OF THIS NAME,
;AND IN B A POINTER TO THE "EXACT" MATCH IF ONE WAS FOUND.
;IF THE FNB HAS NO VERSION NUMBER OR A SPECIFIC VERSION NUMBER,
;THEN THE DIRECTORY ENTRY MUST HAVE THE SAME FOR AN EXACT MATCH
;IF THE FNB HAS < FOR A VERSION NUMBER, THE FIRST FILE
;WITH A VERSION NUMBER IS AN EXACT MATCH. IF THE FNB HAS
;> AS A VERSION NUMBER, THEN THE LAST FILE WITH THE RIGHT
;NAME AND A VERSION NUMBER IS AN EXACT MATCH. NOTE THAT
;> AND < NEVER EXACT MATCH TO A FILE WITH NO VERSION NUMBER,
;AND A FILE WITH NO VERSION NUMBER NEVER EXACT MATCHES A FILE
;WITH ONE
;THE VERSION NUMBER OF THE EXACT MATCH IS RETURNED IN C
;AND Z IS SET IF NO EXACT MATHC IS FOUND
;CALL WITH MFI LOADED INTO ITEM 2
;RETURNS WITH DIR LOADED INTO ITEM 2
DIRSER:	JSR F,ACSAV
	CLR 2(P)	;RETURNED B
	MOV B,E		;COPY FNB POINTER
	MOV #1,FNBFNO(E)	;FIRST FILE (WE SKIP THE SELF ENTRY)
	MOV ITM2A,A	;POINTER TO MFI
	MOV MFBYTP(A),F	;POINTER TO END OF DIRECTORY
	MOV MFIUPT(A),B	;GIP FOR DIRECTORY
	JSR PC,FUPTLK	;LOCK THE DIRECOTORY
	MOV B,A		;COPY THE GIP
	JSR PC,ITM2LD	;LOAD THE DIR OVER THE MFI
	ADD A,F		;REAL END POINTER NOW
	MOV (A),B	;FIRST WORD OF SELF ENTRY
	INC B		;ROUND OFF BYTE COUNT
	BIC #177401,B	;BYTE COUNT
	ADD B,A		;SKIP SELF
;AND THEN SKIP THE PARENT ENTRY TOO
DIRSE1:	INC FNBFNO(E)	;NEXT FILE
	MOV (A),B	;GET FIRST WORD OF ENTRY
	INC B		;ROUND OFF BYTE COUNT
	BIC #177401,B	;GET BYTE COUNT
	ADD B,A		;GO TO NEXT ENTRY
	MOV A,(P)	;SAVE FOR CALLER
	CMP A,F		;ARE WE AT OR PAST THE END?
	BHIS DIRSE2	;YUP, RETURN TO CALLER
	JSR PC,NAMCMP	;COMPARE THE FILE NAMES
	BGT DIRSE1	;HAVEN'T GONE FAR ENOUGH YET
	BLT DIRSE2	;WE'VE GONE TOO FAR
	MOV FNBVER(E),D	;MATCHED FILE NAMES, GET VERSION FROM FNB
	INC D		;WAS IT NO VERSION?
	BGE DIRSE4	;YES, OR POSITIVE VERSION
	CMP #-1,C	;NO VERSION ON THE DIR ENTRY?
	BEQ DIRSE1	;THEN IT CAN'T MATCH < OR >
	MOV A,2(P)	;THIS A REAL MATCH FOR <, AND A POSSIBLE FOR >
	MOV C,4(P)	;SO SAVE IT
	INC D		;WAS IT >?
	BEQ DIRSE1	;SEE IF WE CAN FIND A BIGGER ONE
DIRSE2:	JSR F,ACRES	;RESTORE THE CLOBBERED RESGISTERS
	TST B		;SET Z IF NO EXACT MATCH
	RTS PC
DIRSE4:	DEC D		;COMPENSATE FOR TEST
	CMP D,C		;BOTH HAVE VERSIONS OR NO VERSION
	BGT DIRSE1	;FNB VERSION > FOUND VERSION, KEEP TRYING	
	BLT DIRSE2	;FNB VERSION < FOUND, GIVE UP
	MOV A,2(P)	;EXACT MATCH
	MOV C,4(P)	;PREPARE TO RETURN
	BR DIRSE2
;COMPARE THE NAME IN A FNB WITH THE NAME IN A DIRECTORY AN DECIDE
;IF THEY ARE GREATER, EQUAL OR LESS
;POINTER TO FNB IS IN E, POINTER TO DIR IS IN A
NAMCMP:	SAVE <#0,A,B,E>
	MOV A,B		;COPY DIRECTORY POINTER
	ADD #FNBFN,E	;POINT TO FILE NAME IN FILE NAME BLOCK
	MOV MFVERN-MFENHD(A),C	;GET VERSION NUMBER TO RETURN TO CALLER
	ADD #MFVERN-MFENHD+2,A	;POINT TO POTENTIAL NAME
	BIT #MFEOFB,(B)	;ARE THERE TIEM DATE ETC?
	BEQ .+6		;NOPE
	ADD #10,A	;SKIP STUFF
	BIT #MFACCB,(B)	;ACCESS CODES?
	BEQ NAMCM2	;NOPE
NAMCM1:	ADD #3,A	;SKIP ONE SET OF CODES
	TSTB -1(A)	;LAST?
	BLT NAMCM1	;KEEP GOING
NAMCM2:	CMPB (A)+,(E)+	;COMPARE CHARACTERS
	BNE NAMCM3	;NOT EQUAL, GO FINISH UP
	TSTB -1(A)	;DID THEY BOTH END?
	BGE NAMCM2	;NOPE
NAMCM4:	REST <E,B,A>
	TST (P)+	;SET CONDITION CODES
	RTS PC
NAMCM3:	MOVB -(A),A	;GET LAST CHAR FROM DIRECTORY
	MOV A,B		;COPY IT
	MOVB -(E),E	;GET LAST FROM FNB
	BIC #177600,A	;FLUSH CRAP
	BIC #177600,E	;LIKEWISE
	DEC 6(P)	;ASSUME FNB IS LESS
	CMP E,A		;WHICH IS GREATER?
	BLT NAMCM4	;ASSUMED RIGHT	
	BGT NAMCM5	;DIRETORY IS LESS
	TST B		;TEST SIGN EXTENDED DIRECTORY CHARACTER
	BGE NAMCM4	;DIRETORY ENDED FIRST, FNB IS BIGGER
NAMCM5:	MOV #1,6(P)	;DIRECTORY ENTRY IS SMALLER THAN FNB
	BR NAMCM4
;SEARCH THROUGH ALL MFI'S FOR THE DISK IN E FOR THE FNB
;THAT IS IN A. IF FOUND, RETURN ITEM # IN A AND CLEAR Z
;CALL WITH MFI OF DIRECTORY IN B
;ELSE SET Z
MFISER:	JSR F,ACSAV
	MOV A,B		;COPY FNB POINTER
	MOV A,C		;TWICE
	ADD #FNBFN,B	;ACTUALLY POINT AT NAME
	MOV MFBLNK(E),A	;FIRST MFI ON THE LIST
	BEQ MFISE1	;NOT FOUND
	JSR PC,ITM2PL	;LOAD UP THE MFI
MFISE2:	CMP MFBAKP(A),2(P)	;SAME DIRECTORY?
	BNE MFISE6	;NOPE
	MOV A,E		;COPY MFI POINTER
	MOV B,F		;COPY FNB NAME POINTER
	ADD #MFENHD,E	;POINT TO ENTRY
	MOV E,D		;COPY THAT
	ADD #2,E	;FIRST POSSIBLE PLACE FOR NAME
	BIT #MFEOFB,(D)	;DOES IT HAVE EOF ETC?
	BEQ .+6
	ADD #10,E	;PUSH FORWARD...
	BIT #MFACCB,(D)	;ACCESS CODES?
	BEQ MFISE3	;NOPE
MFISE4:	ADD #3,E	;SKIP ONE SET
	TSTB -1(E)	;LAST SET?
	BGE MFISE4	;NOPE
MFISE3:	CMPB (E)+,(F)+	;COMPARE NAME BYTES
	BNE MFISE6	;NOT THE SAME NAME
	TSTB -1(E)	;END OF NAMES?
	BGE MFISE3	;NOT YET
	CMP MFVERN(D),FNBVER(C)	;SAME NAME, SAME VERSION?
	BNE MFISE6	;NOPE
	MOV ITEM2,(P)	;FOR THE CALLER
	JSR PC,ITM2PO
	JSR F,ACRES
	CLZ
	RTS PC

MFISE6:	MOV MFDLNK(D),A	;NEXT MFI ON THIS DISK
	BEQ MFISE7	;NO MORE
	JSR PC,ITM2LD	;LOAD THIS ONE	
	BR MFISE2	;AND GIVE IT A TRY

MFISE7:	JSR PC,ITM2PO
MFISE1:	JSR F,ACRES
	SEZ
	RTS PC
.SBTTL FILE I/ CALLS
;DISK BYTE INPUT
DKBTI:	MOV #1,C	;WE NEED ONLY 1 BYTE
	JSR PC,DKISET	;SET UP TO DO IT
	ERRORC EQ,RPEF,SV	;ATTEMPT TO READ PAST EOF?
	MOVB (E),B	;GET THE BYTE
	JSR PC,GIVPSW	;GIVE IT TO THE USER
DKBTI1:	JSR PC,ITM2PO	;POP THE FILE PAGE
	JSR PC,LSWPOP	;POP THE LOCK ON THE FA
	JSR PC,FAINC	;INCREMENT THE FILE POINTER
	JMP ERETCZ	;AND RETURN HAPPILY

;DISK WORD INPUT
DKWDI:	MOV #2,C	;THIS TIME WE NEED 2 BYTES
	JSR PC,DKISET	;TRY TO GET THEM
	ERRORC EQ,RPEF,SV	;PAST EOF
	CMP #1,C	;DID WE GET ONLY 1?
	BEQ DKWDI1	;YUP, PAINFULLY CASE
	MOVB 1(E),B	;GET HIGH BYTE
	SWAB B		;INTO RIGHT PLACE
	CLRB B		;MAKE ROOM FOR LOW BYTE
	BISB (E),B	;PUT IT IN
	JSR PC,GIVPSW	;PUT IT ONTO USER'S STACK
	INC FAFBP(D)	;THIS CAN'T OVERFLOW THE PAGE
	BR DKBTI1	;GO CLEAN UP AND INC AGAIN

;IF ONLY 1 BYTE IS AVAILABLE, WE HAVE POTENTIAL PCLOSER PROBLEMS
DKWDI1:	MOVB (E),-(P)	;GET THE FIRST BYTE
	JSR PC,ITM2PO	;POP TH EFILE PAGE
	JSR PC,LSWPOP	;FLUSH THE LOCK ON THE FA
	JSR PC,FAINC	;GO TO THE NEXT FILE BYTE
	MOV #LPCLRT,A	;RUN ON PCLOSER
	MOV ITEM1,B	;THE SPHERE
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV #FAPDEC,LCKWD1(B)	;DEC POINTER ON PCLOSER
	MOV D,LCKWD2(B)	;POINTER TO CAP
	SUB ITM1A,LCKWD2(B)	;MAKE INTO OFFSET
	MOV #1,C	;NOW ONLY NEED ONE MORE BYTE
	JSR PC,DKISET	;MAKE UP THE NEW FUPT
	ERRORC EQ,RPEF,SV	;OOOPS, EOF
	MOVB (E),1(P)	;GET SECOND BYTE
	REST B		;ASSEMBLED WORD INTO B
	JSR PC,GIVPSW	;PASS TO THE USER
	JSR PC,LSWPOP	;POP THE LOCK ON THE FA
	BR DKBTI1	;FINISH CLEANING UP AS USUAL

;INCREMENT THE FILE POINTER AND DO THE RIGHT THING ON OVERFLOW
FAINC:	INC FAFBP(D)	;INC BYTE PART
	CMP #20000,FAFBP(D)	;OVERFLOW?
	BNE FAINC1	;NOPE
	CLR FAFBP(D)	;RESET BYTE PART
	INC FAFPN(D)	;NEXT PAGE
FAINC1:	RTS PC

;PCLOSER ROUTINE TO DECREMENT THE FILE POINTER
FAPDEC:	MOV LCKWD2(B),B	;GET OFFSET
	ADD A,B		;GET ADDRESS OF CAP
	DEC FAFBP(B)	;BACK ONE BYTE
	BNE FAPDE1	;NO UNDERFLOW
	MOV #17777,FAFBP(B)	;CORRECT FOR UNDERFLOW
	DEC FAFPN(B)	;IN PAGE NUMBER TOO
FAPDE1:	RTS PC
;SET UP FOR A DISK INPUT CALL
;CALL THIS ROTUINE WITH THE DESIRED NUMBER OF BYTES IN C
;AND A POINTER TO THE FA CAP IN D
;IT WIL RETURN THE NUMBER OF BYTES AVAILABLE IN C
;AND A POINTER TO THE THE FIRST BYTE IN E
;IT WILL HAVE LOCKED THE FILE CAPABILITY AND LOADED THE FILE PAGE
;INTO ITEM 2
;IT SETS Z IF THERE ARE NO BYTES AVAILABLE, AND ERRORS OUT
;IF THE FILE POINTER IS BEYOND THE END OF FILE
;LOTS OF REGISTERS MIGHT GET CLOBBERED
DKISET:	SAVE C		;SAVE # OF BYTES DESIRED
	MOV FAUPT(D),B	;GET THE FUPT
	BEQ DKISE2	;NONE, GO MAKE ONE UP
	CMP #-1,B	;IS SOMEONE ELSE IS MAKING ONE UP?
	BEQ DKISE5	;YUP, WAIT FOR HIM
	BIC #GIPBIT,B	;MAKE INTO AN ADDRESS
	TST FUPTPR(B)	;SOMEONE ELSE USING THE CAP?
	BEQ DKISE1	;NOPE, GRAB IT
DKISE5:	JSR PC,SFLUSH	;WAIT
	JSR PC,RUNME	;BUT NOT LONG
	BR DKISET	;TRY AGAIN
DKISE1:	JSR PC,FUPTLK	;LOCK THIS FUPT
	MOV UPTPBP(B),E	;GET PB POINTER
	CMP FAFPN(D),PBFPNO(D)	;IS THIS FUPT FOR TH EPAGE WE ARE ON?
	BNE DKISE3	;NOPE, GET A NEW ONE
	MOVB UPTSTL(B),E	;GET THE START AND LENGTH
	MOV E,F		;COPY
	BIC #UPTSMS,E	;START
	BIC #UPTLMS,F	;LENGTH
	ASH #10.-UPTSSH,E	;START INTO BYTES
	INC F		;0=>1
	ASH #10.,F	;LENGTH INTO BYTES
	ADD E,F		;LENGHT INTO END
	CMP FAFBP(D),E	;ARE WE INTERESTED IN STUFF AFTER THE START?
	BLT DKISE3	;NOPE, BEFORE IT
	CMP FAFBP(D),F	;AND BEFORE THE END?
	BGE DKISE3	;NOPE, AFTER IT	
	JSR PC,DKIEFC	;CHECK FOR THE EOF BEING IN THIS BLOCK
	SUB FAFBP(D),F	;THAT'S HOW MANY BYTES THERE ARE AVAILABLE
	MOV F,C		;WANT TO RETURN IT IN C
	SAVE A
	MOV FAUPT(D),A	;GET THE FILE PAGE
	JSR PC,ITM2PL	;LOAD IT UP
	SUB E,A		;SUBTRACT OFF THE PAGE START
	MOV A,E		;COPY 
	ADD FAFBP(D),E	;AND ADD IN THE FILE POINTER
	REST <A,>	;RESTORE A AND FLUSH SAVED C
	TST C		;SET CONDITION CODES
	RTS PC

;COME HERE IF THE CURENT FILE PAGE IS USLESS TO US
DKISE3:	MOV FAUPT(D),B	;GET THE CURENNT PAGE
	JSR PC,UPTDL	;FLUSH IT
	CLR FAUPT(D)	;IT IS FLUSHED
	JSR PC,LSWFLS	;FLUSH THE LOCK WE HAD ON IT
;FALL INTO MAKING A NEW FUPT THAT IS THE RIGHT THING
DKISE2:	REST C		;WE WNAT TO PRESERVE
	JSR F,ACSAV	;ALL THE REGISTERS NOW
	MOV D,A		;COPY CAP POINTER
	SUB ITM1A,A	;MAKE IT RELATIVE	
	ADD #FAUPT,A	;WANT TO LOCK THE FAUPT
	MOV #-1,B	;LOCK ALL BITS
	MOV ITEM1,C	;IN THE CURRENT SPHERE
	JSR PC,LCKASW	;LOCK IT
	MOV FAFPN(D),C	;THE PAGE NUMBER
	MOV FAMFI(D),A	;NEED TO LOOK IN THE MFI
	JSR PC,ITM2PL
	MOV #20000,F	;DEFAULT END OF THIS PAGE
	MOV FAFBP(D),E	;POINTER INTO PAGE
	CMP C,MFPGNO(A)	;ARE WE ON THE EOF PAGE?
	ERRORC HI,APEF	;NO, WE ARE BEYOND IT!
	BLO DKISE6	;NO, WE ARE BEFORE IT
	CMP E,MFBYTP(A)	;IS FILE POINTER BEYOND EOF?
	ERRORC HI,APEF	;ACCESS BEYOND END OF FILE IF SO
	BIS #.FAEOF,(D)	;TELL THE WORLD TO BE CAREFUL
	MOV MFBYTP(A),F	;END OF FILE IS END OF PAGE
DKISE6:	MOV E,B		;COPY FILE POINTER
	ADD 4(P),B	;ADD NUMBER OF BYTES CALLER WANTS TO IT
	CMP B,F		;DOES CALLER WANT MORE THAN CAN FIT ON PAGE?
	BHI .+4		;YES, HE ONLY GETS WHAT FITS
	MOV B,F		;GIVE HIM ONLY WHAT HE WANTS
	ASH #-10.,E	;CONVERT TO BLOCKS
	ASH #-10.,F	;THIS TOO
	SUB E,F		;CONVERT END TO LENGTH
	MOV FAMFI(D),A	;GET THE MFI #
	JSR PC,MAKFPG	;MAKE A FILE PAGE
	ERRORC EQ,APEF	;UGH, MUST HAVE HIT A HOLE!
	JSR PC,LSWPOP	;LOCK ON JUST CREATED FUPT
	JSR PC,LSWPOP	;LOCK ON FA CAP
	MOV C,FAUPT(D)	;THE NEW FILE PAGE
	JSR PC,ITM2PO	;FLUSH LOADED MFI
	JSR F,ACRES
	JMP DKISET	;TRY IT AGAIN

;ROUTINE TO ADJUST F IF THE PAGE IS THE LAST IN THE FILE
;AND F POINTS BEYOND TH EEND OF THE FILE
DKIEFC:	BIT #.FAEOF,(D)	;ARE WE POSSIBLY IN THE LAST PAGE OF THE FILE?
	BEQ DKIEF3	;NO, DON'T WORRY
	SAVE A
	MOV FAMFI(D),A	;GET THE MFI
	JSR PC,ITM2PL
	CMP FAFPN(D),MFPGNO(A)	;ARE WE REALLY ON THE LAST PAGE>
	BLO DKIEF1	;NO, NO NEED TO WORRY
	CMP F,MFBYTP(A)	;DOES THIS POINT PAST THE EOF?
	BLOS DKIEF2	;NOPE
	MOV MFBYTP(A),F	;SET IT TO THE EOF
DKIEF2:	JSR PC,ITM2PO
	REST A
DKIEF3:	RTS PC
DKIEF1:	BIC #.FAEOF,(D)	;NO NEED TO WORRY FOR NOW
	BR DKIEF2
.SBTTL FILE CAPABILITIES-LOWER LEVEL ROUTINES
;GET A FILE NAME FROM THE USER
;TAKES POINTER TO USER CORE IN E
;RETURNS WITH POINTER TO THE FILE NAME BLOCK IN A
;SAID BLOCK IS LOCKED, AND WILL BE RETURNED WHEN THE SWITCH IS POPED
;RETURNS WITH Z SET IF RAN OFF END OF USER'S STRING
;NO OTHER REGISTERS ARE DISTURBED
MAKFNB:	JSR F,ACSAV
MAKFN1:	JSR PC,GETUBY	;GET THE NEXT USER BYTE
	BNE MAKFN2	;SOMETHING THERE IF BYTE IS NON-ZERO
	JSR F,ACRES	;NO NAME THERE
	SEZ
	RTS PC
MAKFN2:	CMP #40,A	;IS IT JUST A SPACE?
	BEQ MAKFN1
	DEC E		;I'LL WANT THAT ONE AGAIN
	MOV #FNBFRE,B	;GET A FILE NAME BLOCK
	JSR PC,FREEGT	;STANDARD METHOD
	SAVE A		;SAVE POINTER TO THING WE GOT	
	MOV #LCKRTN,A	;EXECUTE WHENEVER POPED
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV #FNBULK,LCKWD1(A)
	MOV (P),LCKWD2(A)	;SAVE POINTER TO THIS BLOCK IN THE LOCK BLOCK
	REST B		;GET BACK THE POINTER
	MOV #-1,FNBVER(B)	;NO VERSION YET
	CLR FNBFNL(B)	;FILE NAME IS ZERO LONG
	MOV B,C		;COPY POINTER TO THE BLOCK
	ADD #FNBFN,C	;POINT TO THE FILE NAME PART
	MOV #FNBNML,D	;MAX LENGTH OF NAME
MAKF.1:	JSR PC,GETUBY	;GET THE NEXT BYTE
	BEQ MAKF.2	;GO FINISH UP IF BYTE IS ZERO
	CMP #40,A	;ANOTHER TYPE OF END
	BEQ MAKF.2
	CMP #'#,A	;VERSION NUMBER INDICATOR
	BEQ MAKF.3	;GO PROCESS THAT
	CMP #'",A	;QUOTED CHARACTER NEXT
	BEQ MAKF.7	;GO GOBBLE IT
	CMP #'>,A	;GREATER THAN VERSION?
	BEQ MAKF.4	;YUP
	CMP #'<,A	;LESS THAN?
	BEQ MAKF.5	;YUP
MAKF.8:	INC FNBFNL(B)	;ONE MORE CHAR IN FILE NAME
	MOVB A,(C)+	;NOTHING SPECIAL, PUT IT INTO THE STRING
	SOB D,MAKF.1	;KEEP LOOKING FOR THE END
	ERROR FNTL	;FILE NAME TOO LONG
MAKF.4:	MOV #-2,D	;THE > MARKER
	BR MAKF.9	;GO PLACE IT
MAKF.5:	MOV #-3,D	;THE < MARKER
MAKF.9:	MOV D,FNBVER(B)	;PLACE IT IN THE BLOCK
MAKF.2:	BISB #200,-(C)	;MARK THE END OF THE NAME
	TST A		;IF THE LAST BYTE WAS A ZERO
	BNE .+4
	DEC E		;WE WANT TO BE SURE TO SEE IT THE NEXT TIME
	MOV E,FNBFNE(B)	;SAVE THE END POINTER INTO THE USER
	MOV B,(P)	;RETURN THE POINTER TO THE BLOCK IN A
	JSR F,ACRES
	CLZ
	RTS PC

MAKF.7:	JSR PC,GETUBY	;GET A QUOTED CHARACTER
	BR MAKF.8	;AND STUFF IT INTO THE NAME

;COME HERE TO GET A VERSION NUMBER
MAKF.3:	CLR D		;START NUMBER AT ZERO
MAKF.6:	JSR PC,GETUBY	;GET THE NEXT BYTE
	BEQ MAKF.7	;GO INSERT NUMBER INTO BLOCK IF BYTE IS ZERO
	CMP #40,A	;ANOTHER TERMINATOR?
	BEQ MAKF.7	;YUP
	SUB #'0,A	;MAKE INTO BCD
	ERRORC LT,BFN	;BAD FILE NAME, NON-NUMERIC
	CMP #9.,A	;IS IT A NUMBER?
	ERRORC LT,BFN	;BAD FILE NAME AGAIN
	MUL #10.,D	;CONVERT TO DECIMAL
	ADD A,D
	BR MAKF.6	;GET NEXT DIGIT

;GET A BYTE FROM THE USER USING E AS A POINTER
;RETURN THE BYTE IN A AND INCREMENT E
;AND SET Z IF THE BYTE IS ZERO
GETUBY:	SAVE E		;SAVE THE POINTER
	BIC #1,E	;MAKE IT EVEN
	MFPD (E)	;GET WORD FROM USER
	BIT #1,2(P)	;WAS ORIGINAL POINTER ODD?
	BEQ .+4		;IF NOT, WORD ON STACK IS OK
	SWAB (P)	;REVERSE BYTES TO GET ODD ONE
	REST <A,E>	;GET USERS WORD AND OLD POINTER
	INC E		;UPDATE POINTER
	BIC #177400,A	;CLEAR TOP BYTE
	RTS PC

;GET A WORD FROM THE USER, POSSIBLY ON AN ODD BOUNDARY
;RETURN THE WORD IN A
;AND ADD 2 TO E
GETWRD:	JSR PC,GETUBY	;FIRST BYTE
	SAVE A
	JSR PC,GETUBY	;SECOND BYTE
	SWAB A		;IS HIGH PART
	BIS (P)+,A	;GET FULL WORD
	RTS PC

;WHEN SWITCH IS POPED RETURN NODE TO FREE LIST
FNBULK:	MOV FNBFRE,@LCKWD2(B)	;CLOBBER NODE BEING RETURNED
	MOV LCKWD2(B),FNBFRE	;POINT FREE POINTER AT IT
	RTS PC
;ROUTINE TO CREATE AN MFI AND RETURN POINTER TO IT IN A
;CLEAR Z IF YOU WIN
CRMFI:	SAVE B
	MOV #MFLEN,A	;THE LENGTH OF A BASIC MFI
	JSR PC,CRITEM	;CREATE IT
	BEQ CRMFI1	;FAILED
	SAVE B		;SAVE THE POINTER TO IT
	JSR PC,CLITEM	;CLEAR OUT THE NEW ITEM
	JSR PC,ITM0PO	;RECOVER FROM CLITEM
	MOV (P),A	;GET BACK THE ITEM NUMBER
	JSR PC,ITM2LD	;LOAD IT UP
	MOV #ITMF,(A)	;YOU ARE AN MFI
	MOV #MFLEN_6,MFELN(A)	;CURRENTLY THIS LONG
	MOV #1,MFFREF(A)	;PRESUMABLY, THERE WILL SOON BE A CAPABILITY
	MOV #MFOPNB,MFLAGW(A)	;ENTRY BEING OPENED
	MOV #LPCLRT,A	;RUN ROUTINE ON PCLOSER
	MOV (P),B	;FOR THIS ITEM
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV #MFIUNL,LCKWD1(A)	;MUST DO SPECIAL THINGS TO UNLOCK
	REST <A,B>	;GET OLD B AND NEW A
	CLZ		;INDICATE SUCCESS
	RTS PC
CRMFI1:	REST B
	SEZ		;FAILURE
	RTS PC

;ROUTINE TO FLUSH A REFERENCE TO AN MFI BY A FA OR INFERIOR DIRECTORY
;CALL WITH MFI ITEM # IN A
MFIDEL:	JSR F,ACSAV
	JSR PC,ITM2PL	;LOAD UP THE ITEM
MFIDE3:	DEC MFFREF(A)	;ONE LESS REFERENCE
	BNE MFIDE1	;BUT STILL NON-ZERO
	BIT #MFEBMB,MFLAGW(A)	;HAS THE ENTRY BE MODIFIED?
	BEQ MFIDE2	;NO, IT CAN GO QUIETLY
	INC MFFREF(A)	;IN CASE OF PCLOSER
	JSR PC,MFIINS	;INSERT ENTRY INTO THE DIRECTORY
	BR MFIDE3	;RUN THAT BY AGAIN

MFIDE2:	JSR PC,MFIDFL	;FLUSH THE STRANGE WAY, IF NESSESARY
	BEQ MFIDE1	;IT WAS
	TST MFPBRF(A)	;ANY PAGES LEFT?
	BNE MFIDE1	;YES, DON'T FLUSH MFI
	JSR PC,MFIUN	;BYE-BYE MFI
MFIDE1:	JSR PC,ITM2PO
	JSR F,ACRES
	RTS PC

;ROUTINE TO FLUSH THE REFERENCE TO A FILE BY A PAGE BLOCK
;CALL WITH PB INDEX IN B
MFIPBD:	JSR F,ACSAV
	MOV PBMFIP(B),A	;THE MFI THIS PB IS FROM
	JSR PC,ITM2PL
	DEC MFPBRF(A)	;ONE LESS
	BNE MFIPB1	;STILL MORE THOUGH
	TST MFFREF(A)	;ANY OTHER REFERENCES?
	BNE MFIPB1	;YUP
	JSR PC,MFIUN	;FLUSH IT
MFIPB1:	JSR F,ACRES
	RTS PC

;THIS WILL FLUSH THE MFIUPT OF A DIRECTORY IF THERE IS
;ONE AND THERE IS ONLY ONE PB STILL HANGING AROUND
;AND THE FUPT FOR THE DIR POINTS AT ITSELF
;IF ALL THESE CONDIONS ARE TRUE, THEN DELETEING THE
;FUPT WILL CAUSE THE MFI TO GET FLUSHED BY A 
;(POSSIBLY RECURSIVE) CALL THE MFIPBD, SO THAT
;THE CALLER SHOULD NOT TRY TO FINSH THE DELETEION
;HIMSELF. THIS ROUTINE SETS Z IF THIS IS THE CASE
MFIDFL:	TST MFIUPT(A)	;IS THERE A MFIUPT (MEANING THIS IS A DIR)
	BEQ MFIDF1	;NOPE
MFIDF3:	CMP #1,MFPBRF(A)	;IS THERE EXACTLY ONE PB?
	NBUGC NE	;UGH, HOW DO YOU GET MORE THAN ONE PB FOR A DIR?
	MOV MFIUPT(A),B	;GET THE FUPT
	MOV B,C		;COPY
	BIC #GIPBIT,C	;MAKE INTO ADDRESS
	CMP UPTGIP(C),B	;DOES IT POINT AT ITSELF?
	BNE MFIDF1	;NO, IT CAN STAY	
	MOV UPTPBP(C),B	;GET POINTER TO TH EPB
	BIT #PBVAS,PBFLAG(B)	;IS IT VALID AT SOURCE?
	BNE MFIDF2	;YES, WIN
	JSR PC,PBSWPI	;SWAP IN THE PAGE
	JSR PC,PBVLSR	;VALIDATE AT SOURCE
	BR MFIDF3	;NOW CHECK THINGS AGAIN
MFIDF2:	MOV C,B		;GET BACK FUPT
	BIS #GIPBIT,C	;WELL, ALMOST
;WELL, ALMOST. HAVE TO WORRY ABOUT THE GUY ABOVE US GETTING FLUSHEDD
;GUESS WE BETTER DO IT OURSELVES...
	JSR PC,UPTDL	;THIS OUGHT TO TAKE CARE OF EVERYTHING... (AND NOT HANG)
	SEZ
	RTS PC
MFIDF1:	CLZ
	RTS PC

;PCLOSER ROUTINE TO FLUSH AN INCOMPLETE MFI
MFIUNL:	BIT #MFOPNB,MFLAGW(A)	;WE BETTER NOT BE DONE OPENING!
	NBUGC EQ	;OOPS
	JSR PC,MFIUNX	;FLSUH THE MFI
	RTS PC


;AS MFIUN, BUT FLUSH THE MFIUPT IF IT EXISTS ALSO
MFIUNX:	JSR F,ACSAV
	MOV MFIUPT(A),B	;IF THERE IS AN ASSOCIATED FUPT...
	BEQ MFIUL1	;NOPE, NO NEED TO GET RID OF IT
	JSR PC,UPTDL	;BETTER NOT HANG...
	BR MFIUL1
;FLUSH A MFI THAT IS READY FOR FLUSHING, I.E. IS ASSUMED SAFELY PUT BACK INTO
;THE DIRECTORY AND ALL ASSOCIATED PAGES ARE WINNING, ETC.
;CALL WITH THE MFI LOADED INTO ITEM2 AND THE ADDRESS IN A
MFIUN:	JSR F,ACSAV
MFIUL1:	MOV MFDISK(A),D	;GET THE DISK NUMBER
	MOV MFDLNK(A),C	;THE ONE IT POINTS TO
	MOV MFBLNK(D),A	;GET THE FIRST ITEM IN THE LIST FOR THIS DISK
	MOV ITEM2,E	;GET ITEM NUMBER OF THE BEING FLUSHED MFI
	CMP E,A		;FIRST ON THE LIST?
	BEQ MFIUL2	;YUP, THIS IS EASY
	JSR PC,ITM2PL	;LOAD THE FIRST ON THE LIST
MFIUL3:	CMP E,MFDLNK(A)	;THIS ONE?
	BEQ MFIUL4	;YUP
	MOV MFDLNK(A),A	;GET NEXT
	NBUGC EQ	;END OF LIST?
	JSR PC,ITM2LD
	BR MFIUL3
MFIUL4:	MOV C,MFDLNK(A)	;UNLINK THE BLOCK
	JSR PC,ITM2PO
	BR MFIUL5
MFIUL2:	MOV C,MFBLNK(D)	;POINT ONE FURTHER DOWN THE LIST
MFIUL5:	MOV ITM2A,A
	MOV MFBAKP(A),A	;POINTER TO PARENT
	BEQ MFIUL6	;KNOW PARENT, BETTER BE A ROOT
	JSR PC,MFIDEL	;RECURSE TO FLUSH A REFERENCE TO THE ABOVE DIRECTORY
MFIUL6:	MOV ITEM2,A	;NOW GET THE ITEM NUMBER
	JSR PC,DLITEM	;AND FLUSH THE MFI
	JSR F,ACRES
	RTS PC
;ROUTINE TO CONVERT AN MFI DESCRIBING THE FIRST BLOCK OF A DIRECTORY
;TO AN MFI FOR THE WHOLE DIRECOTRY
;THIS IS DONE BY READING THE SELF ENTRY IN THE DIRECTORY'S FIRST BLOCK
;AND COPYING IT INTO THE MFI
;A POINTS TO THE MFI BEING HACKED
DIRENT:	JSR F,ACSAV
	CLR C		;FOR PAGE ZERO
	JSR PC,MAKFUP	;GET AN FUPT
	CLRB UPTSTL(C)	;FLUSH START AND LENGTH TO BE FOR ONE BLOCK PAGE
	MOV UPTPBP(C),B	;GET THE PB
	CLRB PBLEN(B)	;SAME FOR PB
	JSR PC,ITM2PL	;LOAD THE MFI
	BIS #GIPBIT,C	;CONVERT FUPT ADDRESS TO A GIP
	MOV C,MFIUPT(A)	;FUPT FOR THE DIRECTORY
	JSR PC,ITM2PO	;FLUSH THE MFI
	MOV C,A		;COPY GIP TO THE PARTIAL DIRECTROY
	JSR PC,ITM2PL	;LOAD UP THE DIRETORY
	MOV A,E		;COPY POINTER TO IT
	MOV (A),D	;HEADER WORD OF SELF ENTRY
	MOV (P),A	;GET THE MFI AGAIN
	JSR PC,MFIEXP	;GO EXPAND MFI IF NEEDED
	ADD #MFENHD,A	;POINT TOT THE RIGHT PLACE IN THE MFI
	ASR D		;CONVERT TO WORD COUNT
	MOV (E)+,(A)+	;COPY A WORD
	SOB D,.-2
	JSR PC,ITM1PO	;POP MFI
	JSR PC,ITM2PO	;POP DIRECTORY
	MOV (P),A	;GET BACK MFI POINTER
	JSR PC,ITM2PL	;LOAD IT
	CLR C		;PAGE NUMBER DESIRED
	MOV MFIUPT(A),A	;GET THE FUPT FOR THE DIR
	BIC #GIPBIT,A	;CONVERT TO AN ADDRESS
	MOV A,F		;SAVE THAT
	MOV UPTPBP(A),B	;GET THE PAGE BLOCK POINTER FOR THE FUPT
	JSR PC,SWPPAG	;FLUSH THE THING FROM CORE
	MOV B,A		;COPY PB POINTER
	JSR PC,FILFPB	;FILL IN TH EDISK ADDRESSES
	MOV PBFLEN(B),A	;GET THE LENGTH OF THIS FILE PAGE
	DEC A		;NOW THIS IS NUMBER OF VALID BLOCKS-1
	MOVB A,PBLEN(B)	;WHICH IS ALWAYS THE LENGTH OF THE PAGE
	MOV ITM2A,F	;POINTER TO MFI
	MOVB A,UPTSTL(F)	;FUPT'S LENGTH IS WHOLE THING AND START IS ZERO
	INC A		;NOW NUMBER OF BLOCKS
	MOV A,MFIDLN(F)	;IN CASE SOMEONE IS EVER INTERESTED....
	ASH #10.,A	;CONVERT TO BYTES
	SUB MFBYTP(F),A	;SUBTRACT NUMBER KNOW TO BE USED	
	MOV A,MFIUCF(F)	;THAT IS THE NUMBER OF "UNCOMMITED FREE BYTES"
	BIC #MFOPNB,MFLAGW(F)	;DIRECTORY IS NOW OPEN FOR BUSINESS..
	BIS #.FADIR,MFLAGW(F)	;NOTE IN MFI THAT THIS IS A DIR
	JSR PC,ITM2PO
	JSR F,ACRES
	RTS PC

;TRY TO EPAND THE MFI IF IT WILL NEED TO BE EXPANDED
;TO TAKE AN ENTRY OF LENGTH IN D
;MFI NUMBER IN A
;D GETS INCREMENTED AND BIC #177400
MFIEXP:	SAVE B
	BIC #177400,D	;GET LENGTH OF SELF ENTRY IN BYTES
	INC D		;MUST ROUND IT TO WORDS
	JSR PC,ITM1PL	;LOAD THE MFI
	CLR B
	ADD D,B		;GET THE TOTAL LENGTH NEEDED FOR THE MFI
	ADD #MFENHD,B	;ADD IN THE OVERHEAD
	CMP B,MFELN(A)	;LONGER THAN THE MFI IS NOW?
	BLT DIREX1	;NO, WE'RE SAFE!
	MOV B,A		;COPY THE NEEDED LENGTH
	ASH #-6,A	;MAKE IT INTO 32 WORD BLOCKS
	MOV ITEM1,B	;GET BACK THE ITEM NUMBER
	JSR PC,ITM1PO	;CAN'T HAVE THIS PUSHED IF WE HANG
	JSR PC,EXITEM	;EXPAND THE MFI
	ERRORC EQ,NIS	;NOT ENOUGH SPACE
	SAVE A		;SAVE THE NEW LENGTH
	MOV B,A		;ITEM NUMBER AGAIN
	JSR PC,ITM1PL	;LOAD AGAIN
	REST B
	INC B		;0=>1
	ASH #6,B	;CONVERT TO BYTES
	MOV B,MFELN(A)	;SET THE NEW LENGTH
DIREX1:	REST B
	RTS PC

;MAKE AN FUPT FOR A PAGE OF A FILE
;CALL WITH MFI POINTER IN A, PAGE NUMBER IN C
;RETURN POINTER TO FUPT IN C
MAKFUP:	JSR F,ACSAV
	MOV #FUPTFR,B	;FREE POINTER FOR FUPTS
	JSR PC,FREEGT	;GET A FREE ONE
	JSR PC,FREELK	;LOCK IT IN CASE OF PCLOSER
	MOV #UPTEXB,(A)	;IT EXISTS, AT LEAST
	CLR UPTGIP(A)	;DOESN'T HAVE A GIP POINTER
	CLR FUPTPR(A)	;NO USER EITHER
	MOV A,4(P)	;SAVE TO RETURN TO THE CALLER
	MOV A,D		;SAVE POINTER TO FUPT
	MOV (P),A	;GET BACK MFI POINTER
	JSR PC,MAKFPB	;GO GET A PB FOR THAT PAGE
	MOV B,UPTPBP(D)	;PB POINTER 
	MOV PBGIP(B),E	;GET THE POINTER TO THE CURRENT CIRCULAR LIST
	BEQ MAKFU1	;BRANCH IF THERE ISN'T ONE
	MOV E,B		;COPY THE GIP
	JSR PC,UPTPLD	;GET A GOOD POINTER TO THE GIP
	MOV UPTGIP(B),UPTGIP(D)	;POINT THE NEW FUPT INTO THE LIST
	BIS #GIPBIT,D	;MAKE A GIP POINTER FOR THE FUPT
	MOV D,UPTGIP(B)	;AND POINT OLD GIP AT IT
	JSR PC,ITM2PO	;PUSHED BY UPTPLD
	BR MAKFU2	;KEEP GOING
MAKFU1:	MOV D,E		;COPY FUPT POINTER
	BIS #GIPBIT,E	;MAKE A GIP OUT OF ONE OF THEM
	MOV E,UPTGIP(D)	;POINT TO YOURSELF
	MOV E,PBGIP(B)	;POINT TH EPB AT THIS NEW CIRCULAR LIST
MAKFU2:	JSR PC,LSWPOP	;FLUSH THE LOCK ON THE PB
	JSR PC,LSWPOP	;AND THE MFI
	JSR F,ACRES
	RTS PC

;MAKE UP A FUPT FOR THE PAGE # IN C OF THE FILE
;WHOSE MFI IS IN A WITH START AND LENGTH IN E AND F
;RETURN POINTER TO THE FUPT IN C, UNLESS BLOCKS DON'T
;ALL EXIST, IN WHCIH CASE SET Z
MAKFPG:	JSR F,ACSAV
	MOV 12(P),F	;CALL TO ACSAV CLOBBERS F, RESTORE IT
	MOV E,C		;COPY PAGE NUMBER
	JSR PC,MAKFUP	;MAKE UP THE FUPT
	BIS #GIPBIT,C	;MAKFUP DOESN'T SET IT
	MOV C,4(P)	;SAVE FOR THE CALLER
	MOV #LPCLRT,A	;RUN ON PCLOSER
	CLR B		;NO ITEM
	JSR PC,LOCKSW
	MOV #UPTPCD,LCKWD1(A)	;ROUTINE TO RUN
	MOV C,LCKWD2(A)	;ON THIS UPT
	BIC #GIPBIT,C	;CONVERT TO ADDRESS
	MOV UPTPBP(C),B	;GET POINTER TO THE PB
	MOV E,C		;START
	MOV F,D		;LENGHT
	JSR PC,PBSETU	;FIX UP THE PB
	BEQ MAKFP1	;LOSE
	MOV 4(P),E	;GET BACK FUPT
	BIC #GIPBIT,E	;CONVERT TO ADDRESS
	ASH #UPTSSH,C	;GET START INTO RIGHT PLACE
	BIS C,D		;COMBINE START AND LENGTH
	MOVB D,UPTSTL(E)	;SET UP THE START AND LENGTH
	JSR F,ACRES
	CLZ
	RTS PC

MAKFP1:	JSR PC,FRELSE	;FLUSH THE UPT
	JSR F,ACRES
	SEZ
	RTS PC

;PCLOSER ROUTINE TO DELETE AN ITEM
;THIS WILL BE A REAL PROBLEM IF THIS EVER HANGS
UPTPCD:	MOV LCKWD2(B),B
	JMP UPTDL
;FIND OR MAKE E A PB FOR A PAGE IN A FILE
;CALL WITH ITEM POINTER TO THE MFI IN A
;PAGE NUMBER DESIRED IN C
;RETURNS WITH POINTER TO PB IN B
MAKFPB:	JSR F,ACSAV
	JSR PC,FPBGET	;GET A BLOCK IN CASE WE NEED ONE
	MOVB #-1,PBLEN(B)	;FLUSH THE LENGTH
	MOV B,2(P)	;SAVE IT FOR LATER AND TO RETURN TO USER
	MOV A,PBMFIP(B)	;POINT THE PB AT THE ASSOCIATED MFI
	JSR PC,ITM2PL	;LOAD UP THE MFI
	MOV MFIPB(A),B	;POINTER TO FIRST PB
	BEQ MAKFP4	;COULDN'T FIND ANY PBS
MAKFP6:	CMP C,PBFPNO(B)	;IS THIS THE PAGE WE'RE LOOKING FOR?
	BEQ MAKFP5	;YUP, WIN
	MOV PBFLNK(B),B	;GET THE NEXT ONE
	BNE MAKFP6	;TRY THE NEXT ONE IF IT EXISTS
MAKFP4:	MOV 2(P),B	;GET THE PB POINTER BACK
	MOV B,A		;MAKE A COPY OF IT
	JSR PC,FILFPB	;FILL UP THE FPB WITH DISK ADDRESES
	MOV ITM2A,A	;NOW LINK THE NEW THING
	MOV MFIPB(A),PBFLNK(B)	;ONTO THE EXISTING LIST
	MOV MFDISK(A),PBSDSK(B)	;COPY DISK NUMBER OUT OF MFI
	MOV B,MFIPB(A)	;OF PBS FOR THIS FILE
	INC MFPBRF(A)	;ONE MORE PB FOR THIS MFI
	JSR PC,LSWPOP	;FLUSH SIMPLE LOCK ON BLOCK
	MOV #LPCLRT,A	;RUN ROUTINE ON PCLOSER
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV #FPBPFL,LCKWD1(A)	;ROUTINE
	MOV 2(P),LCKWD2(A)	;FPB POINTER
MAKFP9:	JSR PC,ITM2PO	;FLUSH MFI
	JSR F,ACRES
	RTS PC

MAKFP5:	JSR PC,FRELSE	;FLUSH THE PB WE'RE NOT USING
	MOV B,2(P)	;RETURN POINTER TO EXISTING PB
	BR MAKFP9

;FILL UP A FPB WITH DISK BLOCK NUMBERS
;CALL WITH PAGE NUMBER DESIRED IN C
;POINTER TO PB IN A
;CLOBBERS D  AND E
FILFPB:	ADD #PBSDA,A	;TO POINT AT THE BLOCK NUMBERS
	ASH #3,C	;PAGE NUMBER=>BLOCK NUMBER
	JSR PC,MFBLKG	;INITIALIZE COROUTINE AND VARIABLES
FILFP1:	CMP C,D		;IS THSI THE RIGHT FIRST BLOCK NUMBER?
	BEQ FILFP2	;YUP, START GOBBLING
	JSR PC,@(P)+	;JUMP BACK
	BR FILFP1	;TO TRY AGAIN
FILFP2:	ASH #-3,C	;BACK TO PAGE NUMBER
	MOV C,PBFPNO(B)	;THIS IS THE PAGE FOR THIS PB
	MOV #8.,C	;FOR 8 BLOCKS
	CLR PBFLEN(B)	;ZERO VALID BLOCKS
FILFP3:	MOV E,(A)+	;STORE IN THE PB
	CMP #-1,E	;VALID BLOCK?
	BEQ .+6		;NOPE
	INC PBFLEN(B)	;ONE MORE THEN
	JSR PC,@(P)+	;GET NEXT BLOCK
	SOB C,FILFP3	;CONTINUE TILL 8 DONE
	TST (P)+	;FLUSH COROUTINE LINK
	RTS PC

;PCLOSER ROUTINE TO FLUSH A FILE PAGE BLOCK
;WHICH HAS NOT YET BECOME ASSOCIATED WITH AN FUPT
FPBPFL:	MOV LCKWD2(B),C	;POINTER TO FUPT
	BIT #PBLOCK!PBDISK,PBFLAG(C)	;IS THE PAGE MOVING?
	NBUGC NE	;ARG!
	TST PBGIP(C)	;DOES THE PAGE HAVE A GIP POINTER?
	NBUGC NE	;HAVE TO MORE THAN THIS THEN!
	MOV PBMFIP(C),A	;THE MFI FOR THIS FPB
	JSR PC,ITM2PL	;LOAD IT UP
	CMP C,MFIPB(A)	;IS THIS ONE THE FIRST IN THE LIST
	BEQ FPBPF1	;YES
	MOV MFIPB(A),A	;NO, CONTINUE DOWN LIST
FPBPF3:	NBUGC EQ	;RAN OFF THE END
	CMP PBFLNK(A),C	;THIS ONE?
	MOV PBFLNK(A),A	;NEXT?
	BR FPBPF3
FPBPF1:	MOV PBFLNK(C),MFIPB(A)	;POINT IT AT THE NEXT IN THE LIST
	BR FPBPF4	;CONTINUE ON
FPBPF2:	MOV PBFLNK(C),PBFLNK(A)	;LINK ME OUT OF THE LIST
FPBPF4:	MOV FPBFRE,(C)	;MAKE THE NEW FREE ONE POINT AT THE FREE LIST
	MOV C,FPBFRE	;NEW FREE LIST
	RTS PC
;THIS ROUTINE TAKES A MFI IN ITEM2 AND SPITS OUT BLOCK NUMBERS
;FOR IT. IT USES THE GLOBAL VARIABLES ENTPNT, ENTEND AND ENDCNT,
;SO YOU BETTER NOT SCHEDULE OUT OF IT. IT MAINTAINS THE BLOCK NUMBER
;IN THE FILE IN D AND THE PYHSICAL BLOCK NUMBER IN E
;NON-EXISTANT BLOCKS COME BACK AS -1
;AFTER THE FIRST CALL IT IS A CO-ROUTINE
MFBLKG:	SAVE <A,F>
	CLR D		;START AT ZERO IN THE FILE
	MOV #-1,E	;AND ZERO ON THE DISK (WELL, WILL BE AFTER FIRST INC)
	MOV ITM2A,F	;POINT TO THE MFI
	MOV F,A		;COPY POINTER
	ADD #MFVERN+2,F	;POINT TO NAME IF NO TIME, DATE AND EOF
	BIT #MFEOFB,MFENHD(A)	;TIME DATE ETC?
	BEQ .+6		;NOPE
	ADD #10,F	;SKIP IT
	BIT #MFACCB,MFENHD(A)	;ACCESS CODES?
	BEQ MFBLK2	;NOPE
MFBLK1:	ADD #3,F	;SKIP FIRST CODE GROUP
	TSTB -1(F)	;WAS THAT THE LAST ONE?
	BLT MFBLK2	;AFRAID NOT
MFBLK2:	TSTB (F)+	;LAST CHAR OF NAME?
	BGE MFBLK2	;NOT YET
	MOV F,ENTPNT	;THIS POINTS TO THE FIRST DESCRIPTOR BYTE
	MOV MFENHD(A),F	;GET THE HEADER WORD
	BIC #177400,F	;GET THE ENTRY LENGTH
	ADD A,F		;POINT TO THE FIRST BYTE NOT IN THIS ENTRY
	ADD #MFENHD,F	;NOW IT POINTS TO THE END
	MOV F,ENTEND	;SAVE THAT QUANTITY
	REST <F,A>	;NOW FOR THE MAIN LOOP
MFBLK3:	CMP ENTPNT,ENTEND	;ARE WE AT OR PAST THE END?
	BHIS MFBLK8	;YUP, GIVE HIM -1'S
	SAVE <A,B>
	MOVB @ENTPNT,A	;GET A DESCRIPTOR BYTE
	MOV A,B		;IN TWO PALCES
	INC ENTPNT	;POINT TO NEXT ONE
	BIC #177477,A	;GET THE TYPE	
	ASH #-5,A	;AS A BYTE INDEX
	BIC #177700,B	;ALSO GET THE DATA BITS
	INC E		;ALWAYS GO TO THE NEXT BLOCK
	JMP @MFBLTB(A)	;GO TO THE RIGHT PLACE

;COME HERE FOR A SKIP AND GRAB ONE TYPE
MFBSKP:	ADD B,E		;SKIP
	REST <B,A>
	JSR PC,@(P)+	;GRAB ONE
	INC D		;NEXT BLOCK IN FILE
	BR MFBLK3	;GO GET NEXT BLOCK

;COME HERE FOR A GRAB N BLOCKS TYPE
MFBGET:	MOV B,ENTCNT	;GET THAT MANY BLOCKS
	CMP #40,B	;MAYBE REALLY A HOLE IN THE FILE
	BLE MFBGE2	;YES, GO HOLIFY
MFBGE4:	REST <B,A>
MFBGE1:	JSR PC,@(P)+	;GET ONE BLOCK
	DEC ENTCNT	;ANY MORE?
	BLT MFBLK3	;NO, GET NEXT BYTE
	INC D		;NEXT IN FILE
	INC E		;NEXT ON DISK
	BR MFBGE1
MFBGE2:	SUB #40,ENTCNT	;REMOVE FLAG BIT
	REST <B,A>
MFBGE3:	MOV #-1,E	;NOTHINGNESS
	JSR PC,@(P)+	;RETURN IT
	INC D		;NEXT BLOCK IN FILE
	DEC ENTCNT	;MORE OF SAME?
	BNE MFBGE3	;YUP
	BR MFBLK3	;NO, NEXT BYTE

;COME HERE FOR A SET ADDRESS TYPE OF DESCRIPTOR
MFBSET:	MOV B,ENTCNT	;SAVE THE COUNT
	MOVB @ENTPNT,A	;GET NEXT BYTE
	INC ENTPNT
	BIC #177400,A	;LOSING SIGN EXTEND!
	MOVB @ENTPNT,E	;AND HIGH ORDER BYTE
	INC ENTPNT
	SWAB E		;INTO RIGHT PLACE
	BIC #377,E	;UNEXTEND AGAIN
	ADD A,E		;WHOLE WORD
	BR MFBGE4	;GO DO REGULAR COUNT

;COME HERE FOR SKIP AND COUNT TYPE
MFBSKG:	MOV B,A		;COPY DATA 
	ASH #-3,A	;GET THE SKIP
	ADD A,E		;SKIP IT
	BIC #177770,B	;GET THE COUNT
	BR MFBGET	;TREAT LIKE REGULAR GET

;COME HERE ON END OF FILE, INFINITE NON-EX BLOCKS
MFBLK8:	MOV #-1,E	;NO BLOCK HERE
	JSR PC,@(P)+	;RETURN IT
	INC D		;AND SO ON
	BR MFBLK8	;FOREVER
	.STITL	RANDOM CAPABILITY ROUTINES
CAPRMS:
CAPRSP:	CMPB 1(P),#.SPCLR	;IS IT A READ OF THE C-LIST
	BEQ CAPRS1	;YES
	TSTB 1(P)	;IS IT ZERO
	BNE CPRSP1	;NO, BAD FUNCTION
	MOV A,F		;COPY POINTER TO THE SPHERE CAPABILITY
	MOV 2(P),B	;THE PROCESS CAPABILITY POINTER		
	MOV ITM1A,A	;POINTER TO THE SPHERE IN THE MAP
	JSR PC,GCLSTA	;FIND THE C-LIST
	BEQ CPRSP1	;COULDN'T FIND IT
	ADD B,A		;POINT TO THE CAPABILITY DIRECTLY
	CMP 2(A),ITEM0	;IS IT THIS CURRENT PROCESS
	BEQ CPRSP1	;CAN'T DO IT.
	BIT #.SPCAD,(F)	;CAN I ADD TO THE SPHERE
	BEQ CPRSP1	;NOPE
	BIT #.PRWRA,(A)	;CAN I MOVE THIS PROCESS
	BEQ CPRSP1	;NOPE
	MOV 2(A),A	;GET THE PROCESS NO.
	MOV 2(F),B	;THE SPHERE NO.
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THAT SPHERE
	BEQ CPRSP1	;FAILED, MUST BE RUNNING OR TO MANY PROCESSES
CAPRS3:	ADD #6,P	;POP THE OTHER ARGUMENTS
	JMP ERETCZ	;DONE
CPRSP1:	ADD #6,P
	JMP ERETSZ
CAPRS1:	CLR F		;WHERE TO PUT WHAT FROM THERE
	MOV 2(P),B	;THE C-LIST NUMBER TO INVESTIGATE
	BIT #177400,B	;ANY BIT NUMBERS?
	BNE CPRSP1	;WELL NO CAPABILITY THERE
	MOV 2(A),A	;THE SPHERE TO READ FROM
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM1A,A	;THE PLACE TO INVESTIGATE IT AT
	JSR PC,GCLSTA	;GET THE C-LIST ENTRY
	BEQ CAPRS4	;FAILED
	ADD A,B		;POINT TO IT
	MOVB (B),F	;COPY IT
	BGE CAPRS2	;THERE IS CAPABILITY THERE
CAPRS4:	CLR F
CAPRS2:	MOV F,B
	JSR PC,GIVPSW	;GIVE HIM THE CAPABILITY
	JSR PC,ITM1PO
	BR CAPRS3

CAPRQU:	BPT
CAPRCL:	TST (P)+	;GET RID OF FIRST ARGUMENT
	MOV A,F		;COPY POINTER TO CAPABILITY
	REST D		;IF < 0 GRAB CONSUMER, ELSE RELEASE IT
	BMI CAPCL2	;TRY TO GRAB IN
	BIT #.CLCONS,(F)	;IS HE THE CONSUMER
	BEQ CAPCL1	;NO, RETURN SUCCESSFUL
	MOV 2(F),A	;THE POINTER TO THE CL
	JSR PC,ITM2LD	;LOAD IT UP
	CLR CLCONP(A)	;CLEAR THE CONSUMER POINTER
	BIC #.CLCONS,(F)	;CLEAR THE CONSUMER BIT
CAPCL1:	TST (P)+	;POP OFF OTHER ARG
	JMP ERETCZ	;RETURN SUCESSFULP
CAPCL2:	BIT #.CLCONS,(F)	;AM I THE CONSUMER ALREADY
	BNE CAPCL1	;YES, WIN
	MOV 2(F),A	;THE POINTER TO THE CL
	JSR PC,ITM2LD	;LOAD IT UP
	TST CLCONP(A)	;IS SOME ONE ELSE CONSUMER
	BNE CAPCL3	;YES, FAIL
	MOV ITEM0,CLCONP(A)	;SAY I AM THE CONSUMER
	BIS #.CLCONS,(F)	;SET THE BIT THAT SAYS SO
	BR CAPCL1	;RETURN SUCCESSFULL
CAPCL3:	TST (P)+	;POP OFF THIRD ARG
	JMP ERETSZ	;FAIL MISERABLY

;THIS CALL USES THE SAME CONVENTIONS ON READ/WRITE SELECT AS CAPRPR (40 BIT MEANS
;WRITE, CLEAR MEANS READ)  IF WRITE, 40 => MOV,41 => BIS,42 => BIC.
CAPRTT:	MOVB 1(P),B	;THE FUNCTION
	MOV B,C		;COPY IT
	BIC #40,B	;CLEAR THE WRITE BIT
	CMP B,#NTTFNC	;IS IT LEAGL
	BLOS CAPRT4	;YES
	ADD #6,P
	JMP ERETSZ
CAPRT4:	TST (P)+
	MOV 2(A),A	;THE TTY ITEM
	JSR PC,ITM2LD	;LOAD IT UP
CAPRT3:	CMP ITEM1,TTITM(A)	;DO I OWN THE TTY
	BEQ CAPRT1	;YES
CAPRT2:	JSR PC,LFLUSH	;WAIT FOR IT
	MOV ITM2A,A	;POINT TO THE TTY
	CMP ITEM1,TTITM(A)	;DO I OWN IT NOW
	BNE CAPRT2	;NO
	JSR PC,RUNME	;LETS GO
	BR CAPRT3	;MAKE SURE
CAPRT1:	ASL B		;CONVERT FUNCTION NUMBER TO WORD OFFSET
	JMP @TTIVTB(B)	;DISPATCH TO TTY INVOKE FUNCTION
CAPRT5:	TST (P)+	;FLUSH THIRD ARG
	JMP ERETCZ	;RETURN SUCESS FUL

;THIS SUBROUTINE CAN BE CALLED TO FORCE THE INVOK TO WAIT UNTIL THE
;OUTPUT BUFFER IS EMPTY
TOWAIT:	TST TOQN(A)	;IS THERE ANYTHING IN OUTPUT QUE?
	BEQ TOWAI2	;NO
TOWAI1:	JSR PC,LFLUSH	;GO AWAY FOR A WHILE
	TST TOQN(A)	;IS THE QUE EMPTY YET?
	BNE TOWAI1	;NO, WAIT SOME MORE
	JSR PC,RUNME	;GO AHEAD
	BR TOWAIT	;MAKE SURE
TOWAI2:	RTS PC

;RESET THE TTY'S IF WANTED
TTRST:	BIT #TORST,2(P)		;RESET OUTPUT?
	BEQ TTRST1		;NO
	BIC #TORST,2(P)		;TURN THE BIT OFF
	SAVE PS
	SPL 7
	MOV TTLTTY(A),E		;THE LOGICAL TTY NUMBER
	JSR PC,TYORT		;RESET OUTPUT
	REST PS
TTRST1:	BIT #TIRST,2(P)		;RESET INPUT?
	BEQ TTRST2		;NO
	BIC #TIRST,2(P)
	SAVE PS
	SPL 7
	JSR PC,TYIRT1		;RESET INPUT QUE
	JSR PC,TYBRT		;RESET INPUT BUFFER
	REST PS
TTRST2:	RTS PC

;MISCELLANEOUS TTY INVOKES
TTMOV:	JSR PC,TTRST	;RESET TTY'S IF DESIRED
	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	REST TTYST1(A)	;DO A MOVE INTO THE TTYST1 WORD
	BR CAPRT5
TTBIS:	JSR PC,TTRST	;RESET TTY'S IF DESIRED
	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIS (P)+,TTYST1(A)	;DO A BIS ON THE WORD
	BR CAPRT5
TTBIC:	JSR PC,TOWAIT		;WAIT FOR BUFFER TO CLEAR
	BIC (P)+,TTYST1(A)	;DO A BIC ON THE STATUS WORD
	BR CAPRT5
TTBS2:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIS (P)+,TTYST2(A)	;SET BITS IN TTYST2
	BR CAPRT5
TTBC2:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIC (P)+,TTYST2(A)	;CLEAR BITS IN TTYST2
	BR CAPRT5
TTRD:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	MOV TTYST1(A),B	;GET THE WORD
	BR TTCNO1	;GIVE HIM THE WORD AND RETURN
TTCNO:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	MOV CHARNO(A),B	;GET THE WORD
TTCNO1:	ADD #4,P
	JSR PC,GIVPSW	;GIVE IT TO HIM
	JMP ERETCZ	;SUCCESSFUL RETURN
TTMV2:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	REST TTYST2(A)	;SET TTYST2
	BR CAPRT5
TTTYP:	MOV TTLTTY(A),E	;THE LOGICAL TTY NO.
	MOV TTYTBL(E),B	;THE INFO ABOUT WHAT KIND OF TTY IT IS
	BR TTCNO1	;RETURN IT TO THE USER
TTSPD:	MOV TTLTTY(A),E	;THE LOGICAL TTY NO.
	BIT #DHF,TTYTBL(E)	;IS IT A DH11?
	BNE .+6		;YES, EVERYTHING IS OKAY
	JMP ERETSZ	;CANT SET ANYONE ELSE'S SPEED
TTSPD1:	SPL 5		;STOP IT FROM CHANGING
	BIT #TOTRAN,TTYST1(A)	;IS IT TRANSMITTING?
	BEQ TTSPD3	;NO, WE CAN MUNG IT
TTSPD2:	SPL 0		;LOWER PRIORITY
	JSR PC,SFLUSH	;WAIT FOR A SHORT TIME
	SPL 5
	BIT #TOTRAN,TTYST1(A)	;TRANSMITTING?
	BNE TTSPD2	;YES
	SPL 0
	JSR PC,RUNME	;IT HAS STOPPED FOR A WHILE
	BR TTSPD1	;NOW TRY TO CHANGE THE SPEED
TTSPD3:	SUB #NFDHTY,E	;GET THE DH LINE NO.
	ASR E		;INTO A NUMBER
	BIC #17,DH0SCR	;CLEAR THE LINE NO.
	BIS E,DH0SCR	;SET IN THE NEW ONE
	REST C		;GET THE SPEED
	BIC #37700,DH0LPR	;ZERO THE OLD SPEED
	BIS C,DH0LPR	;SET IN THE NEW
	SPL 0		;BACK TO LOW LEVEL
	JMP ERETCZ	;AND RETURN


;THIS TTY INVOK CAN BE USED TO IMPLEMENT CONTROL Z TYPE BREAKS. THE IDEA
;IS THAT THE USER JOB HAS A PROCESS WHICH SIMPLY MAKES THIS CALL TO CHECK
;FOR ONE OF THE BREAK CHARS.  THE PROCESS HANGS UNTIL THE CALL SUCCEEDS
;WHICH DEPENDS ON THE ARGUMENT TO THE CALL.  TWO CONDITIONS CAN MAKE THE
;CALL SUCCEED WHICH CORRESPOND TO THE TWO ARUGMENTS TO THE CALL.  THE
;FIRST ARGUMENT IS A PAIR OF BYTES. IF ANY OF THE TYPED IN CHARS HAPPENS
;TO EQUAL ONE OF THESE BYTES THEN THE CALL SUCCEEDS.  THE SECOND ARG IS
;A NUMBER SUCH THAT IF ANY OF THE TYPED IN CHARS IS LESS THAN THIS NUMBER
;THEN THE CALL ALSO SUCCEEDS.  A TYPICAL NUMBER MIGHT BE 40, IN WHICH CASE,
;THE CALL WOULD SUCCEED ANY TIME A CONTROL CHAR WAS TYPED. THE ACTUAL CHAR
;TYPED IS RETURNED ON THE USER'S STACK.  NOTE TWO INHERENT BUGS IN THIS CODE:
;FIRST, SINCE THE LAST CHAR IS CHECKED AT LONG-FLUSHED FREQUENCEY, A CHAR
;COULD POTENTIALLY GO BY WITHOUT BEING CHECKED, EG THE USER IS TYPING VERY FAST.
;SECOND, IF TWO PROCESSES MAKE THIS CALL, THEN THE FIRST ONE TO SUCCEED WILL
;CLEAR THE LAST CHAR WORD, SO THAT THE OTHER CANNOT SUCCEED.
TTBRK:	REST B		;SECOND ARG IS A PAIR OF CHARS TO CHECK FOR
	MOV B,C		;MAKE A COPY
	SWAB C		;GET THE HIGH BYTE CHAR
	BIC #177600,B	;CLEAN OFF THE CRUFT
	BIC #177600,C	;AGAIN
	REST E		;THIRD ARG IS THE NUMBER
	JSR PC,TTBCHK	;SHOULD WE BREAK HERE?
	BEQ TTBRK2	;NO
TTBRK1:	JSR PC,GIVPSW	;TTBCHK RETURNS VALUE IN B
	JMP ERETCZ	;SUCCEED
TTBRK2:	JSR PC,LFLUSH	;GO AWAY FOR A WHILE
	JSR PC,TTBCHK	;SHOULD WE BREAK HERE
	BEQ TTBRK2	;NO
TTBRK3:	JSR PC,RUNME	;AS IT SAYS...
	BR TTBRK1	;RESTART TO MAKE SURE

;THIS SUBROUTINE CHECKS IF THE BREAK PROCESS SHOULD BE RELEASED FOR ANY
;REASON AND SETS UP THE CHAR TO RETURN TO THE USER IS IT SHOULD. IT CLEARS
;Z IF THE BREAK SHOULD COMPLETE.  EXPECTS CHECK CHARS IN B AND C, AND THE
;CHECK NUMBER IN E, LOW BYTE, FLAGS IN HIGH BYTE.
TTBCHK:	MOV TLAST(A),F	;GET THE LAST CHAR TYPED
	BEQ TTBCH0	;JUST CHECK FOR MORE BREAK
	CLR TLAST(A)	;SO WE DON'T GET THIS AGAIN
	CMPB F,B	;IS IT ONE OF THE BYTES TO CHECK FOR?
	BEQ TTBCH1	;YES
	CMPB F,C	;HOW ABOUT THE OTHER CHAR?
	BEQ TTBCH1	;YUP
	CMPB F,E	;IS IT PERHAPS LESS THAN THE NUMBER?
	BLT TTBCH1	;YES
TTBCH0:	BIT #.TTMBK,E	;DOES HE WANT TO DO MORE BREAKS?
	BEQ TTBCH3	;NO
	BIT #.TMORM,TTYST1(A)	;IS MORE PROCESSING ENABLED?
	BEQ TTBCH3	;NO, HANG AROUND FOR A WHILE
	BIT #.TMORF,TTYST1(A)	;IS MORE TRIGGERED?
	BEQ TTBCH3	;NO, HANG AROUND
	MOV #.TTMBK,B	;TELL THE CALLER THIS IS A MORE BREAK
	BR TTBCH2
TTBCH1:	MOV F,B		;GET THE CHAR
	BIC #177400,B	;CLEAR THE HIGH BYTE
	BIS #.TTIBK,B	;TELL HIM THIS IS AN INPUT BREAK
	CLR TLAST(A)	;FLUSH THE OLD LAST CHAR
TTBCH2:	CLZ		;SUCCEED
	RTS PC
TTBCH3:	SEZ		;FAIL
	RTS PC

.IFNZ NTVS
;TV INVOKES  WHICH ARE ACTUALLY INVOKES OF TTY CAPABILITY
;TVATC ATTACHES A TV DISPLAY TO A TTY AND KEYBOARD.  THE SECOND
;ARGUMENT TO THE INVOKE IS THE CAPABILITY INDEX OF THE DISPLAY.
TVATC:	REST B		;GET THE DISPLAY CAPABILITY NUMBER
	MOV #ITM1AD,A	;GET THE SPHERE ADDRESS IN B
	JSR PC,GCLSTA	;GET THE OFFSET OF THE CAPABILITY INTO SPHERE
	BEQ TVATC1	;BAD INVOK
	ADD B,A		;GCLSTA RETURNS THE OFFSET IN B
	CMPB (A),#.DSCAP ;MAKE SURE ITS A DISPLAY CAP
	MOV CLSEM0(A),B	;GET THE NUMBER OF THIS DISPLAY
	ASR B		;CONVERT FROM WORD OFFSET TO NUMBER
	SUB #NFTVDS,B	;MAKE SURE IT'S A TV DISPLAY
	BLT TVATC1	;ITS NOT, BAD INVOKE
	CMP B,#NTVS	;IN CASE THE CAP IS SCREWED UP
	BUGC LT
	MOV #ITM2AD,A	;ADDRESS OF THE TTY ITEM
	MOVB TVDSBF(B),C	;GET THE BUFFER NUMBER OF THIS DISPLAY
	BUGC GE		;IT HAD BETTER HAVE A BUFFER ASSIGNED
	CMP C,#NTVCHN	;IN CASE IT'S SCREWED UP
	BUGC LT
	MOV C,TVBUF(A)	;GIVE THIS TV TTY A BUFFER
	INCB TVDSRF(B)	;ONE MORE THING IS REFERENCING THIS BUFFER
	MOV TTLTTY(A),B	;GET THE LOGICAL TTY NUMBER
	MOVB #-15.,TVBLNK(B)	;TURN ON THE CURSOR FOR THIS TV
	ADD #2,P	;POP THE THIRD ARG
	JMP ERETCZ	;SUCCEED
TVATC1:	ADD #2,P	;CLEAN UP
	JMP ERETSZ	;FAIL
.IFF
TVATC:	ADD #4,P
	JMP ERETSZ
.ENDC

.IFNZ NTVS
;THE FOLLOWING INVOKE CAN BE USED TO CLEAR AND GENERALLY RESET THE SCREEN
TVCL:	JSR PC,TOWAIT	;WAIT UNTIL THE OUTPUT BUFFER CLEARS
	SAVE PS
	SPL 7		;TEMPORARILY
	JSR PC,TVINIT	;INITIALIZE TV VARIABLES, PUSH THE FONT IN ITEM 1
	BEQ TVCL1	;IN CASE TVINIT FAILS
	JSR PC,TVCS	;CLEAR THE SCREEN
	CLR CHARNO(A)	;CURSOR IN POSITION 0. NOTE A SET UP BY TVINIT
	CLR LINENO(A)	;CLEAR THE LINE NUMBER
	JSR PC,ITM1PO	;POP THE FONT ITEM, SET UP BY TVINIT
	REST PS		;BACK TO NORMAL PRIORITY
	ADD #4,P	;CLEAN OFF THE ARGUMENTS
	JMP ERETCZ	;SUCCEED
TVCL1:	REST PS		;BACK TO NORMAL PRIORITY
	ADD #4,P	;POP THE ARGUMENTS
	JMP ERETSZ	;FAIL
.IFF
TVCL:	ADD #4,P
	JMP ERETSZ
.ENDC

;THIS INVOK IS USED FOR REVERSING WHITE AND BLACK ON SCREEN
.IFNZ NTVS
TVREV:	SAVE PS
	SPL 7
	JSR PC,TVINIT	;INITIALIZE THE TV VARIABLES
	BEQ TVREV1	;IN CASE TVINIT FAILS
	JSR PC,REVSCR	;DO THE REVERSE
	JSR PC,ITM1PO	;POP THE FONT ITEM SET UP BY TVINIT
	REST PS
	ADD #4,P	;CLEAN UP
	JMP ERETCZ	;SUCCEED
TVREV1:	REST PS
	ADD #4,P	;CLEAN UP
	JMP ERETSZ	;FAIL
.IFF
TVREV:	ADD #4,P
	JMP ERETSZ
.ENDC	
	
;CHANGE THE FONT OF A TV
.IFNZ NTVS
TVFNT:	JSR PC,TOWAIT	;WAIT UNTIL THE BUFFER CLEARS
	REST B		;THE NUMBER OF THE FONT THAT HE WANTS
	BLT TVFNT1	;ERROR, NO NEGATIVE FONT NUMBERS
	CMP B,#NFONTS	;IS IT GREATER THAN THE NUMBER OF FONTS?
	BGE TVFNT1	;YES, ERROR
	ASL B		;CONVERT TO WORD INDEX
	MOV FNTITM(B),A	;GET THE FONT ITEM FOR THIS FONT
	BLE TVFNT1	;NONE
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM2A,C	;ADDRESS OF THE TTY ITEM
	MOV FNHIGH(A),D	;NUMBER OF LINES IN A CHAR
	DEC D		;THIS IS USED FOR LOADING TVWC BY BLINK ETC
	NEG D		;ALLOW 1 FOR LOADING TVRWIN. TVWC EXPECTS NEGATIVE COUNT.
	MOV D,TVLCNT(C)	;LINES IN CHAR MINUS ONE
	MOV FNLINE(A),TVHIGH(C)	;NUMBER OF CHAR LINES ON THE SCREEN
	MOV FNLINL(A),LINEL(C)	;NUMBER OF CHARS PER LINE
	MOV FNLSC(A),TVNLSC(C)	;NUMBER OF LINES TO SCROLL
	JSR PC,ITM1PO	;POP THE FONT ITEM
	MOV B,TVFONT(C)	;SET IN THE NUMBER FOR THIS FONT
	MOV C,A		;COPY TTY ITEM ADDRESS
	CLR -(P)	;PUSH A DUMMY ARGUMENT
	JMP TVCL	;AND DO A CLEAR SCREEN BEFOR RETURNING
TVFNT1:	ADD #2,P	;POP THE NULL ARG
	JMP ERETSZ	;FAIL
.IFF
TVFNT:	ADD #4,P	;POP THE ARGS
	JMP ERETSZ	;FAIL
.ENDC
.IFNZ NTVS
TVSET:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIT #40,C	;DOES HE WANT READ?
	BNE TVSET1	;NO WRITE
	MOV TVCUR(A),B	;THE CHAR POSITION ON LINE
	JSR PC,GIVPSW	;GIVE IT TO HIM
	MOV TVLINE(A),B	;THE LINE NUMBER OF CURSOR
	JSR PC,GIVPSW	;GIVE IT TO HIM
	ADD #4,P	;POP THE ARGS
	JMP ERETCZ	;SUCCEED
TVSET1:	REST C,D	;TVLINE AND TVCUR
	CMP C,TVHIGH(A)	;MAKE SURE IT'S LEGAL
	BGE TVSET2	;TOO HIGH
	CMP D,LINEL(A)	;LENGTH OF A LINE
	BGE TVSET2	;CANNOT PUT IT THERE
	SAVE PS
	SPL 7		;SO THE CURSOR WILL NOT GET CONFUSED
	MOV C,TVLINE(A)	;SET THE TVLINE
	MOV D,TVCUR(A)	;AND THE CHAR NO.
	JSR PC,TVINIT	;LOAD UP FONT ITM ETC
	BEQ TVSET3	;IN CASE INIT FAILS
	JSR PC,RSCUR	;RESET THE VARIABLES
	JSR PC,ITM1PO	;POP THE FONT ITEM
	REST PS		;BACK TO NORMAL PRIORITY
	JMP ERETCZ	;SUCCEED
TVSET3:	REST PS		;BACK TO NORMAL PRIORITY
TVSET2:	JMP ERETSZ	;FAIL
.IFF
TVSET:	ADD #4,P
	JMP ERETSZ	;FAIL
.ENDC
.IFNZ NTVS
TVOFF:	JSR PC,TOWAIT		;WAIT UNTIL BUFFER CLEARS
	BIT #.PRWRT,C		;DOES HE WANT TO READ OR WRITE
	BNE TVOFF1		;WRITE
	MOV TVOFFL(A),B		;GET TVOFFL
	JSR PC,GIVPSW		;RETURN IT TO USER
	ADD #4,P		;POP THE ARGUMENTS
	JMP ERETCZ		;SUCCEED
TVOFF1:	MOV (P),TVOFFL(A)	;FIRST ARG GOES INTO TVOFFLE
	JMP TVCL		;NOW CLEAR THE SCREEN BEFORE RETURNING
.IFF
TVOFF:	ADD #4,P
	JMP ERETSZ		;FAIL
.ENDC

;RETURN THE WIDTH OF CHAR AND TV LINES PER CHAR LINE FOR CURRENT FONT
TVRFN:	ADD #4,P		;NO ARGUMENTS
.IFNZ NTVS
	JSR PC,TVINIT		;LOAD UP THE FONT
	BEQ TVRFN1		;IN CASE THERE IS NO FONT
	MOV FNWIDE(B),E		;WIDTH OF A CHAR
	MOV FNTLCL(B),F		;NUMBER OF TV LINES IN 1 CHAR LINE
	JSR PC,ITM1PO		;POP THE FONT ITEM
	MOV E,B
	JSR PC,GIVPSW		;RETURN THE WIDTH
	MOV F,B
	JSR PC,GIVPSW		;RETURN THE HEIGHT
	JMP ERETCZ		;SUCCEED
TVRFN1:	JMP ERETSZ		;FAIL
.IFF
	JMP ERETSZ
.ENDC

CAPRDS:	.IFZ NTKDIS+NTVS
	BPT
	.IFF
	BITB #100,1(P)	;IS THIS AN OLD STYLE DISPLAY?
	BNE CAPRD5	;NO
	.ENDC
CAPRD3:	.IFZ NTKDIS
	BPT
	.IFF
	TST (A)		;IS THIS AN OLD DISPLAY?
	LBR LT,BADEMT	;NO, NEW ONE
	SAVE <A>	;POINTER TO CAP
	MOV TKDPDL,A	;THE PDLS ETC
	JSR PC,ITM2PL	;LOAD THEM TOO
	REST <A,D>
	SWAB D		;GET THE FUNCTION
	TSTB D
	BEQ CAPRD1	;GO START THE DISPLAY
	CMPB #1,D	;IS IT ONE?
	BEQ CAPRD2	;YES, STOP THE DISPLAY
	ADD #4,P
	JSR PC,ITM2PO
	JMP BADEMT	;NAUGHTY!
CAPRD2:	JSR PC,TKDSP	;STOP IT
CAPRD4:	ADD #4,P
	JSR PC,ITM2PO
	JMP ERETCZ	;WIN
CAPRD1:	JSR PC,TKDSP	;MAKE SURE IT IS STOPPED
	ASL C
	BIC #177760,C	;CONVERT DISPLAY NUMBER TO AN INDEX
	ADD ITM2A,C	;POINT TO THE FIRST WORD EXECUTED FOR THIS DISPLAY
	MOV (P),A	;THE START ADDRESS
	BIS #DPUSHJ,A	;IT IS A PUSHJ
	MOV A,(C)
	BIC #100000,TKDRUN(D)	;START IT ON INT LEVEL
	BR CAPRD4
.ENDC

;TV DISPLAY INVOKES. THESE ARE CALLED WITH A NEGATIVE
;FUNCTION NUMBERS.
CAPRD5:	.IFZ NTVS
	BPT
	.IFF
	MOV CLSEM0(A),C		;GET LOGICAL DISPLAY NUMBER
	BUGC GE			;MUST BE POSITVE
	ASR C			;TV DISPLAYS USE BYTE DATA
	SUB #NFTVDS,C		;GET THE TV NUMBER
	BLT CAPRD6		;IT'S A TK DISPLAY!!!
	CMP C,#NTVS		;MAKE SURE IT'S LEGAL
	BUGC LT			;TOO BIG
	MOVB TVDSBF(C),E	;GET THE BUFFER OF THIS TV
	ASL E			;FOR NOW, WORD OFFSET
	MOVB 1(P),B		;THE FUNCTION HE WANTS
	TST (P)+		;POP THE FIRST ARG
	REST <C,D>		;THE OTHER TWO ARGS
	BIC #100,B		;MAKE INTO SMALL INTEGER
	CMP B,#TVDSIM		;IS IT A LEGAL FUNCTION?
	BGE CAPRD6		;NO!
	ASL B			;OK, SO MAKE INTO WORD OFFSET
	JSR PC,@TVDSIT(B)	;NOW EXECUTE THE FUNCTION
	BEQ CAPRD6		;IN CASE SOMETHING WENT WRONG
	JMP ERETCZ		;EVERTHING'S OK, WE'RE DONE
CAPRD6:	JMP ERETSZ		;OH OH, SOMETHING WENT WRONG


;READ THE CURSOR (OR TURTLE) POSITION
TVDSRC:	MOV TVDSCX(E),B		;THE X POSITION
	JSR PC,GIVPSW		;GIVE IT TO HIM
	MOV TVDSCY(E),B		;THE Y POSITION
	JSR PC,GIVPSW		;LAY IT ON HIM
	CLZ			;SUCCEED
	RTS PC

;SET THE CURSOR POSITION
;TVDSSC CHECKS THE NEW CURSOR POSITION AND UPDATES IT IF IT'S LEGAL
TVDSSC:	TST C			;MAKE SURE IT'S POSITIVE
	BLT TVDSS1		;BAD
	CMP C,#455.		;IS IT TOO HIGH?
	BGE TVDSS1		;YES
	TST D			;THIS ALSO CANNOT BE NEGATIVE
	BLT TVDSS1		;BAD
	CMP D,#576.		;IT X TOO HIGH?
	BGE TVDSS1		;YES!
	MOV C,TVDSCY(E)		;THE NEW Y
	MOV D,TVDSCX(E)		;AND THE NEW X
	CLZ			;OK
	RTS PC
TVDSS1:	SEZ			;SOMETHING WENT WRONG
	RTS PC

;TVDSNL DRAWS A LINE WITH THE PEN UP. IE, IT SETS THE CURSOR
;TO A RELATIVE POSITION JUST LIKE THE REAL LINE DRAWERS
TVDSNL:	SAVE <C,D>		;GET SOME REGISTERS
	MOV TVDSCY(E),A		;OLD Y POSITION
	MOV TVDSCX(E),B		;OLD X POSITION
	ADD A,C			;OLD X + DELTA X
	ADD B,D			;OLD Y + DELTA Y
	JSR PC,TVDSSC		;TRY TO UPDATE THE CURSOR
	BEQ TVDSN1		;SOMETHING WRONG WITH NEW POSITION
	REST <D,C>		;PUT THE INCREMENTS BACK
	CLZ			;SUCCEED
	RTS PC
TVDSN1:	ADD #4,P		;POP THE STUFF WE SAVED
	SEZ			;FAIL
	RTS PC

;TVDSIL IOR'S A LINE ON THE SCREEN
TVDSIL:	JSR PC,TVDSNL		;UPDATE THE CURSOR
	BEQ TVDSX2		;SOMETHING WENT WRONG
	ASR E			;GET THE TV BUFFER NUMBER
	BIS #TVIOR,E		;IOR MODE
	BR TVDSX1		;DRAW THE LINE AND RETURN

;TVDSXL XOR'S A LINE ON THE SCREEN
TVDSXL:	JSR PC,TVDSNL		;UPDATE THE CURSOR
	BEQ TVDSX2		;SOMETHING WRONG
	ASR E			;GET THE BUFFER NUMBER
	BIS #TVXOR,E		;XOR MODE
TVDSX1:	JSR PC,DRAW		;DRAW THE LINE
	CLZ			;SUCCEED
	RTS PC
TVDSX2:	SEZ			;FAIL
	RTS PC

;TVDSCL CLEARS AN AREA OF THE SCREEN
TVDSCL:	JSR PC,TVDSNL		;UPDATE THE CURSOR, CHECK BOUNDS
	BEQ TVDSX2		;FAIL
	ASR E			;THE TV BUFFER NUMBER
	JSR PC,SCRCLR		;CLEAR THE SCREEN
	CLZ			;SUCCEED
	RTS PC

.ENDC
	.STITL CREATE CAPABILITY ROUTINES
CCPRXX:	BPT	;THE ZERO CAPABILITY
CCPRSP:	ADD #6,P
	JMP BADEMT	;CAN'T CREATE A SPHERE CAPABILITY, HAVE TO COPY FROM MASTER
CCPRCC:	CLR B
	MOV #.CCCAP,A	;THIS IS EASY
CCRTS:	RTS PC

;CREATE A MASTER SHPERE CAPABILITY
CCPRMS:	JSR PC,CRSPHR	;CREATE THE ACTUAL SPHERE
	BEQ CCRTS	;NO SPHERE AVAILABLE
	MOV A,B		;THE ITEM NO OF THE SPHERE
	MOV E,C		;ENTER ADDRESS IS 2ND ARG TO CALL
	MOV #MSPCBT!.MSCAP,A	;THE TYPE AND FLAGS
	RTS PC
;CREATE A PROCESS CAPABILITY
CCPRPR:	JSR PC,CRPROC	;CREATE THE ACTUAL PROCESS
	BEQ CCRTS	;NO PROCESS AVAILABLE
	MOV A,B		;FOR THE LOCK ROUTINE 
	JSR PC,ITM0PL	;LOAD IT UP
	MOV E,C	;GET THE STARTING ADRS FOR THE PROCESS
	MOV C,PUPC(A)	;PUT THE STARTING ADRS. INTO ITS USER PC
	JSR PC,ITM0PO	;GET BACK THE ORIGINAL PROCESS
	MOV #.PRCAP!.PRWRA,A	;ITS A PROCESS CAPABILITY
	RTS PC			;SUCCESS
CCPRTT:	CMP E,#NTTYS	;IS IT A LEGAL TTY NO.
	BGT CCPRT1	;NOPE TO LARGE
	ASL E		;TURN IT INTO THE WORD INDEX
	TST TTYITM(E)	;IS THERE ALREADY A ITEM FOR THIS TTY
	BGT CCPRT1	;YES, THIS IS A BAD CALL THEN
	BIT #MXEEF,TTYTBL(E)	;IS IT A MULTIPLEXOR?
	BEQ CCPRT2	;NO
	SAVE E		;THE TTY NUMBER
	MOVB TTYTBL(E),E	;GET THE NUMBER OF THE MULTIPLEXOR TTY
	MOV TTYITM(E),A	;IS THERE A TTY FOR THE MULTIPLEXOR
	BNE CCPRT3	;YES, JUST CREATE THE MULTIPLEXEE
	JSR PC,CRTTY	;CREATE THE TTY
	BEQ CCPRT5	;FAILED
	;HERE PUT IN SOMETHING TO CLEAN UP IF IT LOSES
	MOV B,A		;THE ITEM NO. OF MXOR
	JSR PC,ITM2LD	;LOAD IT UP
	ADD TOQI(A),A	;POINT TO START OF OUTPUT QUEUE
	MOV #NFNLTY,D	;POINT TO PSEUDO TTYS
	MOV #NNLTY,B	;NUMBER OF TTY'S TO CHECK
CCPRT7:	CMPB TTYTBL(D),E	;IS IT THE MULTIPLEXOR?
	BNE CCPRT8	;NOT THIS ONE
	MOVB D,(A)+	;PUT IT INTO QUEUE
CCPRT8:	TST (D)+	;SKIP THIS TTY NEXT TIME
	SOB B,CCPRT7
	BR CCPRT6	;NOW OPEN UP THE MULTIPLEXEE
CCPRT3:	JSR PC,ITM2LD	;LOAD UP THE TTY
	TST TTYU(A)	;IS IT REALLY OWNED OR JUST OPENED BY THE SYSTEM
	BEQ CCPRT4	;OPENED BY THE SYSTEM
	CMP TTYU(A),CURUSR	;IS IT OPENED BY THE CURRENT USER
	BNE CCPRT1	;NO, SO HE LOSES ON THE OPEN
CCPRT4:	INC TTYREF(A)	;INCREMENT ITS REFERENCE COUNT
CCPRT6:	REST E		;GET BACK THE MULTIPLEXEE'S TTY NO.
CCPRT2:	JSR PC,CRTTY	;CREATE THE TTY
	BEQ CCPRT1	;IT FAILED FOR SOME REASON
	MOV #.TTCAP!.TTYI!.TTYO,A	;GIVE HIM I/O CAPABILITY
	RTS PC
CCPRT5:	TST (P)+
CCPRT1:	SEZ
	RTS PC

;CREATE A QUE CAPABILITY
CCPRQU:	MOV E,C	;THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
	JSR PC,CRQUE	;CREATE THE QUE
	BEQ CCPRQ1	;FAILED
	CLR C		;NO DATA WORDS
	MOV #.QUCAP,A	;THE TYPE
CCPRQ1:	RTS PC

;CREATE A QUE ITEM, C CONTAINS THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
CRQUE:	MOV #QUELEN,A	;LENGTH OF QUE
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRQUE2	;FAILED
	MOV B,A		;THE ITEM NO
	JSR PC,ITM2PL	;LOAD TI
	MOV #ITQUE,(A)	;SET THE TYPE
	CLR QUECNT(A)	;NOONE ON THE QUE TO START
	MOV C,QUENUM(A)	;THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
	MOV #1,QUEREF(A)	;ASSUME THE GUY WHO CREATES IT IS GOING TO REFERENCE IT
	MOV #QUESZ/2,QUEENO(A)	;THE NUMBER OF ENTRIES IN THE QUE
	JSR PC,ITM2PO	;POP THE QUE
	CLZ
	RTS PC
CRQUE1:	SEZ
CRQUE2:	RTS PC

CCPRTR:	TST PTRITM	;IS THERE ONE ALREADY
	BNE CRQUE1	;YES, LOSER
	MOV #PTRLEN,A	;GET THE LENGTH
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRQUE2	;FAILED FOR RANDOM REASON
	MOV B,A		;GET THE ITEM NO.
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #ITPTR,(A)+	;SET IN THE TYPE
	MOV #1,(A)+	;THE REFERENCE COUNT
	MOV #PTRBUF,(A)	;THE START OF THE BUFFER
	MOV (A)+,(A)+	;SET IN THE DATA OUT POINTER
	CLR (A)+	;NOTHING IN BUFFER CURRENTLY
	JSR PC,ITM2PO	;POP IT
	MOV B,PTRITM	;SAY THIS IS THE PTR ITEM
	MOV #1,PTRSR	;SET THE INTERRUPT ENABLE
	CLR C		;NO SECONDARY ITEM
	MOV #.TRCAP,A
	RTS PC

CCPRTP:	TST PTPITM	;PAPER TAPBE ITEM
	BNE CRQUE1	;FAIL THERE ALREADY IS ON
	MOV #PTPLEN,A	;GET THE LENGTH
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRQUE2	;FAILED
	MOV B,A		;COPy THE ITEM NO.
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #ITPTP,(A)+	;TYPE
	MOV #1,(A)+	;REFERENCE COUNT
	MOV #PTPBUF,(A)	;THE POINNTER TO START
	MOV (A)+,(A)+	;SET IT IN
	CLR (A)+	;NOTHING IN THE BUFFER
	JSR PC,ITM2PO	;POP IT
	MOV #.TPCAP,A	;THE TYPE OF CAPABLITY
	CLR C		;NOTHING
	MOV B,PTPITM	;THE ITEM IS NOW HERE
	RTS PC

;CREATE A CORE LINK CAPABILITY, LENGTH OF BUFFER IN E
CCPRCL:	MOV E,A		;COPY LENGTH
	BLE CRQUE1	;BAD LENGTH
	ADD #CLDATL,A	;ADD THE NUMBER OF DATA WORDS
	ASH #-6,A	;GET THE LENGTH IN 32. WORD BLOCKS
	CMP A,#1	;IS IT MORE THAN 2 BLOCKS
	BGT CRCL1	;YES, MAKE AN FUPT FOR IT
	JSR PC,CRITEM	;CREATE AN ITEM
	BEQ CCPRQ1	;FAILED
	MOV B,A		;COPY THE ITEM NO. CREATED
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #ITCL,(A)+	;SET IN THE TYPE
	MOV B,C		;GET THE ITEM NO.
CRCL2:	MOV #1,(A)+	;SET IN THE REFENCE COUNT
	CLR (A)+	;SAY THERE IS NO CONSUMER
	CLR (A)+	;CLEAR THE COUNT OF VALID DATA
	MOV E,(A)+	;SET IN THE NUMBER OF ENTRIES
	MOV #CLDATL,(A)	;SET IN THE DATA IN POINTER
	MOV (A)+,(A)	;SET IN THE DATA OUT POINTER
	SAVE B
	JSR PC,ITM2PO	;POP THE ITEM
	MOV #.CLCAP,A	;THE TYPE
	BIT #GIPBIT,C	;IS IT IN A SPHERE
	BNE CRCL4		;NO	
	REST B
	CLZ
	RTS PC
CRCL4:	MOV (P),B		;THE GIP TO THE FUPT
	BIC #GIPBIT,B
	CLR FUPTPR(B)	;SAY NO ONE OWNS IT NOW
	REST B
	CLZ
	RTS PC
CRCL1:	ASH #-4,A	;CONVERT 32 WORD BLOCKS TO 512 WORD BLOCKS
	MOV A,B		;COPY
	MOV A,D		;TWICE
	CMP #7,A	;MORE THAN 4K?
	ERRORC LT,BAD	;BAD ARG
	JSR PC,FRCRGT	;GET SOME FREE CORE
	ERRORC EQ,NSS	;NO SWAP SPACE AVAILABLE
	MOV B,A		;GIP FOR CREATED CORE
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #ITCL,(A)+	;SWAP IT IN
	JSR PC,LSWPOP	;NOW WE ARE SURE TO RUN TO COMPLETION
	BR CRCL2	;GO FINISH UP
;CREATE DISPLAY CAPABILITY
CCPRDS:	.IFZ NTKDIS+NTVS
	SEZ
	RTS PC		;NO DISPLAYS
.ENDC
.IFNZ NTVS
	TST E		;DOES HE WANT THE ONE ASSOCIATED WITH TTY?
	BGE CCPRD7	;NO
	MOV E,B		;THIS HAS THE CAP INDEX OF TTY IN HIGH BYTE
	BIC #177600,B	;CLEAN OFF THE 377
	MOV #ITM1AD,A	;ADDRESS OF THE SPHERE
	JSR PC,GCLSTA	;GET THE OFFSET OF THE CAPABILITY INTO SPHERE
	BEQ CCPR15	;Z SET MEANS BAD CAPABILITY NUMBER PASSED TO GCLSTA
	ADD B,A		;THE OFFSET IS RETURNED IN B, GET THE ADDRESS OF CAP
	CMPB (A),#.TTCAP	;MAKE SURE IT WAS A TTY
	BEQ .+6	;IT WASN'T SO FAIL
CCPR15:	JMP CCPR12
	MOV CLSEPI(A),A	;GET THE TTY ITEM NUMBER
	JSR PC,ITM2PL	;LOAD IT UP
	MOV TTLTTY(A),C	;GET THE LOGICAL TTY NUMBER OF THIS TTY
	JSR PC,ITM2PO	;POP THE TTY ITEM
	BIT #TVF,TTYTBL(C)	;IS IT A TV?
	BNE CCPRD8
	BIT #40000,E	;DOE SHE WANT A TV?	
	BNE CCPRD5	;LOSE
	TST TYDISP(C)	;DOES IT EXIST
	BLT CCPRD5	;NO
	BIC #377,E	;CLEAR OUT THE TTY NO.
	BIS TYDISP(C),E	;GET TK DISP NEAR TTY
.ENDC
.IFZ NTKDIS
	SEZ
	RTS PC		;NO TK DISPLAYS
.IFF

	MOV #DISMAL,A		;START LOOKING FOR A SMALL ONE
	BIT #400,E
	MOV #DISBIG,A	;HE REALLY WANTS A BIG ONE
	CLR B		;INDEX TO DISPLAY TABLES
	MOV #NTKDIS,C	;NUMBER OF BUFFERS AVAILABLE
CCPRD3:	CMP #-1,TKDRUN(B)	;AVAILABLE?
	BNE CCPRD1	;NOPE
	CMP A,TKDLEN(B)	;ADEQUATE SIZE?
	BGE CCPRD2	;YES!
CCPRD1:	TST (B)+	;NEXT!
	SOB C,CCPRD3
CCPRD5:	SEZ		;RAN OUT OF POSSIBLITES
	RTS PC
CCPRD2:	MOVB E,C	;GET THE DISPLAY NUMBER HE WANTS
	BGE CCPRD4	;HE KNOWS WHICH HE WANTS
	BPT		;HERE GET THE ONE NEAR HIS TTY
CCPRD4:	TSTB TKDOWN(C)	;IS THAT DISPLAY FREE?
	BNE CCPRD5	;NOPE, YOU LOSE
	MOVB #1,TKDOWN(C)	;USED NOW!
	JSR PC,TKDSTP	;MAKE SURE IT IS STOPPED
	BIS #100000,C	;OWNED, BUT DON'T START IT YET
	MOV C,TKDRUN(B)	;IT BELONGS TO HIM
	MOV B,C		;INDEX TO TABLES IS FIRST MISC WORD
	MOV TKDITM(C),D	;THE ITEM FOR THE DISPLAY
	MOV ITMTAB(D),B	;GET THE ADDRESS IN 32 WORD BLOCKS
	SUB TKDPDA,B	;SUBTRACT START OF DISPLAY WORLD IN 32 WORD BLOCKS
	ASH #5,B
	JSR PC,GIVPSW	;RETURN THE OFFSET IN WORDS
	MOVB ITLNGT+ITMTAB(D),B	;LENGTH IN 32 WORDS
	INC B		;MINUSE ONE
	ASH #5,B	;MAKE IT WORDS
	JSR PC,GIVPSW	;RETRUN IT
	MOV D,B		;SO THE ITEM GETS SAVED
	MOV #.DSCAP,A	;AND THE TYPE
	RTS PC
TKDSP:	MOV 6(A),D	;THE DISPLAY INDEX
	BIS #100000,TKDRUN(D)	;SO INT LEVEL WON'T START IT
	MOV TKDRUN(D),C	;THE DISPLAY NUMBER
TKDSTP:	SAVE <C>
	BIC #177400,C	;JUST THE DISPLAY
	BIS #TKSTOP,C
	MOV C,NGCSR
	REST <C>
	RTS PC
.ENDC
.IFNZ NTVS
CCPRD7:	MOVB E,C	;NUMER OF THE DISPLAY HE WANTS
	CMPB C,#NFTVDS+NTVS	;THERE ARE ONLY THIS MANY DISPLAYS
	BGE CCPR12	;TOO HIGH! FAIL.
	SUB #NFTVDS,C	;CONVERT TO PHYSICAL TV NUMBER FOR INDEX TO TABLES
	BLT CCPR12	;TOO LOW! FAIL
	BR CCPRD9
CCPRD8:	BIT #40000,E	;DOE SHE WANT A TV?
	BEQ CCPR12	;NOPE, LOSE
	SUB #NFTV,C	;GET THE PHYSICAL NUMBER OF THE KEYBOARD
	ASR C		;THIS WILL BE THE SAME AS THE NUMBER OF THE TV
CCPRD9:	MOVB TVDSBF(C),D;DOES THIS TV ALREADY HAVE A BUFFER?
	BGE CCPR11	;YES, IT MUST ALREADY HAVE A TV BUFFER
	MOV #NTVCHN,B	;THE NUMBER OF TV CHANNELS OR BUFFERS
	CLR D		;OFFSET INTO THE TVBUFF TABLE
CCPR10:	TSTB TVBUFF(D)	;IS THIS BUFFER FREE?
	BLT CCPR11	;YES (-1 MEANS FREE)
	INC D		;TRY THE NEXT BUFFER
	SOB B,CCPR10	;ANY MORE BUFFERS LEFT?
	BR CCPR12	;NO, NO BUFFERS AVAILABLE SO FAIL
CCPR11:	MOVB D,TVDSBF(C);ALLOCATE THIS BUFFER (D) TO THIS TV (C)
	MOVB C,TVBUFF(D);SAY THAT THIS BUFFER IS ALLOCATED
	INCB TVDSRF(C)	;ONE MORE PERSON IS REFERENCING THIS TV
	ASL C		;HO HUM
	MOV TVMAP(C),B	;GET THE CHANNEL NUMBER OF THIS TV
	ASR C
	SWAB B		;IT GOES IN THE HIGH BYTE
	BISB TVDSBF(C),B ;SET IN THE BUFFER NUMBER FOR THIS TV
	MOV B,VIDSW	;SWITCH THE TV TO BUFFER ON VIDEO SWITCH
	CLR B		;FOR NOW, THE ADDRESS OF A TV BUFFER IS IRRELEVENT
	JSR PC,GIVPSW	;RETURN A ZERO, JUST FOR COMPATABILITY
	MOV #100000,B	;A TV BUFFER HAPPENS TO BE 16K WORDS LONG
	JSR PC,GIVPSW	;MIGHT AS WELL GIVE IT TO HIM ANYWAY
	ADD #NFTVDS,C	;FIRST RANDOM WORD IN CAP IS LOGICAL DISPLAY NUMBER
	ASL C		;IT SHOULD BE A WORD INDEX INTO TABLES
	CLR B		;RETURN THE FACT THAT THERE IS NO ITEM FOR TV DISPLAY
	MOV #.DSCAP,A	;THIS WILL BE A DISPLAY CAPABILITY
	RTS PC		;NOTE THAT THE PREVIOUS INST. CAUSED Z CLEARED
CCPR12:	SEZ		;FAIL
	RTS PC
.ENDC
	.STITL PROCESS CAPABILITY ROUTINES
;INVOKE A PROCESS CAPABILITY, FUNCTION 0-7 IS USER'S REGISTERS
;10 IS USERS PS, 11-16 IS USERS FPP REGISTERS 17 IS FLOATING POINT STATUS
;40 BIT CLEAR MEANS READ (CURRENT VALUE PUSHED ON USERS STACK)
;40 BIT SET MEANS WRITE (2ND DATA WORD IS PLACED IN USERS REGISTER)
;A FUNCTION OF 20 ALLOWS READ/WRITE OF THE AVAILABILITY OF FPP
;IF READ, THE WORD RETURNED IS EITHER 1 (FLOATING POINT ENABLED) OR
;0 (NO FLOATING POINT).  IF WRITE, THE SECOND WORD ON THE STACK MUST BE 
;EITHER 1 OR 0.  A FUNCTION OF 21 ALLOWS WRITE AND READ OF THE SUPERIOR STOP BIT.
;IF WRITE, 0 MEANS START THE PROCESS, 1 MEANS STOP IT.  READ, NON ZERO MEANS STOPPED
;FUNCTIONS 23-25 MEAN READ AND WRITE THE FAULT WORDS 1-3
;FUNCTION 24 READS AND WRITES THE ERROR WORD
CAPRPR:	REST C		;GET THE FUNCTION BYTE
	ASH #-7,C	;TURN IT INTO A WORD INDEX
	BIC #177001,C	;CLEAR EXTRA BITS
	MOV C,D		;COPY IT
	ASR D		;SHIFT IT BACK DOWN
	BIC #.PRWRT*2,C	;CLEAR THE READ/WRITE BIT
	BIT #.PRWRT,D	;IS HE WRITING
	BEQ CPRPR1	;NOPE
	BIT #.PRWRA,(A)	;DOES HE HAVE WRITE ACCESS?
	BNE CPRPR1	;YES
CPRPR2:	ADD #4,P
	JMP BADEMT	;BARF
CPRPR1:	CMP C,#PRHGH	;IS IT TO HIGH
	BGE CPRPR2	;YES
	MOV 2(A),A	;ITEM OF THE PROCESS
	JSR PC,ITM2LD	;LOAD IT UP
	JMP @PRIVTB(C)	;DO THE FUNCTION

PRREG:	ADD C,A		;MAKE A POINT TO THE REG (WELL ALMOST)
	ADD #PUREGS,A	;POINT TO THE REGISTER IN DOUBT
PRRET:	BIT #.PRWRT,D	;READING?
	BNE REGWRT	;NOPE
	MOV (A),B	;GET THE APPROPRIATE REG INTO B
PRRET1:	JSR PC,GIVPSW	;GIVE IT TO HIM
	ADD #4,P	;GET RID OF TWO ARGUMENTS
	JMP ERETCZ	;WE WIN
REGWRT:	REST (A)	;SECOND ARG GOES INTO REGISTER	
PRRET0:	TST (P)+	;GET RID OF THIRD ARG
	JMP ERETCZ	;WE WIN
	;HERE IS PSW AND FLOATING REG READ

PRPSW:	ADD #PUPS,A	;POINT TO THE PSW
	MOVB 1(A),1(P)	;DONT LET HIM CHANGE MODE
	BIC #340,(P)	;OR PRIORITY
	BR PRRET	;RETURN IT OR WRITE IT

PRFREG:	MOV (P),E	;GET POINTER TO DATA
	MFPD (E)+	;MAKE SURE WE CAN GIVE IT TO HIM
	MFPD (E)+
	MFPD (E)+
	MFPD (E)+
	ADD #10,P	;POP OFF THE STUFF
	REST E		;POINTER TO DATA IS 2ND ARG
	SUB #2*.PRFREG,C	;MAKE THIS AN INDEX TO A FLOATING REG
	ASH #2,C	;EACH REGISTER IS 4 WORDS
	BIT #PFPFLG,PFLAGS(A)	;DOES HE HAVE THE FPP ENABLED?
	BEQ PRFLT3	;NOPE
	BIT #.PRWRT,D	;IS HE WRITING INTO THIS REG?
	BNE PRWRT	;YEP
	ADD C,A		;MAKE THE A POINT TO A FLOATING REG(ALMOST)
	ADD #PFPPRG+10,A	;MAKE IT ABSOLUTELY POINT TO THE APPROPRIATE REG
	SAVE <-(A),-(A),-(A),-(A)>	;SAVE THE FPP REGISTER
	MTPD (E)+	;GIVE HIM THE REGISTER IF YOU CAN
	MTPD (E)+
	MTPD (E)+
	MTPD (E)+
PRFLT2:	TST (P)+	;THIRD ARG NOT USED
	JMP ERETCZ
PRFLT4:	TST (P)+
PRFLT3:	REST A		;POP OFF 3RD ARG
	JMP ERETSZ
PRWRT:	MFPD (E)+	;GET THE REGISTER (IF WE CAN)
	MFPD (E)+
	MFPD (E)+
	MFPD (E)+
	ADD C,A		;MAKE THE A POINT TO A FLOATING REG(ALMOST)
	ADD #PFPPRG+10,A	;MAKE IT ABSOLUTELY POINT TO THE APPROPRIATE REG
	REST <-(A),-(A),-(A),-(A)>	;PUT THE REGISTER AWAY
	BR PRFLT2	;RETURN

PRFPST:	BIT #PFPFLG,PFLAGS(A)	;DOES IT USE THE FPP
	BEQ PRFLT4	;NO LUSER
	ADD #PFPPS,A	;POINT TO THE REGISTER
	BIT #.PRWRT,D	;IS IT A WRITE
	LBR ,PRRET	;TRANFER THE PROCESSOR STATUS

PRFPEN:	BIT #.PRWRT,D	;IS HE WRITING
	BNE FPPWRT	;YEP
	CLR B		;ASSUME THAT THERE ISNT ANY FPP
	BIT #PFPFLG,PFLAGS(A)	;DOES HE HAVE FPP
	BEQ .+4		;NOTHING HERE
	INC B		;SAY HE HAS FPP
	JMP PRRET1	;RETURN 1 ARG

FPPWRT:	MOV ITEM2,B	;WE WANT THE ITEM TO DO IT TO
	REST E		;GET THE FIRST ARG
	CMP E,#1	;IS IT A LEGAL ARG
	BHI PRLOSE	;ITS TOO BIG
	BEQ PWRT1	;ITS A REQUEST FOR FPP
	BIT #PFPFLG,PFLAGS(A)	;DOES HE ALREADY HAVE IT
	BEQ PWRT2	;NO, WHY BOTHER
	MOV ITEM2,B	;THE ITEM INDEX OF WHAT TO SHRINK
	MOV #PRSLNF,A	;TELL IT THE SIZE WE WANT
	JSR PC,EXITEM	;SHRINK THIS ITEM
	MOV ITEM2,A	;GET BACK THE ITEM
	JSR PC,ITM2LD	;LOAD IT BACK UP IN ITS NEW FORM
	BIC #PFPFLG,PFLAGS(A)	;SAY HE DOESN'T HAVE FPP
	JMP PRRET0	;RETURN SUCESSFUL
PWRT1:	BIT #PFPFLG,PFLAGS(A)	;DOES HE ALREADY HAVE IT
	BNE PWRT2	;YES
	MOV #PRSLFP,A	;THE LENGTH WE WANT IT TO BE
	JSR PC,EXITEM	;EXPAND THE PROCESS
	BEQ PRLOSE	;IT FAILED
	MOV ITEM2,A	;THE NEW ITEM
	JSR PC,ITM2LD	;LOAD IT UP
	BIS #PFPFLG,PFLAGS(A)	;SAY WE HAVE FPP
	MOV #40300,PFPPS(A)	;START WITH INT. DISABLED AND LONG AND DOUBLE
PWRT2:	JMP PRRET0	;RETURN NO ARG
PRLOSE:	TST (P)+	;POP OFF THIRD ARG
	JMP ERETSZ

PRSTOP:	ADD #PSTOP,A	;POINT TO THE STOP WORD
	BIT #.PRWRT,D	;IS IT A WRITE
	BNE PRSTP1	;YES
	MOV (A),B	;GET THE STOP WORD
	JMP PRRET1	;RETURN IT TO HIM
PRSTP1:	CMP (P),#1	;IS IT A ONE
	BHI PRLOSE	;FAIL
	BEQ PRSTP2	;STOP IT	
	BIT #PSUPSB,(A)	;IS HE STOPPED BY A CAPABILITY
	BEQ PRSTP3	;NO, JUST RETURN
	BIC #PSUPSB,(A)	;CLEAR THE BIT
	MOV ITEM2,A	;THE PROCESS
	JSR PC,ITM0PL	;LOAD IT UP
	JSR PC,PSTPDC	;DECREMENT THE STOP COUNT
	JSR PC,ITM0PO	;POP IT
PRSTP3:	TST (P)+	;POP OFF THE ARG
	JMP PRRET0	;DONE
PRSTP2:	BIT #PSUPSB,(A)	;HAS SOMEONE ELSE ALREADY STOPPED IT
	BNE PRSTP3	;SOMEONE BEAT US TO IT.
	BIS #PSUPSB,(A)	;SET THE STOP BIT
	MOV ITEM2,A	;THE PROCESS TO STOP
	JSR PC,PSTPIN	;STOP IT
	ADD #4,P	;POP ARGS
	JMP ERETCZ

PRFAUL:	SUB #.PRFAUL*2,C	;CREATE AN OFFSET
	ADD C,A		;POINT TO IT
	ADD #PFAULT,A	;GET THE FIRST FAULT WORD
	BIT #.PRWRT,D	;IS IT A WRITE REQUEST
	BNE PRFAUW	;WRITE REQUEST
	MOV (A),B	;GET THE FAULT WORD
	JMP PRRET1	;RETURN IT
PRFAUW:	TST (P)		;WRITING A ZERO?
	BEQ PFAUW1	;YES
PFAUW2:	JMP PRRET	;CAUSE THE WRITE
PFAUW1:	TST (A)		;IS IT FAULTED ALREADY
	BEQ PFAUW2	;NO
	MOV PSPHRP-PFAULT(A),B	;POINTER TO THE SPHERE
	JSR PC,FALTFX	;FIX THE FAULT
	JMP REGWRT

PRERR:	ADD #PERRW,A
	BR PFAUW2	;DO THE READ/WRITE

CAPRTR:	CAPRTP:	JMP EIVOK1

CPYXX:	BPT		;ZERO CAPABILITY
CPYCL:	MOV #.CLCONS,E	;CLEAR THE CONSUMER FLAG ON COPY
	MOV 2(F),A	;POINTER TO CORE LNK
	JSR PC,ITM2LD	;LOAD IT UP
	BR CPYFA1	;INCREMENT THE REFERENCE COUNT
CPYTR:
CPYTP:
CPYQU:	CLR E		;NO FLAGS TO CLEAR
	BR CPYFA1	;INCREMENT THE REFERENCE COUNT
;COPY PROCESS CAPABILITY, 2ND ARG SPECIFIES A MASK OF BITS TO
;BE CLEARED, NO BITS MAY BE SET.
CPYPR:	BIC #377,E	;MAKE SURE YOU ONLY TOUCH THE TOP BYTE
	BR CPYFA1	;CREATE THE SPERE CAP.

CPYFA:	BIS #<-.FARD-.FAWT-.FAAP-.FAAC>-177400,E
	CLRB E
	MOV FAMFI(F),A
	MOV A,B		;SUPERIOR ROUTINE WANTS THIS
	JSR PC,ITM2LD
	INC MFFREF(A)
CPYFA1:	JSR PC,SPRINC
	MOV (F),A	;THE FLAG WORD
	BIC E,A
	RTS PC

CPYCC:	CLR B
	MOV #.CCCAP,A	;SAY ITS A CREATE CAPABLITY
	RTS PC

;COPY TTY CAPABILITY, SAME AS COPY SPHERE
CPYTT:
;COPY SPHERE CAPABILITY, ARGS SAME AS PROCESS CALL
CPYSP:	MOV (F),A
	BR CPYMS1

;COPY A MASTER SPHERE CAPABILITY, BECOMES A SPHERE CAP. 2ND ARG
;SPECIFIES A MASK OF BITS TO BE CLEARED DURING THE COPY

CPYMS:	MOV #MSPCBT!.SPCAP,A
	TST 4(F)	;IS THIS THE FIRST COPY OF A MASTER SPHERE?
	BNE CPYMS1	;NOPE
	MOV D,10(F)	;MAKE THE MASTER SPHERE POINT TO ITSELF TEMPORARILY
	MOV ITEM1,4(F)	;SET IN THE ITEM NO.
CPYMS1:	MOV 2(F),B	;THE ITEM NO.
	JSR PC,SPRINC	;INCREMENT SPERE'S REFERENCE COUNTER
	BIC #377,E	;ONLY THE TOP BYTE IS SIGNIFICANT
	BIC E,A		;CLEAR THE CORRECT BITS
	MOV 2(P),E	;POINTER TO CAP DESTINATION
	MOV 2(F),B	;THE ITEM NO. OF SPHERE OF MS CAP
	MOV 4(F),4(E)	;POINTER TO NEXT SPHERE CAP
	MOV 10(F),10(E)	;REST OF POINTER TO NEXT CIRCULAR LIST ENTRY
	MOV ITEM1,4(F)	;THE FIRST SPHERE ON CIRCLE LIST IS THIS SPHERE
	MOV 4(P),10(F)	;THE CAP. NO IS IN B
	RTS PC

;COPY OF DISPLAY CAPABILITY IS NOT ALLOWED
CPYDS:	SEZ
	RTS PC
	.STITL GIVE CAPABILIY ROUTINES
GIVXX:	BPT
GIVSP:	SAVE <A,B,C,D>
		;A CONTAINS RELATIVE POINTER TO DEST. C-LIST ENTRY
		;B THE C-LIST NO. OF DEST
		;C THE SPHERE NO. OF DEST
	MOV E,B		;THE C-LIST NO. OF THE SOURCE C-LIST ENTRY
	MOV D,A	;THE POINTER TO THE SOURCE C-LIST ENTRY
	JSR PC,FNBKPT	;FIND THE PREVIOUS ENTRY IN CIRCULAR LIST
	MOV C,A		;THE PREVIOUS SPHERE
	MOV D,B		;THE PREVIOUS C-LIST NO
	JSR PC,ITM1PL	;LOAD IT UP
	JSR PC,GCLSTA	;FIND IT
	ADD A,B		;MAKE A POINT TO IT
	TST (B)		;IS IT HERE
	BUGC NE		;ITS THERE
	CMP (B),#-1
	BEQ .-6
	MOV 2(P),4(B)	;CORRECT SPHERE POINTER
	MOV 4(P),10(B)	;CORRECT C-LIST POINTER
	JSR PC,ITM1PO	;POP THE SPHERE
	REST <D,C,B,A>
		;FALL THROUGH AND TRANSFER THE CAPABILITY

		;MAY FALL THROUGH FROM GIVE SPHERE ROUTINE
GIVCC:			;CREATE CAP. GIV IS SAME AS PROCESS CAP. GIVE
GIVTP:
GIVTR:
GIVTT:
GIVQU:
GIVCL:
GIVFA:
GIVPR:
GIVDS:	JSR PC,GIVPSW	;GIVE HIM THE WORD, (CAN'T FAIL FROM HERE ON IN)
	SAVE A		;SAVE THE POINTER TO THE CAP TO GIVE
	MOV C,A		;THE DESTINATION SPHERE
	JSR PC,ITM2PL	;LOAD IT UP
	ADD (P)+,A	;MAKE A POINT TO THE C-LIST ENTRY
	MOV D,B		;POINTER TO THE CAPABILITY TO GIVE
	MOV (B)+,(A)+	;MOV THE CAPABILITY
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	JSR PC,ITM2PO	;POP THE ITEM
	CLR (D)		;GET RID OF IT
	ADD #4,P	;POP OFF THE TWO ARGS
	JMP ERETCZ
GIVMS:	SAVE <A,D>
	MOV C,A		;THE SPHERE THAT WE ARE GIVING TO
	JSR PC,ITM2PL	;A BOGUS PUSH
	MOV 2(D),D	;THE SPHERE THAT THE MS REFERS TO
	MOV SMSSPT(A),A	;JUST CHECK THIS ONE'S SUPERIOR
GIVMS1:	CMP A,D		;IS THE SUPERIOR SPHERE, THE ONE THE MS REFERS TO
	BEQ GIVMS2	;YES, WE MUST FAIL
	CMP A,SYSSPR	;IS IT THE SYSTEM SPHERE
	BEQ GIVMS3	;YES, THEN GIVING IT AWAY IS FINE
	JSR PC,ITM2LD	;LOAD UP THE SUPERIOR SPHERE
	MOV SMSSPT(A),A	;GET THIS ONES SUPERIOR SPHERE
	BR GIVMS1	;GO BACK AND CHECK IT OUT
GIVMS2:	ADD #10,P	;POP OFF THE ARGS AND PUSHED REG.
	JSR PC,ITM2PO	;POP THE PUSHED SPHERE
	JMP ERETSZ	;FAILED (MAYBE SHOULD BE A FAULT)
GIVMS3:	MOV D,A		;THE SPHERE THE MS REFERS TO
	JSR PC,ITM2LD	;LOAD IT UP
	MOV C,SMSSPT(A)	;FIX ITS MASTER SPHERE POINTER
			;(HERE FIX USER POINTER ALSO?)
	JSR PC,ITM2PO	;POP THE SPHERE
	REST <D,A>	
	BR GIVSP	;NOW GIVE IT AWAY LIKE A SPHERE
	.STITL DELETE CAPABILITY ROUTINES
DELXX:
DELCC:	CLR (A)		;CLEAR THE FIRST WORD
	CLZ
	RTS PC
DELPR:	CLR (A)	;FLUSH THE CAPABILITY
	MOV 2(A),A	;GET THE ITEM INDEX
	JSR PC,PSTPIN	;STOP HIM FROM RUNNING
	SAVE A
	JSR PC,DLPROC	;DEC PROCESSES REF COUNT
	BEQ DELPR1	;WE DELETED THE PROCESS
	REST A		;GET THE PROCESS ITEM NO.
	JSR PC,ITM0PL	;LOAD IT UP
	JSR PC,PSTPDC	;DECREMENT HIS STOP COUNT
	JSR PC,ITM0PO	;POP THE PROCESS
	CLZ
	RTS PC
DELPR1:	REST A		;GET BACK ITEM INDEX
	CLZ
	RTS PC

DELSP:	SAVE A
	MOV E,B		;THE CAP. NO. TO FLUSH
	JSR PC,FNBKPT	;FIND THE PREVIOUS ENTRY
	MOV (P),A	;GET THE ADDRESS BACK
	MOV 4(A),E	;THIS SPHERE'S POINTER
	MOV 10(A),F	;THE REST OF THE POINTER
	MOV C,A		;THE PREVIOUS ENTRY'S SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	JSR PC,GCLSTA	;GET APOINTER TO IT
	ADD A,B		;MAKE THE POINTER ABSOLUTE
	TST B		;DOES IT EXIST
	BUGC NE		;YES
	MOV E,4(B)	;SPLICE OUT ENTRY WE ARE DELETING
	MOV F,10(B)
	JSR PC,ITM1PO	;POP THE SPHERE
	REST A

DELTP:	SAVE A		;SAVE POINTER TO CAP
	MOV 2(A),A	;THE ITEM
DELTP3:	JSR PC,ITM2PL	;LOAD IT UP
	CMP #1,PTPREF(A)	;IS THIS THE LAST ONE?
	BNE DELTR1	;NO, JUST DELETE IT
	TST PTRNO(A)	;ANY CHARACTERS LEFT TO PUNCH?
	BEQ DELTP4	;NO
DELTP1:	MOV ITEM2,A	;COPY ITEM NO.
	JSR PC,ITM2PO	;POP IT
	JSR PC,LFLUSH	;WAIT A LONG TIME
	JSR PC,ITM2PL	;LOAD IT
	CMP #1,PTPREF(A)	;ANOTHER CAP?
	BNE DELTP2	;YES
	TST PTRNO(A)	;CHARACTERS LEFT?
	BNE DELTP1	;YES
DELTP2:	MOV ITEM2,A
	JSR PC,ITM2PO	;CLEAN UP A BIT
	JSR PC,RUNME
	BR DELTP3	;CHECK TO MAKE SURE
DELTP4:	CLR PTPITM
	BR DELTR1
DELTR:	SAVE A		;SAVE POINTER TO CAP
	MOV 2(A),A	;GET THE TR ITEM
	JSR PC,ITM2PL	;LOAD IT UP
	CMP #1,PTRREF(A)	;REF COUNT 1
	BNE .+6		;NO
	CLR PTRITM	;NO MORE PTR
DELTR1:	JSR PC,ITM2PO	;POP IT
	REST A		;GET BACK A AND DROP IN TO DELETE IT

;DELETE QUE CAPABILITY, JUST DEC REFERENCE COUNT, AND FLUSH CAP.
DELQU:	CLR (A)		;FLUSH THE CAPABLITY
	MOV 2(A),A	;THE ITEM INDEX OF THE SPRERE
	JSR PC,SPRDEC	;DECREMENT SPHERE REF COUNT
	CLZ
	RTS PC

;DELETE CORE LINK JUST FLUSH IT AND CHECK REFERENCE COUNT
DELCL:	BIT #.CLCONS,(A)	;AM I THE CONSUMER
	BEQ DELQU		;YES
	SAVE A
	MOV 2(A),A		;THE ITEM OR GIP
	JSR PC,ITM2PL
	CLR CLCONP(A)		;SAY THERE IS NO MORE CONSUMER
	JSR PC,ITM2PO
	REST A
	BR DELQU

;DELETE TTY CAP, WAIT FOR END OF TRANSMISSION IF LAST CAPABILITY,
;THEN FLUSH ITEM AND CAPABILITY
DELTT:	MOV A,F			;COPY THE TTY CAPABILITY POINTER
	MOV 2(A),A		;GET THE TTY ITEM NO.
	JSR PC,ITM2LD		;LOAD IT UP
DELTT1:	CMP TTYREF(A),#1	;AM I THE LAST
	BGT DELTT6		;NO
	SPL 7			;STOP TTY, AND CLOCK
	BIT #TOTRAN,TTYST1(A)	;IS HE TRANSMITTING
	BEQ DELTT4		;NO
DELTT2:	SPL 0			;RESTORE LOW PRIORITY
	JSR PC,LFLUSH		;LONG, LONG FLUSH
	CMP TTYREF(A),#1	;CHECK IF SOMEONE ELSE COPIED THIS ONE
	BGT DELTT3		;YES, DONE?
	SPL 7
	BIT #TOTRAN,TTYST1(A)	;TRANSMITTING
	BNE DELTT2		;YES
DELTT3:	SPL 0
	JSR PC,RUNME		;TRY ME AGAIN
	BR DELTT1		;JUST TO MAKE SURE
DELTT4:	SPL 7			;UNINTERRUPTABLE
	MOV TTLTTY(A),E		;THE LOGICAL TTY NO.
	CLR TTYITM(E)		;CLEAR THE ITEM NO.
.IFNZ NTVS
	BIT #TVF,TTYTBL(E)	;IS THIS A TV
	BEQ DELTT7		;NO
	TST TVBUF(A)		;THE BUFFER NUMBER OF THIS TV
	BLT DELTT7		;NO BUFFER ASSIGNED TO THIS TV
	MOV E,B			;THE LOGICAL TTY NUMBER
	SUB #NFTV,B		;GET THE PHYSICAL NUMBER OF THIS TV
	ASR B			;THIS IS A BYTE OFFSET
	JSR PC,DELTV		;DECREMENT THE REFERENCE COUNT FOR THIS TV
	CLR TVSTAT(E)		;TURN OFF BLINK AND INTERRUPT BITS
DELTT7:
.ENDC
	SPL 0			;CANT BE BOTHERER ANY MORE
	MOV ITEM2,A		;DELETE THE TTY ITEM
	JSR PC,DLITEM		;DELETE IT
DELTT5:	CLR (F)			;FLUSH THE CAPABILITY
	CLZ
	RTS PC
DELTT6:	DEC TTYREF(A)		;SAY ONE LESS CAPABILITY
	BR DELTT5		;FLUSH IT	

	
DELFA:	MOV A,D		;COPY POINTER TO CAP
	MOV FAUPT(D),B	;GET THE GIP REFERED TO BY THE FILE
	BEQ DELFA1	;THERE IS NONE
	JSR PC,UPTDL	;FLUSH IT
	CLR FAMFI(D)	;AND OUR POINTER TO IT
DELFA1:	MOV FAMFI(D),A	;GET POINTER TO THE MFI
	JSR PC,MFIDEL	;ONE LESS REFERENCE TO THE MFI
	CLR (D)		;FLUSH ACTUAL CAPABILITY
	CLZ
	RTS PC

;DELETE DISPLAY CAP
DELDS:	.IFZ NTKDIS+NTVS
	BPT		;CAN'T EXIST!
.IFF
	MOV CLSEM0(A),B	;GET THE TABLE INDEX
.ENDC
.IFNZ NTVS
	CMP B,#NFTVDS*2	;IS IT A TV DISPLAY?
	BGE DELDS1	;YES
.ENDC
.IFZ NTKDIS
	BPT		;THERE SHOULDN'T BE ANY TK DISPLAYS
.IFF	
	MOV TKDRUN(B),C
	MOV #-1,TKDRUN(B)	;RETURN THE DISPLAY
	JSR PC,TKDSTP	;STOP THE DISPLAY
	BIC #177770,C
	CLRB TKDOWN(C)
	CLR (A)		;FLUSH THE ACTUAL CAPABILITY
	CLZ
	RTS PC
.ENDC
.IFNZ NTVS
DELDS1:	ASR B		;CONVERT TO BYTE INDEX
	SUB #NFTVDS,B	;CONVERT TO PHYSICAL TV NUMBER
	JSR PC,DELTV	;IF REFCOUNT IS ZERO, THEN RELEASE THE BUFFER
	BEQ DELDS2	;IN CASE TVDEL LOSES FOR SOME REASON
	CLR (A)
	CLZ		;SUCCEED
	RTS PC
DELDS2:	SEZ		;FAIL
	RTS PC

;DELTV DECREMENTS THE REFERENCE COUNT OF A TV AND RELEASES THE BUFFER
;OF THAT TV WHEN THE REF COUNT REACHES ZERO. IT EXPECTS THE PHYSICAL
;TV NUMBER IN B
DELTV:	SAVE A
	TST B
	BLT DELTV2	;THERE ARE NO NEGATIVE TV'S
	CMP B,#NTVS	;IS THIS ONE A LEGAL TV
	BGE DELTV2	;NO
	DECB TVDSRF(B)	;DECREMENT THE REFERENCE COUNT
	BGT DELTV1	;IF NOT ZERO, THEN WE'RE DONE
	MOVB TVDSBF(B),A ;GET THE BUFFER NUMBER OF THE TV
	BLT DELTV2	;THIS SHOULD NOT BE NEGATIVE
	CMP A,#NTVCHN	;IS THIS WITHIN THE TABLE?
	BGE DELTV2	;NO, FAIL
	SAVE B
	ASL B		;CONVERT TO WORD INDEX
	MOV TVMAP(B),B	;GET THE RIGHT CONSOLE 
	BIS #17*400,B	;THE SOURCE IS THE BLANK CHANNEL
	MOV B,VIDSW	;CONNECT THIS CONSOLE TO THE BLANK CHANNEL
	REST B
	MOVB #-1,TVDSBF(B)	;SAY THAT THIS TV HAS NO BUFFER
	MOVB #-1,TVBUFF(A)	;SAY THAT THIS BUFFER HAS NO TV
DELTV1:	REST A
	CLZ
	RTS PC
DELTV2:	REST A
	SEZ
	RTS PC
.ENDC

DELMS:	SAVE A		;SAVE POINTER TO CAP FOR END OF ROUTINE
	CLR -(P)
	MOV A,F		;FOR SPCPDL
	JSR PC,SPCPDL
	MOV 2(F),A	;THE ITEM OF THIS SPHERE
	JSR PC,ITM1PL	;PUSH ONCE ONLY!
	MOV ITEM1,A
DELMS2:	JSR PC,ITM1LD	;LOAD IT UP
	SUB D,SPHREF(A)	;FLUSH THE REFERENCES WE FLUSHED
	CMP #1,SPHREF(A)	;WE SHOULD BE THE ONLY ONE LEFT
	BUGC EQ		;BUG IF NOT ZERO
	MOV #-1,E	;FLAG TO STOP ALL PROCESSES
	JSR PC,STPMS	;STOP!!!
DELMS9:	CLR D		;POINTER INTO C-LIST
	JSR PC,GNMSCP	;GET THE NEXT MSCAP
	BEQ DELMS1	;NONE, CAN FLUSH SPHERE AT THIS LEVEL NOW
	INC (P)		;ONE MORE SPHERE DOWN
	MOV 2(B),A	;POINTER TO THE ITEM
	MOV B,F		;FOR THE CALL TO SPCPDL
	MOV D,E		;THE CAP NUMBER
	JSR PC,SPCPDL	;DELETE THE CIRC LIST
	BR DELMS2	;GO LOAD IT UP AND LOOK FOR MSCAPS IN IT
DELMS1:	MOV #-1,A	;NEED TO PUSH THE ITEM TO USE IT
	JSR PC,ITM0PL
DELMS3:	MOV ITM1A,A	;ADDRESS OF SPHERE
	MOV SPHPRP(A),A	;GET POINTER TO FIRST PROCESS
	BEQ DELMS4	;NONE LEFT
	JSR PC,ITM0LD	;LOAD IT UP
	JSR PC,REMPRS	;REMOVE IT FROM THE SPHERE
	BR DELMS3	;GET THEM ALL!
DELMS4:	JSR PC,ITM0PO
	CLR D		;C-LIST ENTRY COUNTER
	MOV ITM1A,A
DELMS5:	JSR PC,GNCLST	;GET THE NEXT REAL ONE
	BEQ DELMS6		;NO MORE
	JSR F,ACSAV	;SAVE THE AC'S
	SAVE ITEM1	;SAVE THE ITEM NO
	ADD #CLSELN,B	;POINT PAST IT
	SAVE <-(B),-(B),-(B),-(B),-(B)>	;SAVE THE CAPABILITY
	MOV P,A		;POINT TO IT
	JSR PC,ITM1PO	;POP IT IN CASE WE GET STOPPED
	MOV (A),B	;FIRST WORD OF CAP
	ASL B		;TURN IT INTO A WORD INDEX
	BIC #177001,B	;CLEAR THE EXTRA BITS
	JSR PC,@DELTAB(B)	;DELETE THE CAPABILITY
	BUGC NE		;SUCCEEDED
	ADD #CLSELN,P	;POP OFF STUFF
	REST A		;THE ITEM NO.
	JSR PC,ITM1PL	;LOAD IT BACK UP
	JSR F,ACRES	;RESTORE THE AC'S
	CLR (B)		;MAKE IT NXM
	INC D
	BR DELMS5
;CONTINUES NEXT PAGE
DELMS6:	MOV ITEM1,C	;THE ITEM THE GIP WILL BE IN
	JSR F,ACSAV
	CLR B		;THE PAGE WE WANT
	JSR PC,ITM1PO
DELMS7:	SAVE <C,B>
	JSR PC,SUPTDL	;FLUSH THAT ONE
	REST <B,C>
	INC B		;NEXT ONE
	CMP #20,B	;GOT TO THE LAST ONE YET?
	BNE DELMS7	;NOPE
	JSR F,ACRES
	MOV C,A		;THE SPHERE WE HAVE NOW FLUSHED
	JSR PC,ITM1PL	;LOAD IT UP FOR A SEC
	MOV SMSSPT(A),F	;GET THE SUPERIOR SPHERE INDEX
	MOV SPRTPT(A),A	;POINTER TO THE PROCESS BLOCK FOR THE SPHER
	MOV #PFREEQ,B	;MOVE IT TO THE FREE QUQUE
	JSR PC,TQUEUE
	JSR PC,ITM1PO	;OK, NOW TO FLUSH THIS SPHERE!
	MOV C,A		;THE ITEM NUM
	JSR PC,DLITEM	;GONE!!!
	MOV F,A		;NOW LOAD THE SUPERIOR
	JSR PC,ITM1PL
	DEC (P)		;AT TOP LEVEL?
	BLT DELMS8	;YES, GO FINISH UP
	CLR D		;GET THE FIRST MSCAP IN THE SUPERIOR
	JSR PC,GNMSCP
	CLR (B)		;FLUSH CAP TO SPHERE WE JUST FLUSHED
	BR DELMS9	;GO FIND ANY OTHER MSCAPS
DELMS8:	JSR PC,ITM1PO
	REST <B,B>	;FLUSH COUNT, GET POINTER TO CAP
	CLR (B)		;FLUSHED!
	CLZ
	RTS PC
;THIS ROUTINE TAKES POINTER TO CAPABILITY IN F, THE MSCAP NO. IN E
;IT DELETES THE CIRCULAR LIST ASSOCIATED WITH IT.
SPCPDL:	SAVE A
	CLR D
	MOV ITEM1,A	;MAKE A BOGUS PUSH
	JSR PC,ITM2PL
	TST 4(F)	;IS THERE A CIRCULAR LIST
	BEQ SPCPDN	;NO
	MOV F,A		;RESTORE POINTER TO CAPABILITY
	BR SPCPD3	;A ALREADY POINT TO THE CAPABILITY AND DON'T WANT MSCAP TO GO AWAY
SPCPD4:	CMP ITEM2,ITEM1	;IS THIS THE SAME SPHERE AS WE STARTED WITH
	BEQ SPCPD2	;YES, DON'T BOTHER TO TEST THE C-LIST LOCK (WE ALREADY LOCKED IT)
	TST SCLSLK(A)	;IS THE C-LIST LOCKED?
	BLE SPCPD2	;NO, JUST DELETE IT
	MOV SCLSLK(A),A	;THE PROCESS THAT LOCKED IT
	JSR PC,PRSPCL	;STOP HIM, (I WANT THAT C-LIST BAD)
	JSR PC,ITM0PL	;LOAD IT UP FOR PSTPDC
	JSR PC,ITM0PO	;POP THE PROCESS
	MOV ITM2A,A	;GET THE ADDRESS BACK
	TST SCLSLK(A)	;IT HAD BETTER BE 0
	BUGC EQ		;IT IS
SPCPD2:	ADD B,A		;MAKE A POINT TO THE SPHERE CAPABILITY
	CLR (A)		;MAKE THIS CAPABILITY GO AWAY
	INC D		;KEEP COUNT OF FLUSHED CAPS
SPCPD3:	MOV 10(A),B	;THE C-LIST NO. OF NEXT CAP.	
	MOV 4(A),A	;GET THE SPHERE POINTER TO THE NEXT CAPABILITY
	BUGC NE		;GOT IT
	CMP A,ITEM1	;IS THIS THE SAME SPHERE
	BNE SPCPD1	;NO
	CMP B,E		;SAME AS THE MSCAP?
	BEQ SPCPDN	;YES, WE ARE DONE
SPCPD1:	CMP A,ITEM1	;IS THIS THE CURRENT SPHERE
	BEQ SPCPD5	;YES, DON'T STOP IT
	MOV A,C		;SAVE FOR SPRSTP
	JSR PC,SPRSTP	;STOP THE SPHERE
	JSR PC,SPRSTR	;START IT
	MOV C,A		;RESTORE THE SPHERE NO.
SPCPD5:	JSR PC,ITM2LD	;LOAD THE NEXT SPHERE
	MOV ITM2A,A	;GET THE ADDRESS
	JSR PC,GCLSTA	;GET POINTER TO NEXT CAP
	BNE SPCPD4	;GO BACK AND TRY AGAIN
	BPT		;ERF, SOMETHING IS SCREWED
SPCPDN:	JSR PC,ITM2PO	;POP THE ITEM PUSHED
	CLR 4(F)	;MAKE SURE THERE IS NO CIRCULAR LIST
	CLR 10(F)	;DITTO
	REST A
	RTS PC
	.STITL TAKE CAPABILITY ROUTINES
TAKXX:	BPT	;THE ZERO CAPABILITY
TAKSP:	SAVE <A,B,C,D>
	MOV C,A		;THE SPHERE OF THE TAKEE
	SAVE ITEM1	;CURRENT SPHERE NO.
	JSR PC,ITM1PL	;LOAD IT UP
	ADD D,A		;MAKE A POINT TO THE CAP
	MOV E,B		;B IS THE C-LIST NO.
	JSR PC,FNBKPT	;GET BACK POINTER
	MOV C,A		;THE PREVIOUS SPHERE
	MOV D,B		;THE PREVIOUS C-LIST NO.
	JSR PC,ITM1LD	;LOAD IT UP
	JSR PC,GCLSTA	;GET THE CAPABILITY
	ADD A,B		;MAKE A POINT TO THE CAP.
	TST (B)		;IS IT THERE
	BUGC NE		;YEP
	REST 4(B)	;THE CURRENT SPHERE IS WHERE THIS SHOULD POINT
	MOV 4(P),10(B)	;SET THE C-LIST NO. ALSO
	JSR PC,ITM1PO	;POP THE ITEM STACK
	REST <D,C,B,A>
TAKFA:
TAKTP:
TAKTR:
TAKTT:
TAKPR:
TAKCL:
TAKQU:
TAKDS:
TAKCC:	JSR PC,GIVPSW	;GIVE THE USER THE C-LIST NO. OF DEST
	SAVE A		;SAVE POINTER TO WHERE THE CAP. IS GOING
	MOV C,A		;THE SPHERE TO TAKE FROM
	JSR PC,ITM2PL	;LOAD IT UP
	ADD D,A		;MAKE THE POINTER ABSOLUTE
	REST B		;POINTER TO DESTINATION
	SAVE A
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	CLR @(P)+	;FLUSH THE CAPABILITY
	JSR PC,ITM2PO
	ADD #4,P	;POP THE TWO ARGS
	JMP ERETCZ
;THIS ROUTINE MAKES SURE THAT THE SPHERE STRUCTURE ALWAYS POINTS DOWN
TAKMS:	SAVE <A,B,C>
	SAVE ITEM1	;THE SPHERE OF TAKER
	MOV C,A		;THE SPHERE OF TAKEE
	JSR PC, ITM1PL	;LOAD IT UP
	ADD D,A		;MAKE A POINT TO THE CAPABILITY TO BE TAKEN
	MOV 2(A),C	;THE SPHERE THAT THE MASTER SPHERE CAP. REFFERS TO
	REST A		;GET THE TAKER'S SPHERE NO.
	CMP C,A		;IS TAKING HIS OWN MASTER SPHERE CAPATILITY
	BEQ TAKMS1	;YES, DONT LET HIM
	CMP C,SYSSPR	;IS HE TAKING THE SYSTEM SPHERE'S MASTER CAP. TO ITSELF
	BEQ TAKMS1	;YES DONT ALLOW HIM TO
TAKMS2:	JSR PC,ITM1LD	;LOAD UP THE SPHERE
	MOV SMSSPT(A),A	;GET THIS SPHERES MASTER SPHERES NO
	CMP A,SYSSPR	;ARE WE AT THE ROOT OF THE SPHERE TREE
	BEQ TAKMS3	;YES
	CMP C,A		;IS IT A SUPERIOR OF THE TAKER
	BNE TAKMS2	;NOPE, GET THE NEXT SUPERIOR
TAKMS1:	JSR PC,ITM1PO
	ADD #12,P	;GET RID OF ALL THE GARBAGE
	JMP ERETSZ	;TELL HIM HE CAN'T TAKE THIS ONE
TAKMS3:	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,SPRSTP	;STOP THE SPHERE THAT THE MS CAP. REFERS TO
	MOV C,B		;THE SPHERE THAT WE STOPPED
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START THE SPHERE WHEN IT IS NULOCKED
	MOV ITEM0,B	;SAY WE LOCKED THE C-LIST
	MOV #SCLSLK,A	;LOCK ITS C-LIST
	JSR PC,LCKASW	;LOCK IT IF YOU CAN
	MOV C,A		;THE SPHERE NO.
	JSR PC,ITM2PL	;LOAD IT
	MOV ITEM1,SMSSPT(A)	;UPDATE THE SUPERIOR SPHERE POINTER
	JSR PC,ITM2PO	;POP THE SPHERE
	REST <C,B,A>
	JMP TAKSP	;UPDATE THE CIRCULAR PINTERS AND TAKE THE CAPABILITY
;INCREMENT SPHERE OR PROCESS REFERENCE COUNT, ITEM NO. IN C
;THIS DEPENDS ON THE SPHERE AND PROCESS REFERENCE COUNT BEING IN THE SAME PLACE
.IIF NZ SPHREF-PRSREF,.ERROR BARF IT WONT WORK
SPRINC:	SAVE A		;DON'T CLOBBER A
	MOV B,A		;GET THE ITEM NO.
	JSR PC,ITM1PL	;LOAD THE SPERE
	INC SPHREF(A)	;INC REFERENCE COUNT
	JSR PC,ITM1PO	;RELOAD ORIGINAL ITEM1
	REST A		;RESTORE IT
	RTS PC
;DECREMENT REFERENCE COUNT OF CORE LINK OR PROCESS
;ITEM NUMBER IN A
SPRDEC:	JSR PC,ITM1PL	;LOAD THE SPHERE
	DEC SPHREF(A)	;DECREMENT THE REFERENCE COUNT
	BEQ SPRDC1	;NO ONE REFERS TO IT ANY MORE
	JSR PC,ITM1PO	;POP THE ITEM STACK
	RTS PC
SPRDC1:	MOV ITEM1,A	;SAVE THE ITEM NO.
	JSR PC,ITM1PO	;IN CASE WE GET STOPPED
	BIT #GIPBIT,A	;IS IT A GIP
	BNE SPRDC2	;YES, MUST BE A FUPT
	JSR PC,DLITEM	;DELETE THE ITEM
	RTS PC
SPRDC2:	SAVE B
	MOV A,B		;COPY THE FUPT
	JSR PC,UPTDL	;DELETE IT
	REST B		;GET B BACK
	RTS PC		;RETURN
	.STITL I-O ROUTINES
EWRDI:	MOV #WDITAB,F
	BR IOTYPE
EWRDO:	MOV #WDOTAB,F
	BR IOTYPE
EBYTI:	MOV #BTITAB,F
	BR IOTYPE
EBYTO:	MOV #BTOTAB,F
	BR IOTYPE
EBLKI:	MOV #BKITAB,F
	BR IOTYPE
EBLKO:	MOV #BKOTAB,F

IOTYPE:	JSR PC,RETNSW	;GET THE CAP NO. OF THE IO DEVICE
	MOV A,B		;CAP NO.IF  IT IS NEGATIVE, WAIT FOR COMPLETION
	MOV A,E		;CONTAINS FLAGS IN HIGH BYTE
	BIC #177600,B	;CLEAR THE FLAG BITS
	MOV ITM1A,A	;START OF SPHERE
	JSR PC,GCLSTA	;GET THE CAPABILITY
	BEQ IOTYP1	;FAILED
	ADD B,A		;MAKE A POINT TO THE CAP.
	MOV A,D		;SAVE POINTER FOR IO ROUTINES
	MOV (A),B	;TYPE AND FLAGS OF CAP.
	BEQ IOTYP1	;NOTHING THERE
	CMPB #.TTCAP,B	;IS IT A TELTYPE CAPABILITY
	BEQ TTYIO
	CMPB #.FACAP,B	;IS IT A FILE ACCESS CAPABILITY
	BEQ DSKIO	;YES
	CMPB #.CLCAP,B	;IS IT A CORE LINK
	BEQ CLIO	;YES
	CMPB #.TPCAP,B	;IS IT A PAPER TAPE PUNCH CAP
	BEQ PTPIO	;YES
	CMPB #.TRCAP,B	;IS IT PAPER TAPE READER
	BEQ PTRIO	;YES
;THESE ARE FOR MEANINGLESS OPERATIONS (OUTPUT TO THE TAPE READER)
TRBKO:	TRWDO:	TRBTO:	
TPBKI:	TPWDI:	TPBTI:
IOTYP1:	JMP ERETSZ	;TELL HIM HE FAILED
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
PTRIO:	JMP @TRIDX*2(F)		;NOTHING TO DO
PTPIO:	JMP @TPIDX*2(F)		;DITTO
DSKIO:	MOV D,A			;POINTER TO THE CAPABILITY
	SUB ITM1A,A		;MAKE IT RELATIVE TO THE START OF THE ITEM
	MOV #.FALB,B		;THE BIT TO LOCK
	MOV ITEM1,C		;LOCK IT IN THE CURENT SPHERE
	JSR PC,LCKASW		;LOCK THE SWITCH
	JSR PC,RETPSW
	MOV A,B			;SAVE FOR DINNER
	BIC #-1-.FAAP,A		;APPEND OR WRITE
	BNE .+6
	BIS #.FAWT,A
	JMP @DKIDX*2(F)		;THE DISK ROUTINES ARE FIRST IN TABLE
TTYIO:	MOV 2(D),A		;THE TTY ITEM NO.
	JSR PC,ITM2LD
	CMP ITEM1,TTITM(A)	;DO I CURRENTLY OWN IT
	BNE TTYIO1		;NOPE
	JMP @TTIDX*2(F)	;THE TTY ROUTINES ARE SECOND IN TABLE
TTYIO1:	JSR PC,LFLUSH	;FLUSH YOURSELF
	CMP ITEM1,TTITM(A)	;DO I OWN IT NOW
	BNE TTYIO1	;NO, GO FLUSH YOURSEF AGAIN
	JSR PC,RUNME	;I THINK I HAVE GOT THE TTY
	BR TTYIO	;GO TRY AGAIN
CLIO:	MOV 2(D),A	;THE CORE LINK POINTER
	BIT #GIPBIT,A	;IS IT A GIP (MEANS IT IS AN FUPT)
	BEQ CLIO1	;NO, JUST GO AHEAD
	SAVE <B,F>
	MOV A,B		;POINTER TO FUPT
	JSR PC,FUPTLK
	JSR PC,SWPIN	;SWAP IT IN
	REST <F,B>	;NOW WE WILL GET PC-LOSERED IF IT GOES OUT AGAIN
CLIO1:	JMP @CLIDX*2(F)	;THE CORE LINK ROUTINES ARE THIRD IN THE TABLES
	.STITL CORE LINK ROUTINES
CLGTBY:	TST CLCNT(A)	;ARE THERE ANY BYTES
	BEQ CLGTB1	;NO, RETURN SEZ
	MOV CLDATO(A),D	;POINTER TO THE DATA OUT
	ADD A,D		;MAKE THE POINTER ABSOLUTE
	MOVB (D),D	;GET THE BYTE
	DEC CLCNT(A)	;DECREMENT THE BYTE COUNT
	INC CLDATO(A)	;INCREMENT THE POINTER
	SAVE B		;GET A REGISTER
	MOV CLNUM(A),B	;THE NUMBER OF ENTRIES IN BUFFER
	ADD #CLDATL,B	;GET THE TOTAL MAXIMUM OFFSET
	CMP CLDATO(A),B	;ARE WE AT THE END OF THE BUFFER
	BLT .+10
	MOV #CLDATL,CLDATO(A)	;RESET THE DATA OUT POINTER
	REST B
CLGTB1:	RTS PC

CLCHAR:	MOV CLCNT(A),B	;GET THE NUMBER OF CHARACTERS LEFT
	RTS PC

CLDPBY:	CMP CLCNT(A),CLNUM(A)	;ANY SPACE LEFT
	BEQ CLGTB1	;NO
	SAVE B
	MOV CLDATI(A),B	;THE DATA IN POINTER
	ADD A,B		;MAKE THE POINTER ABSOLUE
	MOVB D,(B)	;PUT IN THE BYTE
	INC CLCNT(A)	;SAY ANOTHER CHARACTER
	INC CLDATI(A)	;INCREMENT POINTER TO NEXT
	MOV CLNUM(A),B	;GET THE NUMVER OF SLOTS
	ADD #CLDATL,B	;GET THE TOTAL OFFSET
	CMP CLDATI(A),B	;ARE WE AT THE END
	BLT .+10
	MOV #CLDATL,CLDATI(A)	;RESET THE POINTER
	REST B
	RTS PC
CLO:	JSR PC,CLDPBY	;DEPOSITE THE BYTE
	BEQ CLO1	;FAILED
	RTS PC
CLO1:	MOV ITEM2,A	;THE CL
	JSR PC,ITM2PO	;POP THE CL
	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD IT UP
	CMP CLCNT(A),CLNUM(A)	;IS IT STILL FULL
	BEQ CLO1	;YES
	MOV ITEM2,A
	JSR PC,ITM2PO
	JSR PC,RUNME	
	JSR PC,ITM2PL
	BR CLO

STIOQ:	JSR PC,TIOQ	;GET A CHARACTER
	BIT #TILIPM,TTYST1(A)	;AM I IN LOGO INPUT MODE
	BEQ STIOQ1	;NO
	CLR E		;CLEAR THE WAIT FLAG
STIOQ1:	RTS PC
	.STITL TTY AND CORE LINK INPUT ROUTINES
;THIS ROUTINE TAKES A CHARACTER FROM THE TTY POINTED TO BY THE CAPABILITY POINTED TO BY D
;AND PUTS IT ON THE TOP OF THE USERS STACK
TRBTI:	SAVE <#TRGTBY,#TRCHAR>
	BR TTBTI1	;LOAD IT UP
CLBTI:	SAVE <#CLGTBY,#CLCHAR>	;GET A BYTE
	BIT #.CLCONS,B	;AM I THE CONSUMER
	BEQ TTBTI4	;NO, ERROR
	BR TTBTI1
TTBTI:	SAVE <#STIOQ,#CHARCK>
	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TTBTI4	;NOPE
TTBTI1:	MOV 2(D),A	;GET THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,@(P)	;GET THE NUMBER OF CHARACTERS INTO B
	TST B		;EOF?
	BMI TTBTI6
	CMP B,#1	;CAN WE GET ONE
	BLT TTBTI3	;NOPE
	JSR PC,@2(P)	;GET IT
	MOV D,B		;THE CHAR
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,GIVPSW	;GIVE IT TO THE USER
	ADD #4,P
	JMP ERETCZ
TTBTI3:	MOV (P),C	;GET THE ADDRESS OF THE CHARACTER RETURNING ROUTINE
TTBTI5:	MOV ITEM2,A	;SAVE THE ITEM NO.
	JSR PC,ITM2PO	;POP THE ITEM
	TST E		;SHOULD WE WAIT
	BMI TTBTI4	;NOPE
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	JSR PC,ITM2PL	;LOAD THE TTY OR CL
	JSR PC,(C)	;IS THERE A CHARACTER
	CMP B,#1	;ANY CHARACTERS
	BLT TTBTI5	;NO
	JSR PC,ITM2PO
	JSR PC,RUNME	;I CAN GET ONE NOW
	BR TTBTI1	;GO GET IN
TTBTI4:	ADD #4,P
	JMP ERETSZ
TTBTI6:	JSR PC,ITM2PO	;POP THE ITEM
	ADD #4,P
	JMP ERETSC
;THIS ROUTINE  IS THE SAME AS THE TTBTI, EXCEPT IT RETURNS TWO CHARACTERS
;THE FIRST IN THE LOW ORDER BYTE, AND THE NEXT IN THE TOP ORDER BYTE
TRWDI:	SAVE <#TRGTBY,#TRCHAR>
	BR TTWDI1
CLWDI:	SAVE <#CLGTBY,#CLCHAR>	;GET A BYTE
	BIT #.CLCONS,B	;IS HE A CONSUMER
	BEQ TTWDI3	;NO
	BR TTWDI1
TTWDI:	SAVE <#STIOQ,#CHARCK>
	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TTWDI3	;NOPE
TTWDI1:	MOV 2(D),A	;THE TTY ITEM NO.
TTWDI7:	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,@(P)	;CHECK TO SEE IF THERE ARE ENOUGH
	TST B		;EOF?
	BMI TTBTI6	;YES
	CMP B,#2	;2 BYTES LEFT
	BLT TTWDI2	;NOPE
	JSR PC,@2(P)	;GET A BYTE
	MOV D,B		;SAVE IT
	BIC #177400,B	;CLEAR THE HIGH BYTE
	JSR PC,@2(P)	;GET ANOTHER BYTE
	SWAB D		;PUT IT INTO THE TOP BYTE
	BIC #377,D	;CLEAR THE LOWER BYTE
	BIS D,B		;PUT THEM BOTH IN THE SAME WORD
	JSR PC,ITM2PO
	JSR PC,GIVPSW	;GIVE THE WORD TO THE USER
	ADD #4,P
	JMP ERETCZ	;RETURN SUCCESSFUL

	CMP B,#1
	BEQ TTWDI4	;THERE IS A CHARACTER
	JSR PC,ITM2PO
TTWDI3:	ADD #4,P
	JMP ERETSZ
TTWDI4:	JSR PC,@2(P)
	MOV D,B		;THE CHARACTER
	JSR PC,ITM2PO	;POP THE TTY	
	JSR PC,GIVPSW	;GIVE THE CHAR TO THE USERR
	ADD #4,P
ERETSC:	MOV ITM0A,A	;GET THE PROCESS ADDRESS
	CLR PUPDLO(A)	;NOTHING GETS POPPED
	SEZ!SEC
	JMP EMTRET
TTWDI2:
TTWDI5:	MOV ITEM2,D	;SAVE THE ITEM NO.
	MOV (P),C	;THE ADDRESS OF THE ROUTINE THAT RETURNS NUMBER OF BYTES
TTWDI6:	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	MOV D,A		;GET BACK THE CL-TTY
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,(C)	;GET NUMBER OF CHARACTERS
	CMP B,#2	;ENOUGH CHARACTERS YET
	BLT TTWDI6	;NOPE
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;I THINK I HAVE GOT THEM
	BR TTWDI7
;THIS ROUTINE TAKES A BLOCK OF CHARACTER FROM THE TTY, THE FIRST THING ON
;THE STACK IS THE NEGATIVE OF THE BYTE COUNT, THE SECOND IS A POINTER TO WHERE THE DATA
;GOES IN THE USERS D-SPACE
TRBKI:	SAVE <#TRGTBY,#TRCHAR>
	BR BKICOM
CLBKI:	SAVE <#CLGTBY,#CLCHAR>	;GET A BYTE
	BIT #.CLCONS,B	;AM I THE CONSUMER
	BEQ TBKISZ	;NO LOSER
	BR BKICOM
TTBKI:	SAVE <#STIOQ,#CHARCK>
	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TBKISZ	;NO
BKICOM:	JSR PC,RETNSW	;GET THE COUNT
	MOV A,C		;SAVE IT
	BEQ TBKICZ	;ITS 0, WE WIN
	BPL TBKISZ	;ITS POSITIVE, WE WANT A NEGATIVE COUNT
	JSR PC,RETNSW	;GET THE POINTER
	MOV A,F		;SAVE IT
	ASR A		;SEE IF IT IS AT AN ODD ADRESS
	BCC TBKI2	;IT IS OK
	MOV 2(D),A	;THE ITEM NO.
TBKI1:	DEC F		;MAKE B POINT TO THE PREVIOUS WORD
	MFPD (F)	;GET THE PREVIOUS WORD
	SAVE (P)
	MTPD (F)	;MAKE SURE WE CAN WRITE IT
	JSR PC,ITM2PL	;LOAD THE TTY ITEM
	BR TBKI4
TBKI2:	MOV 2(D),A	;THE TTY ITEM NO.
TBKI3:	MFPD (F)	;MAKE SURE WE CAN WRITE THIS WORD
	SAVE (P)	;SAVE IT
	MTPD (F)	;MAKE VBERY SURE WE CAN WRITE IT
TBKI11:	JSR PC,ITM2PL	;LOAD THE TTY
	JSR PC,@2(P)	;CAN I GET A CHAR
	CMP B,#1	;IS THERE ONE
	BLT TBKI5	;FAILED
	JSR PC,@4(P)	;GET THE CHARACTER	
	MOVB D,(P)	;SAVE THE FIRST CHAR
	INC C		;INCREMENT THE COUNT
	BEQ TBKIRT	;DONE IF ZERO

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

TBKI4:	JSR PC,@2(P)	;ARE THERE CHAR.
	CMP B,#1
	BLT TBKI9	;NOPE
	JSR PC,@4(P)	;GET THE CHARACTER
	MOVB D,1(P)	;PUT IT IN THE TOP BYTE
	MOV ITEM2,A	;SAVE IT FOR NEXT TIME
	JSR PC,ITM2PO	;POP THE TTY ITEM
	MTPD (F)+	;RETURN THE CHARACTERS
	INC C		;INC THE COUNT
	BEQ TBKICZ	;IF ZERO WE ARE DONE
	SAVE <A,B,C,F>
	MOV ITM0A,A	;GET THE ADDRESS OF ITEM
	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;CORRECT IT
	MTPD -(B)	;PUT BACK THE POINTER
	MTPD -(B)	;PUT BACK THE COUNT
	REST <B,A>
	BR TBKI3	;GO BACK FOR MORE
TBKI5:	JSR PC,ITM2PO
TBKI6:	ADD #4,P
	JMP ERETSC	;SET THE CARRY AND RETURN
TBKI7:	SAVE C
	MOV 4(P),C	;THE CHARACTER CHECKING ROUTINE
TBKI8:	MOV ITEM2,A	;SAVE THE ITEM NO.
	JSR PC,ITM2PO	;POP IT
	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD THE TTY
	JSR PC,(C)	;ANY CHARACTERS
	CMP B,#1
	BLT TBKI8	;NOPE
	MOV ITEM2,A	;SAVE IT FOR LATER
	JSR PC,ITM2PO	;POP THTE TTY
	JSR PC,RUNME	;I THINK I HAVE GOT IT
	REST C		;GET BACK RANDOM REG
	BR TBKI11	;GO GET THE CHAR

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

TBKIRT:	JSR PC,ITM2PO	;POP THE TTY
	MTPD (F)	;GIVE IT BACK, WITH ONE BYTE CHANGED
TBKICZ:	ADD #4,P	;POP OFF GARBAGE
	JMP ERETCZ	;RETURN SUCCESSFUL
TBKISZ:	ADD #4,P
	JMP ERETSZ
TBKI9:	MOV ITEM2,A	;SAVE IT
	JSR PC,ITM2PO	;POP THE TTY
	MTPD (F)	;GIV IT BACK WITH BYTE MODIFIED
	INC F		;CORRECT BYTE POINTER
	MOV F,B		;GIVE HIM THE POINTER
	JSR PC,GIVPSW
	MOV C,B		;THE COUNT
	JSR PC,GIVPSW	;GIVE IT TO HIM
	TST B		;EOF ERROR?
	BMI TBKI6	;YES
	SAVE C
	MOV ITM0A,C	;POINT TO THE PROCESS
	ADD #4,PUPDLO(C)	;CORRECT THE OFFSET
	MOV 2(P),C	;THE CHARACTER CHECKING ROUTINE
	BR TBKI12
TBKI10:	MOV ITEM2,A
	JSR PC,ITM2PO
TBKI12:	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD THE TTYY
	JSR PC,(C)	;ARE THERE CHARACTERS
	CMP B,#1
	BLT TBKI10	;NOPE
	MOV ITEM2,A	;SAVE FOR LATER
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;RUN ME, RUN ME
	REST C
	JMP TBKI1	;FIX THE POINTER AND GET THE CHAR
	.STITL CORE LINK AND TTY OUTPUT ROUTINES
;THIS ROUTINE TAKES A BYTE OFF THE TOP OF THE USERS STACK AND OUTPUTS IT TO THE TTY
TPBTO:	SAVE <#TPO>
	BR TTBTO2
CLBTO:	SAVE <#CLO>
	BR TTBTO2
TTBTO:	SAVE <#TYO>
	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE TTBTO2	;YES
TTBTO1:	TST (P)+
	JMP ERETSZ
TTBTO2:	JSR PC,RETNSW	;GET THE CHARACTER TO TRANSMIT
	MOV A,F		;SAVE IT
	MOV 2(D),A	;THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT UP
	MOV F,D		;THE CHAR
	JSR PC,@(P)	;SEND THE CHARACTER
TTBTO3:	JSR PC,ITM2PO
	TST (P)+	;POP OFF THE ARGUMENT
	JMP ERETCZ	;SUCESS
;THIS ROUTINE TAKES A WORD OFF THE USERS STACK AND OUTPUTS IT TO THE TTY
TPWDO:	SAVE #TPO
	BR TTWDO2
CLWDO:	SAVE #CLO
	BR TTWDO2
TTWDO:	SAVE #TYO
	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE TTWDO2		;NOPE
TTWDO1:	ADD #2,P
	JMP ERETSZ
TTWDO2:	JSR PC,RETNSW	;GET THE CHARACTERS TO OUTPUT
	MOV A,F		;SAVE THEM
TTWDO3:	MOV 2(D),A	;THE TTY ITEM NO
TTWDO4:	JSR PC,ITM2LD	;LOAD IT
	BIT #.TTWD,E ;HAVE WE SENT THE FIRST BYTE YET?
	BNE TTWDO5	;YES
	MOVB F,D	;COPY THE BYTE
	JSR PC,@(P)	;SEND IT
	BIS #.TTWD,E ;FIRST BYTE WRITTEN BIT
	MOV F,B		;PUT BACK THE OUTPUT WORD
	JSR PC,GIVPSW	;GIVE BACK TO USER
	MOV E,B		;PUT FLAGS AND CAP NUMBER BACK THE WAY THEY WERE
	JSR PC,GIVPSW	;GIVE BACK TO USER
	JSR PC,RETNSW	;THIS IS THE WAY WE WERE CALLED
	BR TTWDO2	;NOW SEND THE SECOND CHAR	
TTWDO5:	SWAB F		;GET THE NEXT CHAR
	MOVB F,D	;THE OTHER CHAR
	JSR PC,@(P)	;SEND IT ALSO
	ADD #2,P	;POP THE ADDRESS
	JMP ERETCZ	;SUCCESS


;CL AND TTY BLOCK OUTPUT
TPBKO:	SAVE #TPO
CLBKO:	SAVE #CLO
	BR TBKO1
TTBKO:	SAVE #TYO
	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE TBKO1
TBKOSZ:	ADD #4,P
	JMP ERETSZ
TBKO1:	MOV 2(D),A	;THE TTY ITEM
	JSR PC,ITM2LD	;LOAD IT UP
	JSR PC,RETNSW	;GET THE COUNT
	MOV A,C		;SAVE IT
	BEQ TBKOCZ	;NONE TO TRANSFER
	BPL TBKOSZ	;POSITIVE COUNT?
	JSR PC,RETNSW	;GET THE POINTER
	MOV A,F		;SAVE IT
	MOV ITM2A,A	;GET THE ADDRESS OF THE TTY ITEM
	BIT #1,F	;DOES POINTER POINT TO A BYTE?
	BEQ TBKO2	;NO, IT POINTS TO A WORD
	DEC F		;MAKE IT POINT TO THE PREVIOUS WORD
	MFPD (F)	;GET THE WORD
	INC F		;GET BACK TO THE CORRECT POINTER
	BR TBKO4	;PRETEND YOU HAVE ALREADY SENT A CHARACTER
TBKO2:
TBKO3:	MFPD (F)	;GET THE TWO CHARACTERS
	MOVB (P),D	;THE FIRST CHARACTER
	JSR PC,@2(P)
	INC F
	INC C		;INCREMENT THE COUNT
	BEQ TBKORT	;DONE
	JSR PC,TBKRSP	;RESET THE POINTERS IN USER SPACE

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

TBKO4:	MOVB 1(P),D	;THE SECOND CHAR
	JSR PC,@2(P)	;PUT THE CHAR IN THE BUFFER
	INC F		;THE POINTER
	INC C		;INC THE COUNT
	BEQ TBKORT	;DONE
	JSR PC,TBKRSP	;RESET THE POINTERS IN USER SPACE
	TST (P)+	;POP OFF THE CHARACTERS
	BR TBKO3	;DO IT AGAIN
TBKORT:	TST (P)+	;POP OFF THE CHARACTERS
TBKOCZ:	ADD #2,P	;POP OFF THE ROUTINE ADDRESSES
	JMP ERETCZ

;THIS SUBROUTINE RESETS THE POINTERS SO THAT IS WE GET PC-LUSERED, WE'RE OK
TBKRSP:	SAVE <A,B,C,F>
	MOV ITM0A,A	;GET THE ADDRESS OF ITEM
	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;CORRECT IT
	MTPD -(B)	;PUT BACK THE POINTER
	MTPD -(B)	;PUT BACK THE COUNT
	REST <B,A>
	RTS PC

ACSAV:	SAVE <E,D,C,B,A>
	JMP (F)

ACRES:	TST (P)+
	REST <A,B,C,D,E>
	RTS F

;ROUTINES TO LOAD ITEMS INTO THE MAP AND TO PUSH AND POP THE ITEM STACKS

.IRPC X,<012>	;CONSTRUCT ROUTINES FOR EACH OF THE ITEM PAGES
;PUSH THE CURRENT ITEM FOR THIS PAGE ON THE STACK
;AND LOAD THE ITEM WHOSE INDEX IS IN A
ITM'X'PL:	SUB #2,ITM'X'P		;DECREMENT THE STACK POINTER
	MOV ITEM'X,@ITM'X'P		;STORE CURRENT ITEM ON STACK
	INC ITM'X'D			;INDICATE PUSHED ONE MORE LEVEL
;FALL INTO THE LOAD ITEM ROUTINE

;LOAD ITEM WHOSE INDEX IS IN A INTO AN ITEM PAGE
;RETURN THE ADDRESS THAT THE ITEM WAS LOADED INTO IN A
ITM'X'LD:
	SAVE PS
	SPL 7
	CLRB ITM'X'KB		;NO PAGE MAPPED IN
	BIT #GIPBIT,ITEM'X	;IS THE PREVIOUS ITEM A GIP?
	BEQ ITM'X'L4
	BIT #100,ITM'X'DR	;WAS THIS GIP WRITTEN?
	BEQ ITM'X'L4		;NO, CAN IGNORE IT
	CMP #-1,ITEM'X		;IS IT REALLY NON-EX?
	BEQ ITM'X'L4		;YUP, FORGET IT
	SAVE B			;SAVE A REGISTER
	MOV ITEM'X,B		;THE THING TO INDICATE WAS WRITTEN
	JSR PC,ITMGWT		;GO MARK IT AS WRITTEN
	REST B
ITM'X'L4:	MOV A,ITEM'X		;THIS IS NOW THE CURRENT ITEM
	BLT ITM'X'L1			;NOT REALLY AN ITEM
	MOV ITMTAB(A),ITM'X'AR		;SET THE AR
	MOV ITMTAB+ITACCS(A),ITM'X'DR	;AND THE DR
ITM'X'L2:
	REST PS
	MOV #ITM'X'AD,A		;AND THE ADDRESS
	RTS PC
ITM'X'L1:	CMP A,#-1
	BNE ITM'X'L3		;ITS A GIP
	CLR ITM'X'DR		;MAKE THE ITEM NXM
	BR ITM'X'L2		;GO FINISH
ITM'X'L3:	SAVE <B,A>	;SAVE REG AND GIP AND LOAD UP A UPT
	MOV #-1,ITEM'X		;SO WHEN WE POP ITEM2 WE WIN
	JSR PC,ITMGIP
	REST <ITEM'X>		;SET ITEM FIRST TO AVOID TIMING SCREW
	MOV A,ITM'X'DR		;CAN ONLY RECURSE ONE LEVEL
	MOV B,ITM'X'AR
	MOVB #-1,ITM'X'KB	;LEGAL TO GET A PAGE TRAP ON THIS PAGE
	REST <B>		;RESTORE REGISTER
	BR ITM'X'L2

;POP THE TOP ITEM OFF THE STACK
ITM'X'PO:	SAVE A	;DON'T CLOBBER A
	DEC ITM'X'D	;INDICATE POPED ONE LEVEL
	BUGC GE		;DID WE OVER POP?
	MOV @ITM'X'P,A	;GET THE OLD THING
	ADD #2,ITM'X'P	;FLUSH ITFROM THE PDL
	JSR PC,ITM'X'LD	;LOAD THE OLD ITEM
	REST A
	RTS PC
.ENDM
;CLEAR THE VALID AT SWAP SPACE AND VALID AT SOURCE BITS OF THE GIP POINTED TO BY A
ITMGWT:	JSR F,ACSAV
	JSR PC,UPTPLD	;GET A POINTER TO THE UPT
	MOV UPTPBP(B),C	;GET POINTER TO THE PB	
	BIT #PBVACR,PBFLAG(C)	;BETTER BE VALID IN CORE!
	NBUGC EQ	;UGH, GOT OUT BEFORE WE MAPPED IT OUT!
	BIC #PBVASS!PBVAS,PBFLAG(C)	;CAN'T BE VALID AT SWAP SPACE OR SOURCE, WE'VE WRITTEN IT
	JSR F,ACRES
	RTS PC

ITMGIP:	SAVE <C,D,E>
	MOV A,B
	JSR PC,UPTPLD		;RETURN ADDRESS OF UPT IN B
	BIT #UPTABS,(B)		;CHECK THAT IT ISN'T AN ABSOLUTE PAGE
	NBUGC NE
	MOV B,E		;COPY POINTER TO THE UPT
	MOV UPTPBP(E),D	;GET A POINTER TO THE PB
	BIT #PBVACR,PBFLAG(D)	;IS IT VALID IN CORE?
	BEQ ITMGP2	;NO, FORGET ABOUT IT
	MOVB UPTSTL(E),A	;GET THE UPT START
	BLT ITMGP2	;NOT SET UP YET
	BIC #UPTSMS,A	;CLEAR OTHER BITS
.IIF NZ 4-UPTSSH,ASH #4-UPTSSH,A	;SHIFT IF NEEDED
	MOVB PBRAN(D),C	;GET THE PB START
	BIC #PBSTRT,C	;CLEAR OTHER STUFF
	ASH #4,C	;32.=512.
	SUB A,C		;GET PBSTART-UPTSTART
	NEG C		;CHANGE TO UPTSTART-PBSTART
	MOV PBCAR(D),B	;THE PB START ADDRESS
	ADD C,B		;CORRECTED
	ASH #4,B	;CONVERT TO 32 WORD BLOCKS
	SWAB A		;PUT IT INTO THE RIGHT PLACE
	BIS #17_8.+4,A	;OTHERWISE FIX UP THE DR
ITMGP1:	REST <E,D,C>
	JSR PC,ITM2PO
	RTS PC
ITMGP2:	CLR A		;NOBODY HOME
	BR ITMGP1
;RESTORE THE ITEM2 PDL OF TH EPROCESS POINTED TO BY A
ITM2RS:	SAVE C
	MOV A,C		;SAVE ANOTHER POINTER TO ITEM
	ADD #PITM2P,C	;POINT AT ITEM2 STACK
	MOV (C)+,A	;GET FIRST ITEM2
	JSR PC,ITM2LD	;LOAD IT UP
ITM2R3:	DEC PITM2C(B)	;ONE LESS TO LOAD
	BLT ITM2R4	;NO MORE
	MOV (C)+,A	;GET NEXT ONE
	JSR PC,ITM2PL	;LOAD
	BR ITM2R3
ITM2R4:	REST C
	RTS PC
	.SBTTL PROCESS HACKING ROUTINES
;CREATE PROCESS AND PUT IT ON THE STOPPED QUQUE
;RETURN ITEM NUMBER IN A AND CLEAR Z IF SUCESSFUL
;OTHERWISE SEET Z
;RETURN ADDRESS OF PROCESS TABLE ENTRY IN B
CRPROC:	MOV #PRSLNF,A	;SIZE OF A PROCESS WITHOUT THE FLOATING POINT
	JSR PC,CRITEM	;GET AN ITEM FOR IT
	BEQ CRPRO1	;NO ITEM, TOUGH LUCK
	JSR PC,CLITEM	;CLEAR IT AND PUT IT IN ITEM0
	MOV #ITPROC,(A)	;SET THE TYPE
	BIS #PSUPSB,PSTOP(A)	;STOPPED!
	INC PSTOPC(A)		;ONE FOR THE BIT
	MOV #-1,PSPHRP(A)	;NO SPHERE AS OF NOW
	MOV #-1,PITM2P(A)	;NO ITEMS EITHER
	MOV #174000,PUPS(A)	;THE USER MODE PS
	INC NEWPRI		;GET TO NEXT RPOCESS ID #
	BNE .+6
	INC NEWPRI+2
	MOV NEWPRI,PRSID1(A)	;SET THE PROCESS ID
	MOV NEWPRI+2,PRSID2(A)

;NOTE THAT CRUSER ENTERS HERE
;AND INTIALIZES THE VARIABLES THAT IT HAS IN COMMON WITH PROCESSES
CRUSR1:	INC PRSREF(A)	;PRESUMABLY, THE GUY ASKING FOR IT WILL REFERENCE IT
	MOV PFREEQ,PPRTPT(A)	;THE PROCESS BLOCK WE WILL SOON GOBBLE
	JSR PC,ITM0PO	;NOW WE POP THE ITEM STACK
	MOV PFREEQ,A	;GET A PROCESS TABLE ENTRY
	BNE CRPRO2	;GOT ONE!
	MOV B,A		;AFTER ALL THAT WORK
	JSR PC,DLITEM	;WE HAVE TO GIVE UP
CRPRO1:	SEZ		;FAILURE
	RTS PC
CRPRO2:	MOV B,PRTPPT(A)	;SAVE THE ITEM # OF THE PROCESS IN THE PROCESS TABLE
	MOV #IPRIOR,PRTPRI(A)	;EVERYONE STARTS OUT WITH THIS
	SAVE B		;SAVE THE ITEM NUM
	MOV CURUSR,B	;THE CURRENT USER BLOCK
	CMP #-1,B	;ONLY THE VERY FIRST TIME (I HOPE)
	BEQ CRPRO3
	MOV PRTJTM(B),PRTJTM(A)	;START HIM AT A DISADVANTAGE
CRPRO3:	MOV B,PRTUPT(A)		;THE USER CREATING THIS IS THE PROCESS'S USER
	MOV #STOPQ,B	;MOVE FROM THE FREE Q TO THE STOPPED Q
	JSR PC,TQUEUE
	MOV A,B
POPACZ:	REST A		;ITEM NUM
	CLZ		;SUCESS
	RTS PC


;KEEP THIS NEAR CRPROC
;CREATE A USER
;RETURN ITEM NUMBER IN A, ADDRESS OF PROCESS TABLE ENTRY IN B
;CLEAR Z IF SUCESSFUL, OTHERWISE SET IT
CRUSER:	MOV #USRLEN,A	;THE LENGTH OF A USER
	JSR PC,CRITEM	;DO IT!
	BEQ CRPRO1	;FAIL
	JSR PC,CLITEM	;CLEAR THE ITEM
	MOV #ITUSER,(A)	;SET THE TYPE
	JSR PC,CRUSR1	;USE A LOT OF CODE FROM CRPROC
;NOTE THAT THIS WILL LEAVE THE USER ON THE STOP QUEUE
;WHICH WILL CAUSE A PROBLEM IF THE SCHEDULER RUNS
;WHICH IT SHOULDN'T
	BEQ CRPRO1	;FAILURE
	SAVE A		;SAVE THE ITEM INDEX
	MOV B,A		;THE PROCESS TABLE ADDRESS
	MOV #USERQ,B	;THE PLACE WHERE A USER BELONGS
	JSR PC,TQUEUE	;TRANSFER TO USER QUEUE
	MOV A,B
	BR POPACZ	;SUCCESS

;DECREMENT REFERENCE COUNT OF PROCESS IN A
;WIPE IT OUT IFCOUNT REACHES ZERO
DLPROC:	SAVE B
	JSR PC,ITM0PL
	DEC PRSREF(A)	;ONE LESS REFERENCE
	BNE DLPRO1	;SOMEONE ELSE STILL REFERENCES IT
	JSR PC,REMPRS	;REMOVE IT FROMTHE SPHERE
	MOV ITM0A,A
	MOV PPRTPT(A),A	;THE PROCESS TABLE ENTRY FOR IT
	MOV #PFREEQ,B	;MAKE THE PROCESS TABLE ENTRY FREE
	JSR PC,PRSAOD	;DEATVIATE PAGES FOR THIS PROCESS IF ACTIVE
	JSR PC,TQUEUE
	MOV ITEM0,A
	JSR PC,DLITEM	;FLUSH THE ACTUAL PROCESS
	JSR PC,ITM0PO
	REST B
	SEZ		;SAY YOU DELETED IT
	RTS PC
DLPRO1:	JSR PC,ITM0PO
	REST B
	CLZ		;SAY YOU DIDN'T DELETE THE PROCESS
	RTS PC

;TRANFER PROCESS TABLE ENTRY IN A
;FROM IT'S PRESENT QUEUE TO THE ONE IN B
TQUEUE:	SAVE <C,PS>
	SPL 7
;MUST SPL 7 HERE IF THE INT LEVEL LOOKS AT QUEUES BACKWARDS
	MOV (A),C	;THE FORWARD POINTER OF THE ENTRY TO BE MOVED
	MOV C,@PRTBCK(A)	;CORRECT THE FORWARD POINTER OF THE PREVIOUS ENTRY
	TST C		;IS THERE A NEXT ENTRY?
	BEQ .+10	;NO, DON'T DO ANYTHING TO IT!
	MOV PRTBCK(A),PRTBCK(C)	;CORRECT THE BACK POINTER OF THE NEXT ENTRY
;MAY SPL 0 HERE, THE ENTRY IS IN LIMBO FOR THE TIME BEING
	MOV (B),C	;GET THE CONTENTS OF THE QUEUE POINTER
	MOV C,(A)	;POINT THE THING BEING MOVED AT THE BEGGINING OF THE QUEUE
	MOV B,PRTBCK(A)	;CORRECT BACK POINTER OF THING WE ARE MOVING
;SPL 7 HERE IF YOU DID ABOVE
	TST C		;IS THERE AN OLD FIRST ENTRY?
	BEQ .+6		;NO, DON'T DO ANYTHING TO IT!
	MOV A,PRTBCK(C)	;FIX BACK POINTER OF OLD FIRST ENTRY ON NEW QUEUE
	MOV A,(B)	;FIX QUEUE POINTER ITSELF
;SPL 0
	SAVE A
	MOV PRTPPT(A),A	;GET THE ITEM NUMBER OF THE THING
	JSR PC,ITM0PL
	MOV QBIT(B),PQBIT(A)	;SET THE RIGHT Q-BIT
	JSR PC,ITM0PO
	REST A
	REST <PS,C>
	RTS PC
;PUT THE PROCESS WHO'S ITEM IS IN A
;INTO THE SPHERE WHOS ITEM IS IN B
;SHOULD FAIL FOR RUNNING PROCESS OR TOO MANY PROCESSES IN SPHERE (NOT YET)
;CLEARS Z ON SUCESS
PUTPRS:	SAVE <A,B>
	JSR PC,ITM0PL	;PUT THE PROCESS INTO ITEM 0
	TST PSTOPC(A)	;IS IT STOPPED?
	BEQ PUTPR2	;NO, CAN'T MOVE IT THEN
	JSR PC,REMPRS	;GET IT OUT OF ANY SPHERE IT IS IN
	MOV (P),A	;GET THE SPHERE INDEX
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	BIT #FAULT1!FAULT2!FAULT3,SFLAG(A)	;IS THERE A FAULT HAPPENING
	BEQ PUTPR1
	BIS #PSPHSB,PSTOP(B)	;SAY I AM PART OF IT
	INC PSTOPC(B)
PUTPR1:	MOV SPHPRP(A),PSPHCP(B)	;POINT PROCESS TO BEG OF OLD LIST
	MOV (P),PSPHRP(B)	;TELL PROCESS WHO IT BELONGS TO
	MOV 2(P),SPHPRP(A)	;LINK IT INTO THE LIST
	INC PRSREF(B)		;INCREMENT THE REFERENCE COUNT
	REST <B,A>
	JSR PC,ITM0PO
	JSR PC,ITM1PO
	CLZ
	RTS PC
PUTPR2:	JSR PC,ITM0PO	;POP ITEM 0
	REST <B,A>
	SEZ	;SAY WE CAN'T DO IT
	RTS PC
;REMOVE PROCESS IN ITEM0 (ADDRESS IN A) FROM WHATEVER SPHERE IT IS IN
;CLOBBERS B AND A
REMPRS:	MOV PSPHRP(A),A	;POINTER TO SPHERE THIS BELONGS TO
	BLE REMPR1	;WHEW, NO SPHERE, IT'S EASY
	JSR PC,ITM1PL	;GET THE SPHERE IT'S IN
	MOV ITM0A,B	;ADDRESS OF THE PROCESS ITEM
	CMP SPHPRP(A),ITEM0	;DOES IT POINT DIRECTLY TO THE PROCESS?
	BNE REMPR3	;NO, GO SEARCH FO RIT
	MOV PSPHCP(B),SPHPRP(A)	;SPLICE IT OUT OF THE LIST
	BR REMP10	;SKIP THIS LOAD
REMPR5:	MOV PSPHRP(A),A	;GET THE SPHERE BACK
	JSR PC,ITM1LD	;LOAD IT UP
REMP10:	BIT #FAULT1!FAULT2!FAULT3,SFLAG(A)	;WAS IT STOPPED FOR FAULT
;	BEQ REMPR9	;NO
	BR REMPR9	;WELL BRUCE, I DON'T KNOW WHAT THIS CRAP IS FOR!!-RON
	DEC PSTOPC(B)	;RESTART IT
	BIC #PSPHSB,PSTOP(B)	;CLEAR THE SPHERE STOPPING IT BIT.
	BGT REMPR8	;WAS STOPPED FOR ANOTHER REASON
	INC PSTOPC(B)	;STOP IT AGAIN BUT SAY SUPERIOR STOPPED IT
	BIS #PSUPSB,PSTOP(B)	;OKAY FOR NOW
REMPR8:	ADD #PFAULT,B	;POINT TO THE FIRST PHAULT WORD
	TST (B)+	;CHECK THE THREE PHAULT WORDS
	BNE REMPR7
REMPR9:	JSR PC,ITM1PO	;RESTORE ITEM 1
	MOV ITM0A,A	;ADDRESS OF PROCESS
	CLR PSPHRP(A)	;NO LONGER IN SPHERE
	MOV ITEM0,A	;THE PROCESS
	JSR PC,SPRDEC	;DECREMTENT THE REF COUNT AND DELETE IF 0
REMPR1:	RTS PC
REMPR7:	MOV ITEM1,A	;THE SPHERE TO DO THE DEED ON
	JSR PC,FALTFX	;FIX THE FAULT
	CLR -(B)	;CLEAR THE FAULT WORDS
	BR REMPR9	;DONE
REMPR3:	MOV SPHPRP(A),A	;GET THE FIRST PROCESS IN LINE
REMPR6:	BUGC NE		;IS THERE ANOTHER ONE?
	JSR PC,ITM1LD	;PUT THIS PROCESS INTO ITEM1
	CMP PSPHCP(A),ITEM0	;DOES IT POINT TO PROCESS WE WANT TO SPLICE OUT?
	BNE REMPR4	;NOPE, KEEP TRYING
	MOV ITM0A,B
	MOV PSPHCP(B),PSPHCP(A)	;SPLICE IT OUT OF THE LIST
	BR REMPR5	;NOW WE CAN PUT IT WHERE WE WANT TO
REMPR4:	MOV PSPHCP(A),A	;GET NEXT ONE
	BR REMPR6	;GO CHECK IT OUT

;DECREMENT STOP COUNT OF PROCESS
;IF IT REACHES ZERO, PUT PROCESS ONTO RUN Q
;ASSUMES PROCESS IS LOADED INTO ITEM 0
PSTPDC:	SAVE A
	MOV ITM0A,A	;WHERE IS IT?
	DEC PSTOPC(A)	;ONE LESS REASON TO BE STOPPED
	BUGC GE		;SHOULD NOT GET NEGATIVE!
	BGT PSTPD1	;DON'T START IT YET
	SAVE <B,C>
	MOV PPRTPT(A),A	;POINTER TO THE PROCESS TABLE
	MOV #RUNQ,B	;PUT IT ONTO THE RUN Q
	JSR PC,GQTIME	;GET AMOUNT OF TIME ON THE STOP Q
	CMP #5*2,C	;MORE THAN 5 SECONDS?
	BGT .+6		;NO
	MOV #ACTQ,B	;START HIM UP AT AN ADVANTAGE
	JSR PC,PRSAOD
	JSR PC,TQUEUE
	REST <C,B>
PSTPD1:	REST A
	RTS PC
;INCREMENT STOP COUNT OF PROCESS WHOSEITEM ISIN A
;IF THE COUNT WAS ZERO AND THE PROCESS WAS IN THE SYSTEM, PCLOSER IT
PSTPIN:	JSR F,ACSAV
	JSR PC,ITM0PL	;GET IT INTO THE MAP
	TST PSTOPC(A)	;IS IT ALREADY NON-ZERO?
	BNE PSTPI1	;YES, JUST INCREMENT
	MOV PPRTPT(A),A	;IT'S PROCESS TABLE ENTRY
	MOV #STOPQ,B	;STOP THE PROCESS
	JSR PC,PRSAOD	;DEACTIVE PAGES OF THIS PROCESS
	JSR PC,TQUEUE
	MOV ITM0A,A
	TST PSPC(A)	;IN THE SYSTEM?
	BEQ PSTPI1	;NOPE, PC ISUSER MODE PC
	CLR PSPC(A)	;CLEAR HIS PC
	JSR PC,PRSUNL	;UNLOCK HIS SWITCHES
PSTPI1:	INC PSTOPC(A)	;TELL THE WORLDHE IS STOPPED
	JSR PC,ITM0PO
	JSR F,ACRES
	RTS PC

;UNLOCK ALL THE SWITCHES OF THE GUY IN ITEM0
;IN "BEING PCLOSERED" MODE
;CAN BE EXPECTED TO CLOBBER MOST REGISTERS
PRSUNL:	SAVE BPCLSR	;SAVE THE FLAG
	MOV #1,BPCLSR	;SAY WE ARE PCLOSERING HIM
PSTPI2:	MOV ITM0A,A
	TST PLCKSL(A)	;ANY SWITCHES LOCKED
	BEQ PSTPI3	;NOPE
	JSR PC,LSWPOP	;POP THE TOP SWITCH
	BR PSTPI2
PSTPI3:	REST BPCLSR	;DONE PCLOSERING HIM
	RTS PC

;THIS IS WHERE WE GET AFTER SOMEONE SETS PIRQ AND PIRBRK DISPATCHES
;(NOTE THAT WE DON'T GET TO PIRBRK UNTIL ALL INTERUPTS HIGHER
;THAN CLKL HAVE EXITED. CLKL SHOULD BE THE LOWEST INTERUPT IN
;THE SYSTEM, SO IT ALWAYS INTERRUPTS DIRECTLY FROM
;THE MAIN PROGRAM LEVEL)
;STOP A PROCESS IF IT IS IN USER MODE
;IF IT FINDS THE PROCESS
;WAS IN USER MODE, IT ASSUMES THAT THE SECOND REGISTER SET
;WAS BEING USED, AND CLOBBERS SET 0 ARBITRAILY
;IT SAVES THE PROCESSES REGISTERS, THEN RETURNS TO WHOMEVER STARTED
;THE PROCESS BY DOING AN RTS PC
STOPPR:	TST USRMOD	;ARE WE IN USER MODE?
	BNE PIRRET	;NOPE, THE SYSTEM WILL STOP HIM
	MOV PC,USRMOD	;NO LONGER IN USER MODE
	TST (P)+	;FLUSH THE SAVED A
	JSR F,SPCPSP	;SAVE THE PC, THE PS AND P
	JSR PC,PACSAV	;SAVE THE REST OF THE REGISTERS, INCLUDING THE FPP
	JSR PC,SAVAWB	;SAVE THE A AND W BITS
	JSR PC,TIMEUS	;GO CHARGE HIM FOR TIME USED
	MOV #-1,PRUNNG	;NO PROCESS RUNNING NOW
	CLR CDISP	;NO ONE AROUND
	MOV ITM1A,A	;POINT TO THE PROCESS
	MOV SPRTPT(A),A	;PROCESS TABLE POINTER
	RTS PC		;(GULP!!) RETURN TO CALLER
PIRRET:	REST A
	RTT
;CHARGE USER FOR THE TIME HE HAS USED
;EXPECTS POINTER TO ITEM0 IN A. CLOBBERS B AND C
;AND SPHERE IN ITEM1
TIMEUS:	MOV TUSED,B	;NUMBER OF TICKS HE USED
	ASL B		;CONVERT TO HALF TICKS
	BNE .+4		;DID HE USE ANY TIME?
	INC B		;EVERYONE USES AT LEAST ONE HALF-TICK
	ADD B,PTUSED(A)	;UPDATE HIS TIME USED
	ADC PTUSED+2(A)
	MUL #JTMUAC,B	;MULTIPLY BY THE ADDTIVE FACTOR
	MOV PPRTPT(A),C	;POINTER TO PROCESS BLOCK
	ADD B,PRTJTM(C)	;UPDATE THE PROCESS JTMU
	MOV PRTUPT(C),C	;POINTER TO THE USER BLOCK
	ADD B,PRTJTM(C)	;UPDATE THAT JTMU TOO
	SAVE <D,E>
	MOV ITM1A,C	;POINTER TO THE SPHERE
	ADD #SUPTS,C	;MAKE C POINT TO THE FIRST UPT
	MOV #20,B	;NUMBER OF UPT'S
TIMUS1:	BIT #UPTDEI,2(C)	;IS IT I=D SPACE
	BEQ TIMUS2	;NO
	CMP #10,B	;IS IT A DATA PAGE
	BLE TIMUS3	;YES, IT IS ALREADY COUNTED
TIMUS2:	MOVB 1(C),D	;THE DR
	BIC #177617,D	;CLEAR ALL BUT THE LENGTH OF THE REFERENCED ENTRY
	ADD #20,D	;SINCE 0 IS A 1 BLOCK PAGE
	ADD D,E		;GET THE TOTAL CORE LENGTH
TIMUS3:	ADD #UPTLEN,C	;POINT TO THE NEXT UPT
	SOB B,TIMUS1	;GET ALL THE PAGES
	ASH #-4,D	;GET IT INTO THE LOW BITS
	MUL TUSED,D	;GET THE CORE TIME PRODUCT
	MOV ITM1A,C	;POINTER TO THE SPHERE
	MOV SPRTPT(C),C	;POINTER TO PROCESS TABLE ENTRY FOR THIS SPHERE
	ADD D,PRTJTM(C)	;ADD TO THE JTMU
	BVC .+10	;IT DIDN'T OVERFLOW
	MOV #-1,PRTJTM(C)	;MAKE IT AS LARGE AS WE CAN (THE CORE HOG!!!)
	REST <E,D>
	RTS PC
;ENTER THE RUNNING QUEUE
RUNME:	TST ACTCHK
	BNE RUNME1
	SAVE <#ACTQ>	;PROPABLY WANT TO GO TO ACTIVE QUQUE FROM DORMANT
	SAVE A			
	MOV ITM0A,A	;POINT TO PROCESS
	BIT #DORQB,PQBIT(A)	;WAS IT DORMANT?
	BNE FLUSH5	;YES, GO TO ACTIVE STATE
	MOV #RUNQ,2(P)	;NO, GO TO RUN STATE
	BR FLUSH5
RUNME1:	SAVE <#WINQ>	;I'M BEING ACTIVATED SO PUT ME ON WINQ
	BR FLUSH

;ENTER THE SHORT FLUSHED QUEUE
SFLUSH:LFLUSH:	;ENTER A HANGING QUQUE
	SAVE #DORQ	;IF WE ARE ALREADY RUNNING, BECOME DORMANT
	SAVE A
	MOV ITM0A,A	;POINT TO PROCESS
	TST PSPC(A)	;ALREADY FLUSHED?
	BEQ FLUSH5	;NO, BECOME DORMANT
	BIT #DORQB,PQBIT(A)	;DORMANT BEFORE?
	BNE FLUSH5	;STAY THAT WAY
	MOV #IACTQ,2(P)	;STAY INACTIVE
	BR FLUSH5

FLUSH:	SAVE A		;GET A FREE REGISTER
	MOV ITM0A,A	;THE RUNNING PROCESS IS ALWAYS ITEM 0
FLUSH5:	ADD #PSREGS,A	;A POINTER TO THE SYSTEM REGISTERS FOR THE GUY
	TST BPCLSR	;IS THIS GUY BEING PCLOSERED?
	NBUGC NE	;SHOULD NEVER HANG!
	REST (A)+	;GET BACK A
.IRPC X,<BCDEF>
	MOV X,(A)+
.ENDM
	MOV ITM0A,E
	MOV PPRTPT(E),A	;POINTER TO PROCESS TABLE
	MOV (P),B	;QUEUE TO MOV IT TO
	JSR PC,PRSAOD	;ACTIVATE OR DEACTIVE PAGES IF APPROPRIATE
	JSR PC,TQUEUE	;DO THE ACTUAL MOVE
	MOV ITM0A,A
	REST <B,E>		;GET THE QUEUE AGAIN
	TST PSPC(A)	;WERE WE ALREADY FLUSHED?
	BNE FLUSH2	;YES
.IRPC X,<01>
	TST ITM'X'D
	NBUGC NE		;HAD ITEMS PUSHED
.ENDM
	CLR CDISP	;OLD GUY NOT RUNNING ANY MORE
	JSR PC,PACSAV	;IN CASE USER'S REGISTERS NOT SAVED YET
	JSR PC,TIMEUS	;CHARGE HIM FOR TIME USED
	JSR PC,SAVAWB	;SAVE REFERENCED PAGES
	JSR PC,PDLSAV	;SAVE THE SYSTEM PDL
	MOV ITM1A,A	;POINT TO THE SPHERE
	MOV SPRTPT(A),A	;POINT TO THE PROCESS TABLE ENTRY
FLUSH2:	MOV ITM0A,A
	MOV A,B		;COPY POINTER INTO ITEM
	ADD #PITM2P+2,A	;POINT TO ITEM2 PDL
	MOV ITM2D,C	;COUNT OF ITEMS PUSHED ON ITEM2 STACK
	MOV C,PITM2C(B)
	BEQ FLUSH4	;NONE, EASY CASE
	ASL C		;MAKE COUNT INTO INDEX
	CMP #PIT2PL-2,C	;CHECK THAT THERE AREN'T TOO MANY PUSHED
	NBUGC LT
	ADD C,A		;POINT TO END OF PDL AREA TO BE USED
	ASR C		;CONVERT BACK TO COUNT
FLUSH3:	MOV ITEM2,-(A)	;SAVE CURRENTLY LOADED ITEM
	JSR PC,ITM2PO	;POP NEXT ONE
	SOB C,FLUSH3
FLUSH4:	MOV ITEM2,-(A)	;SAVE THE LAST ONE
	MOV #-1,A	;DUMMY ITEM	
	JSR PC,ITM2LD	;LOAD TO FORCE W BITS ON ITEM2
	MOV E,PSPC(B)
	RTS PC
;START THE PROCESS WHOSE PROCESS TABLE ENTRY IS
;POINTED TO BY A
;WHEN PROCESS FINALLY STOPS, THE ROUTINE WILL RETURN
;CLOBBERS ALL REGISTERS
STPROC:	MOV HSECS,LTPSTA	;SAVE THE LAST TIME A PROCESS WAS STARTED
	MOV P,STPSVP	;SAVE P FOR ERROR RECOVERY
	BIS #30000,PS	;MAKE SURE PREVIOUS MODE IS USER
	SPL CLKL	;STOP US FROM GETTING STOPPED
	BIC #CLKPIR,PIRQ	;MAKE SURE NO STOP PENDING
	MOV PRTUPT(A),CURUSR	;THE GUY TO "CHARGE" FOR THIS RUN
	CLR TUSED		;START COUNTING NOW
	MOV PRTPPT(A),A		;GET THE PROCESS ITEM #
	MOV A,PRUNNG		;THIS IS THE RUNING PROCESS
	MOV A,CDISP		;SAY WHICH PROCESS IS RUNNING
	JSR PC,ITM0LD	;IT IS EXPECTED TO BE IN ITEM0
	MOV A,B		;SAVE THE POINTER TO IT
	JSR PC,ITM2RS	;RETORE THE ITEM2 PDL
	MOV PSPHRP(B),A	;GET A POINTER TO THE SPHERE
	JSR PC,ITM1LD	;IT IS EPECTED IN ITEM1
	JSR PC,PACRES	;RESTORE REGISTER SET 1
	JSR PC,MAPRES	;RESTORE THE MAP
	SAVE PUP(B)	;GET THE USER'S PDL POINTER
	MTPI P		;RESTORE IT TO HIM
	TST PSPC(B)	;IS HE RUNNING IN THE SYSTEM?
	BNE STPRO1	;YES, GO RESTORE OTHER THINGS
	BIC #PPCLSR,PFLAGS(B)	;THEN HE DOESN'T NEED TO BE PCLOSERED!
	TST PFAULT(B)	;IS THERE A FAULT?
	BEQ .+6		;NO, JUST RETURN TO HIM
	JMP CFAULT	;CAUSE THE MAGIC FAULT TO HAPPEN
	MOV P,PSP(B)	;WHERE THE PDL ENDS
	SAVE <PUPS(B),PUPC(B)>	;HIS PROCESSOR STATUS AND HIS PROGRAM COUNTER
	CLR USRMOD	;THE WORLD IS NOW IN USER MODE
	RTT		;RETURN TO HIM IN USER MODE

STPRO1:	BIT #PPCLSR,PFLAGS(B)	;SHOULD HE BE PCLOSERED?
	BEQ STPRO2	;NO
	BIC #PPCLSR,PFLAGS(B)
	CLR PSPC(B)
	JSR PC,LSWCLR	;CLEAR THE SWITCHES
	RTS PC		;RETURN TO THE SCHEDULER

STPRO2:	JSR F,PDLRES	;RESTORE HIS SYSTEM PDL
	SAVE <#30000,PSPC(B)>	;GET PS AND GET PC
	CLR PSPC(B)	;INDICATE NOT HUNG
	MOV (P),USRMOD	;INDICATE THAT WE ARE NOT IN USER MODE
	MOV B,A		;POINTER TO THE PROCESS
	ADD #PSREGS+14,A	;THE SYSTEM REGISTERS
.IRPC X,FEDCBA
	MOV -(A),X
.ENDM
	RTT		;EXIT TO RIGHT PLACE IN THE SYSTEM
;SAVE THE USER'S PC, PS AND PDL POINTER
;CALL WITH JSR F,SPCPSP
;A GETS CLOBBERED TO ITEM 0 ADDRESS
;F GETS CLOBBERED TO VALUE OF THE USER'S P
;ITEM0 IS EXPECTED TO BE THE PROCESS
SPCPSP:	TST (P)+
	MOV ITM0A,A	;THE ADDRESS OF THE PROCESS IN THE MAP
	REST <PUPC(A),PUPS(A)>	;SAVE HIS PC AND HIS PS
SAVEPP:	MOV ITM0A,A
	MFPD P		;GET HIS P
	MOV (P),PUP(A)	;SAVE HIS PDL POINTER (PUP-P?)
	RTS F		;RETURN WITH P IN F
;SAVE THE PROCESSES REGISTERS, INCLUDING THE FPP IF THAT IS ENABLED
;THE GENERAL REGISTERS ARE IN SET 1
;THE ADDRESS OF THE PROCESS ITEM IS EXPECTED IN A
;THE PROCESS ITEM IS EXPECTED TO BE IN THE MAP
PACSAV:	SAVE A		;TO COMMUNICATE WITH THE OTHER REGISTER SET
	BIT #PACSVF,PFLAGS(A)	;HAVE THE AC'S ALREADY BEEN SAVED?
	BEQ PACSV1	;ZERO=>SAVED
	BIC #PACSVF,PFLAGS(A)
	BIS #4000,PS	;CHANGE TO OTHER SET
	SAVE A		;SAVE A OF SET 1
	MOV 2(P),A	;GET A FROM SET 0
	ADD #PUREGS,A	;POINT TO PALCE TO SAVE REGISTERS
	REST (A)+	;SAVE A OF SET 1
	MOV B,(A)+	;SAVE REST OF SET 1
	MOV C,(A)+
	MOV D,(A)+
	MOV E,(A)+
	MOV F,(A)+
	BIC #4000,PS	;BACK TO SET 0
;NOTE THAT SET 0'S A HAS NOT BEEN CLOBBERED
	BIT #PFPFLG,PFLAGS(A)	;HAS HE ENABLED THE FPP?
	BEQ PACSV1	;NOPE
	STFPS PFPPS(A)		;STORE THE STATUS
	ADD #PFPPRG,A	;POINT TO FPP REGISTERS
	SETD		;SO WE SAVE ALL THE BITS
	STD A,(A)+
	STD B,(A)+
	STD C,(A)+
	STD D,(A)+	;SAVE ALL WE CAN GET TO DIRECTLY
	LDD E,A		;LAST 2 HAVE TO BE MOVED SPECIAL
	STD A,(A)+
	LDD F,A
	STD A,(A)+
PACSV1:	REST A
	RTS PC
;RESTORE THE USER'S REGISTERS
;B IS EXPECTED TO CONTAIN A POINTER TO THE PROCESS ITEM
;NO REGISTERS ARE CLOBBERED (EXCEPT, OF COURSE, THE USER'S)
PACRES:	SAVE B
	BIT #PACSVF,PFLAGS(B)	;WERE THEY EVER SAVED?
	BNE PACRS1	;ONE=>NOT SAVED
	BIS #PACSVF,PFLAGS(B)
	BIS #4000,PS	;GO TO REGISTER SET 1
	MOV (P),A	;GET THE POINTER TO THE ITEM
	ADD #PUREGS+14,A	;CONVERT TO A REGISTER POINTER
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	BIC #4000,PS	;BACK TO SET 0
	BIT #PFPFLG,PFLAGS(B)
	BEQ PACRS1		;DOESN'T USE FPP
	SETD		;RESTORE ALL BITS
	ADD #PFPPRG+<16.*2>,B	;POINT TO REGISTERS E AND F FIRST
	LDD (B)+,A
	STD A,E
	LDD (B)+,A
	STD A,F
	MOV (P),B
	ADD #PFPPRG,B		;GO BACK FOR REG'S A THROUGH D
.IRPC X,<ABCD>
	LDD (B)+,X
.ENDM
	MOV (P),B
	LDFPS PFPPS(B)
PACRS1:	REST B
	RTS PC
;RESTORE THE USER'S SYSTEM PDL
;CALLED WITH JSR F,PDLRES  
;CLOBBERS A AND C AND F
;AS WELL AS PUSHING THINGS ONTO P
;EXPECTS A POINTER TO THE PROCESS ITEM IN B
PDLRES:	TST (P)+
	MOV PSP(B),A	;THE INCREMENT FOR THE STACK POINTER
	MOV P,PSP(B)	;FOR PDLSAV, THE VALUE IT SHOULD HAVE AFTER SAVING
	ASR A		;CONVERT TO COUNT
	BEQ PDLRE1	;NONE, DON'T LOOP
	MOV B,C		;COPY POINTER TO ITEM
	ADD #PPDL,C	;MAKE IT A POINTER TO THE PDL
PDLRE2:	MOV (C)+,-(P)	;POP-PUSH
	SOB A,PDLRE2
PDLRE1:	JMP (F)	
;SAVE THE SYSTEM PDL INTO THE PROCESS'S
;SYSTEM PDL AREA. SAVES UP TO WHAT IS INDICATED BY PSP
;CALLED WITH JSR PC,PDLSAV
;CLOBBERS A,B,C, AND F
;ALSO POPS STUFF OFF THE STACK
PDLSAV:	REST F		;GET THE RETURN ADDRESS
	MOV ITM0A,A	;GET A POINTER TO THE PROCESS
	MOV PSP(A),B	;WHAT THE PDL POINTER SHOULD BE
	MOV B,C
	SUB P,B		;WHAT'S THE DIFFERENCE?
	MOV B,PSP(A)	;SAVE THE OFFSET
	BEQ PDLSA1	;NONE, FORGET IT
	NBUGC LT	;MAKE SURE IT'S POSITIVE
	CMP #PRPDLL,B	;IS IT PUSHED TO DEEP?
	BUGC GT		;NAUTGHY!
	ADD A,B		;MAKE A POINTER TO THE END OF
	ADD #PPDL,B	;THE PROCESS'S PDL
PDLSA2:	MOV (P)+,-(B)	;POP-PUSH
	CMP C,P		;ARE WE DONE YET?
	BNE PDLSA2	;NOPE
PDLSA1:	JMP (F)

;RETURN THE NEXT WOR DFROM THE USER'S PDL
;INCREMENT THE POP COUNT SO IT IS POPED IF THE CALL RETURNS
;THE WORD IS RETURNED IN A
RETNSW:	SAVE B
	MOV ITM0A,A	;ASSUME THE PROCESS IS ITEM 0
RETNS1:	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;THE OFFSET SO FAR
	ADD #2,PUPDLO(A)	;POPPED ONE MORE THING
	MFPD (B)	;GET THE WORD
	MOV  (P),A	;SAVE THE WORD
	MTPD (B)	;MAKE SURE WE CAN WRITE IT BACK
	REST B
	RTS PC
;RETURN THE PREVIOUS WORD FROM THE USER'S STACK (THE ONE YOU GOT ALREADY)
;RETURNED IN A
RETPSW:	SAVE B
	MOV ITM0A,A
	SUB #2,PUPDLO(A)	;BACK UP!
	BR RETNS1	;GO DO THE REST

:GIVE THE WORD IN B TO THE USER
GIVPSW:	SAVE <A,C,B>
	MOV ITM0A,A	;ASSUME PROCESS IS IN ITEM0
	MOV PUP(A),C	;THE PDL POINTER
	SUB #2,PUPDLO(A)	;DEC THE OFFSET
	ADD PUPDLO(A),C	;MAKE IT CORRECTED
	MTPD (C)	;MOVE THE WORD
	REST <C,A>	;RESTORE REGS
	RTS PC
	.SBTTL SPHERE HACKING ROUTINES

;CREATE A SPHERE
;RETURN THE INDEX OF THE ITEM IN A
CRSPHR:	SAVE B
	MOV #SPHLEN,A	;THE LENGTH OF A SPHERE (INITIALLY)
	JSR PC,CRITEM	;MAKE ONE
	BNE CRSPH1	;DID IT SUCEED?
CRSPH0:	REST B
	SEZ		;INDICATE FAILURE
	RTS PC		;NOPE
CRSPH1:	JSR PC,CLITEM	;LOAD IT INTO ITEM0 AND CLEAR IT
	MOV #ITSPHR,(A)	;SET THE TYPE
	MOV CURUSR,SUSRPT(A)	;THE GUY WHO CREATES IT GETS "CHARGED" FOR  IT
	MOV #SICLST+<NCLSEB*CLSELN*2>,SCLSEP(A)	;THE LAST LOCATION USED
	SAVE <C,B>
	MOV A,B
	ADD #SCLSTT,B	;GET AN ADDRESS POINTER TO THE INDEX TABLE
	MOV #<MNCLSE/NCLSEB>/2,C	;NUMBER OF WORDS OF POINTERS
	MOV #-1,(B)+
	SOB C,.-4	;INTIALIZE THEM TO POINT AT NOTHING
	MOVB #1,-(B)	;EXPECT THE LAST ONE POINTS AT THE 2ND BLOCK
	CLRB SCLSTT(A)	;AND THE FIRST TO THE FIRST
	MOV CURSPH,SMSSPT(A)
	MOV (P),B	;GET THE ITEM INDEX BACK
	JSR PC,CRUSR1	;INITIALIZE THE PROCESS TABLE ENTRY
	BEQ CRSPH2
	MOV B,A		;THE PROCESS TABLE ENTRY
	MOV #SPHRQ,B	;THE PLACE TO PUT IT
	JSR PC,TQUEUE	;MOVE IT
	REST A	;THE ITEM #
	REST C
	REST B	;THE ORIGINAL CONTENTS OF B
	CLZ		;SUCECESS
	RTS PC
CRSPH2:	REST <A,C>
	BR	CRSPH0

;SAVE THE A AND W BITS FOR THE CURRENT SPHERE
;THE SPHERE IS EXPECTED TO BE IN ITEM1, AND THE USER
;SEGMENTATION REGISTERS ARE EXPECTED TO REFLECT THIS SPHERE
SAVAWB:	JSR F,ACSAV
	MOV ITM1A,A	;ADDRESS OF ITEM1 IN THE MAP
	ADD #SUPTS,A	;POINT TO THE UPTS DR
	MOV #USRISD,B	;THE ACTUAL SEGMENTATION REGISTERS
	MOV #20,C	;NUMBER OF SEGMENTS
SAVAW1:	BIT #100,(B)	;THE SEGMENTER'S DR, W BIT
	BEQ SAVAW2	;NOT WRITTEN, CAN IGNORE IT
	MOV UPTPBP(A),D	;GET PB POINTER
	BIC #PBVASS!PBVAS,PBFLAG(D)	;NO LONGER VALID AT SOURCE OR SWAP SPACE
SAVAW2:	CLR (B)+	;MAP OUT THAT PAGE
	ADD #UPTLEN,A	;TO THE NEXT UPT ENTRY
	SOB C,SAVAW1
	MOV #-1,CURSPH	;NO SPHERE MAPPED IN NOW!
	JSR F,ACRES
	RTS PC
	.SBTTL SPHERE HACKING ROUTINES- C-LIST HANDLERS
;GET ADDRESS OF A C-LIST ENTRY
;A CONTAINS ADDRESS OF SPHERE IN MAP
;B CONTAINS C-LIST NUMBER
;B RETURNS OFFSET INTO SPHERE IF SUCESSFUL (Z CLEAR)
;OTHERWISE Z SET AND B CONTAINS SPHERE BYTE ADDRESS OF INDEX BYTE
GCLSTA:	SAVE <D,C,A>
	CMP B,#200		;IS IT TO LARGE?
	BHIS GCLST1	;YES
	CLR C		;FOR THE DIVIDE
	MOV B,D		;SAVE C-LIST NUMBER
	DIV #NCLSEB,C	;GET THE BLOCK AND OFFSET
	ADD C,A		;CONVERT TO
	ADD #SCLSTT,A	;ADDRESS OF INDEX BYTE
	MOVB (A),B	;GET THE BYTE
	BLT GCLST1	;NEGATIVE IMPLIES NO STUCK BLOCK
	MUL #NCLSEB*CLSELN,B	;RELATIVE ADDRESS OF BLOCK
	MUL #CLSELN,D	;REMANDER
	ADD D,B		;NOW WITHIN BLOCK
	ADD #SICLST,B	;LESS RELATIVE
	REST <A,C,D>
	CLZ		;SUCESS
	RTS PC
GCLST1:	MOV A,B		;SAVE FOR THE CALLER
	REST <A,C,D>
	SEZ		;FAILURE
	RTS PC
;ALWAYS GET THE ADDRESS OF A C-LIST ENTRY
;(CREATE IF NON-EXISTANT)
;B CONTAINSC-LIST NUMBER
;C CONTAINS ITEM NUMBER TO INSERT INTO
;A GETS CLOBBERED
;B RETURNS OFFSET INTO SPHERE IF SUCESSFUL (Z CLEARED)
;OTHERWISE, SET Z
AGCLSA:	SAVE B
	MOV C,A		;COPY SPHERE ITEM NUMBER
	JSR PC,ITM1PL	;LOAD IT INTO THE MAP
	JSR PC,GCLSTA	;SEE IF THE ENTRY IS ALREADY THERE
	BNE AGCLS1	;SUCESS, IT'S ALREADY THERE
	MOV SCLSEP(A),A	;POINTER TO BEGGINING OF UNUSED SPACE
	ADD #NCLSEB*CLSELN,A	;NEW END
	JSR PC,ITM1PO	;IN CASE WE HANG
	SAVE B
	MOV C,B		;COPY SPHERE ITEM NUMBER
	ASH #-6,A	;MAKE WORD SIZE INTO BLOCK SIZE
	JSR PC,EXITEM	;MAKE SURE IT'S BIG ENOUGH
	BEQ AGCLS2	;FAILURE
	MOV C,A		;ITEM WHERE THE NEW THING IS GOING
	JSR PC,ITM1PL	;LOAD IT UP
	MOV #NCLSEB*CLSELN/2,B	;NUMBER OF WORDS WE JUST ADDED
	MOV SCLSEP(A),C	;POINTER TO OLD END+2
	ADD #NCLSEB*CLSELN,SCLSEP(A)	;THE NEW END
	SAVE D
	MOV C,D		;FOR DIVIDE LATER
	ADD A,C		;MAKE IT A REAL ADDRESS FOR CLEAR
	CLR (C)+	;WIPE OUT NEW STUFF
	SOB B,.-2
	CLR C		;FOR DIVIDE
	SUB #SICLST,D	;MAKE IT RELATIVE
	DIV #NCLSEB*CLSELN,C	;GET BLOCK NUMBER
	MOV 2(P),B	;RESTORE BYTE POINTER
	MOVB C,(B)	;NEW BLOCK NUMBER
	MOV ITEM1,C	;THE SPHERE WE ARE HACKING
	JSR PC,ITM1PO	;RESTORE ITEM 1
	REST <D,B,B>
	BR GCLSTA	;TRY AGAIN
AGCLS1:	JSR PC,ITM1PO	;POP THE ITEM WE PUSHED
	TST (P)+
	CLZ
	RTS PC
AGCLS2:	REST <B,B>
	SEZ
	RTS PC
;GET THE ADDRESS OF A C-LIST ENTRY, ASSUMING THE SPHERE IS IN ITEM 1
;RETURN REAL ADDRESS IN A AND CLEAR Z, UNLESS YOU FAIL
AGCLAD:	SAVE <B,C>
	MOV ITEM1,C	;ASSUME THE SPHERE IS IN ITEM 1
	JSR PC,AGCLSA	;GO GET THE ADDRESS
	BEQ AGCLA1	;FAILURE
	MOV ITM1A,A	;GET THE ADDRESS IN THE MAP
	ADD B,A		;MAKE A REAL ADDRESS
	REST <C,B>
	CLZ
	RTS PC
AGCLA1:	REST <B,C>
	SEZ
	RTS PC


;GET A POINTER TO THE NEXT EXISTANT C-LIST ENTRY
;ON ENTRY, A POINTS TO THE ITEM WITH THE SPHERE
;D IS THE FIRST C-LIST NUMBER TO CHECK
;B RETURNS POINTING TO THE C-LIST ENTRY
;D RETURNS POINTING TO THE C-LIST ENTRY
;CLEAR Z IF SUCESSFUL, SET OTHERWISE
GNCLST:	CMP #MNCLSE,D	;AT THE LAST ENTRY?
	BNE GNCLS3	;NOT YET, TRY AGAIN
	RTS PC		;AT END, NOTE THAT Z IS SET
GNCLS3:	MOV D,B		;COPY THE C-LIST NUMBER
	JSR PC,GCLSTA	;TRY TO GET POINTER
	BEQ GNCLS1	;NO SUCH BLOCK
	ADD A,B		;MAKE A REAL POINTER
	TST (B)		;ANYHTING THERE?
	BEQ GNCLS2	;NO, TRY NEXT ONE
	RTS PC		;FOUND ONE, NOTE THAT Z IS CLEAR
GNCLS1:	ADD #NCLSEB-1,D	;NEXT BLOCK
GNCLS2:	INC D		;NEXT ENTRY
	BR GNCLST
;CREATE A C-LIST ENTRY, ITEM OF SPHERE IN C, POSITION OF ENTRY
;TO BE CREATED IN B (-1 GETS THE FIRST AVAILABLE ENTRY), RETRURNS WITH Z CLEARED
;NORMALLY, SETS Z IF SLOT ISN'T AVAILABLE, AND SETS C IF NO SLOTS AVAILABLE
;ON NORMAL RETURN, B CONTAINS C-LIST NO. AND A CONTAINS ADDRESS OF ENTRY RELATIVE TO SPHERE
CRCLST:	BIC #177400,B	;ONLY THE BOTTOM BYTE IS SIGINIFICANT
	CMP #377,B	;IS IT -1
	BNE CRCLS1	;NO, FIGURE OUT WHICH ONE IT IS
	MOV #MNCLSE-1,B	;START LOOKING AT THE TOP
CRCLS2:	SAVE B		;THE CURRENT C-LIST NO.
	JSR PC,AGCLSA	;GET A C-LIST ENTRY
	BEQ CRCLS3	;FAILED, BECAUSE NOT AVAILABLE
	MOV C,A		;THE SPHERES ITEM NO.
	JSR PC,ITM1PL	;LOAD IT UP
	ADD B,A		;MAKE THE POINTER TO THE C-LIST ENTRY ABSOLUTE
	TST (A)		;IS IT FREE
	BEQ CRCLS4	;YES RETURN SUCESSFUL
	REST B
	DEC B		;TRY THE NEXT C-LIST ENTRY
	BEQ CRCLS5	;NO MORE RETURN WITH CARRY SET
	JSR PC,ITM1PO	;POP THE SPHERE
	BR CRCLS2	;TRY THE NEXT ONE
CRCLS1:	SAVE B
	JSR PC,AGCLSA	;GET A C-LIST ENTRY
	BEQ CRCLS3	;FAILED (NOT AVAILABLE)
	MOV C,A		;SPHERES ITEM NO
	JSR PC,ITM1PL	;LOAD UP THE SPHERE
	ADD B,A		;MAKE THE POINTER ABSOLUTE
	TST (A)		;IS TI FREE
	BNE CRCLS6	;NOPE
CRCLS4:	REST B
	SUB ITM1A,A	;MAKE IT RELATIVE AGAIN
	JSR PC,ITM1PO	;POP THE SPHERE
	CLZ!CLC		;CLEAR EVERYTHING
	RTS PC
CRCLS6:	REST B
CRCLS5:	JSR PC,ITM1PO	;POP THE SHPERE
	CLZ
	SEC
	RTS PC
CRCLS3:	REST B
	SEZ 
	RTS PC
;THIS ROUTINE TAKES A POINTER TO THE FIRST CAPABILITY OF A CIRCULAR
;LIST IN A AND THE C-LIST NO. OF THAT CAP IN B, AND RETURNS THE
;ITEM NO. (IN C) AND THE C-LIST NO. (IN D) OF THE C-LIST ENTRY THAT
;POINTS TO IT. THE C-LIST NO. OF THE ORIG. ENTRY IS IN B,AND THE ORIG.
;ITEM NO. IN A. RETURNS WITH Z SET IF NO CIRCULAR LIST
FNBKPT:	TST 4(A)	;IS THERE A CIRCULAR LIST
	BNE FNBPT1	;YES
	MOV ITEM1,C	;FAKE THE CIRCULAR LIST
	MOV B,D		;COPY IT
	RTS PC
FNBPT1:	MOV ITEM1,A	;THE CURRENT ITEM NO.
	SAVE <A,B>	;FOR REFERENCE LATER
FNBPT2:	SAVE <A,B>	;SAVE CURRENT ITEM AND C-LIST
	JSR PC,ITM1PL	;LOAD UP THIS SPHERE
	JSR PC,GCLSTA	;GET ADDRESS OF C-LIST ENTRY
	BUGC NE		;DID WE SUCCEED
	ADD A,B		;MAKE THE POINTER ABSOLUTE
	MOV 4(B),A	;THE NEXT C-LIST NO.
	MOV 10(B),B	;THE NEXT C-LIST ITEM
	BUGC NE		;THE ITEM SHOULDN'T BE 0
	JSR PC,ITM1PO	;GET RID OF THIS ITEM
	REST <D,C>	;GET THE OLD VALUES
	CMP A,2(P)	;IS THE POINTER THE SAME AS THE ORIG.
	BNE FNBPT2	;NOPE FIND THE NEXT ONE
	CMP B,(P)	;IS THE REST OF THE POINTER THE SAME
	BNE FNBPT2	;NOPE TRY AGAIN
	ADD #4,P	;POP OFF THE ORIG. ITEM AND C-LIST NO.
	CLZ
	RTS PC

;STOP SPHERE WITH INDEX IN C
SPRSTP:	SAVE A
	MOV #-1,A	;FOR THE BOGUS PUSH
	JSR PC,ITM0PL	;CREATE A WORK CELL
	MOV C,A		;THE SPHERE NO.
	JSR PC,ITM1PL	;LOAD THE SPHERE
	MOV SPHPRP(A),A	;GET POINTER TO THE FIRST PROCESS
	JSR PC,ITM1PO	;POP THE SPHERE
	BR SPSTP2	;CHECK OUT THE FIRST PROCESS
SPSTP1:	JSR PC,PSTPIN	;STOP THE PROCESS
SPSTP3:	JSR PC,ITM0LD	;LOAD THE PROCESS JUST STOPPED
	MOV PSPHCP(A),A	;GET THE NEXT PROCESS
SPSTP2:	CMP A,PRUNNG	;DONT STOP THE CURRENT PROCESS
	BEQ SPSTP3	;THIS IS IT
	TST A		;ARE THERE ANY PROCESSES
	BNE SPSTP1	;YES
	JSR PC,ITM0PO	;POP THE WORK CELL
	REST A
	RTS PC

;PCLOSER ROUTINE FOR DECREMENTING SPHERE STOP COUNTS
PCSPST:	SAVE E
	MOV LCKWD2(B),E	;THE ONE NOT TO START
	MOV ITEM2,A	;THE SPHERE IS LOADED INTO ITEM2
	BR SPRST5
;DECREMENT THE STOP COUNTS OF EVERYTHING ATTACHED TO THIS SPHERE
;INDEX IN A
SPRSTR:	SAVE E
	CLR E		;STOP ALL THE PROCESSES
SPRST5:	SAVE B
	JSR PC,ITM1PL	;LOAD THE SPHERE
	MOV SPHPRP(A),B	;GET THE POINTER TO THE FIRST PROCESS
	JSR PC,ITM1PO	;POP THE SPHERE
	MOV #-1,A
	JSR PC,ITM0PL	;MAKE A BOGUS PUSH
	BR SPSTR4	;CHECK THE FIRST ONE
SPSTR1:	JSR PC,PSTPDC	;DECREMENT THE PROCESSES STOP COUNT
SPSTR3:	BIC #PSPHSB,PSTOP(A)	;CLEAR THE STOP BIT
	MOV PSPHCP(A),B	;GET THE NEXT PROCESS
SPSTR4:	TST B		;ARE THERE ANY MORE PROCESSES
	BEQ SPSTR2	;NO WE ARE DONE
	MOV B,A		;THE NEXT PROCESS
	JSR PC,ITM0LD
	CMP B,E		;IS THIS THE ONE NOT TO DECREMENT
	BEQ SPSTR3	;YES IGNORE IT
	BR SPSTR1	;GO STOP THIS ONE
SPSTR2:	JSR PC,ITM0PO	;POP THE PROCESS
	REST <B,E>
	RTS PC
;THIS ROUTINE IS THE PC-LOSER ROUTINE FOR RESTARTING PROCESSES IN A SPHERE AND
;ALL INFERIOR SPHERES
PCMSST:	MOV ITEM2,A	;GET THE SPHERE NO.
	JSR PC,ITM1PL	;LOAD UP THE SPHERE
	SAVE E		;KEEP E FROM BEING CLOBBERED
	CLR E		;SAY WE SHOULD START THE PROCESSES
	JSR PC,STPMS	;START THEM
	REST E		;RESTORE E
	JSR PC,ITM1PO	;POP THE SPHERE
	RTS PC		;RETURN

;THIS ROUTINE EXPECTS THAT MS TO BE STOPPED OR STARTED TO BE LOADED IN ITEM1
;IF E IS < 0 THE SPHERE (AND INFERIORS ARE STOPPED, ELSE STARTED)
STPMS:	JSR F,ACSAV	;SAVE THE AC'S
	SAVE <#-1>	;FLAG THE TOP OF THE STACK
STPMS8:	MOV ITEM1,A	;WHATEVER IS IN ITEM1 IS WHAT WE WANT TO STOP
	TST E		;OR START
	BLT STPMS1	;STOPPING
	JSR PC,SPRSTR	;STARTING
	BR STPMS2
STPMS1:	MOV A,C		;REQUIRES SPHERE IN DIFFERENT REGISTER
	JSR PC,SPRSTP	;STOP IT
STPMS2:	CLR D		;D IS THE CURRENT C-LIST ENTRY NUMBER
STPMS3:	MOV ITM1A,A	;POINT TO THE CURRENT SPHERE
STPMS9:	JSR PC,GNMSCP	;GET NEXT MS CAP
	BEQ STPMS4	;NO ONE HOME
	SAVE <D>	;SAVE THE CONTINUATION POINT
	MOV 2(B),A	;GET THE INDEX OF THE SPHERE POINTED TO
	JSR PC,ITM1LD	;LOAD IT UP
	BR STPMS8	;GO STOP/START IT AND LOOK AT ITS C-LIST
STPMS4:	REST D		;TRY TO POP TO SUPERIOR SPHERE
	BLT STPMS6	;GOT THE FLAG
	MOV SMSSPT(A),A	;GET THE SUPERIOR
	JSR PC,ITM1LD	;AND MAKE IT CURRENT
	INC D		;NEXT C-LIST ENTRY
	BR STPMS9	;CONTINUE THROUGH ITS C-LIST
STPMS6:	JSR F,ACRES
	RTS PC		;DONE
;GET NEXT MSCAP
;A POINTS TO THE SPHERE IN THE MAP
;D POINTS TO THE FIRST C-LIST ENTRY TO CHECK
;B GETS THE POINTER TO THE ENTRY
;D GETS THJeNUMBER OF THE ENTRY
;SET Z ON FAILURE
GNMSC2:	INC D		;LOOP TO NEXT ENTRY
GNMSCP:	JSR PC,GNCLST	;GET THE NEXT C-LIST ENTRY
	BEQ GNMSC1	;NONE
	CMPB #.MSCAP,(B)	;IS IT A MSCAP?
	BNE GNMSC2	;NO, TRY NEXT ONE
	CLZ		;Z HAD BEEN SET, BUT WE WON SO CLEAR IT
GNMSC1:	RTS PC		;RETRUN WITH Z SET OR CLEARED

;TAKES POINTER TO UPT IN B PCLOSERS EVERYONE NEAR THAT PAGE
PAGPCL:	CMP #-1,B		;IS IT REALLY NULL?
	NBUGC EQ
	SAVE <A,B>
	MOV #-1,A		;BOGUS PUSH
	JSR PC,ITM2PL		;LOAD UP NOTHING
PAGPLP:	JSR PC,UPTLD		;LOAD A UPT
	MOV ITEM2,A		;THE SPHERE TO PC-LOSER
	BMI PAGL1		;FUPT
	JSR PC,SPRPCL		;PC-LOSER THAT SPHERE
PAGL2:	MOV UPTGIP(B),B		;GET NEXT UPT
	BEQ PAGDON		;NO MORE
	CMP B,(P)		;IS IT THE SAME AS THE FIRST
	BNE PAGPLP		;NO, PC-LOSER IT
PAGDON:	REST <B,A>
	JSR PC,ITM2PO		;POP THE SPHERE
PAGL3:	RTS PC
PAGL1:	MOV FUPTPR(B),A		;THE PROCESS THIS BELONGS TO
	BLE PAGL2		;NO ONE TRY NEXT UPT
	JSR PC,PRSPCL		;PCLOSER PROCESS
	BR PAGL2		;TRY NEXT UPT

;PCLOSER SPHERE ITEM IN A
SPRPCL:	SAVE A
	MOV #-1,A
	JSR PC,ITM0PL		;FOR A BOGUS PUSH
	MOV (P),A		;GET BACK POINTER TO SPHERE
	JSR PC,ITM1PL		;LOAD IT UP
	MOV SPHPRP(A),A		;POINTER TO THE CURRENT PROCESS
	JSR PC,ITM1PO		;POP SPHERE
	TST A			;ARE THERE ANY PROCESSES
	BEQ SPRPC2
SPRPC1:	JSR PC,PRSPCL		;PCLOSER PROCESS
	JSR PC,ITM0LD		;LOAD THE CURRENT PROCESS
	MOV PSPHCP(A),A		;POINTER TO NEXT PROCESS
	BNE SPRPC1		;THERE IS ANOTHER
SPRPC2:	JSR PC,ITM0PO		;POP THE BOGUS PUSH
	REST A
	RTS PC

;PCLOSER PROCESS ITEM IN A
PRSPCL:	CMP A,PRUNNG		;IS THIS THE CURRENT PROCESS
	BEQ PRSPC2		;YES, DONT PCLOSER YOURSELF
	JSR F,ACSAV
	JSR PC,ITM0PL		;LOAD THE PROCESS
	TST PSTOPC(A)		;IS IT STOPPED ALREADY
	BNE PRSPC1		;YES
	TST PSPC(A)		;IS IT IN SYSTEM
	BEQ PRSPC1		;NO
	BIS #PPCLSR,PFLAGS(A)	;SET BIT TO PCLOSER HIM
	JSR PC,PRSUNL		;UNLOCK HIS SWITCHES
PRSPC1:	JSR PC,ITM0PO		;POP PROCESS
	JSR F,ACRES
PRSPC2:	RTS PC

;CHECK IF OUR OWN PCLOSER BIT IS SET AND PCLOSER IF IT IS
PCLCHK:	SAVE A
	MOV ITM0A,A	;ASSUME WE ARE LOADED IN ITEM0
	BIT #PPCLSR,PFLAGS(A)	;IS IT ON?	
	BEQ PCLCH1	;NO, JUST RETRUN
	JSR PC,SFLUSH	;FLUSHING SHOULD CAUSE PCLOSERING TO HAPPEN
	JSR PC,RUNME	;ACTUALLY, HAPPENS ON THE RUNME
	BPT		;CAN'T GET HERE FROM THERE!
PCLCH1:	REST A
	RTS PC

PCLCLR:	SAVE A		;WANT TO CLEAR OUR OWN PCLOSER BIT
	MOV ITM0A,A	;ASSUME WE ARE LOADED IN 0
	BIC #PPCLSR,PFLAGS(A)	;CLEAR IT
	BR PCLCH1	;AND RETURN
;PUSH ITEM2 AND THEN FALL INTO LOAD A UPT
;GIP IS IN B
;RETURN CORE ADDRESS IN B

UPTPLD:	SAVE <A>
	MOV #-1,A		;MAKE IT NXM
	JSR PC,ITM2PL
	REST <A>
UPTLD:	TST B
	BUGC NE
	BIT #GIPSPR,B		;THIS BIT SET IN SPHERE UPT
	BNE UPTL.1
	BIC #GIPBIT,B		;GET FUPT ADDRESS
	RTS PC
UPTL.1:	SAVE <A>
	MOV B,A
	BIC #GIPITM,A		;GET THE ITEM NUMBER
	ASH #2,A		;CONVERT TO ITEM NUMBER
	JSR PC,ITM2LD		;LOAD THE SPHERE OVER THIS ITEM
	BIC #GIPUPT,B		;GET THE UPT NUMBER
	SWAB B
	ASH #-2,B		;GET THE UPT NO.
	MUL #UPTLEN,B
	ADD A,B
	ADD #SUPTS,B
	REST <A>
	RTS PC
	.SBTTL CLOCK AND PIRQ ROUTINES
;ENTERED BY AN INTERUPT FROM EITHER THE LINE CLOCK OR THE PROGRAMABLE
;CLOCK. HOPEFULLY, ONLY ONE OF THESE WILL BE ENABLED!
LCBRK:
PCBRK:	JSR F,ACSAV	;SAVE THE ACS
	JSR PC,SWCHEK
	INC TIME	;INCREASE TIME-SINCE-SYSTEM UP
	BNE .+6		;OVERFLOW?
	INC TIME+2	;YUP
	DEC HSECNT	;TIME TO INC HSECS?
	BGT PCBRK1
	INC HSECS
	MOV #30.,HSECNT
PCBRK1:
.IIF NZ NTKDIS,JSR PC,TKDCLK	;KEEP DISPLAYS GOING
.IIF NZ NTVS,JSR PC,TVTICK	;PROCESS TV CHARS
	BIT #1,TIME	;DO THIS ONLY EVERY OTHER TICK
	BNE .+6
	JSR PC,CLKTTY	;PROCESS CHARACTERS
	INC TUSED	;ONE MORE TICK FOR THIS USER
	DEC STIMER	;MAINTAIN TIMERS
	DEC LTIMER
	DEC JTMUUP	;TIME TO UPDATE THE JTMUS?
	BNE .+6		;NOT YET
	JSR PC,JTMUU	;GO UPDATE THEM
	DEC QUANT	;HAS THE CURRENT USER OVERSTAYED HIS WELCOME?
	BGT CLKRET	;NO, RETURN TO MAIN PROGRAM
	BIS #CLKPIR,PIRQ	;CAUSE THE STOP USER ROUTINE TO RUN
CLKRET:	JSR F,ACRES	;RESTORE THE ACS
	RTT

SWCHEK:	MOV CSWR,SVCSR	;IS SWITCH REGISTER ZERO?
	BNE .+6
	MOV PC,LOOKSW	;YES, SAY WE SHOULD LOOK AT SWITCHES
	TST LOOKSW	;SHOULD WE LOOK AT SWITCHES?
	BEQ SWCHE1	;NOPE
	BIT #100000,CSWR	;BPT SWITCH?
	BEQ .+4
	BPT
	BIT #1,CSWR	;INGNORE SWITCHES SWITCH
	BEQ .+6
	CLR LOOKSW
SWCHE1:	RTS PC
.IFNZ NTKDIS
TKDCLK:	MOV TKDPDL,A	;THE PDL ITEM
	JSR PC,ITM2PL	;LOAD IT UP
	MOV A,F		;SAVE POINTER INTO IT
	ADD #20,F	;MAKE IT POINT TO PDLS
	CLR A		;THE DISPLAY NUMBER
	CLR D		;THE DISPLAY*2
	MOV #8.,C	;THERE ARE 8 DISPLAYS
TKDCL1:	MOV TKDRUN(A),B	;IF RUNNING, WHICH DISPLAY I AM
	BLT TKDCL2	;NOT RUNNING
	MOV B,D
	SWAB B
	MOV B,NGCSR	;CHECK THAT DISPLAY
	BIT #TKRUN,NGCSR	;STILL RUNNING?
	BNE TKDCL2	;YUP
	ASL D
	BIC #17,F
	ADD D,F
	MOV TKDPDP(D),(F)	;RESTORE THE PDL POINTER
	BIS #TKGO,B	;BIS DOESN'T WORK ON NGCSR
	MOV B,NGCSR	;RESTART DISPLAY
TKDCL2:	TST (A)+
	SOB C,TKDCL1	;DO THEM ALL
	JSR PC,ITM2PO
	RTS PC
.ENDC

;THIS IS ENTERED BY THE PROGRAM INTERUPT REQUEST
;CURRENTLY IT IS ONLY USED FOR THE "CLOCK", BUT ITS DISPATCH
;TABLE COULD ACCOMADATE USES FOR OTHER LEVELS
PIRBRK:	SAVE A		;SAVE A REGISTER
	MOV PIRQ,A	;GET THE INTERUPT LEVEL
	BIC #177761,A	;USE AS AN INDEX TO DISPATCH
	BIC PIRBIT(A),PIRQ	;CLEAR THE RIGHT BIT
	ASH #4,A	;GET PRIORITY INTO RIGHT BITS
	MOVB A,PS	;SET PRIORITY OF PROCESSOR TO PRIORITY
			;LEVEL RESPONSABLE FOR THIS INTERUPT
	ASH #-4,A	;GET BACK FOR DISPATCHING
	JMP @PIRDIS(A)
PIRLOS:	BPT	;UNIMPLEMENTED LEVELS COME HERE
	BR .-2

	.SBTTL SCHEDULING ROUTINES
;THE SYSTEM'S MAIN LOOP
;ENTERED AT SCHED, NEVER EXITED
SCHED:	JSR PC,CHKACT	;CHECK FOR PROCESSES TO BE ACTIVATED
SCHED4:	MOV WINQ,A	;ANYBODY ON THE WINNERS QUEUE?
	BEQ SCHED1	;NOPE, TRY FOR THE LOSERS
	MOV WQUANT,QUANT	;GIVE HIM A WINNERS QUANTUM
	JSR PC,STPROC	;START HIM UP
	BR SCHED	;TRY FOR MORE WINNERS
SCHED1:	MOV #DORQ,A	;SEE IF ANY OF TH EDORMANT GUYS WANT TO WAKE UP
	JSR PC,CHKQ
	TST LTIMER	;TIME TO CHECK THE SLOW GUYS?
	BLT SCHED3	;YUP
	TST ACTQ	;ANYONE ACTIVE?
	BEQ SCHED3	;NO, GO CHECK THE SLOW GUYS ANYWAY
	JSR PC,RUNBPS	;RUN THE BEST PROCESS
	BR SCHED
SCHED3:	MOV #LTIMEL,LTIMER	;RESET THE TIMER
	MOV #IACTQ,A	;THE INACTIVE GUYS
	JSR PC,CHKQ	;TRY TO PUT THEM ON THE RUN QUEUE OR ACTQ
SCHED5:	MOV #RUNQ,A	;GUYS ON THE RUN QUE
	JSR PC,GLQTIM	;GET THE ONE ON FOR THE LARGEST TIME
	CMP #5*2,C	;IS IT > 5 SECS?
	BGT SCHED	;NO, HE STAYS THERE
	MOV #ACTQ,B	;HE GETS MOVED TO THE ACTIVE QUEUE
	JSR PC,PRSAOD	;ACTIVEATE HIM
	JSR PC,TQUEUE	;MOVE HIM
	BR SCHED5	;TRY FOR THE NEXT GUY WHO'S GOOD
;UPDATE JTMUS ON ALL QUEUES
JTMUU:	MOV #JTMUUT,JTMUUP	;RESTORE TIME TILL NEXT UPDATE
	MOV #FIRSTQ,A	;BEGGINING OF THE QUEUE POINTERS
	MOV #NQS,B	;NUMBER OF QUEUES THAT EXIST
JTMUU1:	MOV (A),C	;POINTER TO BEGGINING OF QUEUE
	BEQ JTMUU2	;NOBODY THERE!
JTMUU4:	MOV PRTJTM(C),F	;GET THE JTMU
	BEQ JTMUU3	;IT'S ALREADY ZERO, FORGET IT
	CLR E		;FOR THE DIVIDE
	DIV #JTMUDC,E	;FIND OUT HOW MUCH TO DECAY BY
	INC E		;MAKE SURE IT EVENTUALLY GETS TO ZERO
	SUB E,PRTJTM(C)	;DECAY IT
JTMUU3:	MOV (C),C	;GO DOWN THE LINK
	BNE JTMUU4	;MORE ON THIS QUEUE
JTMUU2:	ADD #QLEN,A	;GO TO NEXT QUEUE
	SOB B,JTMUU1	;GO THROUGH ALL QUEUES
	RTS PC

;RETURN THE LENGTH OF TIME THE PROCESS TABLE ENTRY POINTED
;TO BY A HAS BEEN ON IT'S CURRENT QUEUE
GQTIME:	MOV HSECS,C	;CURRENT TIME
	SUB PRTTIM(A),C	;TIME ON QUEUE
	RTS PC

;GET THE PROCESS THAT HAS BEEN ON THE Q IN A THE LONGEST TIME
;AND RETURN IT IN A, RETURN TIME ON Q IN C
;A AND C ARE ZERO IF NOT PROCESS ON Q
GLQTIM:	JSR F,ACSAV
	CLR D		;LONGEST TIME WE'VE FOUND
	MOV #GLQTM,F	;"FLAG"
	BR GQTIM

;SIMILAR TO GLQTIM, BUT FOR SHORTEST TIME
;C IS -1 IF NONE FOUN
GSQTIM:	JSR F,ACSAV
	MOV #-1,D	;SHORTEST TIME FOUND
	MOV #GSQTM,F	;"FLAG"
GQTIM:	CLR (P)		;SAVED A FOR RETURN
GQTIM1:	MOV (A),A	;NEXT ONE
	BEQ GQTIM2	;NO MORE
	JSR PC,GQTIME	;GET AMOUNT OF TIME ON QUEUE
	JSR PC,(F)	;DO COMPARE
	BHI GQTIM1	;NOT A RECORD SETTER
	MOV C,D		;NEW RECORD
	MOV A,(P)	;BY NEW PROCESS
	BR GQTIM1
GQTIM2:	MOV D,4(P)	;SET C FOR RETURN
	JSR F,ACRES
	RTS PC
GLQTM:	CMP D,C
	RTS PC
GSQTM:	CMP C,D
	RTS PC
;CHECK RUNNABILITY OF A PROCESS
;PROCESS TABLE ENTRY IN A
;MIGHT CLOBBER ALL REGISTERS
CHKPRS:	MOV PRTPPT(A),A	;GET THE ITEM
	JSR PC,ITM0LD
CHKPRL:	SAVE PSPC(A)	;GET THE PLACE TO CONTINUE IT AT
	BUGC NE		;MAKE SURE IT IS NON-ZERO
	MOV A,B
	MOV PSPHRP(A),A	;GET THE SPHERE
	JSR PC,ITM1LD
	MOV B,A		;RESTORE ITEM ADDRESS
	JSR PC,ITM2RS	;RETORE THE ITEM2 STACK
	MOV B,A
	ADD #PSREGS+14,A	;POINTER TO REGISTERS
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	RTS PC

;CHECK RUNNABLITY OF PROCESSES ON QUEUE IN A
;MAY CLOBBER ALL REGISTERS
CHKQ:	SAVE (A)
CHKQ1:	MOV (P),A	;GET THE NEXT IN LINE TO CHECK
	BEQ CHKQ2	;NO MORE
	MOV (A),(P)	;LINK THROUGH FOR NEXT TIME
	JSR PC,CHKPRS	;CHECK IT
	BR CHKQ1
CHKQ2:	REST A
	RTS PC

;PUT PROCESS ON THE WAKE-UP QUICK LIST
;CALL WITH ITEM IN A, PROCESS ID WORD 1 IN B, PROCESS ID WORD 2 IN C
;IF CAN'T PUT IT ON LIST, JUST RETURNS....
PRSWAK:	SAVE <PS,D>
	SPL 7		;DON'T INTERUPT ME
	MOV ACTFRE,D	;GET A FREE BLOCK
	BEQ PRSWA1	;THERE ARE NONE
	MOV (D),ACTFRE	;SPLICE IT OUT
	MOV A,ACTITM(D)	;THE ITEM
	MOV B,ACTPI1(D)	;PROCESS ID WORD 1
	MOV C,ACTPI2(D)	;PROCESS ID WORD 2
	MOV ACTLST,ACTLNK(D)	;LINK TH ENEW NODE
	MOV D,ACTLST	;TO THE FRONT OF THE LIST
PRSWA1:	REST <D,PS>	;RESTORE THE INT LEVEL AND D
	RTS PC

;CHECK THE RUNABILITY OF ALL PROCESSES ON THE ACTLST
CHKACT:	MOV PC,ACTCHK
	SPL 7		;SO THE LIST DOESN'T CHANGE
	MOV ACTLST,E	;GET THE FIRST GUY
	BEQ CHKAC1	;NOBODY HOME
	MOV (E),ACTLST	;SPLICE HIM OUT
	SPL 0		;OK NOW
	MOV ACTITM(E),A	;THE ITEM
	JSR PC,ITM0LD	;LOAD HIM UP
	CMPB #ITACCD,ITM0DR	;IS THIS STILL A GOOD ITEM?
	BNE CHKAC2	;NOPE, FORGET THIS LOSER
	CMP #ITPROC,(A)	;IS THIS THING I LOADED A PROCESS?
	BNE CHKAC2	;NO, CAN'T BE WHAT I WANT
	CMP ACTPI2(E),PRSID2(A)	;DO THE IDS MATCH?
	BNE CHKAC2	;NOPE
	BIT #RUNQB!STOPQB!WINQB!ACTQB,PQBIT(A)	;IS HE RUNNING OR STOPPED?
	BNE CHKAC2	;YUP
	SAVE E
	JSR PC,CHKPRL	;GO CHECK HIM OUT
	REST E
CHKAC2:	SPL 7
	MOV ACTFRE,(E)	
	MOV E,ACTFRE	;PUT IT ON THE FREE LIST
	BR CHKACT	;AND TRY AGAIN
CHKAC1:	SPL 0
	CLR ACTCHK
	RTS PC

;RUN THE BEST PROCESS ON THE RUN QUEUE
;CLOBBERS ALL REGISTERS
RUNBPS:	MOV ACTQ,A	;START OF GUYS TO RUN
	BNE RUNBP1	;SOME THERE FIND HIM
	WAIT		;TWIDDLE YOUR THUMBS
	RTS PC		;I GIVE UP!
RUNBP1:	SAVE <#-1,#77777,#-1,#-1,#77777,#-1>
RUNBP2:	MOV PRTUPT(A),B	;WHO IS THIS GUY'S USER?
	CMP 6(P),B	;SAME GUY WHO IS ALREADY BEST?
	BEQ RUNBP3	;YES, GO SEE IF THIS PROCESS IS BETTER
	MOV PRTPRI(B),E	;GET THE PRIORITY MULITPLE FOR THIS GUY
	BIC #177760,E	;MASK IT TO 4 BITS
	MUL PRTJTM(B),E	;GET THE NET PRIOTIRTY
	CMP E,10(P)	;HIGH PART > THAN OLD HIGH PART?
	BLO RUNBP4	;NO, THIS USER IS BETTER!
	BHI RUNBP6	;YES, THIS USER NOT AS GOOD
	CMP F,12(P)	;HIGH ORDER EQUAL, TRY LOW
	BHIS RUNBP6	;SAME OR WORSE
RUNBP4:	MOV B,6(P)	;THIS IS THE NEW BEST USER
	MOV E,10(P)	;AND HERE IS HIS PRIORITY
	MOV F,12(P)
	MOV PRTPRI(A),E	;NOW COMPUTE PRIORITY FOR THIS PROCESS
	BIC #177760,E
	MUL PRTJTM(A),E
RUNBP5:	MOV A,(P)	;THIS IS NOW THE BEST PROCESS
	MOV E,2(P)	;AND THIS IS IT'S PRIORITY
	MOV F,4(P)
RUNBP6:	MOV (A),A	;NEXT ONE ON THE QUEUE
	BNE RUNBP2	;GO SEE IF HE IS BETTER
	REST A		;THIS ONE IS BEST
	ADD #12,P	;FLUSH THE CRAP OFF THE STACK
	MOV PQUANT,QUANT	;HOW LONG TO RUN HIM FOR
	JMP STPROC	;GO TO IT (WILL RETURN TO CALLER OF RUNBPR)
RUNBP3:	MOV PRTPRI(A),E	;SAME USER, IS THIS PROCESS BETTER?
	BIC #177760,E
	MUL PRTJTM(A),E
	CMP E,2(P)	;IS THE HIGH PART BETTER?
	BLO RUNBP5	;YUP, HE'S NOW BEST
	BHI RUNBP6	;NOPE, OLD GUY IS BEST
	CMP F,4(P)	;SAME HIGH PARTS, WHAT ABOUT LOW?
	BHIS RUNBP6	;OLD GUY BEST
	BR RUNBP5	;NEW GUY BEST
	.SBTTL LOCK SWITCH ROUTINES
;GET A LOCKED SWITCH BLOCK AND STUFF THE TYPE AND ITEM INTO IT
;AND LINK IT INTO THE CURRENT PROCESS'S LOCKED LIST
;CALL WITH TYPE IN A, ITEM IN B
;PUTS ADDRESS OF BLOCK INTO A, CLOBBERS B
LOCKSW:	TST LCKFRE	;ARE THERE ANY FREE LOCKS?
	BNE LOCKS1	;YES, GO GOBBLE
LOCKS3:	BPT		;WE JUST RAN OUT OF LOCK BLOCKS!!!
			;NO GARENTEES IF YOU PROCEED FROM HERE, BUT IT WILL TRY
	JSR PC,SFLUSH	;WAIT A WHILE
	TST LCKFRE	;TRY AGAIN
	BNE LOCKS3	;NONE YET
	JSR PC,RUNME	;HOPEFULLY, WE CAN GET ONE NOW
	BR LOCKSW	;TRY AGAIN
LOCKS1:	SAVE A
	CLR A		;TO DO THE SILLY DIVIDE
	DIV #ITMTEL,A	;TO CONVERT INDEX TO NUMBER
	BIS A,(P)	;SET NUMBER INTO TYPE
	MOV LCKFRE,A	;GET THE FREE LOCK BLOCK
	MOV (A),LCKFRE	;SPLICE IT OUT
	REST LCKTIT(A)	;POP THE THING INTO THE TYPE AND ITEM
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	MOV PLCKSL(B),(A)	;PUT IT INTO LIST FOR THIS PROCESS
	MOV A,PLCKSL(B)
	MOV #-1,LCKWD1(A)	;LOCK NOT REALLY USED YET
	CLR LCKWD2(A)
	RTS PC

;CLEAR THE LOCKED SWITCH LIST
LSWCLR:	SAVE A
	MOV ITM0A,A
LSWCL2:	TST PLCKSL(A)	;ANY LOCKED
	BEQ LSWCL1	;NOPE, ALL POPED
	JSR PC,LSWPOP	;FLUSH ONE
	BR LSWCL2	;TRY AGAIN
LSWCL1:	REST A
	RTS PC
;LOCK A PARTICULAR SWITCH
;A HAS THE ADDRESS OF THE SWITCH, OR THE OFFSET INTO THE SPHERE
;B HAS THE BIT(S) WHICH ARE TO BE LOCKED
;C HAS THE ITEM NO THAT THE SWITCH IS IN  (OR 0 IF ABSOLUTE)
LCKASW:	TST INITSW	;NO SWITCHES LOCKED IN THE INIT CODE
	BNE LOCKA5
	SAVE <E,D,A,B>
	MOV A,E		;COPY THE OFFSET
	MOV #LONOFF,A	;THE TYPE OF LOCK
	MOV C,B		;THE ITEM NO. OF THE SPHERE
	JSR PC,LOCKSW	;GET A LOCK
	REST B
	MOV A,D		;SAVE POINTER TO THE LOCK
LOCKA2:	MOV C,A		;THE SPHERE NO. THAT THE SWITCH IS IN
	BEQ .+6		;NO ITEM
	JSR PC,ITM1PL	;LOAD IT UP
	ADD E,A	;MAKE A POINT TO THE SWITCH
	BIT B,(A)	;IS THE LOCK UNLOCKED?
	BEQ LOCKA1	;YES
LOCKA3:	TST C		;ANY ITEM PUSHES
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,SFLUSH	;TWIDDLE OUR THUMBS
	MOV C,A		;THE SPHERE NO.
	BEQ .+6		;ABSLOLUTE SWITCH
	JSR PC,ITM1PL	;LOAD IT UP
	ADD E,A	;MAKE A POINT TO THE SWITCH
	BIT B,(A)	;IS IT UNLOCKED YET
	BNE LOCKA3	;NOT YET
	TST C		;IS THE SWITCH IN AN ITEM
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,RUNME	;I THINK I HAVE GOT IT
	BR LOCKA2	;MAKE SURE
LOCKA1:	BIS B,(A)	;LOCK THE SWITCH
	TST C		;ANY ITEM PUSHED
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	REST A		;GET THE POINTER TO THE LOCK
	MOV A,LCKWD1(D)	;SAY THIS LOCK IS USED
	MOV B,LCKWD2(D)	;THE BITS LOCKED
	REST <D,E>	;GET ORIGINAL CONTENTS OF D
LOCKA5:	RTS PC
;POP THE TOP LOCK OFF THE LOCKED SWITCH LIST
LSWPOP:	TST INITSW	;ARE WE IN INIT CODE?
	BNE LSWPO2	;NO SWITCHES EVER LOCKED
	SAVE <A,B,C>
	MOV ITM0A,A	;ASSUME ITEM0 IS THE PROCESS WHICH IS UNLOCKING
	MOV PLCKSL(A),B	;SPLICE LOCK OUT OF IT'S LIST
	BUGC NE		;ONLY SHOULD GET CALLED IF ANYTHING IS LOCKED
	MOV (B),PLCKSL(A)
	MOV LCKFRE,(B)	;PUT IT ONTO THE FREE LIST
	MOV B,LCKFRE
	CMP #-1,LCKWD1(B)	;IS IT FOR REAL?
	BEQ LSWPOR+4	;NOPE, WE HAVE "UNLOCKED" IT
	SAVE B		;FOR THE ROUTINES WE CALL
	MOV LCKTIT(B),B	;GET THE TYPE
	MOV #-1,A	;MAKE ITEM NXM (FOR THE SAKE OF THE PUSH)
	JSR PC,ITM2PL
	SAVE B		;SAVE TYPE AND ITEM
	CLR A		;IN CASE THERE IS NO ITEM
	BIC #176000,B	;GET THE ITEM
	BEQ LSWPO1	;NOPE, NO ITEM
	MUL #ITMTEL,B	;CONVERT TO INDEX
	MOV B,A
	JSR PC,ITM2LD	;SAVE IT AWAY
LSWPO1:	REST <C,B>		;GET BACK FOR TYPE
	ASH #-9.,C
	BIC #177601,C	;MAKE IT INTO A 6 BIT INDEX
	JMP @LCKDIS(C)	;DISPATCH ON TYPE

LSPONF:	ADD LCKWD1(B),A	;POINT INTO ITEM IF THERE IS ONE
	BIC LCKWD2(B),(A)	;UNLOCK ON-OFF TYPE LOCK
LSWPOR:	JSR PC,ITM2PO	;POP THE ITEM STACK
	REST <C,B,A>
LSWPO2:	RTS PC
LSPERR:	BPT		;GASP! BAD LOCK TYPE
	BR .-2
LSPPCL:	TST BPCLSR	;IS HE BEING PCLSRED?
	BEQ LSWPOR	;IF NO, GO AWAY
LSPRTN:	JSR PC,@LCKWD1(B)	;BEING PCLSRED, RUN ROUTINE
	BR LSWPOR	;ALL DONE WITH THIS SWITCH
LSPDEC:	ADD LCKWD1(B),A	;GET ABSOULUTE ADDRESS
	DEC (A)		;FIXUP THE FLAG
	BNE LSWPOR	;IF NOT ZERO, ALL DONE
	TST LCKWD2(B)	;IS THERE A ROUTINE TO RUN ON ZERO FLAG?
	BEQ LSWPOR	;NO, FINISHED THEN
	JSR PC,@LCKWD2(B)	;CALL THE ROUTINE
	BR LSWPOR

LSPULN:	TST BPCLSR	;PCLOSERING ?
	BEQ LSWPOR	;NO, JUST POP
	MOV @LCKWD2(B),A	;GET THE CONTENTS OF FREE LIST POINTER
	MOV LCKWD1(B),@LCKWD2(B)	;POINT FREE LIST AT ENTRY TO BE FLUSHED
	MOV A,@LCKWD1(B)	;AND FLUSHED ENTRY AT REST OF LIST
	BR LSWPOR

;THE DELETE ON PCLOSERING ROUTINE, FOR THINGS THAT NEED ITEMS FLUSHED
PCLDLI:	MOV ITEM2,A
	JMP DLITEM	;THE LOADED ITEM IS GETTING FLUSHED

;POP A SWITCH WITHOUT DOING ANYTHING WITH IT
LSWFLS:	SAVE <A,B>
	MOV ITM0A,A	;POINT INTO PROCESS
	MOV PLCKSL(A),B	;GET FIRST SWITCH
	NBUGC EQ	;NO SWITCH?
	MOV (B),PLCKSL(A)	;FLUSH THIS ONE
	MOV LCKFRE,(B)	;RETURN THE NODE
	MOV B,LCKFRE	;TO THE FREE LIST
	REST <B,A>
	RTS PC
	.SBTTL TRAP AND FAULT ROUTINS
ILLBRK:	TSTB PS+1
	BNE ILLBR1
	BPT
	BR .-2
ILLBR1:	MOV #100000+.ILLTF,C
	BR CCFAUL

BEBRK:	TSTB PS+1	;DID IT COME FROM USER MODE?
	BNE BEBRK1	;YES
	BPT
	RTT
BEBRK1:	MOV #100000+.BETF,C	;BEBRK FAULT
	BR CCFAUL

IOTBRK:	TSTB PS+1	;DID IT COME FROM USER MODE
	BNE IOTBR1	;YES
	BPT
	RTT
IOTBR1:	MOV #100000+.IOTTF,C
	BR CCFAUL

FPPBRK:	MOV #100000+.FPPTF,C
	BR CCFAUL

PARBRK:	BPT
	RTT

BPTBRK:	TSTB PS+1	;FROM USER MOD
	BNE BPTBR1	;YES
	SAVE <RUGSTA,RUGVEC>	;SAVE THE STUFF FOR RUG
	RTI		;RETURN TO RUG
BPTBR1:	MOV #100000+.BPTTF,C	;SAY A BPT FAULT
CCFAUL:	MOV PC,USRMOD	;IN THE SYSTEM NOW
	JSR F,SPCPSP
	MOV C,PFAULT(A)	;THE TYPE OF FAULT
;FALLS IN TO THE NEXT PAGE
;FALLS IN FROM PREVIOUS PAGE
CFAULT:	SPL 0		;JUST IN CASE
	MOV STPSVP,P	;RESTORE STACK TO THE STATE IT WAS IN WHEN SHED CALLED US
	JSR F,SAVEPP	;SAVE THE USERS PDL POINTER
	TST (P)+	;CAUSE SAVEPP LEAVES IT THERE, THAT'S WHY!
	MOV PC,BPCLSR	;WE NEED TO PCLOSER HIM
	JSR PC,LSWCLR	;TO FLUSH WHAT EVER HE WAS DOING
	CLR BPCLSR
	TST LOOKSW
	BEQ CFAUL9	;IGNORE SWITCHES
	BIT #40000,CSWR
	BEQ CFAUL9
	BPT
CFAUL9:	MOV ITEM1,C	;THE SPHERE TO STOP
	CMP C,SYSSPR	;THE SYSTEM SPHERE?
	BNE .+4
	BPT		;YES, DIE
	JSR PC,SPRSTP	;STOP THE SPHERE
	MOV ITM1A,A	;THE SUPERIOR SPHERE
	BIS #FAULT1,SFLAG(A)	;SAY THERE IS A FAULT
	MOV SMSSPT(A),A	;GET THE SUPERIOR SPHERE
	JSR PC,ITM2LD	;LOAD IT UP
	SAVE #177	;THE FIRST CAPABILITY NO.
CFAUL2:	MOV (P),B	;GET THE CAPAIBLITY NO.
	JSR PC,GCLSTA
	BEQ CFAUL3	;COULDN'T GET IT
	ADD A,B		;POINT TO IT DIRECTLY
	CMPB (B),#.MSCAP	;IS IT MASTER SPHERE
	BNE CFAUL3	;NO
	CMP 2(B),ITEM1	;FOR THIS SPHERE
	BEQ CFAUL4	;YES
CFAUL3:	DEC (P)		;THE COUNTER
	BGE CFAUL2	;TRY THE NEXT ONE
	BPT		;COULDN'T FIND IT
	TST (P)+
CFAUL5:	MOV ITEM0,A	;PROCESS THAT FAULTED
	JSR PC,PSTPIN	;INCREMENT MY STOP WORD NOW, AND  PCLOSER MYSELF
	SAVE PC		;JUST FOR RANDOMNESS
	SAVE #STOPQ	;STOP YOURSELF
	JMP FLUSH	;LET THE PROCESS CREATED HANDLE IT
CFAUL4:	BIT #.SPFES,(B)	;CAN I CAUSE AN ENTER
	BNE CFAUL5	;NO, FORGET IT
	MOV 6(B),E	;THE ENTER ADDRESS	
	BIT #1,E	;DOES IT EXIST
	BNE CFAUL5	;NO
CFAUL6:	MOV ITEM2,C	;POINTER TO THE SUPERIOR SPHERE
	MOV #-1,B	;PUT IT ANYWHERE
	JSR PC,CRCLST	;CREATE A PACE FOR IT
	BCS CFAUL5	;C-LIST FULL FORGET IT
	ADD ITM2A,A	;POINT TO THE C-LIST ENTRY
	MOV #-1,(A)	;RESERVE IT
	MOV A,F		;SAVE THE POINTER
	MOV B,D		;SAVE THE CAPABILITY NO.
	MOV #LPCLRT,A	;INCASE OF PC-LOSER
	MOV ITEM2,B	;THE ITEM
	JSR PC,LOCKSW	;RELEASE THE SLOT
	MOV F,LCKWD2(A)	;POINT TO THE C-LIST SLOT
CFAUL7:	MOV F,A		;POINTER TO FIRST CAPABILITY
	MOV #.PRWRA!.PRCAP,(A)+	;CREATE A PROCESS CAPABILITY TO THE FAULTING PROCESS
	MOV ITEM0,(A)+	;SET IN THE PROCESS ITEM NO.
	MOV ITM0A,A
	INC PRSREF(A)
	JSR PC,CRPROC	;CREATE PROCESS
	BEQ CFAUL5	;FAILED
	JSR PC,ITM0PL	;LOAD IT UP
	DEC PRSREF(A)	;SINCE THERE WILL BE NO CAP TO IT, AND PUTPRS WILL INCREMENT IT
	BIC #PSUPSB,PSTOP(A)	;CLEAR THE BIT
	MOV E,PUPC(A)	;SET UP THE STARTING ADDRESS
	ADD #PUREGS,A	;POINT TO THE REGISTERS
	MOV D,(A)+	;PUT IN CAPABILITY TO THE FAULTING PROCESS INTO %0
	REST (A)	;PUT IN CAPABILITY OF MS CAPABILITY TO FAULTING SPHERE
	MOV ITEM0,A	;COPY THE ITEM NO. OF THE FAULT HANDLER
	MOV ITEM2,B	;THE SUPERIOR SPHERE
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THE SPHERE
	JSR PC,PSTPDC	;START IT
	JSR PC,ITM0PO	;POP THE ITEM
	JMP CFAUL5

;FIX THE FAULT FOR THE SPHERE IN B
FALTFX:	SAVE <A,C>	;SAVE SOME REGS.
	MOV B,A		;THE SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	BIT #FAULT1!FAULT2!FAULT3,SFLAG(A)	;IS THERE A FAULT
	BUGC NE		;JUST CHECKING
	BIC #FAULT1!FAULT2!FAULT3,SFLAG(A)	;SAY NO MORE FAULT
	MOV ITEM1,A	;GET THE SPHERE NO.
	JSR PC,ITM1PO	;POP  THE SPHERE
	JSR PC,SPRSTR	;START IT UP
	REST <C,A>	;CLEAN UP
	RTS PC

TRPBRK:	MOV #TRPBRV,A	;POINTER TO THE TRAP STUFF
	JSR PC,USRTRP	;CHECK OUT THE TRAP
	MOV ITM0A,A	;POINTER TO THE PROCESS
	TSTB PS+1	;IS IT FROM KERNEL MODE
	BEQ TRPBR1	;YES,
	MOV #100000+.TRPTF,PFAULT(A)	;FAULT TYPE FOR BAD TRAP
	JMP CFAULT	;JUST CAUSE THE FAULT
TRPBR1:	SUB #2,(P)	;POINT TO THE TRAP
	MOV (P),PERRAD(A)	;SAVE SYSTEM ADDRESS WHERE ERROR HAPPENED
	MFPI @(P)	;GET THE ACTUAL TRAP INSTRUCTION
	REST B		;GET BACK THE INSCTRUCTION
	MOV STPSVP,P	;RESTORE STACK TO THE STATE IT WAS IN WHEN SHED CALLED US
	CCC		;CLEAR THE CONDITION CODES
	SAVE PS		;SAVE A COPY OF THE PS TO MUNG
	BIT #TRPZBT,B	;ARE WE SUPPOSED TO SET THE Z BIT?
	BEQ .+6		;NO
	BIS #4,(P)	;SET IT
	BIT #TRPVBT,B	;ARE WE SUPPOSED TO SET THE V BIT?
	BEQ .+6		;NO
	BIS #2,(P)	;SET IT
	BIC #177400!TRPZBT!TRPVBT,B	;CLEAR BITS
	MOV B,PERRW(A)	;THAT'S THE ERROR TYPE
	MOV PC,BPCLSR	;FLUSH SWITCHES
	JSR PC,LSWCLR	;LIKE HE'S BEING PCLOSERED
	CLR BPCLSR
	JMP EMTRTP	;EMT RETURN SPECIAL ENTRY

;THIS ROUTINE EXPECTS A TO BE A POINTER TO THE TRAP VECTOR IN THE USERS CORE
;AND DECIDES IF IT IS A FAULT OR A TRAP THROUGH
USRTRP:	TSTB PS+1	;IS IT FROM KERNEL MODE
	BNE USRTR1	;NO
	RTS PC		;TEMPORARY FOR TRAP TO WORK
USRTR1:	MOV PC,USRMOD	;SAY WE ARE IN THE SYSTEM
	REST E		;THE CALLING ADDRESS	
	MOV A,B		;SAVE THE POINTER TO THE TRAP
	JSR F,SPCPSP	;SAVE HIS STUFF, AND F GETS USER P POINTER
	SUB #2,PUPC(A)	;DECREMENT IT TO THE CALL IF PCLOSERED
;HERE IF NOT TRAP THROUGH JUST RETURN BY JMP (E)
	MFPD -(F)	;GET THAT WORD
	MFPD -(F)	;GET THE PC WORD
	MFPI 2(B)	;ALL THIS TO PREVENT HANG BELOW
	MFPI (B)	;PROBABLY UNNECCESSARY
	ADD #10,P	;POP OFF THE EXTRA STUFF
	SAVE <PUPS(A),PUPC(A)>
	ADD #2,(P)	;MAKE IT LOOK LIKE REAL TRAP
	MTPD (F)+	;GIVE HIM THE PC
	MTPD (F)+	;AND THE PS
	SUB #4,F
	SAVE F		;THE NEW P
	MTPI P		;GIVE IT BACK
	MFPI 2(B)	;GET THE TRAP VECTOR STATUS
	BIC #340,(P)	;CLEAR THE PRIORITY BITS
	BIS #174000,(P)	;USER MODE, FOR SURE
	MFPI (B)	;AND THE ADDRESS	
	CLR USRMOD
	RTT		;RETURN
	.SBTTL EMT HANDLERS
;GET HERE WHEN A USER EXECUTES AN EMT
EMTBRK:	CMPB #60,PS+1	;MAKE SURE IT CAM FROM USER MODE
	BUGC EQ
	MOV PC,USRMOD	;NOW WE AREIN THE SYSTEM!
	JSR F,SPCPSP	;SAVE THE USER'S PC, PS AND PDL POINTER
	CLR PUPDLO(A)	;NOTHING POPED YET
	SUB #2,PUPC(A)	;POINT TO THE CALL ITSELF
	MFPI @PUPC(A)	;GET THE ACTUAL CALL
	REST B		;POP IT OFF THE STACK
	ASL B		;CONVERT IT TO A WORD INDEX
	BIC #177001,B	;8 BITS ARE SIGNIFICANT
	BIC #PFALTB,PFLAGS(A)	;SET THE TEMPORARY FAULT BIT 
	BIT #400,B	;IS THE FAULT ON FAIL BIT SET?
	BEQ .+10	;NO
	BIS #PFALTB,PFLAGS(A)	;SET THE TEMPORARY FAULT BIT 
	BIC #400,B	;CLEAR THE TOP BIT
	CMP #EMTHGH*2,B	;IS IT TOO HIGH?
	BLOS BADEMT	;YUP, TELL HIM HE IS A LOSER
	SAVE PS		;NOTE THAT TRACE TRAPS WILL ACT STRANGELY HERE
	BIC #357,(P)	;PRIORITY 0
	SAVE EMTDIS(B)	;DISPATCH ADDRESS
	RTT
BADEMT:	MOV ITM0A,A	;POINT TO THE PROCESS
	MOV #100000+.EMTTF,PFAULT(A)	;CAPABILITY FAULT
	JMP CFAULT

;RETURN FROM EMT TO USER
ENOOP:
EMTRET:	SAVE PS		;FOR THE CONDITION CODES
EMTRTP:	MOV ITM0A,A	;PROCESS HAD BETTER BE THERE
EMTRE1:
;THIS IS TEMPORARY INSTRUCTION
	JSR PC,LSWCLR
	TST PLCKSL(A)	;DOES HE HAVE ANY SWITCHES LOCKED?
	BUGC EQ		;NOPE
EMTRE2:
.IRPC X,<012>
	TST ITM'X'D
	BUGC EQ		;HAD ITEMS PUSHED
.ENDM
	BIT #4,(P)	;HAS THE CALL FAILED?
	BEQ EMTRE4	;BR IF NOT
	CLR PUPDLO(A)	;NOTHING GETS POPPED
	BIT #PFALTB!PFAILB,PFLAGS(A)	;SHOULD HE BE FAULTED
	BNE BADEMT	;YES, IT IS A BADEMT
EMTRE4:	BIC #PFALTB,PFLAGS(A)	;CERTAINLY NO LONGER A $ EMT
	CLR PSPC(A)	;NOT IN THE SYS ANYMORE
	MOVB PUPS+1(A),1(P)	;GO BACK TO USER MODE PROPERLY
	BIT #20,PUPS(A)	;RESTORE TRAP BIT IF WAS SET
	BEQ .+6
	BIS #20,(P)	;SET THE TRAP BIT
	SAVE PUP(A)	;GET HIS OLD P ONTO MY STACK
	ADD PUPDLO(A),(P)	;ANYTHING POPED FROM IT?
	MTPI P		;RESTORE P FOR HIM
	SAVE PUPC(A)	;PUT THE PC ON THE STACK NOW
	ADD #2,(P)	;START HIM AFTER THE CALL
	MOV A,B		;THE ITEM ADDRESS
	JSR PC,PACRES	;RESTORE HIS AC'S
EMTRE3:	SPL CLKL	;PREVENT A SCHEDULE
	CLR USRMOD	;THIS COULD CAUSE ONE
	TST QUANT	;HAS HE OVERSTAYED HIS WELCOME?
	BGE .+10	;NO
	BIS #CLKPIR,PIRQ	;GET HIM AFTER THE RTI
	RTI		;GO TO USER MODE
;PROCESS HACKING EMTS
;.FORK:
;1 ARGUMENT IS ADDRESS OF PLACE TO START NEW PROCESS
;CLEARS Z IF IT SUCEEDS IN CREATING A NEW PROCESS
EFORK:	MFPD @PUP(A)	;GET THE PLACE TO START IT
	MOV #2,PUPDLO(A)	;INDICATE THAT AN ARG SHOULD BE POPED
	JSR PC,CRPROC	;ATTEMPT TO CREATE A PROCESS
	BEQ EFORK1	;FAIL
	MOV CURSPH,B	;PUT IT INTO THE CURRENT PROCESS
	JSR PC,PUTPRS
	JSR PC,ITM0PL	;LOAD IT TEMPORARILLY
	DEC PRSREF(A)	;IT IS ONE TO LARGE (SHOULD BE ONLY ONE)
	BUGC GT
	REST PUPC(A)	;SET ITS PC
	BIC #PSUPSB,PSTOP(A)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO START IT
	ADD #PUREGS,A	;MAKE A POINT TO THE OLD REGISTERS
	BIS #4000,PS
	SAVE <F,E,D,C,B,A>
	BIC #4000,PS
	MOV #6,E	;THE NUMBER TO COPY
	REST (A)+
	SOB E,.-2
	JSR PC,ITM0PO	;POP ITEM STACK
ERETCZ:	CCC		;SUCESS
EFORK1:	JMP EMTRET

;.POOFF:
;NO ARGUMENT. MAKE THE PROCESS EXECUTING ITDISAPPEAR WITHOUT A TRACE
;CURRENTLY, THE PROCESS IS ONLY STOPPED
;IF THERE ARE ANY REFERENCES TO ITREMAINING
EPOOFF:	MOV ITEM0,B	;THE PROCESS ITEM
	JSR PC,SPRINC	;INCREMENT THE REFERENCE COUNT (SO IT DOESN'T DISAPPEAR
			;IN REMPRS)
	MOV ITM0A,A	;THE FOLLOWING IS ONLY DONE TO KEEP THINGS CONSISTENT
	JSR PC,PACSAV
	JSR PC,TIMEUS
	JSR PC,SAVAWB
	JSR PC,PDLSAV
	MOV ITM0A,A	;PROCESS POINTER
	JSR PC,REMPRS	;REMOVE IT FROM THE SPHERE IT IS IN
	MOV PRUNNG,A
	JSR PC,PSTPIN	;INCREMENT THE STOP COUNT
	JSR PC,DLPROC	;DECREMENT REFERENCE COUTN AND DELETE IF ZERO
	RTS PC		;HOPEFULLY, RETURN TO SCHEDULER
;.INVOKE:
;1 ARG IS CAPABILITY NUMBER TO INVOKE AND MAYBE FLAGS
;MORE ARGS MAY BE TAKEN IF CAPABILTY WANTS THEM
;BUT THERE MUST ALWAYS BE 3 THINGS ON THE STACK AND 3 THINGS WILL BE POPPED
EINVOK:	SUB #6,P	;CREATE 3 WORDS OF TEMP STORAGE FOR ARG
	JSR PC,RETNSW	;GET THE TOP OF THE STACK
	MOV A,(P)	;LOTS OF PEOPLE WILL WANT IT
	JSR PC,RETNSW	;GET 2ND ARG
	MOV A,2(P)	;SAVE IT
	JSR PC,RETNSW	;GET 3RD ARG
	MOV A,4(P)	;SAVE LAST ARG
	MOV ITM1A,A	;GET ADDRESS OF SPHERE
	MOV (P),B	;THE CAP NUMBER
	BIC #177400,B	;CLEAR WHATEVER IS THERE
	MOV B,E		;TO SAVE IT FOR LATER ROUTINES
	JSR PC,GCLSTA	;SEE IF IT IS THERE
	BEQ EIVOK1	;LOSER
	ADD B,A		;GET A REAL ADDRESS FOR CAP
	MOV (A),B	;THE FIRST WORD OF CAP
	BEQ EIVOK1	;NOTHING THERE
	CMP B,#-1
	BEQ EIVOK1
	ASL B		;TO A WORD ADDR
	BIC #177001,B	;FLUSH EXTRA BITS
	CMP B,#CAPHGH*2
	BUGC LT		;IF THE CAPABLITY IS TOO BIG
	MOVB 1(P),C	;THE FUNCTION
	BITB #200,C	;IS IT A GENERAL REQUEST
	BNE .+6
	JMP @IVKCTB(B)	;GO TO THE RIGHT ROUTINE
	ASL C		;TURN IT INTO A WORD INDEX
	BIC #177400,C	;CLEAR THE TOP BYTE
	CMP C,#GENHGH
	BLT EIVOK2	;TOO HIGH OF A FUNCTION
	ADD #6,P	;CLEAN UP STACK
	JMP BADEMT
EIVOK2:	JMP @GENDIS(C)	;GO TO THE GENERAL FUNCTION ROUTINE
EIVOK1:	ADD #6,P	;POP OFF THE THREE ARGS
ERETSZ:	CCC
	SEZ
	JMP EMTRET

DELCAP:	MOV CURSPH,C	;THE CURRENT SPHERE MUST BE PCLOSERED
;Z	JSR PC,SPRSTP	;STOP IT
;Z	MOV CURSPH,A	;AND AGAIN
;Z	JSR PC,SPRSTR	;AND START IT UP
	ADD #6,P	;POP OFF ALL THE ARGUMENTS
	JSR PC,@DELTAB(B)	;DELETE ROUTINE FOR THIS CAPABILITY
	JMP EMTRET	;RETURN WHATEVER FLAGS SET
CPYCAP:	MOV A,F
	MOV B,C		;FOR ROUTINES LATER
	TST (P)+	;ONLY WANT TWO ARGS
	ADD #CPYTAB,C
	JMP CPYCA1
GIVCAP:	TST (P)+	;FIRST ARG NO LONGER NEEDED
	MOV (A),C	;TYPE AND FLAGS OF CAP TO USE WHEN GIVING AWAY
	CMPB C,#.MSCAP	;IS IT A MASTER SPHERE CAPABILITY
	BEQ GVCAP1	;YES
	CMPB C,#.SPCAP	;IS IT SPHERE CAP.
	BEQ GVCAP1	;YEP
GVCAP2:	ADD #4,P	;POP OFF GARBAGE
	JMP BADEMT
GVCAP1:	BIT #.SPCAD,C	;DOES HE HAVE APPEND ACCESS
	BEQ GVCAP2	;NOPE, HE LOSES
	MOV (P),B	;THE SECOND ARG SPECIFIES WHAT TO GIVE AWAY
	BIC #177400,B	;GET THE GOOD BITS
	MOV B,E		;TO SAVE IT FOR LATER
	MOV A,C		;SAVE POINTER TO SPHERE OR MS CAP
	MOV ITM1A,A	;FIND IT IN THIS SPHERE
	JSR PC,GCLSTA	;FIND THE CAP.
	BEQ GIVLOS	;CAN'T FIND IT
	ADD A,B		;MAKE B POINT TO THE CAPABILITY
	MOV B,D		;FOR LATER DELETION
	MOV (B),F	;GET THE TYPE AND FLAGS
	BEQ GIVLOS	;THERE ISN'T A CAPABILITY THERE
	CMP #-1,F
	BEQ GIVLOS
	ASL F		;CHANGE IT TO A WORD INDEX
	BIC #177001,F	;CLEAR EXTRA BITS
	MOV 2(C),C	;GET THE SPHERE NO. THAT WE ARE GIVING TO
	JSR PC,SPRSTP	;STOP IT
	MOV C,B		;FOR THE LOCK ROUTINES
	MOV #LCKRTN,A	;RUN A ROUTINE IF UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START PROCESSES IF UNLOCKED
	MOV #-1,B	;BECAUSE LCKASW DOES A BIT
	MOV #SCLSLK,A	;C-LIST LOCK
	JSR PC,LCKASW	;LOCK AN ITEM'S SWITCH
	MOV C,A		;GET BACK THE SPHERE
	JSR PC,ITM2PL	;LOAD IT UP
	MOV PRUNNG,SCLSLK(A)	;PUT MY PROCESS NUMBER THERE
	JSR PC,ITM2PO	;POP IT AGAIN
	MOV 2(P),B	;WHERE TO PUT IT
	JSR PC,CRCLST	;CREATE A C-LIST ENTRY IN HIS C-LIST
	BCS GVCAP2	;C-LIST FULL
	BEQ GIVLOS	;DESTINATION OCCUPIED
	SAVE <C,B,A>
	MOV ITEM1,C	;THIS SPHERE
	JSR PC,SPRSTP	;STOP IT (EXCEPT FOR ME)
	MOV C,B		;THE ITEM FOR THE LOCKSW ROUTINES
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;LOCK THE SWITCH
	MOV #PCSPST,LCKWD1(A)	;START THE PROCESSES WHEN UNLOCKED
	MOV ITEM0,LCKWD2(A)	;START ALL THE PROCESSES, EXCEPT ME
	REST <A,B,C>
	JMP @GIVTAB(F)	;DISPATCH ON TYPE
GIVLOS:	ADD #4,P
	JMP ERETSZ

;THIS ROUTINE CALLS THE APPROPRIATE ROUTINE WITH INFO AS FOLLOWS
;A- POINTER TO CAP DEST.,C- SPHERE OF TAKEE, D-OFFSET OF TAKEE CAP.
;B-C LIST NO. OF DESTINATION,E-C LIST NO. OF TAKEE,F-DISPATCH TYPE
TAKCAP:	TST (P)+	;FIRST ARGUMENT NO LONGER NEEDED
	MOV (A),C	;TYPE AND FLAGS OF CAP. TO USE WHEN TAKING AWAY
	CMPB C,#.MSCAP	;MASTER SPHERE CAP.
	BEQ TKCAP1	;YES
	CMPB C,#.SPCAP	;SPHERE CAP.?
	BEQ TKCAP1	;YES
TKCAP2:	ADD #4,P	;POP OFF ARGS
	JMP BADEMT
TKCAP1:	BIT #.SPCLD,C	;CAN WE DELETE FROM THIS C-LIST
	BEQ TKCAP2	;NO!
	MOV (P),B	;WHAT WE ARE SUPPOSED TO TAKE AWAY
	BIC #177400,B	;GET THE GOOD BITS
	MOV B,E		;THE C-LIST NO. OF TAKEE
	MOV 2(A),A	;THE SPHERE NO. OF TAKEE
	MOV A,C		;SAVE IT FOR LATER
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,GCLSTA	;DOES THE CAP EXIST
	BEQ TAKLOS	;NOPE
	MOV B,D		;OFFSET OF TAKEE
	ADD A,B		;MAKE B POINT TO IT
	MOV (B),F	;CAPABILITY TYPE AND FLAGS
	BEQ TAKLOS	;DOESN'T EXIST
	CMP #-1,F
	BEQ TAKLOS
	JSR PC,ITM2PO	;DONE FOR NOW WITH THIS
	ASL F		;TURN TYPE INTO WORD INDEX
	BIC #177001,F	;CLEAR EXTRA BITS
	JSR PC,SPRSTP	;STOP THE SPHERE OF TAKEE
	MOV C,B		;FOR THE LOCK ROUTINE
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START THE SPHERE WHEN UNLOCKED
	MOV #-1,B	;BECAUSE LCKASW DOES A BIT
	MOV #SCLSLK,A	;LOCK THE SPHERES C-LIST
	JSR PC,LCKASW	;LOCK AN ITEM'S SWITCH
	MOV C,A		;GET THE SPHERE NO
	JSR PC,ITM2PL	;LOAD IT BACK UP
	MOV PRUNNG,SCLSLK(A)	;PUT MY ITEM NO. THERE
	JSR PC,ITM2PO	;POP IT AGAIN
	MOV 2(P),B	;THE DESTINATION IN TAKER
	SAVE C		;SAVE SPHERE OF TAKEE
	MOV ITEM1,C	;CREATE THE C-LIST ENTRY IN THIS SPHERE
	JSR PC,CRCLST	;CREATE AN ENTRY
	BCS TKCAP4	;C-LIST FULL
	BEQ TKCAP3	;C-LIST DESTINATION OCCUPIED
	ADD ITM1A,A	;MAKE A POINT ABSOLUTELY
	REST C		;SPHERE OF TAKEE
	JMP @TAKTAB(F)
TAKLOS:	JSR PC,ITM2PO
	BR TKCAP2
TKCAP3:	JMP EIVOK1
TKCAP4:	ADD #6,P
	JMP BADEMT

;.SINK
;DISABLES FLOATING POINT FOR THIS PROCEEDURE
;ALWAYS SUCCEEDS
ESINK:	MOV #PRSLNF,A		;SIZE OF A PROCESS WITHOUT FLOATING POINT AC'S
	MOV ITEM0,B		;THE ITEM INDEX OF THE PROCESS
	JSR PC,EXITEM		;SHRINK THE PROCESS IF NECESSARY
	MOV ITM0A,A		;THE ADDRESS OF THE ITEM
	BIC #PFPFLG,PFLAGS(A)	;CLEAR THE FLOATING  POINT FLAG IN PROCESS
	CLZ			;ALWAYS SUCCEEDS
	JMP EMTRET

;.FLOAT
;ENABLES FLOATING POINT FOR THIS PROCEDURE
EFLOAT:	MOV ITM0A,A
	BIT #PFPFLG,PFLAGS(A)
	BNE EFLOT2
	MOV #PRSLFP,A		;SIZE OF PROCESS WITH FLOATING POINT
	MOV ITEM0,B		;THE ITEM INDEX OF THE PROCESS
	JSR PC,EXITEM		;EXPAND THE PROCESS TO INCLUDE SPACE FOR FLOATING POINT AC'S
	BNE EFLOT1		;IT FAILED
	JMP EMTRET
EFLOT1:	MOV B,A
	JSR PC,ITM0LD		;LOAD THE NEW PROCESS
	MOV #40300,PFPPS(A)	;START HIM WITH INT. DISABLED AND IN DOUBLE AND LONG MODE
	BIS #PFPFLG,PFLAGS(A)
EFLOT2:	CLZ 
	JMP EMTRET

;MAKE THE PROCESS EXECUTING THIS CALL, A USER, AND GIVE THE PROCESS TO THAT USER
;TAKES 3 ARGS, IF FIRST IS NON ZERO, PUT THE NAME OF THE USER INTO THE CURUSR
;LENGTH OF NAME IS SECOND ARG
;POINTER TO NAME IS THIRD
ECRUSR:	CMP CURSPH,SYSSPR	;IS THIS THE SYSTEM SPHERE
	BEQ .+6			;NO, FAIL
ECRUS1:	JMP ERETSZ
	JSR PC,RETNSW		;GET THE SWITCH
	TST A
	BNE ECRUS2		;SET IN THE NAME
	JSR PC,CRUSER		;CREATE A USER
	BEQ ECRUS1		;FAILED
	MOV ITM0A,F		;GET ADDRESS OF THE PROCESS
	MOV PUP(F),E		;POINTER TO TOP OF PDL
	SAVE #-1		;PUSH A -1 ONTO USERS STACK
	MTPD (E)		;PUT THE WORD BACK
	MOV PPRTPT(F),F		;THE PROCESS TABLE POINTER
	MOV B,PRTUPT(F)		;SAY THE NEW USER IS THIS USER
	MOV B,CURUSR		;SAY IT TO EVERYONE
ECRUS2:	MOV CURUSR,B		;GET THE PROCESS TABLE ENTRY FOR USER
	MOV PRTPPT(B),A		;ITEM NO. OF THE USER
	JSR PC,ITM2LD		;LOAD IT UP
	JSR PC,RETNSW		;GET THE NAME
	MOV A,F			;SAVE COUNT
	BLE ECRUS1		;FAIL
	CMP F,#10.		;IS IT MORE THAN 10 CHARACTERS
	BLE .+6			;NO
	MOV #10.,F		;ONLY SAVE 10 CHARACTERS
	JSR PC,RETNSW		;GET POINTER TO NAME
	BIT #1,A		;DOES IT LAY ON BYTE BOUNDARY
	BNE ECRUS1		;YES, FAIL
	MOV F,E			;COPY COUNT
	ASR E			;GET WORD COUNT
	ADC E			;GET AN EXTRA WORD IF BYTE COUNT IS ODD
	MOV E,D			;SAVE IT
	MOV P,C			;SAVE POINTER TO P
	MFPD (A)+
	SOB E,.-2		;GET THE ENTIRE NAME
	BIT #1,F		;IS THERE ANOTHER BYTE
	BEQ .+6			;NO
	CLRB 1(P)		;CLEAR THE SPURIOUS BYTE
	MOV ITM2A,B		;POINTER TO USER ITEM
	ADD #USRNAM,B		;POINT TO THE FIRST BYTE OF NAME
	MOV C,E			;POINTER TO THE BYTES ON PDL
	MOV -(E),(B)+		;SET IN THE NAME
	SOB D,.-2		;GET ENTIRE NAME
	MOV C,P			;RESET PDL POINTER
	JMP ERETCZ		;SUCESS
;.TTGIV
;GIVE TTY AWAY, THE FIRST ARGUMENT IS A MASTER SPHERE CAPABILITY
;THE SECOND IS A TELETYPE CAPABILITY
ETTGIV:	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;THE MASTER SPHERE CAPABILITY
	BIC #177400,B	;CLEAR THE TOP BYTE
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE IN THE MAP
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T GET IT
	ADD B,A		;MAKE A POINT TO THE SPHERE CAP
	MOV (A),C	;THE TYPE AND FLAGS
	BEQ TTGIV1	;DOESN'T EXIST
	CMPB C,#.MSCAP	;IS IT A MASTER SPHERE CAP.
	BNE TTGIV1	;NOPE, CAN'T DO IT
	MOV 2(A),D	;THE SPHERE TO GIVE IT TO
	JSR PC,RETNSW	;GET THE SECOND ARG
	MOV A,B		;THE ARGUMENT
	BIC #177400,B	;CLEAR THE TOP BYTE
	MOV ITM1A,A
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE TTY CAP
	MOV (A),C	;TYPE AND FLAGS
	BEQ TTGIV1	;DOESN'T EXIST
	CMPB C,#.TTCAP	;IS IT A TTY CAPABILITY
	BNE TTGIV1	;NOPE
	MOV 2(A),A	;THE MASTER TTY ITEM NO.
	JSR PC,ITM2LD	;LOAD IT UP
	MOV ITM1A,B	;POINTER TO THE CURRENT SPHERE
	MOV CURSPH,C	;THE CURRETN SPHERE
TTGIV2:	CMP C,TTITM(A)	;IS THIS SPHERE THE OWNER OF THE TTY
	BEQ TTGIV4	;YES
TTGIV3:	JSR PC,LFLUSH	;WAIT FOR IT
	CMP C,TTITM(A)	;DO I OWN IT NOW?
	BNE TTGIV3	;NO
	JSR PC,RUNME	;TRY TO GET IT
	BR TTGIV2	;MAKE SURE
TTGIV4:	MOV TTYST1(A),STTFG1(B)	;STORE THE CURRENT TTY STATUS
	MOV TTYST2(A),STTFG2(B)	;STORE THE EXTRA STATUS WORD
	MOV D,SIFTTY(B)	;NEW INFERIOR SPHERE
	MOV D,A		;THE SPHERE WE ARE GIVING IT TO
	JSR PC,ITM1PL	;BOGUS PUSH
	MOV D,A
TTGIV5:	JSR PC,ITM1LD	;LOAD UP THE INFERIOR SPHERE
	MOV SIFTTY(A),A	;GET THE SPHERE IT GAVE THE TTY TO
	BNE TTGIV5	;HE GAVE IT AWAY
	MOV ITM2A,B	;POINTER TO THE TTY ITEM
	MOV ITM1A,A	;POINTER TO THE SPHER
	MOV CURUSR,TTYU(B)	;FIX USER POINTER
	MOV STTFG1(A),TTYST1(B)	;SET UP HIS STATUS
	MOV STTFG2(A),TTYST2(B)	;SET UP HIS OTHER STATUS WORD
	MOV ITEM1,TTITM(B)	;SET IN THE NEW OWNER
	JSR PC,ITM1PO	;GET RID OF HIM
	MOV CURSPH,A
	JSR PC,SPRPCL	;PCLOSER EVERY (EXCEPT ME)
	MOV ITM0A,A	;POINT TO ME
	BIC #PPCLSR,PFLAGS(A)	;CLEAR THE PCLOSER BIT
	JMP ERETCZ	;SUCCESS
TTGIV1:	JMP ERETSZ

;.TTGET
;GET THE TTY, THE ARGUMENT IS A TTY CAPABILITY
 ;HANGS UNTIL IT CAN GET THE TTY
ETTGET:	JSR PC,RETNSW	;GET THE CAPABILITY NO. OF A TTY CAP.
	MOV A,B		;GET THE TTY NO.
	BIC #177400,B	;CLEAR THE EXTRA BITS
TTGET1:	MOV ITM1A,A
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE CAPABILITY
	CMPB (A),#.TTCAP	;IS IT A TTY CAP
	BNE TTGIV1	;NO, HE IS A LOSER
	MOV 2(A),E	;GET THE TTY ITEM NO.
	MOV CURSPH,C	;THE CURRENT SPHERE
TTGET2:	MOV E,A		;THE TTY NUMBER
	JSR PC,ITM1PL	;LOAD THE TTY ITEM
	MOV TTITM(A),D	;THE CURRENT OWNER OF THE TTY
	MOV D,A
	CMP C,A		;DO I ALREADY OWN IT
	BEQ TTGET5	;YES, SUCCEED
TTGET3:	JSR PC,ITM1LD	;LOAD THE ITEM
	MOV SMSSPT(A),A	;THE MASTER OF THIS SPHERE
	CMP A,C		;IS ITS SUPERIOR THE REQUESTOR
	BEQ TTGET4	;SUCESS
	CMP SYSSPR,A	;ARE WE AT THE ROOT OF THE SPHERE STRUCTURE
	BNE TTGET3	;LINK THROUGH TO THE NEXT SPHERE
	JSR PC,ITM1PO	;CLEAN UP THE STACK
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	BR TTGET2	;TRY AGAIN
TTGET4:	MOV E,A		;THE TTY ITEM
	JSR PC,ITM2LD	;LOAD IT UP
	MOV A,B		;POINTER TO THE TTY ITEM
	MOV D,A		;THE SPHERE THAT CURRENTLY OWNS IT
	JSR PC,ITM1LD	;LOAD THE OWNER OF THE TTY
	MOV TTYST1(B),STTFG1(A)	;STORE THE FLAGS
	MOV TTYST2(B),STTFG2(A)	;STORE THE OTHER FLAGS
	MOV CURUSR,TTYU(B)	;SET THE USER
	MOV CURSPH,A	;THE NEW OWNER OF THE TTY
	MOV A,TTITM(B)	;NOW EVERYONE KNOWS
	JSR PC,ITM1LD	;LOAD THE NEW OWNER
	MOV STTFG1(A),TTYST1(B)	;SET IN THE OLD FLAGS
	MOV STTFG2(A),TTYST2(B)	;SET UP OTHER OLD FLAGS
	MOV D,A		;THE OLD OWNER
	JSR PC,SPRPCL	;AND HE GETS PCLOSERED
TTGET5:	JSR PC,ITM1PO	;THIS WAS PUSHED SOMEWHERE
	MOV ITM1A,A	;POINT TO THE SPHERE
	CLR SIFTTY(A)	;NO INFERIOR NOW
	JMP ERETCZ
;.SLEEP:
;1 ARG IS TOP 2 WORDS ON STACK (LOW ORDER IS TOP WORD)
;NEGATIVE=>NEGATIVE OF SYSTEM TIME TO CONTINUE
;POSITIVE=>NUMBER OF 60THS TO SLEEP
ESLEEP:	MOV PUP(A),B	;GET HIS PDL POINTER
	MFPD (B)	;GET TOP WORD
	MOV (P),C	;SAVE IT IN C
	MTPD (B)+	;MAKE SURE WE CAN WRITE IT
	MFPD (B)	;GET HIGH ORDER WORD
	MOV (P),D	;SAVE IT IN D
	MTPD (B)	;MAKE SURE WE CAN WRITE IT
	MOV #4,PUPDLO(A)	;POP 2 THINGS IF SUCESSFUL
	TST D		;IS IT NEGATIVE?
	BLT ESLEE1	;YES, GO SEE IF IT'S TIME YET
	NEG C		;NEGATE DOUBLE WORD NUMBER
	ADC D
	NEG D
	SUB TIME,C	;NOW COMPUTE NEGATIVE TIME TO WAKE UP
	SBC D
	SUB TIME+2,D
	SAVE D		;NOW CLOBBER USER'S THING TO NEGATTIVE
	MTPD (B)	;CLOBBER HIGH ORDER
	SAVE C
	MTPD -(B)
ESLEE1:	JSR PC,ESLEEC	;CHECK IF TIME IS UP
	BLT ESLEE4	;NOPE SLEEP SOME MORE
	JMP ERETCZ	;TIME IS UP, GO AWAY
ESLEE4:	CMP #-1,B	;IS IT A LONGE TIME TO WAIT?
	BNE ESLEE2	;YES, MORE THAN 2**16 TICKS
	CMP #-LTIMEL*4,A	;WELL, IS IT LONG?
	BGT ESLEE2	;YUP, MORE THAN 4 LONG WAITS
	JSR PC,SFLUSH	;NOT LONG
	BR ESLEE3	;NOW TRY AGAIN
ESLEE2:	JSR PC,LFLUSH	;LONG TIME TO WAIT
ESLEE3:	JSR PC,ESLEEC	;WELL, TIME UP NOW?
	BLT ESLEE4	;NOPE
	JSR PC,RUNME	;ALL DONE
	JMP ERETCZ	;GO RETURN TO USER
ESLEEC:	MOV C,A		;COPY TIME TO WAKE UP
	MOV D,B
	ADD TIME,A
	ADC B
	ADD TIME+2,B
	RTS PC

;RETURN THE SYSTEM STATUS BLOCK TO THE GUY AT THE PLACE HE PASES TO US
ESSTAT:	JSR PC,RETNSW	;GET THE ONE ARGUMENT
	MOV #SSTATS,B	;POINTER TO THE BLOCK WE GIVE HIM
	MOV #NSTATS,C	;AMOUNT OF STUFF TO GIVE HIM
ESSTA1:	MFPD (A)	;YEAH DEC!
	MOV (B)+,(P)	;WHAT I REALLY WANT TO DO
	MTPD (A)+	;IS GIVE IT TO HIM
	SOB C,ESSTA1
	JMP ERETCZ
;.QUNLK
;THE FIRST ARG IS THE CAPABILITY NO. OF THE QUE CAP
EQUNLK:	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;GET THE CAP. NO
	BIC #177400,B	;CLEAR THE SILLY BITS
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ UNLCK1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE CAPABILITY
	CMPB (A),#.QUCAP	;IS IT A QUE CAPABILITY
	BNE UNLCK1	;NO
	MOV 2(A),A	;THE ITEM NO OF THE QUE
	JSR PC,ITM2LD	;LOAD IT UP
	INC QUENUM(A)	;UNLOCK (FEATURE: IF NEVER LOCKED, INCREASES MAX LOCKS)
	JSR PC,QUECHK	;SHORT FLUSH FIRST GUY ON QUQUE
	JMP ERETCZ
UNLCK1:	JMP ERETSZ

QUECHK:	TST QUENUM(A)	;CAN ANYONE WIN?
	BNE .+4		;YES
QUECH1:	RTS PC		;NO
	TST QUECNT(A)	;IS ANYONE WAITING?
	BEQ QUECH1	;NO
	MOV QUEQUE(A),A	;GET THE FIRST GUY WHO CAN WIN
	JSR PC,ITM0PL	;LOAD HIM
	SAVE <B,C>
	MOV PRSID1(A),B	;ID WORD 1
	MOV PRSID2(A),C	;ID WORD 2
	MOV ITEM0,A	;THE ITEM
	JSR PC,PRSWAK	;SET IT TO WAKE UP
	JMP ITM0PO	;POP HIM OFF
;REMOVE THE GUY IN ITEM0 FROM THE QUE POINTED TO BY A
;IF HE HAS IT LOCKED, START SOMEONE ELSE, OTHERWISE JUST
;REMOVE HIM
PCQUNL:	SAVE A
	MOV QUECNT(A),F	;THE NUMBER OF PEOPLE ON THE QUE
	BEQ QUNLK7
	MOV F,A		;COPY THE COUNT
	MOV F,C		;COPY IT AGAIN
	ASL A		;TURN IT INTO A WORD INDEX
	ADD (P),A	;MAKE IT LESS RELATIVE
	ADD #QUEQUE,A	;MAKE A POINT TO THE START OF THE QUE
	MOV ITEM0,B	;THE PERSON TO LOOK FOR
QUNLK1:	CMP -(A),B	;IS HE HERE
	BEQ QUNLK2	;YES
	SOB C,QUNLK1	;TRY THE NEXT QUE ENTRY
QUNLK7:	REST A
	SEZ		;SAY HE WASN'T HERE
	RTS PC
QUNLK2:	SUB F,C		;THE NUMBER OF PEOPLE AFTER HIM
	NEG C		;MAKE THE COUNT POSITIVE
	SAVE C		;SAVE THE COUNT
	BEQ QUNLK4	;NOBODY AFTER HIM ON THE QUE
QUNLK3:	MOV 2(A),(A)+	;MOVE EVERYONE UP ONE SLOT ON THE QUE
	SOB C,QUNLK3
QUNLK4:	REST <C,A>
	DEC QUECNT(A)	;ONE LESS PERSON ON THE QUE
	JSR PC,QUECHK	
QUNLK6:	CLZ
	RTS PC
;.QULK,;THE FIRST ARG IS THE CAPABILITY NO OF THE QUE TO LOCK
EQULK:	JSR PC,RETNSW	;GET THE CAPABILITY NO
	MOV A,B
	BIC #177400,B	;CLEAR THE EXTRA BITS
	MOV ITM1A,A
	JSR PC,GCLSTA	;GET THE CAPABILITY
	BEQ UNLCK1	;FAILED
	ADD B,A		;MAKE A POINT TO THE CAP
	CMPB (A),#.QUCAP	;IS IT A QUE
	BNE UNLCK1	;NO
	MOV 2(A),A	;THE ITEM NO OF THE QUE
	JSR PC,ITM2LD	;LOAD IT
QULK5:	MOV QUECNT(A),C	;THE NUMBER OF PEOPLE ON THE QUE
	CMP C,QUEENO(A)	;IS THERE ROOM FOR ONE MORE
	BEQ QULK4	;NO, ENLARGE THE QUE
	INC QUECNT(A)	;ONE MORE PERSON ON THE QUE
	ASL C		;CHANGE IT INTO A WORD INDEX
	ADD A,C		;MAKE C POINT TO THE QUE ENTRY (ALMOST)
	MOV PRUNNG,QUEQUE(C)	;PUT HIM ON THE QUE
	MOV ITEM2,B	;THE Q ITEM
	MOV #LPCLRT,A	;RUN IF PCLOSERED
	JSR PC,LOCKSW	;LOCK IT
	MOV #PCQUNL,LCKWD1(A)	;FLUSH HIM FROM Q IF PCLOSERED
QULK9:	MOV ITM2A,A
	TST QUENUM(A)	;CAN I LOCK IT?
	BEQ QULK1	;NO, FULL
	CMP PRUNNG,QUEQUE(A)	;AM I FIRST?
	BNE QULK3	;NO, SOMEONE ELSE BEFORE ME
	DEC QUENUM(A)	;LOCK
	DEC QUECNT(A)	;ONE LESS WAITING
	BEQ QULK2	;NO ONE WAITING NOW
	MOV QUECNT(A),B
	MOV A,C
	ADD #QUEQUE,C
	MOV 2(C),(C)+	;COPY ME OUT OF WAITING LIST
	SOB B,.-4
QULK2:	JSR PC,LSWPOP	;FLUSH THE SWITCH
	JSR PC,QUECHK	;START ANYONE ELSE
	JMP ERETCZ
QULK3:	JSR PC,QUECHK
	MOV ITM2A,A
QULK1:	JSR PC,LFLUSH	;WAIT A LONG TIME
	TST QUENUM(A)	;CAN IT BE LOCKED?
	BEQ QULK1	;NOPE, WAIT
	JSR PC,RUNME	;GIVE IT A TRY
	BR QULK9
	;MAY JUMP TO NEXT PAGE
	;MAY BE JUMPED INTO FROM ABOVE
QULK4:	MOV QUEENO(A),A	;THE NUMBER OF ENTRIES IN THE QUE
	ASH #-6,A	;TURN IT INTO A ITEM SIZE
	INC A		;WE WANT TO MAKE IT ONE SIZE LOARGER
	MOV (P),B	;THE IUTEM NO FOR EXITEM
	JSR PC,EXITEM	;EXPAND THE QUE
	BNE QULK6	;SUCCEEDED
	JMP ERETSZ
QULK6:	ADD #32.,QUEENO(A)	;MADE IT 16. ENTRIES LARGER
	BR QULK5	;GO TRY TO LOCK IT

;.FONT CALL
;FIRST ARG IS FUNCTION,,FONT #
;SECOND ARG IS POINTER INTO USER CORE
;FUNCTION 0=> READ FONT INTO USER
;FUNCTION .PRWRT=> WRITE FONT FROM USER CORE
EFONT:	.IFZ NTVS
	JMP ERETSZ	;THERE HAD BETTER BE TV'S
.IFF
	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;SAVE IT
	BIC #177400,A	;GET THE FONT #
	CMP #NFONTS,A
	BGT .+6		;FONT NUMBER OK
	JMP EFNTL1	;BAD FONT NUMBER
	SAVE A		;SAVE THE FONT NUMBER
	JSR PC,RETNSW	;GET SECOND (USER ADDRESS)
	SAVE A
	BIT #.PRWRT*400,B	;WRITE TO USER OR FONT?
	BNE EFONT9	;GO TO WRITE THE FONT
	BIC #177400,B
	ASL B		;MAKE A WORD ADDRESS
	MOV FNTITM(B),A	;GET THE FONT ITEM NUMBER
	JSR PC,ITM2LD
;NOTE THAT IN CASE OF PCLOSERING, WE DO ALL THIS WORK AGAIN,
;BUT AT LEAST NO HARM IS DONE. BESIDES, IF THE FONT IS BEING
;READ INTO ONLY ONE PAGE, IT CAN ONLY LOSE THE FIRST TIME
;OF COURSE, IF THE USER BITES THE BAG, HIS POINTER DOESN'T POINT
;THE FACT OUT TO HIM.
	MOV FNTEND(A),C	;GET THE END POINTER FOR THE FONT
	BLE EFNTL	;CALL FAILS IF FONT NOT THERE
	REST B		;GET BACK THE USER'S ADDRESS
	ASR C		;FOR THE SOB
EFONT8:	MFPD (B)	;LET'S HEAR IT FOR DEC!
	MOV (A)+,(P)	;AND THE WORD JUST KEEP ON COMING!
	MTPD (B)+	;AND GOING
	SOB C,EFONT8	;LOTS OF TIMES
	TST (P)+
	JMP ERETCZ	;WIN


;THIS PART READS IN A FONT FROM USER
EFONT9:	ADD #FNWIDE,A	;SET THE POINTER TO THE WIDTH
	MFPD (A)+	;GET WIDTH
	REST C		;C WILL HOLD IT FOR A WHILE
	CMP #16.,C
	BLT EFNTL	;CAN'T HAVE A WIDTH OVER 16!
	MFPD (A)+	;HOW HIGH?
	REST E		;E WILL KEEP THAT FOR A MINUTE
	CMP #454.,E	;HIGHT OF SCREEN!
	BLT EFNTL	;DON'T BE SILLY
	MFPD (A)+	;END OF FONT (LENGTH IN BYTES)
	REST D		;KEEP IN D
	CMP #20000,D	;IS IT MORE THAN 4K?
	BLT EFNTL	;WELLL.....
	MFPD (A)+	;THE NUMBER OF TV LINES IN A CHAR LINE
	REST F
	CMP F,E		;THIS HAD BETTER BE GREATER OR EQUAL TO HEIGHT
	BLT EFNTL	;OTHERWISE CHARS WON'T FIT IN A LINE
	CMP F,#454.	;IT HAD ALSO BETTER BE LESS THAN OR EQUAL TO SCREEN SIZE
	BGT EFNTL	;STRANGE CHARACTERS..
	MOV D,F		;COPY THE BYTE COUNT OF THE FONT
	ASR F		;FOR THE SOB
	MOV (P),B	;GET BACK USER POINTER
EFONT1:	MFPD (B)+	;THIS LOOP PREVENTS US FROM
	TST (P)+	;GETTING SCREWED
	SOB F,EFONT1	;BY A PAGE NOT BEING IN CORE WHEN WE WANT IT
	MOV (P),B	;NOW WE WILL CHECK THE LEGALITY OF THE POINTERS
	ADD #FNTPNT,B	;POINT TO THE POINTER TABLE
	MOV #128.,F	;FOR THE SOB
EFONT2:	MFPD (B)+	;GET A POINTER
	TST (P)		;ZERO MEANS NO CHARATCER
	BEQ EFONT3	;WHICH IS FINE
	CMP #<FNTPNT+256.>,(P)	;DEFS START AFTER TABLE
	BGT EFNTL0	;UGH
	CMP D,(P)	;AND END AT (D)
	BLT EFNTL0
EFONT3:	TST (P)+	;YOU'RE OK, POINTER
	SOB F,EFONT2	;CHECK ALL 128. OF THEM
	MOV D,A		;LENGTH IN BYTES OF THE TABLE
	ASH #-6,A	;NUMBER OF BLOCKS FOR CRITEM
	JSR PC,CRITEM	;CREATE AN ITEM OF THE SIZE IN A
	BEQ EFNTL	;CAN'T CREATE AN ITEM
	MOV B,A		;CRITEM RETURNS THE INDEX IN B
	JSR PC,ITM2LD	;LOAD UP THE ITEM WE JUST CREATED
	REST C		;THE USER'S ADDRESS
	ASR D		;CONVERT TO WORD COUNT
EFONT4:	MFPD (C)+	;READ THE USER'S DATA
	REST (A)+	;A IS INITIALLY SET BY THE ITM2LD CALL
	SOB D,EFONT4	;KEEP MOVING UNTIL WE GET ALL OF HIS DATA
	MOV #454.,D	;THE NUMBER OF LINES ON A SCREEN
	CLR C		;FOR THE DIVIDE
	MOV ITM2A,A	;ADDRESS OF THE FONT ITEM
	DIV FNTLCL(A),C	;FIND HOW MANY LINES FIT ON A SCREEN
	CMP D,FNHIGH(A)	;THE LAST LINE DOES NOT NEED SEPARATOR SPACE
	BLT EFON10	;NOT ENOUGH ROOM FOR ANOTHER LINE
	INC C		;WE CAN FIT IN ONE MORE LINE
	SUB FNTLCL(A),D	;GET THE AMOUNT TO ADD TO NEXT LINE TO GET TO TOP
EFON10:	MOV C,FNLINE(A)	;THIS MANY LINES FIT ON A SCREEN
	SAVE C
	MOV D,C		;FOR THE MULTIPLY
	MUL #110,C	;COMPUTE THE NUMBER OF BYTES LEFT OVER AT THE BOTTOM OF SCREEN
	MOV D,FNREM(A)	;THIS NUMBER MAY BE NEGATIVE IF WE SQEEZED IN AN EXTRA LINE
	MOV FNTLCL(A),C	;THE NUMBER OF TV LINES IN ONE CHAR LINE
	MUL #110,C	;COMPUTE THE NUMBER OF BYTES IN ONE CHAR LINE
	MOV D,FLFINC(A)	;THIS IS THE LINE FEED INCREMENT	
	REST D		;THE NUMBER OF LINES ON SCREEN
	CLR C		;FOR THE DIVIDE
	DIV #5,C	;5 SEEMS TO GIVE GOOD RESULTS
	MOV C,FNLSC(A)	;THE NUMBER OF LINES TO SCROLL
	MOV #576.,D	;NUMBER OF BITS ON A LINE
	CLR C		;FOR THE DIVIDE
	DIV FNWIDE(A),C	;DIVIDE BY THE NUMBER OF BITS PER CHAR
	MOV C,FNLINL(A)	;GET THE NUMBER OF CHARS PER LINE
	REST C		;THE FONT NUMBER
	ASL C		;CONVERT TO WORD INDEX
	MOV FNTITM(C),A	;GET THE ITEM INDEX OF THE CURRENT FONT WITH THIS NUM
	MOV B,FNTITM(C)	;NOW THE NEW ITEM IT THIS FONT NUMBER
	TST A		;WAS ANYTHING THERE?
	BEQ EFONT5	;NO
	JSR PC,DLITEM	;DELETE THE OLD FONT
EFONT5:	JMP ERETCZ	;WIN
EFNTL0:	ADD #2,P	;POP SOME STUFF
EFNTL:	ADD #4,P	;POP GARBAGE OFF THE STACK
EFNTL1:	JMP ERETSZ	;LOSE
.ENDC

;THIS SYSTEM CALL ALLOWS CONTROL OF THE VIDEO SWITCH. BASICALLY,
;THE FIRST ARGUMENT SETS THE SOURCE IN VARIOUS MODES, AND THE
;SECOND ARGUMENT SETS THE DESTINATION IN SIMILAR MODES.  FOR
;BOTH SOURCE AND DESTINATION ARGUMENTS, THE GENERAL FORM IS
;A NUMBER IN THE LOW BYTE AND A MODE IN THE HIGH BYTE. THE SOURCE
;USUALLY MEANS THE BUFFER ASSOCIATED WITH THE TV IMPLIED BY THE
;THE MODE AND NUMBER EXCEPT ABSOLUTE GOES DIRECTLY TO THE SWITCH.
;THE MODES ARE:
;.VIABS  =>  JUST PUT THE NUMBER INTO THE APPROPRIATE PART OF SWITCH
;.VILOT  =>  THE NUMBER IS THE LOGICAL NUMBER OF A TTY
;             THE SAME NUMBER THAT IS USED IN THE CREATE INVOK.
;.VILOD  =>  THE NUMBER IS THE LOGICAL NUMBER OF A DISPLAY
;.VICAM  =>  THE NUMBER IS THE INDEX OF A CAPABILITY IN THE CALLER'S
;	      SPHERE, WHICH IS THE TTY OR DISPLAY TO SWITCH IN.
;
;IF THE CALL FAILS, IT IS GENERALLY BECAUSE THE NUMBER IN AN
;ARGUMENT IS INAPPROPRIATE FOR THE MODE, SUCH AS A LOGICAL
;TTY NUMBER THAT IS NOT A TV TTY, OR CAPABILITY THAT IS NOT
;THE APPROPRIATE TYPE ETC.
.IFNZ NTVS
EVIDSW:	JSR PC,RETNSW		;GET THE FIRST ARGUMENT, THE SOURCE
	MOV A,C			;THE VALUE IS RETURNED IN A
	JSR PC,RETNSW		;GET THE SECOND ARG, THE DESTINATION
	MOV A,D			;SAVE VALUE IN D
	SWAB A			;GET DESTINATION MODE IN LOW BYTE
	BIC #177600,D		;ISOLATE THE DESTINATION NUMBER
	CMPB A,#.VICAM		;IS IT CAPABILITY MODE
	BNE EVIDS2		;NO
	MOV D,B			;THE DESTINATION NUMBER IS CAPABILITY INDEX
	MOV ITM1A,A		;ADDRESS OF THE SPHERE ITEM
	JSR PC,GCLSTA		;GET THE OFFSET OF THE CAPABILITY INTO SPHERE
	BEQ EVID15		;ERROR, BAD CAPABILITY NUMBER
	ADD A,B			;CONVERT OFFSET TO ABSOLUTE ADDRESS
	CMPB (B),#.TTCAP	;IS DESTINATION A TTY?
	BNE EVIDS1		;NO
	MOV CLSEPI(B),A		;THE TTY ITEM
	JSR PC,ITM2LD		;LOAD IT UP
	MOV TTLTTY(A),D		;THE LOGICAL TTY NUMBER - WORD OFFSET VERSION
	ASR D			;CONVERT WORD OFFSET VERSION TO NUMBER
	BR EVIDS3		;CONTINUE LIKE LOGICAL TTY NUMBER
EVIDS1:	CMPB (B),#.DSCAP	;IS DESTINATION A DISPLAY?
	BNE EVID15		;NO, BAD CAPABILITY TYPE ERROR
	MOV CLSEM0(B),A		;THE LOGICAL DISPLAY NUMBER - WORD OFFSET
	ASR A			;CONVERT WORD OFFSET VERSION TO NUMBER
	BR EVIDS5		;NOW CONTINUE LIKE LOGICAL DISPLAY NUMBER
EVIDS2:	CMPB A,#.VILOT		;IS MODE LOGICAL TTY NUMBER MODE
	BNE EVIDS4		;NO
EVIDS3:	SUB #NFTV/2,D		;CONVERT TO PHYSICAL TV NUMBER
	BLT EVID15		;ERROR, THIS TTY IS NOT A TV TTY
	CMP D,#NTVS		;MAKE SURE ITS A VALIDE TV NUMBER
	BGE EVID15		;NO, BAD TTY NUMBER ERROR
	ASL D			;GET WORD OFFSET
	MOV TVMAP(D),D		;ARRANGE TO GET THE CORRECT MONITOR
	BR EVIDS7		;NOW PROCESS THE SOURCE ARGUMENT
EVIDS4:	CMPB A,#.VILOD		;IS MODE LOGICAL DISPLAY NUMBER MODE
	BNE EVIDS6		;NO
EVIDS5:	SUB #NFTVDS,D		;GET PHYSICAL TV NUMBER
	BLT EVID15		;BAD DISPLAY TYPE, MUST BE A TK DISPLAY
	CMP D,#NTVS		;MAKE SURE THIS NUMBER IS LEGAL
	BGE EVID15		;ERROR, BAD DISPLAY NUMBER
	ASL D			;GET WORD OFFSET
	MOV TVMAP(D),D		;ARRANGE TO GET RIGHT MONITOR
	BR EVIDS7		;NOW PROCESS THE SOURCE ARGUMENT
EVIDS6:	CMPB A,#.VIABS		;ABSOLUTE MODE?
	BNE EVID15		;NO, THERE ARE NO MORE LEGAL MODES SO ERROR
EVIDS7:	MOV C,A			;GET SOURCE MODE
	SWAB A			;GET MODE IN LOW BYTE
	BIC #177600,C		;ISOLATE THE SOURCE NUMBER
	CMPB A,#.VICAM		;CAPABILITY MODE?
	BNE EVIDS9		;NO
	MOV C,B			;THE CAPABILITY NUMBER
	MOV ITM1A,A		;SPHERE ITEM ADDRESS
	JSR PC,GCLSTA		;GET THE OFFSET INTO THE SPHERE OF CAPABILITY
	BEQ EVID15		;BAD CAPABILITY NUMBER ERROR
	ADD A,B			;GET THE ABSOLUTE ADDRESS OF CAPABILITY
	CMPB (B),#.DSCAP	;IS IT A DISPLAY CAPABILITY?
	BNE EVIDS8		;NO
	MOV CLSEM0(B),C		;GET LOGICAL DISPLAY NUMBER
	ASR C			;CONVERT FROM WORD OFFSET VERSION TO NUMBER
	BR EVID10		;CONTINUE AS LOGICAL DISPLAY NUMBER
EVIDS8:	CMPB (B),#.TTCAP	;IS CAPABILITY A TTY CAP?
	BNE EVID15		;BAD CAPABILITY TYPE ERROR
	MOV CLSEPI(B),A		;GET THE TTY ITEM
	BR EVID12		;GET THE BUFFER ASSOCIATED WITH THIS TTY
EVIDS9:	CMPB A,#.VILOD		;IS SOURCE MODE LOGICAL DISPLAY?
	BNE EVID11		;NO
EVID10:	SUB #NFTVDS,C		;MAKE SURE IT'S A TV DISPLAY
	BLT EVID15		;ERROR, MUST BE A TK DISPLAY
	CMP C,#NTVS		;MAKE SURE IT'S A VALID TV NUMBER
	BGE EVID15		;ERROR, IT'S NOT
	MOV TVDSBF(C),C		;GET THE BUFFER ASSIGNED TO THIS DISPLAY
	BLT EVID15		;NO BUFFER ASSIGNED TO THIS DISPLAY
	BR EVID14		;SWITCH IN THE NUMBERS
EVID11:	CMPB A,#.VILOT		;IS SOURCE LOGICAL TTY NUMBER MODE?
	BNE EVID13		;NO
	CMP C,#NTTYS		;IS THIS A VALID TTY NUMBER?
	BGE EVID15		;NO, ERROR
	TST C			;MAKE ABSOLUTELY SURE
	BLT EVID15		;AHA! IT'S NEGATIVE, THEREFOR ERROR
	ASL C			;CONVERT TO WORD OFFSET
	MOV TTYITM(C),A		;GET THE ITEM FOR THIS TTY
	BLE EVID15		;THIS TTY HAS NO ITEM
EVID12:	JSR PC,ITM2LD		;LOAD IT UP
	MOV TVBUF(A),C		;GET THE BUFFER NUMBER FOR THIS TTY
	BLT EVID15		;ERROR, NO BUFFER ATTACHED TO THIS TTY
	BR EVID14		;GO AHEAD AND SWITCH IN THE ARGUMENTS
EVID13:	CMPB A,#.VIABS		;IS IT ABSOLUTE MODE?
	BNE EVID15		;NO MORE MODES, THUS ERROR
EVID14:	SWAB D			;DESTINATION GOES IN HIGH BYTE
	BIS D,C			;SOURCE IN LOW BYTE
	MOV C,VIDSW		;SWITCH IT
	JMP ERETCZ		;THAT'S ALL FOLKS.
EVID15: JMP ERETSZ		;SOMETHING WENT WRONG
.IFF
EVIDSW:	JMP ERETSZ		;CAN'T SWITCH 'EM IF YOU DON'T HAVE 'EM
.ENDC

	.SBTTL INVOKE CAPABILITY ROUTINES
CAPRXX:	BPT	;THE ZERO CAPABILITY
CAPRCC:	TST (P)+	;ONLY WANT TWO ARGS
	ASL C		;THE CAPABILITY TYPE TO CREATE
	CMP C,#CAPHGH	;IS HE ASKING FOR A NON-EXISTANT TYPE?
	BGE CAPRC1	;LOSER!
	ADD #CCTAB,C
CPYCA1:	MOV E,D	;CAP NUMBER
	MOV 2(P),B	;CAP DESTINATION
	MOV (P)+,(P)	;SECOND ARG
	SAVE <C>	;ADDRESS OF ROUTINE
	MOV ITEM1,C
	JSR PC,CRCLST
	BEQ CAPRC4	;THE C-LIST ENTRY WAS USED
	BCS CAPRC1	;FULL C-LIST
	ADD ITM1A,A	;MAKE A POINT ABSOLUTELY TO ENTRY
	REST <C,E>	;ROUTINE ADDRESS AND SECOND ARG
	SAVE <B,A>
	MOV #-1,(A)+	;SAVE THIS SPACE
	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)+
	MOV #LPCLRT,A
	MOV ITEM1,B
	JSR PC,LOCKSW
	MOV (P),LCKWD2(A)
	MOV #CAPRC5,LCKWD1(A)
	MOV C,A		;ROUTINE ADDRESS
	CLR C
	JSR PC,@(A)
;THE ROUTINE WE CALL IS EXPECTED TO RETURN:
;IN A THE CAP TYPE AND FLAGS
;IN B THE PRIMARY ITEM 
;THE SECONDARY ITEM IS NEVER RETURNED
;IN C THE FIRST MISC WORD
;THE SECOND MISC WORD IS NEVER RETURNED
;THE ROUTINE SHOULD SET Z IF IT FAILS, OTHERWISE CLEAR IT
	BEQ CAPRC3	;FAILURE
	REST F
	MOV A,(F)+	;THE TYPE AND FLAGS
	MOV B,(F)+	;THE PRIMARY ITEM
	TST (F)+	;NO SECONDARY ITEM
	MOV C,(F)+	;THE 1ST MISC WORD
	REST <B>
	JSR PC,GIVPSW
	JMP ERETCZ	;SUCESS
CAPRC1:	CMP (P)+,(P)+
CAPRC2:	JMP BADEMT
CAPRC3:	CLR @(P)	;FREE CAP SLOT
CAPRC4:	REST <A,B>
	JMP ERETSZ	;FAIL
CAPRC5:	MOV LCKWD2(B),B
	CLR (B)		;RELEASE CAP SPACE
	RTS PC
	.SBTTL START THE WORLD ROUTINE
GO:	RESET
	MOV #PDL,P	;SET UP THE PDL
	MOV #RUGVEC,A	;POINTER TO VECTOR STORAGE
	MOV #BPTBRV,B	;THE VECOTR
	MOV (B),(A)+	;THE STUFF
	MOV #BPTBRK,(B)+	;SET UP OUR VECTOR
	MOV (B),(A)+	;STORE STATUS
	MOV #340,(B)+	;SET UP INFINITE PRIORITY
	JSR PC,PARIN	;INITIALIZE THE PARITY STUFF
	JSR PC,TYINIT	;INITIALIZE THE TTY'S
	JSR PC,MAPSET	;SET UP THE INTIAL MAP
	JSR PC,INITTB	;LINK UP LISTS
	JSR PC,MEMTST	;SET UP MEMORY TABLES
	JSR PC,CLKIN	;START UP THE CLOCK
;FALL THROUGH TO NEXT PAGE TO START UP THE SYSTEM PROCESS, ETC.
;FALLS IN FROM PREVIOUS PAGE
;START UP THE SYSTEM PROCESS
	JSR PC,CRUSER	;CREATE A USER
	MOV B,CURUSR	;HE IS THE CURRENT USER
	MOV #2,PRTPRI(B)	;INCREASE HIS PRITORITY
	JSR PC,CRSPHR	;CREATE A SPHERE FOR HIM
	MOV A,SYSSPR	;THE SYSTEM SHPERE
	MOV A,C		;SAVE THE SPHERE ITEM#
	JSR PC,CRPROC	;CREATE A PROCESS
	MOV C,B		;PUT THE SPHERE ITEM IN THE RIGHT PLACE
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THE SPHERE
	MOV A,D		;SAVE THE PROCESS ITEM
	JSR PC,ITM0LD	;MAKE PROCESS ITEM 0
	MOV A,C		;SAVE ADDRESS
	MOV B,A		;GET SPHERE ITEM #
	JSR PC,ITM1LD	;MAKE SPHERE ITEM1
	ADD #SUPTS,A	;GET A POINTER TO THE UPTS
	MOV #20,D	;THERE ARE 20 PAGES
	CLR E		;WE WILL SET UP MAP TO ABS CORE FOR THIS SPHERE
SYSJI1:	MOV #UPTABS,(A)+	;AN ABSOLUTE PAGE
	MOV E,(A)+	;THE AR
	MOV #77406,(A)+	;THE DR
	ADD #200,E	;GO TO NEXT PAGE
	BIC #176000,E	;FOR THE OVERFLOW INTO I SPACE
	SOB D,SYSJI1	;DO FOR 20 PAGES
	CLR B		;CAPABILITY ZERO
	JSR PC,AGCLAD	;GO GET THE ADDRESS
	MOV #.CCCAP,(A)	;A CREATE CAPABILITY CAPABILITY
	MOV #1,B	;CAPABILITY ONE
	JSR PC,AGCLAD	;GO GET THE ADDRESS
	MOV #.MSCAP,(A)	;MAKE IT A MASTER SPHERE CAPABILITY TO ITSELF (!!!!)
	BIS #MSPCBT!.SPFES,(A)+	;EVERYTHING AND NO ENTERS
	MOV SYSSPR,(A)	;THSI IS IT
	MOV #30.,E	;THE NUMBER OF SLOTS OF USERS TO TRY TO START
	SAVE C		;SO THAT IT DOESN'T GET CLOBBERED
	JSR PC,CCPRCL	;CREATE A CORE LINK
	REST C
	MOV B,TTYCL	;SET UP POINTER TO THE CORE LINK FOR TTY ROUTINES
	MOV #2,B	;THE CAPABILITY 2
	JSR PC,AGCLAD	;GET THE ADDRESS
	MOV #.CLCAP!.CLCONS,(A)+	;SET IN THE FLAGS
	MOV TTYCL,B	;GET THE POINTER TO IT
	MOV B,(A)+	;SET IT IN
	MOV B,A		;GET IT
	JSR PC,ITM2LD	;LOAD IT
	MOV ITEM0,CLCONP(A)	;SET IN CONSUMER POINTER
	MOV #SYSJOB,PUPC(C)	;SET THE THINGS PROGRAM COUNTER
	MOV #SYSJPD,PUP(C)	;AND ITS PDL POINTER
	BIC #PSUPSB,PSTOP(C)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO DECREMENT THE STOP COUNT AND PUT ON RUN Q
	MOV #5*2,HSECS	;THE WORLD STARTS 5 SECONDS AGO (RUN THAT BY AGAIN???)
	CLR INITSW	;EXITING INIT CODE
	JMP SCHED	;GO GO GO!
;INITIALIZE THE CLOCK THAT EXISTS TO TICK AT 60. HZ
CLKIN:	SAVE BEBRV	;FIND OUT WHICH CLOCK WE HAVE
	MOV #CLKIN1,BEBRV	;GO TO GOPC FOR PROGRAMMABLE CLOCK
	MOV #100,LCCS	;TRY TO START THE LINE CLOCK
	BR CLKIN2		;WON'T GET HERE IF UNSUCESSFUL
CLKIN1:	SPL 0		;IN CASE SET BY THE BREAK
	CMP (P)+,(P)+	;FLUSH SAVED THINGS
	MOV #1666.,PCCB	;WE HAD BETTER HAVE A PROGRAMMABLE CLOCK!
	MOV #111,PCCS	;LINE FEQUENCY, REPEAT INT, ETC.
CLKIN2:	REST BEBRV	;WE HAVE SET UP THE CLOCK
	RTS PC

;INIT THE TABLES AND HARDWARE REGISTERS ASSOCIATED WITH PARITY
PARIN:	SAVE BEBRV	;TO TRAP NON-EX PARITY REGISTERS
	MOV #PARIN1,BEBRV
	MOV #PARREG,A	;POINT TO THE BEGINING OF THE TABLE
	MOV #PARCSR,B	;POINT TO THE BEGGINING OF THE HARWARE REGISTERS
	MOV B,C
	MOV #20,D	;THERE MAY BE AS MANY AS 16. OF THEM
PARRCK:	MOV #1,(B)+	;ENABLE THE PARITY CHECKING
	MOV C,(A)+	;SKIPPED IF REG NOT THERE
PARIN2:	ADD #2,C	;UPDATE THE POINTER TO THE REGISTER THAT IS STORED AWAY
	SOB D,PARRCK
	REST BEBRV
	RTS PC
PARIN1:	CMP (P)+,(P)+	;CLEAR CRAP OFF STACK
	SPL 0
	BR PARIN2
;INITIALIZE VARIOUS TABLES
INITTB:	MOV #INITLS,A	;THINGS TO LINK INTO FREE LISTS
INTLST:	MOV (A)+,B	;GET THE TABLE ADDRESS
	BEQ INTLS1	;DONE WITH THESE THINGS
	MOV (A)+,C	;GET THE ADDRESS OF THE FREE POINTER
	MOV (A)+,D	;GET THE NUMBER OF THINGS
	MOV (A)+,E	;GET THE LENGTH OF THEM
	MOV B,(C)	;SET UP THE FREE POINTER
	MOV B,C		;COPY POINTER INTO TABLE
INTLS2:	ADD E,C		;POINTER TO NEXT ONE
	MOV C,(B)	;GET PUT INTO THIS ONE
	ADD E,B		;GO TO NEXT ONE
	SOB D,INTLS2	;HOWEVER MANY TIMES
	BR INTLST
INTLS1:	MOV #INITM1,A	;STUFF TO MAKE -1
INTM11:	MOV #-1,(A)+
	CMP #EINTM1,A
	BNE INTM11
	MOV #ITMBIT,A	;THE BIT TABLE POINTERS
	MOV #ITMBTP,B
	MOV #NITMBL,C
INTBT1:	MOV A,(B)+	;POINTER TO A BIT TABLE
	ADD #22,A	;FURTHER ON
	SOB C,INTBT1	;FOR SO MANY BIT TABLES
	RTS PC

SYSJOB:	SAVE <#10,#MFITST,#.FACAP*400>
	$INVOK			;MAKE A ROOT MFI
	REST <A>		;ROOT CAP IN A
	SAVE <#-1,#0,A>
	BIS #.CPYCP,(P)		;COPY THE ROOT CAP
	$INVOK
	REST <B>		;BITS CAP WIL BE IN B
	SAVE <#0,#MFIBIT,B>
	BIS #.FAMU,(P)
	$INVOK
	SAVE <#0,#0,B>
	BIS #.FAMB,(P)		;SET UP BIT TABLE
	$INVOK
	SAVE <#-1,#0,A>
	BIS #.CPYCP,(P)		;COPY THE ROOT CAP
	$INVOK
	REST C
	SAVE <#.FAWSB,#MFIDSC,C>
	BIS #.FAMU,(P)		;GET THE DESCRIPTOR FILE
	$INVOK
	SAVE <C,C>		;FOR THE WRDI
	$WRDI			
	TST (P)+		;DONT WANT CREATION DATE
	$WRDI			;GET THE START
	SAVE C
	$WRDI			;AND LENGTH
	SAVE <#0>		;DISK NUMBER
	$ALLOC
	SAVE <#-1,#0,A>
	BIS #.CPYCP,(P)
	$INVOK
	REST C
	SAVE <#.FAWSB,#MFISYS,C>
	BIS #.FAMU,(P)		;MUTATE THE ROOT
	$INVOK
	SAVE <#<7*400>,#0,#13777,#.CRWRT+1>	;SET UP FRESH PAGE IN PAGE 7-17
	$MAP
	MOV #ABSLD,A
	MOV #<<ABSEND-ABSLOD>/2>,B	;NUMBER OF WORDS
	MOV #160000,D			;TOP PAGE
	MOV (A)+,(D)+
	SOB B,.-2
	MOV C,SYSFCP			;POINTER TO SYSTEM FILE CAPABILITY
	SAVE <#<7*400>,#0,#10000+377,#.CRWRT+1>	;SET UP FRESH PAGE IN PAGE 0-10
	$MAP
	SAVE <#<7*400>,#0,#10400+377,#.CRWRT+1>	;SET UP FRESH PAGE IN PAGE 1-11
	$MAP
	JMP 160000			;START IT UP

.IIF P1,NUNDEF==0
.IRP X,<CCPRFA,DKWDI,DKWDO,DKBTI,DKBTO,DKBKI,DKBKO,MFACF,MFARE,MFASP,MFADL,MFAAD,MFAMU,MFAMB,MFARI,MFARP,MFADI>
.IF NDF X
X:
	.ERROR NO ROUTINE FOR X YET
	BPT
	0
NUNDEF==NUNDEF+1
.ENDC
.ENDM
.IF P2
.REPT NUNDEF
BPT
0
.ENDR
.ENDC

LSTILC=.	;PUT THIS AT THE LAST INSTRUCTION LOCATION
FSTFRB==<<<.!1777>+1>_-10.>&77	;FIRST FREE BLOCK
.MACRO PAD A,B
.PRINT /A B
/
.ENDM
.IF2
PAD ^/SYSTEM END =/,\.
.IRP Y,<0,1,2,3>
.IRP X,<0.,1.,2.,3.,4.,5.,6.,7.,8.,9.>
.IIF Z <<<FSTFRB+1>/2>-Y''X>,PAD Y''X,<K>
.ENDM
.ENDM
.ENDC
	.END GO
