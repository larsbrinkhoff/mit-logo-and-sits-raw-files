.IFNZ FLOP
;SPECIAL DSKBLK FOR COPIES
DSKSBL:	SAVE <A,B,C,D,E,F>
	BR DSKBLS	;CALLER MUST SET UP FLOPSC AND FLOPTR


;DISK ROUTINES FOR THE FLOPPY DISK
DSKBLK:	SAVE <A,B,C,D,E,F>
	MOV BLOKNO,F	;THE BLOCK NUMBER
	CLR E
	ASHC #3,E	;8 SECTORS/BLOCK
	DIV #26.,E	;26 SECTORS/TRACK
	TST FLPTYP	;OLD OR NEW?
	BNE 1$		;OLD
	INC E		;NEW OFFSETS TRACKS BY 1
1$:	MOV E,FLOPTR	;TRACK
	INC F		;SECTORS ARE NUMBERED FUNNY
	MOV F,FLOPSC	;SECTOR
DSKBLS:	MOV FLOPSC,FLOPSS	;SAVED SECTOR
	MOV B,FLOPCA	;SAVE STARTING CORE ADDRESS
	MOV B,FLPSCA
	MOV TRNSLE,FLOPWC	;STARTING WORD COUNT
	SUB TRNSLE,B
	SUB TRNSLE,B	;GET END OF BUFFER ADDRESS
	MOV B,FLOPHW	;FOR "HALF WAY" MARK
	MOV #SMSCSR,F	;THE CONTROL REGISTER
	MOV #SMSDBF,E	;THE DATA BUFFER

DSKBL1:	TST FLOPWC	;ANY WORDS LEFT TO XFER?
	BNE 1$		;YUP
	REST <F,E,D,C,B,A>
	RTS PC
1$:


	MOV #NRETRY,RETRYS	;SET RETRYS FOR THIS SECTOR
DSKBL2:	MOV #SMSSEK,A		;REENTER HERE ON ERROR
	JSR PC,DCMD
	MOV FLOPTR,A
	JSR PC,CMD2		;SEEK TO TRACK	
	JSR PC,GETST		;GET STATUS OF THE SEEK
	BEQ FLPERR
	JSR PC,SECMUN		;GO MUNG WITH SECTOR NUMBER
	CMP #DISKWR,DISKIO	;WRITE?
	BEQ FLOPWR
	CMP #DISKWC,DISKIO	;WRITE CHECK?
	BEQ FLOPCM
	CMP #DISKRD,DISKIO	;READ?
	BEQ FLOPRD
2$:	HALT			;??????
	BR 2$

FLOPWR:	MOV #SMSWRT!SMSHTB,A	;TRANSFER BLOCK TO BUFFER
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV #128.,B		;# OF BYTES/SECTOR	
1$:	MOVB (A)+,(E)
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	MOV #SMSWRT!SMSBTD,A	;TRANFER BUFFER TO THE DISK
	JSR PC,DCMD
	MOV FLOPNS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	BR FLPSEC		;DONE WITH THIS SECTOR	

FLPERR:	JMP FLPERX

FLOPRD:	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPNS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV #128.,B		;# OF BYTES/SECTOR	
1$:	MOVB (E),(A)+
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC		;DONE WITH THIS SECTOR	

FLOPCM:	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPNS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV #128.,B		;# OF BYTES/SECTOR	
1$:	CMPB (E),(A)+
	BNE FLPERC
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC

FLPERC:	DEC B		;ONE LESS BYTE
	BEQ 2$	;ERROR ON LAST BYTE
1$:	MOV (E),A	;TO EMPRY BUFFER
	SOB B,1$
2$:	JSR PC,GETST
	BR FLPERR	;NOW DO THE ERROR

FLPSEC:	ADD #64.,FLOPWC		;TRANSFERED 64. WORDS
	BEQ 1$			;DONE TRANSFER
	ADD #256.,FLOPCA	;OR 128. BYTES
	TST FLPTYP		;OLD OR NEW?
	BEQ FLPNSC		;NEW
	ADD #2,FLOPSC		;OR ONE SECTOR
	CMP FLOPHW,FLOPCA	;ARE WE PAST THE BUFFER END?
	BLOS 2$			;YUP, TIME TO DOUBLE BACK
	CMP #27.,FLOPSC		;OVER TRACK BOUNDARY?
	BGT 1$
	BIT #1,FLOPSC		;ON FIRST HALF OF THIS PARTIAL TRACK TRANSFER?
	BNE 2$			;YUP, GO DO SECOND
	MOV #1,FLOPSC		;TO START ON NEXT TRACK
	INC FLOPTR
	SUB #128.,FLOPCA	;BACK OFF THE CA
	MOV FLOPCA,FLPSCA
	MOV FLOPSC,FLOPSS
	BR 1$
2$:	MOV FLOPSS,FLOPSC	;GET SAVED SECTOR NUMBER
	INC FLOPSC
	MOV FLPSCA,FLOPCA	;GET SAVED CA
	ADD #128.,FLOPCA
1$:	JMP DSKBL1		;GO CONTINUE THE TRANSFER

FLPNSC:	INC FLOPSC		;NEXT SECTOR
	SUB #128.,FLOPCA	;CORRECT FOR OLD ROUTINES MISTAKES
	CMP #27.,FLOPSC
	BNE 1$
	INC FLOPTR
	MOV #1,FLOPSC
1$:	JMP DSKBL1

SECMUN:	TST FLPTYP		;OLD OR NEW?
	BEQ 1$			;NEW
	MOV FLOPSC,FLOPNS	;OLD
	RTS PC			;IS SIMPLE
1$:	SAVE <A,B>
	MOV FLOPTR,B		;NEW IS HARDER
	DEC B
	MUL #3,B		;SECTORS ARE OFFSET BY 6 FOR EACH TRACK
	CLR A
	ADD FLOPSC,B
	DEC B
	DIV #13.,A
	ASL B
	INC B
	CMP #13.,FLOPSC
	ADC B
	MOV B,FLOPNS
	REST <B,A>
	RTS PC

FLPERX:	DEC RETRYS		;TIME TO GIVE UP?
	BGE 1$
2$:	TYPEIT <Too many errors, ignore or retry? >
	JSR PC,TYI1
	CMP #'I,A
	BNE 3$
	JMP FLPSEC	
3$:	CMP #'R,A
	BNE 2$
	BR RECAL	;SEEK TO ZERO AND RETRY
1$:	MOV ERRST,A
	ASL A
	JMP @.+4(A)
	DSKBL2		;STRANGE, ERROR DISAPPEARED???
	BADER		;COMMAND ERROR IS BAD
	DRERR		;DRIVE ERROR
	OPRERR		;OPERATION ERROR

BADER:	TYPEIT <Software error>
1$:	HALT
	BR 1$

DRERR:	TYPEIT <Fix drive and type a space_>
	JSR PC,TYI1
	JMP RECAL

OPRERR:	BIT #SMSHPE!SMSDAM!SMSSUR,ERRDAT	;SEEK ERROR?
	BEQ OPRER1			;NOPE
RECAL:	MOV #SMSSEK,A
	JSR PC,DCMD
	CLR A			;SEEK TO TRACK ZERO
	JSR PC,CMD2
	JSR PC,GETST
OPRER1:	JMP DSKBL2		;TRY AGAIN




FORMAT:	TYPEIT <ormat disk?  >
	JSR PC,TYI1
	CMP #'Y,A
	BEQ 1$
	JMP CRLF
1$:	MOV #76.,E	;TRACK COUNTER
	MOV #SMSCSR,F
FORMA1:	MOV E,FLOPTR	;FOR ERROR PRINTOUT
	MOV #SMSSEK,A	;FIRST SEEK TO TRACK
	JSR PC,DCMD	;ON SELECTED DISK
	MOV E,A		;TRACK ADDRESS
	JSR PC,CMD2	;ISSUE SECOND BYTE OF COMMAND
	JSR PC,GETST	;GET STATUS OF COMMAND
FORMA2:	JSR PC,REQST	;GET DISK STATUS
	BIT #SMSSIP,A	;SEEK STILL GOING?
	BNE FORMA2	;YUP, WAIT FOR IT TO END

	MOV #SMSFMT,A	;FORMAT THIS TRACK
	JSR PC,DCMD
	MOV E,A		;LABEL THE TRACK CORRECTLY
	JSR PC,CMD2
1$:	TSTB SMSCSR	;DONE?
	BPL 1$		;NOT YET
	JSR PC,GETST	;GET STATUS OF OPERATION
	DEC E
	BGE FORMA1	;DO NEXT TRACK
	RTS PC		;DONE FORMATTING





;ROUTINES TO INTRACT WITH THE DISK ON A LOW LEVEL

;GET THE STATUS OF THE SELECTED DISK
REQST:	MOV #SMSSTS,A	;GET STATUS
	JSR PC,DCMD	;ISSUE REQUEST FOR STATUS
	JSR PC,CMD2	;SECOND BYTE IGNORED
	JSR PC,GETST	;GET THE STATUS
			;IF WE GET BACK WITHOUT ERROR IT WILL BE DISK STATUS
	RTS PC

;ISSUE THE FIRST COMMAND BYTE (IN A), ORING IN THE DISK NUMBER
DCMD:	SAVE A		;SAVE THE COMMAND BYTE
	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW!SMSDNE,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	TYPEIT <Controller not in good state to get command
>
	JSR PC,FLOPER
	HALT
1$:	MOV WCHDSK,A
	ASH #3,A
	BIS (P)+,A
	MOV A,SMSCMD	;GIVE COMMAND
	RTS PC

;ISSUE THE SECOND BYTE OF A COMMAND
CMD2:	SAVE <A,B>		;SAVE THE COMAND BYTE
	MOV #20,B
2$:	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	SOB B,2$
	TYPEIT <Controller not ready for second byte
>
	JSR PC,FLOPER
	HALT
1$:	REST <B,SMSCMD>	;GIVE IT THE BYTE
	RTS PC

GETST:	CLR A	;TO TIME OUT
1$:	BIT #SMSST1!SMSST0,(F)	;STATUS AVAILABLE?
	BNE 2$
	SOB A,1$
	TYPEIT <Timed out waiting for status
>
	JSR PC,FLOPER
	HALT
2$:	BIT #SMSERR,(F)	;ERROR?
	BNE 3$		;YUP
	BIT #SMSXFW,(F)	;WAITING TO TRANSFER?
	BNE 4$
	TYPEIT <Status available but not waiting for xfr????
>
	JSR PC,FLOPER
	HALT
4$:	MOV SMSDBF,A	;GOBBLE STATUS
	CLZ
	RTS PC

3$:	JSR PC,ERRGBL	;GOBBLE ERROR STATUS
	JSR PC,FLOPER
	SEZ
	RTS PC

ERRGBL:	BIT #SMSST1!SMSST0,(F)	;ANYTHING THERE?
	BEQ ERRGB1		;NOPE, KEEP OLD ERROR
	MOVB 1(F),A		;GET NEW ERROR TYPE
	BIC #177774,A		;FLUSH EXTRA STUFF
	MOV A,ERRST
	BIT #SMSXFW,(F)		;WAITING FOR XFR?
	BNE 1$
	TYPEIT <Status available but not waitng for xfr????
>	
	JSR PC,FLOPER
	HALT			;TO AVOID RECURSIVE LOOP
1$:	MOV SMSDBF,ERRDAT
ERRGB1:	RTS PC

;GENERAL ERROR PRINTOUT ROUTINE
FLOPER:	SAVE <A,B,C,D,E,F>
	TYPEIT <_Error csr: >
	MOV SMSCSR,A
	JSR PC,PRONL
	TYPEIT < disk: >
	MOV WCHDSK,A
	JSR PC,PRDN
.IFZ 105
	TYPEIT < block: >
	MOV BLOKNO,A
	JSR PC,PRONL
.ENDC
	TYPEIT < trk: >
	MOV FLOPTR,A
	JSR PC,PRONB
	TYPEIT < rsec: >
	MOV FLOPNS,A
	JSR PC,PRONB
	TYPEIT < vsec: >
	MOV FLOPSC,A
	JSR PC,PRONB
	JSR PC,ERRGBL	;GOBBLE UP THE ERROR STATUS IS THERE IS ONE
			;OTHERWISE LEAVE BEHIND THE OLD STATUS	
	TYPEIT <_Etyp: >
	MOV ERRST,A	;THE BITS THAT GIVE THE TYPE OF ERROR
	JSR PC,PRONB
	TYPEIT < edat: >
	MOV ERRDAT,A
	JSR PC,PRONB
	TYPEIT <_>
	MOV ERRST,A
	ASL A
	JMP @.+4(A)
	NOERR
	CMDERR
	DRVERR
	OPERR

NOERR:	TYPEIT <  No error available
>
	JMP FLOPE1

CMDERR:	TYPEIT < Cmd err: >
	BIT #SMSITA,ERRDAT
	BEQ 1$
	TYPEIT <Invalid track  >
1$:	BIT #SMSISA,ERRDAT
	BEQ 2$
	TYPEIT <Invalid sector  >
2$:	BIT #SMSIBS,ERRDAT
	BEQ 3$
	TYPEIT <Invalid buffer spec>
3$:	TYPEIT <_>
	JMP FLOPE1

DRVERR:	TYPEIT < Drive error: >
	BIT #SMSDNR,ERRDAT
	BEQ 1$
	TYPEIT <Drive not ready  >
1$:	BIT #SMSDUS,ERRDAT
	BEQ 2$
	TYPEIT <Drive unsafe  >
2$:	BIT #SMSDWP,ERRDAT
	BEQ 3$
	TYPEIT <Write protected  >
3$:	BIT #SMSNAM,ERRDAT
	BEQ 4$
	TYPEIT <No address marks  >
4$:	BIT #SMSSIP,ERRDAT
	BEQ 5$
	TYPEIT <Seek in progress>
5$:	TYPEIT <_>
	JMP FLOPE1

OPERR:	TYPEIT <Op error:  >
	BIT #SMSRWA,ERRDAT
	BEQ 1$
	TYPEIT <Read/write abort  >
1$:	BIT #SMSHPE,ERRDAT
	BEQ 2$
	TYPEIT <Head pos err  >
2$:	BIT #SMSDAM,ERRDAT
	BEQ 3$
	TYPEIT <Data address mark missing  >
3$:	BIT #SMSDOV,ERRDAT
	BEQ 4$
	TYPEIT <Overrun  >
4$:	BIT #SMSSUR,ERRDAT
	BEQ 5$
	TYPEIT <Sector unrecoverable  >
5$:	BIT #SMSCRC,ERRDAT
	BEQ 6$
	TYPEIT <Crc err  >
6$:	BIT #SMSRWC,ERRDAT
	BEQ 7$
	TYPEIT <Read/write complete  >
7$:	BIT #SMSDDR,ERRDAT
	BEQ 8$
	TYPEIT <Deleted data>
8$:	TYPEIT <_>

FLOPE1:	REST <F,E,D,C,B,A>
	RTS PC


DISKON:	SAVE <A,B,F>
	BIS #SMSRSB!SMSPWR,SMSCSR	;RESET CONTROLLER AND POWER DRIVES ON
	CLR A		;FOR TIMER
	MOV #30.,B	;ALSO
1$:	BIT #SMSFDO,SMSCSR	;IS IT RESET YET?
	BEQ 2$
	SOB A,1$	;WAIT
	SOB B,1$	;A LONG TIME
5$:	TYPEIT <Disk won't power on or no disk in drive_Type P when disk is ok_>
	HALT
	BR DISKON
2$:	MOV #10000.,B
	MOV #SMSCSR,F
3$:	MOV #SMSSTS,A
	JSR PC,DCMD
	JSR PC,CMD2
	JSR PC,GETST
	BIT #SMSDNR,A	;DISK READY?
	BEQ 4$		;YUP
	SOB B,3$
	BR 5$		;NOPE
4$:	REST <F,B,A>
	RTS PC

DSKOFF:	BIS #SMSRSB,SMSCSR
	BIC #SMSPWR,SMSCSR
1$:	RTS PC


.ENDC
