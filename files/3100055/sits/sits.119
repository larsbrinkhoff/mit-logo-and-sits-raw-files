.ABS
VERN==%FNAM2
%COMPAT==0		;SUPRESS INCOMPATABLE OP-CODE MESSAGES
NPC==0
NTKDIS==0
TVS==0
NTVS==0
NTVCHN==0
MBFLG==0
.INSRT SITS;SITMAC >
.IIF NDF GUY,GUY==0

.IF Z GUY
NTKDIS==4
TVS==1
MBFLG==1
.ENDC
.IFNZ TVS
NTVS==32.
NTVCHN==4
.ENDC
	.SBTTL INTERNAL REGISTER DEFINITIONS
;MEMORY SEGMENTATION UNIT
SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
USRISD=177600
USRDSD=177620
USRISA=177640
USRDSA=177660
SUPISD=172200
SUPDSD=172220
SUPISA=172240
SUPDSA=172260
KERISD=172300
KERDSD=172320
KERISA=172340
KERDSA=172360

;SEGMENTATION REGISTER DEFINITION
SEGNRA==100000		;SEGMENTATION NON RESIDENT ABORT
SEGSLE==40000		;SEGMENT LENGTH ERROR
SEGRVI==20000		;READ ONLY VIOLATION
SEGTRP==10000		;SEGMENTATION TRAP
SEGPMO==177637		;PAGE MODE THAT CAUSED TRAP
SEGKER==0		;KERNEL MODE
SEGUSR==140		;USER MODE
SEGPNO==177741		;THE PAGE NO. MASK

;CONSOLE SWITCHES AND DISPLAY
CDISP=177570
CSWR=177570

;PROGRAM INTERUPT REQUEST REGISTER
PIRQ=177772

;STACK LIMIT REGISTER
STKLIM=177774

;PROCESSOR STATUS
PS=177776

;START OF PARITY REGISTERS
PARCSR=172100

RUGST==157000		;RUG STARTING LOCATION
;KERNAL MAP REGISTERS
I0AR=KERISA
I1AR=I0AR+2
I2AR=I1AR+2
I3AR=I2AR+2
I4AR=I3AR+2
I5AR=I4AR+2
I6AR=I5AR+2
I7AR=I6AR+2
RUGIAR=I6AR

I0DR=KERISD
I1DR=I0DR+2
I2DR=I1DR+2
I3DR=I2DR+2
I4DR=I3DR+2
I5DR=I4DR+2
I6DR=I5DR+2
I7DR=I6DR+2
RUGIDR=I6DR

VAR0AR=KERDSA
VAR1AR=VAR0AR+2
VAR2AR=VAR1AR+2
ITM0AR=VAR2AR+2
ITM1AR=ITM0AR+2
ITM2AR=ITM1AR+2
RUGDAR=ITM2AR+2
IOAR=RUGDAR+2

VAR0DR=KERDSD
VAR1DR=VAR0DR+2
VAR2DR=VAR1DR+2
ITM0DR=VAR2DR+2
ITM1DR=ITM0DR+2
ITM2DR=ITM1DR+2
RUGDDR=ITM2DR+2
IODR=RUGDDR+2

;INTERNAL TRAP VECTORS
BEBRV=4
ILLBRV=10
BPTBRV=14
IOTBRV=20
PWFBRV=24
EMTBRV=30
TRPBRV=34
PARBRV=114
PIRBRV=240
FPPBRV=244
SEGBRV=250
	.SBTTL DEVICE DEFINITIONS
;RF11 FIXED HEAD DISK
RFCS=177460	;CONTROL AND STATUS
RFWC=177462	;WORD COUNT
RFBA=177464	;BUSS ADDRESS
RFDA=177466	;DISK ADDRESS (LOW PART)
RFDAE=177470	;HIGH PART OF ADDRESS AND ERROR REGISTER
RFBRV=204

;RK11 MOVING HEAD DISK
RKDS=177400	;DRIVE STATUS REGISTER
RKER=177402	;ERROR REGISTER
RKCS=177404	;CONTROL AND STATUS REGISTER
RKWC=177406	;WORD COUNT
RKBA=177410	;BUSS ADDRESS
RKDA=177412	;DISK ADDRESS
RKBRV=220

;CONSOLE TELETYPE
;BREAK LEVEL 4
TKBRV=60	;CONSOLE KEYBOARD BREAK VECTOR
TKS=177560	;CONSOLE KEYBOARD STATUS
TKB=177562	;CONSOLE KEYBOARD DATA
TPBRV=64	;CONSOLE PRINTER BREAK VECTOR
TPS=177564	;CONSOLE PRINTER STATUS
TPB=177566	;CONSOLE PRINTER DATA


;PROGRAMMABLE CLOCK KW11-P
PCCS=172540	;CONTROL AND STATUS
PCCB=172542	;COUNT SET BUFFER
PCCN=172544	;COUNTER
PCBRV=104	;INTERUPT VECTOR

;LINE FEQUENCY CLOCK KW11-L
LCCS=177546	;CONTROL AND STATUS
LCBRV=100	;INTERUPT VECTOR

;TK DISPLAY
NGCSR=164040	;CONTROL AND STATUS
NGREL=164042	;RELOCATION

;PAPER TAPE PUNCH AND READER
PTRSR=177550	;PAPER TAPE READER STATUS
PTRBR=177552	;PAPER TAPE READER BUFFER
PTPSR=177554	;PAPER TAPE PUNCH STATUS
PTPBR=177556	;PAPER TAPE PUNCH BUFFER
PTRBRV=70	;VECTOR FOR READER
PTPBRV=74	;VECTOR FOR PUNCH

PLTBCR=177500	;PLOTTER BYTE COUNT REGISTER
LPTMEX=177502	;DMA MEMORY EXTENSION BITS REGISTER
PRTBCR=177504	;PRINTER BYTE COUNT REGISTER
LPTBA=177506	;BUSS ADDRESS FOR THE DMA CONTROLLER
PLTCSR=177510	;PLOTTER CONTROL STATUS REGISTER
PLTDBR=177512	;PLOTTER DATA BUFFER REGISTER
PRTCSR=177514	;PRINTER CONTROL STATUS REGISTER
PRTDBR=177516	;PRINTER DATA BUFFER REGISTER
PRTBRV=200	;PRINTER VECTOR
PLTBRV=174	;PLOTTER VECTOR

;MB11 MAR AND HISTORY REGISTER
MBCSR=170000+0		;CONTROL AND STATUS
MBXHGH=MBCSR+2		;HIGH BITS OF X REGISTER
MBXLOW=MBCSR+4		;LOW BITS OF X REGISTER
MBYHGH=MBCSR+6		;HIGH BITS OF Y REGISTER
MBYLOW=MBCSR+10	;LOW BITS OF Y REGISTER
MBHHGH=MBCSR+12	;HIGH BITS OF HISTORY REGISTER
MBHLOW=MBCSR+14	;LOW BITS OF HISTORY REGISTER
MBHCNT=MBCSR+16	;HISTORY MEMORY COUNTER

;BITS IN MBCSR
MBINTE==100
MBAFRZ==200
MBXAYR==400		;X<A<Y READ TRAP
MBXAYW==1000		;X<A<Y WRITE TRAP
MBNOIN==2000		;IGNORE INIT
MBINAO==4000		;INTERRUPT ON ALMOST OVERFLOW

;BITS IN MBXHGH AND MBYHGH
MBREDT==4		;READ TRAP BIT
MBWRTT==10		;WRITE TRAP BIT

;BITS IN MBHHGH
MBWRTB==4		;WRITE BIT IN HISTORY MEMORY HIGH BITS

;BREAK VECTOR
MBBRV=374

.SBTTL MACROS FOR DEFINING VARIOUS THINGS

;MACRO TO INITIALIZE DEFINITION OF SOME RANDOM THING
.MACRO DTHING
FOO==0
.ENDM

;MACRO TO DEFINE A WORD FOR SOME RANDOM THING
.MACRO DWORD A,B
.IIF P1,.IIF DF A,.ERROR A ALREADY DEFINED
A==FOO
.IF NB B
.IIF P1,.IIF DF B,.ERROR B ALREADY DEFINED
B==FOO+1
.ENDC
FOO==FOO+2
.ENDM

;MACRO TO INIT THE DEFINITION OF RANDOM FLAGS
.MACRO DFLAGS
BAR==1
.ENDM

;MACRO TO DEFINE A RANDOM FLAG BIT
.MACRO DFLAG FLAG
.IIF P1,.IIF DF FLAG,.ERROR FLAG ALREADY DEFINED
.IIF Z BAR,.ERROR FLAG TOO MANY FLAGS
FLAG==BAR
BAR==BAR_1
.ENDM

;MACRO TO ADD SOMETHING TO A REMOTE MACRO
.MACRO ADDMAC MAC,STUFF
MAC <
.MACRO MAC A,B,C
A>,<STUFF>,<B
C
.ENDM>
.ENDM

;MACRO FOR THE INITLS TABLE
.MACRO INITSL A,B,C
A
INITLS:
B
C
.ENDM

;MACRO FOR STORAGE ALLOCATION OF LIST SPACE
.MACRO LSTSTO A,B,C
A
LISTST:
B
C
.ENDM

.MACRO ALSTM FREENM,TABNAM,LENGTH,NUM
ADDMAC LSTSTO,<FREENM:	0
.IIF NB TABNAM,TABNAM:
.BLKB LENGTH*NUM
AILSTM FREENM,NUM,LENGTH>
.ENDM

.MACRO AILSTM FREENM,NUM,LENGTH
ADDMAC INITSL,<ILIST FREENM+2,FREENM,NUM,LENGTH>
.ENDM

;MACRO TO DEFINE A LIST STORAGE AREA
.MACRO ILISTS FREENM,TABNAM,NUM
ALSTM FREENM,TABNAM,\FOO,NUM
.ENDM

.MACRO ILIST AD,FREE,NUM,LEN
WORDS <AD+LEN,FREE,NUM-2,LEN>
.ENDM
	.SBTTL DEFINITIONS FOR VARIOUS TYPES OF ITEMS
;MACROS TO DEFINE ITEMS WITH

;THE START DEFINING ITEM MACRO
	.MACRO SITEMD SYM
FOO==2
ITMTFO==ITMTFO+1
SYM==ITMTFO
	.ENDM

;THE DEFINE SYMBOL MACRO
;IF SECOND ARG IS PRESENT, IT IS HOW MUCH SPACE TO RESERVE, IN BYTES
	.MACRO DITMS SYM,SIZE
.IIF P1,.IIF DF SYM,.ERROR SYM ALREADY DEFININED
SYM==FOO
	.IIF B SIZE,FOO==FOO+2
	.IIF NB SIZE,FOO==FOO+<SIZE>
	.ENDM

;THE DEFINE FLAG WORD MACRO
;SPACE IS RESERVED FOR THE FLAG WORD, AND FLAGS ARE DEFIND
;SEQUENTIALLY FROM THE RIGHT TO THE LEFT 
	.MACRO DFWORD SYM,BITS
FOOBAR==0
SYM==FOO
FOO==FOO+2
	.IRP X,<BITS>
X==1_FOOBAR
FOOBAR==FOOBAR+1
	.ENDM
	.ENDM

;THE DEFINE ITEM SIZE MACRO
;DEFINES A SYMBOL AS THE SIZE OF THE ITEM DEFINED SO FAR
	.MACRO DITMSZ SYM
SYM==FOO_-6
	.ENDM
.SBTTL MACROS FOR GENERATING CODE

.MACRO LBRLEM ADDR,COND,A,Q
	.IF IDN COND,A
	B'Q .+6
	JMP ADDR
	.ENDC
	.IF IDN COND,Q
	B'A .+6
	JMP ADDR
	.ENDC
.ENDM

.MACRO LBR COND,ADDR
	.IF1
	  .IFDF ADDR
	     .IFGE ADDR-.+376
	      .=.+2
	     .IFF
	      .=.+6
	      .IIF B COND,.=.-2
	     .ENDC
	  .IFF
	   .=.+6
	   .IIF B COND,.=.-2
	  .ENDC
	.IFF
	 LBRCSW==0
	  .IFLE ADDR-.
	     .IFGE ADDR-.+376
	      LBRCSW==1
	        .IF NB COND
	         B'COND ADDR
	        .IFF
	         BR ADDR
	        .ENDC
	     .ENDC
	  .ENDC
	  .IFZ LBRCSW
	     .IIF B COND,JMP ADDR
	     LBRLEM ADDR,COND,EQ,NE
	     LBRLEM ADDR,COND,LT,GE
	     LBRLEM ADDR,COND,LE,GT
	     LBRLEM ADDR,COND,HIS,LO
	     LBRLEM ADDR,COND,LOS,HI
	     LBRLEM ADDR,COND,CS,CC
	     LBRLEM ADDR,COND,VS,VC
	  .ENDC
	.ENDC
.ENDM
;MACRO TO DO A BUG CHECK IN THE "NATURAL DIRECTION"
;THAT IS, IF THE CONDITION IS TRUE, BPT
.MACRO NBUGC COND
	RBRPP4 COND
	BPT
.ENDM

;MACRO TO BRANCH TO .+4 (PP4) ON THE OPPISITE OF THE SUPPLIED CONDITON
.MACRO RBRPP4 COND
	BRO .+4,COND,MI,PL
	BRO .+4,COND,EQ,NE
	BRO .+4,COND,LT,GE
	BRO .+4,COND,LE,GT
	BRO .+4,COND,HIS,LO
	BRO .+4,COND,LOS,HI
	BRO .+4,COND,CS,CC
	BRO .+4,COND,VS,VC
.ENDM

;MACRO TO GENERATE BRANCH OF OPPISTIE CONDITION
.MACRO BRO ADDR,COND,A,Q
.IIF IDN COND,A,	B'Q ADDR
.IIF IDN COND,Q,	B'A ADDR
.ENDM

.MACRO BUGC COND
	NBUGC COND
.ENDM


.MACRO CHECKP
;	JSR PC,CHEKIN
.ENDM

	.MACRO TRAPV DEV,PRI
.=DEV'BRV
.IIF P2,.IIF NDF DEV'BRK,DEV'BRK==0
	DEV'BRK
.IIF NB PRI,	PRI_5
.IIF B PRI,	200
.ENDM
;MACRO TO GENERATE A CONDITIONAL ERROR TRAP
.MACRO ERRORC COND,ERR,F1,F2
	RBRPP4 COND
	ERROR ERR,F1,F2
.ENDM

;MACRO TO GENERATE AN ERROR TRAP
.MACRO ERROR ERR,F1,F2
ERRCOD==.E'ERR!TRPZBT
	EFLAG F1
	EFLAG F2
	TRAP ERRCOD
.ENDM

;MACRO TO HELP OUT ERROR
.MACRO EFLAG FLAG
.IIF IDN FLAG,SZ,ERRCOD==ERRCOD!TRPZBT
.IIF IDN FLAG,CZ,ERRCOD==ERRCOD&<-TRPZBT-1>
.IIF IDN FLAG,SV,ERRCOD==ERRCOD!TRPVBT
.IIF IDN FLAG,CV,ERRCOD==ERRCOD&<-TRPVBT-1>
.ENDM

TRPZBT==200
TRPVBT==100

;MACRO TO ASSIGN AN ERROR SYMBOL
.MACRO ERDEF CODE
.E'CODE==FOO
FOO==FOO+1
.ENDM

.MACRO EMTD NAME
.IF NB NAME
.'NAME==FOO+EMT
$'NAME==FOO+200+EMT
	E'NAME
.IFF
	BADEMT
.ENDC
FOO==FOO+1
.ENDM


	.SBTTL SYSTEM PARAMETERS

;GENERALIZED ITEM POINTER DEFINITION
GIPBIT==100000	;SET IF IT IS A GENERALIZED ITEM POINTER
GIPSPR==40000	;BIT SET IF UPT IS IN A SPHERE
GIPITM==176000	;MASK FOR ITEM INDEX
GIPUPT==141777	;MASK FOR UPT NUMBER (IN SPHERE)
GIPFUP==140000	;MASK FOR FLOATING UPT TABLE OFFSET

;FOR THE ITEM LIST
NITEMS==150.	;MAXIMUM NUMBER OF ITEMS
NITMBL==8.	;MAXIMUM NUMBER OF BLOCKS ALLOCATED TO ITEM STROAGE
NITMPS==20.	;MAXIMUM DEPTH OF ITEM PUSHES
NITALS==NITMBL*8.	;NUMBER OF FREE STROAGE NODES
;DEFINITION OF AN ITEM TABLE ENTRY
DTHING
DWORD ITLINK	;LINK WORD FOR FREE ENTRIES
ITMADR==ITLINK	;WHERE THE ADDRES OF THE ITEM IS KEPT
DWORD ITACCS,ITLNGT	;ACCESS CODE, LENGTH
ILISTS ITMFRE,ITMTAB,NITEMS
ITMTEL==FOO
.IIF NZ 4-ITMTEL,.ERROR ITEM NODES AND ITEM ALLOCATE NODES NOT SAME SIZE!
ITACCD==6	;ITEM ACCESS CODE (READ-WRITE NO TRAP)
FOO==4
ILISTS ITMAFR,,NITALS	;FREE STORAGE NODES
;ADDRESSES OF THE ITEM SLOTS
ITM0AD==<ITM0AR-KERDSA>_12.
ITM1AD==<ITM1AR-KERDSA>_12.
ITM2AD==<ITM2AR-KERDSA>_12.

;PROCESS AND USER PARAMETERS
NPROSS==80.	;MAXIMUM NUMBER OF PROCESSES AND USERS
PRPDLL==200	;LENGTH OF THE PDL FOR THE PROCESS (BYTES)
PIT2PL==14	;LENGTH OF ITEM 2 PDL IN PROCESS
;DEFINITION OF A PROCESS TABLE ENTRY
PRSTEL==16	;LENGTH OF A PROCESS TABLE ENTRY
PRTFRD==0	;FORWARD POINTER
PRTBCK==2	;BACK POINTER
PRTPPT==4	;PROCESS POINTER (OR TO ITEM IF USER)
PRTUPT==6	;USER POINTER (-1 FOR USER)
PRTJTM==10	;JTMU
PRTPRI==12	;HIS PRIORITY
PRTTIM==14	;TIME IN HALF-SECS THIS PROCESS PUT ON THIS QUEUE

;SPHERE PARAMTERS
MNCLSE==200	;MAXIMUM NUMBER OF C-LIST ENTRIES
NCLSEB==10	;NUMBER OF C-LIST ENTRIES PER BLOCK
CLSELN==12	;LENGTH OF A C-LIST ENTRY (NOTE THAT THE LENGTH OF A BLOCK=NCLSEB*CLSELN, WHATEVER IT IS)
;DEFINITION OF A C-LIST ENTRY
CLSETY==0	;TYPE
CLSEPI==2	;PRIMARY ITEM FOR ENTRY
CLSESI==4	;SECONDARY ITEM FOR ENTRY
CLSEM0==6	;FIRST RANDOM WORD FOR ENTRY
CLSEM1==10	;SECOND RANDOM WORD
;THESE ARE FOR THE .RDMAP CALL
.PLENM==177770	;MASK FOR THE LENGTH OF THE PAGE
.PACCM==174377	;MASK FOR THE ACCESS
.PDEI==100000	;BIT FOR DATA = I PAGE
.PABS==40000	;BIT FOR ABSOLUTE PAGE
.PFIL==2000	;BIT FOR FILE PAGE


	;FOR THE TELETYPE ITEM
TITQ==TOQM-1
TIQSZ==350.
TIBSZ==50.
TOQSZ==64.
TIBT==TIQM
TIQLM==TOQM
TOQLM==TOQM+TOQSZ

;FOR THE QUE ITEM
QUESZ==64	;THE SIZE OF THE QUE

;FOR THE PAPER TAPE ITEMS
PTRSZ==120.
PTPSZ==120.
;FOR THE LOCKED SWITCH LISTS
NLCKBL==NPROSS/4	;A GUESS
DTHING
DWORD LCKLNK	;THE LINK
DWORD LCKDSP	;DISPATCH ADDRESS FOR LOCK
DWORD LCKTIT	;ITEM
DWORD LCKWD1	;WORD ONE OF LOCK DATA
DWORD LCKWD2	;WORD TWO
ILISTS LCKFRE,,NLCKBL

;MISC SYSTEM PARAMETERS
LTIMEL==6	;TIME BETWEEN CHECKING INATIVE GUYS
JTMUUT==6	;NUMBER OF TICKS BETWEEN JTMU UPDATES
JTMUAC==40	;ADDITIVE CONSTANT
JTMUDC==4	;DECAY CONSTANT
CLKL==1		;LEVEL CLOCK RUNS AT
CLKPIR==1_<CLKL+10>	;BIT FOR PIRQ
TTYL==2		;LEVEL TTY PROCESSING RUNS AT
TTYPIR==1_<TTYL+10>
DMRL==3		;LEVEL THE MIDDLE LEVEL DISK ROUTINES RUN AT
DMRPIR==1_<DMRL+10>	;MIDDLE LEVEL DISK PIRQ BIT
IPRIOR==4	;PRIORITY TO SET A NEWLY CREATED PROCESS TO
IQUANT==4	;INTIAL QUANTUM
ITMTFO==0	;THE TYPE OF THE LAST ITEM DEFINED
ITTYPE==0	;FOR ALL ITEMS, THE FIRST WORD IS THE TYPE
;DEFINITION OF A PROCESS ITEM
SITEMD ITPROC
;THE NEXT THREE SHOULD NOT BE MOVED
;WITHOUT MOVING THE COORESPONDING THREE IN THE USER DEFINITION
DITMS PRSREF		;REFERENCE COUNT
DITMS PPRTPT		;POINTER TO PROCESS TABLE
DITMS PQBIT		;THE QUEUE BIT
DITMS PRSUSR		;THE USER PROCESS TABLE POINTER
DITMS PTUSED,4		;TIME USED BY THIS PROCESS IN HALF-TICKS
DITMS PRSID1		;PROCESS ID LOW PART
DITMS PRSID2		;PROCESS ID HIGH PART
DITMS PFAULT		;IF NON-ZERO, WHAT KIND OF FAULT
DITMS PERRW		;ERROR WORD FOR SYSTEM CALLS (PERRW AND PERRAD MUST BE IN THIS ORDER)
DITMS PERRAD		;SYSTEM ADDRES WHERE ERRRO TRAP HAPPENED FROM
DITMS PSPHRP		;POINTER TO SPHERE
DITMS PSPHCP		;CIRCULAR POINTER TO OTHER PROCESSES IN SPHERE
DITMS PLCKSL		;END OF THE LOCKED SWITCH LIST
DITMS PUPDLO		;OFFSET OF USER'S PDL IF CALL COMPLETES
DITMS PITM2P,PIT2PL	;PROCESS'S ITEM2 PDL
DITMS PITM2C		;COUNT OF ITEMS ON ITEM2 PDL
DITMS PUREGS,14		;THE USER'S REGISTER'S
DITMS PUP		;THE USER'S PDL POINTER
DITMS PUPC		;THE USER'S PC
DITMS PUPS		;THE USER'S PROCESSOR STATUS
DITMS PSREGS,14		;THE SYSTEM'S REGISTERS
DITMS PSP		;THE SYSTEM'S PDL POINTER
DITMS PSPC		;THE SYSTEM'S PC
DITMS OPSPC		;OLD SYSTEM PC
DITMS PPDL,PRPDLL	;THE PROCESS'S PDL
DFWORD PFLAGS,<PFALTB,PFAILB,PFPFLG,PACSVF,PPCLSR,PTVFLG,PPBNMP,PPCLDF>	;PROCESS FLAG WORD
DITMS PSTOPC		;STOP COUNT
DFWORD PSTOP,<PSPHSB,PSUPSB>	;STOP WORD
;PSPHSB INDICATES THE SPHERE HAS STOPPED THE PROCESS
;PSUPSB INDICATES SOME OTHER SUPERIOR PROCESS HAS STOPPED IT
DITMS PTVMAP		;-1 => DON'T MAP IN TV, HIGH BYTE IS TVSEL REGISTER
DITMSZ PRSLNF		;SIZE WITH NO FLOATING POINT
DITMS PTVMSK		;SAVED MASK
DITMS PTVINC		;SAVED INCREMENT REGISTER
DITMS PTVSHR		;SAVED SHIFT COUNT
DITMS PTVRAD		;THE ADDRESS REGISTER
DITMS PFPPRG,24.*2	;FLOATING POINT REGISTERS
DITMS PFPPS		;FLOATING POINT STATUS
;NEXT TWO MUST BE IN THIS ORDER
DITMS PFEC		;FLOATING EXCEPTION CODE
DITMS PFEAP		;FLOATING EXCEPTION ADDRESS POINTER
DITMSZ PRSLFP		;LENGTH WITH FLOATING POINT

;DEFINITION OF A USER ITEM
SITEMD ITUSER
;THE NEXT THREE SHOULD NOT BE MOVED (SEE PROCESS)
DITMS USRREF		;THE REFERENCE COUNT
DITMS UPRTPT		;POINTER INTO PROCESS TABLE
DITMS UQBIT		;THE QUEUE BIT (HAD BETTER BE USER QUEUE)
DITMS UTUSED,4		;TIME USED BY THIS USER
DITMS USRTTY		;THE TTY NUMBER OF THIS USER
DITMS USRNAM,10.	;USER NAME
DITMSZ USRLEN		;LENGTH OF A USER ITEM

;DEFINITION OF A SPHERE ITEM
SITEMD ITSPHR
;THE NEXT THREE SHOULD NOT BE MOVED (SEE USER)
DITMS SPHREF		;REFERENCE COUNT
DITMS SPRTPT		;THE SPHERE PROCESS TABLE POINTER
DITMS SQBIT		;THE QUEUE BIT (BETTER BE SPHERE QUE)
DITMS SCLSLK		;SPHERE C-LIST LOCK (CONTAINS THE ITEM NO. OF THE PROCESS THAT
			;LOCKED IT
DFWORD SFLAG,<ENFLT1,ENFLT2,FAULT1,FAULT2,FAULT3>	;ENABLE FAULTS ONE AND TWO
			;AND SAY WHETHER FAULT OR NOT
DITMS STTFG1		;TELETYPE FLAG WORD 1
DITMS STTFG2		;TTY FLAG WORD 2
DITMS SMTTY		;ITEM NO. OF MASTER TTY ITEM
DITMS SIFTTY		;ITEM NO. OF INFERIOR TTY SPHERE
DITMS SPHPRP		;POINTER TO FIRST PORCESS
DITMS SPHPRC		;COUNT OF PROCESSES IN SPHERE
DITMS SPHAPR		;COUNT OF ACTIVE PROCESSES
DITMS SUSRPT		;POINTER TO USER ITEM RESPONSIBLE FOR THIS SPHERE
DITMS SMSSPT		;POINTER TO MASTER SPHERE OF THIS SPHERE
DITMS SCLSEP		;POINTER TO FIRST UNUSED LOCATION, RELATIVE TO ITEM
.IFNZ MBFLG		;IF WE HAVE AN MB11 ON
;NEXT 5 MUST BE IN THIS ORDER
DITMS SPMBCN		;CONTROL REGISTER FOR MB11 (0=> NOT USING)
DITMS SPMBHX		;HIGH X BITS
DITMS SPMBLX		;LOW X BITS
DITMS SPMBHY		;HIGH Y BITS
DITMS SPMBLY		;LOW Y BITS
.ENDC
DITMS SUPTS,16.*UPTLEN	;THE UPT ENTRIES
DITMS SCLSTT,MNCLSE/NCLSEB	;THE INDEX OFFSETS TO THE C-LIST
DITMS SICLST,NCLSEB*CLSELN*2	;START WITH 2 BLOCKS OF C-LIST
DITMSZ SPHLEN

;DEFINITION OF A TELETYPE ITEM
SITEMD ITTTY
DITMS TTYREF	;REFERENCE COUNTER FOR TTY
DITMS TTITM	;ITEM THAT CURRENTLY OWNS THIS TTY
DITMS TTLTTY	;THE LOGICAL TTY NO. ASSOCIATED WITH THIS ITEM
DITMS TTYU	;USER NUMBER OF THE OWNER OF THIS TTY
DFWORD TTYST1,<TIRST,TIQF,TOTRAN,TIMAGI,TIMAGO,TIRBM,TIEDM,TIECM,TICVM,TILIPM,TORST,TERST,TICTM,TICTF,TMORM,TMORF>
;STATUS OF TTY - FIRST WORD
.TIRST==TIRST	;=> RESET THE TTY ON NEXT INPUT BREAK
.TIQF==TIQF	;=> SUPER QUOTE THE NEXT CHARACTER
.TOTRN==TOTRAN	;=> CURRENTLY TRANSMITTING
.TIMGI==TIMAGI	;=> INPUT IMAGE MODE
.TIMGO==TIMAGO	;=> OUTPUT IMAGE MODE
.TIRBM==TIRBM	;=> IN RUBOUT MODE
.TIEDM==TIEDM	;=> IN EDIT MODE
.TIECM==TIECM	;=> IN ECHO MODE
.TICVM==TICVM	;=> CONVERT FROM LOWER TO UPPER CASE MODE
.TLIPM==TILIPM	;=> LOGO INPUT MODE
.TORST==TORST	;=> RESET THE TTY ON NEXT OUTPUT BREAK
.TERST==TERST	;=> RESET THE TTY EDIT BUFFER ON THE NEXT OUTPUT COMMMAND
.TICTM==TICTM	;=> CONTROLIFY MODE
.TICTF==TICTF	;=> CONTROLIFY THE NEXT CHAR FLAG
.TMORM==TMORM	;=> ENABLE MORE PROCESSING
.TMORF==TMORF	;=> MORE BREAK TRIGGERED
DFWORD TTYST2,<TSCRL,TOEDM,TILWT,TTHANG,TTBK>
;TTY STATUS, SECOND WORD
.TSCRL==TSCRL	;=> SCROLL MODE. IF ZERO THEN WRAP MODE IS ASSUMED
.TOEDM==TOEDM	;=> MEANS THAT THE BYTE OUTPUT WILL GO TO THE EDIT BUFFER
.TTHNG==TTHANG	;=> MEANS THAT WE ARE HANGING ON INPUT IN LINE MODE
		;TTBK MEANS THAT WE SHOULD TRANSMIT A BREAK FOR TTBRKL CHARACTERS ON
		;NEXT OUTPUT INTERRUPT
DITMS TOTSR	;ADDR OF TRANSMIT STATUS REGISTER
DITMS TIBI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN INPUT BUFFER
DITMS TIBO	;  "     "    "     "    "  COMES OUT  "   "     "
DITMS TIBN	;NUMBER OF CHAR. IN INPUT BUFFER
DITMS TIQI	;POINTER TO WHERE NEXT CHAR GOES IN, IN INPUT QUE
DITMS TIQO	;    "    "   "     "    " COMES OUT  "   "    "
DITMS TIQN	;NUMBER OF CHAR. IN INPUT QUE
DITMS TOQI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN OUTPUT QUE
DITMS TOQO	;   "     "   "    "    "   COMES OUT  "    "     "
DITMS TOQN	;NUMBER OF CHAR. IN OUTPUT QUE
DITMS TIEQO	;POINTER TO WHERE NEXT CHAR COMES OUT, IN OUTPUT QUE
DITMS TIEQN	;NUMBER OF CHARACTERS IN EDIT QUE
DITMS TIBC	;NUMBER OF UNMATCHED LEFT BRACKETS IN INPUT QUE
DITMS TIEBC	;   "   "       "      "      "     "   "    "
DITMS TIQTO	;POINTER TO WHERE ECHO IS PROCESSING
DITMS TIQTON	;NUMBER OF CHAR THAT ECHO STILL HAS TO PROCESS
DITMS TIEQTN	;NUMBER OF CHAR THAT RDSTR HAS TO PROCESS
DITMS TIEQTO	;POINTER TO WHERE RDSTR IS PROCESSING
DITMS TITQN	;TOTAL NUMBER OF CHAR IN INPUT/EDIT QUE
DITMS TOPAD	;NUMBER OF CHAR LEFT TO SEND PAD
DITMS TOIPC	;SAVED PC FOR ECHO
DITMS TOISVA	;SAVED A FOR ECHO
DITMS TOPC	;SAVED PC FOR OUTPUT
DITMS TOOPC	;SAVED SAVED PC FOR DEBUGGING
DITMS TOSVC	;SAVED C FOR OUTPUT
DITMS TOSVD	;SAVED D FOR OUTPUT
DITMS CHARNO	;NUMBER OF CHAR PRINTED FROM LEFT EDGE OF PAGE
DITMS LINENO	;NUMBER OF LINES FROM TOP OF SCREEN
DITMS TLAST	;THE LAST CHAR TYPED
DITMS LINEL	;THE LENGTH OF A LINE
DITMS TIHPIT	;ITEM OF PROCESS HANGING ON INPUT
DITMS TIHPI1	;ID WORD 1 OF "
DITMS TIHPI2	;ID WORD 2
DITMS TTBRKL	;LENGTH OF BREAK CONDITION IN CHARACTERS
.IFNZ NTVS
DITMS TVCRLN	;BYTE ADDRESS OF THE CURSOR IN BUFFER
DITMS TVSCRL	;ADDRESS IN 64 BIT CHUNKS OF SCROLL START
DITMS TVLINE	;THE LINE NUMBER OF THE CURSOR (CHAR LINE NUMBER)
DITMS TVHIGH	;THE NUMBER OF CHAR LINES ON A SCREEN
DITMS TVFONT	;THE FONT NUMBER OF THIS TV
DITMS TVST	;TV STATUS (CONTENTS OF TVCNSL)
DITMS TVCUR	;INTERRUPT LEVEL CURSOR POSITION
DITMS TVBUF	;THE NUMBER OF THE TV BUFFER FOR THIS TV,AND CURSOR MODE
DITMS TVNLSC	;THE NUMBER OF LINES TO SCROLL
DITMS TVHBIT	;THE HORIZONTAL BIT POSITION ON THE CURRENT LINE OF CURSOR
DITMS TVLCNT	;THE NUMBER OF LINES IN A CHAR - 1, USED BY BLINK FOR TVWC
DITMS TVMSK1	;THE LEFT SIDE OF THE CURSOR MASK
DITMS TVMSK2	;THE RIGHT SIDE OF THE CURSOR MASK, IN CASE CURSOR CROSSES WORD
DITMS TVSHCT	;SHIFT COUNT FOR THE CURSOR POSITION
DITMS TVCRSN	;BYTE ADDRESS OF THE BEGINNING OF LINE, LIKE TVCRLN
DITMS TVOFFL	;TOP LINE IN WRAP MODE, WHERE THE CURSOR GOES FROM BOTTOM
.ENDC
DITMS TIBB,TIBSZ	;INPUT BUFFER
DITMS TIQM,TIQSZ	;INPUT QUE
DITMS TOQM,TOQSZ	;OUTPUT QUE
DITMSZ TTYLEN

;DEFINITION OF A QUE ITEM
SITEMD ITQUE	;QUE ITEM
DITMS QUEREF	;REFERENCE COUNT OF THE ITEM
DITMS QUEENO	;NO OF ENTRIES IN QUE
DITMS QUECNT	;NO OF PEOPLE ON QUE
DITMS QUENUM	;THE NUMBER OF PEOPLE WHO CAN LOCK QUE
DITMS QUEQUE,QUESZ	;THE QUE
DITMSZ QUELEN


;DEFINITION OF A MASTER FILE ITEM
SITEMD ITMF		;TOP BYTE IS COUNT OF CAP WITH LOCK ON MFI
DITMS MFFREF		;REFERENCE COUNT INCREMENTED BY INFERIOR MFI'S
			;AND FA CAPS
DITMS MFPBRF		;REFERENCE COUNT INCREMENTED BY FPBS
DITMS MFELN		;ACTUAL LENGTH OF THE ITEM IN BYTES
DITMS MFENDB		;DISK ADDRESS OF LAST BLOCK IN THE FILE, SET BY MUTATE AND RESET WHEN BLOCK ADDED
DITMS MFENDT		;DISPATCH ADDRESS FOR TYPE OF LAST REAL BYTE
DITMS MFENDP		;POINTER TO LAST REAL BYTE
DITMS MFIDLN		;NUMBER OF BLOCKS CURRENTLY ALLOCATED TO DIRECTORY
DITMS MFIUCF		;BYTES IN DIRECORY NOT COMMITED TO EXITANT MFI'S
DITMS MFICBY		;BYTES COMMITTED FOR US IN THE DIRECTORY ABOVE
DITMS MFDISK		;DISK THE FILE/DIRECTORY IS ON
DITMS MFDLNK		;LINK TO OTHER OPEN FILES ON THIS DISK
DITMS MFIUPT		;SLOT FOR SYSTEM TO STORE FUPT
DITMS MFIPB		;FIRST IN LIST OF LINKED FPBS
DITMS MFIFNO		;FILE NUMBER IN DIRECTORY
DITMS MFBAKP		;ITEM NUMBER OF PARENT MFI IF A FILE
DITMS MFLAGW		;BOTTOM BYTE IS LOGICAL DSK #
.FALNK==100000		;USER REQUEST FOR A LINK
			;BIT SET IF DIRECTORY
.FADIR==40000		;USER REQUEST FOR DIRECTORY
			;ROOT DIR. BIT
.FARUT==10000		;USER REQUEST FOR ROOT DIRECTORY
			;LOCKED BY USER BIT
.FALOK==4000		;USER REQUEST TO LOCK MFI
MFEBMB==2000		;ENTRY BEEN MUNGED
MFIBEB==1000		;MFI BEING ENLARGED BIT
MFOPNB==400		;FILE BEING OPENED BIT
MFDWDB==200		;DELETE WHEN DONE BIT
MFTMPF==100		;TEMPORARY FILE
MFNODR==40		;NO ENTRY IN DIR FOR THIS YET
MFELEN==FOO		;EXACT LEGNTH IN BYTES OF OVERHEAD
DITMS MFENHD		;ENTRY HEADER
DITMS MFVERN
DITMS MFPGNO		;EOF PAGE NUMBER
DITMS MFBYTP		;EOF BYTE POINTER
DITMS MFDATE		;FILE DATE
DITMS MFTIME		;AND TIME
DITMS MFNAME		;START OF NAME IF NO ACCESS CODES
DITMS MFDUM,12		;SPACE TO INTIALLY ALLOCATE FOR ENTRY
MFPARE==0		;BITS IN ENTRY HEADER FLAG WORD
MFDIRE==1000
MFFILE==2000
;TYPE 3000 IS UNUSED
MFSLFE==4000
MFLNKE==5000
;TYPES 14 AND 16 ARE UNUSED

MFEOFB==100000		;SET IF EOF DATE AND TIME WORDS EXIST
MFACCB==40000		;SET IF ACCESS CODE EXIST
			;BIT 20000 IS UNUSED
MFSHRB==10000		;SET IF BLOCKS SHARED WITH OTHER FILE
			;BITS 7000 ARE USED BY ENTRY TYPES
MFLSTB==400		;SET IF EOF WORD POINTS TO EXISTING BLOCK
DITMSZ MFLEN

;DEFINITION OF CORE LINK ITEM, (WHEN A PAGE, IT LOOKS THE SAME)
SITEMD ITCL
DITMS CLREF		;THE REFERENCE COUNT
DITMS CLCONP		;POINTER TO THE CONSUMER
DITMS CLCNT		;THE AMOUNT OF VALID DATA IN ITEM
DITMS CLNUM		;THE NUMBER OF SLOTS IN THE BUFFER
DITMS CLDATI		;POINTER TO DATA IN
DITMS CLDATO		;POINTER TO DATA OUT
CLDATL==FOO		;THE LENGTH OF THE DATA WORDS



;DEFINITION OF A FONT ITEM
SITEMD ITFNT
DITMS FNTREF		;NOT REALLY USED FOR ANYTHING
DITMS FNWIDE		;WIDTH OF THIS FONT
DITMS FNHIGH		;HEIGHT OF THIS FONT
DITMS FNTEND		;POINTER TO THE END OF THE FONT
DITMS FNTLCL		;THE NUMBER OF TV LINES IN ONE CHAR LINE
DITMS FNMSK		;A RIGHT ADJUSTED MASK FOR CHARS IN THIS FONT
;THE SYSTEM COMPUTES THE NEXT 2 VARIABLES WHEN THE ITEM IS CREATED
DITMS FNLINE		;THE NUMBER OF CHAR LINES THAT FIT ON A SCREEN
DITMS FLFINC		;NUMBER OF BYTES IN ONE CHAR LINE
DITMS FNREM		;THE NUMBER OF BYTES AFTER LAST SCREEN LINE. MAY BE NEGATIVE.
DITMS FNLINL		;THE NUMBER OF CHARS PER LINE
DITMS FNLSC		;THE NUMBER OF LINES TO SCROLL
;VARIOUS PRECOMPUTED VARIABLES GO HERE
FOO==40			;THE DISPATCH TABLE ALWAYS STARTS AT 40
DITMS FNTPNT,400	;AND IS 128. WORDS LONG

;DEFINITION OF THE PAPER TAPE READER ITEM
SITEMD ITPTR
;DON'T CHANGE THE ORDER BELOW!
DITMS PTRREF		;REFERENCE COUNT
DITMS PTRDAI		;POINTER TO WHERE DATA GOES IN
DITMS PTRDAO		;POINTER TO WHERE DATA COMES OUT
DITMS PTRNO		;NUMBER OF BYTES IN BUFFER
DITMS PTRBUF,PTRSZ	;BUFFER FOR PAPER TAPE READER
PTREND==FOO		;TOP OF BUFFER
DITMSZ PTRLEN

;DEFINITION OF THE PAPER TAPE PUNCH ITEM
SITEMD ITPTP
;DON'T CHANGE THE ORDER BELOW!
DITMS PTPREF		;REFERENCE COUNT
DITMS PTPDAI		;POINTER TO WHERE DATA GOES IN
DITMS PTPDAO		;POINTER TO WHERE DATA COMES OUT
DITMS PTPNO		;NUMBER OF BYTES
DITMS PTPBUF,PTPSZ	;BUFFER FOR DATA
PTPEND==FOO		;TOP OF THE BUFFER
DITMSZ PTPLEN

LPTBSZ==512.
PLTBSZ==4096.
LINSIZ==264.	;THE NUMBER OF BYTES IN A PLODDING LINE
;DEFINITION OF A LINE PRINTER ITEM.
SITEMD ITLPT
;DON'T CHANGE THE ORDER BLEOW WITHOUT CHECKING THE CCPRLP ROUTINE
DITMS LPTREF	;REFERENCE COUNT
DITMS LPTEND	;POINTER TO THE END OF THE BUFFER
DITMS LPTLCT	;NUMBER OF TIMES TO OUTPUT THIS LINE
DITMS LPTMOD	;ZERO IF IN PRINT MODE, OTHERWISE THE SCALE FACTOR FOR PLODDING
DITMS LPTCSR	;CONTAINS THE CONTROL STATUS REGISTER OF THE CURRENT MODE
DITMS LPTDAI	;POINTER TO WHERE DATA GOES IN
DITMS LPTDAO	;POINTER TO WHERE DATA COMES OUT FROM
DITMS LPTNUM	;NUMBER OF CHARACTERS IN THE BUFFER
DITMS LPTWCT	;THE NUMBER OF BYTES TRANSFERED IN THIS TRANSFER
DITMS LPTPCT	;COUNT OF PLOT BYTES TO GO INTO THIS LINE
DITMS LPTPIT	;PROCESS TO ACTIVE
DITMS LPTPI1	;ID WORD 1 OF PROCESS
DITMS LPTPI2	;ID WORD 2 OF PROCESS
DITMS LPTBUF,LPTBSZ	;THE BUFFER
PRTEND==FOO	;THE END OF THE PRINTER BUFFER
DITMSZ PRTLEN	;LENGTH FO PRINTER ITEM
DITMS LPTBEX,PLTBSZ-LPTBSZ	;BUFFER EXTENSION FOR THE PLODDER
PLTEND==FOO	;THE END OF THE PLODDER BUFFER
DITMS LPTLBF,LINSIZ	;THE BUFFER FOR THE CURRENT PLODDER LINE
DITMSZ PLTLEN	;LENGTH OF PLODDER ITEM

.SBTTL ERROR DEFINITIONS

FOO==0

ERDEF NUL	;NO ERROR AT ALL
ERDEF APEF	;ACCESS PAST END OF FILE
ERDEF BAC	;BAD ACCESS
ERDEF BAD	;BAD ARGUMENTS TO CALL
ERDEF BCN	;BAD CAPABILITY NUMBER
ERDEF BCT	;BAD CAPABILITY TYPE
ERDEF BFN	;BAD FILE NAME
ERDEF BFUN	;BAD FUNCTION
ERDEF BPN	;BAD PAGE NUMBER
ERDEF CDD	;CAN'T DELETE NON-EMPTY DIRECTORY
ERDEF DEVE	;DEVICE ERROR
ERDEF DFL	;DISK FULL
ERDEF DRF	;DIRECTORY FULL
ERDEF EAE	;ENTRY ALREADY EXISTS
ERDEF FLOK	;FILE LOCKED
ERDEF FNF	;FILE NOT FOUND
ERDEF FNTL	;FILE NAME TOO LONG
ERDEF FTL	;FILE ENTRY TOO LONG
ERDEF NIS	;NO ITEM SPACE AVAILABLE
ERDEF NIT	;NO ITEM AVAILABLE
ERDEF NSS	;NO SWAP SPACE LEFT
ERDEF RNA	;RESOURCE NOT AVAILABLE
ERDEF RPEF	;ATTEMPT TO READ PAST END OF FILE
ERDEF SYS	;CALL MAY ONLY BE EXECUTED BY SYSSPR
ERDEF CLF	;C LIST IS FULL
ERDEF DSKE	;DISK ERROR (ONLY USED BY LSITS)
ERDEF DVBE	;DISK VERY BAD ERROR (ONLY LSITS)
	.SBTTL TRAP VECTORS
	.=0
	BPT
	.=4
	.REPT 77
	.+2
	BPT
	.ENDR

;TRAP VECTORS FOR INTERNAL DEVICES
TRAPV BE	;BUSS ERRORS
TRAPV ILL	;ILLEGAL INSTRUCTIONS
TRAPV BPT	;BREAKPOINTS
TRAPV IOT	;IOT
TRAPV PWF,7	;POWER FAILURE
TRAPV EMT	;EMT
TRAPV TRP	;TRAP
TRAPV PAR	;PARITY ERROR
TRAPV PIR,7	;PROGRAMMED INTERUPT
TRAPV FPP	;FLOATING POINT ERROR
TRAPV SEG	;SEGMENTATION ABORT OR TRAP

;TRAP VECTORS FOR OTHER DEVICES
TRAPV RF,5	;FIXED HEAD DISK
TRAPV RK,5	;MOVING HEAD DISK
TRAPV LC,6	;LINE CLOCK
TRAPV PC,6	;PROGRAMABLE CLOCK
TRAPV TK	;CONSOLE KEYBOARD
TRAPV TP	;CONSOLE PRINTER 
TRAPV PTR,4	;PAPER TAPE READER
TRAPV PTP,4	;PAPER TAPE PUNCH
TRAPV PRT,4	;LINE PRINTER IN PRINT MODE
TRAPV PLT,4	;LINE PRINTER IN PLOT MODE
.IIF NZ MBFLG,TRAPV MB,7	;MAR AND HISTORY REGISTER
;USER SYMBOLS FOR TRAP FAULTS
.IRP X,<BE,ILL,BPT,IOT,EMT,TRP,FPP,SLE,RDO,NXM>
.'X'TF==1+.IRPCN
.ENDM
	.=400
	.SBTTL SYSTEM VARIABLES AND TABLES
ZERO:	0	;DEFINED TO BE ZERO

ABSLD:
.OFFSET 160000-.
ABSLOD:	MOV #ABLDPD,P	;REINIT THE PDL POINTER
	CLR D
	MOV #20000,E
	CLR (D)+
	SOB E,.-2
	CLR ABSCNT
	;C IS CHECKSUM
	;D IS CORE ADDRESS
	;E IS BYTE COUNT
ABSLOP:	CLR C
	JSR PC,GBYTE
	CMPB #1,A	;IS IT THE START OF A BLOCK?
	BNE ABSLOP	;NO, TRY AGAIN
	JSR PC,GBYTE
	TST A
	BNE ABSLOP	;SHOULD BE A ZERO NEXT
	JSR PC,GWORD	;GET THE COUNT
	MOV A,E		;SAVE IT
	JSR PC,GWORD	;GET THE ADDRESS
	MOV A,D
	ADD E,A		;CHECK THAT WE AREN'T OVERLOADING
	CMP #40000,A
	BHI .+4		;MUST BE UNDER 8K
	BPT
	CMP #6,E	;IS IT THE START BLOCK?
	BEQ ABSSRT	;YUP
	SUB #6,E	;THAT MANY ALREADY LOADED
ABSLP1:	JSR PC,GBYTE
	MOVB A,(D)+
	SOB E,ABSLP1
	JSR PC,GBYTE	;THE CHECKSUM
	TSTB C
	BEQ ABSLOP	;CHECKSUM GOOD
	BPT		;BAD CHECKSUM
ABSSRT:	JSR PC,GBYTE	;GET CHECKSUM
	TSTB C
	BEQ .+4
	BPT		;BAD CHECKSUM
	CMP -(P),-(P)	;EXTRA WORDS
	SAVE <SYSFCP>
	BIS #.DELCP,(P)	;DELETE CAPABILITY TO FILE
	$INVOK
	JMP (D)

GBYTE:	DEC ABSCNT
	BLT GBYTE1
	MOVB @ABSPNT,A
	INC ABSPNT
	ADD A,C
	RTS PC
GBYTE1:	MOV #2000,ABSCNT	;A BARFER LOAD
	MOV #ABSBRF,ABSPNT
	SAVE <#ABSBRF,#-2000,SYSFCP>
	$BLKI
	BR GBYTE

GWORD:	JSR PC,GBYTE
	SAVE A
	JSR PC,GBYTE
	MOVB A,1(P)
	REST A
	RTS PC
SYSFCP:	0
ABSPNT:	0
ABSCNT:	0
ABLDPD==.+20
ABSBRF==ABLDPD
ABSEND==.
.OFFSET 0
;THE PDL MAY GROW DOWN HERE ON A POWER FAILURE
	.BLKW 100	;FOR THE SYSTEM PDL
.=<.&177700>+200		;MAKE A NICE NUMBER
PDL:
PARREG:	.BLKW 20	;FOR THE REAL PARITY REGISTERS
CHEKPN:	CHEKBG
CHEKBG:	.BLKW 20
CHEKEN::
SSTATS::	;THE SYSTEM STATUS BLOCK
	VERN	;SYSTEM VERSION
TIME:	.BLKW 2	;TIME IN 60TH'S SINCE SYS START
SVCSR:	0	;THE CONSOLE SWITCHES
LOOKSW:	0	;NON-ZERO=>PAY ATTENTION TO SWITCHES
NSTATS==<.-SSTATS>/2
;DON'T CHANGE ORDER OF THESE THINGS
FDATE:	-1	;FILE DATE
FTIME:	-1	;FILE TIME
SECNT:	1.	;HALF SECOND COUNTER
SECOND:	0	;CURRENT SECOND
MINUTE:	0	;MINUTE
HOUR:	0
DAY:	0
MONTH:	0
YEAR:	-1
MONS:	.BYTE 31.,28.,31.,30.,31.,30.,31.,31.,30.,31.,30.,31.
SECONL:	60.
MINUTL:	60.
HOURL:	24.
DAYL:	0	;SET FROM MONS
MONTHL:	12.
YEARL:	2000.	;SYSTEM LOSES IN YEAR 2000.
RESETT:	.WORD 0,0,0,1,1	;VALUES TO RESET TO
TSHIFT:	.WORD 4,5,5,6,5	;AMOUNT TO SHIFT BY
TIMCHK:	0	;IF NON-ZERO MAINTAIN LEVEL TABLE
LEVTAB:	.BLKW 8.	;LEVEL CLOCK INTERUPTED FROM
MFITST:	.FARUT!0		;DATA BLOCK TO MAKE ROOT DIR
MFIBIT:	ASCIZ <BITS>
MFISYS:	ASCIZ <. SYSSPR>
MFIDSC:	ASCIZ <DESCR>
	.EVEN
PATCH:
PAT:	.BLKW 140
SYSJPD:		;THE SYSTEM JOB'S PDL
BMT:	.BYTE 1,2,4,10,20,40,100,200	;BIT MARK TABLE
	;FOR MARKING BIT TABLES, THE NTH ENTRY IS THE NTH BIT
DECTAB:	.WORD 10000.,1000.,100.,10.,1,0
INITSW:	-1	;ZERO AFTER EXITING INIT CODE
PRUNNG:	-1	;ITEM # OF RUNNING PROCESS, NEG=> IN SYSTEM
			;(THIS IS NOT SET TO -1 BY INTERUPT ROUTINES)
USRMOD:	-1	;IF A PROCESS IS RUNNING, NON-ZERO=> IN SYSTEM CODE
			;0=>IN USER'S CODE
SYSSPR:	-1	;ITEM NUMBER OF THE SYSTEM SPHERE
CURUSR:	-1	;PROCESS BLOCK INDEX OF THE RUNNING PROCESS'S USER
CURSPH:	-1	;ITEM INDEX OF SPHERE OF THE RUNNING PROCESS
NEWPRI:	.BLKW 2	;PROCESS ID OF NEXT PROCESS TO BE CREATED
STPSVP:	0	;SAVED P WHEN WE WENT TO START A PROCESS (FOR ERROR RECOVERY)
BPCLSR:	0	;NON-ZERO WHEN IN PROCESS OF PCLSRING THE GUY GETTING UNLOCKED
QUANT:	0	;NUMBER OF TICKS BEFORE THE RUNNING PROCESS SHOULD BE STOPPED
PQUANT:	IQUANT	;QUANTUM TO GIVE A PROCESS WHEN YOU START IT
WQUANT:	IQUANT*2	;SAME, BUT FOR WINNERS
TUSED:	0	;TIME THE PROCESS HAS USED SINCE LAST STARTED
STIMER:	0	;TIME TILL NEXT CHECK OF SHORT FLUSHES
LTIMER:	0	;TIME TILL NEXT CHECK OF LONG FLUSES
JTMUUP:	JTMUUT	;NUMBER OF TICKS TILL NEXT UPDATE OF JTMUS
RUGVEC:	0		;STORING PLACE FOR RUG'S VECTOR
RUGSTA:	0		;DITTO FOR RUG'S STATUS
;SAVED VALUES FROM THE SEGMENTER
PSSR0:	0
PSSR1:	0
PSSR2:	0
PIRDIS:	.WORD PIRLOS,STOPPR,TTYBRK,DMRBRK,PIRLOS,PIRLOS,PIRLOS,PIRLOS	;THE PIR DISPATCH
PIRBIT:	.WORD 0,1000,2000,4000,10000,20000,40000,100000	;THE PIR BITS
;EMT DISPACTCH TABLES
FOO==0
;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
EMTDIS:
	EMTD NOOP	;NOP CALL
	EMTD FORK
	EMTD POOFF
	EMTD SLEEP
	EMTD SINK
	EMTD FLOAT
	EMTD INVOK
	EMTD QULK
	EMTD QUNLK
	EMTD TTGIV
	EMTD TTGET
	EMTD WRDI
	EMTD WRDO
	EMTD BYTI
	EMTD BYTO
	EMTD BLKI
	EMTD BLKO
	EMTD MAP
	EMTD ALLOC
	EMTD CRUSR
	EMTD RDMAP
	EMTD FONT
	EMTD SSTAT
	EMTD VIDSW
	EMTD RUG
	EMTD GERRW
	EMTD TIME
	EMTD SYSJB
	EMTD GETID
	EMTD MFPI
EMTHGH==FOO
.MACRO CLSTYD X
.'X'CAP==FOO
.=IVKCTB+<2*FOO>
	CAPR'X
.IRP Y,<CCPR,CPY,DEL,GIV,TAK,DOIO>
.=.+CAPHGH-2
	Y''X
.ENDM
.IIF P1,CAPHGH==CAPHGH+2
.=IVKCTB+<CAPHGH*7>	;7 IS THE NUMBER OF TABLES
FOO==FOO+1
.ENDM
.IIF P1,CAPHGH==0
FOO==0

;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
IVKCTB:

CLSTYD XX	;THE ZERO CAPABILITY SHOULD NOT EXIST
CLSTYD CC	;CREATE CAPABILITY
CLSTYD MS	;MASTER SPHERE
CLSTYD SP	;SPHERE (NON-MASTER I.E. COPY OF MASTER)
CLSTYD PR	;PROCESS CAPABILITY
CLSTYD TT	;TELETYPE CAPABILITY (NO DATA WORDS)
CLSTYD FA	;FILE ACCESS CAPABILITY
CLSTYD QU	;THE QUE CAPABILITY
CLSTYD CL	;CORE LINK CAPABILIY
CLSTYD DS	;DISPLAY CAPABILITY
CLSTYD TR	;PAPER TAPE READER
CLSTYD TP	;PAPER TAPE PUNCH
CLSTYD LP	;LINE PRINTER CAPABILITY
CLSTYD CM	;COLOR MAP

;FIRST ITEM IS THE SPHERE
;SECOND IS SPHERE (IF ANY) IN CIRCULAR LIST OF SPHERES HAVING SHPERE
;CAPABILITY TO THIS SPHERE
;FIRST MISC IS FAULT ENTRY ADDRESS
;SECOND MISC IS C-LIST NUMBER (IF ANY) FOR CIRCULAR LIST
;BITS ARE:
.SPFES==4000	;SURPRESS ENTERS THROUGH HERE
.SPCLC==10000	;ALLOW COPY FROM C-LIST
.SPCLD==20000	;ALLOW DELETE FROM C-LIST
.SPCRR==400	;ALLOW CORE READ
.SPCRW==1000	;ALLOW CORE WRITE
.SPCRE==2000	;ALLOW CORE EXECUTE
	;THESE FLAGS ARE FOR EMAP, DIFFERENT NAMES, SAME FUNCTION
	.CRPRI==4000	;PRIVATE PAGE
	.CRRD==.SPCRR
	.CRWRT==.SPCRW
	.CREX==.SPCRE
.SPCAD==40000	;ALLOW C-LIST APPEND
MSPCBT==.SPCAD!.SPCLC!.SPCLD!.SPCRR!.SPCRW!.SPCRE	;ALL SET IN SPHERE

;SAME PROPERTIES AS MASTER SPHERE, EXCEPT SOME BITS MAY NOT BE SET
;AND THERE IS NO ENTRY ADDRESS
;HERE ARE THE FUNCTIONS FOR THE .SPCAP AND .MSCAP INVOK'S
.SPPTT==0	;PUT THE PROCESS INTO SPHERE
.SPCLR==1	;READ THE C-LIST

;WORDS ARE ASSIGNED AS IN MASTER SPHERE AND ENTER ADDRESS IS STARTING ADDRESS
;BITS ARE:
.PRWRA==10000	;ALLOW WRITING OF INFORMATION

;FLAGS ARE
.TTYO==10000	;ALLOW OUTPUT TO TTY
.TTYI==20000		;ALLOW INPUT FROM TTY

FAMFI==2	;FIRST WORD IS MFI PTR
FAFPN==4	;SECOND IS FILE PAGE NUMBER
FAUPT==6	;THIRD IS GIP FOR FUPT
FAFBP==10	;FOURTH IS BYTE PTR IN FILE PAGE (SEE 2ND WORD)

.FAEOFB==1000	;SET IF THE POINTER IS IN THE LAST BLOCK OF THE FILE
.FAWD==2000	;SET IF FIRST BYTE OF DKWDO IS WRITTEN
.FARD==4000	;FILE READ ACCESS
.FAWT==10000	;FILE WRITE ACCESS
.FAAP==20000	;FILE APPEND ACCESS
.FAAC==40000	;ACCESS CODES ACCESS
.FALB==100000	;LOCK BIT

		;NO FLAGS

;FIRST ITEM IS GIP TO THE BUFFER
;FLAGS ARE
.CLCONS==400	;I AM THE CONSUMER FLAG

;IT HAS AN ITEM IF IT IS A TV DISPLAY, THE ITEM WORD IS 0 IF TV.
;THE FIRST MISCELLANEOUS WORD IS THE INDEX OF THE DISPLAY. FOR
;TK DISPLAYS, THIS NUMBER IS THE WORD INDEX INTO THE TKD TABLES.
;FOR TV DISPLAYS, IT IS STILL A WORD INDEX, AND SINCE THE TV TABLES
;ARE BYTE TABLES, THE NUMBER MUST BE DIVIDED BY 2 AND HAVE NFTVDS
;SUBTRACTED FROM IT BEFORE USE.

;NO FLAGS, ITEM IS THE PTR ITEM

;NO FLAGS, ITEM IS PTP ITEM

;NO FLAGS, ITEM IS THE LPT ITEM

;NO ITEM, THESE ARE FLAGS FOR CALLS:
.CMRED==2000	;SET RED
.CMGRN==1000	;SET GREEN
.CMBLU==400	;SET BLUE
.CMBIT==100000	;SET BIT COORESPONDENCE
	;DISPATCH TABLES
FOO==IVKCTB
.IRP X,<CC,CPY,DEL,GIV,TAK,DOI>
FOO==FOO+CAPHGH
X'TAB=FOO
.ENDM

	;GENERAL FUNCTIONS FOR INVOKE
.MACRO GENFUN NAME
	NAME'CAP
	.'NAME'CP==400*<200+FOO>
	FOO==FOO+1
.ENDM

FOO==0
GENDIS:	GENFUN DEL	;DELETE THE CAPABLITY
	GENFUN CPY	;COPY THE CAPABILITY
	GENFUN GIV	;GIVE THE CAPABILIITY AWAY
	GENFUN TAK	;TAKE THE CAPABILITY (GIMMEE,GIMMEE)
GENHGH==FOO*2

;THIS IS THE DISPATCH TABLE FOR I-O DEVICES

.IRP OP,<WDI,WDO,BTI,BTO,BKI,BKO>	;INITIALZE TABLES FOR THESE TRANSFER TYPES
OP'TAB:
.IRP DEV,<DK,TT,CL,TR,TP,LP>
DEV'IDX==.IRPCN
	DEV''OP
.ENDM
.ENDM

;THESE ARE THE TABLES FOR THE PROCESS INVOK
.MACRO PRINVK FUN,CNT
.PR'FUN==FOO
.IFB CNT
FOO==FOO+1
PR'FUN
.IFF
FOO==FOO+CNT
.REPT CNT
PR'FUN
.ENDR
.ENDC
.ENDM

FOO==0
PRIVTB:	PRINVK REG,8	;8 REGISTERS
	PRINVK PSW	;PROGRAM STATUS WORD
	PRINVK FREG,6	;6 FLOATING POINT REGISTERS
	PRINVK FPST	;FLOATING POINT STATUS WORD
	PRINVK FPEN	;ENABLE FLOATING POINT
	PRINVK STOP	;THE STOP WORD OF THE PROCESS
	PRINVK ERR	;THE ERROR WORD
	PRINVK FAUL	;THE FAULT WORD (OR WORDS)
	PRINVK ERA	;ERROR ADDRESS IN SYSTEM
PRHGH==FOO*2
.PRRD==0		;THE READ FUNCTION
.PRWRT==40		;THE WRITE FUNCTION

.MACRO SPINVK FUN
.SP'FUN==FOO
FOO==FOO+1
SP'FUN
.ENDM
FOO==0

SPITAB:	SPINVK PTP	;PUT PROCESS
	SPINVK RCP	;RETURN CAPABILITY
	SPINVK KIL	;KILL ALL PROCESSES
	SPINVK STP	;STOP ALL PROCESSES
	SPINVK STR	;START ALL PROCESSES
	SPINVK PGT	;GET ID AND PC OF PROCESS
	SPINVK GNP	;GET NUMBER OF PROCESSES
	SPINVK GPC	;GET CAPABILITY TO PROCESS
	SPINVK ENT	;SET THE ENTER ADDRESS
	SPINVK STX	;SET X OF MAR
	SPINVK STY	;SET Y OF MAR
	SPINVK SMC	;SET MAR CONTROL REGISTER
SPIHGH==FOO

;FOR THE TTY INVOK
.MACRO TTIVK FNC
.'FNC==NTTFNC
FNC
NTTFNC==NTTFNC+1
.ENDM

.TTWRT==40
.TTIBK==400		;TTY I/O FLAG SPECIFING AN INPUT TYPE BREAK
.TTMBK==10000		;TTY FLAG SPECIFYING A MORE BREAK
.TTWD==40000		;FLAG SAYING THAT FIRST BYTE DONE ON WORD OUTS
.TTEDM==1000		;SAYING THAT THIS OUTPUT IS TO GO TO THE EDIT BUFFER

NTTFNC==0
;THESE FUNCTIONS WRITE IF THE .TTWRT BIT IS SET AND READ OTHERWISE
TTIVTB:	TTIVK TTMOV	;MOVE INTO TTY STATUS WORD (ALWAYS WRITE)
	TTIVK TTBIS	;BIS INTO TTY STATUS (ALWAYS WRITE)
	TTIVK TTBIC	;BIC INTO TTY STATUS (ALWAYS WRITE)
	TTIVK TTRD	;READ THE TTY STATUS (ALWAYS READ)
	TTIVK TTCNO	;READ OR SET THE CHARNO VARIABLE 
	TTIVK TVATC	;ATTACH A DISPLAY BUFFER TO A TTY
	TTIVK TVCL	;CLEAR THE SCREEN
	TTIVK TTBRK	;READ THE LAST BREAK CHAR TYPED, HANG IF NONE
	TTIVK TVREV	;REVERSE WHITE AND BLACK ON SCREEN
	TTIVK TTMV2	;SET TTYST2
	TTIVK TTSPD	;SET THE SPEED AND LINE PARAMETERS (DH11 ONLY)
	TTIVK TTTYP	;RETURN THE TYPE OF THE TTY TO THE USER
	TTIVK TVFNT	;CHANGE THE FONT OF THE TV TTY
	TTIVK TTBS2	;BIS INTO TTY STATUS 2
	TTIVK TTBC2	;BIC INTO TTY STATUS 2
	TTIVK TVSET	;READ OR SET TVLINE AND TVCUR
	TTIVK TVOFF	;READ OR SET TVOFFL
	TTIVK TVRFN	;READ CHAR WIDTH IN BITS AND LINE HEIGHT IN TVLINES
	TTIVK TTPEK	;PEEK AT THE NEXT CHARACTER
	TTIVK TVMOD	;SET THE CURSOR WRITING MODE
	TTIVK TBRAK	;CAUSE BREAK ON LINE FOR (ARG) NUMBER OF CHARACTERS
	TTIVK TTSLNL	;SET LINE LENGTH

;THE TV WRITING MODES
.TVIOR=TVIOR_-6
.TVXOR=TVXOR_-6
.TVMOV=TVMOV_-6


.IFNZ NTVS
.MACRO TDSIVK FUNCTION
	.WORD FUNCTION
.'FUNCTION==TVDSIM+100
TVDSIM==TVDSIM+1
.ENDM

TVDSIM==0
;TV DISPLAY INVOKES
TVDSIT:	TDSIVK TVDSRC		;READ THE CURSOR
	TDSIVK TVDSSC		;SET THE CURSOR
	TDSIVK TVDSNL		;DRAW A NULL LINE
	TDSIVK TVDSIL		;IOR A LINE
	TDSIVK TVDSXL		;XOR A LINE
	TDSIVK TVDSCL		;CLEAR A BLOCK OF THE SCREEN
	TDSIVK TVSAVE		;SAVE TV REGISTERS FOR THIS PROCESS
	TDSIVK TVMAPS		;MAP IN TV PAGES FOR THIS PROCESS

;VIDEO SWITCH MODES
.VIABS==0	;ABSOLUTE MODE
.VILOT==1	;LOGICAL TTY NUMBER MODE
.VILOD==2	;LOGICAL DISPLAY NUMBER MODE
.VICAM==3	;CAPABILITY MODE
.ENDC

.IRPC X,<012>
ITEM'X:		-1		;ITEM CURRENTLY IN PAGE ITM0
ITM'X'PB:	0		;IF ITEM IS A GIP, THIS IS THE PB FOR IT
ITM'X'A:	ITM'X'AD	;ADDRESS OF ITEM IN ITEM'X
ITM'X'D:	0		;PUSH DEPTH
ITM'X'P:	ITM'X'PD	;PDL POINTER FOR ITM'X
	.BLKW NITMPS		;PDL FOR ITM'X'
ITM'X'PD::
.ENDM

ITMATB:	.BLKW 200	;ITEM ALLOCATE TABLE (ONE WORD PER SIZE)
			;THESE POINT INTO ITMALS
ITMBAL:	.BLKW 1		;ITEM BLOCK STORAGE ALLOCATE LOCK
INITM1::		;INITIALIZE FOLLOWING AREA TO -1
ITMBNF:	.BLKW NITMBL	;NUMBER OF BLOCKS FREE IN THIS BIG BLOCK
ITMBST:	.BLKW NITMBL	;ADDRESS OF FIRST BLOCK OF THIS BIG BLOCK
ITMBTP:	.BLKW NITMBL	;POINTERS TO BEGGININGS OF BIT TABLES
	.BLKW 1		;THIS IS THE BACKWARDS-SEARCHING FENCE FOR THE 1ST BIT TABLE
ITMBIT:	.BLKW 11*NITMBL	;8 WORD BIT TABLE FOR EACH BIG BLOCK
				;AND A FENCE BETWEEN THE BLOCKS
EINTM1::	;END OF STUFF TO INIT TO -1
;TABLES AND SYMBOLS FOR THE FILE SYSTEM

;MACRO TO DEFINE FILE ACCESS CAPABILITY FUNCTIONS
.MACRO MFADCF SYMBOL
.FA'SYMBOL==FOO
MFA'SYMBOL
FOO==FOO+1000
.ENDM
FOO==0
FATAB:
MFADCF CF			;CLEAR FLAGS
MFADCF RE			;RETURN EOF WORDS
MFADCF SP			;SET POINTER
MFADCF RP			;RETURN POINTER
MFADCF DL			;DELETE ENTRY
MFADCF AD			;ADD ENTRY
MFADCF MU			;MUTATE CAPABILITY
MFADCF MB			;SET UP BIT TABLE FOR ROOT DIR
MFADCF RI			;RETURN INFORMATION ABOUT THE FILE
MFADCF DI			;RETURN INFORMAITON ABOUT THE DISK
MFADCF SDL			;DELETE THE FILE OR DIRECTORY, EVEN IF STUFF IN DIR
MFADCF MD			;MAKE A DIRECTORY
MFAHGH==<FOO-1000>/400

;STUFF FOR GROVELING THROUGH DESCRIPTORS
MFBLTB:	MFBSKP	;SKIP AND GRAB ONE
	MFBGET	;GET LOTS
	MFBSET	;SET ADDRESS AND GRAB LOTS
	MFBSKG	;SKIP SOME, GRAB SOME
MFENTB:	MFESKP	;SKIP AND GRAB ONE
	MFEGET	;GET LOTS
	MFESET	;SET ADDRESS AND GRAB LOTS
	MFESKG	;SKIP SOME, GRAB SOME
ENTPNT:	0	;POINTER INTO MFI
ENTEND:	0	;END OF MFI ENTRY
ENTCNT:	0	;COUNT FOR COUNT TYPES
ENTMOD:	0	;MODE OF CURENT BYTE, USED FOR ADDING A BLOCK
.SBTTL PROCESS QUEUES
	;FOR THE PROCESS TABLE
;MACRO FOR DEFINING A QUEUE
.MACRO DEFQ NAME
NAME'Q:	.BLKW 2
NAME'QB==1_FOO
	1_FOO
FOO==FOO+1
.ENDM
QLEN==6		;THE LENGTH OF A QUEUE POINTER
QBIT==4		;POSITION OF QUEUE BIT WITHIN THE POINTER
FOO==0		;INITALIZE THE QUEUE NUMBER
FIRSTQ==.
DEFQ WIN	;GUYS WHO ARE REAL WINNERS
DEFQ ACT	;GUYS WHO ARE MODERATE WINNERS
DEFQ DOR	;MODERATE WINNERS WHO ARE HUNG
DEFQ RUN	;GUYS WHO WANT TO RUN BUT ARE LOSERS
DEFQ IACT	;GUYS WHO ARE HUNG AND ARE LOSERS
DEFQ STOP	;GUYS WHO ARE STOPPED
DEFQ USER	;FOR CONFORMITY, USERS ARE KEPT HERE
DEFQ SPHR	;FOR CONFORMITY SPHERES ARE KEPT HERE
NQS==FOO
PFREQB==1_FOO
PFREEQ:	.WORD PRSTAB,0,PFREQB	;FREE PROCESS BLOCKS LIST POINTER
FOO==PRSTAB+PRSTEL
FOOBAR==PFREEQ
PRSTAB:	.REPT NPROSS
	FOO
	FOOBAR
FOO==FOO+PRSTEL
FOOBAR==.-4
	.=.+PRSTEL-4
	.ENDR
	.WORD 0,FOOBAR
	.BLKB PRSTEL-2	;THE LAST PROCESS BLOCK MUST GO HERE

DTHING		;THE PROCESS ACTIVATE BLOCKS
DWORD ACTLNK	;LINK WORD
DWORD ACTITM	;PROCESS ITEM
DWORD ACTPI1	;ID WORD 1
DWORD ACTPI2	;ID WORD 2
ILISTS ACTFRE,,10.	;TEN OUGHT TO BE PLENTY
ACTLST:	0	;LIST TO ACTIVATE
PTRITM:	0		;PAPER TAPE READER ITEM NO.
PTPITM:	0		;PAPER TAPE PUNCH ITEM NO.
LPTITM:	0	;CONTAINS ITEM NO OF THE LINE PRINTER ITEM
CMUSE:	0	;COUNT OF COLOR MAP CAPS

.SBTTL RANDOM DISK PARAMETERS
NRRKD==4	;NUMBER OF REGULAR RK11S
NRFD==0		;NUMBER OF RF11 DISKS

NDISKS==NRRKD+NRFD	;TOTAL NUMBER OF DISKS

NSWPA==NDISKS	;MAX NUMBER OF DISK SWAP AREAS

MNRTY==50.	;NUMBER OF TIMES TO RETRY OPERATION

NDRQBL==20	;NUMBER OF LOW LEVEL DISK REQUEST BLOCKS TO ALLOCATE

;LOW LEVEL DISK REQUEST BLOCKS
DTHING
DWORD DRQLNK	;LINK WORD
DWORD DRQDNO	;DISK NUMBER
DWORD DRQHCA,DRQFUN	;HIGH CORE ADDRESS,,FUNCTION (ALSO GETS ERROR BIT)
DRQFER==100000	;INT ROUTINES SET THIS BIT TO INDICATE ERROR
DWORD DRQCA	;CORE ADDRESS (LOW PART)
DWORD DRQDA	;DISK BLOCK ADDRESS
DWORD DRQWC	;WORD COUNT
DWORD DRQABL	;PAGE REQUEST BLOCK TO ACTIVATE
ILISTS DSKRFL,,NDRQBL	;ALLOCATE NDRQBL OF THESE BLOCKS

;MIDDLE LEVEL DISK REQUEST BLOCKS
DTHING
DWORD DMRLNK
DWORD DMRPBP	;PAGE BLOCK POINTER
		;NEXT 3 MUST STAY IN THIS ORDER
DWORD DMRPWK	;ITEM OF PROCESS TO WAKE UP
DWORD DMRPW1	;ID WORD 1 OF PROCESS TO WAKE UP
DWORD DMRPW2	;ID WORD 2 OF PROCESS TO WAKE UP
DWORD DMRFUN	;FUNCTION
DWORD DMRDRC	;COUNT OF DISK REQUESTS ENTERED FOR THIS BLOCK
DWORD DMRPBB	;PB BIT(S) TO CLEAR ON COMPLETION OF REQUESTS
ILISTS DMRPNT,,10.	;ONLY 10 OF THESE=> MAX OF 10 PAGES MOVING AT ONCE
.SBTTL CORE DATA STRUCTURE DEFINITIONS

;DEFINITION OF A PAGE BLOCK
DTHING
DWORD PBFLAG	;WORD OF RANDOM FLAGS, USED AS LINK IN FREE LIST
DFLAGS
DFLAG PBUSED	;MUST BE THE 1 BIT-SET IF USED
DFLAG PBZERO	;THIS PAGE WANTS TO BE ZERO
DFLAG PBWCHK	;THIS PAGE SHOULD ALWAYS BE WRITE-CHECKED
DFLAG PBVAS	;PAGE IS VALID AT SOURCE
DFLAG PBVASS	;PAGE IS VALID AT SWAP SPACE
DFLAG PBVACR	;PAGE IS VALID AT CORE
DFLAG PBFILE	;PAGE IS A FILE PAGE
DFLAG PBSTS	;PAGE SHOULD BE SWAPPED TO SOURCE
DFLAG PBDISK	;PAGE HAS DISK TRANSFER(S) PENDING
DFLAG PBLOCK	;HANDS OFF!
DFLAG PBERR	;PAGE IN ERROR DUE TO DISK LOSSAGE
DFLAG PBNOSW	;NEVER ASSIGN SWAP SPACE
DWORD PBLKPC	;TEMP WORD, PC PB LOCKED FROM
DWORD PBLKPS	;TEMP WORD, PROCESS THAT LOCKED PB
DWORD PBGIP	;GIP IN TH ECIRC LIST OF GIPS FOR THIS PAGE
DWORD PBCAR	;CORE ADDRESS, ZERO=>OUT
DWORD PBRAN,PBLEN	;RANDOM (START AND DISK #),,LENGTH
PBSTRT==177770	;MASK FOR START
PBDSKM==177407	;MASK FOR DISK
PBDISS==2	;DISK SHIFT (LOW ORDER BIT OF DISK IS 0)
DWORD PBDA	;START OF SWAP AREA ADDRESS
DWORD PBAUSR	;NUMBER OF ACTIVE USERS OF THIS PAGE
ILISTS PBFREL,,50.	;ALLOW FOR 50 DIFFERENT PAGES TO EXIST
;THE FOLLOWING IS THE EXTENSION OF PAGE BLOCKS TO FILE PAGE BLOCKS
DWORD PBSDSK	;THE DISK THE SOURCE IS ON
DWORD PBSDA	;THE SOURCE DISK ADDRESSES (8 OF THEM)
FOO==PBSDA+20	;ALLOCATE THEM
DWORD PBFLEN,PBNEWB	;LENGTH OF PAGE IN BLOCKS, # OF NEW BLOCK
DWORD PBFLNK	;LINK BETWEEN PBS FOR THIS FILE
DWORD PBFPNO	;PAGE NUMBER IN FILE THAT THIS FPB IS FOR 
DWORD PBMFIP	;POINTER BACK TO MFI FOR THIS FPB
ILISTS FPBFRE,,50.	;ALLOW FOR 50 FILE PAGES

;DEFINITION OF A UPT OR FUPT
DTHING
DWORD UPTFLG,UPTSTL	;FLAGS, START AND LENGTH
DFLAGS
DFLAG UPTEXB		;THIS PAGE EXISTS!
DFLAG UPTABS		;ABSOLUTE PAGE
DFLAG UPTEXD		;EXPAND DOWN
DFLAG UPTRDO		;READ ONLY
DFLAG UPTEXO		;EXECUTE ONLY
DFLAG UPTIED		;I=D, THIS SET IN THE I SPACE PAGE
DFLAG UPTDEI		;D=I, THIS SET IN THE DATA PAGE
UPTLMS==177770		;LENGTH
UPTSMS==177617		;START
UPTSSH==4		;SHIFT FOR START
DWORD UPTPBP		;POINTER TO PAGE BLOCK (AR OF ABS PAGE)
DWORD UPTGIP		;CIRCULAR LIST POINTER (DR OF ABS PAGE)
UPTLEN==FOO		;LENGTH OF UPT
;FOR FUPTS ALSO HAVE:
DWORD FUPTPR		;POINTER TO PROCESS THAT CURRENTLY "OWNS" THIS FUPT
ILISTS FUPTFR,,50.	;ALLOCATE 50 FUPTS

;LIST FOR DELETEING UPT OR FUPTS
DTHING
DWORD DLULNK	;LINK WORD
DWORD DLUUPT	;UPT TO DELETE
ILISTS DLUFRE,,10.
DLULST:	0	;DLU LIST TO ACT ON
.SBTTL DISK RANDOM STORAGE
DSKPS:	0	;PDL POINTER SAVE FOR ERROR CHECK
DSKPSV:	0	;PDL POINTER SAVE FOR MAIN PROG PDL POINTER
DSKP:	DPDL-14	;PDL POINTER FOR DISK ROUTINES
	.BLKW 100	;DPL STORAGE FOR DISK
DPDL:	DSTART	;CAREFULLY INITED PDL

DSKRQ:	0	;POINTER TO LIST OF PENDING REQUESTS
DRQDL:	0	;POINTER TO LIST OF DONE REQUESTS
DRQFCN:	NDRQBL	;NUMBER OF FREE DISK REQUEST BLOCKS
DMRLST:	0	;MIDDLE LEVEL DISK REQUEST LIST

DISKER:	.BLKW NDISKS	;ERRORS ON EACH DISK
DSKOFS:	.REPT NRRKD
	.RPCNT_13.
	.ENDR
DSKRQS:			;SERVICE ROUTINES FOR THE VARIOUS DISKS
	.REPT NRRKD
	RKDSKS
	.ENDR

DSKREA==0	;READ
DSKWRT==2	;WRITE
DSKWCH==4	;IF THIS BIT IS SET, WRITE-CHECK AFTER READ OR WRITE
DKWCH==10	;THE INDEX OF THE WRITE CHECK FUNCTION

RKFUN:	105	;READ
	103	;WRITE
	105	;READ W DSKWCH SET
	103	;WRITE W DSKWCH SET
	107	;WRITE CHECK

NRETRY:	0		;NUMBER OF DISK RETRYS BEFORE GIVIN GUP
DERBL:	.BLKW 10	;PLACE WHERE THE LAST ERROR IS STORED
CURDSK:	RKCS		;CS OF THE CURRENTLY RUNNING DISK
MFBITS:	.BLKW NDISKS	;FUPTS OF BIT TABLES
MFFREE:	.BLKW NDISKS	;COUNT OF FREE BLOCKS
MFBLNK:	.BLKW NDISKS	;LINK THROUGH MFI'S ACTIVE ON THIS DISK
MFROVR:	.BLKW NDISKS	;ROVING POINTER INTO BIT TABLE

;FILE NAME BLOCKS
FNBNML==20.	;MAX CHARS IN A FILE NAME
DTHING
DWORD FNBFNE	;END OF THE FILE NAME IN THE USER
DWORD FNBVER	;VERSION NUMBER OF THE FILE NAME
DWORD FNBFNO	;NUMBER O FFILE IN DIR
DWORD FNBFNL	;LENGTH OF FILE NAME
DWORD FNBFN	;ACTUAL FILE NAME
FOO==FNBFN+FNBNML	;ALLOCATE ENOGUH SPACE FOR FILE NAME
ILISTS FNBFRE,,4	;SHOULDN'T NEED VERY MANY
.SBTTL RANDOM STORAGE FOR SWAP AREA INFO
SWPBPT:	SWPBIT		;POINTERS TO THE SWAP AREA BITS TABLES
	.BLKW NSWPA
SWPBDK:	.BLKW NSWPA	;DISK NUMBER FOR THIS SWAP AREA
SWPBDA:	.BLKW NSWPA	;BEGGINING DISK ADDRESS FOR THIS SWAP AREA
SWPEDA:	.BLKW NSWPA	;ENDING DISK ADDRESS FOR THIS SWAP AREA
SWPFCN:	.BLKW NSWPA	;NUMBER OF FREE SWAP BLOCKS IN THIS SWAP AREA
SWPBIT:	.BLKW 105	;ACTUAL SWAPPING BIT TABLES
SWPBTE::		;END OF BIT TABLES

BITS:	.WORD 1,2,4,10,20,40,100,200
	.WORD 400,1000,2000,4000,10000,20000,40000,100000

BITSST:	.WORD 0,1,3,7,17,37,77,177,777,1777
	.WORD 3777,7777,17777,37777,77777,177777

MNCBLK==124.*2		;MAX NUMBER OF BLOCKS OF CORE TO WORRY ABOUT
.IIF NZ NTVS,MNCBLK==108.*2	;NOT AS MANY POSSIBLE IF TVS EXIST
.SBTTL RANDOM STORAGE FOR CORE INFORMATION
DFLAGS
DFLAG CSTFRB		;INDICATES BLOCK IS FREE
DFLAG CSTSYB		;INDICATES BLOCK USED BY SYSTEM
DFLAG CSTBEB		;THE BLOCK EXISTS BIT
CST:	.BLKW MNCBLK	;CORE STATUS TABLE
	0		;MAKE SURE THE TABLE HAS AN END
CSTPB:	.BLKW MNCBLK	;PB POINTERS FOR CORE USED BY PBS
FREECR:	0		;AMOUNT OF CORE THAT IS FREE
CSTROV:	CSTPB		;FOR LOGJAMS, PLACE TO SWAP A PAGE OUT
CST1FR:	CST+<FSTFRB*2>	;POINTER TO FIRST FREE CST ENTRY
CST1NS:	CST+<FSTFRB*2>	;POINTER TO FIRST NON-SYSTEM CST ENTRY
CSTTOP:	0		;POINTER TO LAST REAL WORD IN CST
USRCOR:	0		;AMOUNT OF CORE NOT USED BY SYSTEM
SYSUPD:	0		;NUMBER OF TIMES SYS JOB HAS DELETEED UPTS
LOGJAM:	0		;TIMES WHEN THERE WAS NOT ENOUGH CONGIOUS SPACE
			;TO PUT SOME SIZE PAGE, BUT THERE WAS MORE THAN
			;6K ACTUALLY FREE
NOFIT:	0		;NUMBER OF TIMES A PAGE COULDN'T FIT IN CORE
			;WHEN THERE WAS ENOUGH FREE
HSECNT:	30.		;60THS TILL TIME TO INC HSECS
HSECS:	0		;TIME IN .5 SECS, FOR SWAP DESICIONS
LTPSTA:	0		;LAST TIME PROCESS STARTED (IN .5 SEC)
ACTCHK:	0		;FLAG TO INDICATE CHECKING FOR ACTIVATING PROSSES
ACORE:	0		;AMOUNT OF CORE POTENITIALLY NEEDED BY ACTIVE PROCESSES
PBSWPO:	.BLKW 50.	;PAGES WHICH MAY BE SWAPPED OUT
PBSWOE:	0		;DUMMY END ENTRY
NPBSWO:	0		;NUMBER OF PBS ON SWAP OUT LIST
KERSBT:	.BLKB 16.*3	;KERNAL, NON-EX AND SUPER
	.REPT 16.	;USER
	.BYTE 1		;SEGBRK LEGAL ON ALL PAGES
	.ENDR
.IRPC X,<012>
ITM'X'KB==KERSBT+<<ITM'X'AR-I0AR>/2>	;BYTE FOR A PARTICULAR PAGE
.ENDM
.SBTTL ASSEMBLE THE STUFF GENEATED BY THE REMOTE MACROS
LSTSTO	;STORAGE FOR THE LISTS
LSTEND:	;END OF LIST STORAGE AREA
INITSL	;INIT TABLE FOR THE LISTS
0
;DISPLAY VARIABLES
;AND PARAMTERS
.IFNZ NTKDIS
DISMAL==2
DISBIG==4
TKDLEN:	.WORD DISMAL,DISMAL,DISMAL,DISBIG
.IIF NE .-TKDLEN-<2*NTKDIS>,.ERROR BAD TKDLEN TABLE LENGTH
TKDITM:	.BLKW 8.	;THE ITEMS FOR THE DISPLAYS
TKDOWN:	.BLKW 8.	;IF DISPLAY OWNED
TKDPDA:	0		;PDL ADDRESS
TKDPDL:	0		;THE ITEM FOR THE DISPLAY PDLS
TKRELS:	0		;THE RELOCATION REGISTER FOR THE DISPLAY
TKDRUN:	.WORD -1,-1,-1,-1,-1,-1,-1,-1	;THE RUN FLAGS
TKDPDP:	.WORD 40,130,220,310,400,470,560,650	;PDL POINTERS FOR EACH DISPLAY
DPUSHJ==100000
DSTOP==140400
TKRUN==4000
TKGO==10000
TKSTOP==20000
.ENDC

.IFNZ NTVS
NFTVDS==NTKDIS		;THE FIRST TV IS THE ONE AFTER THE TK DISPLAYS

;THIS TABLE CONTAINS THE REFERENCE COUNTS FOR EACH OF THE TVS. THE BUFFER
;FOR A TV SHOULD BE RELEASED WHEN THE REFERENCE COUNT REACHES ZERO. THE
;REFERENCE COUNT CAN BE INCREMENTED FOR EACH TTY ITEM WHICH REFERS TO
;THIS TV AND FOR EACH DISPLAY CAPABILITY TO THE TV.
TVDSRF:
.REPT NTVS
.BYTE 0
.ENDR

;TVDSBF CONTAINS THE BUFFER NUMBER OF EACH TV. THIS NUMBER IS -1 WHEN
;THERE IS NO BUFFER ALLOCATED TO A PARTICULAR TV.
TVDSBF:
.REPT NTVS
.BYTE -1
.ENDR

;TVBUFF SHOWS WHICH BUFFERS HAVE BEEN ALLOCATED. IF THE VALUE IS -1,
;THEN THE BUFFER IS FREE.  OTHERWISE, IT CONTAINS THE NUMBER OF THE
;TV WHICH USES THIS BUFFER.
TVBUFF:
.REPT NTVCHN
.BYTE -1
.ENDR
.ENDC


;TV DISPLAY CURSOR (OR TURTLE) VARIABLES
;Y POSITIONS
TVDSCY:	.REPT NTVCHN
	.WORD 0
	.ENDR

	;X POSITIONS
TVDSCX:	.REPT NTVCHN
	.WORD 0
	.ENDR

;FONT TABLE CONTAINS THE ITEM OF EACH FONT
NFONTS==4		;INITIALLY, THERE CAN BE TWO FONTS
FNTITM:	.BLKW NFONTS
.INSRT STYI >
CHEKIN:	SAVE PS
	SPL 7
	ADD #2,CHEKPN
	CMP #CHEKEN,CHEKPN
	BHI 1$
	MOV #CHEKBG,CHEKPN
1$:	MOV 2(P),@CHEKPN
	REST PS
	RTS PC

.SBTTL DISK INTERUPT LEVEL ROUTINES

;ALL DISK INTERUPTS COME HERE-ONLY ONE DISK CAN BE ACTIVE AT A TIME
;IN THIS SCHEME.
RKBRK:RFBRK:
DSKBRK:	JSR F,ACSAV	;COMPLETE THE SAVE OF THE CURRENT CONTEXT
	MOV P,DSKPSV	;SAVE A POINTER TO THE "FRAME"
	MOV DSKP,P	;POINT TO DISK CONTEXT FRAME
	MOV P,DSKPS	;SAVE FOR ERROR CHECKING
	JMP ACRET

;THIS IS THE ROUTINE TO CALL TO RETURN TO NORMAL CONTEXT UNTIL NEXT INTERUPT

DFLUSH:	CMP DSKP,DSKPS	;CHECK THAT STACK DIDN'T OVERFLOW
	BUGC NE
	JSR F,ACSAV	;SAVE THE DISK LEVEL CONTEXT
	MOV P,DSKP	;AND THE FRAME POINTER
	MOV DSKPSV,P	;PREPARE TO RESTORE REGULAR CONTEXT
	JSR F,ACRES	;RETORE REGISTERS
	CHECKP
	RTT		;RETORE PS AND PC


;MAIN DISK SERVICE LOOP
;PICKS UP REQUESTS FROM THE DSKRQ LIST AND SERVICES THEM
;BY CALLING SERVICE ROUTINE FOR PROPER DISK

DSTART:	MOV DSKRQ,A	;GET FIRST NODE ON LIST
	BNE DSKRQP	;GOT ONE, GO PROCESS IT
	CLR @CURDSK	;NO REQUEST, CLEAR CS OF CURRENT DISK
	JSR PC,DFLUSH	;AND RETURN CONTROL
	BR DSTART	;GO TRY AGAIN

;REALLY PROCESS A REQUEST
DSKRQP:	MOV (A),DSKRQ	;TAKE THE BLOCK OFF THE LIST
	CLR (A)		;AND CLEAR ITS LINK POINTER
	MOV #MNRTY,NRETRY	;NUMBER OF TIMES TO TRY BEFORE YOU GIVE UP
DSKRQR:	MOVB DRQDNO(A),B	;GET THE DISK NUMBER
	MOVB DRQFUN(A),D	;AND THE FUNCTION
	JSR PC,@DSKRQS(B)	;RUN THE SERVICE ROUTINE
	BNE DSKRQD	;ERROR ON TRANSFER?
	DEC NRETRY	;HAVE WE EXHUASTED RETRY COUNT?
	BGE DSKRQR	;IF NOT, GO RETRY
	BIS #DRQFER,DRQHCA(A)	;SET THE TRANSFER ERROR BIT
DSKRQD:	MOV #DRQDL,B	;ADDRESS OF BEG OF THE DONE LIST
	JSR PC,BLISTE	;GET TO END OF LIST IN B
	MOV A,(B)	;PUT THIS ONE ON THE END OF THE LIST
	BIS #DMRPIR,PIRQ	;CAUSE A MIDDLE LEVEL INTERUPT
	BR DSTART	;AND TRY FOR ANOTHER

;SEARCH TO THE END OF THE LIST POINTED TO BY B
;LEAVE THE POINTER IN B POINTING TO THE LINK WORD
;OF THE NODE ON THE END OF THE LIST
BLISTE:	TST (B)		;IS THIS THE LAST NODE
	BEQ BLIST1	;YUP
	MOV (B),B	;GO TO NEXT NODE
	BR BLISTE
BLIST1:	RTS PC
;ENTER HERE TO WRITE-CHECK THE FUNCTION YOU JUST PERFORMED
RKDSKW:	MOV #DKWCH,D	;CHANGE FUNCTION TO WRITE CHECK

;THE DISK SERVICE ROUTINE FOR REGULAR TYPE RK11 DISKS
RKDSKS:	MOV #RKCS,CURDSK	;THE RK11 IS THE CURRENT DISK
	MOV #RKDA,C	;POINTER TO THE DISK REGISTERS
	CLR E		;FOR THE DIVIDE
	MOV DRQDA(A),F	;GET THE DISK ADDRESS
	ASL F		;CONVERT TO 256 WORD BLOCKS
	DIV #12.,E	;CONVERT TO CYLENDIR AND SECTOR ADDRESSES
	ASH #4,E	;PUT THE CYLENDER ADDRESS IN THE RIGHT PLACE
	BIS F,E		;AND THE SECTOR ADDRESS
	BIS DSKOFS(B),E	;THE DISK NUMBER TOO
	MOV E,(C)	;ALL THAT JUST FOR THE DISK ADDRESS
	MOV DRQCA(A),-(C)	;CORE ADDRESS IS SIMPLE
	MOV DRQWC(A),-(C)	;SO IS WORD COUNT
	MOV DRQHCA(A),E	;HIGH CORE ADDRESS IS HARDER
	ASH #4,E	;PUT IT IN THE RIGHT PLACE
	BIS RKFUN(D),E	;AND BIS IN THE FUNCTION
	MOV E,-(C)	;START UP THE DISK!
RKDSWT:	JSR PC,DFLUSH	;WAIT FOR TH ENEXT INTERUPT
	TSTB (C)	;IS THE DISK REALLY DONE?
	BGE RKDSWT	;NOPE, KEEP WAITING
	TST (C)		;WAS THERE AN ERROR?
	BLT RKDSKE	;BRANCH IF THERE WAS
	BIT #DSKWCH,D	;AM I SUPOSED TO WRITE CHECK THIS FUNCTION?
	BNE RKDSKW	;YUP, GO CALL YOURSELF
	CLZ		;FINISHED SUCESSFULLY
	RTS PC

;GOT AN ERROR ON THE RK11
RKDSKE:	INC DISKER(B)	;INC NUMBER OF ERRORS ON THIS DISK
	MOV #DERBL,C	;THE DISK ERROR RECORDING BLOCK
	MOV #RKDS,D	;THE REGISTERS OF THE RK11
	MOV #6,E	;ALL 6 OF THEM
2$:	MOV (D)+,(C)+	;GET COPYIED
	SOB E,2$
	MOV #17,RKCS	;RESET THE DRIVE
	MOV #1,RKCS	;AND THE CONTROL
1$:	TSTB RKCS	;MAKE SURE ITS READY
	BGE 1$
	SEZ		;RETURN AN ERROR
	RTS PC
.SBTTL LOW LEVEL MAIN PROGRAM LEVEL DISK ROUTINES

;GET A LOW LEVEL DISK REQUEST BLOCK AND LEAVE IT'S INDEX IN C
GRQBLK:	MOV DSKRFL,C	;TRY TO GET A BLOCK
	BUGC EQ		;MUST BE ONE THERE!
	MOV (C),DSKRFL	;LINK IT OUT OF LIST
	DEC DRQFCN	;ONE LESS FREE
	RTS PC

;PUT A LOW LEVEL DISK REQUEST BLOCK ONTO THE REQUEST LIST
;POINT TO REQUEST ARRIVES IN C
ADDRQ:	SAVE B		;RANDOM REG
	MOV #DSKRQ,B	;LIST OF REQUESTS
	JSR PC,BLISTE	;GET TO THE END OF THE LIST
	CLR (C)		;MAKE SURE NEW GUY DOESN'T POINT ANYWHERE
	MOV C,(B)	;CLOBBER NEW GUY ONTO END
	BIS #100,@CURDSK	;WAKE UP THE DISK IF IT NEEDS IT
	REST B
	RTS PC
.SBTTL MIDDLE LEVEL DISK ROUTINES
;REQUEST A MIDDLE LEVEL DISK TRANSFER AND WAIT FOR ITS COMPLETION
;ENTER WITHT THE POINTER TO THE PAGE BLOCK IN B
;AND THE FUNCTION IN E
DMRWT:	JSR PC,DMRBGT	;TRY TO PLACE THE REQUEST
	BNE DMRWT1	;IF SUCCESS, CONTINUE
	JSR PC,SFLUSH	;WAIT A SEC
	JSR PC,RUNME	;NOT LONG
	BR DMRWT	;AND TRY AGAIN
DMRWT1:	JSR PC,PBWAIT	;WAIT FOR THE TRANSFER TO BE DONE
	RTS PC		;AND RETURN


;REQUEST A MIDDLE LEVEL PAGE VALIDATION DISK TRANSFER
;ENTER WITH THE POINTER TO THE PAGE BLOCK IN B
;AND THE FUNTION IN E
DMRBGT:	SAVE A
	SPL 7		;TO PREVENT THE DISK ROUTINES FROM SCREWING US
	MOV DMRPNT,A	;TRY TO GET A DISK REQUEST BLOCK
	BNE DMRBG1	;GOT ONE
	REST A
	SPL 0
	SEZ		;FAILED
	RTS PC
DMRBG1:	MOV (A),DMRPNT	;TAKE IT OFF THE FREE LIST
	SPL 0		;OUT OF DANGER
	CLR (A)		;DON'T POINT LIKE THAT, IT'S IMPOLITE!
	BIS #PBDISK,(B)	;DISK TRANSFER PENDING FOR THIS PAGE
	MOV B,DMRPBP(A)	;THIS IS THE PAGE TO OPERATE ON
	SAVE B
	MOV A,B		;POINTER TO BLOCK
	ADD #DMRPWK,B	;FIRST OF 3 WORDS
	JSR PC,ACTSET	;SETUP TO ACTIVATE ME
	MOV E,DMRFUN(A)	;SET IN THE FUNCTION
	CLR DMRDRC(A)	;NO REQUESTS ENTERED FOR HIM YET
	CLR DMRPBB(A)	;AND NO BITS TO CLEAR
	MOV #DMRLST,B	;NOW FIND THE END OF THE REQUEST LIST
	JSR PC,BLISTE
	MOV A,(B)	;AND TACK THE REQUEST ON THERE
	REST <B,A>
	BIS #DMRPIR,PIRQ	;CAUSE A MIDDLE LEVEL INTERUPT
	CLZ		;INDICATE REQUEST PLACED
	RTS PC

;WAIT FOR A GIP TO STOP DISKING
GPWAIT:	SAVE B
	JSR PC,GIPPB	;CONVERT TO PB
	JSR PC,PBWAIT	;WAIT FOR PB TO STOP
	REST B
	RTS PC

;WAIT FOR A PAGE BLOCK TO NO LONGER HAVE A DISK REQUEST PENDING
;THE PAGE BLOCK INDEX IS IN B
PBWAIT:	SAVE A
	MOV #PBDISK,A
	BR PBULW3

PBWAI1:	REST A
	RTS PC

;WAIT FOR A PAGE TO BE HACKABLE
;I.E. PBDISK AND PBLOCK CLEAR
PBULWT:	SAVE A
	MOV #PBDISK!PBLOCK,A	;WAIT FOR THESE FLAGS TO CLEAR
PBULW3:	BIT A,(B)	;IS IT UNLOCKED NOW?
	BEQ PBWAI1	;YES, JUST RETURN
PBULW1:	JSR PC,SFLUSH	;WAIT A LITTLE WHILE
	BIT #PBUSED,(B)	;STILL THERE?
	BEQ PBULW5	;GONE???
	BIT A,(B)	;NOW?
	BNE PBULW1	;NOT YET
	JSR PC,RUNME	;MAYBE NOW
	BR PBULW3	;TRY AGAIN
PBULW5:	MOV ITM0A,A	;POINT TO PROCESS
	BIT #PPCLSR,PFLAGS(A)	;IS HE GOING TO PCLOSER>
	BEQ PBULW6	;NO, BETTER EXPECT THIS THEN
	JSR PC,RUNME	;THIS WILL NEVER RETURN
	BPT		;I HOPE
PBULW6:	BIT #PPBNMP,PFLAGS(A)	;DID HE EPECT IT?
	BUGC EQ		;NO, WHAT A LOSER
	JSR PC,RUNME	;REVIVE HIM
	BR PBWAI1

;ROUTINE CALLED BY THE PIRQ ROUTINE
DMRBRK:	JSR F,ACSAV	;SAVE MAIN PROG ACS
DMRBR1:	BIC #DMRPIR,PIRQ	;PREVENT UNNESSARY INTERUPTS
	MOV DRQDL,A	;ANYHTING ON LIST OF DONE REQUESTS?
	BEQ DMRBR2	;NOPE
	MOV DSKRFL,F	;POINTER TO FREE BLOCKS
	MOV A,DSKRFL	;LIST BEING FREED IS NOW AT FRONT OF FREELIST
DMRBR3:	INC DRQFCN	;ONE MORE FREE ONE
	JSR PC,DRQDNE	;GO CLEAN UP FOR THIS REQUEST
	SPL 7		;I VANT TO BE ALONE
	TST (A)		;IS THERE ANOTHER DONE ONE?
	BEQ DMRBR4	;NOPE
	SPL DMRL	;BACK TO NORMAL
	MOV (A),A	;GET NEXT ONE
	BR DMRBR3	;AND PROCESS IT
DMRBR4:	MOV F,(A)	;TACK OLD FREE LIST ON END OF NEW
	CLR DRQDL	;ALL DONE ONES PROCESSED
	SPL DMRL	;AND GO BACK TO NORMAL
DMRBR2:	CMP #8.,DRQFCN	;ARE THERE AT LEAST 8 BLOCKS FREE?
	BGE DMRBR9	;EXIT TO WAIT FOR MORE BLOCKS FREE
	MOV DMRLST,A	;GET FIRST REQUEST
	BEQ DMRBR9	;NO REQUESTS
	MOV (A),DMRLST	;TAKE IT OFF THE LIST
	MOV DMRPBP(A),B	;GET POINTER TO PAGE BLOCK
	BIT DMRFUN(A),(B)	;IS WHAT WE WNAT ALREADY TRUE?
	BNE DMRBR8	;YUP, IGNORE THE REQUEST
	CLR F		;TO BUILD UP THE FUNCTION IN
	BIT #PBWCHK,(B)	;ARE WE SUPPOSED TO BE CAREFU WITH THIS PAGE?
	BEQ 1$		;NO, NO WRITE CHECK
	BIS #DSKWCH,F	;SET THE WRITE CHECK BIT
1$:	BIT #PBVACR,DMRFUN(A)	;VALIDATE IN CORE?
	BNE DMRBVC	;YES, GO DO IT
	BIT #PBVACR,(B)	;IT BETTER BE VALID IN CORE!
	BUGC EQ
	BIS #DSKWRT,F	;FUNCTION WILL BE A WRITE TO DISK
	BIS DMRFUN(A),(B)	;AND THIS INDICATES THAT THE TRUE WILL
				;EVENTUALLY BE THAT THE REQUEST HAS BEEN GRANTED
				;THUS IF THE PAGE IS MODIFIED IN CORE AFTER WE
				;START TO WRITE IT OUT, THE WRITE WILL HAVE BEEN
				;A NO-OP, WHICH IS THE RIGHT THING
	BIT #PBVASS,DMRFUN(A)	;WANT TO VALIDATE AT SWAP SPACE?
	BNE DMRBVW		;GO DO IT
	BIT #PBVAS,DMRFUN(A)	;VALIDATE AT SOURCE?
	BNE DMRBVS		;GO DO THAT
	BPT			;NO FUNCTION????
	
;COME HERE FOR A REQUEST THAT NEEDS NO ACTION
DMRBR8:	BIC #PBDISK,(B)	;DISK TRANSFER "DONE"
	JSR PC,ACTDMR		;ACTIVATE PROCESS THAT MADE THIS REQUEST (THE TURKEY)
	MOV DMRPNT,(A)		;PUT REQUEST
	MOV A,DMRPNT		;ONTO FREE LIST
	BR DMRBR2		;AND TRY TO FIND SOMEONE WHO IS MORE OF A WINNER

;COME HERE WHEN WE THINK WE'RE ALL DONE
DMRBR9:	BIT #DMRPIR,PIRQ	;IS SOMEONE TRING TO WAKE US UP?
	BNE DMRBR1		;SIGH GO FIND OUT WHAT HE WANTS
	JSR F,ACRES
	REST A
	CHECKP
	RTT

;COME HERE TO TRY TO VALIDATE THE PAGE IN CORE
DMRBVC:	BIS #DSKREA,F		;WE WANT TO READ FROM THE DISK
	MOV #PBVACR,DMRPBB(A)	;WILL SET THE VALID IN CORE BIT WHEN DONE
	BIT #PBVASS,(B)	;IS IT VALID ON SWAP SPACE?
	BNE DMRBVW		;GO GET IT FROM SWAP SPACE
	BIT #PBVAS,(B)	;IS IT VALID AT SOURCE?
	BNE DMRBVS		;GO GET IT FROM SOURCE
	BPT			;NOT VALID ANYWHERE????

;COME HERE TO DO A TRANSFER TO OR FROM SWAP SPACE
;DEPENDING ON THE FUNCTION THAT IS IN F
DMRBVW:	BIT #PBSTS,(B)	;IS IT A SWAP TO SOURCE PAGE?
	BNE DMRBVS	;YUP
	JSR PC,GRQBLK	;GET A REQUEST BLOCK
	MOVB F,DRQFUN(C)	;STORE AWAY THE FUNCTION
	CLR E		;FOR THE ASHC
	MOV PBCAR(B),F	;THE CORE ADDRESS IN 512 WORD BLOCKS
	ASHC #10.,E	;MAKE INTO A BYTE ADDRESS
	MOVB E,DRQHCA(C)	;SET THE HIGH PART OF THE ADDRESS
	MOV F,DRQCA(C)	;SET THE LOW PART
	MOVB PBRAN(B),E	;GET DISK #
	BIC #PBDSKM,E	;CLEAR CRAP
	ASH #-PBDISS,E	;SHIFT INTO PLACE
	MOV E,DRQDNO(C)	;SET IN THE DISK NUMBER
	MOV PBDA(B),E	;GET THE STARTING DISK ADDRESS
	MOVB PBRAN(B),F	;NOW NEED THE START
	BIC #PBSTRT,F	;TO GET TO THE RIGHT PLACE IN THE SWAP SPACE
	ADD F,E		;THIS SHOULD BE IT
	MOV E,DRQDA(C)	;PUT IT INTO THE BLOCK
	MOVB PBLEN(B),E	;GET THE LENGTH
	INC E		;CONVERT 0 TO 1
	ASH #9.,E	;CONVERT TO WORDS
	NEG E		;WORD COUNT ONLY A DISK COULD LOVE
	MOV E,DRQWC(C)	;SO GIVE IT TO A DISK
	MOV A,DRQABL(C)	;ACTIVE ME ON YOUR COMPLETION
	INC DMRDRC(A)	;NUMBER OF REQUESTS MADE FOR THIS REQUEST
	JSR PC,ADDRQ	;MAKE THE REQUEST
	JMP DMRBR2

;COME HERE TO READ OR WRITE SOURCE
;DEPENDING ON FUNCTION IN F
DMRBVS:	BIT #PBFILE,(B)	;BETTER BE A FILE PAGE
	BUGC EQ
	SAVE F		;SAVE THE FUNCTION
	CLR E		;TO COMUTE CORE ADDRESS
	MOV PBCAR(B),F	;HAVE TO SHIFT IT
	ASHC #10.,E	;TO MAKE IT INTO BYTES
	SAVE <E,F>	;SAVE IT ON THE STACK
	MOV B,D		;COPY THE PB POINTER
	ADD #PBSDA,D	;POINT TO FIRST DISK ADDRESS
	MOVB PBRAN(B),E	;TO GET START
	BIC #PBSTRT,E	;CLEAR CRAP
	ASL E		;BITES
	ADD E,D		;BLOCK TO REALLY START WITH
	MOVB PBLEN(B),E	;NUMBER OF BLOCKS WE WANT
DRBVS3:	JSR PC,GRQBLK	;GET A BLOCK TO MAKE THE REQUEST WITH
	INC DMRDRC(A)	;NUBER OF REQUESTS FOR THIS REQUEST
	MOV A,DRQABL(C)	;ACTIVATE ME ON YOUR COMPELETION
	MOVB 4(P),DRQFUN(C)	;GET BACK THE FUNCTION
	MOVB 2(P),DRQHCA(C)	;THE HIGH CORE ADDRESS
	MOV (P),DRQCA(C)	;AND THE LOW CORE ADDRESS
	MOVB PBSDSK(B),DRQDNO(C)	;THE DISK #
	CLR DRQWC(C)	;NOW COMPUTE TRANSFER LENGTH
	MOV (D),DRQDA(C)	;GET STARTING DISK ADDRESS
	BUGC EQ			;SHOULD NEVER TOUCH BLOCK ZERO!
DRBVS2:	MOV (D)+,F		;INTO F ALSO
	CMP #-1,F		;MAKE SURE NOT NON-EX BLOCK
	BUGC EQ
	ADD #2000,(P)		;INC CORE ADDRESS
	ADC 2(P)		;TO NEXT BLOCK
	ADD #-1000,DRQWC(C)	;ONE MORE BLOCK
	DEC E			;ONE MORE BLOCK READY TO GO
	BLT DRBVS1		;THAT'S ALL WE WANT
	INC F			;ADDRESS OF NEXT SEQUENTIAL BLOCK
	CMP F,(D)		;IS THE NEXT BLOCK RIGHT AFTER THIS ONE?
	BEQ DRBVS2		;YUP, GOBBLE IT ON THIS TRANSFER
	JSR PC,ADDRQ		;HAVE TO SPLIT TRANSFER
	BR DRBVS3		;GO TAKE ANOTHER CRACK AT IT
DRBVS1:	JSR PC,ADDRQ		;ADD THE LAST REQUEST
	ADD #6,P		;FLUSH CRAP FROM STACK
	JMP DMRBR2		;DONE WITH THIS ONE
;COME HERE TO CLEAN UP FOR EACH DISK REQUEST THAT FINISHES
;MUST CHECK IF ALL REQUESTS ARE DONE, AND FINISH THE GUY UP IF THEY ARE
;THE REQUEST BLOCK IS POINTED TO BY A
DRQDNE:	MOV DRQABL(A),B		;MIDDLE LEVEL BLOCK TO ACTIVATE
	MOV DMRPBP(B),C		;POINTER TO PAGE BLOCK
	BIT #DRQFER,DRQHCA(A)	;WAS THERE A HARD ERROR?
	BEQ DRQDN1		;NOPE
	BIS #PBERR,(C)	;FLAG ERROR FOR MAIN PROGRAM
	BPT			;UGH
DRQDN1:	DEC DMRDRC(B)		;ONE LESS REQUEST PENDING
	BNE DRQDN2		;BUT MORE STILL THERE
	SAVE A			;THIS GUY IS ALL DONE, FINISH HIM OFF
	MOV B,A			;ACTDMR EXPECTS ARG IN A
	JSR PC,ACTDMR		;THIS GUY IS A WINNER, RUN HIM QUICK
	REST A
	BIS DMRPBB(B),(C)	;SET ANY BITS YOU NEED TO
	BIC #PBDISK,(C)	;AND INDICATE DISK OP IS DONE
	MOV DMRPNT,(B)		;PUT THE FREE LIST
	MOV B,DMRPNT		;BACK TOGETHER
DRQDN2:	RTS PC

ACTDMR:	JSR F,ACSAV		;GROSS OUT
	MOV #DMRPWK,B		;POINTER TO 3 WORD BLOCK
	ADD A,B			;IN THIS BLOCK
	JSR PC,GOACT		;GO PUT ON ACTIVATE LIST
	JMP ACRET
.SBTTL MAIN PROGRAM LEVEL PAGE VALIDATION ROUTINES

;VALIDATE THE PAGE WHOSE PB IS IN B IN CORE
;THE ASSUMPTION IS THAT THE PAGE IS EITHER PBZERO OR
;IS VALID ON SWAP OR SOURCE
;ALSO, THE PAGE MUST HAV ECORE ASSIGNED TO IT
VALCOR:	JSR F,ACSAV	;SO WE DON'T HAVE TO WORRY
	BIT #PBLOCK!PBDISK,(B)	;IS SOMETHING FISHY?
	BUGC NE
	BIT #PBZERO,(B)	;SHOULD IT BE ZEROED?
	BEQ VALCO3	;NOPE, GO SWAP IT IN INSTEAD
	BIC #PBZERO,(B)	;WE GO THIS WAY BUT ONCE....
				;NOW WE PROCEED TO PLAY WITH ITEM2
				;IN A FUNNY WAY TO CLEAR THE PAGE
	MOV #-1,A	;FIRST WE DO A FAKE PUSH
	JSR PC,ITM2PL
	MOV PBCAR(B),A	;GET THE REAL CORE ADDRESS
	BUGC EQ	;WHICH BETTER BE NON-ZERO
	ASH #4,A	;MAKE IT IN 32 WORD BLOCKS
	MOV #ITM2AD,C	;POINT TO ITEM2
	MOVB PBLEN(B),D	;GET THE LENGTH
	INC D		;0=>1
	ASH #9.,D	;CONVERT TO WORDS
	SPL 7		;PREVENT INT LEVEL FROM GETTIGN CONFUSED
	MOV A,ITM2AR	;POINT TO PAGE
	MOV #77406,ITM2DR	;MAXIMAL LENGTH PAGE
1$:	CLR (C)+	;CLEAR A WORD
	SOB D,1$
	SPL 0		;INTS OK NOW
	JSR PC,ITM2PO
	BIS #PBVACR,(B)	;NOW VALID IN CORE
	BIC #PBVAS!PBVASS,(B)	;NOT VALID ON SOURCE OR SWAP SPACE
VALCO1:	JMP ACRET

VALCO5:	JSR PC,RUNME	;TRY AGAIN FOR BLOCK

;COME HERE TO TRY TO ENTER REQUEST TO VALIDATE PAGE IN CORE
VALCO3:	MOV (B),F	;SAVE FOR THE LOCK FLAG
	MOV #PBVACR,E	;REQUEST TO VALIDATE IN CORE
	JSR PC,DMRBGT	;TRY TO ENTER REQUEST
	BNE VALCO2	;BR IF YOU WON
VALCO4:	JSR PC,SFLUSH	;WAIT....
	BIT #PBLOCK,F	;IF IT WAS LOCKED WHEN I STARTED
	BNE VALCO5	;THEN IT DAMN WELL BETTER BE ME WHO HAS IT LOCKED!
	BIT #PBLOCK!PBVACR,(B)	;SOMEONE ELSE BRINGING IT IN?
	BEQ VALCO5
	BIT #PBLOCK!PBDISK,(B)	;WAIT FOR IT TO SETTLE DOWN?
	BNE VALCO4
	JSR PC,RUNME	;SOMEONE ELSE WAS KIND ENOUGH TO BRING IT IN
	BR VALCO1	;I CAN RETURN
VALCO2:	JSR PC,PBWAIT	;WAIT FOR THE DISK TO WIN
	BR VALCO1	;DONE!
;VALIDATE PAGE ON SWAP SPACE
;THE PAGE MUST BE VALID IN CORE WHEN THE ROUTINE IS ENTERED
;A PB POINTER TO THE PAGE IS IN B
VALSWP:	BIT #PBSTS,(B)	;IS IT A SWAP TO SOURCE PAGE?
	BNE PBVLSR	;YES, VALIDATE AT SOURCE INSTEAD
	JSR F,ACSAV	;BETTER SAFE THAN...
	MOV (B),F
VALSW5:	JSR PC,PBWAIT
	BIT #PBVASS,(B)	;IS PAGE ALREADY VALID ON SWAP SPACE?
	BNE VALCO1	;RETURN IF ALREADY VALID
	BIT #PBVACR,(B)	;IT BETTER BE VALID IN CORE!
;	BUGC EQ
	BNE VALSW1
	JSR PC,BUGGER

;COME HERE TO ENTER THE REQUEST TO VALIDATE THE PAGE ON SWAP SPACE
VALSW1:	MOV #PBVASS,E	;REQUEST VALIDATION OF PAGE ON SWAP SPACE
	BIT #PBFILE,(B)	;IS THIS A FILE PAGE?
	BNE 1$		;YES
	BIS #PBVAS,E	;SWAP SPACE IS SOURCE
1$:	JSR PC,DMRBGT	;GO TRY TO REQUEST IT
	BNE VALCO1	;BRANCH IF YOU WIN, WE'RE DONE
VALSW2:	JSR PC,SFLUSH	;WAIT FOR CONDITIONS TO IMPROVE
	BIT #PBLOCK,F	;HAVE I GOT THE PAGE LOCKED?
	BNE VALSW4	;BR IF I'VE GOT IT
	BIT #PBLOCK,(B)	;SOMEONE ELSE GOT IT LOCKED?
	BNE VALSW2	;BR TO WAIT FOR UNLOCKED
VALSW4:	JSR PC,RUNME	;TRY AGAIN
	BR VALSW5

;VALIDATE A PAGE BLOCK ON SOURCE
PBVLSR:	JSR F,ACSAV	;SAVE THE RESGISTERS
	BR VALS59	;JUMP IN AFTER GIP CONVERT

;VALIDATE PAGE AT SOURCE
;THE PAGE MUST BE VALID IN CORE WHEN ROUTINE IS ENTERED
;A GIP TO TH PAGE IS IN B
VALSRC:	JSR F,ACSAV	;BETTER SAFE THAN...
	JSR PC,GIPPB	;CONVERT GIP TO PB
VALS59:	MOV (B),F
VALS5:	JSR PC,PBWAIT	;WAIT FOR ANY DISKING TO DIE DOWN
	BIT #PBVAS,(B)	;IS PAGE ALREADY VALID ON SOURCE
	BNE VALCO1	;RETURN IF ALREADY VALID
	BIT #PBFILE,(B)	;IS IT REALLY A FILE PAGE?
	BEQ VALSW5	;NO, REALLY VALIDATE IT AT SWAP
	BIT #PBVACR,(B)	;IT BETTER BE VALID IN CORE!
;	BUGC EQ
	BNE VALS1
	JSR PC,BUGGER	;TRY TO PCLOSER OUT

;COME HERE TO ENTER THE REQUEST TO VALIDATE THE PAGE ON SAP SPACE
VALS1:	MOV #PBVAS,E	;REQUEST VALIDATION OF PAGE ON SAP SPACE
	JSR PC,DMRBGT	;GO TRY TO REQUEST IT
	BNE VALCO1	;BRANCH IF YOU WIN, WE'RE DONE
VALS2:	JSR PC,SFLUSH	;WAIT FOR CONDITIONS TO IMPROVE
	BIT #PBLOCK,F	;HAVE I GOT THE PAGE LOCKED?
	BNE VALS4	;BR IF I'VE GOT IT
	BIT #PBLOCK,(B)	;SOMEONE ELSE GOT IT LOCKED?
	BNE VALS2	;BR TO WAIT FOR UNLOCKED
VALS4:	JSR PC,RUNME	;TRY AGAIN
	BR VALS5
.SBTTL SWAP SPACE ALLOCATE/DEALLOCATE ROUTINES
;FIND SWAP SPACE FOR THE PB IN B
;AND CLOBBER THE PB TO REFLECT IT
FINSWP:	JSR F,ACSAV
	MOV B,F		;SAVE AWAY THE PB POINTER SO IT IS EASY TO GET LATER
	CLR C		;INDEX TO BIT TABLE POINTERS
FINSW1:	MOV SWPBPT+2(C),B	;HAVE WE EXHAUSTED SPACE TO SEARCH?
	BEQ FINSW8	;YUP, YOU LOSE
	MOV SWPBPT(C),A	;POINT TO BEG OF THIS TABLE	
	TST (C)+	;GO TO THE NEXT ONE
	TST SWPFCN-2(C)	;ARE THERE ANY FREE ONES?
	BEQ FINSW1	;NO, TRY FOR THE NEXT ONE
	JSR PC,FINBIT	;TRY TO FIND A FREE BIT
	BEQ FINSW1	;LOSEY LOSEY
	DEC SWPFCN-2(C)	;ONE LESS FREE ONE
	ASH #3,B	;FROM 4K => 512
	ADD SWPBDA-2(C),B	;GET THE REAL DISK ADDRESS
	MOV B,PBDA(F)	;SET IN THE DISK ADDRESS	
	BIC #PBVASS!PBSTS,(F)	;SHOULD NOT BE SWAPPED TO SOURCE, NOT VALID AT SWAP SPACE
	MOV SWPBDK-2(C),D	;GET THE DISK
	ASH #PBDISS,D	;PUT IT IN THE RIGHT PLACE
	BISB D,PBRAN(F)	;SET IT IN
ACRETC:	JSR F,ACRES
	CLZ
	RTS PC

ACRETS:
FINSW8:	JSR F,ACRES
	SEZ
	RTS PC

;FIND A FREE BIT IN A RANDOM BT TABLE AND SET IT
;CALL WITH START OF TABLE IN A, END IN B
;SEZ IF CAN'T FIND ONE
;IF YOU WIN, A GETS THE POINTER TO TH WORD AND B GETS THE BIT NUMBER
FINBIT:	SAVE <C,A>
FINBI1:	CMP A,B		;OFF THE END OF THE TABLE
	BHIS FINBI7	;YUP, NO BITS FOR YOU
	CMP #-1,(A)+	;ANY FREE BITS IN THIS WORD?
	BEQ FINBI1	;NOPE, TRY THE NEXT
	CLR B		;CLEAR A COUNTER
	MOV -(A),C	;GET THE WORD IN QUESTION
FINBI2:	ROR C		;GET THE LOW ORDER BIT
	BCC FINBI3	;IF CARRY IS CLEAR, THATS THE ONE WE WANT
	SOB B,FINBI2	;CHUCKLE
;WE NEVER (I HOPE) FALL THROUGH THE SOB
FINBI3:	NEG B		;MAY HAVE SAVED SOME CYCLES WITH THIS TRICK
	ASL B		;GET A WORD INDEX
	BIS BITS(B),(A)	;SET THE RIGHT BIT
	ASR B		;ADJUST BACK
	SUB (P),A	;OFFSET FROM START OF TABLE
	ASH #3,A	;MULITPLIED BY 16
	ADD A,B		;GIVES BIT NUMBER IN TABLE
	REST <A,C>
	CLZ		;WIN
	RTS PC

FINBI7:	REST <A,C>
	SEZ		;LOSE
	RTS PC

;FREE THE SWAP AREA USED BY THE PB IN B
PBSFRE:	BIT #PBSTS,(B)	;DOES IT HAVE SWAP SPACE?
	BNE PBSFR3	;NO SPACE, DON'T FREE IT!
	JSR F,ACSAV
	CLR C		;POINTER TO THE BIT TABLE TABLES
	MOVB PBRAN(B),A	;GET THE DISK NUMBER
	BIC #PBDSKM,A	;MASK THE DISK # OFF
	ASH #-PBDISS,A	;SHIFT IT TO A REASNABLE SPOT
	MOV PBDA(B),E	;MAKE THE DISK ADDRESS EASY TO GET AT
PBSFR1:	CMP A,SWPBDK(C)	;IS IT MAYBE IN THIS BIT TABLE?
	BNE PBSFR2	;NOPE
	CMP E,SWPBDA(C)	;IS IT AFTER THE START	
	BLO PBSFR2	;NOPE (???)
	CMP E,SWPEDA(C)	;BUT BEFORE THE END
	BHIS PBSFR2	;NO
	SUB SWPBDA(C),E	;MAKE IT RELATIVE TO THIS TABLE
	MOV E,F		;NOW HAVE 2 COPIES
	ASH #-6,E	;GET THE WORD NUMBER
	BIC #160001,E	;EXTRA CRAP
	ASH #-2,F		;THE BIT NUMBER
	BIC #177741,F	;LIKEWISE
	ADD SWPBPT(C),E	;POINT
	BIC BITS(F),(E)	;CLEAR THE RIGHT BIT
	INC SWPFCN(C)	;ONE MORE FREE
	CLR PBDA(B)	;MAKE SURE HE DOESN'T USE IT AGAIN!
	JSR F,ACRES
PBSFR3:	RTS PC

PBSFR2:	TST (C)+	;GO TO THE NEXT BIT TABLE
	TST SWPBPT+2(C)	;MAKE SURE IT ISN'T NON-EX
	BNE PBSFR1	;WIN
	BPT		;LOSE

;ALLOCATE SWAP SPACE
;THIS CALL MAY ONLY BE EXECUTED BY THE SYSSPR
;THE 3 ARGS ON THE STACK ARE THE SIZE OF THESWAP SPACE
;IN BLOCKS, THE BLOCK ADDRESS OF THE START OF SWAP SPACE
;AND THE DISK NUMBER THAT THIS SWAP SPACE IS ON
;THE CALL IS EXECUTED ONCE FOR EACH SWAP SPACE TO BE ALLOCATED
EALLOC:	JSR PC,SYSCHK	;CHECK THAT THIS IS SYSSPR
	JSR PC,RETNSW	;GET THE DISK NUMBER
	MOV A,E		;STORE IT AWAY
	JSR PC,RETNSW	;GET THE NUMBER OF BLOCKS
	MOV A,F		;AND SAVE IT
	JSR PC,RETNSW	;FINNALLY, GET THE START
	MOV #NSWPA,D	;NUMBER OF SWAP SPACES POSSIBLE
	CLR C		;POINTER INTO SWAP SPACE TABLES
EALLO1:	TST SWPBPT+2(C)	;IS THIS SPACE FREE?
			;IF IT IS, NEXT SPACE BEGGINING=0
	BEQ EALLO3	;FOUND A FREE SPACE
	TST (C)+	;TRY THE NEXT
	SOB D,EALLO1	;UNLESS WE RUN OUT
	ERROR BAD	;SYSSPR WAS BAD, SLAP ITS WRIST
EALLO3:	MOV E,SWPBDK(C)	;SAVE THE DISK NUMBER
	MOV A,SWPBDA(C)	;AND SAVE THAT AS THE START
	MOV SWPBPT(C),D	;GET THE POINTER TO THIS BIT TABLE
	ADD F,A		;GET END BLOCK
	MOV A,SWPEDA(C)	;STORE IT AWAY
	ASH #-3,F	;CONVERT TO 4K BLOCKS
	MOV F,SWPFCN(C)	;SAVE COUNT OF FREE SWAP SPACES
EALLO4:	CLR (D)+	;16 FREE BITS
	SUB #20,F	;ALLOCATE 16 SWAP SPACES
	BGT EALLO4	;MORE
	BEQ EALLO6	;A FULL WORD OF BITS
	MOV #100000,E	;GET A BIT
	INC F		;CAUSE ONE BIT IS ALREADY SET
	ASH F,E		;SET THE BITS IN THE HIGH PART OF THE WORD
	BIS E,-(D)	;PUT THEM IN THE WORD WE JUST CLEARED
EALLO6:	TST (D)+	;GO TO THE FIRST FREE WORD
	CMP D,#SWPBTE	;HIGHER THAN THE END OF THE TABLE?
	BUGC HIS
	MOV D,SWPBPT+2(C)	;SET THE START OF THE NEXT TABL
	JMP ERETCZ	;WIN
.SBTTL SWAP IN/OUT AND ITEM SPACE ALLOCATE
;SWAP OUT PAGE WHOSE PB IS IN B
;BUT BE HAPPY IF THE PAGE GETS FREED OUT FROM UNDER US
SWPNMP:	SAVE A
	MOV ITM0A,A
	BIS #PPBNMP,PFLAGS(A)	;SET THE MAGIC FLAG
	JSR PC,SWPPAG		;DO THE SWAP
	BIC #PPBNMP,PFLAGS(A)
	REST A
	RTS PC
;SWAP OUT PAGE WHOSE PB IS IN B
SWPPAG:	JSR PC,PBULWT	;WAIT FOR IT TO BE HACKABLE
	SAVE B
	MOV PBGIP(B),B	;CONVERT PB TO GIP
	JSR PC,PAGPCL	;PCLOSER EVERYONE WHO MIGHT DEPEND ON THIS PAGE
	REST B		;GET BACK PB
SWPPG:	JSR PC,SAVAWB	;IN CASE IT IS IN MY MAP
	JSR PC,PBLCK	;NOW I LOCK IT!
	JSR PC,VALSWP	;VALIDATE ON SWAP SPACE
	JSR PC,PBWAIT	;WAIT FOR DISKING TO STOP
	JSR PC,LSWPOP	;POP SWITCH, UNLOCKING BLOCK
	BIT #PBVASS!PBVAS,(B)	;IS IT REALLY VALID AT SWAP, OR AT LEAST AT SOURCE?
	BEQ SWPPAG	;NOPE, TRY AGAIN
	JSR PC,PBCFRE	;FREE THE CORE IT TOOK
	JMP MAPRES	;IN CASE MY MAP NEEDS UPDATEING


;GET CORE TO EXPAND ITEM SPACE
;CALL WITH DESIRED AMOUNT OF COORE IN A
ITMSEX:	JSR F,ACSAV
	INC A		;0=1
ITMSE1:	MOV CST1NS,C	;POINT TO FIRST NON-SYSTEM BLOCK
ITMSE6:	MOV A,D		;COPY FOR SOB
	MOV C,E		;COPY START OF SPACE BEING GOBBLED
ITMSE2:	BIT #CSTFRB,(C)+	;IS THIS BLOCK FREE?
	BEQ ITMSE4	;NOPE, HAVE TO FREE IT
	SOB D,ITMSE2	;CHECK ALL THE BLOCKS WE WANT TO GOBBLE
	SUB A,FREECR	;THAT MUCH LESS FREE CORE TOO
	SUB A,USRCOR	;THIS MUCH WILL BE STOLEN FROM USERS
	BUGC LE	;SYSTEM HAS ZERO OR NEGATIVE CORE FOR USERS!
	MOV E,C		;POINT TO START AGAIN, THEY ARE ALL FREEE
	SUB #CST,E	;CONVERT
	ASR E		;TO BLOCK NUMBER
	MOV E,2(P)	;RETURN THE START IN B FOR THE USER
ITMSE3:	BIT #CSTFRB,(C)	;IS IT REALLY FREE?
	BUGC EQ
	BIS #CSTSYB,(C)	;USED BY SYSTEM
	BIC #CSTFRB,(C)+	;AND NO LONGER FREE
	CMP C,CST1FR	;IS THIS THE FIRST FREE BLOCK?
	BNE 1$
	ADD #2,CST1FR	;NOT ANY MORE
1$:	SOB A,ITMSE3	;FOR ALL THE BLOCKS
	JMP ACRET
ITMSE4:	TST -(C)	;BACK TO BLOCK THAT ISN'T FREE
	BIT #CSTSYB,(C)	;IS THIS BLOCK ALREADY USED BY THE SYSTEM?
	BNE ITMSE5	;YES, WE'LL IGNORE IT
	MOV CSTPB-CST(C),B	;WHO IS THAT, ANYWAY
	JSR PC,PCLDEF	;DEFERE A PCLOSER TILL WE ARE DONE
	JSR PC,SWPNMP	;OUT WITH HIM!(NOT MY PAGE)
	BR ITMSE1	;GO TRY IT ALL AGAIN
ITMSE5:	TST (C)+	;GO HIGHER
	CMP C,CSTTOP	;OFF THE TOP?
	BUGC HIS	;UGH RAN OFF TOP
	BR ITMSE6	;TRY AGAIN

.SBTTL SEGMENT BREAK ROUTINES
SEGBRK:	MOV SSR0,PSSR0	;COPY INTO PSEUDO SEGMENT REGISTERS
	MOV SSR1,PSSR1
	MOV SSR2,PSSR2
	BIC #174000,SSR0	;RESUME MONITORING
	MOV PSSR2,(P)	;GET THE PC WHERE THE INSTRUCTION STARTED
	BIT #200,PSSR0	;DID THE INSTRUCTION COMPLETE?
	BUGC NE	;STRANGE, I DON'T THINK THIS SHOULD HAPPEN
	BIT #140000,2(P)	;WAS IT FROM KERNAL MODE?
	BEQ SEGKR	;YES, GO PROCESS IT LIKE A SUBROUTINE CALL
	MOV PC,USRMOD	;FROM USER MODE, TREAT LIKE A SSYTEM CAL
	SPL 0
	JSR F,SPCPSP	;SAVE THE PS, PC AND P POINTER OF TH EUSER
	JSR PC,PACSAV	;AND HIS ACS
	MOV ITM0A,A	;POINT TO THE PROCESS BLOCK
	ADD #PUREGS,A	;POINT TO SAVED REGISTERS
	JSR PC,ACFIX	;FIX UP THE USERS REGISTERS
	JSR PC,PAGIN	;SWAP IN THE PAGE
	MOV ITM0A,B	;POINT TO THE PROCESS
	JSR PC,PACRES	;RESTORE USERS REGISTERS
	SAVE PUP(B)	;GET USERS P POINTER
	MTPI P		;RESTORE IT
	SAVE <PUPS(B),PUPC(B)>	;TO RETURN TO USER MODE
	SPL CLKL	;PREVENT A SCHEDULE
	CLR USRMOD	;THIS COULD CAUSE ONE
	TST QUANT	;HAS HE OVERSTAYED HIS WELCOME?
	BGE 1$		;NO
	BIS #CLKPIR,PIRQ	;GET HIM AFTER THE RTT
1$:	CHECKP
	RTT		;GO TO USER MODE

SEGKR:	SPL 0
	CLR -(P)	;SAVE A 0 VALUE FOR P
	JSR F,ACSAV	;SAVE THE REST OF THE KERNAL REGISTERS
	MOV PSSR0,A	;GET SEGMENTER STATUS
	ASR A		;SHIFT
	BIC #177700,A	;GET THE PAGE NUMBER THAT WE FAULTED ON
	TSTB KERSBT(A)	;IS IT OK TO FAULT ON THIS PAGE FROM KERNAL?
	BUGC EQ	;NO, UGH
	BGT SEGKR1	;YES, IT IS A USER PAGE
	BIT #SEGNRA,PSSR0	;THE ONLY LEGAL KERNAL PAGE TRAP
	BUGC EQ	;IS NON-RESIDENT
SEGKR1:	MOV P,A		;A POINTER TO THE KERNAL REGISTERS
	JSR PC,ACFIX	;FIX THEM UP
	JSR F,ACRES	;GET BACK THE FIXED UP ACS
	TST (P)		;DOES KERNAL P NEED FIXING?
	BUGC LT	;CAN'T WIN IF NEED TO ADD TO IT
	ADD (P),P	;CORRECT THE P STACK (REMOVE THINGS PUSHED)
	TST (P)+	;AND FLUSH THE DUMMY P VALUE
	SAVE <A,B>	;SAVE THE CORRECTED ACS ON THE CORRECTED STACK	
	JSR PC,PAGIN	;TRY TO SWAP IN THE PAGE
	REST <B,A>	;RESTORE THE KERNAL REGISTERS
	CHECKP
	RTT		;RETURN FROM THIS "SUBROUTINE"
;FIX UP THE REGISTER SET POINTED TO BY A
ACFIX:	MOV #2,F	;DO IT TWICE
	MOV PSSR1,E	;GET THE CORRECTION VALUES
ACFIX1:	MOVB E,B	;GET ONE OF THEM
	BEQ ACFIX2	;ZERO, ALL DONE
	BIC #177770,B	;WHCIH REGISTER?
	CMP #7,B	;NEVER FIX UP THE PC
	BEQ ACFIX2	;SSR2 TAKES CARE OF THAT
	ASL B		;WORD INDEX
	MOVB E,C	;GET THE AMOUNT(SIGN EXTENDED)
	ASH #-3,C	;THEN FLUSH THE REGISTER # AND SIGN EXTEND MORE
	ADD A,B		;POINT TO THE STORED REGISTER VALUE
	SUB C,(B)	;CORRECT IT
ACFIX2:	SWAB E		;FOR THE SECOND ONE
	SOB F,ACFIX1	;DO IT AGAIN
ACFIX3:	RTS PC

;SWAP IN THE PAGE THAT WE FAULTED ON, OR GIVE THE USER AN ERROR
;IF THE FAULT WAS NOT NON-RESIDENT OR THE PAGE IS NON-EX
PAGIN:	MOV PSSR0,A	;GET STATUS
	BIT #SEGNRA,A	;NON-RESIDENT?
	BEQ PAGERR	;NO, ERROR ON THE PART OF THE USER
	ASR A		;CONVERT TO PAGE NUM
	BIT #60,A	;IS IT A KERNAL PAGE?
	BEQ PAGIN1	;YES, BETTER BE ITEM2
	BIC #177760,A	;GET PAGE NUMBER
	MOV A,B		;COPY IT
	MUL #UPTLEN,B	;MAKE A POINTER
	ADD ITM1A,B	;INTO THE SPHERE'S
	ADD #SUPTS,B	;UPTS
	TST (B)		;DOES THE PAGE EXIST?
	BEQ PAGACV	;NXM ERRROR
	MOV UPTPBP(B),B	;GET THE PB TO SWAP IN
	JSR PC,PBULWT	;MAKE SURE IT IS UNLOCKED
	JSR PC,SAVAWB	;SAVE THE W BITS
	JSR PC,PBSWPI	;GO DO IT
	JMP MAPRES	;RESTORE THE MAP WITH THE NEW PAGE

PAGIN1:	BIC #177700,A	;CLEAR CRAP
	CMP #<<ITM2AR-I0AR>/2>,A	;IS IT ITEM2?
	BUGC NE
	MOV ITEM2,B	;GET THE ITEM
	JSR PC,SWPIN	;SWAP IT IN
	MOV ITEM2,A	;NOW
	JMP ITM2LD	;RELOAD IT

PAGERR:	MOV ITM0A,A	;THE PROCESS
	BIT #SEGSLE,PSSR0	;SEGMENT LENGTH ERROR?
	BNE PAGSLE	;ITS SET
	BIT #SEGRVI,PSSR0	;READ ONLY VIOLATION?
	BNE PAGRDO	;READ ONLY PAGE
	BPT

PAGSLE:	MOV #100000+.SLETF,PFAULT(A)	;SEGMENT LENGTH ERROR
SEGFLT:	CMP (P)+,(P)+	;POP OFF SSR0,SSR1, AND RETURN ADDRESS
	JMP CFAULT	;HE LOSES
PAGRDO:	MOV #100000+.RDOTF,PFAULT(A)	;READ ONLY FAULT
	BR SEGFLT	;FAULT HIM
PAGACV:	MOV ITM0A,A	;POINT TO PROCESS
	MOV #100000+.NXMTF,PFAULT(A)	;NON EXISTANT MEMORY FAULT
	BR SEGFLT
;SWAP IN THE PAGE POINTED TO BY THE GIP IN B
SWPIN:	SAVE B
	JSR PC,UPTPLD	;GET THE UPT FOR THE PAGE
	MOV UPTPBP(B),B	;GET THE POINTER TO THE PAGE BLOCK
	JSR PC,ITM2PO	;PUSHED BY UPTPLD
	JSR PC,PBSWPI	;SWAP IN THE PAGE
	REST B
	RTS PC

;SWPA IN THE PAGE REPRESENTED BY THE PB IN B
;THIS ROUTINE TAKES CARE OF MAKING SPACE IN CORE BY SWAPPING
;OUT PAGES AND/OR DEACTIVATING OTHER USERS AS NEEDED
PBSWPI:	JSR PC,PBWAIT		;MAKE SURE PAGE IS AVAILABLE
	BIT #PBVACR,(B)		;ALREADY IN CORE?
	BNE PBSWP1		;YES, NOTING TO DO
	JSR PC,FINPAG		;TRY TO FIND A PLACE TO PUT IT
	BEQ PBSWP2		;UGH, HAVE TO WORK FOR OUR CORE
	JSR PC,VALCOR		;SWAP IT IN	
	BR PBSWPI		;AND WE SHOULD BE ALL SET
PBSWP1:	RTS PC
PBSWP2:	JSR PC,CRFREE		;GO OFF TO FREE SOME CORE
	BR PBSWPI		;AND TRY AGAIN
.SBTTL SWAP SCHEDULING ROUTINES
 ;THE PROCESS IN A IS ABOUT TO BE MOVED TO THE QUQUE IN B
 ;IF THE PAGES THE PROCESS USES SHOULD BE ACTIVIATED OR DEACTIVATED
 ;THIS ROUTINE WILL DO IT
PRSAOD:	JSR F,ACSAV	;GORSS
	MOV PRTPPT(A),A	;GET ITEM #
	JSR PC,ITM0PL	;LOAD PROCESS
	BIT #WINQB!ACTQB!DORQB,PQBIT(A)	;ARE THE PAGES ACTIVE NOW?
	BEQ PRSAC1	;NO, GO SEE IF WE SHOULD ACTIVATE
	BIT #WINQB!ACTQB!DORQB,QBIT(B)	;ARE WE GOING TO AN ACTIVE QUQE?
	BNE PRSAO1	;YES, DO NOTHING
	MOV #PBDACT,F	;MUST DEATIVATE PAGES
	MOV #-1,C	;ONE LESS ACTIVE
	BR PRSAO2	;GO DO IT

PRSAC1:	BIT #RUNQB!IACTQB!STOPQB!PFREQB,QBIT(B)	;ARE WE GOING TO AN INACTIVE QUQE?
	BNE PRSAO1	;YES, DO NOTHING
	MOV #PBACT,F	;NO, ACTIVATE THE PAGES
	MOV #1,C	;ONE MORE ACTIVE
PRSAO2:	MOV PPRTPT(A),B	;GET POINTER TO PROCESS TABLE ENTRY
	MOV HSECS,PRTTIM(B)	;TIME THAT THIS PROCESS WENT ONTO THIS QUQUE
	MOV PSPHRP(A),A	;GET THE SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	ADD C,SPHAPR(A)	;ONE MORE OR LESS ACTIVE
	ADD #SUPTS,A	;POINT TO THE UPTS
	MOV #16.,D	;PROCESS ALL 16 OF THEM
PRSAO3:	TST (A)		;DOES IT EXIST?
	BEQ PRSAO4	;NO, IGNORE IT
	BIT #UPTABS,(A)	;IS IT AN ABSOLUTE PAGE?
	BNE PRSAO4	;YES, LEAVE IT ALONE
	MOV UPTPBP(A),B	;GET ITS PAGE BLOCK
	MOV #1,C	;ONLY ONE PROCESS
	JSR PC,(F)	;CALL APPROPRIATE ROUTINE
PRSAO4:	ADD #UPTLEN,A	;NEXT
	SOB D,PRSAO3
	JSR PC,ITM1PO
PRSAO1:	JSR PC,ITM0PO
	JMP ACRET

PBDACT:	SUB C,PBAUSR(B)	;ONE LESS ACTIVE PROCESS USING THIS PAGE
	BUGC LT	;FIX THIS
	BNE PBDAC2	;ALREADY NON-ZERO
	SAVE A
	MOVB PBLEN(B),A	;GET THE LENTGH OF THE PAGE BEING DEATIVATED
	SUB A,ACORE	;THAT MUCH LESS ACTIVE CORE
	BIT #PBVACR,(B)	;IS IT VALID IN CORE?
	BEQ PBDAC3	;NO, DON'T PUT ON SWAP OUT LIST
	MOV #PBSWPO,A	;SIMPLE LINEAR SWAP OUT LIST
1$:	TST (A)+	;LOOK FOR A FREE ENTRY
	BNE 1$
	CMP #PBSWOE,A	;DID WE GET TOT THE END?
	BUGC EQ	;OOPS, TRYING TO PUT TOO MANY PAGES ON SWAP OUT LIST
	MOV B,-(A)	;PUT IT ON THE LIST
	INC NPBSWO	;ONE MORE PAGE TO BE SWAPPED OUT
PBDAC3:	REST A
PBDAC2:	RTS PC
;ACTIVATE PAGE POINTED TO BY B
PBACT:	TST PBAUSR(B)	;IS IT ALREADY ACTIVE?
	BNE PBACT1	;YUP, NOTHING TO DO
	SAVE <A,C>
	MOVB PBLEN(B),A	;LENGTH OF PAGE BEING ACTIVATED
	ADD A,ACORE	;MORE ACTIVE CORE
	JSR PC,PBNSWP	;TAKE OFF SWAP OUT LIST IF ON IT
	REST <C,A>
PBACT1:	ADD C,PBAUSR(B)	;INC THE COUNT
	RTS PC

;IF THE PB IN B IS ON THE SWAP OUT LIST, TAKE IT OFF
PBNSWP:	SAVE A
	MOV #PBSWPO,A	;IS IT ON SWAP OUT LIST?
PBNSW2:	CMP B,(A)+	;THIS ONE?
	BNE PBNSW3	;YUP, SAVE HIM
	DEC NPBSWO
	CLR -(A)
PBNSW3:	CMP #PBSWOE,A	;AT END OF LIST?
	BNE PBNSW2	;NOT YET
PBNSW4:	REST A
	RTS PC
;FREE UP SOME CORE, MOVING PROCESSES FROM DORMANT TO INACTIVE OR
;ACTIVE TO RUNNING AS NEEDED
CRFREE:	JSR F,ACSAV
CRFRE1:	CMP #NDRQBL-4,DRQFCN	;ARE THERE MANY ACTIVE DISK TRANSFERS?
	BLT CRFRE3	;NO, LETS DO SOME
CRFRE2:	JSR PC,SFLUSH	;WAIT FOR THINGS TO CALM DOWN
	CMP #NDRQBL-4,DRQFCN	;HAVE THEY?
	BGE CRFRE2	;NOPE
	JSR PC,RUNME	;MAYBE NOW THERE WILL BE ROOM
	CMP #8,FREECR	;IS THERE AT LEAST 4K?
	BLE CRFRE9	;YES, ASSUME THERE MIGHT BE ENOUGH FREE
CRFRE3:	TST NPBSWO	;ANY PAGES WAITING TO BE SWAPPED OUT?
	BEQ CRFRE4	;NO, BETTER MAKE SOME
	MOV #PBSWPO,A	;POINT TO THE SWAP OUT LIST
1$:	MOV (A)+,B	;LOOK FOR A NON-ZERO ENTRY
	BEQ 1$
	CMP #PBSWOE,A	;WITHIN THE TABLE?
	BUGC LOS	;UGH
	DEC NPBSWO	;ONE LESS ENTRY
	CLR -(A)	;FLUSH IT
CRFRE8:	BIT #PBUSED,(B)	;REALLY STILL THERE?
	BEQ CRFRE3	;NO, TRY AGAIN
	JSR PC,SWPNMP	;SWAP IT OUT (NOT MY PAGE)
	JSR PC,PCLCHK	;MUST PCLOSER SELF IF SWAPPED OUT MY OWN PAGE
CRFRE9:	JMP ACRET	;MAYBE NOW THERE WILL BE SPACE
CRFRE4:	CMP #12.,FREECR	;IS THERE MORE THAN 6K FREE?
	BLE CRFRE7	;THEN THINGS ARE IN BAD SHAPE
	MOV #DORQ,A	;SEE IF ANYONE ON THE DORMANT QUEUE
	MOV #IACTQ,E	;WOULD LIKE TO BECOME INACTIVE
	JSR PC,CRFREL
	BNE CRFRE3	;GOT ONE, GO SWAP OUT A PAGE OF HIS
	MOV #ACTQ,A	;HAVE TO REMOVE AN ACTIVE USER
	MOV #RUNQ,E	;TO THE RUNQ
	JSR PC,CRFREL
	BNE CRFRE3	;GOT ONE, GO SWAP
	BR CRFRE2	;UGH BLETCH!!!!!!

CRFRE7:	INC LOGJAM	;ANOTHER DAY, ANOTHER LOGJAM
	MOV CSTROV,A	;ROVING CSTPB POINTER
1$:	MOV (A)+,B	;GET A PB
	BNE 2$		;FOUND ONE
	BIT #CSTBEB,CST-CSTPB(A)	;COME TOT HE END OF THE CORE?
	BNE 1$		;NOPE
	MOV #CSTPB,A	;RESET POINTER
	BR 1$
2$:	MOV A,CSTROV	;FOR THE NEXT TIME
	BR CRFRE8

CRFREL:	JSR PC,GLQTIM	;GET THE GUY LONGEST ON THE QUEUE
	TST A		;ANYONE ON?
	BEQ CRFRL1	;NOPE
	MOV E,B		;MOVE HIM TO A LESS FAVORED POSITION
	JSR PC,PRSAOD	;DEACTIVATE HIS PAGES
	JSR PC,TQUEUE	;AND MOVE HIM
	CLZ
CRFRL1:	RTS PC
.SBTTL RANDOM UTILITIES FOR MUNGING WITH CORE TABLES
;CONVERT THE GIP IN B TO A PAGE BLOCK POINTER IN B
GIPPB:	SAVE A
	MOV #-1,A
	JSR PC,ITM1PL	;DO A DUMMY PUSH
	TST B		;MAKE SURE WE HAVE A GIP
	BUGC GT		;WHATCH OUT FOR REAL ITEMS
	BIT #GIPSPR,B	;IS IT A SPHERE GIP?
	BEQ GIPPB1	;NOPE
	MOV B,A		;COPY IT
	BIC #GIPITM,A	;GET THE ITEM PART
	ASH #2,A	;MAKE IT A REAL ITEM INDEX
	JSR PC,ITM1LD	;LOAD IT UP
	ADD #SUPTS,A	;POINT INTO UPTS
	BIC #GIPUPT,B	;GET THE UPT #
	ASH #-10.,B	;INTO THE RIGHT PLACE
	MUL #UPTLEN,B	;MAKE IT AN INDEX
	ADD A,B		;REAL POINTER
	BR GIPPB2
GIPPB1:	BIC #GIPBIT,B	;CLEAR THE EXTRA BIT
GIPPB2:	MOV UPTPBP(B),B	;GET THE PAGE BLOCK POINTER
	JSR PC,ITM1PO
	REST A
	RTS PC

;GET A FILE PAGE BLOCK, SETTING THE LENGTH TO WHAT
;IS IN B. RETRUN POINTER TO PAGE BLOCK IN B
;SET PBFILE BUT NOT PBZERO
;SWAP SPACE IS NOT ALLOCATED
;WILL HANG FOREVER FOR PB IF NONE AVAILABLE
FPBGET:	SAVE <A,B>
	MOV #FPBFRE,B	;POINTER TO FILE PAGE BLOCKS
	JSR PC,FREEGT		;GET ONE
	MOV #PBUSED!PBFILE!PBVAS!PBSTS,(A)	;INDICATE IT IS A FILE BLOCK
	BR PBGET1		;GO JOIN NORMAL PB GETTING

;GET A REGULAR PAGE BLOCK, ARGS AND RETURNS
;JUST LIKE FPBGET, EXCEPT IT SETS PBZERO AND NOT PBFILE
PBGET:	SAVE <A,B>
	MOV #PBFREL,B	;POINTER TO REGULAR FREE LIST
	JSR PC,FREEGT	;GET THE BLOCK
	MOV #PBUSED!PBZERO,(A)	;ZERO BLOCK ON FIRST SWAP IN
PBGET1:	JSR PC,FREELK	;MAKE A LOCK THAT WILL PUT IT BACK ON THE FREE LIST
	MOVB (P)+,PBLEN(A)	;POP THE LENGTH OFF THE STACK
	CLRB PBRAN(A)	;CLEAR THE RANDOM BYTE
	CLR PBAUSR(A)	;NO ACTIVE USERS (???)
	CLR PBGIP(A)	;DOESN'T POINT AT GIP
	MOV A,B		;COPY POINTER TO THE PB
	REST A
	RTS PC

;LOCK THE "LOCKED" BIT IN THE PB POINTED TO BY B
;TO BE UNLOCKED WHENEVER SWITCH IS POPED
PBLCK:	SAVE <A,B,C>
	JSR PC,PBWAIT	;WAIT FOR ANY DISKING TO STOP
	MOV B,A
	MOV #PBLOCK,B	;BIT TO LOCK
	CLR C		;NO ITEM
	JSR PC,LCKASW	;LOCK IT
	REST <C,B,A>
	MOV (P),PBLKPC(B)	;SAVE PC
	MOV PRUNNG,PBLKPS(B)	;AND PROCESS
	RTS PC

;GET A NODE OUT OF A STANDARD FREE LIST
;B CONTAINS POINTER TO FREE POINTER
;ON RETURN A CONTAINS POINTER TO GOBBLED NODE
;ROUTINE WILL HANG FOREVER WAITING FOR NODE
FREEGT:	TST (B)		;ANY FREE ONES?
	BNE FREEG2	;YES, GO GOBBLE
FREEG1:	JSR PC,SFLUSH	;WAIT A LITTLE
	TST (B)		;ANY?
	BEQ FREEG1	;NOPE
	JSR PC,RUNME	;HOPE ITS STILL THERE WHEN I GET BACK
	BR FREEGT	;TRY AGAIN
FREEG2:	MOV (B),A	;THE FREE ONE
	MOV (A),(B)	;FREE POINTER NOW POINTS AT NEXT FREE
	RTS PC

;LOCK A STANDARD NODE OFF A FREE LIST
;NO PROCESSING IS DONE ON PCLOSERING EXCPET FREEING THE
;NODE, SO BE CAREFUL HOW YOU USE THIS!
;ON ENTRY, A POINTS TO THE NODE AND B POINTS
;TO THE FREE POINTER FOR THIS TYPE OF NODE
FREELK:	SAVE <A,B>
	MOV #LSPULN,A	;AN UNLINK TYPE OF LOCK
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV (P),LCKWD2(A)	;LOCK WORD 2 POINTS TO THE FREE POINTER
	MOV 2(P),LCKWD1(A)	;WORD ONE POINTS TOT EH NODE
	REST <B,A>
	RTS PC

;THIS CROCK WILL FREE A LOCKED LIST NODE IF YOU FAIL IN
;SOME WAY OTHER THAN PCLOSERING BY PRETENDING TO PCLOSER
;FOR THE TOP SWITCH
FRELSE:	MOV PC,BPCLSR	;SAY WE ARE PCLOSERING
	JSR PC,LSWPOP	;POP THE SWITCH
	CLR BPCLSR	;PREVIOUS STATEMENTS ARE NOW INOOPERATIVE
			;(WE LIED)
	RTS PC
.SBTTL CORE HACKING ROUTINES
;INTIAL MAP-SETTING ROUTINE
;CLOBBERS MOST AC'S, INTENDED TO BE RUN ONLY AT ITIALIZE TIME
;OR AFTER A POWER FAIL RESTART
MAPSET:	MOV #I0AR,A	;FIRST WE'LL SET UP A STRAIGHT MAP
	CLR B		;I AND D SPACE THE SAME AND MAPPED DIRECTLY
	MOV #8.,C	;FROM VIRTUAL CORE TO PHYSICAL
MAPST1:	MOV #77406,VAR0DR-I0AR(A)	;DATA SPACE 4K SEGEMNET
	MOV #77406,I0DR-I0AR(A)		;INSTRUCTION SPACE 4K SEGMENT
	MOV B,VAR0AR-I0AR(A)		;VIRTUAL MAPPED DIRECTLY TO PHYSICAL
	MOV B,(A)+			;FOR BOTH INST AND DATA SPACE
	ADD #200,B	;4K WORTH
	SOB C,MAPST1	;DO FORR 8 SEGMENTS
	;NOW WE'LL HACK THE SPEECAIL THINGS
	MOV #7600,IOAR	;MAP USUAL I/O SPACE TO REAL I/O SPACE
;THE FOLLOWING THING IS THE DR FOR THE RUG PAGES (UGH!)
FOO==<<200-<<RUGIDR-I0DR+2>*100>+<<RUGST_-6>&1777>>_8.>+16
	MOV #FOO,RUGDDR	;MAP 156000-157776 VIRTUAL TO SAME PHYSICAL
	MOV #VAR2DR,A	;NOW FLUSH UNUSED VARIABLE PAGE AND 3 ITEM PAGES
	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)
	MOV #I7DR,A
	CLR (A)		;FLUSH HIGH INSTRUCTION PAGE
	TST -(A)	;DON'T CLOBBER RUG PAGE
	MOV #120000,B	;FIRST LOCATION IN A PAGE BEFORE RUG PAGE
MAPST2:	CMP #LSTILC,B	;LAST INSTRUCTION LOCATION
	BHI MAPST3	;IF THERE IS SOMETHING THERE, WE'RE DONE
	CLR -(A)	;NO ONE THERE, FLUSH IT
	SUB #20000,B	;NEXT PAGE DOWN
	BR MAPST2
MAPST3:	MOV #7,SSR3	;ENABLE I AND D FOR ALL MAPS
	MOV #1,SSR0	;THERE WE GO!!
	RTS PC
;MAP RESTORE ROUTINE
;CLOBBERS NO REGISTERS
;EXPECTS THE SPHERE TO RESTORE IN ITEM1
;DOES NOT RESTORE IF CURSPH IS SAME AS ITEM1
MAPRES:	CMP CURSPH,ITEM1	;IS IT ALREADY LOADED?
	BNE 1$		;NO
	RTS PC
1$:	CMP #-1,CURSPH	;IS THERE A SPHERE MAPPED IN?
	BUGC NE	;UGH, THAT MEANS HIS W BITS DIDN'T GET COPIED OUT!
MAPRE1:	MOV ITEM1,CURSPH
	JSR F,ACSAV	;THIS IS THE ENTRY POINT FOR RESTORING THE MAP EVERY TIME
	MOV #20,A	;FOR ALL PAGES
	MOV #USRISD,B	;ALL DR'S
1$:	CLR (B)+	;MAKE NON-EX
	SOB A,1$
	MOV ITM1A,A	;POINTER TO THE ITEM
	ADD #SUPTS,A	;GET POINTER TO UPTS FOR SPHERE
	CLR B		;POINT TO USER MAP
	MOV #20,C	;NUMBER OF SEGMENTS TO LOAD
MAPRE2:	TST (A)		;DOES THE PAGE EXIST?
	BEQ MAPRE3	;NO PAGE HERE
MAPRE7:	BIT #UPTABS,(A)	;IS IT AN ABS PAGE?
	BNE MAPRE8	;YUP, GO LOAD IT
	BIT #UPTDEI,(A)	;IS IT THE DATA PART OF A D=I ?
	BNE MAPRE3	;YUP, GO IGNORE IT
	MOV UPTPBP(A),D	;GET A POINTER TO THE PAGE BLOCK
	BEQ MAPRE3	;NO PB=>NO PAGE
	BIT #PBVACR,(D)	;IS THE PAGE IN CORE?
	BEQ MAPRE3	;NOPE, IGNORE IT
	BIT #PBLOCK!PBDISK,(D)	;LOCKED OR IN DISK TRANSFER?	
	BNE MAPRE3	;IF SO, IGNORE IT
	MOVB UPTSTL(A),E	;GET THE UPT START AND LENGTH
	BIC #UPTSMS,E	;CLEAR OFF CRAP
	ASH #-UPTSSH,E	;SHIFT TO GET # OF START BLOCK
	MOVB PBRAN(D),F	;TO GET PB START
	BIC #PBSTRT,F	;IT IS IN BLOCKS
	SUB F,E		;GETS HOW FAR PAST PB START UPT START IS
	ADD PBCAR(D),E	;WHICH TELLS US WHAT TO ADD TO THE CORE ADDRESS
	ASH #4,E	;32.=512.
	BIT #UPTEXD,(A)	;IF IT IS EXPAND DOWN
	BUGC NE	;WE HAVE TO DO SPECIAL STUFF
	MOV E,USRISA(B)	;LOAD THE AR
	MOVB UPTSTL(A),E	;NOW TO GET THE START TO USE
	BIC #UPTLMS,E	;GET THE START
	ASH #12.,E	;GET INTO DR FORMAT
	BIS #17_8.,E	;FIX FOR THE SEGMENTER
	MOV #4,F	;READ/WRITE TRAP (TRAP IS NOT ENABLED THOUGH)
	BIT #UPTRDO,(A)	;IS IT READ-ONLY?
	BEQ 1$		;NO, READ-WRITE
	MOV #1,F	;READ-ONLY, TRAP
1$:	BIS F,E		;SET INTO DR WORD
	MOV E,USRISD(B)	;SET INTO THE DR
MAPRE6:	BIT #UPTIED,(A)	;IS THIS TH EI SPACE HALF OF AN I=D?
	BEQ MAPRE3
	MOV USRISD(B),USRDSD(B)	;COPY THE DR
	MOV USRISA(B),USRDSA(B)	;COPY THE AR
MAPRE3:	TST (B)+	;NEXT
	ADD #UPTLEN,A
	DEC C
	BEQ 1$
	JMP MAPRE2
1$:
.IFNZ TVS
	MOVB #73,TVSHR+1	;SET THE THING INTO MEMORY
	MOV ITM0A,A	;POINTER TO ITEM 0
	MOVB PTVMAP+1(A),TVSEL	;SET SELECT REGISTER
	MOVB PTVMAP(A),D	;SET >0 IF HE WANTS IT IN HIS MAP	
	BMI MAPRE0		;DOESNT WANT IT
	CLR TVMSK		;NO MASKING
	ASL D		;FOR INDEXING
	MOV #4,E	;MAX NUMBER OF DISPLAY PAGES
	MOV #6600,F	;THE APPROPRIATE AR
MAPRE4:	CMP #20,D	;PAST ALL THE POSSIBLE D PAGES?
	BLOS MAPRE0	;THEN WE'RE DONE	
	MOV #77406,USRDSD(D)	;A FULL 4K PAGE
	MOV F,USRDSA(D)	;WHERE THE DISPLAY IS
	ADD #200,F	;4K MORE
	TST (D)+	;NEXT PAGE
	SOB E,MAPRE4
.ENDC
MAPRE0:	JSR F,ACRES
MAPRE9:	RTS PC

MAPRE8:	MOV UPTPBP(A),USRISA(B)	;PB POINTER IS THE AR
	MOV UPTGIP(A),USRISD(B)	;GIP POINTER IS THE DR
	BR MAPRE6		;CHECK FOR I=D
;THE MEMORY TABLE INITIALIZER
;CLOBBERS ALL REGISTERS
MEMTST:	MOV #20,ITM0AR	;FIRST FIND HOW MUCH MEMORY
	MOV #6,ITM0DR	;LENGTH 1 PAGE
	SAVE BEBRV	;SAVE THE BUSS ERROR VECTOR
	MOV #MEMTS1,BEBRV	;TRAP BACK TO THE ROUTINE
	MOV #MNCBLK,A		;THE MOST WE WILL PAY ATTENTION TO
	MOV #CST,B
MEMTS2:	TST ITM0AD	;CAUSE BUSS ERROR IF NXM
	ADD #20,ITM0AR	;INCREMENT BY 512 WORDS
	MOV #CSTBEB!CSTSYB,(B)+	;SAY IT EXISTS AND SYSTEM USING IT
	SOB A,MEMTS2	;TRY AGAIN UNLESS WE HAVE ENOUGH
	MOV B,CSTTOP
	BR MEMTS3
MEMTS1:	SPL 0
	MOV B,CSTTOP
	CMP (P)+,(P)+	;FLUSH THE TRAP
1$:	MOV #CSTSYB,(B)+	;SAY THE SYSTEM IS USING NON-EX CORE
	SOB A,1$
MEMTS3:	REST BEBRV
	MOV ITM0AR,B
.IF NZ NTVS
	CMP #<124.-16.>*<1024./32.>,B	;DOES CORE CONFLICT WITH DISPLAY?
	BUGC LO
.ENDC
	SUB #20+<<<RUGIAR-I0AR>+2>*100>,B	;CONVERT TO AMOUNT ABOVE RUG
	BUGC LE		;IS THERE ENOGUH FOR RUG
	ASH #-4,B	;CONVERT TO 512 WORD BLOCKS
	MOV #<<RUGIAR-I0AR>+2>*4,A	;FIRST BLOCK AFTER RUG
.IIF NZ NTKDIS,JSR PC,DISALC
	ASL A		;CONVERT TO
	ADD #CST,A	;INDEX IN TO THE CST
	MOV B,FREECR	;AMOUNT OF FREE CORE
MEMAL1:	BIC #CSTSYB,(A)	;NOT USED BY SYSTEM
	BIS #CSTFRB,(A)+	;AND FREE
	SOB B,MEMAL1

	MOV #CST+<FSTFRB*2>,A	;POINT TO FIRST FREE CST ENTRY
	MOV #<<<RUGST-LSTILC>_-10.>>&77-1,B	;NUMBER FREE BEFORE RUG
	ADD B,FREECR
	MOV FREECR,USRCOR	;ALL FREE CORE IS CURRENTLY USER CORE
MEMAL2:	BIC #CSTSYB,(A)
	BIS #CSTFRB,(A)+	;FREE BLOCK, NOT USED BY SYSTEM
	SOB B,MEMAL2
	MOV #CSTSYB!CSTBEB,CST+<<RUGST_-9.>&176>	;PROTECT RUG PAGE
	RTS PC
.IFNZ NTKDIS
;DISPLAY ALLOCATION ROUTINE
;ENTER WITH PLACE TO START ALLOCATING IN A
;NUMBER OF BLOCKS FREE IN B
;RETURN WITH A POINTING PAST WHAT WE HAVE ALLOCATED
;AND B HAVING WHAT WE HAVE ALLOCATED REMOVED
DISALC:	CMP #100,A	;THE DISPLAYS MUST START
	NBUGC LE
	MOV A,C		;SAVE START
	ASH #10.,C	;CONVERT TO WORD ADDRESS
	MOV C,TKRELS	;AND SAVE AS THE RELOCATION
	MOV C,NGREL	;ALSO SET RELOCATION
	MOV #1,C	;LENGTH ONE BLOCK
	JSR PC,ITMFAK	;FAKE UP AN ITEM
	MOV D,TKDPDL	;THE PDL AND START VECTOR ITEM
	MOV ITMTAB(D),TKDPDA	;SAVE THE START IN A CONVEINET PLACE
	CLR E		;THE ONE WE ARE ALLOCATING
	MOV #NTKDIS,F
DISAL1:	MOV TKDLEN(E),C	;LENGTH FOR THIS ONE
	JSR PC,ITMFAK	;FAKE UP AN ITEM
	MOV D,TKDITM(E)	;SAVE THE ITEM FOR THIS DISPLAY BUFFER
	TST (E)+
	SOB F,DISAL1
	SAVE <A>
	MOV TKDPDL,A	;THE PDLS AND START WORDS
	JSR PC,ITM2LD
	MOV #8.,C
DISAL2:	MOV #DSTOP,(A)+	;STOP ALL DISPLAYS
	SOB C,DISAL2
	REST <A>
	RTS PC

;FAKE UP AN ITEM
ITMFAK:	SAVE <C>
	MOV ITMFRE,D	;THE ITEM LIST
	MOV (D),ITMFRE	;TAKE THIS ITEM
	ASH #4,C	;MAKE LENGHT INTO 32. WORD BLOCKS
	DEC C		;CAUSE OF WAY SEGMENTS WORK
	MOVB C,ITLNGT(D)	;SET LENGHT
	MOVB #ITACCD,ITACCS(D)	;AND ACCESS
	MOV A,C		;COPY START
	ASH #4,C	;MAKE IT INTO 32. WORD BLOCKS
	MOV C,(D)	;SET THE ADDRESS INTO THE ITEM
	SUB #ITMTAB,D	;MAKE IT INTO AN ITEM NUMBER
	REST <C>	;RESTORE LENGHT IN 512. WORD BLOCKS
	ADD C,A		;NEXT PLACE TO ALLOCATE
	SUB C,B		;STUFF WE'VE USED
	BUGC LE
	RTS PC
.ENDC
;TRY TO FIND A NUMBER OF CONTIGOUS BLOCKS LARGE ENOUGH FOR THE PAGE
;REPRESENTED BY THE PB POINTED TO BY B
;ON SUCESS, CLOBBER THE CAR OF THE PAGE TO THE RIGHT THING
;AND UNFREE THE CORE IN CST AND CSTPB
FINPAG:	TST PBCAR(B)	;DOES IT ALREADY HAVE CORE?
	BNE FINPA0	;YES, JUST RETURN WINNING
	JSR F,ACSAV	;MIGHT AS WELL SAVE THEM ALL...
	MOVB PBLEN(B),A	;HOW LONG DO WE NEED?
	INC A		;0=1
	CMP A,FREECR	;DO WE HAVE THAT MUCH ALL TOGETHER?
	BGT FINPA8	;NO WAY TO WIN
	MOV CST1FR,C	;POINT TO CST ENTRY OF FIRST FREE BLOCK
	MOV #CSTFRB,E	;A COMMONLY USED CONSTANT
	MOV CSTTOP,F	;GENERATE NUMBER OF TIMES TO TRY
	SUB C,F		;DEIFFERENCE OF TOP AND FIRST FREE
	ASR F		;WORDS
FINPA1:	MOV A,D		;COPY THE LENGTH
	BIT E,(C)+	;THIS ONE FREE?
	BNE FINPA3	;GOT ONE
FINPA4:	SOB F,FINPA1	;KEEP TRYING
	BR FINPA8	;NO GOOD

FINPA3:	MOV C,B		;SAVE POINT TO START OF BLOCK+2
	DEC D		;GOT ONE BLOCK, IS THAT ENOUGH?
	BEQ FINPA9	;YUP, WIN
FINPA5:	BIT E,(C)+	;IS NEXT ONE FREE?
	BEQ FINPA4	;NO, HAVE TO TRY ANOTHER PAGE
	DEC D		;ONE MORE, ENOUGH?
	BEQ FINPA9	;YUP
	SOB F,FINPA5	;KEEP TRYING
	INC NOFIT	;INCREMENT NUMBER OF TIMES THAT A PAGE WOULDN'T FIT
FINPA8:	JMP ACRETS	;NO LUCK, GIVE UP

FINPA9:	MOV B,F		;GET BACK THE POINTER TO THE START+2
	TST -(F)	;BACK UP TOT HE REAL ENTRY
	MOV F,C		;COPY IT
	MOV A,D		;AND THE LENGTH
FINPA6:	MOV 2(P),CSTPB-CST(C)	;THIS PAGE OCCUPIES THIS BLOCK
	BIC E,(C)+	;BLOCK IS NO LONGER FREE
	SOB D,FINPA6
	SUB A,FREECR	;TAKE THIS AWAY FROM FREE CORE
	BNE FINP10	;SOMETHING STILL FREE
	MOV CSTTOP,CST1FR	;TOP IS FIRST FREE, IS NOTHING
	BR FINPA7

FINP10:	CMP F,CST1FR	;IS THIS WHAT USED TO BE FIRST FREE?
	BNE FINPA7	;NOPE
1$:	BIT E,(C)+	;IS THIS FREE?
	BEQ 1$		;LOOP UNTIL WE FIND THE FIRST FREE BLOCK
	TST -(C)	;OVERSHOT	
	MOV C,CST1FR	;REPLACE WITH NEW FIRST FREE
FINPA7:	SUB #CST,F	;GET THE BLOCK NUMBER
	ASR F
	MOV 2(P),B	;GET BACK POINTER TO THE PB
	MOV F,PBCAR(B)	;AND PUT TI INTO THE PB
	JSR F,ACRES
FINPA0:	CLZ
	RTS PC
;FLUSH CORE USED BY THE B IN B, PCLOSERING AS NEEDED
PBCFLS:	BIT #PBVACR,(B)	;IS THE PAGE IN CORE?
	BEQ PBCFR9	;NO, DON'T NEED TO WORRY
	SAVE B		;SAVE THE PB POINTER
	MOV PBGIP(B),B	;GET A GIP FOR IT
	JSR PC,PAGPCL	;PCLOSER ANYONE WHO MIGHT HACK THIS PAGE
	JSR PC,PCLCLR	;I DON'T WANT TO BE PCLOSERED BY THIS!
	REST B		;GET BACK PB POINTER
			;FALL IN
;FREE THE BLOCKS BELONGING TO THE PAGE BLOCK POINTED TO BY B
PBCFRE:	SAVE <A,C>
	BIT #PBDISK!PBLOCK,(B)	;BETTER NOT BE LOCKED OR DISKING
;	BUGC NE
	BEQ 1$
	JSR PC,BUGGER
1$:	BIC #PBVACR,(B)	;NO LONGER VALID IN CORE
	MOVB PBLEN(B),A		;GET THE LENGTH
	INC A			;0=1
	MOV PBCAR(B),C		;GET THE START
	BEQ PBCFR2		;SOMEONE ELSE ALREADY FREED HIS CORE
	CLR PBCAR(B)		;NO LONGER VALID
	ASL C			;CONVERT TO A WORD INDEX
	ADD #CST,C		;POINTER INTO CST
	CMP C,CST1FR		;IS THIS BEFORE THE FIRST FREE?
	BHI PBCFR1			;NO
	MOV C,CST1FR		;NOW THIS IS FIRST FREE
PBCFR1:	BIS #CSTFRB,(C)	;FREE THE BLOCK
	CLR CSTPB-CST(C)		;DOESN'T BELONG TO ANYONE
	INC FREECR		;ONE MORE FREE
	TST (C)+		;NEXT
	SOB A,PBCFR1		;AS MANY TIMES AS NEEDED
PBCFR2:	REST <C,A>
PBCFR9:	RTS PC

BUGGER:	BIT #10,CSWR
	BEQ 1$
	BPT
1$:	MOV ITM0A,A
	BIS #PPCLSR,PFLAGS(A)
	JSR PC,PCLCHK
	BPT

.SBTTL FUPT HACKING ROUTINES
;GET A FUPT THAT POINTS AT A PB THAT REPRESENTS (B) BLOCKS OF FREE CORE
;ON EXIT, A CONTAINS A GIP TO THE NEW PAGE AND B POINTS TO THE PB
;Z IS SET IF NO SWAP SPACE IS AVAILABLE
;A SWITCH IS PUSHED THAT WILL DELETE THE PAGE IF PCLOSERED
FRCRGT:	JSR PC,PBGET	;GET A PAGE BLOCK
	JSR PC,FUPTGT	;GET A FUPT AND POINT IT AT THE PB
	JSR PC,FINSWP	;TRY TO FIND SWAP SPACE FOR IT
	BEQ FRCRG1	;CAN'T
	JSR PC,LSWPOP	;POP LOCK FOR FUPT
	JSR PC,LSWPOP	;POP LOCK FOR PB
	SAVE <B,A>	;NOW TO LOCK FPT A DIFFERENT WAY
	MOV #LSPPCL,A	;RUN ROUTINE ON PCLOSER
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;GET A LOCK BLOCK
	MOV #FUPTFL,LCKWD1(A)	;ROUTINE
	MOV (P),LCKWD2(A)	;FUPT POINTER
	REST <A,B>
	CLZ
	RTS PC
FRCRG1:	JSR PC,FRELSE	;FLUSH THE FUPT
	JSR PC,FRELSE	;FLUSH THE PB
	SEZ
	RTS PC

;GET A FUPT TO POINT TO THE PB POINTED TO BY B
;COPY THE LENGTH FROM THE PB INTO THE FUPT
FUPTGT:	SAVE <C,B>
	MOV #FUPTFR,B	;FREE POINTER FOR FUPTS
	JSR PC,FREEGT	;GET ONE
	JSR PC,FREELK	;LOCK IT
	MOV (P),B	;POINTER TO THE PB
	MOV B,UPTPBP(A)	;POINT FPT AT IT
	CLR FUPTPR(A)	;THE THING CURRENTLY IS NOT LOCKED BY A PROCESS
	MOV #UPTEXB,UPTFLG(A)	;INIT THE FLAGS
	MOVB PBLEN(B),UPTSTL(A)	;INIT THE LENGTH AND START
	TST PBGIP(B)	;DOES THIS PB POINT TO OTHER UPTS?
	BEQ FUPTG1	;NO, EASY CASE
	MOV PBGIP(B),B	;FIRST ONE IT POINTS TO IN CIRC LIST
	JSR PC,UPTPLD	;PUSH AND LOAD 
	MOV UPTGIP(B),UPTGIP(A)	;POINT  NEW ONE TO 2ND IN LIST
	BIS #GIPBIT,A	;MAKE A A VALID GIP
	MOV A,UPTGIP(A)	;POINT FIRST IN LIST AT NEW ONE
	JSR PC,ITM2PO	;RESTORE ITEM2
FUPTG2:	REST <B,C>
	RTS PC
FUPTG1:	MOV A,C		;COPY POINTER TO NEW FUPT
	BIS #GIPBIT,A	;MAKE A VALID GIP
	MOV A,PBGIP(B)	;POINT THE PB AT IT
	MOV A,UPTGIP(C)	;AND POINT IT AT ITSELF
	BR FUPTG2

;THIS PCLOSER ROUTINE FLUSHS A FUPT ASSUMMING IT HAS NO CIRCLAR LIST
;AND THE PAGE DOESN'T NEED TO BE SWAPPED BACK TO SOURCE
FUPTFL:	MOV LCKWD2(B),B	;GET THE GIP
	BIC #GIPBIT,B	;CONVERT TO FUPT POINTER
	SAVE B		;WE'LL NEED IT OCCASIONALLY
	MOV UPTPBP(B),B	;POINT TO THE PB
	JSR PC,PBSFRE	;FREE THE SWAP SPACE
	JSR PC,FPBFR	;FREE A FILE PAGE BLOCK
	REST B		;GET FUPT POINTER BACK
	MOV FUPTFR,A	;ONES FREE NOW
	MOV B,FUPTFR	;NEW ONE
	MOV A,(B)	;INTO LIST
	RTS PC

;MAKES A GENERALIZED ITEM POINTER, B CONTAINS UPT NO, C CONTAINS SPHERE NO.
;THEN DELETES UPT, BY FALLING INTO UPTDL
SUPTDL:	ASH #10.,B		;SET THE UPT NO. IN THE CORRECT BITS
	ASH #-2,C		;FOR GIP
	BIS C,B			;SET IN THE ITEM NO.
	ASH #2,C
	BIS #GIPBIT!GIPSPR,B	;SAY IT IS A GIP AND IN A SPHERE
;FALL INTO UPTDL
;THIS ROUTINE FLUSHS A UPT THAT MIGHT HAVE A CIRCULAR LIST
;AND THAT MIGHT POINT AT CORE THAT IS NOT VALID AT SOURCE
;NEEDLESS TO SAY, IT MIGHT HANG
;THE UPT IS POINTED TO BY B, WHICH MIGHT GET CLOBBERED
UPTDL:	JSR PC,SAVAWB	;IN CASE WE AFFECT A MAPPED IN PAGE
	JSR F,ACSAV
	SAVE B		;SAVE THE ACTUAL GIP
	JSR PC,UPTPLD	;LOAD UP THE UPT
	SAVE B		;SAVE THE POINTER TO THE UPT
	BIT #UPTABS,(B)	;ABSOLUTE PAGE?
	BNE UPTDL7	;YUP, EASY
	TST (B)		;DOES IT EXIST?
	BEQ UPTDL7	;NO, JUST AS EASY
UPTDL4:	MOV UPTPBP(B),B	;GET ITS PB POINTER
	JSR PC,PBWAIT	;MAKE SURE PAGE IS STABLE
	BIT #PBVAS,(B)	;IS IT VALID AT SOURCE?
	BNE UPTDL1	;YES, WE'RE SAFE
	MOV 2(P),B	;GET BACK GIP POINTER TO IT
	JSR PC,SWPIN	;SWAP IT IN
	JSR PC,VALSRC	;VALIDATE IT AT THE SOURCE
	JSR PC,GPWAIT	;WAIT FOR IT TO SETTLE DOWN
	MOV (P),B	;GET ADDRESS BACK
	BR UPTDL4	;DOUBLE CHECK
UPTDL1:	MOV (P),B	;GET BACK THE ADDRESS
	CMP 2(P),UPTGIP(B)	;DOES IT POINT TO ITSELF?
	BEQ UPTDL8	;YES, EASY CASE
	CLR E		;NO BITS SET YET
	SAVE <UPTGIP(B),UPTGIP(B)>	;TWO COPIES OF WHAT IT POINTS TO	
UPTDL2:	MOV (P),B	;GET THE NEXT POINTER
	JSR PC,UPTLD	;LOAD IT
	MOV UPTGIP(B),(P)	;GET THE NEW NEXT
	JSR PC,UPTEST	;SET BITS IN E ACCORDING TO UPT
	CMP 6(P),(P)	;IS THE NEXT THING THE THING WE STARTED WITH?
	BNE UPTDL2	;NOPE, KEEP TRING
	MOV 2(P),UPTGIP(B)	;THIS UPT POINTS AT WHAT WE WANT TO FLUSH
				;2(P) IS WHAT THE THING WE ARE FLUSHING POINTS TO
				;THUS, THIS INST FLUSHES THE UPT WE WANT TO FLUSH
	MOV 6(P),B	;GET POINTER TO GIP BEING FLUSHED
	JSR PC,UPTLD	;MAKE SURE THATS WHATS LOADED
	MOV UPTPBP(B),B	;GET POINTER TO THE PB
	CMP 6(P),PBGIP(B)	;WAS THIS THE ONE THE PB POINTED TO?
	BNE 1$		;NO, SAFE
	MOV 2(P),PBGIP(B)	;DON'T LET THE PB GET LONELY
1$:	CLR C		;ACCUMULATE STARTT
	JSR PC,PBLFIX	;GO FIX UP THE PB TO ACCOMADATE ONLY WHAT'S LEFT
	CMP (P)+,(P)+	;FLUSH DUMMIES FROM STACK
UPTDL7:	REST B		;GET BACK ORRIGINAL ADDRESS
	BIT #GIPSPR,(P)	;IS IT A SPHERE UPT?
	BNE UPTDL3	;GO HANDLE THAT
;COME HERE FOR FUPT
UPTD.2:	SAVE FUPTFR	;LINK INTO
	MOV B,FUPTFR	;THE FREE LIST
UPTDL5:	REST (B)	;THE FUPT
	REST B		;GET BACK THE NOW USLESS GIP
	JSR PC,ITMFLS	;FLUSH THIS IF IT MIGHT EVER GET LOADED SOMEPLACE
	JSR PC,MAPRES
	JMP ACRTP2
UPTDL3:	BIT #UPTABS,(B)	;ABSOLUTE PAGE?
	BNE UPTD.1	;IGNORE
	BIT #UPTEXB,(B)	;EXIST?
	BEQ UPTD.1	;NO, IGNORE
	SAVE <A,B,C>
	MOV ITM2A,A	;POINT TO SPHERE BEING AFFECTED
	MOV SPHAPR(A),C	;NUMBER OF ACTIVE PROCESSES
	MOV UPTPBP(B),B	;THE PB BEING AFFECTED
	JSR PC,PBDACT	;DEACTIVE THIS MANY TIMES
	REST <C,B,A>
UPTD.1:	CLR -(P)	;TO CLOBBER UPT WHEN DONE
	BIT #UPTDEI,(B)	;IS IT A D=I PAGE?
	BEQ UPTDL0	;NO
	BIC #UPTIED,-8.*UPTLEN(B)	;DELETE CORESPONDING BIT INI PAGE
	BR UPTDL5
UPTDL0:	BIT #UPTIED,(B)	;IS IT THE I HALF?
	BEQ UPTDL5	;NOPE
	BIC #UPTDEI,8.*UPTLEN(B)	;DELETE COORESPONDING BIT
	BR UPTDL5

UPTDL8:	MOV (P),B	;GET POINTER TO FUPT
	MOV UPTPBP(B),B	;GET POINTER TO PB
	MOV (B),C	;UGH, SAVE FLAGS
	JSR PC,PBCFRE	;FREE THE CORE
	JSR PC,PBSFRE	;FREE THE SWAP SPACE
	JSR PC,FPBFR	;FREE FPB OR REGUALR PB
	BIT #PBFILE,C	;IS IT A FILE PAGE?
	BEQ UPTDL6		;NO, NOTHING SPECIAL THEN
	JSR PC,MFIPBD	;DELETEING A PB FROM AN MFI
UPTDL6:	REST B
	BIT #GIPSPR,(P)	;DELETED FROM SPHERE?
	BEQ UPTD.2	;NO, FREE FUPT
	CLR -(P)	;YES, PREPARE TO CLOBBER UPT
	BR UPTDL5

;FLUSH THE THING IN B FROM ANY ITEMS IT MIGHT GET LOADED INTO
;IN ENGLISH, CLOBBER THIS ITEM OFF OF STACKS AND ITEMN
ITMFLS:	SAVE <A,C>
	.IRPC N,<012>
	CMP B,ITEM'N	;LOADED INTO THIS ITEM?
	BNE ITMFL'N	;NOPE
	MOV #-1,ITEM'N	;DUMMY ITEM
ITMFL'N:	MOV ITM'N'D,A	;NUMBER OF FROBS ON THIS STACK
	BEQ 1$	;NONE
	MOV ITM'N'P,C	;STACK POINTER
3$:	CMP B,(C)	;SAME?
	BNE 2$		;NOPE
	MOV #-1,(C)	;CLOBBER
2$:	TST (C)+	;NEXT
	SOB A,3$
1$:
.ENDM
	REST <C,A>
	RTS PC
;SET BITS IN E CORESPONDING TO BLOCK STHE UPT POINTED TO
;BY B USES.
;CLOBBERS C AND D
UPTEST:	MOVB UPTSTL(B),C	;GET START AND LENGTH
	BLT EBSET2	;NOT SET UP YET FOR THIS GUY
	MOV C,D		;COPY IT
	BIC #UPTLMS,D	;GET LENGTH
	BIC #UPTSMS,C	;AND START
	ASH #-UPTSSH,C	;SHIFT START
;ENTER HERE TO JUST SET THE BITS FOR THE START IN C AND LENGHT IN D
;CLOBBERS C AND D
EBSET:	INC D		;0=>1
EBSET1:	CMP #7,C	;CHECK THAT BLOCK IS OK
	ERRORC LO,BAD	;BAD ARGUMENT TO CALL
	BISB BMT(C),E	;SET BIT FOR THIS BLOCK
	INC C		;NEXT BLOCK
	SOB D,EBSET1	;GO FOR THE WHOLE LENGTH
EBSET2:	RTS PC

;CALL THIS TO FIX UP A PB TO CONFORM TO THE NEEDS REPRESENTED
;BY THE BITS IN E. B POINTS TO THE PB, C AND D GET CLOBBERED
PBLFIX:	TST E		;ANY?
	BEQ PBLFI9	;NOPE
	CLR C
PBLFI1:	BITB BMT(C),E	;THIS BIT ON?
	BNE PBLFI6	;YUP, WE HAVE THE START
	INC C		;ONE MORE
	BR PBLFI1
PBLFI6:	MOV #7,D	;NOW FROM THE OTHER END
PBLFI7:	BITB BMT(D),E	;THIS ONE HERE?
	BNE 1$		;YUP
	SOB D,PBLFI7	;KEEP TRYING
1$:	SUB C,D		;CONVERT END TO LENGTH
	CMPB D,PBLEN(B)	;SAME LENGTH AS BEFORE?
	BNE PBLFI4	;NO, NEED TO FLUSH FROM CORE
	MOVB PBRAN(B),E	;GET THE START
	BIC #PBSTRT,E
	ASH #-UPTSSH,E
	CMP C,E		;STARTS THE SAME?
	BEQ PBLFI5	;YUP, NO NEED TO CHANGE
PBLFI4:	JSR PC,PBCFLS	;FLUSH THE PB'S CORE
	BIT #PBFILE,(B)	;SWAP TO SOURCE?
	BEQ PBFLI8	;YES, OK
	BIC #PBVASS,(B)	;IT IS NOT VALID ON SWAP SPACE, MUST GET FROM SOURCE
PBFLI8:	MOVB D,PBLEN(B)	;SET THE LENGTH
	BICB #7,PBRAN(B)	;FLUSH OLD START
	BISB C,PBRAN(B)	;SET IN NEW START
PBLFI5:	RTS PC
PBLFI9:	MOV #-1,D	;NO BLOCKS
	BR PBLFI4
;PC LOSER ROUTINE TO CLOBBER A FUPTPR BACK TO ZERO
PRPFIX:	MOV LCKWD2(B),A	;GET POINTER TO FUPT
	CMP ITEM0,FUPTPR(A)	;DO I HAVE IT LOCKED?
	BUGC NE	;UGH, I SHOULDN'T BE UNLOCKING IT!
	CLR FUPTPR(A)	;UNLOCK
	MOV UPTPBP(A),B	;THE PB BEING AFFECTED
	MOV #1,C	;ONE PROCESS
	JSR PC,PBDACT	;NO LONGER REFERS TO IT
	RTS PC

;SET THE FUPTPR OF AN FUPT
;HANG UNTIL IT IS ZERO, THEN SET IT TO RUNNING PROCESS
;WITH A ROUTINE TO RUN WHEN THE LOCK IS POPED
FUPTLK:	JSR F,ACSAV
	BIC #GIPBIT,B	;CONVERT TO CORE ADDRESS
FUPTL3:	TST FUPTPR(B)	;ALREADY LOCKED?
	BEQ FUPTL1
	CMP PRUNNG,FUPTPR(B)	;AM I THE GUY WHO HAS IT LOCKED?
	BUGC EQ	;WILL NEVER BE AVAILABLE..
FUPTL2:	JSR PC,SFLUSH	;WAIT
	TST FUPTPR(B)	;TRY AGAIN
	BNE FUPTL2
	JSR PC,RUNME
	BR FUPTL3
FUPTL1:	MOV ITEM0,FUPTPR(B)	;SAY I USE THIS FUPT
	MOV B,F		;SAVE POINTER TO IT
	MOV #LSPRTN,A	;RUN THIS ROUTINE WHEN UNLOCKED
	CLR B		;SAY THERE IS NO ITEM
	JSR PC,LOCKSW	;LOCK A SWITCH
	MOV #PRPFIX,LCKWD1(A)	;PUT IN THE ROUTINE TO RUN
	MOV F,LCKWD2(A)	;POINTER TO THE FUPT TO FIX
	MOV UPTPBP(F),B	;THE PB BEING AFFECTED
	MOV #1,C	;ONE PROCESS
	JSR PC,PBACT	;REFERES TO IT
FUPTL4:	JMP ACRET
;ROUTINE TO FIX UP A PB TO BE A SPECIFIED START AND LENGTH
;CALL WITH PB POINTER IN B, DESIRED START IN C
;DESIRED LENGTH IN D
;ROUTINNE RETURNS WITH Z SET IF NOT ALL THE REQUESTED
;BLOCKS EXIST IN A FILE PAGE
PBSETU:	JSR F,ACSAV
	JSR PC,PBLONG	;GET THE NEEDED START AND LENGTH
			;AND THE CURENT START AND LENGTH
	BEQ PBSET1	;NOT ALL BLOCKS OF FILE PAGE EXIST
	CMPB #-1,PBLEN(B)	;IS THE PAGE NOT SET UP?
	BEQ PBSET3	;THEN JUST SET IT
	CMP C,E		;IS NEEDED START = EXISTING?
	BNE PBSET2	;NO, NEED TO WORK
	CMP D,F		;IS NEEDED LENGTH EQUAL ALSO?
	BNE PBSET2	;OH WELL...
	JMP ACRETC	;NOTHING TO DO

PBSET2:	BIT #PBVAS,PBFLAG(B)	;IS IT VALID AT SOURCE?
	BNE PBSET3	;YES, WE CAN CLOBBER THE PAGE
	JSR PC,PBSWPI	;MAKE SURE PAGE IS IN CORE
	JSR PC,PBVLSR	;VALIDATE THE PAGE AT SOURCE
	JSR F,ACRES
	BR PBSETU	;GO TRY IT ALL AGAIN
PBSET3:	JSR PC,PBWAIT	;WAIT FOR DISKING TO DIE DOWN
	JSR PC,PBCFLS	;FLUSH THE CORE
PBSET4:	MOVB D,PBLEN(B)	;SET EH NEW LENGTH
	BICB #7,PBRAN(B)	;CLEAR OLD START
	BISB C,PBRAN(B)	;SET IN NEW START
	JMP ACRETC
PBSET1:	JMP ACRETS

;DO LENGTH COMPARISIONS FOR NEW AND OLD PB STARTS AND LENGTHS
;CALL WITH PB POINTER IN B, NEW START AND LENGTH IN C AND D
;RETURNS WITH NEEDED START AND LENGTH IN C AND D AND CURRENT
;START AND LENGTH IN E AND F
;RETURNS WITH Z SET IF SOME BLOCKS IN THE NEEDED PAGE ARE NON-EX
PBLONG:	SAVE A
	ADD C,D		;CONVERT LENGTH TO LAST BLOCK #
	MOVB PBLEN(B),F	;GET CURRENT LENGTH
	BLT PBLON2	;PB NOT SET UP
	MOVB PBRAN(B),E	;AND CURENT START
	BIC #PBSTRT,E
	ADD F,E		;;CONVERT TO END BLOCK
	CMP C,E		;IS NEW START LESS THAN OLD START?
	BLT PBLON1	;YES, NEED TO EXPAND PAGE DOWN
	MOV E,C		;THIS WILL BE THE REQUIRED START
	CMP F,D		;IS NEW END PAST OLD END?
	BLT PBLON2	;YES, NEED TO EXPAND UP
	MOV F,D		;OLD ONE IS HIGH ENOUGH
PBLON3:	SUB C,D	;CONVERT BACK TO LENGTH
	SUB E,F		;LIKEWISE
	REST A
	CLZ
	RTS PC

PBLON1:	CMP F,D		;IS NEW END PAST OLD END?
	BLT PBLON2	;YES, USE NEW
	MOV F,D		;NO, USE OLD
PBLON2:	BIT #PBFILE,PBFLAG(B)	;IS THIS A FILE PAGE?
	BEQ PBLON3	;NO, WE'RE DONE
	MOV B,A		;COPY PB POINTER
	ADD #PBSDA,A	;POINT AT SOURCE ADDRESSES
	ADD C,A		;POINT AT
	ADD C,A		;FIRST ONE WE REFERENCE
	SAVE D		;SAVE END POINTER
	SUB C,D		;CONVERT TO LENGTH
PBLON5:	CMP #-1,(A)+	;NON-EX BLOCK?
	BEQ PBLON4	;YOU CAN'T MAP THAT IN!
	DEC D		;DONE ALL?
	BGE PBLON5	;NOT YET
	REST D		;MADE IT THROUGH OK
	BR PBLON3
PBLON4:	REST <D,A>
	SEZ		;TRYIED TO MAP IN NON-EX BLOCK
	RTS PC
	.SBTTL ITEM TABLE ROUTINES
.IIF NZ ITMADR!ITLINK,.ERROR NO, IT WON'T WORK WITH ITLINK OR ITADDR NON-ZERO
;CREATE AN ITEM OF SPECIFIED SIZE
;THE SIZE IS PUT INTO A; THE ITEM'S INDEX RETURNS IN B
;THE Z BIT IS SET IF THE ITEM CANNOT BE CREATED; OTHERWISE, IT IS CLEARED
;THIS MAKES NO ATTEMPT TO COMPRESS EXISTING ITEMS TO PRODUCE CONTIGOUS FREE SAPCE
;THAT FEATURE IS OF SOMEWHAT QUESTIONALBE VALUE, BUT MIGHT BE ADDED LATER
CRITEM:	CMP #200,A	;CHECK THAT NO ONE ASKS FOR A BLOCK>4K
	BUGC LE
	MOV ITMFRE,B	;ATTEMPT TO GET A FREE ITEM
	BEQ CRITM1	;NO MORE AVAILABLE, GO LOSE
	SAVE <C,D>
CRITM8:	MOV A,C		;GET THE LENGTH
	ASL C		;CONVERT IT TO AN INDEX
	ADD #ITMATB,C	;INTO THE ALLOCATE TABLE
	CLR D		;FOR THE LEFTOVER COUNT
CRITM3:	TST (C)+	;IS THERE A FREE ITEM BLOCK OF THIS SIZE?
	BNE CRITM2	;YES, GO USE IT
	TST (D)+	;ONE MORE TO FREE WHEN WE FINALLY FIND
			;A BLOCK BIGGER THAN WHAT WE REALLY WANTED
	CMP #ITMATB+400,C	;ARE WE ALREADY OFF THE TOP?
	BNE CRITM3	;NOPE, NOT YET
;IF WE GET HERE WE HAVE TO ALLOCATE A NEW BIG BLOCK
	TST ITMBAL	;IS SOMEONE ELSE ALREADY ALLOCATING?
	BEQ CRIT11	;NO, GO LOCK THE SWTICH
CRIT13:	JSR PC,SFLUSH	;WAIT FOR THE OTHER GUY TO BE DONE
	TST ITMBAL	;DONE YET?
	BNE CRIT13	;NOPE
	JSR PC,RUNME	;DONE, NOW  SEE IF HE LEFT ENGOUGH FOR US
CRIT16:	MOV ITMFRE,B	;HAVE TO GET ANOTHER ITEM
	BEQ CRIT12	;MAYBE OTHER PEOPLE TOOK THEM ALL
	BR CRITM8	;NOPE
CRIT11:	SAVE A		;LOCK SWTCH SO NO ONE ELSE GETS TO THIS CODE
	MOV #ITMBAL,A
	MOV #-1,B	;USE ALL THE BITS
	CLR C		;THE SWITCH IS INOT IN AN ITEM
	JSR PC,LCKASW	;IN CASE WE HANG WAITING FOR A BLOCK
	MOV #NITMBL,B	;FIND A FREE ITEM BLOCK SLOT
	MOV #ITMBST,C
CRIT10:	TST (C)+	;NEGATIVE INDICATES FREE
	BLT CRITM9	;FOUND ONE!
	SOB B,CRIT10	;KEEP TRYING
	JSR PC,LSWPOP	;LOSE, NO SPACE TO PUT ANOTHER BLOCK
	REST A
CRIT12:	REST <D,C>
CRITM1:	SEZ		;INDICATE FAILURE
	RTS PC
;NO, THIS ISN'T THE END OF THE ROUTINE!
CRITM2:	MOV (B),ITMFRE	;NOW THE ITEM POINTED TO BY THIS ONE IS
			;THE BEGINNING OF THE FREE LIST
	MOVB A,ITLNGT(B)	;SET IN THE LENGTH
	MOVB #ITACCD,ITACCS(B)	;AND THE ACCESS CODE
	SAVE <E,F>
	MOV -(C),E	;GET A POINTER TO THE NODE FOR THE FREE BLOCK
	MOV (E),(C)	;SPLICE OUT THIS NODE
	MOV 2(E),F	;ADDRESS OF THE BLOCK
	MOV F,(B)	;PUT IT AWAY IN THE ITEM
	MOV F,C		;COPY IT
	BIC #170000,F	;GET THE ADDRESS PART
	SAVE F		;AND SAVE IT FOR LATER
	TST D		;IS THERE ANY LEFTOVER?
	BEQ CRITM4	;NO, JUST GO FREE THE NODE
	TST -(D)	;CORRECT D, IT'S OVERENTHUSIASTIC
	MOV ITMATB(D),(E)	;PUT THE NODE INTO THE LIST FOR THE LEFTOVER SIZE
	MOV E,ITMATB(D)		;THERE!
	ADD A,2(E)	;ADD THE AMOUNT USED TO THE ADDRESS
	INC 2(E)	;SINCE ZERO IS ONE(?)
	BR CRITM5	;NOW GO USE WHAT WE GOT
CRITM4:	MOV ITMAFR,(E