.MLLIT==1
TITLE PICTURE DISPLAY

;OUTPUTS ON TV'S THE STANFORD FORMAT TV PICTURES

; WORD 0: -1
; WORD 1: BITS PER PIXEL
; WORD 2: WORDS PER LINE
; WORD 3: NUMBER OF FIRST DATA ROW
; WORD 4: ... LAST ROW
; WORD 5: ... FIRST COLUMN
; WORD 6: ... LAST COLUMN
; WORD 7: <-WORD COUNT OF DATA PORTION (NOT HEADER)>,,200
; DATA PORTION STARTS IN WORD 200.

BPP==1
WOFF==2

A=1
B=2
C=3
D=4
E=5
F=6
T=7
Q=10
R=11
S=12
W=13
X=14
Y=15
Z=16
P=17

G=PUSHJ P,

TVP==200
TV==TVP*2000	;ADDRESS OF BEG OF TV BUFFER
TVEND==TV+<8.*2000>-1
DEFINE TVDEF A,B
A==TV+<<B-660000>/4>
TERMIN

TVDEF COLORD,764102
TVDEF VIDSW,764104
TVDEF COLORA,764106
TVDEF TVCNTL,764142
TVDEF TVSHR,764152
TVDEF TVCNSL,764162
TVDEF TVINCR,764140

BEG:	MOVEI P,PDL
	SKIPN AITV'
	JRST LOGOTI
	MOVEI B,TVP	;WHERE 11 MEM STARTS IN 10
	MOVEI A,10.
	MOVE C,[602330,,1777]
11IN1:	.CALL  [SETZ
		SIXBIT /T11MP/
		B
		SETZ C]
	.VALUE
	AOS B
	ADD C,[4,,]
	SOJGE A,11IN1
	JRST PLOOP

LOGOTI:	MOVE A,[-11,,TVP]
	MOVEI B,0
	.CALL [SETZ
		SIXBIT /CORBLK/
		1000,,600000
		1000,,-1
		A
		1000,,-2
		SETZ B]
	.VALUE
PLOOP:	SKIPN AITV
	JRST AITVIN
	MOVE A,[-20,,4]
	MOVEM A,TVINCR
	MOVEI A,10
	MOVEI B,10
	MOVEI C,16.	
CLOOP:	MOVEM A,COLORD
	MOVEM B,COLORA
	ADDI B,20
	ADDI A,760
	SOJG C,CLOOP
	MOVE A,[35400_4+10]
	MOVEM A,TVSHR
IRPC X,,[1234]
	MOVE A,TV!X
	MOVEM A,TVCNTL
	MOVE A,[10000_4+10]
	MOVEM A,TVCNSL
	MOVE A,[<<3!X-1>_8.+X-1>_20.+4]
	MOVEM A,VIDSW
	G CLR
TERMIN
	JRST AIPIC
AITVIN:	G CLR
	JRST AIPIC		;GO DO AN AI PIC OR TWO


;THIS CODE FOR SAIL DIRTY MOVIES
SFPIX:	MOVEI A,NAMES
	SKIPN @NAMEPT
	MOVEM A,NAMEPT
	MOVE A,@NAMEPT
	MOVEM A,FNAME1
	AOS NAMEPT
	.OPEN D,FNAMS
	.VALUE
	MOVE A,[-30000,,FBUF]
	.IOT D,A
	ADDI A,FBUF
	HRRZM A,FBUFE
	.CLOSE D,
	SKIPL FBUF
	JRST OLDFT
	MOVE A,FBUF+WOFF
	MOVEM A,PWIDTH
	MOVEI A,1
	MOVEM A,6BIT
	MOVE A,FBUF+BPP	;BITS/PIXEL
	CAIN A,4
	SETZM 6BIT
	CAIN A,6
	SETOM 6BIT
	MOVEI A,200
	MOVEM A,STARTA'
RET:	SKIPLE 6BIT
	.VALUE
	PUSHJ P,WRITE
	MOVEI A,300.
	.SLEEP A,
	JRST PLOOP

OLDFT:	MOVEI A,1
	MOVEM A,6BIT
	MOVE A,FBUF+1
	CAIN A,6
	SETOM 6BIT
	CAIN A,4
	SETZM 6BIT
	MOVE A,FBUF+4
	MOVEM A,PWIDTH
	MOVEI A,12
	MOVEM A,STARTA
	JRST RET

CLR:	SETZM TV+10*2000-1
	MOVSI F,-10*2000+1
	MOVE A,[SETZM TV(F)]
	MOVE B,[AOBJN F,A]
	MOVE C,[JRST CLR1]
	JRST A

CLR1:	POPJ P,

WRITE:	MOVEI A,FBUF
	ADD A,STARTA
	MOVEM A,FBUFP
	SETZM WIDTH
	MOVEI A,TV
	MOVEM A,TVPTR
	PUSHJ P,NEWWD
LUP1:	MOVEI F,32.
	SETZB T,Q
	SETZB R,S
	SKIPN AITV
	JRST AIBIT
	MOVE W,[440100,,T]
	MOVE X,[440100,,Q]
	MOVE Y,[440100,,R]
	MOVE Z,[440100,,S]
LUP:	ROT E,1
	IDPB E,W
	ROT E,1
	IDPB E,X
	ROT E,1
	IDPB E,Y
	ROT E,1
	IDPB E,Z
	SKIPGE 6BIT
	ROT E,2
	SOSG BC
	PUSHJ P,NEWWD
	SOJG F,LUP
	MOVE A,TV1
	MOVEM A,TVCNTL
	AOS TVPTR
	MOVEM T,@TVPTR
	MOVE A,TV2
	MOVEM A,TVCNTL
	MOVEM Q,@TVPTR
	MOVE A,TV3
	MOVEM A,TVCNTL
	MOVEM R,@TVPTR
	MOVE A,TV4
	MOVEM A,TVCNTL
	MOVEM S,@TVPTR
	JRST LUP1

AIBIT:	MOVEI F,32.
	MOVEI S,0
	MOVE Z,[440100,,S]
AILUP:	LDB X,[400400,,E]
	MOVEI W,0
	CAMLE X,CUTLEV'
	MOVEI W,1
	IDPB W,Z
	ROT E,4
	SKIPE 6BIT
	ROT E,2
	SOSG BC
	PUSHJ P,NEWWD
	SOJG F,AILUP
	AOS TVPTR
	MOVEM S,@TVPTR
	JRST AIBIT


NEWWD:	MOVE E,@FBUFP
	AOS A,FBUFP
	CAML A,FBUFE
	JRST NW1
	MOVEI A,9
	SKIPGE 6BIT
	MOVEI A,6
	MOVEM A,BC
	AOS A,WIDTH
	CAMGE A,PWIDTH
	POPJ P,
	SETZM WIDTH
	MOVE A,TVPTR
	SUBI A,TV
	IDIVI A,18.
	MOVEI A,18.
	SUB A,B
	ADDM A,TVPTR
	POP P,A
	JRST LUP1

NW1:	POP P,A
	POPJ P,
XINC:	10
YINC:	10

AIPIC:	G CLR
	PUSHJ P,FOP	;OPEN UP THE IMAGE FILE
	MOVE A,YUR	;AND Y START
	SUBI A,20
	MOVEM A,CURY'
	MOVEI A,TV
	MOVEM A,TVLPT'
	MOVEM A,CURTVA'	;START AT ZERO ON TV
XLOOP:	MOVE A,XLL	;GET X START
	MOVEM A,CURX'
TVWLP:	MOVE A,[440100,,AIWRD']
	MOVEM A,AITVP'
	SKIPN AITV
	JRST TVWLP1
	IRPC X,,[1234]
	SETZM TVW!X'
	MOVE A,[440100,,TVW!X]
	MOVEM A,BIT!X!PT'
TERMIN
TVWLP1:	MOVEI A,32.
	MOVEM A,TVBITC'
PTLOOP:	MOVE A,CURX	;GET THE CURRENT X VALUE
	CAML A,XUR	;GONE PAST X LIMIT?
	JRST YLOOP	;GO TO NEXT LINE
	MOVE C,XINC
	ADDM C,CURX
	MOVE B,CURY
	PUSHJ P,FAKETV
	SKIPE AITV
	JRST PTLP1
	MOVEI X,1
	CAMLE A,CUTLEV
	MOVEI X,0
	IDPB X,AITVP
	JRST PTLP2
PTLP1:	LSH A,-4	;MAKE 4 BITS OUT OF NINE
IRPC X,,[4321]
	IDPB A,BIT!X!PT
	LSH A,-1
TERMIN
PTLP2:	SOSE TVBITC
	JRST PTLOOP
	PUSHJ P,TVWRT
	AOS CURTVA
	JRST TVWLP
TVWRT:	SKIPE AITV
	JRST TVWD1
	MOVE A,AIWRD
	MOVEM A,@CURTVA
	POPJ P,
TVWD1:
IRPC X,,[1234]
	MOVE A,TV!X
	MOVEM A,TVCNTL
	MOVE A,TVW!X
	MOVEM A,@CURTVA
TERMIN
	POPJ P,

YLOOP:	PUSHJ P,TVWRT
	MOVEI A,18.
	ADDB A,TVLPT
	MOVEM A,CURTVA
	MOVE A,CURY
	SUB A,YINC
	MOVEM A,CURY
	JUMPG A,XLOOP
	.VALUE





WIDTH:	0
PWIDTH:	0
BC:	0
6BIT:	0	;FLAG FOR 4 OR 6 BIT PICTURE
TVPTR:	0
TV1:	0,,70
TV2:	0,,50
TV3:	0,,30
TV4:	0,,10

FBUFP:	0
FBUFE:	0
	CONSTANTINOPLE
	VARIABILITY

PAT:	BLOCK 200
PDL:	BLOCK 40

FBUF:	BLOCK 30000
	1

FNAMS:	SIXBIT /  &DSK/
FNAME1:	0
FNAME2:	SIXBIT />/

NAMES:	SIXBIT /PLAMA/
	SIXBIT /PLAMA2/
	SIXBIT /PLAMA3/
	SIXBIT /PLAMA4/
	SIXBIT /BILL/
	SIXBIT /CANDY/
	0
NAMEPT:	NAMES

;FUNCTIONS THAT ALLOW READING VIDISECTOR VALUES
;  FROM A STORED IMAGE

IF1 TITLE FAKETV CODE HAS BEEN INSERTED

;VARIOUS PARAMETERS

SUBSIZ==64.	;SUB-PICTURE SIZE
VIDIS==4.	;NUMBER OF VIDI VALUES PER WORD
FRESL==16.	;STORED IMAGE HAS 1 OUT OF EVERY 16. POINTS
HFRESL==FRESL/2.	;FRESL MUST BE EVEN
RESBLK==64.	;NUMBER OF BLOCKS OF IMAGE RESIDING IN CORE

CURBLK:	BLOCK RESBLK	;NUMBER OF BLOCK CURRENTLY IN CORE
XBLOKS:	0
YBLOKS:	0
NBLOKS:	0	;TOTAL NUMBER OF BLOCKS
FCFL:	0	;CONFIDENCE LEVEL OF IMAGE
FDCL:	0	;DIM CUTOFF LEVL
WRDBLK:	0
XWRDS:	0
XLL:	0
YLL:	0
XUR:	0
YUR:	0
BUFFER:	BLOCK 1024.*RESBLK
ODCL:	0	;PREVIOUS DCL VALUE
NVDK:	1200	;DIM CUTOFF VALUE

DCL:	3

FTVERR:	VERR
VERR:	.VALUE
	;CONTAINS ADDRESS OF ERROR ROUTINE IN CASE OF NON-EXISTENT
	;VIDI POINT. ROUTINE CAN PUT A VALUE IN ACCUMULATOR 'A' TO
	;BE RETURNED FOR POINTS THAT ARE OUTSIDE THE WINDOW E.G.,
	;-1 OR 212400,,1200 (IT OUGHT TO LOOK LIKE A NORMAL VIDI
	;WORD). THE ROUTINE MUST RETURN WITH A POPJ P,
	;THE SYSTEM SUPPLIES AN ERROR ROUTINE THAT PRINTS
	;OUT A MESSAGE, AND STOPS.

IFNDEF TVCI,[TVCI==4]
IFNDEF TYOC,[TYOC==2]

;THIS FUNCTION OPENS THE IMAGE FILE AND
;  COMPUTES SOME NEEDED VALUES
;	IT ASKS FOR A FILE NAME TO BE TYPED AT THE TTY
;	IN STANDARD ITS FORMAT. IF FILE DOESN'T EXIST,
;	IT WILL ASK FOR ANOTHER NAME. TYPES OUT WINDOW
;	COORDINATES TOO.

FNOFIL:	.VALUE
;
;FTVOPN:	MOVE A,[SIXBIT /VIS   /]
;	MOVEM A,FRMSNM	;DEFAULT UNAME IS VIS;
;	STRIKE _TYPE IMAGE FILE NAME:    
;	PUSHJ P,TTINR
INOP:	SIXBIT /   DSKFACE  >/
FRMSNM:	SIXBIT /LOGOP/

;ENTER HERE IF FILE NAME ALREADY IN INOP
FOP:	MOVEI A,6
	HRLM A,INOP	;SET FOR BLOCK MODE READIN
	.SUSET [.SSNAME,,FRMSNM]
	.OPEN TVCI,INOP
	JRST FNOFIL

	SETOM ODCL	;FORCE IT TO COMPUTE A DIM CUTOFF VALUE

	MOVEI A,SUBSIZ
	IMUL A,A
	IDIVI A,VIDIS
	MOVEM A,WRDBLK


	MOVSI A,-RESBLK	;SETUP LIST OF RESIDENT BLOCKS
	MOVEI B,BUFFER
	HRROM B,CURBLK(A)
	ADD B,WRDBLK
	AOBJN A,.-2

	MOVEI A,SUBSIZ
	IDIVI A,VIDIS
	MOVEM A,XWRDS

	SETZM A
	PUSHJ P,BLKRD	;READ IN FIRST (HEADER) BLOCK

	HRRZ B,CURBLK(Q)
	MOVE A,(B)	;XLL,,YLL
	HLRZM A,XLL
	HRRZM A,YLL
	MOVE A,1(B)	;XUR,,YUR
	HLRZM A,XUR
	HRRZM A,YUR
	MOVE A,2(B)
	HLRZM A,FDCL
	HRRZM A,FCFL

	MOVE A,XUR
	SUB A,XLL
	MOVEI C,SUBSIZ
	IMULI C,FRESL
	PUSH P,C
	IDIV A,C
	SKIPE B
	AOS A	;ROUND OFF
	MOVEM A,XBLOKS

	MOVE A,YUR
	SUB A,YLL
	POP P,C
	IDIV A,C
	SKIPE B
	AOS A
	MOVEM A,YBLOKS

	IMUL A,XBLOKS
	MOVEM A,NBLOKS	;NUMBER OF SUB-PICTURES IN FILE
	
	MOVE A,XLL
	MOVE B,YLL
	MOVE C,XUR
	MOVE D,YUR
	ASH A,-4
	ASH B,-4
	ASH C,-4
	ASH D,-4
;	STRIKE    XLL = %1I4  YLL = %2I4  XUR = %3I4  YUR = %4I4_
	POPJ P,
;THIS ROUTINE WILL READ A VIDI VALUE FROM THE STORED IMAGE
;  OPENED BY FTVOPN
;	A=X POSITION (ON A 16384. X 16384. GRID)
;	B=Y POSITION
;VIDI VALUE IS RETURNED IN A

FAKETV:	MOVEM A,XSAVE
	MOVEM B,YSAVE

	CAML A,XLL
	CAMLE A,XUR
	JRST @FTVERR	;ERROR - OUTSIDE WINDOW
	CAML B,YLL
	CAMLE B,YUR
	JRST @FTVERR	;OUTSIDE WINDOW

	SUB A,XLL
	SUB B,YLL
	PUSH P,B
	IDIVI A,FRESL
	CAIL B,HFRESL
	AOS A	;CONVERT TO 1024. POINT FRAME SIZE
	POP P,B
	IDIVI B,FRESL
	CAIL C,HFRESL
	AOS B

	PUSHJ P,BLKNUM	;COMPUTE BLOCK NUMBER THAT CONTAINS POINT
;	CAMLE A,NBLOKS	;IS IT A REAL BLOCK?
;	JRST @FTVERR	;OUTSIDE WINDOW
	MOVE D,DCL	;GET DIM CUTOFF LEVEL
	CAMN D,ODCL	;HAS IT CHANGED?
	JRST FKTV1	;NOPE
	MOVEM D,ODCL	;SET IT AS OLD
	CAIN D,0	;CFL IS ASSUMED TO BE 3
	MOVEI D,1
	CAIN D,7
	MOVEI D,1
	IMULI D,100
	MOVNS D
	ADDI D,1300
	MOVEM D,NVDK	;NEW DIM CUTOFF VALUE

FKTV1:	PUSHJ P,BLKRD	;READ IN DESIRED BLOCK IF NECESSARY
	JRST VIDGET

XSAVE:	0
YSAVE:	0

;THIS ROUTINE COMPUTES THE BLOCK NUMBER OF A X-Y POINT
;	A=X COORD (FULL SCALE = 1024.)
;	B=Y COORD (FULL SCALE = 1024.)

BLKNUM:	IDIVI B,SUBSIZ
	PUSH P,C
	IMUL B,XBLOKS
	EXCH A,B
	IDIVI B,SUBSIZ
	PUSH P,C
	ADD A,B
	ADDI A,1	;A=BLOCK NUMBER
	POP P,B	;B=X POSITION IN BLOCK
	POP P,C	;C=Y POSITION IN BLOCK
	POPJ P,

;THIS ROUTINE GETS A VIDI VALUE FROM THE CURRENT BLOCK
;	B=X POSITION IN BLOCK
;	C=Y POSITION IN BLOCK

VIDGET:	HRRZ A,CURBLK(Q)	;ADDRESS OF BLOCK
	IMUL C,XWRDS
	ADD A,C
	IDIVI B,VIDIS
	ADD A,B	;ADDRESS OF WORD CONTAINING DESIRED BYTE

	SUBI C,3
	MOVMS C
	IMULI C,110000	;COMPUTE BYTE POINTER
	ADDI C,1100	;9 BITS PER BYTE
	HRL A,C

	LDB A,A	;GET BYTE
	CAMLE A,NVDK	;IS IT GREATER THAN DOM CUTOFF VALUE?
	MOVE A,NVDK	;YES, SUBSTU;ITUTE DIM CUTOFF VALUE
	POPJ P,		;I'M STATISFIYED WITH THIS....
	LDB B,[60600,,A]	;RECREATE VIDI WORD FORMAT
	ADDI B,224
	MOVE C,A
	TRZ C,777700	;GET RID OF EXPONENT
	ADDI C,100
	FSC C,(B)
	HLL A,C

	POPJ P,	;A=VIDI VALUE

;ROUTINE TO CHECK IF BLOCK IS RESIDENT AND READ IT IN IF NOT
;	A=BLOCK NUMBER DESIRED
;ON RETURN, Q IS INDEX TO DESIRED BLOCK

BLKRD:	PUSHJ P,BLKCHK
	POPJ P,	;BLOCK IS ALREADY IN
	PUSHJ P,BROLL	;MAKE ROOM FOR NEW ONE
	HRLM A,CURBLK	;SAVE BLOCK NUMBER
	IMUL A,WRDBLK
	.ACCESS TVCI,A	;GO TO BEGINNING OF BLOCK
	MOVN A,WRDBLK
	HRLZS A
	HRR A,CURBLK	;WHERE TO PUT IT
	.IOT TVCI,A	;AND READ IT INTO CORE
	SETZM Q	;NEW ONE HAS INDEX ZERO
	POPJ P,	;RETURN



;ROUTINE TO SEE IF DESIRED BLOCK IS RESIDENT IN CORE
BLKCHK:	MOVSI Q,-RESBLK
	HLRE Y,CURBLK(Q)
	CAMN A,Y	;IS THIS IT?
	POPJ P,	;YES, Q=INDEX
	AOBJN Q,.-3	;NO,TRY AGAIN
	AOS (P)	;SKIP IF NOT IN CORE
	POPJ P,

;ROUTINE TO ROLL BLOCK LIST
BROLL:	PUSH P,CURBLK-1+RESBLK	;SAVE LAST ONE
	MOVEI T,RESBLK-1
	MOVE Y,CURBLK-1(T)
	MOVEM Y,CURBLK(T)
	SOJG T,.-2
	POP P,CURBLK	;LAST IS NOW FIRST
	POPJ P,
END BEG
