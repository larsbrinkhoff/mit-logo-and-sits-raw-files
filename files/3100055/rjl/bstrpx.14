;
;
;
; RT-11 BOOTSTRAP
;



; CONDITIONAL ASSEMBLY OF BOOT FOR S/J OR F/B SYSTEM
.IIF NDF BF,BF=0		;DEFAULT TO S/J
				;BOOTSTRAP UPDATE LEVEL 10
.IF NE BF
.SBTTL	FOREGROUND/BACKGROUND
.IFF
.SBTTL	SINGLE/JOB
.ENDC
.IF NDF $FLSYS
.IF NDF	$RFSYS		;TURN ON $RKSYS IF ALL OTHERS ARE OFF
.IF NDF $FDSYS		;X02
.IF NDF	$DTSYS
.IF NDF	$DPSYS
.IF NDF	$DSSYS
.IF NDF $RCSYS
.IF NDF	$DXSYS
$RKSYS=	0	;IT MUST BE AN RK SYSTEM
.ENDC
.ENDC
.ENDC
.ENDC
.ENDC
.ENDC
.ENDC
.ENDC
UPDATE = 02.				;EXTERNAL UPDATE NUMBER
.RADIX	10.
.IRP	...,<\UPDATE>
.IF DF $RKSYS
.TITLE RK BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $FDSYS		;X02
.TITLE FD BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $RFSYS
.TITLE RF BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $DTSYS
.TITLE DT BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $DPSYS
.TITLE DP BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $DSSYS
.TITLE DS BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $DXSYS
.TITLE DX BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $RCSYS
.TITLE RC BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.IF DF $FLSYS
.TITLE FL BOOT SGTL V0'... FOR RT-11 V02X
.ENDC
.ENDR
.RADIX	8.
.SBTTL	MACROS, GLOBALS

.MCALL	..V1..
..V1..
.MCALL	.EXIT,	.LOOKUP,.PRINT,	.SAVESTATUS

; GLOBAL REFERENCES TO MONITOR:
.GLOBL	$DVREC,	$ENTRY,	$INPTR,	$KMLOC,	$MONBL,	$PNAME,	$SLOT
.GLOBL	$SWPBL,	$USRLC,	$PNAMO
.GLOBL	BSTRNG,	CORPTR,	DKASSG,	FILLER,	HWFPU$,	HWDSP$,	KMLOC
.GLOBL	KMON,	KMONSZ,	KW11L$,	MAPOFF,	QCOMP,	RT11SZ
.GLOBL	RTLEN,	RTSIZE,	SWAPSZ,	SYENTO,	SYINDO,	SYNCH,	SYASSG
.GLOBL	SYSLOW,	TTIBUF,	TTOBUF,	USRLOC,	USRSZ, MAXSYH
.GLOBL	LSI11$,$MFPS,$INTEN,GETPSW				;DV15

.GLOBL	RELLST

; FOLLOWING ARE GLOBALS FOR EITHER F/B OR S/J SYSTEM, BUT NOT BOTH

.IF NE BF
.GLOBL	BCNTXT,	BKGND1,	BKGND2,	BKGND3,	CNTXT,	FUDGE1,	FUDGE2
.GLOBL	MSGENT,	RMONSP,	SWIPTR,	SWOPTR,	TTIUSR,	TTOUSR,	.$CRTN
.GLOBL	IMPLOC							;DV15
.IFF
.GLOBL	AVAIL,	I.CSW,	FPPADD,	FPPIGN,	MONLOC,	TRAPLC,	TRAPER
.ENDC

PERM	= 2000			;STATUS WORD FOR PERMANENT FILE
ENDBLK	= 4000			;STATUS OF END OF SEGMENT MARK
JSW	= 44			;ADDRESS OF JOB STATUS
SR	= 177570		;CONSOLE SWITCH REGISTER
PS	= 177776		;PROCESSOR STATUS WORD		;DV15
PR0	= 0
PR4	= 200
PR7	= 340

; REGISTER DEFINITIONS:

R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
SP=%6
PC=%7

; MONITOR OFFSET CONSTANTS

CONFIG	= 300		;HARDWARE CONFIGURATION WORD
SYUNIT	= 274		;SYSTEM UNIT #

LKCS	= 177546	;CLOCK STATUS REGISTER
GT40	= 172000	;GT40 LOCATION
TKS	= 177560	;KEYBOARD STATUS
TKB	= 177562	;   "	  BUFFER
TPS	= 177564	;PRINTER STATUS
TPB	= 177566	;   "	 BUFFER
.SBTTL	ASECT

	.ASECT
	. = 0
	240			;BOOT VALIDATION PATTERN
	BR	BOOT1		;BRANCH TO REAL BOOT

	.IF NDF	$DXSYS
	. = 34			;PUT THE JUMP BOOT IN TRAP VECTOR
BOOT1:	JMP	BOOT		;START THE BOOTSTRAP

	.IFF
	CSGO=	1		;START FUNCTION
	CSEBUF=	2		;EMPTY BUFFER
	CSRD=	6		;READ SECTOR
	CSUNIT=	20		;UNIT 1 SELECTION
	CSDONE=	40		;RX DONE
	CSTR=	200		;RXDB TRANSFER READY
	CSERR=	100000		;RX ERROR

	RXCS=	177170		;RXCS STATUS REGISTER

	. = 14			;INITIALIZE BPT AND IOT VECTORS
	.WORD	READS		;ON BPT INTERUPT TO READS ROUTINE
	.WORD	340		;PS SET TO 7			;DV15
	.WORD	WAIT		;ON IOT INTERUPT TO WAIT ROUTINE
	.WORD	340		;PS SET TO 7			;DV15
	. = 34			;34-52 USEABLE
BOOT1:	MOVB	UNITRD(R0),RDCMD;SET READ FUNCTION FOR CORRECT UNIT
RETRY:	MOV	@PC,SP		;INIT SP WITH NEXT INSTRUCTION
	MOV	#200,R2		;AREA TO READ IN NEXT PART OF BOOT
	CLR	R0		;SET TRACK NUMBER
	BR	2$		;OUT OF ROOM HERE, GO TO CONTINUATION
	. = 70			;PAPER TAPE VECTORS
2$:	MOV	SP,R1		;SET TO BIG WORD COUNT
	INC	R0		;SET TO ABSOLUTE TRACK 1
	BR	3$		;BRANCH TO CONTINUATION
	. = 110			;X03 ;PROGRAMMABLE CLOCK
3$:	MOV	@PC,R3		;ABSOLUTE SECTOR 3 FOR NEXT PART
	BPT			;CALL READS SUBROUTINE
	BR	BOOT2		;BRANCH TO CONTINUATION
UNITRD:	.BYTE	CSGO+CSRD	;READ FROM UNIT 0, SETS WEIRD BUT OK PS
	.BYTE	CSGO+CSRD+CSUNIT;READ FROM UNIT 1
	. = 120			;LOTS OF UNUSED VECTORS, (DR-11B?)
READS:	MOV	#RXCS,R4	;R4 -> RX STATUS REGISTER
	MOV	R4,R5		;R5 WILL POINT TO RX DATA BUFFER
	MOV	(PC)+,(R5)+	;INITIATE READ FUNCTION
RDCMD:	.WORD	0		;GETS FILLED WITH READ COMMAND
	IOT			;CALL WAIT SUBROUTINE
	MOV	R3,@R5		;LOAD SECTOR NUMBER INTO RXDB
	IOT			;CALL WAIT SUBROUTINE
	MOV	R0,@R5		;LOAD TRACK NUMBER INTO RXDB
	IOT			;CALL WAIT SUBROUTINE
	MOV	#CSGO+CSEBUF,@R4;LOAD EMPTY BUFFER FUNCTION INTO RXCS
BROFFS	=	READF-.		;USE FOR COMPUTING BR OFFSET	;LP1
RDX:	IOT			;CALL WAIT SUBROUTINE		;LP1
	TSTB	@R4		;IS TRANSFER READY UP?
	BPL	RTIRET		;BRANCH IF NOT, SECTOR MUST BE LOADED
	MOVB	@R5,(R2)+	;MOVE DATA BYTE TO MEMORY
	DEC	R1		;CHECK BYTE COUNT
	BGT	RDX		;LOOP AS LONG AS WORD COUNT NOT UP ;LP1
	CLR	R2		;KLUDGE TO SLUFF BUFFER IF SHORT WD CNT
	BR	RDX		;LOOP				;LP1
WAIT:	TST	@R4		;IS TR, ERR, DONE UP? INT ENB CAN'T BE
	BEQ	WAIT		;LOOP TILL SOMETHING
	BMI	RETRY		;START AGAIN IF ERROR
RTIRET:	RTI			;RETURN

	. = 200			;SECTOR 2 OF RX BOOT
BOOT2:	CMPB	(R3)+,(R3)+	;BUMP TO SECTOR 5
	BPT			;CALL READS SUBROUTINE
	CMPB	(R3)+,(R3)+	;BUMP TO SECTOR 7
	BPT			;CALL READS SUBROUTINE
	BIT	#CSUNIT,RDCMD	;CHECK UNIT ID
	BNE	1$		;BRANCH IF BOOTING UNIT 1, R0=1
	CLR	R0		;SET TO UNIT 0
1$:	MOV	R0,(PC)+	;SAVE UNIT BOOTED FROM FOR LATER
BTUNIT:	.WORD	0		;SAVE THE UNIT HERE
	MOV	#TRWAIT,@#20	;LETS HANDLE ERRORS DIFFERENTLY
	MOV	(PC)+,@(PC)+	;USE FASTER ROUTINE TO EMPTY SILO ;LP1
	  BR	.+BROFFS	;REPLACE IOT AT RDX WITH THIS INSTR ;LP1
	  RDX			;-> TO REPLACED INSTRUCTION	;LP1
	BR	BOOT		;NOW WE ARE READY TO DO THE REAL BOOT

.	=	330		;SKIP OVER SIGNON MESSAGE	;LP1

READF:	TST	@R4		;ERROR, DONE, OR TR UP?		;LP1
	BEQ	READF		;BR IF NOT			;LP1
	BMI	BIOERR		;BR IF ERROR			;LP1
	TSTB	@R4		;TR OR DONE?			;LP1
	BPL	RTIRET		;BR IF DONE			;LP1
	MOVB	@R5,(R2)+	;MOVE DATA BYTE TO MEMORY	;LP1
	DEC	R1		;CHECK BYTE COUNT		;LP1
	BGT	READF		;LOOP IF MORE			;LP1
	CLR	R2		;SLUFF BUFFER IF SHORT WD CNT	;LP1 
	BR	READF		;LOOP				;LP1
.ENDC

.IF DF $RKSYS
	. = 330
; BLOOK IS THE ARGUMENT AREA FOR AN RT-11 LOOKUP.
BLOOK:	.RAD50	/SY /
FNAME:	.WORD	0,0		;FILENAME GOES HERE
	.RAD50	/SYS/
CBLOK:	.BLKW	5		;SAVESTATUS GOES HERE

	.ENDC
	.IF DF $FLSYS
;FOLLOWING CROCK NEEDED TO BRING DOWN SIZE OF THE WORLD
.=120
READS:	MOV #SMSCSR,R4		;COMMONLY USED POINTER
	MOV #SMSSEK,R5		;SEEK COMMAND
	JSR PC,DCMD		;FIRST WORD
	MOV R0,R5		;TRACK ADDRESS
	JSR PC,CMD2		;SECOND COMMAND BYTE
	JSR PC,GETST		;GET STATUS OF OP
	MOV #SMSRED!SMSDTB,R5	;READ COMMAND
	JSR PC,DCMD
	MOV R3,R5		;SECTOR ADDRESS
	JSR PC,CMD2
	JSR PC,GETST
	MOV #SMSRED!SMSBTH,R5	;READ FROM BUFFER
	JSR PC,DCMD
	JSR PC,CMD2		;SECOND BYTE IGNORED
1$:	BIT #SMSXFW,(R4)
	BEQ 1$
	MOV #128.,R5
2$:	MOVB SMSDBF,(R2)+
	DEC R5			;OUR COUNT
	BEQ 3$			;SECTOR EXHAUSTED
	DEC R1			;CALLER'S COUNT
	BGT 2$			;HE ISN'T TIRED EITHER
	BR 4$
3$:	DEC R1
	BR 4$
.IIF GT .-244,.ERROR		;THIS PART TOO BIG
.=250
4$:	BIT #SMSXFW,(R4)	;READY TO XFER?
	BEQ 4$
	TST SMSDBF		;CALLER DOESN'T WANT IT, EMPTY IT OUT
	DEC R5
	BGE 4$			;THSI WILL FLUSH STATUS BYTE ALSO
	RTS PC
.IIF GT .-270,.ERROR		;THIS %$& PART TOO BIG
.=330				;SKIP SYSTEM MESSAGE AND FLOPPY DISK INTERUPT
DCMD:
CMD2:	BIT #SMSCMW,(R4)	;READY FOR COMMAND?
	BEQ CMD2
	MOV R5,SMSCMD
	RTS PC

.IIF GT .-360,.ERROR		;THIS OTHER PART TOO BIG

.ENDC
; FOLLOWING ARE THE BOOTSTRAP I/O DRIVERS FOR EACH VALID
; SYSTEM DEVICE.
; CALLING SEQUENCE:
;	R0 = PHYSICAL BLOCK TO READ/WRITE
;	R1 = WORD COUNT
;	R2 = BUFFER ADDRESS
;	R3,R4,R5 ARE AVAILABLE AND MAY BE DESTROYED BY THE DRIVER
; THE DRIVER MUST GO TO BIOERR IF A FATAL I/O ERROR OCCURS.
; IT MUST ALSO INVOKE THE MACRO SYSDEV
.MACRO	SYSDEV	NAME,VECTOR
.GLOBL	NAME'INT, NAME'SIZE	;DEFINE SYSTEM DEVICE INTERRUPT & SIZE
SYNAME	= 0
.IRPC	X,<NAME>
SYNAME	= <SYNAME+''X-100>*50
.ENDR
SYVEC	= VECTOR		;IT VECTORS TO THIS LOCATION
. = SYVEC			;AT THE VECTORS
	.WORD	NAME'INT,340	;  PUT A VECTOR TO THE SYSTEM HANDLER
.IF NDF $DXSYS!$FLSYS						;DV15
. = SYSIZE
	.WORD	NAME'SIZE	;PUT HANDLER SIZE WHERE IT CAN BE USED
.ENDC								;DV15
. = 402				;AND START THE CODE AT 402
SYBITO	= VECTOR / 20		;OFFSET INTO BIT MAP FOR PROTECTION
SYBITS	= ^B11000000		;COMPUTE ACTUAL BITS
.REPT	<VECTOR & 17> / 4	;VECTOR IS A MULTIPLE OF 4
SYBITS	= SYBITS / 4		;SHIFT RIGHT 2 MORE BITS
.ENDR
.ENDM	SYSDEV
.IF DF	$FDSYS		;FD DRIVER
.SBTTL	BOOTSTRAP I/O DRIVER FOR DIALOG FLOPPY DISK

	;UNIBUS REGISTERS FOR FD CONTROLLER

	FDCSR =	177170	;COMMAND/STATUS REGISTER
	FDDAT =	177172	;DATA TRANSFER REGISTER
	FDDAR = 177174	;DISK ADDRESS REGISTER

	FD.RD = 3	;READ FUNCTION
	FD.CM = 10	;SIGNAL FUNCTION COMPLETED


	SYSDEV	FD,264

READ:	MOV	R0,(PC)+	;SAVE THE BLOCK NUMBER
	.WORD	0		;FOR DEBUGGING

	MOV	#FDCSR,R3	;POINT TO CMD/STATUS REGISTER
	MOV	#FDDAT,R4	;AND TO THE DATA REGISTER
	MOV	#100200,R5	;GET MASK FOR CHECKING OPERATION

1$:	BIT	#40,(R3)	;WAIT FOR READY
	BEQ	1$

	ROL	R0		;GET PHYSICAL SECTOR ADDRESS
	ROL	R0
	MOV	R0,@#FDDAR	;START DISK SEEKING

FRD:	;LOOP TO READ PHYSICAL SECTORS FOR LENGTH OF READ REQUEST

	MOV	#FD.RD,(R3)	;START READ OPERATION
	MOV	#64.,R0		;GET TRUNCATED SECTOR LENGTH

FRLUP:	BIT	R5,(R3)		;WAIT FOR REGISTER READY
	BMI	BIOERR
	BEQ	FRLUP

	MOV	(R4),(R2)+	;READ IN NEXT WORD
	DEC	R1		;COUNT WORDS IN TRANSFER
	BLE	FRDONE
	DEC	R0		;COUNT WORDS IN SECTOR
	BGT	FRLUP

	;CLEAN UP END OF SECTOR AND START ANOTHER ONE

	MOV	#FD.CM,(R3)	;SAY THIS TRANSFER IS COMPLETE
2$:	BIT	#40,(R3)	;WAIT FOR COMPLETION
	BNE	FRD
	BR	2$


FRDONE:	;LAND HERE WHEN TRANSFER IS COMPLETE

	MOV	#FD.CM,(R3)	;SAY TRANSFER IS COMPLETE
3$:	BIT	#100040,(R3)	;WAIT FOR DISK TO AGREE
	BMI	BIOERR
	BEQ	3$

	RTS	PC		;RETURN TO CALLER

.ENDC

.IF DF	$DSSYS	;RS SYSTEM
.SBTTL	BOOTSTRAP I/O DRIVER - RS11

; RS11 DISK HANDLER

.IF DF MBUSSC
	SYSDEV	DS,150
RSCS2	= 176310
.ENDC
.IF NDF MBUSSC
	SYSDEV	DS,204
RSCS2=172050
.ENDC

READ:	MOV	R0,R4		;COPY BLOCK NUMBER
	MOV	#RSCS2,R5	;POINT TO REGISTERS
	MOV	(R5),-(SP)	;SAVE UNIT #
	MOV	#40,@R5		;CONTROLLER CLEAR
	BIT	#2,16(R5)	;WHAT IS IT?
	BNE	1$		;IT'S AN RS04
	ASL	R4		;IT'S AN RS03
1$:	ASL	R4		;CONVERT TO TRACK/SECTOR
	BIC	#^C7,(SP)	;STRIP TO UNIT BITS
	MOV	(SP)+,(R5)	;SET UNIT
	MOV	R4,-(R5)	;SET BLOCK
	MOV	R2,-(R5)
	MOV	R1,-(R5)
	NEG	@R5
	MOV	#71,-(R5)	;GO, READ, NO INTERRUPT
2$:	BIT	#100200,@R5	;WAIT FOR DONE OR ERROR
	BEQ	2$
	BMI	BIOERR		;BOOT ERROR
	RTS	PC

.ENDC
.IF DF	$DPSYS			;CONDITIONAL FOR RP11 DISK
.SBTTL	BOOTSTRAP I/O DRIVER - RP11

; RP11 DISK DRIVER

	SYSDEV	DP,254			;DEVICE IS RP. IT VECTORS TO 254
RPCS=	176714				;RP11 DEVICE CONTROL REG
RPDS=	176710				;RP03 DEVICE STATUS REG
RPDA=	176724				;RP03 DISK ADRS REGISTER
CS.GO=	000001				;GO BIT IN CONTROL & STATUS
CS.RD=	000004				;READ FUNCTION CODE
CS.DRV=	003400				;UNIT SELECT BITS
DS.ATT=	000377				;UNIT ATTN BITS

READ:	MOV	R0,R3		;R3 = BLOCK #
	JSR	R2,DIV		;GET SECTOR NUMBER
	.WORD	10.		;BY DIVIDING BY 10
	MOV	R4,-(SP)	;SAVE SECTOR
	MOV	R5,R3		;SET NEW DIVIDEND
	JSR	R2,DIV		;AND COMPUTE CYL & TRACK
	.WORD	20.		;BY DIVIDING BY 20
	SWAB	R4		;POSITION TRACK IN HIGH BYTE
	BIS	(SP)+,R4	;AND INSTALL SECTOR
	MOV	#RPDA,R3	;R3 -> DISK ADRS REG
	MOV	R4,@R3		;SET TRACK & SECTOR
	MOV	R5,-(R3)	;AND CYLINDER
	MOV	R2,-(R3)	;AND BUS ADDRESS
	MOV	R1,-(R3)	;AND WORD COUNT
	NEG	@R3		;MAKE NEGATIVE
	BIC	#^C<CS.DRV>,-(R3) ;CLEAR ALL BUT UNIT #
	BIS	#CS.RD+CS.GO,@R3 ; AND START READ
1$:	TSTB	@R3		;WAIT UNTIL TRANSFER COMPLETE
	BPL	1$
	TST	@R3		;ANY ERRORS?
	BMI	BIOERR		;YES
	MOVB	#DS.ATT,@#RPDS	;CLEAR UNIT ATTN FOR BOTH
	CLRB	@#RPDS		;  OLD & ECO'D CONTROLLERS
	RTS	PC		;ELSE JUST RETURN

; DIVIDE ROUTINE FOR RP HANDLER.
; R5 = R3 / @R2, REMAINDER IN R4

DIV:	CLR	R5		;QUOT. = 0
	CLR	R4		;REM. = 0
	TST	R3		;IS DIVIDEND 0?
	BEQ	4$		;YES - JUST RETURN
	COM	R5		;QUOT. = -1 & SET CARRY
1$:	ROL	R3		;NORMALIZE
	BCC	1$
2$:	ROL	R4		;SHIFT & SUBTRACT
	CMP	R4,@R2
	BLO	3$
	SUB	@R2,R4
3$:	ROL	R5
	ASL	R3
	BNE	2$
	COM	R5		;FIX QUOTIENT
4$:	TST	(R2)+
	RTS	R2

.ENDC
.IF DF	$RKSYS!$RFSYS!$RCSYS

.IFDF	$RFSYS			;CONDITIONAL FOR RF DISK
.SBTTL	BOOTSTRAP I/O DRIVER - RF11

; RF11 DISK HANDLER

	SYSDEV	RF,204		;DEVICE IS RF. IT VECTORS TO 204.
RFCS	= 177460		;CONTROL & STATUS REGISTER
RFWC	= 177462		;WORD COUNT
RFMA	= 177464		;MEMORY ADDRESS
RFDA	= 177466		;DISK ADDRESS
RFDE	= 177470		;DISK ADDRESS EXTENSION
RFDB	= 177472		;DATA BUFFER

READ:	MOV	#RFDA,R3	;POINT TO DISK ADDRESS
	MOV	R0,R5		;COPY BLOCK NUMBER
	SWAB	R5		;MULTIPLY BY 256 TO GET WORD # ON DISK
	MOV	R5,R4		;SAVE HIGH ORDER DISK ADDRESS
	CLRB	R5		;MAKE DA AN EVEN BLOCK NUMBER
	MOV	R5,(R3)+	;PUT LOW ORDER ADDRESS IN CONTROLLER
	BIC	#177740,R4	;ISOLATE HIGH ORDER ADDRESS
	MOV	R4,(R3)		;PUT IT IN CONTROLLER
	TST	-(R3)		;RESET POINTER

.ENDC
.IFDF	$RCSYS		;CONDITIONAL FOR RC (RS64) DISK

	.SBTTL	BOOTSTRAP I/O DRIVER - RC11

; RC11 DISK HANDLER
	SYSDEV	RC,210		;DEVICE IS RC. IT VECTORS TO 210

; RC11 CONTROL REGISTERS

	RCLA=	177440		;LOOK AHEAD REGISTER
	RCDA=	177442		;DISK ADDRESS REGISTER
	RCER=	177444		;DISK ERROR STATUS REGISTER
	RCCS=	177446		;DISK CONTROL & STATUS REGISTER
	RCWC=	177450		;WORD COUNT REGISTER
	RCCA=	177452		;CURRENT ADDRESS REGISTER
	RCMN=	177454		;MAINTENANCE REGISTER
	RCDB=	177456		;DATA BUFFER REGISTER

READ:	MOV	#RCDA,R3	;PT TO DISK ADR REGISTER
	MOV	R0,R5		;GET BLOCK NUMBER
	ASL	R5		;CALCULATE DISK ADR FOR RCDA
	ASL	R5		;(UNIT,TRACK # & SECTOR ADR)
	ASL	R5		;[32 * 8=256]
	MOV	R5,@R3		;IND PROPER DISK ADR
	ADD	#12,R3		;PT TO CURRENT ADR REG + 12
;				/(INTERFACE TO COMMON CODE)
.ENDC
.IFDF	$RKSYS
.SBTTL	BOOTSTRAP I/O DRIVER - RK05

; RK05 DISK HANDLER

	SYSDEV	RK,220		;DEVICE IS RK. IT VECTORS TO 220
RKDA	= 177412		;RK DISK ADDRESS

READ:	MOV	#14,R3		;PHYSICAL BLOCK TO RK DISK ADD.
	BR	2$		;ENTER BLOCK # COMPUTATION
1$:	ADD	#20,R3		;CONVERT DISK ADDRESS
2$:	SUB	#14,R0
	BPL	1$
	ADD	R3,R0		;R0 HAS DISK ADDRESS
5$:	MOV	#RKDA,R3	;POINT TO HARDWARE DISK ADDR REGISTER
	BIC	#17777,@R3	;LEAVE THE UNIT NUMBER
	BIS	R0,(R3)		;PUT DISK ADDRESS INTO CONTROLLER

.ENDC
; THIS CODE IS COMMON TO RK05,RC11 AND RF11 HANDLERS
	MOV	R2,-(R3)	;BUFFER ADD.
	MOV	R1,-(R3)	;WORD COUNT
	NEG	(R3)		;(NEGATIVE)
	MOV	#5,-(R3)	;START DISK READ
3$:	TSTB	(R3)		;WAIT UNTIL COMPLETE
	BPL	3$
	TST	(R3)		;ANY ERRORS?
	BMI	BIOERR		;HARD HALT ON ERROR
	RTS	PC

.ENDC
.IF DF $DTSYS

.SBTTL	BOOTSTRAP I/O DRIVER - DECTAPE

; DECTAPE BOOTSRAP HANDLER
	SYSDEV	DT,214		;DEVICE IS DT. IT VECTORS TO 214.
TCCM	= 177342		;COMMAND REGISTER
TCDT	= 177350		;DATA REGISTER
TCST	= 177340		;STATUS REGISTER

READ:	MOV	#TCCM,R4	;R4 -> COMMAND REG
	MOV	#TCDT,R3	;R3 -> DATA REG
DTSRCH:	MOV	R0,R5		;COPY BLOCK NUMBER
	SUB	#2,R5		;SEARCH FOR 2 EARLIER
	MOV	#4003,@R4	;REVERSE,RNUM
2$:	BIT	#100200,@R4	;WAIT TILL BLOCK FOUND
	BEQ	2$
	BMI	DTERR
	CMP	R5,@R3		;IS IT THE DESIRED BLOCK
	BLT	DTSRCH		;NO,CONTINUE SEARCHING
DTFWRD:	MOV	#3,@R4		;SEARCH FORWARD (RNUM)
4$:	BIT	#100200,@R4	;WAIT
	BEQ	4$
	BMI	DTERR
	CMP	R0,@R3		;DESIRED BLOCK
	BGT	DTFWRD		;NO-SEARCH FORWARD
	BLT	DTSRCH		;NO-SEARCH REVERSE
	MOV	R2,-(R3)	;BUFFER ADDRESS
	NEG	R1
	MOV	R1,-(R3)	;WORD COUNT
	MOV	#5,@R4		;READ 
DT4:	BIT	#100200,@R4	;WAIT FOR COMPLETION
	BEQ	DT4
	BMI	BIOERR		;READ ERROR
	CLR	@R4		;STOP DT
	RTS	PC
DTERR:	TST	@#TCST		;WHAT KIND OF ERROR ?
	BPL	BIOERR		;NOT END ZONE
	BIT	#4000,@R4	;REVERSE?
	BNE	DTFWRD		;THEN GO SEARCH FORWARD
	BR	DTSRCH		;ELSE SEARCH REVERSE

.ENDC
	.IF DF	$DXSYS		;FLOPPY SYSTEM
	.SBTTL	BOOTSTRAP I/O DRIVER - FLOPPY

	SYSDEV	DX,264		;FLOPPY VECTORS THROUGH 264

READ:	ASL	R0		;CONVERT BLOCK TO LOGICAL SECTOR
	ASL	R0		;LSN=BLOCK*4
	ASL	R1		;MAKE WORD COUNT BYTE COUNT
1$:	MOV	R0,-(SP)	;SAVE LSN FOR LATER
	MOV	R0,R3		;WE NEED 2 COPIES OF LSN FOR MAPPER
	MOV	R0,R4
	CLR	R0		;INIT FOR TRACK QUOTIENT
	BR	3$		;JUMP INTO DIVIDE LOOP
2$:	SUB	#23.,R3		;PERFORM MAGIC TRACK DISPLACEMENT
3$:	INC	R0		;BUMP QUOTIENT, STARTS AT TRACK 1
	SUB	#26.,R4		;TRACK=INTEGER(LSN/26)
	BPL	2$		;LOOP - R4=REM(LSN/26)-26
	CMP	#-14.,R4	;SET C IF SECTOR MAPS TO 1-13
	ROL	R3		;PERFORM 2:1 INTERLEAVE
4$:	SUB	#26.,R3		;ADJUST SECTOR INTO RANGE -1,-26
	BPL	4$		;(DIVIDE FOR REMAINDER ONLY)
	ADD	#27.,R3		;NOW PUT SECTOR INTO RANGE 1-26
	BPT			;CALL READS SUBROUTINE
	MOV	(SP)+,R0	;GET THE LSN AGAIN
	INC	R0		;SET UP FOR NEXT LSN
	TST	R1		;WHATS LEFT IN THE WORD COUNT
	BGT	1$		;BRANCH TO TRANSFER ANOTHER SECTOR
	RTS	PC		;RETURN

TRWAIT:	TST	@R4		;ERROR, DONE, OR TR UP?
	BEQ	TRWAIT		;BR IF NOT
	BPL	RTIRET		;RETURN FROM INTERUPT

	;*****  THIS MUST FALL INTO BIOERR  *****

	.ENDC

	.IF DF	$FLSYS		;SGTL FLOPPY SYSTEM
	.SBTTL	BOOTSTRAP I/O DRIVER - FLOPPY
SMSCSR=177200	;CSR
SMSDBF=SMSCSR+2	;DATA BUFFER
SMSCMD=SMSDBF+2	;COMMAND BUFFER

SMSSEK=1	;SEEK COMMAND
SMSRED=2	;READ
 SMSDTB=100	;DISK TO BUFFER
 SMSBTH=200	;BUFFER TO HOST

SMSCLE=2000	;CLOCK ENABLE
SMSCMW=20	;COMMAND WAIT
SMSXFW=1	;XFER WAIT

	SYSDEV	FL,270		;FLOPPY VECTORS THROUGH 264

READ:	ASL	R0		;CONVERT BLOCK TO LOGICAL SECTOR
	ASL	R0		;LSN=BLOCK*4
	ASL	R1		;MAKE WORD COUNT BYTE COUNT
1$:	MOV	R0,-(SP)	;SAVE LSN FOR LATER
	MOV	R0,R3		;WE NEED 2 COPIES OF LSN FOR MAPPER
	MOV	R0,R4
	CLR	R0		;INIT FOR TRACK QUOTIENT
	BR	3$		;JUMP INTO DIVIDE LOOP
2$:	SUB	#23.,R3		;PERFORM MAGIC TRACK DISPLACEMENT
3$:	INC	R0		;BUMP QUOTIENT, STARTS AT TRACK 1
	SUB	#26.,R4		;TRACK=INTEGER(LSN/26)
	BPL	2$		;LOOP - R4=REM(LSN/26)-26
	CMP	#-14.,R4	;SET C IF SECTOR MAPS TO 1-13
	ROL	R3		;PERFORM 2:1 INTERLEAVE
4$:	SUB	#26.,R3		;ADJUST SECTOR INTO RANGE -1,-26
	BPL	4$		;(DIVIDE FOR REMAINDER ONLY)
	ADD	#27.,R3		;NOW PUT SECTOR INTO RANGE 1-26
	JSR PC,READS		;CALL READS SUBROUTINE
	MOV	(SP)+,R0	;GET THE LSN AGAIN
	INC	R0		;SET UP FOR NEXT LSN
	TST	R1		;WHATS LEFT IN THE WORD COUNT
	BGT	1$		;BRANCH TO TRANSFER ANOTHER SECTOR
	RTS	PC		;RETURN


GETST:	BIT #SMSXFW,(R4)
	BEQ GETST
	TST (R4)		;ERROR?
	BLT 1$			;YUP
	TST SMSDBF		;FLUSH STATUS BYTE
	RTS PC

1$:	TST SMSDBF		;FLUSH STATUS BYTE
	TST (SP)+		;FLUSH RETURN ADDRESS
;** FALLS IN TO BIOERR
	.ENDC


BIOERR:	JSR	R0,REPORT	;SAY THAT WE GOT ERROR
	.ASCIZ	<15><12>\?B-I/O ERROR\<12>
	.EVEN
.SBTTL	BOOTSTRAP CORE DETERMINATION

REPOR1:	MOVB	(R0)+,@#TPB	;PUT ANOTHER CHARACTER OUT
REPORT:	TSTB	@#TPS		;WAIT FOR TYPER READY
	BPL	REPORT		; ...
	TSTB	@R0		;ANYTHING MORE ?
	BNE	REPOR1		;YES, LOOP
	RESET			;STOP ALL DEVICES
	HALT
	BR	.-2		;KEEP HIM FROM CONTINUING

BOOT:	MOV	#10000,SP	;SET STACK POINTER
	MOV	#2,R0		;READ IN SECOND PART OF BOOT
	MOV	#<BOOTSZ-1>*400,R1 ;EVERY BLOCK BUT THE ONE WE ARE IN
	MOV	#1000,R2	;INTO LOCATION 1000
	JSR	PC,READ
.IIF GT	.-1000,	.ERROR		;BOOTSTRAP BLOCK 0 TOO BIG
	MOV	#4,R3		;POINT TO TRAP LOCATIONS
	MOV	@R3,R5		;SAVE TRAP LOC
	MOV	#NXM,@R3	;SET TRAP FOR NON EXISTENT MEMORY ;DV15

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; THIS BOOTSTRAP CAN SIMULATE ANY SIZE PDP-11.
; IF LOCATION 'FIDDLE' IS A HALT, THE CPU WILL STOP DURING THE BOOT.
; ON CONTINUE, THE TOP 5 BITS OF THE SWITCH REGISTER ARE USED TO
; SET THE TOP OF AVAILABLE CORE AS A MULTIPLE OF 1K.
; IF THE SR IS >= 160000 OR IF FIDDLE IS A   BR 1$ ,
; THE BOOTSTRAP WILL DO A NORMAL CORE DETERMINATION.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.ENABL	LSB

BHALT:	.GLOBL	BHALT		;FOR THE LOAD MAP...

FIDDLE:	BR	1$		;CHANGE TO HALT FOR FIDDLING
	MOV	@#SR,R2		;GET SWITCH VALUE
	BIC	#3777,R2	;ISOLATE TOP 5 BITS (1K INCREMENTS)
	CMP	R2,#160000	;SHOULD WE DO NORMAL CHECK ?
	BLO	NXM		;NO, USE THE SR VALUE
1$:	CLR	R2		;LOOK FOR TOP OF CORE
2$:	ADD	#4000,R2	;MOVE TO NEXT 1K BANK
.IF NDF $FLSYS			;WE WANT TO ALLOW FULL MEMORY USAGE
	CMP	R2,#160000	;REACHED 28K YET ?
	BEQ	NXM		;YES, DO A 28K SYSTEM
.ENDC
	TST	@R2		;NO, SEE IF THIS LOCATION EXISTS
	BR	2$		;KEEP GOING IF WE DIDN'T TRAP
NXM:	MOV	#BCLR,@R3	;NONMEMORY TRAPS HERE		;DV15
	MOV	@R3,10		;BAD INSTRUCTIONS TRAP HERE
	MOV	#TSLIST,R1	;BITS FOR CLEARING ON ERROR TRAPS
	MOV	R1,R0
.IF DF $DXSYS!$RKSYS!$FLSYS					;DV15
	TST	@#PS		;TEST FOR LSI11			;DV15
	BIC	(R1)+,-(R0)	;CLEAR BIT IF NOT LSI11, ADVANCE LIST ;DV15
	BNE	5$		;BR IF LSI11, ASSUME A CLOCK	;DV15
.IFTF								;DV15
	TST	@(PC)+		;CHECK PRESENCE OF CLOCK
LK.CS:	.WORD	LKCS
.IFT								;DV15
5$:	BIS	(R1)+,@R0	;ADVANCE LIST			;DV15
.IFF								;DV15
	BIS	(R1)+,-(R0)	;ADVANCE LIST			;DV15
.ENDC								;DV15
.DSABL	LSB
	TST	@#GT40		;CHECK FOR DISPLAY
	BIS	(R1)+,@R0
	CFCC			;CHECK FOR FPU
	BIS	(R1)+,@R0
	MOV	R5,(R3)+	;RESTORE TRAP
	TST	(R3)+		;BUMP TO POINT TO 10		;DV15
	MOV	R5,@R3		;RESTORE 10			;DV15
	SUB	#RTSIZE,R2	;R2 NOW POINTS TO WHERE WE WANT THE KMON
	ADD	#FILLER,R2	;ABUT IT AGAINST THE TOP OF CORE
.IF NDF $DXSYS!$FLSYS						;DV15
	SUB	(PC)+,R2	;RECOVER UNUSED CORE FROM SY:
SYSIZE = .
. = .+2				;SYSTEM HANDLER SIZE PUT HERE
	ADD	#MAXSYH,R2	;THIS WAY BECAUSE NO GLOBAL ARITH.
.ENDC								;DV15
	CMP	R2,#10000	;IS IT JUST TOO TINY ?
	BLO	TOOSML		;YES
	MOV	R2,-(SP)	;PUT LOAD ADDRESS ON STACK
	MOV	#1,R0		;NOW READ FIRST DIRECTORY BLOCK
DFND:	ASL	R0
	ADD	#4,R0		;DIRECTORY STARTS AT 6
	MOV	#1000,R1
	MOV	#BUFFB,R2
	JSR	PC,READ		;READ THE SEGMENT
	MOV	#BUFFB+10,R1	;POINT TO START BLOCK WORD
	MOV	(R1)+,R0
MONF:	MOV	R1,R2		;SAVE ADDRESS OF STATUS WORD
	BIT	#PERM,(R1)+	;IS IT A PERMANENT FILE?
	BEQ	1$		;NO. WE ARE TRYING TO FIND THE
	SUB	(PC)+,(R1)+	;FILE  MONITR.SYS, AS THAT IS
	 .RAD50	/MON/		;THE CURRENT MONITOR.
	SUB	(PC)+,(R1)+
	 .RAD50	/ITR/
	SUB	(PC)+,(R1)
	 .RAD50	/SYS/
	BNE	1$		;LAST WAS NOT .SYS EXTENSION
	BIS	-(R1),-(R1)	;BOTH MUST BE 0
	BEQ	MONFND		;FOUND THE MONITOR
1$:	BIT	#ENDBLK,(R2)	;IS THIS ALL IN SEGMENT?
	BNE	2$		;YES. READ NEXT, IF ANY.
	ADD	10(R2),R0	;INCREASE START BLOCK
	ADD	#16,R2		;GET TO NEXT ENTRY
	ADD	BUFFB+6,R2
	MOV	R2,R1		;POINT R1 TO NEXT
	BR	MONF
2$:	MOV	BUFFB+2,R0	;SEE IF NEXT IS AVAILABLE
	BNE	DFND		;YES. CONTINUE
	JSR	R0,REPORT	;HE AIN'T GOT A MONITOR
.IIF NDF $FLSYS,	.ASCIZ	<15><12>\?B-NO MONITR.SYS\<12>
.IIF DF $FLSYS,		.ASCIZ	<15><12>\?B-NO MON\
	.EVEN
TOOSML:	JSR	R0,REPORT	;HE IS IN A TINY MACHINE
.IIF NDF $FLSYS,	.ASCIZ	<15><12>\?B-NOT ENOUGH CORE\<12>
.IIF DF $FLSYS,		.ASCIZ	<15><12>\?B-NO CORE\
	.EVEN
.SBTTL	READ MONITOR, LOOKUP HANDLERS
MONFND:	MOV	@SP,R2		;RECALL LOAD LOCATION
	ADD	#BOOTSZ,R0	;BUMP R0 OVER BOOT RECORDS
	MOV	R0,-(SP)	;SAVE SWAP BLOCK POINTER
.IF NDF $DXSYS!$FLSYS							;DV15
	MOV	#MAXSYH,R1	;DO GLOBAL ARITHMETIC HERE
	SUB	SYSIZE,R1	;R1 = MAXSYH-SYSIZE (BYTES)
	ADD	#FILLER,R1	;ADD AMOUNT OF EXTRA STUFF
.IFF								;DV15
	MOV	#FILLER,R1	;AMOUNT OF EXTRA STUFF		;DV15
.ENDC								;DV15
	ASR	R1		;(WORDS)
	NEG	R1		;(TO SUBTRACT)
	ADD	#RTLEN,R1	;LENGTH TO LOAD (WORDS)
	ADD	#SWAPSZ,R0	;POINT TO BLOCK WITH KMON
	JSR	PC,READ		;READ THE MONITOR INTO PLACE
	MOV	#RELLST,R0	;POINT TO LIST OF THINGS TO RELOCATE
	MOV	(SP)+,R1	;R1 = SWAP BLOCK NUMBER
	MOV	(SP)+,R4	;R4 -> KMON IN CORE
	SUB	#KMON,R4	;SUBTRACT LOCATION KMON WAS LINKED TO
	MOV	R1,$SWPBL(R4)	;R4 = BIAS. SET UP SWAP BLOCK #
	ADD	#SWAPSZ,R1
	ADD	#KMONSZ,R1
	MOV	R1,$MONBL(R4)	;SET USR BLOCK #
1$:	ADD	R4,@(R0)+	;RELOCATE A POINTER IN THE ASECT
	CMP	R0,#RELST2	;DONE YET ?
	BLO	1$		;NO
	MOV	(R0)+,R5	;GET POINTER TO THING IN MONITOR
2$:	ADD	R4,R5		;BIAS THE POINTER
	ADD	R4,@R5		;NOW RELOCATE THE WORD
	MOV	(R0)+,R5	;GET NEXT POINTER
	BNE	2$
.IF DF $DXSYS!$RKSYS!$FLSYS					;DV15
	BIT	#LSI11$,BCNFG	;AN LSI11 MACHINE??		;DV15
	BEQ	4$		;NO, SKIP CODE MODIFICATION	;DV15
	MOV	(R0)+,R5	;YES, GET ADDR OF PS REFERENCE	;DV15
3$:	ADD	R4,R5		;BIAS THE POINTER		;DV15
	MOV	(R0)+,@R5	;MODIFY THE CODE		;DV15
	MOV	(R0)+,R5	;GET NEXT POINTER		;DV15
	BNE	3$		;BRANCH IF MORE			;DV15
.ENDC								;DV15
4$:	MOV	@#54,R0		;POINT TO MONITOR		;DV15

	.IF DF	$RKSYS!$DXSYS!$DPSYS!$DSSYS ;THE RK,RX,RP,RJSO3/4 CAN BOOT FROM ANY UNIT

	.IF DF	$RKSYS		;CODE FOR RK
	MOV	@#RKDA,R1	;GET THE RK UNIT NUMBER
	ROL	R1
	ROL	R1
	ROL	R1
	ROL	R1
	BIC	#^C7,R1		;EXTRACT IT
	.ENDC			;DF $RKSYS
	.IF DF	$DSSYS		;CODE FOR RJS03/4
	MOV	@#RSCS2,R1	;UNIT # INTO R1
	BIC	#^C7,R1		;STRIP TO 3 BITS
	.ENDC
	.IF DF	$DPSYS		;RP11
	MOV	@#RPCS,R1	;GET CONTROLLER STATUS REG INTO R1
	BIC	#^C<CS.DRV>,R1	;STRIP TO UNIT NUMBER
	SWAB	R1		;UNIT # INTO BITS 2-0
	.ENDC			;DF $DPSYS

	.IF DF	$DXSYS		;FLOPPY
	MOV	BTUNIT,R1	;GET BOOTED UNIT (STORED BY BOOT2)
	.ENDC			;DF $DXSYS

	ADD	R1,DKASSG(R0)	;FIX PERMANENT PSEUDO-ASSIGNMENTS
	ADD	R1,SYASSG(R0)
	MOVB	R1,SYUNIT+1(R0)	;SET UNIT NUMBER WE BOOTED

	.ENDC			;DF $RKSYS!$DXSYS!DPSYS
.ENABL	LSB

	BIS	BCNFG,CONFIG(R0) ;SET HARDWARE CONFIGURATION
	CLR	R3		;COUNT DEVICE SLOTS
	MOV	#$ENTRY,R1	;POINT TO $ENTRY TABLE IN RMON
	ADD	R4,R1
4$:	TST	(R1)+		;RESIDENT DEVICE ?
	BEQ	5$		;NO, SKIP IT
	ADD	R4,-(R1)	;YES, FIX HANDLER POINTER
	CMP	$PNAMO(R1),#SYNAME ;IS THIS THE SYSTEM DEVICE?
	BNE	45$		;NO
	MOV	R3,SYINDO(R0)	;SET SYSTEM INDEX NUMBER
	ADD	R3,SYINDO(R0)	;(DOUBLED)
	MOV	@R1,SYENTO(R0)	;AND SET UP SYSTEM ENTRY POINTER
45$:	TST	(R1)+
5$:	INC	R3		;ANY MORE ?
	CMP	#$SLOT,R3
	BNE	4$
	ADD	#SYBITO,R0	;ADD IN OFFSET TO SYSTEM VECTOR IN MAP
	BISB	#SYBITS,MAPOFF(R0) ;AND PROTECT IT
	MOV	#$PNAME,R1	;POINT TO PERM NAME TABLE
	ADD	R4,R1
	ADD	#$DVREC,R4	;POINT R4 TO $DVREC IN RMON
	MOV	#$SLOT,R3	;NUMBER TO LOOK UP
6$:	MOV	(R1)+,FNAME	;FILL IN NAME IN LOOKUP
	.LOOKUP	0,#BLOOK	;LOOKUP SY:HH.SYS
	BCC	7$		;GO IF THERE
	CLR	(R4)+		;CLEAR RECORD NUMBER
	BR	8$
7$:	.SAVEST	0,#CBLOK	;SAVE STATUS OF THING
	MOV	CBLOK+2,@R4	;SET STARTING RECORD
	INC	(R4)+		;FIX IT
8$:	DEC	R3
	BNE	6$
	MOV	#100000,@#JSW	;NOTHING TO SWAP
	.PRINT	#BSTRNG		;PRINT BOOT HEADER
	CLR	R0
	MOV	(PC)+,(R0)+
	 BIC	R0,R0
	MOV	(PC)+,(R0)+
	 .EXIT
.IF DF $DXSYS!$RKSYS!$FLSYS					;DV15
	BIT	#LSI11$,BCNFG	;IF THIS IS AN LSI11		;DV15
	BNE	10$		;NO CLOCK STATUS REGISTER	;DV15
.ENDC								;DV15
	BIT	#KW11L$,BCNFG	;AND IF HE HAS A CLOCK
	BEQ	10$		;  WE TURN IT
	MOV	#100,@LK.CS	;    ON
.IF NDF $DXSYS
	MOV	#100,@(PC)+	;PATCH TO SET KW11-P PRESET COUNT
	.WORD	LKCS
.ENDC
10$:	CLR	R0
.IF DF $FLSYS
	BIS #SMSCLE,SMSCSR	;ENABLE CLOCK
.ENDC
	.EXIT
.DSABL	LSB

BCLR:	CLR	@R1		;TRAP MEANS THIS CONFIGURATION NYET
	RTI			;UNTRAP
.SBTTL	RELOCATION LIST
RELLST:	4			;ILLEGAL MEM AND INST. TRAPS
	10
	30			;EMT
	54			;ADDRESS OF RMON
	60			;TTY VECTORS
	64
	100			;CLOCK VECTOR
	SYVEC			;SYSTEM DEVICE VECTOR
	244			;LOCATION OF FPU TRAP
RELST2:	USRLOC			;LOCATION OF USR NOW
	$USRLC			;ADDRESS OF 'NORMAL' USR
	QCOMP			;QUEUE COMPLETION
	$KMLOC			;ADDRESS OF KMON
	TTIBUF			;TTY RING BUFFER--INPUT
	TTIBUF+2
	TTIBUF+6
	TTIBUF+10
	TTOBUF			;TTY RING BUFFER--OUTPUT
	TTOBUF+4
	TTOBUF+6
	SYSLOW			;LOWEST USED LOCATION
	CORPTR+2		;FREE CORE LIST
	$INPTR			;POINTER TO $INTEN IN RESIDENT HANDLER
	SYNCH			;SYNCHRONIZATION ADDRESS
.IF NE BF
	MSGENT			;RELOCATE F/B STUFF HERE
	IMPLOC							;DV16
	TTIUSR
	TTOUSR
	FUDGE1
	FUDGE2
	BKGND1
	BKGND2
	BKGND3
	CNTXT
	BCNTXT
	RMONSP
	SWIPTR
	SWOPTR
	.$CRTN
.IFF
	TRAPLC
	TRAPER			;LOCS FOR TRAPS TO 4/10
	FPPADD
	FPPIGN			;FPP SERVICE FOR MONITOR
	MONLOC			;WHERE USR WILL SIT
	I.CSW			;SINGLE USER STUFF HERE
	AVAIL			;MONITOR FREE Q POINTER
.ENDC
	0			;END OF LIST OF ADDRESSES
; CODE MODIFICATION LIST FOR LSI11 PROCESSORS			;DV15
.IF DF $DXSYS
	DXINT+4			;RUN DX AT PRI 0 ON LSI-11	;DV24
	^C<PR0>&PR7						;DV24
.ENDC
.IF DF $DXSYS!$RKSYS!$FLSYS					;DV15
	GETPSW+2						;DV15
	MFPS	2(SP)						;DV15
	. = . - 2						;DV15
	GETPSW+4						;DV15
	2							;DV15
	GETPSW+6						;DV15
	RTS	PC						;DV15
.IF EQ BF							;DV15
	$INTEN+2						;DV15
	MFPS	R4						;DV15
	$INTEN+4						;DV15
	BIC	(R5)+,R4					;DV15
	$INTEN+6						;DV15
	MTPS	R4						;DV15
.IFF								;DV15
	RMONSP+4						;DV15
	MFPS	R4						;DV15
	RMONSP+6						;DV15
	BIC	(R5)+,R4					;DV15
	RMONSP+10						;DV15
	MTPS	R4						;DV15
.ENDC								;DV15
	0			;END OF LIST			;DV15

BCNFG:	.WORD	LSI11$		;BOOT CONFIGURATION WORD-DO NOT MOVE ;DV15
TSLIST:	.WORD	LSI11$,KW11L$,HWDSP$,HWFPU$ ;BITS IN CONFIG WORD ;DV15
.IFF								;DV15
BCNFG:	.WORD	0		;BOOT CONFIGURATION WORD-DO NOT MOVE ;DV15
TSLIST:	.WORD	KW11L$,HWDSP$,HWFPU$ ;BITS IN CONFIG WORD	 ;DV15
.ENDC								;DV15

.IF NDF $RKSYS
; BLOOK IS THE ARGUMENT AREA FOR AN RT-11 LOOKUP.
BLOOK:	.RAD50	/SY /
FNAME:	.WORD	0,0		;FILENAME GOES HERE
	.RAD50	/SYS/
CBLOK:	.BLKW	1		;SAVESTATUS GOES HERE
.ENDC
.IIF GT .-2000,.ERROR		;PIP WON'T WIN IF BOOT IS BIGGER THAN 2 BLOCKS
BUFFB = . + 12

BOOTSZ	= . + 777 / 1000
.	= BOOTSZ * 1000
	.END
