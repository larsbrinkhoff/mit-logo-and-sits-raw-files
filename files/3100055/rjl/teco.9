	.TITLE SITS TECO

;	PDP-11 TECO
;	A BRUTE FORCE TRANSLATION BY HANK MAURER
;	(  1-JUNE-1973  THROUGH  4-JUNE-1973  )
;	(WITH I/O ARRANGEMENTS BY BOB HARTMAN)
;	(AT FORD OF COLOGNE, WEST GERMANY)
;	[SLIGHT MODIFICATIONS BY MARK BRAMHALL OF DEC]
;	[FOR CORE EXPANSION AND HIGH/LOW SEGS]
;	<PDP-10 COMPATIBILITY, ETC. BY ANTON CHERNOFF>
;	OF OS-8 TECO WHICH COMES FROM A PROGRAM
;	ORIGINALLY WRITTEN BY RUSSELL HAMM, WAY BACK WHEN
;	MODIFIED FOR OS/8 BY THE O.M.S.I. CREW
;	SPEEDED UP, SHORTENED AND MADE PDP-10
;	COMPATIBLE BY RICHARD LARY OF DEC
;	WITH ASSISTANCE FROM MARIO DENOBILI OF THE P?S

VERSON	=	11.		;VERSION NUMBER
;THIS VERSION OF TECO IS IN THE PROCESS OF BECOMING SITS COMPATIBLE


.RADIX	10
.IRP	N,<\VERSON>
.RADIX	8
.LIST
.IDENT	/V'N/
.NLIST
.ENDM
.SBTTL	INTERNAL GLOBALS

; ENTRY POINT AND VERSION NUMBER

.GLOBL	TECO,	VERSON

; READ/WRITE (F OFFSET) AREA SIZE

.GLOBL	RWSIZE

; SPECIAL ACCESS TO LINE-FINDING ROUTINE

.GLOBL	.VVV.V

; SPECIAL ACCESS FOR CCL USAGE

.GLOBL	DOCCL

; VARIOUS GLOBAL OFFSETS ARE DEFINED LATER...
;GLOBAL DISPLAY STUFF
.GLOBL TYO
.GLOBL ECHO
.GLOBL DSPLAY
.GLOBL CMDFLG
.GLOBL DERFLG
.GLOBL TTINIT
.GLOBL TOPDIS
.SBTTL	EXPLAINING THINGS...

; ASSEMBLY PARAMETER
;
; IF THE SYMBOL "ERRTXT" IS DEFINED AS NON-ZERO, THEN ALL ERROR
;	CALLS (INCLUDING THOSE FROM 'TECOIO') PASS AN ASCIZ
;	STRING TO EXPLAIN THE ERROR. IF THE SYMBOL "ERRTXT" IS
;	DEFINED AS ZERO, THEN NO ASCIZ STRINGS NEED BE PASSED
;	AND NO EXPLANATIONS ARE EVER GIVEN.
;
; THE DEFAULT IS FOR "ERRTXT" TO BE DEFINED AS NON-ZERO.

.IIF	NDF	ERRTXT	ERRTXT=1	;DO THE DEFAULT
; READ/WRITE AREAS USED BY TECO
;
; THERE ARE FOUR DIFFERENT READ/WRITE AREAS:
;
; 1) THE MAIN READ/WRITE AREA (TECO'S CRITICAL DATA)
;
;	LENGTH:	DEFINED (FOR 'TECOIO') BY THE TECO DEFINED
;		GLOBAL "RWSIZE". THIS IS THIS AREA'S SIZE
;		IN BYTES.
;	WHERE:	'TECOIO' DETERMINES WHERE THIS AREA IS AND
;		POINTS TO IT BY SETTING F TO POINT TO ITS START.
;	SETUP:	THIS WHOLE AREA MUST BE CLEARED TO ALL ZEROS
;		EXCEPT FOR THE FOLLOWING ITEMS:
;			TECOSP (SEE AREA #2)
;			TECOPD, PDL, SCHBUF (SEE AREA #3)
;			TXSTOR, QRSTOR, ZMAX, QMAX, CURFRE
;				(SEE AREA #4)
;		[NOTE: THE ABOVE ITEMS ARE DEFINED BY TECO AS
;			GLOBAL OFFSET VALUES FROM F.]
;
; 2) THE SP STACK AREA (FOR TECO AND 'TECOIO' USAGE)
;
;	LENGTH:	WHATEVER SEEMS REASONABLE (200(8) BYTES SEEMS
;		A GOOD GUESS).
;	WHERE:	'TECOIO' INITIALLY SETS THE STACK POINTER (SP)
;		TO POINT TO THE END OF THIS AREA +2. IN ADDITION,
;		'TECOIO' SETS "TECOSP" TO ALSO POINT TO THE END
;		OF THIS AREA +2 (I.E. SP STACK RESET VALUE).
;	SETUP:	NONE NEEDED.
;
; 3) THE PUSH-DOWN LIST AND SEARCH BUFFER
;
;	LENGTH:	WHATEVER SEEMS REASONABLE (100(8) BYTES FOR
;		THE PUSH-DOWN LIST AND ANOTHER 100(8) BYTES FOR
;		THE SEARCH BUFFER SEEM GOODLY NUMBERS).
;		NOTE THAT THESE TWO AREAS ARE COMBINED INTO ONE
;		AREA. TECO DEPENDS ON THE FACT THAT THIS IS
;		TRUE! FURTHERMORE, THE PUSH-DOWN LIST MUST BE
;		THE LOWER IN ADDRESS SPACE OF THESE TWO COMBINED
;		AREAS.
;		'TECOIO' MUST GLOBALIZE THE SEARCH BUFFER'S
;		LENGTH VIA THE SYMBOL "SCHSIZ".
.GLOBL	SCHSIZ
;	WHERE:	'TECOIO' POINTS TO THIS AREA BY SETTING:
;			"TECOPD" AND "PDL" TO POINT TO THE AREA'S
;				START (PUSH-DOWN LIST).
;			"SCHBUF" TO POINT INTO THE MIDDLE OF THE
;				AREA (SEARCH BUFFER START).
;	SETUP:	THE BYTE POINTED TO BY "SCHBUF" MUST BE SETUP
;		TO BE -1. ALL OTHER BYTES NEED NOT BE SET UP.
;
; 4) THE TEXT AND Q-REGISTER DATA AREA
;
;	LENGTH:	'TECOIO' INITIALLY DEFINES THE LENGTH OF THIS
;		AREA, BUT THIS AREA'S SIZE IS CAPABLE OF BEING
;		EXPANDED (IF YOUR ENVIORNMENT ALLOWS IT). THE
;		AREA'S LENGTH IS REFLECTED BY THE SUM OF "ZMAX"
;		PLUS "QMAX" PLUS "CURFRE". THE AREA IS ORGANIZED
;		SUCH THAT TEXT STORAGE COMES FIRST (LOWEST IN
;		ADDRESS SPACE), THE Q-REGISTER STORAGE COMES
;		NEXT, AND THE FREE SPACE (IF ANY) COMES LAST.
;		"ZMAX", "QMAX", AND "CURFRE" REFLECT THE SIZES
;		OF THESE AREAS RESPECTIVELY.
;	WHERE:	'TECOIO' SETS UP TWO POINTERS TO THIS AREA:
;			"TXSTOR" POINTS TO AREA'S START
;				(TEXT START).
;			"QRSTOR" POINTS TO AREA'S MIDDLE
;				(Q-REGISTER START).
;		NOTE THAT TECO MAY SHUFFLE THE TEXT AND Q-REGISTER
;		AREAS WITHIN THIS WHOLE AREA THUS CHANGING "QRSTOR"
;		AS WELL AS THE MAXIMUMS.
;		ONE OF THE 'TECOIO' SUBROUTINE CALLS IS FOR
;		EXPANDING THIS AREA. WHEN 'TECOIO' EXPANDS THE
;		AREA (BY ADDING TO ITS END), 'TECOIO' MUST UPDATE
;		(BY ADDING TO) "CURFRE" TO REFLECT THE ADDITION.
;	SETUP:	NONE NEEDED.
; DOCUMENTATION OF 'TECOIO' SUBROUTINES
;
; NOTE THAT, UNLESS A REGISTER IS SPECIFICALLY MENTIONED AS
; OUTPUT FROM A SUBROUTINE, IT MUST BE PRESERVED!

.GLOBL	DATE	;JSR PC,DATE
; OUT:	A = TODAY'S DATE IN SYSTEM INTERNAL FORM

.GLOBL	WATCH	;JSR PC,WATCH
; IN:	A =  0 MEANS CLEAR THE SCOPE (WE WON'T CALL AGAIN)
;	   <> 0 MEANS DISPLAY A LINES & KEEP SCOPE BUSY
;
; NOTE:	YOU CAN ALSO KEEP SCOPE BUSY AT ANY STALL TIME OF COURSE
;       THE NUMBER OF LINES TO WATCH IS ALWAYS AVAILABLE IN NWATCH(E)

.GLOBL	LISTEN	;JSR PC,LISTEN
; IN:	A =  0 MEANS DELIMITERS ARE: ALTMODE, RUBOUT, CTRL/U, CTRL/G
;	A <> 0 MEANS ANYTHING IS A DELIMITER (SINGLE CHARACTER MODE)
;
; OUT:	A = RETURNED CHARACTER (001 <= CHARACTER <= 177)
;
; NOTE:	IT IS THE RESPONSIBILITY OF 'LISTEN' TO APPEND A LINE
;	FEED TO A CARRIAGE RETURN (IF THE SYSTEM DOESN'T)
;	IT IS ALSO THE RESPONSIBILITY OF 'LISTEN' TO ECHO
;	THE TYPED CHARACTERS (IF THE SYSTEM DOESN'T)

.GLOBL	TYPE	;JSR PC,TYPE
; IN:	A = CHARACTER TO OUTPUT TO TERMINAL
;
; NOTE:	ANY CHARACTER CONVERSIONS (TAB'S, ETC.) ARE TO BE DONE BY
;	'TYPE' (IF THE SYSTEM DOESN'T)

.GLOBL	PRINT	;JSR PC,PRINT
; IN:	D = POINTER TO STRING OF CHARACTERS TO PRINT
;	E = NUMBER OF CHARACTERS TO PRINT (0 <= E <= 32767.)
;
; NOTE:	JUST LIKE 'TYPE', 'PRINT' IS RESPONSIBLE FOR ANY CHARACTER
;	CONVERSIONS (IF SYSTEM DOESN'T DO IT FOR YOU)

.GLOBL	XITNOW	;JSR PC,XITNOW
; NOTE:	IF 'TECOIO' CONDITIONED THE TERMINAL NON-NORMALLY FOR
;	TECO, THEN THIS IS THE TIME TO UNCONDITION IT. SHOULD
;	INPUT AND/OR OUTPUT BE REQUESTED AGAIN BY TECO (ONLY
;	HAPPENS IN CASE OF AN I/O ERROR), YOU MUST DETECT THE
;	FACT THAT YOU UNCONDITIONED THE TERMINAL AND RE-CONDITION
;	IT.

.GLOBL	TEXIT	;JMP TEXIT
; NOTE:	THIS IS THE WAY TECO EXITS TO THE OPERATING SYSTEM

.GLOBL	GEXIT	;JMP GEXIT
; NOTE:	THIS IS THE WAY TECO EXITS TO THE OPERATING SYSTEM TO
;	"GO"

.GLOBL	NOCTLO	;JSR PC,NOCTLO
; NOTE:	'NOCTLO' CANCELS ANY CTRL/O EFFECT CURRENTLY IN PROGRESS

.GLOBL	SIZER	;JSR PC,SIZER
; IN:	B = AMOUNT TO EXPAND THE TEXT & Q-REG AREA
;
; OUT:	IF AREA CAN (AND HAS BEEN) EXPANDED THE AMOUNT DESIRED,
;	THEN EXIT WITH THE CARRY CLEAR AND "CURFRE" UPDATED. IF
;	THE AREA CANNOT BE EXPANDED THAT AMOUNT, THEN EXIT WITH
;	THE CARRY SET AND "CURFRE" UNTOUCHED.

.GLOBL	TIME	;JSR PC,TIME
; OUT:	A = TIME OF DAY IN SYSTEM INTERNAL FORM

.GLOBL	SWITCH	;JSR PC,SWITCH
; OUT:	A = VALUE OF SWITCH REGISTER

.GLOBL	GETFLS	;JSR PC,GETFLS
; IN:	A = POINTER TO A "DEV:[P,PN]FILE.EXT" STRING
;	B = 0 FOR ER CALL
;	   < 0 FOR EB CALL
;	   > 0 FOR EW CALL
;	E = LENGTH OF "DEV:[P,PN]FILE.EXT" STRING
;
; OUT:	IF NO ERROR THEN CARRY BIT IS CLEAR.
;	SEE ERROR NOTES IF ERROR.

.GLOBL	GETBUF	;JSR PC,GETBUF
; IN:	A = POINTER TO BUFFER START
;	B = MAXIMUM SIZE OF BUFFER
;
; OUT:	IF NO ERROR THEN CARRY BIT IS CLEAR AND
;	B = ACTUAL NUMBER OF CHARACTERS TRANSFERED INTO BUFFER
;	C = -1 IF BUFFER ENDED WITH A FORM FEED
;	   =  0 IF BUFFER DIDN'T END WITH A FORM FEED
;	IF END-OF-FILE, THEN "EOFLAG" IS SET TO -1 AND
;	BOTH B AND C ARE RETURN AS ZERO (THIS IS NOT AN ERROR).
;	SEE ERROR NOTES IF ERROR.
;
; NOTE:	BUFFER IS FILLED UNTIL:
;	1) FORM FEED FOUND (C=-1) (THE FORM FEED IS NOT PUT IN BUFFER)
;	2) LESS THAN 128 CHARACTERS ARE FREE IN BUFFER AND
;		LINE FEED FOUND OR END OF FILE FOUND (C=0)
;	3) BUFFER IS FULL (C=0)

.GLOBL	PUTBUF	;JSR PC,PUTBUF
; IN:	A = POINTER TO BUFFER START
;	B = NUMBER OF CHARACTERS TO OUTPUT
;	C = -1 MEANS END BUFFER WITH FORM FEED
;	   =  0 MEANS DON'T ADD FORM FEED TO BUFFER
;
; OUT:	IF NO ERROR THEN CARRY BIT IS CLEAR.
;	SEE ERROR NOTES IF ERROR.

.GLOBL	CLSFIL	;JSR PC,CLSFIL
; NOTE:	CLOSES OUTPUT FILE AND DOES THE EB RENAMING IF NEEDED.
;
;	IF NO ERROR THEN CARRY BIT IS CLEAR.
;	SEE ERROR NOTES IF ERROR.

.GLOBL	INPSAV	;JSR PC,INPSAV
; NOTE:	SAVE STATUS OF CURRENTLY OPEN INPUT FILE.
;	SEE ERROR NOTES IF ERROR.

.GLOBL	OUTSAV	;JSR PC,OUTSAV
; NOTE:	SAVE STATUS OF CURRENTLY OPEN OUTPUT FILE.
;	SEE ERROR NOTES IF ERROR.

;ERROR NOTES:
;	ON ERROR EXITS SET:
;		CARRY BIT ON (I.E. "BCS" BRANCHES)
;		A = RAD50 OF ERROR CODE
;		C = POINTER TO ASCIZ TEXT OF ERROR (OR 0 FOR NO TEXT)
;	SPECIAL (CHECKED FOR BY TECO) ERROR CODES ARE:
.GLOBL		NI	;NO INPUT FILE CURRENTLY OPEN
.GLOBL		NO	;NO OUTPUT FILE CURRENTLY OPEN
;		THE VALUE OF "NI" AND "NO" AS RETURNED IN A
;		MUST BE GLOBALIZED BY 'TECOIO'.
;	THE ASCIZ ERROR MESSAGE TEXT ON AN ERROR RETURN FROM "GETFLS"
;	MAY OPTIONALLY CONTAIN A BYTE OF -2 TO SIGNAL PRINTING THE
;	FAILING FILE NAME STRING AT THAT POINT. E.G.
;		.ASCIZ	"FILE '"<-2>"' IS ILLEGAL"
.SBTTL	GENERAL PDP-11 DEFINITIONS

; GENERAL REGISTERS

A	=	%0
B	=	%1
C	=	%2
D	=	%3
E	=	%4
F	=	%5
SP	=	%6
PC	=	%7

.SBTTL	CHARACTER DEFINITIONS

NULL	=	000	;ASCII NULL
BELL	=	007	;ASCII BELL (CONTROL/G)
TAB	=	011	;ASCII HORIZONTAL TAB
LF	=	012	;ASCII LINE FEED
VT	=	013	;ASCII VERTICAL TAB
FF	=	014	;ASCII FORM FEED
CR	=	015	;ASCII CARRIAGE RETURN
ALTMOD	=	033	;ASCII ESCAPE (ALSO CALLED ALTMODE)
SPACE	=	040	;ASCII SPACE
LAB	=	'<	;ASCII LEFT ANGLE BRACKET
RAB	=	'>	;ASCII RIGHT ANGLE BRACKET
RUBOUT	=	177	;ASCII RUBOUT (ALSO CALLED DEL)

.SBTTL	COMMAND Q-REG VALUE

CMDQRG	=	<'Z-'A+1>+<'9-'0+1>+1
.SBTTL	MACROS

.MACRO	SORT	TABLE,ENTRY
	 JSR	E,SORT'ENTRY
	 .WORD	TABLE-2
.ENDM	SORT

.MACRO	PUSH	ARGS
	 JSR	E,PUSH
.IRP	ARG,<ARGS>
	 .WORD	ARG
.ENDM
	 .WORD	-1
.ENDM	PUSH

.MACRO	POP	ARGS
	 JSR	E,POP
.IRP	ARG,<ARGS>
	 .WORD	ARG
.ENDM
	 .WORD	-1
.ENDM	POP

.MACRO	SKPSET	CHR
	 JSR	E,SKPSET
	 .WORD	CHR
.ENDM	SKPSET

.MACRO	TSTNXT	CHR
	 JSR	E,TSTNXT
	 .WORD	CHR
.ENDM	TSTNXT

.MACRO	SIZE	AREA
	 JSR	E,SIZE
.IF	IDN	<AREA>,<TEXT>
	 .WORD	ZMAX
.MEXIT
.ENDC
.IF	IDN	<AREA>,<QREGS>
	 .WORD	QMAX
.MEXIT
.ENDC
.ERROR	; AREA IS ILLEGAL IN SIZE CALL
.ENDM	SIZE
.MACRO	OFFSET	LABEL,AMT
LABEL	=	$$$$$$
.GLOBL	LABEL
.LIST
		LABEL	=	LABEL
.NLIST
.IF	NB	<AMT>
$$$$$$	=	AMT*2+$$$$$$
.IFF
$$$$$$	=	1*2+$$$$$$
.ENDC
.ENDM	OFFSET

.MACRO	.TABLE	KIND
.'KIND:
.MACRO	.ENTRY	CHR,DSP
.IF	B	<DSP>
	 .WORD	''CHR,	KIND''CHR
.IFF
	 .WORD	''CHR,	DSP
.ENDC
.ENDM	.ENTRY
.ENDM	.TABLE

.MACRO	CMDCHR	VAL
.IRP	NUM,<\<VAL+1000>>
$$'NUM:
.CSECT	TECOCH
.	=	VAL*2+TECOCH
.NLIST
.SBTTL	COMMAND CHARACTER VAL
	 .WORD	$$'NUM
.LIST
.ENDM
.CSECT	TECORO
.ENDM	CMDCHR

.MACRO	MESSAG	TEXT
.CSECT	TECOER
.NLIST
$$$$$$	=	.
	 .ASCIZ	TEXT
.LIST
.CSECT	TECORO
.ENDM	MESSAG
.MACRO	ERROR	NUM,TEXT
.IF	NDF	$E$'NUM
$E$'NUM:
.ENDC
$$$$$$	=	.-$E$'NUM
.IF	GE	$$$$$$-400
	 JMP	$E$'NUM
.MEXIT
.ENDC
.IF	NE	$$$$$$
	 BR	$E$'NUM
.MEXIT
.ENDC
.IF	NE	ERRTXT
$$$$$$	=	0
.IRPC	CHR,<NUM>
$$$$$$	=	$$$$$$*40+<''CHR-<'A-1>>
.ENDM
.IF	EQ	$$$$$$&077740-<'N-<'A-1>*40+'A-<'A-1>*40+0>
	 JSR	E,ERRORA
$$$$$$	=	1.
.IRPC	CHR,<NUM>
.IF	EQ	$$$$$$-3.
	 .BYTE	''CHR-<'A-1>
.ENDC
$$$$$$	=	$$$$$$+1.
.ENDM
.NCHR	$$$$$$,<TEXT>
.IF	EQ	$$$$$$-17.
.IRPC	CHR,<TEXT>
.IF	EQ	$$$$$$-2.
	 .BYTE	''CHR
.ENDC
$$$$$$	=	$$$$$$-1.
.ENDM
.MEXIT
.ENDC
.IF	EQ	$$$$$$-24.
.IRPC	CHR,<TEXT>
.IF	EQ	$$$$$$-6.
	 .BYTE	''CHR-100
.ENDC
$$$$$$	=	$$$$$$-1.
.ENDM
.MEXIT
.ENDC
.ERROR	; NUM ERROR IN ILLEGAL FORMAT!!
	 .BYTE	'?
.MEXIT
.ENDC
.IF	EQ	$$$$$$&076037-<'I-<'A-1>*40+0*40+'C-<'A-1>>
	 JSR	E,ERRORC
$$$$$$	=	1.
.IRPC	CHR,<NUM>
.IF	EQ	$$$$$$-2.
	 .BYTE	''CHR-<'A-1>*5
.ENDC
$$$$$$	=	$$$$$$+1.
.ENDM
.NCHR	$$$$$$,<TEXT>
.IF	EQ	$$$$$$-21.
.IRPC	CHR,<TEXT>
.IF	EQ	$$$$$$-12.
	 .BYTE	''CHR
.ENDC
$$$$$$	=	$$$$$$-1.
.ENDM
.MEXIT
.ENDC
.IF	EQ	$$$$$$-30.
.IRPC	CHR,<TEXT>
.IF	EQ	$$$$$$-18.
	 .BYTE	''CHR-100
.ENDC
$$$$$$	=	$$$$$$-1.
.ENDM
.MEXIT
.ENDC
.ERROR	; NUM ERROR IN ILLEGAL FORMAT!!
	 .BYTE	'?
.MEXIT
.ENDC
.ENDC
	 JSR	E,ERRMSG
	 .RAD50	/NUM/
.IF	NE	ERRTXT
	 MESSAG	<TEXT>
	 .WORD	$$$$$$
.ENDC
.ENDM	ERROR
.SBTTL	INITIALIZE THE .CSECT'S, ETC.

; THIS ORDERS THE .CSECT'S (USE /SQ IF NEEDED...)

.CSECT	TECORO
.CSECT	TECOCH
.CSECT	TECOER

; THIS INITIALLY LOADS THE COMMAND CHARACTER TABLE

.CSECT	TECOCH
TECOCH:
.REPT	'_+1
.NLIST
	.WORD	ERROR
.LIST
.ENDR

; NOW BACK TO THE MAIN .CSECT

.CSECT	TECORO
.SBTTL	DEFINE THE OFFSETS FROM F

$$$$$$	=	0;OFFSETS START AT ZERO...

CLRSRT	=	$$$$$$;START OF EACH COMMAND CLEAR AREA

OFFSET	SCANP	;COMMAND LINE EXECUTION POINTER
OFFSET	NFLG	;NUMBER FLAG
OFFSET	N	;NUMBER
OFFSET	M	; ARGUMENTS
OFFSET	OFLG	;OPERATOR FLAG
OFFSET	CFLG	;COMMA FLAG
OFFSET	MPDL	;MACRO FLAG (SAVED "PDL")
OFFSET	ITRST	;ITERATION START
OFFSET	CLNF	;COLON FLAG
OFFSET	TFGTMP	;BACKUP FOR "TFLG"
OFFSET	QFLG	;QUOTED STRING FLAG
OFFSET	SCHAR	;LAST SORTED CHARACTER
OFFSET	OSCANP	;BACKUP FOR "SCANP"
OFFSET	QCMND	;COMMAND LINE OR MACRO Q REG NUMBER
OFFSET	QUOTE	;QUOTE CHARACTER (NORMALLY 33)
OFFSET	QNMBR	;CURRENT Q REG NUMBER
OFFSET	QLENGT	;COMMAND LINE LENGTH
OFFSET	CNDN	;COUNTER FOR " NESTING
OFFSET	NP	;VALUE OF CURRENT NUMBER
OFFSET	NACC	;EXPRESSION ACCULMULATOR
OFFSET	PST	;CHARACTER POSITION AT SEARCH START
OFFSET	ITRCNT	;ITERATION COUNT
OFFSET	NOPR	;ARITHMETIC OPERATOR
OFFSET	TEMP	;GENERAL TEMPORARY READ/WRITE WORD
OFFSET	TFLG	;TRACE FLAG
OFFSET	REPFLG	;REPLACE FLAG

CLREND	=	$$$$$$;END OF EACH COMMAND CLEAR AREA

OFFSET	FFFLAG	;FORM FEED FLAG
OFFSET	P	;CURRENT TEXT POINTER (.)
OFFSET	QBASE	;COMMAND LINE Q REG BASE OFFSET
OFFSET	NMRBAS	;RADIX
OFFSET	ERRPOS	;ERROR POSITION
OFFSET	PDL	;PUSH-DOWN LIST POINTER
OFFSET	LSCHSZ	;-(LENGTH) OF LAST SKIPPED QUOTED STRING
OFFSET	EHELP	;EDIT HELP LEVEL
OFFSET	ESFLAG	;EDIT SEARCH FLAG
OFFSET	ETYPE	;EDIT TYPEOUT FLAG
OFFSET	EOFLAG	;END-OF-FILE FLAG
OFFSET	NWATCH	;NUMBER OF LINES TO DISPLAY ON SCOPE
OFFSET	ROFLAG	;NON-ZERO IF RUBOUT OR CTRL/U (FOR SCOPE)

OFFSET	TXSTOR	;TEXT BUFFER BIAS
OFFSET	ZZ	;TEXT BUFFER SIZE IN USE
OFFSET	ZMAX	;TEXT BUFFER SIZE

OFFSET	QRSTOR	;Q REG BUFFER BIAS
OFFSET	QZ	;Q REG BUFFER SIZE IN USE
OFFSET	QMAX	;Q REG BUFFER SIZE

OFFSET	CURFRE	;CURRENT FREE SPACE IN BYTES

OFFSET	QARRAY,<<<'Z-'A+1>+<'9-'0+1>>*2>;Q REGISTER ARRAY
OFFSET	QPNTR	;COMMAND Q REGISTER OFFSET
OFFSET	QLCMD	;SIZE OF LAST COMMAND

OFFSET	TECOSP	;SP STACK RESET VALUE
OFFSET	TECOPD	;PDL RESET VALUE
OFFSET	SCHBUF	;SEARCH BUFFER POINTER

RWSIZE	=	$$$$$$	;SIZE OF AREA IN BYTES
.SBTTL	SCAN

.CMD.R:	DEC	QZ(F)			;REMOVE LAST CHARACTER
	DEC	QPNTR(F)		; ENTERED INTO COMMAND
	MOV	QZ(F),D		;GET POINTER TO END+1
	ADD	QRSTOR(F),D		; AND MAKE IT ABSOLUTE
	MOV	QPNTR(F),E		;NOW GET SIZE OF THE COMMAND
	RTS	PC			;AND EXIT

.ENABL	LSB

CMDCHR	<'?>				;"?" IS THE TRACE FLIP/FLOP
	COM	TFLG(F)		;SO FILP THE FLOP
2$:	RTS	PC			;AND EXIT

3$:	CMP	(SP),#.CMD.C		;END OF COMMAND; MAIN CALL?
	BNE	4$			;NOPE, SO MUST BE AN ERROR
	CMP	MPDL(F),PDL(F)	;YES, IN MACRO?
	BNE	4$			;NO (OR UNTERMINATED MACRO)
	POP	<SCANP,ITRST,MPDL,QCMND>;YES, RESTORE ALL ITEMS
	MOV	QCMND(F),A		;GET COMMAND Q REG NUMBER
	JSR	PC,SETCMD		;AND (RE)SET COMMAND
SCAN:	MOV	(F),A			;GET CURRENT COMMAND POINTER
	CMP	A,QLENGT(F)		;END OF THIS COMMAND?
	BHIS	3$			;YES, CHECK FOR A MACRO
	ADD	QBASE(F),A		;NO, ADD BASE OF COMMAND Q REG
	ADD	QRSTOR(F),A		;AND MAKE ABSOLUTE POINTER
	MOVB	(A),A			;GET NEXT CHARACTER (LEAVE IT THIS WAY TO PREVENT PROBLEMS)
	INC	(F)			;THEN BUMP POINTER ONE AHEAD
	TST	TFLG(F)		;TRACING?
	BEQ	2$			;NOPE
	JMP	ECHO			;YES, SO ANNOUNCE CHARACTER

4$:	TST	(SP)+			;PURGE THE RETURN ADDRESS
	TST	MPDL(F)		;WITHIN MACRO?
	BNE 5$			;YES
	JSR PC,DISPLAY		;NO, DISPLAY WHAT WE'VE DONE
	BR	.CMD.D			;NOW BACK TO MAIN EDIT LEVEL
5$:	ERROR	UTM,<"UNTERMINATED MACRO">;YES, MUST BE UNTERMINATED
.DSABL	LSB
.SBTTL	COMMAND INPUT
;ALL COMMANDS PREFIXED "CMD" ARE DISPATCHED TO VIA SORT ..CMD

.ENABL	LSB

;SPACE
.CMDSP:	CMP	TEMP(F),#BELL		;PRECEEDED BY A BELL?
	BNE	13$			;NO, SO NORMAL
	JSR	PC,.CMD.R		;REMOVE 1ST BELL AND GET POINTER, COUNT
	BEQ	TECO1			;NOTHING, SO RESTART US (SKIP DISPLAY)
10$:	DEC	E			;ONE LESS IN COUNT NOW
	BMI	11$			;ONLY ONE LINE WAS IN COMMAND
	CMPB	-(D),#LF		;BACKED UP TO A LINE FEED?
	BNE	10$			;NO, KEEP GOING
	INC	D			;YES, SO CORRECT POINTER
11$:	COM	E			;NEGATE AND DECREMENT COUNT
	ADD	QPNTR(F),E		;FORM THE POSITIVE PRINT COUNT
	JSR	PC,PRINT		;PRINT THE LINE
	BR	.CMD.W			;AND CONTINUE

;BELL (^G)
.CMDBL:	MOV	#100000,ERRPOS(F)	;FLAG THIS AS A BELL
	CMP	A,TEMP(F)		;2ND BELL?
	BNE	.CMD.Z			;NOPE, SO NORMAL
	JSR	PC,.CMD.R		;REMOVE 1ST BELL AND GET COUNT
	MOV	E,QLCMD(F)		;NOW SAVE THE COUNT AS LAST COMMAND COUNT
	BR	TECO			;AND RESTART US
;QUESTION MARK
.CMDQM:	MOV	ERRPOS(F),E		;GET ERROR POSITION
	BLE	.CMD.Y			;IF NONE, THEN NORMAL CHARACTER
	JSR PC,TOPDIS		;GET TO TOP OF SCREEN
	MOV	QBASE(F),D		;GET BASE OF LAST COMMAND
	ADD	QRSTOR(F),D		;NOW MAKE POINTER ABSOLUTE
	JSR	PC,PRINT		;AND PRINT THE ERRING LINE
	MOV	#'?,A			;END LINE WITH
	JSR	PC,TYO			; A "?"
	BR	TECO1			;AND RESTART US

;STAR (REFERENCE OF A Q-REGISTER)
.CMDST:	TST	QPNTR(F)		;WAS THIS THE 1ST THING TYPED?
13$:	BNE	.CMD.Y			;NOPE, SO NORMAL
	JSR	PC,LISTEN		;YES, SO GET NEXT AS Q REG NAME
	JSR	PC,.CMD.S		;AND VALIDATE IT AND SUM IT
	MOV	QLCMD(F),A		;GET LAST COMMAND'S SIZE
	ADD	A,QZ(F)		;INCREASE Q REG AREA SIZE BY THAT
	MOV	A,QPNTR(F)		;AND PLACE IT IN COMMAND Q REG
	JSR	PC,QADJ			;NOW ADJUST SELECTED REG TO THAT SIZE
	MOV	C,D			;SAVE OFFSET TO SELECTED Q REG
	MOV	#CMDQRG,A		;NOW SET TO SUM THE
	JSR	PC,QSUMX		; COMMAND Q REG
	ADD	QRSTOR(F),D		;ABS POINTER TO SELECTED Q REG
	ADD	QRSTOR(F),C		;ABS POINTER TO COMMAND Q REG
	MOV	(B),B			;GET SIZE OF DATA TO MOVE
	BEQ	TECO			;MOVE NOTHING?
15$:	MOVB	(C)+,(D)+		;MOVE THE DATA
	SOB B,15$		;THIS MANY TIMES
;FALLS INTO TECO
.DSABL	LSB
.ENABL	LSB
;COMES HERE ONLY ON ENTRY INTO TECO
TECO:	JSR PC,TOPDIS		;GET TO TOP OF SCREEN
	MOV #MSG1,D		;PRINT OUT WELCOME
	MOV #4,E		;LENGTH OF MESSAGE
	JSR PC, PRINT
;THIS IS NORMAL RETURN POINT AFTER EVALUATION OF COMMAND STRING
TECO1:	JSR PC,TTINIT		;SET ALL TTY VARIABLES (THIS IS GLOBAL)
	MOV	TECOSP(F),SP		;SET UP OUR SP STACK
	MOV	TECOPD(F),PDL(F)	;NOW SET UP THE PUSH-DOWN LIST
.CMD.D:	CMP	SP,TECOSP(F)		;IS SP STACK OK?
	BNE	90$			;NOPE
	CMP	PDL(F),TECOPD(F)	;WAS LAST COMMAND UNTERMINATED?
	BNE	90$			;YEP, GO GIVE ERROR
	MOV	#CMDQRG,A		;INDICATE THE COMMAND Q REG
	JSR	PC,QREFA		;REFERENCE IT
	JSR	PC,QADJ			; AND ADJUST TO 0 SIZE
	MOV	F,B			;GET OFFSET POINTER
	ADD	#CLREND,B		;AND INDEX TO CLEAR AREA (+2)
	MOV	#CLREND-CLRSRT/2,C	;LOAD A COUNT OF HOW MANY TO CLEAR
22$:	CLR	-(B)			;NOW CLEAR OUR VARIABLES
	SOB C,22$		;ISN'T THIS A NICE INSTRUCTION?
	JSR	PC,IREST		;RESTORE QUOTE TO 33 (ALTMODE)
.CMD.W:	CLR	TEMP(F)		;AVOID DOUBLE CHARACTER INDICATIONS
.CMD.X:	MOV	ERRPOS(F),A		;SELECT INPUT MODE
	JSR	PC,LISTEN		;AND GET A CHARACTER
	CLR	ROFLAG(F)		;ENABLE WATCH AT NEXT PROMPT
	SORT	..CMD			;SORT OUT SPECIAL CHARACTERS
.CMD.Y:	CLR	ERRPOS(F)		;NO ERROR POSITION IF STORING
.CMD.Z:	CLR	QLCMD(F)		;NO LAST COMMAND IF STORING ANYTHING
	MOV	#.CMD.X,-(SP)		;SET THE RETURN ADDRESS
	MOV	A,TEMP(F)		;SAVE CHARACTER ABOUT TO BE STORED
.CMDAX:	MOV	QZ(F),B		;GET OUR CURRENT SIZE
	MOV	QMAX(F),C		;AND OUR MAXIMUM SIZE
	DEC	C			;ADJUSTED FOR NEW CHARACTER
	CMP	B,C			;CAN WE DO THIS?
	BHIS	91$			;NO, GO GIVE ERROR
	INC	QZ(F)			;INDICATE 1 MORE IN COMMAND
	INC	QPNTR(F)		; Q REGISTER
	ADD	QRSTOR(F),B		;GET POSITION TO STORE IN
	MOVB	A,(B)			;AND STORE CHARACTER
	SUB	QRSTOR(F),B		;BACK TO RELATIVE AGAIN
	ADD	#100.,B		;FUDGE BY 100. MORE CHARACTERS
	SIZE	QREGS			;GET ROOM FOR THOSE CHARACTERS
	BCS	31$			;ALL IS STILL O.K.
	MOV	#BELL,A		;IF NOT, THEN RING THE BELL
	JMP	ECHO			;FOR A WARNING, THEN CONTINUE

90$:	ERROR	UTC,<"UNTERMINATED COMMAND">

91$:	ERROR	MEM,<"MEMORY OVERFLOW">	

;RUBOUT
.CMDRO:	MOV	#23$,-(SP)		;SET RETURN ADDRESS FROM RUBBING OUT
30$:	INC	ROFLAG(F)		;IF IT ALL VANISHES, DO NOT WATCH
	TST	QPNTR(F)		;ANYTHING LEFT TO REMOVE?
	BEQ	TECO1			;NO, SO RESTART US
	JSR	PC,.CMD.R		;REMOVE A CHARACTER AND GET POINTER
	MOVB	(D),A			;TO GET CHARACTER REMOVED
31$:	RTS	PC			;NOW EXIT

;^U DELETES CURRENT COMAND STRING
.CMDCU:	JSR	PC,30$			;REMOVE 1 CHARACTER FROM BUFFER
	CMP	A,#LF			;LINE FEED JUST REMOVED?
	BNE	.CMDCU			;NOPE, KEEP REMOVING
	INC	QZ(F)			;YEP, SO PUT IT
	INC	QPNTR(F)		; BACK IN COMMAND
	BR	.CMD.W			;AND CONTINUE

.DSABL	LSB
.SBTTL	INTERPRETER

.ENABL	LSB

;CONTROL COMES HERE ON RECEPTION OF ALTMODE
.CMDAM:	CMP	A,TEMP(F)		;2ND ALTMODE?
	BNE	.CMD.Y			;NOPE, SO NORMAL CHARACTER
	JSR	PC,.CMDAX		;YES, SO STORE THE FINAL ALTMODE
	MOV	QPNTR(F),QLCMD(F)	; AND SAVE COMMAND AS LAST
	MOV	#CMDQRG,A		;SET UP TO REFERENCE
	JSR	PC,SETCMD		; THE COMMAND REGISTER
40$:	JSR	PC,SCAN			;SCAN THE COMMAND
.CMD.C:	;UPPER CASE CONVERSION DONE BY TTY ROUTINES
42$:	MOV	A,B			;COPY THE CHARACTER
	CLR	A			;LEAVE A (THE AC...) CLEAR
	ASL	B			;WE NEED A WORD INDEX
	JSR	PC,@TECOCH(B)		;DISPTACH TO COMMAND
	TST	NFLG(F)		;NUMBER?
	BMI	40$			;YES, SO JUST CONTINUE
	CLR	N(F)			;NO, SO CLEAR THE ARGUMENT
	CLR	NFLG(F)		;AND RESET NUMBER FLAG
	BR	40$			;AND CONTINUE

CMDCHR	<'^>				;^ MEANS NEXT IS CONTROL/CHARACTER
	TST	(SP)+			;POP THE RETURN ADDRESS
	JSR	PC,SCAN		;AND GET NEXT FORCING UPPER CASE
;SHOULD TELETYPES TAKE CARE OF CNTRL-CHARS?
	BIC	#-77-1,A		;BUT MAKE IT A CONTROL/CHARACTER
	BR	42$			;AND CONTINUE WITH IT

.DSABL	LSB
;THIS IS OBSOLETE AND WILL GO AWAY
CMDCHR	<'W-100>			;CTRL/W IS SCOPE WATCH
	INC	NFLG(F)		;ARGUMENT?
	BNE	1$			;NOPE
	MOV	N(F),NWATCH(F)	;YES, SO GET IT
1$:	MOV	NWATCH(F),A		;GET AMOUNT TO WATCH
	JMP	WATCH			;AND WATCH THE SCOPE

CMDCHR	<'L>				;"L" IS THE LINE MOVER
	JSR	PC,GETN			;GET THE NUMBER OF LINES
.VVV.V:	MOV	TXSTOR(F),C		;GET TEXT POINTER BIAS
	MOV	P(F),B		;GET THE CURRENT .
	ADD	C,B			;AND MAKE THAT ABSOLUTE
	MOV	#LF,D			;SPEED UP THE COMPARES
	TST	A			;WHICH DIRECTION
	BLE	15$			;<=0 IS BACKWARDS
	ADD	ZZ(F),C		;>0 IS FORWARDS; SO GET END OF TEXT
11$:	CMP	B,C			;PAST END OF TEXT YET?
	BHIS	13$			;YES, SO STOP THE MOVE
	CMPB	D,(B)+		;NOPE, IS THIS A LINE FEED?
	BNE	11$			;NO, KEEP MOVING
	SOB A,11$
13$:	SUB	TXSTOR(F),B		;GET THE NEW .
	MOV	B,P(F)		;AND STORE IT
	RTS	PC			;THEN EXIT

15$:	CMP	B,C			;TOO LOW?
	BLOS	13$			;YES, SO QUIT
	CMPB	D,-(B)		;NO, IS IT LINE FEED?
	BNE	15$			;NOPE, KEEP GOING
	INC	A			;YEP, MORE?
	BLE	15$			;STILL ARE MORE TO GO
	INC	B			;DONE, CORRECT .
	BR	13$			;AND GO SET NEW .
.ENABL	LSB

CMDCHR	<LAB>				;"<" STARTS AN ITERATION
.CSMI:	PUSH	<ITRST,ITRCNT>		;SAVE ITERATION START AND COUNT
	MOV	N(F),ITRCNT(F)	;SET THE NEW ITERATION COUNT
	CLR	NFLG(F)		; USING UP THE NUMBER
	MOV	(F),ITRST(F)		;AND SET ITERATION START
	RTS	PC			;NOW EXIT

CMDCHR	<RAB>				;">" ENDS AN ITERATION
	DEC	ITRCNT(F)		;GO AROUND AGAIN?
	BEQ	.CSMO			;YES, SO END US
	MOV	ITRST(F),(F)		;NO, SO RESET SCAN POINTER
	BEQ	90$			;ERROR IF NO PLACE TO RESTART
CMDCHR	<ALTMOD>			;ALTMODES COME HERE
CMDCHR	<''>				;END OF CONDITIONALS COME HERE
5$:	CLR	NFLG(F)		;USE UP ANY NUMBER
	JMP	IREST			;AND RESTORE NORMAL QUOTE

90$:	ERROR	BNI,<<RAB>" NOT IN ITERATION">
CMDCHR	<';>				;";" IS SPECIAL ITERATION END
	MOV	ITRST(F),E		;GET ITERATION START POINTER
	BEQ	91$			;IF ANY...
	INC	NFLG(F)		;ARGUMENT?
	BNE	92$			;GIVE ERROR IF NONE
	TST	N(F)			;SUCCESSFUL?
	BMI	5$			;YES, SO JUST CONTINUE
.SCH.I:	MOV	E,-(SP)		;SAVE ITERATION START POINT
	SKPSET	'>			;GO TO MATCHING >
	MOV TFGTMP(F),TFLG(F)		;THIS WILL GO AWAY
	MOV	(SP)+,E		;RESTORE ITERATION START
	CMP	E,ITRST(F)		;MATCH THIS START?
	BEQ	.CSMO			;YES, SO EXIT
	MOV	#.SCH.I,-(SP)		;NO, SO POP LEVEL AND CONTINUE
.CSMO:	POP	<ITRCNT,ITRST>		;POP THE COUNT AND START
	BR	5$			;GO RESET QUOTE CHARACTER

91$:	ERROR	SNI,<"; NOT IN ITERATION">

92$:	ERROR	NAS,<"NO ARG BEFORE ;">

.DSABL	LSB
CMDCHR	<'M>				;"M" IS THE MACRO COMMAND
	JSR	PC,QREF			;REFERENCE A Q REGISTER
	PUSH	<QCMND,MPDL,ITRST,SCANP>;NOW PUSH ALL OLD DATA
	CLR	(F)			;START MACRO OFF AT RELATIVE 0
	CLR	ITRST(F)		;NOT INTO ANY ITERATION YET
	MOV	PDL(F),MPDL(F)	;SAVE PDL AT MACRO'S START
	MOV	QNMBR(F),A		;THIS IS THE Q REG WITH THE MACRO IN IT
	JMP	SETCMD			;GO OFF AND START THE MACRO

.ENABL	LSB

CMDCHR	<'=>				;"=" IS THE NUMBER PRINTER
	INC	NFLG(F)		;ANY NUMBER?
	BNE	90$			;HE'S IN ERROR IF NOT
	CLR	NMRBAS(F)		;SET RADIX=DECIMAL INITIALLY
	TSTNXT	'=			;IS IT REALLY "=="?
	ADC	NMRBAS(F)		;C=1 IF SO, SET RADIX=OCTAL
;HOW WILL THIS APPEAR ON DISPLAY?
	JSR	E,ZEROD		;THIS DOES THE REAL WORK
	.WORD	TYPE			;OUTPUT TO TERMINAL
;THIS WILL GO AWAY
CRLF:	MOV	#CR,A			;TYO
	JSR	PC,ECHO			; RETURN
	MOV	#LF,A			;  THEN
	JMP	ECHO			;   LINE FEED

90$:	ERROR	NAE,<"NO ARG BEFORE =">

.DSABL	LSB
.ENABL	LSB

CMDCHR	<'\>				;"\" IS NUMBER INSERTER/GETTER
	INC	NFLG(F)		;WAS THERE AN ARGUMENT?
	BNE	2$			;NO, SO GET A NUMBER FROM TEXT
	JSR	E,ZEROD		;YES, SO INSERT IT INTO TEXT
	.WORD	.BSL.I
1$:	RTS	PC			;AND EXIT

2$:	JSR	PC,NCOM			;SET UP NUMBER PROCESSOR
	JSR	PC,GETXTP		;GET CHAR FROM TEXT
	BCC	1$			;NOTHING THERE
	SUB	#'-,A			;MINUS SIGN?
	BNE	3$			;NOPE
	JSR	PC,@'-*2+TECOCH		;YES, SO DO THE MINUS OPERATOR
	BR	4$			;AND CONTINUE

3$:	CMP	A,#'+-'-		;PLUS SIGN?
	BNE	5$			;NOPE
4$:	INC	P(F)			;BUMP .
5$:	JSR	PC,GETXTP		;GET CHARACTER FROM TEXT
	BCC	1$			;EXIT IF NO MORE
	JSR	PC,NUMER		;CHECK FOR NUMERIC
	BCC	1$			;NOT A NUMBER
	MOV	A,B			;MOVE DIGIT OVER TO HERE
	JSR	PC,.BSL.N		;NUMBER, SO USE IT
	BR	4$			;AND CONTINUE

CMDCHR	<'!>				;"!" IS THE COMMENT DELIMITER
	CMP	(A)+,(A)+		;MAKE A = 4 (SKIP 2 WORDS)
CMDCHR	<'A-100>			;CTRL/A IS THE TEST PRINTER
	MOV	A,C			;SAVE DETERMINATION
	CLR	NFLG(F)		;USE UP ANY NUMBER
	MOV	B,E			;GET CHARACTER (*2) THAT CALLED US
	ASR	E			;NOW MAKE NORMAL CHARACTER
10$:	JSR	PC,SCAN			;SCAN TEXT
	CMP	A,E			;END?
	BEQ	1$			;YES, SO EXIT
	ADD	C,PC			;CHECK DETERMINATION
;THIS IS ANOTHER ONE TO BE CONSIDERED
	JSR	PC,TYPE			;CTRL/A CHARS GET TYPED
	BR	10$			;AND LOOP

.DSABL	LSB
.ENABL	LSB

CMDCHR	<'">				;'"' IS THE CONDITIONAL
	INC	NFLG(F)		;ANY ARGUMENT?
	BNE	90$			;THERE HAD BETTER BE
	SORT	..CND,C			;AND SPECIAL SORT
	ERROR	ICC,<'ILLEGAL " CHARACTER'>

90$:	ERROR	NAQ,<'NO ARG BEFORE "'>	;NO

.CNDC:	ADD	#RAD50-NUMER,C		;"C" IS A-Z,0-9,.,$
.CNDD:	ADD	#NUMER-ALPHA,C		;"D" IS 0-9
.CNDA:	ADD	#ALPHA-ALPHAN,C	;"A" IS A-Z
.CNDR:	ADD	#ALPHAN,C		;"R" IS A-Z,0-9
	MOV	D,A			;SET UP TEST CHARACTER
	JSR	PC,(C)			;AND GO CHECK IT
	BCS	4$			;CARRY SET IS SUCCESS
	BR	2$			;ELSE FAILURE

.CNDN:	TST	D			;SET CC'S
	BNE	4$			;"N" IS OK IF <>
	BR	2$			;ELSE NOT OK

.CNDG:	NEG	D			;"G" IS OK IF >
	BVS	2$			;TRAP -32768. CASE
.CNDS:					;"S" IS SUCCESSFUL (-1)
.CNDT:					;"T" IS TRUE (-1)
.CNDL:	TST	D			;SET CC'S
	BPL	2$			;"L" IS NO GOOD IF >=
	BR	4$			;ELSE OK

.CNDF:					;"F" IS FALSE (0)
.CNDU:					;"U" IS UNSUCCESSFUL (0)
.CNDE:	TST	D			;SET CC'S
	BEQ	4$			;"E" IS OK IF =
2$:	MOV	#-1,CNDN(F)		;INTO 1 LEVEL OF CONDITIONAL SKIP
3$:	SKPSET	''			;SKIP TO A '
	MOV TFGTMP(F),TFLG(F)		;THIS WILL GO AWAY
	INC	CNDN(F)		;DID IT MATCH OUR "?
	BNE	3$			;NO, SKIPSOME MORE
4$:	JMP	IREST			;YES, RESTORE QUOTE AND EXIT

.DSABL	LSB
;WHAT EXACTLY DOES THIS DO?
CMDCHR	<'O>
	MOV	(F),-(SP)		;SAVE CURRENT POINTER
	CLR	NFLG(F)		;USE UP ANY NUMBER
	CLR	QFLG(F)		;AND USE ALTMODE AS QUOTE
	JSR	PC,QSKP			;SKIP THE QUOTED STRING
	MOV	ITRST(F),(F)		;START SEARCH AT ITERATION START
1$:	SKPSET	'!			;SKIP UNTIL A !
	JSR	PC,ENTRCE		;REENABLE TRACE
	MOV	(SP),E			;GET BACK THE TAG'S START
	ADD	QBASE(F),E		;AND ADDIN Q REG OFFSET
	ADD	QRSTOR(F),E		;THEN MAKE ABSOLUTE
2$:	JSR	PC,SCAN			;SCAN THE FOUND TAG
	CMP	A,#'!			;END OF TAG?
	BEQ	4$			;YES
	CMPB	A,(E)+		;NO, MATCH?
	BEQ	2$			;CONTINUE UNTIL END IF MATCH
3$:	JSR	PC,SCAN			;SCAN FOR TAG'S END IF NO MATCH
	CMP	A,#'!			;END OF TAG?
	BNE	3$			;NOT YET...
	BR	1$			;YES, SO FIND NEXT TAG

4$:	CMPB	(E)+,#ALTMOD		;BOTH ENDS MATCH?
	BNE	1$			;NOPE, SO FIND NEXT TAG
	TST	(SP)+			;YES, SO DUMP SAVED TAG POINTER
	RTS	PC			;AND EXIT

CMDCHR	<':>				;":" IS THE SEARCH MODIFIER
	MOV	#-1,CLNF(F)		;SET COLON FLAG
	TSTNXT	':			;DOUBLE COLON?
	SBC	CLNF(F)		;YES MEANS FLAG=-2
	RTS	PC			;AND EXIT
.ENABL	LSB

CMDCHR	<'U-100>			;CTRL/U IS Q REG TEXT INSERT
	JSR	PC,QREF			;REFERENCE THE Q REG
	JSR	PC,QSKP			;NOW SKIP THE QUOTED STRING
	MOV	(F),A			;GET SCAN POINTER
	DEC	A			;LESS 1 FOR QUOTE CHAR
	SUB	OSCANP(F),A		;NOW HAVE LENGTH
	JSR	PC,QADJX		;ADJUST Q REG TO ITS NEW SIZE
	CLR	NFLG(F)		;USE UP ANY NUMBER
	MOV	OSCANP(F),A		;GET INSERT STRING START
	ADD	QBASE(F),A		;AND ADD IN OFFSET
	ADD	QRSTOR(F),A		;NOW MAKE IT ABSOLUTE
	BR	15$			;AND GO INSERT IT IN Q REG

CMDCHR	<'U>				;"U" IS Q REG NUMBER SETTER
	JSR	PC,QREF			;REFERENCE THE Q REG
	INC	NFLG(F)		;ANY NUMBER?
	BNE	90$			;THERE MUST BE
	TST	(B)+			;SKIP THE SIZE
	MOV	N(F),(B)		;AND SET THE NUMBER
	RTS	PC			;THEN EXIT

90$:	ERROR	NAU,<"NO ARG BEFORE U">	;NOPE
CMDCHR	<'X>				;"X" IS Q REG TEXT INSERT
	JSR	PC,QREF			;REFERENCE THE Q REG
	JSR	PC,NLINES		;GET NUMBER OF CHARACTERS
	JSR	PC,QADJX		;ADJUST Q REG TO ITS NEW SIZE
	MOV	M(F),A		;GET START OF TEXT
	ADD	TXSTOR(F),A		;AND MAKE IT ABSOLUTE
15$:	ADD	QRSTOR(F),C		;MAKE POINTER TO Q REG ABSOLUTE
	MOV	(B),B			;NOW GET SIZE OF Q REG
	BEQ	21$			;NO SIZE IS FAST EXIT
20$:	MOVB	(A)+,(C)+		;ELSE MOVE BYTES INTO Q REG
	SOB B,20$
21$:	JMP	IREST			;RESTORE THE ALTMODE AS QUOTE

.DSABL	LSB
.ENABL	LSB

CMDCHR	<'F>				;"F" IS PREFIX FOR SPECIAL SEARCHES
	SORT	..FFF,S			;AND SORT ON IT
	ERROR	IFC,<"ILLEGAL F CHARACTER">

CMDCHR	<'R-100>			;CTRL/R IS STRING REPLACEMENT
.FFFS:	MOV	#-1,REPFLG(F)		;SET REPLACE FLAG
CMDCHR	<'S>				;"S" IS SEARCH
	JSR	PC,SEARCH		;SEARCH FOR THE STRING
1$:	TST	REPFLG(F)		;REPLACEMENT?
	BEQ	3$			;NOPE
	MOVB	B,-(SP)		;YES, SO SAVE SUCCESS/FAILURE FLAG
	JSR	PC,QSKP			;AND SKIP THE 2ND STRING
	MOVB	(SP)+,B		;RESTORE SUCCESS/FAILURE FLAG
	BEQ	2$			;NO REPLACEMENT IF FAILURE
	MOV	PST(F),A		;GET START OF FOUND STRING
	SUB	P(F),A		;AND NOW ITS -(LENGTH)
	MOV	PST(F),P(F)		;THEN UPDATE .
	JSR	PC,.SCH.R		;DO REPLACEMENT
	MOV	#-1,B			;RESTORE SUCCESS FLAG
2$:	CLR	REPFLG(F)		;CLEAR REPLACE FLAG
3$:	MOVB	B,A			;GET REAL NUMBER IN A
	JSR	PC,NCOM			;INIT THE NUMBER PROCESSOR
	TST	CLNF(F)		;WAS THERE A ":" THERE?
	BMI	10$			;YES, SO JUST RETURN FLAG
	CLR	CLNF(F)		;ELSE SET FLAG TO FALSE
	MOV	ITRST(F),E		;IN AN ITERATION?
	BEQ	4$			;NOPE
	TST	N(F)			;YES, SEARCH SUCCEED?
	BMI	10$			;IF SO, PRETEND WE SAW A ":"
	TSTNXT	<';>			;IS SEARCH CHECKED FOR?
	BCS	9$			;YES, SO RETURN VALUE
.IF	NE	ERRTXT
	JSR	PC,NOCTLO		;CANCEL ANY CTRL/O
	MESSAG	<<CR><12>"SRCH FAIL IN ITER"<CR><LF>>
	MOV	#$$$$$$,D		;GET MESSAGE POINTER
.CSECT	TECOER
.	=	.-1			;BACK OVER ZERO BYTE
$$$$$$	=	.-$$$$$$
.CSECT	TECORO
	MOV	#$$$$$$,E		;GET MESSAGE SIZE
	JSR	PC,PRINT		;SO WE CAN PRINT A WARNING
.ENDC
	MOV	ITRST(F),E		;RESTORE ITERATION START
	JMP	.SCH.I			;ELSE GET OUT OF ITERATION
4$:	CLR	NFLG(F)		;USE UP THE NUMBER
	TST	N(F)			;SUCCESSFUL?
	BPL	5$			;NOPE
	MOV	ESFLAG(F),E		;YES, GET EDIT SEARCH FLAG
	BEQ	10$			;=0, SO EXIT
	JMP	.SCH.V			;ELSE GO PRINT SOMETHING

5$:	ERROR	SRH,<%SEARCH FAILURE FOR "%<-1>%"%>

9$:	DEC	(F)			;MAKE SURE WE SEE THE ";"
10$:	CLR	CLNF(F)		;CLEAR COLON FLAG
	JMP	IREST			;RESTORE QUOTE AND EXIT
.FFFN:	CLR	A			;INSURE "N" TYPE SEARCH
	MOV	#-1,REPFLG(F)		;AND DO A REPLACE
	BR	17$			;NOW JOIN UP

CMDCHR	<'_>				;"_" IS DESTRUCTIVE SEARCH
	MOV	#21$-20$,A		;SET TO SKIP BUFFER DUMP
CMDCHR	<'N>				;"N" IS THE PAGING SEARCH
17$:	MOV	A,TEMP(F)		;SAVE DETERMINATION
	JSR	PC,SEARCH		;AND SEARCH
18$:	BMI	1$			;SUCCESS(-1) OR BACKWARDS FAIL(177400)
19$:	MOV	C,-(SP)		;SAVE THE SEARCH COUNTER
	ADD	TEMP(F),PC		;CHECK DETERMINATION
20$:	MOV	TXSTOR(F),A		;GET BUFFER START
	MOV	ZZ(F),B		; AND ITS LENGTH
	MOV	FFFLAG(F),C		;  AND FORM FEED FLAG
	JSR	PC,PUTBUF		;PUT OUT THE BUFFER
	BCS	IO.ERR			;ERROR FROM 'TECOIO'
21$:	JSR	PC,@'Y*2+TECOCH		;NOW YANK IN A PAGE OF TEXT
	MOV	(SP)+,C		;RESTORE SEARCH COUNTER
	TST	ZZ(F)			;ANYTHING WORTH SEARCHING FOR?
	BNE	22$			;YES, SO SEARCH SOME MORE
	TST	FFFLAG(F)		;NOPE, IS THIS IS TRUE NULL PAGE?
	BNE	19$			;DON'T BOTHER TO SEARCH NULL
	CLR	B			;IF REAL END, THEN SIGNAL
	BR	1$			; FAILURE, AND QUIT

22$:	JSR	PC,.SURCH		;CONTINUE SEARCHING
	BR	18$			;NOW CHECK FOR FAILURE

.DSABL	LSB

.FFFR:	JSR	PC,QSKP			;SKIP THE INSERT STRING
	MOV	LSCHSZ(F),A		;GET -(LENGTH) OF LAST FOUND STRING
	JSR	PC,.FFF.R		;AND BACK UP . TO THERE
	MOV	LSCHSZ(F),A		;GET -(LENGTH) AGAIN
	BR	.SCH.R			;AND DO THE INSERT

CMDCHR	<'G>				;"G" IS GET Q REG INTO TEXT
	JSR	PC,QREF			;REFERENCE THE Q REG
	CLR	NFLG(F)		;USE UP ANY NUMBER
	MOV	C,-(SP)		;SAVE OFFSET TO Q REG
	MOV	(B),A			;AND GET Q REG'S SIZE
	MOV	A,-(SP)		;SAVE INSERT LENGTH
	COM	(SP)			;MAKE IT -(LENGTH)-1
	BR	.GGG.I			;NOW REALLY INSERT IT
.ENABL	LSB

CMDCHR	<'I>				;"I" IS INSERT TEXT
	INC	NFLG(F)		;NUMBER TO INSERT?
	BNE	1$			;NOPE
	TSTNXT	ALTMOD			;MUST HAVE AN ALTMODE AFTER IT
	BCC	1$			;NONE, SO REGULAR INSERT
	MOV	N(F),A		;YES, SO GET THE NUMBER
.BSL.I:	BIC	#-177-1,A		;MAKE INTO A VALID CHARACTER
	MOV	A,-(SP)		;AND SAVE IT
	MOV	#1,A			;ADJUST TEXT UP BY
	JSR	PC,ADJ			; 1 CHARACTER
	MOV	P(F),B		;GET .
	ADD	TXSTOR(F),B		;MAKE ABSOLUTE
	MOVB	(SP)+,(B)		;AND STORE NEW CHARACTER
	INC	P(F)			;BUMP .
	RTS	PC			;AND EXIT

CMDCHR	<'I-100>			;TAB IS SPECIAL FORM OF "I"
	CLR	QFLG(F)		;INSURE NO QUOTE SPECIALS
	DEC	(F)			;AND INCLUDE THE TAB IN TEXT
1$:	JSR	PC,QSKP			;SKIP THE QUOTED STRING
	CLR	A			;AND INDICATE NO BIAS
.SCH.R:	MOV	OSCANP(F),D		;GET STRING START
	MOV	D,-(SP)		;AND SAVE START
	ADD	QBASE(F),(SP)		;START NOW REAL
	SUB	(F),D			;NOW HAVE -(LENGTH)-1
	SUB	D,A			;NOW HAVE (LENGTH)+1+(BIAS)
	DEC	A			;NOW HAVE (LENGTH)+(BIAS)
	MOV	D,-(SP)		;SAVE INSERT -(LENGTH)-1
.GGG.I:	JSR	PC,ADJ			;ADJUST TEXT BUFFER SIZE
	MOV	(SP)+,D		;RESTORE INSERT -(LENGTH)-1
	MOV	D,LSCHSZ(F)		;SAVE TEXTUAL LENGTH
	INC	LSCHSZ(F)		;  AS -(LENGTH)
	MOV	(SP)+,C		; AND START
	ADD	QRSTOR(F),C		;MAKE THE START ABSOLUTE
	MOV	P(F),B		;GET .
	ADD	TXSTOR(F),B		;AND MAKE . ABSOLUTE ALSO
	BR	20$			;ENTER INSERT LOOP

10$:	MOVB	(C)+,(B)+		;INSERT A BYTE
20$:	INC	D			;DONE?
	BLT	10$			;NOPE
	SUB	TXSTOR(F),B		;MAKE NEW . RELATIVE
	MOV	B,P(F)		;AND SET THE NEW .
	JMP	IREST			;RESTORE QUOTE AS ALTMODE AND EXIT

.DSABL	LSB
.ENABL	LSB

CMDCHR	<'P>				;"P" IS PAGE WRITER
.SBTTL	COMMAND CHARACTER "PW
	TSTNXT	'W			;REALLY "PW"?
	ROR	-(SP)			;SAVE THE DETERMINATION
	TST	CFLG(F)		;M,N??
	BMI	30$			;YES
	JSR	PC,GETN			;NOPE, GET A NUMBER
	MOV	A,E			;AND SAVE IT
5$:	MOV	TXSTOR(F),A		;WRITE FROM HERE
	MOV	ZZ(F),B		; AND WRITE THIS MUCH
	BEQ	10$			; (UNLESS THAT IS ZERO...)
	MOV	FFFLAG(F),C		;  AND WRITE WITH OPTIONAL FORM FEED
	TST	(SP)			;"P" OR "PW" COMMAND?
	BPL	6$			;IF "P", THEN FORM FEED IS OPTIONAL
	MOV	#-1,C			;IF "PW", THEN ALWAYS A FORM FEED
6$:	JSR	PC,PUTBUF		;DUMP THE BUFFER
IO.ERR:	BCS	IOERR			;ERROR FROM 'TECOIO'
10$:	TST	(SP)			;"PW"?
	BMI	22$			;YES, SO NO YANK
	JSR	PC,@'Y*2+TECOCH		;SIMULATE THE YANK
22$:	DEC	E			;AGAIN?
	BGT	5$			;YES
25$:	TST	(SP)+			;DUMP "PW" DETERMINATION
	RTS	PC			;NO, EXIT

30$:	JSR	PC,NLINES		;MAKE M,N INTO CHARACTERS
	MOV	A,B			;COUNT GOES HERE
	MOV	M(F),A		;START FROM HERE
	ADD	TXSTOR(F),A		; MAKE IT ABSOLUTE
	CLR	C			;NEVER A FORM FEED
	JSR	PC,PUTBUF		;AND PUT IT
	BCC	25$			;EXIT IF NO ERROR
IOERR:					;I/O ERRORS COME HERE
.IF	NE	ERRTXT
	MOV	C,-(SP)		;SAVE TEXT POINTER IF ANY
.ENDC
	JMP	ERRMIO			;AND CALL ERROR PROCESSOR

.DSABL	LSB
.ENABL	LSB

CMDCHR	<'A>				;"A" IS APPEND
	INC	NFLG(F)		;UNLESS THERE IS A NUMBER
	BNE	10$			;AND THERE IS NOT
	MOV	N(F),A		;GET THE NUMBER
	ADD	P(F),A		;INDEXED BY .
	JSR	PC,BZCHK		;CHECK IT
	ADD	TXSTOR(F),A		;THEN MAKE IT ABSOLUTE
	MOVB	(A),A			;AND GET THE CHARACTER
	JMP	NCOM			;AND COMPUTE AS IF NUMBER

CMDCHR	<'Y>				;"Y" IS YANK IN A BUFFER
	CLR	NFLG(F)		;USE UP A NUMBER
	CLR	P(F)			;AND ERASE THE
	CLR	ZZ(F)			; OLD BUFFER
10$:	MOV	ZZ(F),A		;GET END OF CURRENT BUFFER
	MOV	A,B			;AND SAVE IT
	ADD	#128.,B		;INCREASE IT BY 128. CHARS
	SIZE	TEXT			;ADJUST AND SEE IF O.K.
	BCC	12$			;WON'T FIT AT ALL
	MOV	ZMAX(F),B		;GET MAX SIZE
	DEC	B			;LESS 1 FOR SAFETY
	SUB	A,B			;FIND REAL ROOM LEFT
	ADD	TXSTOR(F),A		;MAKE POINTER ABSOLUTE
	JSR	PC,GETBUF		;GET GET SOME DATA
	BCS	IOERR			;ERROR
	ADD	B,ZZ(F)		;INCREASE DATA SIZE IN BUFFER
	MOV	C,FFFLAG(F)		;AND SAVE FORM FEED FLAG
	BNE	12$			;IF FORM FEED FOUND, THEN EXIT
	TST	EOFLAG(F)		;ELSE WAS END-OF-FILE FOUND?
	BEQ	10$			;IF NOT, THEN EXPAND AND TRY AGAIN
12$:	RTS	PC			;NOW EXIT

.DSABL	LSB
.ENABL	LSB

CMDCHR	<'E>				;"E" IS SPECIAL COMMANDS
	MOV	NFLG(F),C		;SAVE THE NUMBER FLAG
	CLR	NFLG(F)		;NO NUMBER
	SORT	..EEE,S			;AND SORT
	ERROR	IEC,<"ILLEGAL E CHARACTER">

.EEEB:					;A GETS <0 FOR EB
.EEER:					;A GETS =0 FOR ER
.EEEW:	SUB	#'R,A			;A GETS >0 FOR EW
	MOV	A,-(SP)		;SAVE DETERMINATION
	JSR	PC,QSKP			;AND SKIP QUOTED STRING
	MOV	OSCANP(F),A		;GET STRING START
	MOV	A,E			;SAVE START
	SUB	(F),E			;FIND -(LENGTH)-1
	COM	E			;NOW HAVE LENGTH
	ADD	QBASE(F),A		;ADD OFFSET TO START
	ADD	QRSTOR(F),A		;AND MAKE ABSOLUTE
	MOV	(SP)+,B		;RESTORE DETERMINATION
DOCCL:	MOV	A,TEMP(F)		;THEN SAVE START FOR ERRORS
	JSR	PC,GETFLS		;AND DO THE CORRECT THING
5$:	BCS	IOERR			;ERROR
	JMP	IREST			;RESTORE QUOTE AND EXIT

.EEEX:	MOV	#TEXIT,-(SP)		;EXIT FROM TECO SOON
	BR	7$			;AFTER FINISHING UP

;THIS IS NO LONGER NEEDED
.EEEG:	MOV	#TEXIT,-(SP)		;EXIT FROM TECO SOON
7$:	JSR	PC,XITNOW		;WE WILL BE EXITING SOON
	BR	15$			;NOW FINISH UP
10$:	MOV	ZMAX(F),B		;GET BUFFER SIZE
	DEC	B			;LESS 1 FOR SAFETY
	JSR	PC,GETBUF		;NOW DO THE INPUT
	BCC	12$			;ALL OK
	CMP	A,#NI			;NO INPUT?
	BNE	IOERR			;NO, REAL ERROR
.EEEF:	JSR	PC,CLSFIL		;CLOSE THE OUTPUT FILE
	BR	5$			;AND ERROR CHECK

12$:	MOV	C,FFFLAG(F)		;SAVE FORM FEED FLAG
	MOV	B,ZZ(F)		;AND DATA SIZE
	BNE	15$			;CONTINUE IF GET SOMETHING
	TST	C			;NULL TYPE PAGE?
	BEQ	.EEEF			;NOPE, TRUE END OF FILE
15$:	MOV	TXSTOR(F),A		;FROM BEGINNING
	MOV	ZZ(F),B		; TO END
	MOV	FFFLAG(F),C		;  WITH OPTIONAL FORM FEED
	JSR	PC,PUTBUF		;WRITE BUFFER
	BCC	10$			;AROUND AGAIN
	CMP	A,#NO			;NO OUTPUT?
	BNE	IOERR			;NO, REAL ERROR
	RTS	PC			;YES, SO QUIT

.EEEP:	JSR	PC,INPSAV		;SAVE INPUT FILE STATUS
	BR	5$			;AND ERROR CHECK

.EEEA:	JSR	PC,OUTSAV		;SAVE OUTPUT FILE STATUS
	BR	5$			;AND ERROR CHECK

.EEEC:	JSR	PC,15$			;PAGE OUT THE REST OF THE FILE
	CLR	ZZ(F)			;NOW CLEAR TEXT BUFFER
	CLR	FFFLAG(F)		;AND SAY NO FORM FEED IN BUFFER
	RTS	PC			;NOW EXIT

.DSABL	LSB
.SCH.V:	JSR	PC,IREST		;RESTORE QUOTE CHARACTER
	MOV	E,A			;AND LOAD TYPEOUT FLAG
CMDCHR	<'V>				;"V" IS VERIFY (0TT)
	CLR	NFLG(F)		;USE UP ANY NUMBER
	MOV	A,-(SP)		;SAVE TYPEOUT DETERMINATION
	MOV	P(F),E		;SAVE .
	CLR	A			;SET UP FOR THE
	JSR	PC,.VVV.V		; "0L"
	MOV	E,P(F)		;RESTORE THE REAL .
	MOV	(SP)+,D		;AND RESTORE TYPE OUT FLAG
	BLE	1$			;NOTHING SPECIAL
	CMP	D,#SPACE		;USE LINE FEED?
	BHIS	1$			;NOPE
	MOV	#LF,D			;YES
1$:	MOV	TXSTOR(F),C		;GET TEXT AREA BIAS
	ADD	C,B			;MAKE "0L" TYPE . ABSOLUTE
	ADD	C,E			;MAKE REAL . ABSOLUTE
	ADD	ZZ(F),C		;AND GET ABSOLUTE END OF TEXT
10$:	CMP	B,C			;END OF TEXT?
	BHIS	20$			;YES, SO QUIT
	CMP	B,E			;NOPE, AT .?
	BNE	15$			;NO AGAIN, SO NORMAL
	MOV	D,A			;GET TYPEOUT FLAG
	BLE	15$			;NOTHING TO DO
;PROBABLY NEEDS TO BE PUT AT SCREEN TOP FIRST
	JSR	PC,ECHO			;ELSE TYPE IT
15$:	MOVB	(B)+,A		;GET A CHARACTER
	JSR	PC,ECHO			;AND TYPE IT
	CMP	A,#LF			;END OF LINE?
	BNE	10$			;NOPE
20$:	RTS	PC			;YES, EXIT

CMDCHR	<'T>				;"T" IS THE PRINTER
	JSR	PC,NLINES		;FIND NUMBER OF CHARACTERS
1$:	MOV	M(F),D		;GET STARTING POINT
	ADD	TXSTOR(F),D		;AND MAKE ABSOLUTE
	MOV	A,E			;MOVE COUNT INTO HERE
	JMP	PRINT			;AND PRINT IT
CMDCHR	<'O-100>			;CTRL/O MEANS OCTAL RADIX
	INC	A			;MAKE A NON-ZERO
CMDCHR	<'D-100>			;CTRL/D MEANS DECIMAL RADIX
	MOV	A,NMRBAS(F)		;SET THE RADIX
	RTS	PC

ERROR:	ERROR	ILL,<"ILLEGAL COMMAND">	;ILLEGAL COMMANDS COME HERE
.ENABL	LSB

CMDCHR	<'N-100>			;CTRL/N IS EOF FLAG
	MOV	EOFLAG(F),A		;GET END-OF-FILE FLAG
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<'B-100>			;CTRL/B IS TODAY'S DATE
	JSR	PC,DATE			;GET DATE
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<'S-100>			;CTRL/S IS -(LENGTH) OF LAST STRING
	MOV	LSCHSZ(F),A		;GET -(LENGTH) OF LAST
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<'F-100>			;CTRL/F IS SWITCH REGISTER VALUE
	JSR	PC,SWITCH		;GET SWITCH REGISTER
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<'H-100>			;CTRL/H IS TIME OF DAY
	JSR	PC,TIME			;GET TIME OF DAY
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<'H>				;"H" MEANS ALL (0,Z)
	CLR	N(F)			;SIMULATE THE "B" (OR 0)
	JSR	PC,1$			;NOW SIMULATE THE COMMA
CMDCHR	<'Z>				;"Z" MEANS END OF TEXT
	MOV	ZZ(F),A		;GET END OF TEXT VALUE
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<'.>				;"." IS CURRENT POSITION
	MOV	P(F),A		;GET .
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<',>				;"," IS THE M,N SEPARATOR
	INC	NFLG(F)		;WAS THERE A "M"?
	BNE	90$			;THERE SHOULD HAVE BEEN
1$:	MOV	N(F),M(F)		;SAVE "M"
	CLR	N(F)			;NOW CLEAR "N" AGAIN
	MOV	#-1,CFLG(F)		;AND INDICATE A COMMA
CMDCHR	<NULL>				;IGNORE NULLS
CMDCHR	<LF>				;IGNORE LINE FEED
CMDCHR	<VT>				;IGNORE VERTICAL TAB
CMDCHR	<FF>				;IGNORE FORM FEED
CMDCHR	<CR>				;IGNORE CARRIAGE RETURN
CMDCHR	<SPACE>				;IGNORE SPACE(S)
	RTS	PC			;NOW RETURN

90$:	ERROR	NAC,<"NO ARG BEFORE ,">	;NO
CMDCHR	<'T-100>			;CTRL/T MEANS VALUE OF NEXT INPUT CHARACTER
	MOV	SP,A			;SINGLE CHARACTER MODE
	JSR	PC,LISTEN		;GET A CHARACTER
	BR	3$			;AND COMPUTE AS A NUMBER

CMDCHR	<'^-100>			;CTRL/^ MEANS VALUE OF NEXT CHARACTER
	JSR	PC,SCAN			;GET NEXT CHARACTER
3$:	BR	NCOM			;AND COMPUTE AS A NUMBER

CMDCHR	<'V-100>			;CTRL/V MEANS VERSION NUMBER
	MOV	#VERSON,A		;GET VERSION NUMBER
	BR	NCOM			;AND COMPUTE AS A NUMBER

CMDCHR	<'Z-100>			;CTRL/Z MEANS SIZE OF Q REGS
	MOV	QZ(F),A		;GET SIZE OF Q REGS
	BR	NCOM			;AND COMPUTE AS A NUMBER

CMDCHR	<'E-100>			;CTRL/E MEANS FORM FEED FLAG
	MOV	FFFLAG(F),A		;GET FORM FEED FLAG VALUE
	BR	NCOM			;AND COMPUTE AS A NUMBER

CMDCHR	<'Q>				;"Q" IS VALUE IN Q REGISTER
	JSR	PC,QREF			;REFERENCE Q REG AS SPECIFIED
	BR	2$			;NOW GET ITS VALUE

CMDCHR	<'%>				;"%" IS ADD TO Q REG VALUE
	JSR	PC,QREF			;REFERENCE Q REG AS SPECIFIED
	JSR	PC,GETN			;GET THE NUMBER ALSO
2$:	TST	(B)+			;SKIP THE OFFSET WORD
	ADD	(B),A			;AND ADD FOR A NEW VALUE
	MOV	A,(B)			;THEN STORE IT AWAY
	BR	NCOM			;AND COMPUTE AS A NUMBER

CMDCHR	<'&>				;"&" IS LOGICAL 'AND'
	MOV	#OP$AND-OP$OR,A	;SET FOR 'AND'
CMDCHR	<'#>				;"#" IS LOGICAL OR
	ADD	#OP$OR-OP$DIV,A	;SET FOR 'OR'
CMDCHR	<'/>				;"/" IS DIVISION
	ADD	#OP$DIV-OP$MUL,A	;SET FOR DIVIDE
CMDCHR	<'*>				;"*" IS MULTIPLICATION
	ADD	#OP$MUL-OP$SUB,A	;SET FOR MULTIPLY
CMDCHR	<'->				;"-" IS SUBTRACTION
	TST	(A)+			;SET FOR SUBTRACT
CMDCHR	<'+>				;"+" IS ADDITION
9$:	MOV	A,NOPR(F)		;SAVE THE OPERATOR DISPTACH
	MOV	N(F),NACC(F)		;SAVE CURRENT NUMBER IN ACCULMULATOR
	CLR	NP(F)			;NO DIGITS FOUND NOW
	MOV	#-1,OFLG(F)		;INDICATE OPERATOR PENDING
	CLR	NFLG(F)		;BUT NO NUMBER PENDING
	RTS	PC			;AND RETURN
CMDCHR	<'(>				;"(" IS START OF NEW EXPRESSION
	TST	OFLG(F)		;OPERATOR PENDING?
	BNE	10$			;YES
	JSR	PC,NCOM			;NO, INITIALIZE US
10$:	PUSH	<NACC,NOPR>		;SAVE ACCULMULATOR
	BR	9$			;THEN SET UP AS IF "+"

.DSABL	LSB

.ENABL	LSB

CMDCHR	<')>				;")" IS END OF EXPRESSION
	TST	NFLG(F)		;ANYTHING BEFORE THIS?
	BPL	90$			;BADNESS IF NOT
	POP	<NOPR,NACC>		;RESTORE OPERATOR
	MOV	N(F),A		;GET VALUE INSIDE PARENS
	BR	20$			;AND TREAT AS A NUMBER

90$:	ERROR	NAP,<"NO ARG BEFORE )">
CMDCHR	<'0>				;THE DIGITS
CMDCHR	<'1>
CMDCHR	<'2>
CMDCHR	<'3>
CMDCHR	<'4>
CMDCHR	<'5>
CMDCHR	<'6>
CMDCHR	<'7>
CMDCHR	<'8>
CMDCHR	<'9>
	ASR	B			;FORM NON-WORD-INDEX FROM CHARACTER
.BSL.N:	SUB	#'0,B			;AND MAKE INTO BINARY DIGIT
	INC	NFLG(F)		;ANY DIGIT BEFORE THIS?
	BNE	31$			;NO, SO INITIALIZE US
	MOV	NP(F),A		;YES, SO GET OLD NUMBER
	ASL	A			;TIMES 2
	ASL	A			;TIMES 4 NOW
	TST	NMRBAS(F)		;RADIX?
	BNE	21$			;OCTAL
	ADD	NP(F),A		;DECIMAL
21$:	ASL	A			;TIMES 8. OR 10. BY NOW
	ADD	B,A			;AND ADD IN NEW DIGIT
	MOV	A,NP(F)		;SAVE THE NUMBER
20$:	ADD	NOPR(F),PC		;DISPATCH ON OPERATOR
	BR	23$			;+
OP$SUB:	NEG	A			;-
23$:	ADD	NACC(F),A		;FORM RESULT
30$:	MOV	A,N(F)		;SAVE THE RESULT
	MOV	#-1,NFLG(F)		;AND INDICATE A NUMBER
	CLR	OFLG(F)		;BUT NO OPERATOR
	RTS	PC			;THEN EXIT

31$:	MOV	B,A			;COPY FIRST DIGIT
	MOV	B,NP(F)		;SAVE IT IN NUMBER ACCUMULATOR
	BR	32$			;ENTER PROCESSING
CMDCHR	<'B>				;"B" IS ZERO
NCOM:	CLR	NP(F)			;USUALLY WE SET NP TO 0
32$:	TST	OFLG(F)		;OPERATOR?
	BNE	20$			;YES
	CLR	NACC(F)		;NO, SO INITIALIZE US
	CLR	NOPR(F)
	BR	20$			;AND CONTINUE
OP$AND:	MOV	NACC(F),B		;GET MASK
	COM	B			;MAKE INTO AN 'AND' MASK
	BIC	B,A			;AND DO THE 'AND'
	BR	30$

OP$OR:	BIS	NACC(F),A		;DO THE 'OR'
	BR	30$

OP$MUL:	MOV NACC(F),B		;GET THAT NUMBER
	MUL A,B		;THAT WAS EASY
	BR 30$

OP$DIV:	MOV	A,C			;SET THE DIVISOR
	MOV	NACC(F),A		;AND THE DIVIDEND
	MOV	#30$,-(SP)		;STACK RETURN ADDRESS
DIVD:	CLR	B			;CLEAR THE REMAINDER
	DIV C,A
	RTS	PC			;NO, EXIT

.DSABL	LSB

CMDCHR	<'_-100>			;THE COMPLEMENT OPERATOR (UNARY)
	TST	NFLG(F)		;IS THERE A NUMBER?
	BPL	90$			;THERE SHOULD HAVE BEEN
	COM	N(F)			;DO A COMPLEMENT
	RTS	PC			;AND LEAVE

90$:	ERROR	NAB,<"NO ARG BEFORE "<'_-100>>
.ENABL	LSB

.EEET:	MOV	#ETYPE,A		;"ET" IS EDIT TYPEOUT
	BR	1$			;GO TO COMMON CODE

.EEEH:	MOV	#EHELP,A		;"EH" IS EDIT HELP
	BR	1$			;GO TO COMMON CODE

.EEES:	MOV	#ESFLAG,A		;"ES" IS EDIT SEARCH
1$:	ADD	F,A			;MAKE POINTER ABSOLUTE
	INC	C			;ARGUMENT?
	BEQ	2$			;YES
	MOV	(A),A			;NO, RETURN VALUE
	BR	NCOM			;AND COMPUTE AS A NUMBER

2$:	MOV	N(F),(A)		;SET THE NEW VALUE
	RTS	PC			;AND EXIT

.DSABL	LSB
.ENABL	LSB

CMDCHR	<'J>				;"J" IS MOVE POINTER
	CLR	NFLG(F)		;USE UP THE NUMBER
	MOV	N(F),A		;NOW GET THE NUMBER
	BR	2$			;AND GO SET .

CMDCHR	<'R>				;"R" IS MOVE POINTER CHARACTERS
	JSR	PC,GETN			;GET THE NUMBER OF CHARACTERS
	NEG	A			;THIS IS THE REVERSE MOVE
	BR	.FFF.R			;GO JOIN COMMON CODE

CMDCHR	<'C>				;"C" IS MOVE POINTER CHARACTERS
	JSR	PC,GETN			;GET THE NUMBER OF CHARACTERS
.FFF.R:	ADD	P(F),A		;CALCULATE NEW .
2$:	JSR	PC,BZCHK		;CHECK FOR VALIDITY
	MOV	A,P(F)		;SET NEW .
	RTS	PC			;AND EXIT

CMDCHR	<'D>				;"D" IS DELETE CHARACTERS
	TST	CFLG(F)		;IS FORM M,ND ?
	BMI	10$			;YES, SO PRETEND IT IS M,NK
	JSR	PC,GETN			;GET THE NUMBER OF CHARACTERS
	MOV	A,B			;AND SAVE THAT NUMBER
	BPL	20$			;>0 IS FORWARD DELETE
;THERE SEEMS TO BE TROUBLE HERE
	JSR	PC,.FFF.R		;<0 IS BACKWARD (-ND = -NC ND)
	MOV	B,A			;RESTORE THE DELETE COUNT
	BR	ADJ			;NOW DELETE

CMDCHR	<'K>				;"K" IS THE LINE DELETER
10$:	JSR	PC,NLINES		;GET THE NUMBER OF LINES
	MOV	M(F),P(F)		;STARTING FROM HERE
20$:	NEG	A			;DELETE THIS MANY (<0 IS DELETE)
	;BR	ADJ			;NOW DO IT

.DSABL	LSB
.SBTTL	ADJUST TEXT AREA ROUTINE
.SBTTL		A = 0 MEANS NO ADJUSTMENT
.SBTTL		A < 0 MEANS SHRINK AREA BY ABS(A)
.SBTTL		A > 0 MEANS ENLARGE AREA BY A
.SBTTL		(A,B,C,D ARE CLOBBERED)

.ENABL	LSB

ADJ:	MOV	P(F),C		;GET .
	MOV	ZZ(F),D		;AND GET END OF TEXT
	MOV	A,B			;COPY THE CHANGE AMOUNT
	BMI	5$			;<0 MEANS SHRINK AREA
	BEQ	4$			;=0 MEANS NO CHANGE
	ADD	D,B			;NOW HAVE NEW SIZE
	SIZE	TEXT			;CHECK OUT THE SIZE
	BCC	90$			;WE CAN'T DO IT
	MOV	B,ZZ(F)		;UPDATE THE BUFFER SIZE
	MOV	TXSTOR(F),A		;GET ABSOLUTE POINTER BIAS
	ADD	A,B			;MAKE NEW ZZ ABSOLUTE
	ADD	A,C			;MAKE . ABSOLUTE
	ADD	A,D			;MAKE OLD ZZ ABSOLUTE
	MOVB	(C),A			;SAVE CHARACTER AT .
	CLRB	(C)			;THEN FLAG THAT SPOT
	BR	3$			;AND ENTER MOVE LOOP

2$:	MOVB	-(D),-(B)		;MOVE A BYTE UP FROM END
	BNE	2$			;CANNOT BE END OF NON-ZERO
3$:	CMP	D,C			;REACHED . YET?
	BHI	2$			;NOPE, SO CONTINUE
	MOVB	A,(B)			;YES, RESTORE CHARACTER AT .
4$:	RTS	PC			;AND EXIT

90$:	ERROR	MEM,<"MEMORY OVERFLOW">	;SORRY...
5$:	NEG	B			;MAKE SHRINK COUNT POSITIVE
	MOV	B,A			;AND SAVE IT
	ADD	C,B			;NOW HAVE END OF DELETE
	CMP	B,D			;IS DELETE TOO BIG?
	BHI	91$			;YEP
	SUB	A,ZZ(F)		;SET NEW DATA SIZE
	MOV	TXSTOR(F),A		;GET BUFFER BIAS
	ADD	A,B			;MAKE END OF DELETE ABSOLUTE
	ADD	A,C			;MAKE . ABSOLUTE
	ADD	A,D			;MAKE END OF BUFFER ABSOLUTE
	CLRB	(D)			;AND FLAG END OF BUFFER
	BR	9$			;NOW ENTER BYTE MOVE LOOP

8$:	MOVB	(B)+,(C)+		;MOVE A BYTE DOWN
	BNE	8$			;CANNOT BE END IF NON-ZERO
9$:	CMP	B,D			;END OF BUFFER REACHED?
	BLO	8$			;NOT YET
	RTS	PC			;NOW EXIT

91$:	ERROR	DTB,<"DELETE TOO BIG">

.DSABL	LSB
.SBTTL	SORT
.SBTTL		INVOKED VIA "SORT" MACRO
.SBTTL		A = CHARACTER TO SORT (GOES INTO "SCHAR")
.SBTTL		(B IS CLOBBERED)

.ENABL	LSB

SORTC:	MOV	N(F),D		;GET ARGUMENT
SORTJ:	CLR	C			;SET UP FOR THE "ADD" CHAIN
SORTS:	JSR	PC,SCAN		;GET CHARACTER TO SORT ON
SORT:	MOV	(E)+,B		;GET TABLE ADDRESS (-2)
	MOV	A,SCHAR(F)		;SAVE TO BE SORTED CHARACTER
1$:	TST	(B)+			;SKIP THE DISPATCH ADDRESS
	CMP	A,(B)+		;GET A MATCH?
	BHI	1$			;NO, KEEP GOING
	BLO	2$			;NO, TOO AR
	MOV	(B),E			;YES, CHANGE RETURN ADDRESS
2$:	RTS	E			;AND EXIT
.SBTTL	SKIP OVER COMMAND
.SBTTL		INVOKED VIA "SKPSET" MACRO
.SBTTL		(A,B,C,D,"TEMP" ARE CLOBBERED)

SKPSET:	MOV	(E)+,TEMP(F)		;SAVE SPECIAL CHARACTER
	JSR	PC,NOTRCE		;DISABLE TRACE
10$:	JSR	PC,SCAN		;GET NEXT CHARACTER
11$:	MOV	A,SCHAR(F)		;SAVE AS SORTED CHARACTER
	CMP	A,TEMP(F)		;IS IT THE SPECIAL CHARACTER?
	BEQ	2$			;YES, SO EXIT
	MOV	#10$,-(SP)		;STACK A RETURN ADDRESS
	SORT	..CSM			;SORT ON SPECIAL SKIPPERS
	RTS	PC			;NON-SPECIALS ARE IGNORED

.CSMDQ:	DEC	CNDN(F)		;INTO ONE MORE CONDITIONAL
.CSMD:	JMP	SCAN			;IGNORE NEXT CHARACTER

.CSMU:	JSR	PC,SCAN			;IGNORE NEXT CHARACTER
	BR	.CSMQ			;AND 1 QUOTED STRING

.CSMF:	JSR	PC,SCAN		;GET "F" MODIFIER
	CMP	A,#'R			;"FR"?
	BEQ	.CSMQ			;YES, ONLY SKIP 1 STRING
.CSM2Q:	JSR	PC,QSKP			;IGNORE 1 QUOTED STRING
.CSMQ:	JSR	PC,QSKP			;IGNORE 1 QUOTED STRING
IREST:	MOV	#ALTMOD,A		;SET TO RESTORE QUOTE AS ALTMODE
	BR	20$			;GO DO IT

QCHK:	TST	QFLG(F)		;QUOTE FLAG?
	BEQ	21$			;NOPE
	JSR	PC,SCAN			;YES, SO GET THE QUOTE CHARACTER
20$:	MOV	A,QUOTE(F)		;AND SET QUOTE CHARACTER
	CLR	QFLG(F)		;NOW CLEAR THE QUOTE FLAG
21$:	RTS	PC			;AND EXIT

.CSMY:	MOV	#.CSMQ,-(SP)		;IGNORE A STRING QUOTED ON
	BR	20$			;THIS CHARACTER

.CSME:	SORT	..CSME,S		;IS IT EB, ER, EW ?
	RTS	PC			;NO

CMDCHR	<'@>				;"@" IS QUOTE FLAG SETTER
.CSMA:	MOV	#-1,QFLG(F)		;@ FOUND; SET QUOTE FLAG
	RTS	PC			;EXIT

.CSMUA:	JSR	PC,SCAN		;GET CHARACTER AFTER ^
	BIC	#-77-1,A		;  THEN FORCE CONTROL CHARACTER
	TST	(SP)+			;JUNK THE RETURN ADDRESS
	BR	11$

.DSABL	LSB
.SBTTL	ERROR MESSAGE PROCESSOR

.IF	NE	ERRTXT

.ENABL	LSB

ERRORA:	MOVB	(E)+,A		;GET 3RD RAD50 CHARACTER
	ADD	(PC)+,A		;NOW FORM "NA?"
	.RAD50	/NA /
	MESSAG	<"NO ARG BEFORE "<-3>>
	MOV	#$$$$$$,-(SP)		;STACK MESSAGE POINTER
	BR	1$			;AND GO TO COMMON PROCESSING

ERRORC:	MOVB	(E)+,A		;GET 2ND RAD50 CHARACTER
	ASL	A			;MAKE INTO
	ASL	A			; REAL
	ASL	A			;  2ND CHARACTER
	ADD	(PC)+,A		;NOW FORM "I?C"
	.RAD50	/I C/
	MESSAG	<"ILLEGAL "<-3>" CHARACTER">
	MOV	#$$$$$$,-(SP)		;STACK MESSAGE POINTER
1$:	MOVB	(E)+,E		;GET LAST/MIDDLE CHARACTER
	BR	ERRMIO			;AND GO TO COMMON PROCESSING

.DSABL	LSB

.ENDC
ERRMSG:
	MOV	(E)+,A		;GET RAD50 OF ERROR CODE
.IF	NE	ERRTXT
	MOV	(E)+,-(SP)		;SAVE THE TEXT POINTER
	MOV	(PC),E			;SET E = 012702
.ENDC
ERRMIO:	MOV	#50,C			;SET TO DIVIDE BY 50
	CLR	-(SP)			;FLAG END OF CHARACTERS
1$:	JSR	PC,DIVD			;DIVIDE BY 50
	MOV	B,-(SP)		; AND SAVE REMAINDER
	TST	A			;  ANY ANSWER LEFT?
	BNE	1$			;   LOOP IF SO...
	MOV #-1,DERFLG		;WE WANT THE TOP LINE CLEARED
	JSR PC,TOPDIS		;GET TO TOP OF SCREEN AND MAKE ROOM FOR ERROR MESSAGE
	MOV	#'?-<'A-1>,D		;NOW PRINT A "?"
2$:	ADD	#'A-1,D		;MAKE A CHARACTER
	CMP	D,#'Z			;REALLY ALPHABETIC?
	BLOS	3$			;YES, SO TYPE IT
	ADD	#'0-36-<'A-1>,D	;NO, SO CONVERT TO NUMERIC
3$:	JSR	PC,TYO			; AND TYPE IT
	MOV	(SP)+,D		;GET NEXT
	BNE	2$			; IF ANY...
	MOV	(F),ERRPOS(F)		;SAVE ERRING "SCANP"
	MOV	EHELP(F),A		;GET EDIT HELP LEVEL
.IF	NE	ERRTXT
	DEC	A			;LESS 1
	BEQ	10$			;IF "EH"=1 THEN ONLY RAD50
	MOV	(SP)+,B		;GET THE STRING POINTER
	BEQ	9$			;IF ANY...
	MOV	#TAB,D			;START WITH A TAB
4$:	JSR	PC,TYO
5$:	MOVB	(B)+,D		;GET STRING CHARACTER
	BGT	4$			; IF MORE...
	BEQ	9$			;  OR THE REAL END
	MOV	SCHBUF(F),C		;GUESS AT PRINT SEARCH BUFFER FIRST
	CMPB	D,#-2			;WHICH TYPE OF SPECIAL WAS IT??
	BGT	7$			;IF -1 (-1.GT.-2) THEN ALL SET UP
	BEQ	6$			;IF -2 (-2.EQ.-2) THEN SET POINTER
	MOVB	E,D			;IF -3 (-3.LT.-2) THEN SET CHARACTER
	BR	4$			;AND PRINT IT, THEN JUST CONTINUE

6$:	MOV	TEMP(F),C		;THIS IS THE SAVED FILENAME POINTER
7$:	DEC	E			;MORE TO PRINT IN STRING?
	BMI	5$			;NOPE, SO QUIT NOW
	MOVB	(C)+,D		;YEP, SO FETCH NEXT CHARACTER
	BPL	8$			;AND PRINT IT
	CMPB	D,#-1			;IF SPECIAL, THEN THE END?
	BEQ	5$			;QUIT BEFORE PRINTING END CHARACTER
	BIC	#-177-1,D		;ELSE TRIM OFF SPECIAL BIT(S)
8$:	JSR	PC,TYO			;AND PRINT CHARACTER AS NORMAL
	BR	7$			;AROUND AGAIN FOR GOODNESS

9$:	DEC	A			;CHECK LEVEL AGAIN
.IFF
	SUB	#2,A			;CHECK THE LEVEL
.ENDC
	BLE	10$			;UNLESS "EH">=3 THEN EXIT
	MOV D,A		;IS THIS NECESSARY?
	JMP	.CMDQM			;NOW DO THE ?

10$:	JMP	TECO1			;RESTART TECO

.DSABL	LSB
.SBTTL	Q REGISTER REFERENCE
.SBTTL		RETURNS:	A = 0
.SBTTL				B = POINTER TO Q REG SIZE
.SBTTL				C = OFFSET TO BASE OF Q REG
.SBTTL				"QNMBR" SET AS SPECIFIED

.ENABL	LSB

QREF:	JSR	PC,SCAN		;GET NEXT CHARACTER
.CMD.S:	JSR	PC,ALPHAN		;MUST BE ALPHANUMERIC
	BCC	90$			; BUT IT IS NOT
	CMP	A,#'A			;IS IT ALPHA?
	BLO	2$			;NOPE, IT IS NUMERIC
	ADD	#13-'A-<1-'0>,A	;YEP, RANGE IS 13-44
2$:	ADD	#1-'0,A		;RANGE IS 1-12
QREFA:	MOV	A,QNMBR(F)		;SAVE THE Q REG NUMBER

.SBTTL	GET SUM OF Q REGISTER IN "QNMBR" (QSUMY)

QSUMY:	MOV	QNMBR(F),A		;GET THE Q REG NUMBER

.SBTTL	GET SUM OF Q REGISTER IN A (QSUMX)

QSUMX:	MOV	#QARRAY,B		;GET OFFSET TO Q REG ARRAY
	ADD	F,B			;NOW FIND IT FOR REAL
	CLR	C			;START OFFSET OF REG AT 0
	BR	12$			;AND ENTER COUNTING LOOP

11$:	ADD	(B)+,C		;SUM THE TOTAL OFFSE
	TST	(B)+			;AND SKIP THE VALUE SPOT
12$:	SOB A,11$
	RTS	PC			; EXIT

90$:	ERROR	IQN,<"ILLEGAL Q REG NAME">;BAD Q REG NUMBER

.DSABL	LSB
.SBTTL	Q REGISTER SIZE ADJUST ROUTINE
.SBTTL		A = NEW SIZE OF Q REGISTER IN "QNMBR"
.SBTTL		RETURNS:	A = 0
.SBTTL				B = POINTER TO NEW Q REG SCK THE LEVEL
.ENDC
	BLE	10$			;UNLESS "EH">=3 THEN EXIT
	JMP	.CMDQM			;NOW DO THE ?

10$:	JMP	TECO			;RESTART TECO

.DSABLOBBER COMMAND?
	BEQ	90$			;YES, BOOT HIM
QADJ:	MOV	A,D			;COPY THE NEW Q REG SIZE
	JSR	PC,QSUMY		;AND SUM CURRENT Q REG OFFSET
	MOV	QZ(F),A		;GET END OF ALL Q REGS
	MOV	B,E			;COPY Q REG SIZE POINTER
	MOV	D,B			;AND GET WORKING COPY OF NEW SIZE
	ADD	(E),C			;POINTER TO CURRENT END OF Q REG
	SUB	(E),B			;SIZE CHANGE (NEW-OLD)
	BLO	25$			;NEW < OLD
	BEQ	QSUMY			;NEW = OLD
	ADD	A,B			;NEW > OLD; GET NEW QZ
	SIZE	QREGS			;CHECK OUT THE SIZE
	BCC	91$			;WE CAN'T DO IT
	MOV	D,(E)			;SET NEW Q REG SIZE
	MOV	B,QZ(F)		;SET NEW TOTAL Q REG SIZE
	MOV	QRSTOR(F),D		;GET Q REG AREA POINTER
	ADD	D,A			;MAKE ALL
	ADD	D,B			; POINTERS
	ADD	D,C			;  ABSOLUTE
	MOVB	(C),E			;SAVE CHARACTER IN MIDDLE
	CLRB	(C)			;THEN FLAG THAT BYTE AS NULL
	BR	23$			;AND ENTER MOVE LOOP

22$:	MOVB	-(A),-(B)		;MOVE A BYTE UP FROM TOP
	BNE	22$			;CANNOT BE END IF NON-ZERO
23$:	CMP	A,C			;DONE?
	BHI	22$			;NOT YET...
	MOVB	E,(B)			;RESTORE SAVED CHARACTER
24$:	MOV	QCMND(F),A		;GET COMMAND Q REG NUMBER
	MOV	#QSUMY,-(SP)		;SET FOR COMMAND SETUP JUST IN CASE
SETCMD:	MOV	A,QCMND(F)		;SET COMMAND Q REG NUMBER
	JSR	PC,QSUMX		;AND SUM UP FOR THAT REGISTER
	MOV	C,QBASE(F)		;STORE THE BASE OFFSET
	MOV	(B),QLENGT(F)		; AND THE LENGTH
	RTS	PC			;THEN EXIT
.SBTTL	Q REGISTER SIZE ADJUST ROUTINE
.SBTTL		A = NEW SIZE OF Q REGISTER IN "QNMBR"
.SBTTL		RETURNS:	A = 0
.SBTTL				B = POINTER TO NEW Q REG SIZE
.SBTTL				C = OFFSET TO THIS Q REG
.SBTTL				(D,E ARE CLOBBERED)

.ENABL	LSB

QADJX:	CMP	QNMBR(F),QCMND(F)	;ABOUT TO CLOBBER COMMAND?
	BEQ	90$			;YES, BOOT HIM
QADJ:	MOV	A,D			;COPY THE NEW Q REG SIZE
	JSR	PC,QSUMY		;AND SUM CURRENT Q REG OFFSET
	MOV	QZ(F),A		;GET END OF ALL Q REGS
	MOV	B,E			;COPY Q REG SIZE POINTER
	MOV	D,B			;AND GET WORKING COPY OF NEW SIZE
	ADD	(E),C			;POINTER TO CURRENT END OF Q REG
	SUB	(E),B			;SIZE CHANGE (NEW-OLD)
	BLO	25$			;NEW < OLD
	BEQ	QSUMY			;NEW = OLD
	ADD	A,B			;NEW > OLD; GET NEW QZ
	SIZE	QREGS			;CHECK OUT THE SIZE
	BCC	91$			;WE CAN'T DO IT
	MOV	D,(E)			;SET NEW Q REG SIZE
	MOV	B,QZ(F)		;SET NEW TOTAL Q REG SIZE
	MOV	QRSTOR(F),D		;GET Q REG AREA POINTER
	ADD	D,A			;MAKE ALL
	ADD	D,B			; POINTERS
	ADD	D,C			;  ABSOLUTE
	MOVB	(C),E			;SAVE CHARACTER IN MIDDLE
	CLRB	(C)			;THEN FLAG THAT BYTE AS NULL
	BR	23$			;AND ENTER MOVE LOOP

22$:	MOVB	-(A),-(B)		;MOVE A BYTE UP FROM TOP
	BNE	22$			;CANNOT BE END IF NON-ZERO
23$:	CMP	A,C			;DONE?
	BHI	22$			;NOT YET...
	MOVB	E,(B)			;RESTORE SAVED CHARACTER
24$:	MOV	QCMND(F),A		;GET COMMAND Q REG NUMBER
	MOV	#QSUMY,-(SP)		;SET FOR COMMAND SETUP JUST IN CASE
SETCMD:	MOV	A,QCMND(F)		;SET COMMAND Q REG NUMBER
	JSR	PC,QSUMX		;AND SUM UP FOR THAT REGISTER
	MOV	C,QBASE(F)		;STORE THE BASE OFFSET
	MOV	(B),QLENGT(F)		; AND THE LENGTH
	RTS	PC
25$:	MOV	D,(E)			;SET NEW Q REG SIZE
	ADD	B,QZ(F)		;LOWER THE TOTAL Q REG SIZE
	ADD	C,B			;POINT TO THE NEW END
	MOV	QRSTOR(F),D		;GET Q REG AREA POINTER
	ADD	D,A			;MAKE ALL
	ADD	D,B			; POINTERS
	ADD	D,C			;  ABSOLUTE
	CLRB	(A)			;FLAG THE END BYTE AS NULL
	BR	27$			;ENTER MOVE LOOP

26$:	MOVB	(C)+,(B)+		;MOVE A BYTE DOWN
	BNE	26$			;CANNOT BE END IF NON-ZERO
27$:	CMP	C,A			;DONE?
	BLO	26$			;NOT YET...
	BR	24$			;ALL DONE

90$:	ERROR	CCC,<"CAN'T CLOBBER COMMAND">

91$:	ERROR	MEM,<"MEMORY OVERFLOW">	;NO GO

.DSABL	LSB
.SBTTL	GENERAL SUBROUTINES

GETXTP:	MOV	P(F),A		;GET .
	CMP	A,ZZ(F)		;TOO FAR?
	BHIS	1$			;YES [BHIS=BCC]
	ADD	TXSTOR(F),A		;NO, MAKE ABSOLUTE
	MOVB	(A),A			;AND GET CHARACTER
	SEC				;OK [CARRY SET]
1$:	RTS	PC			;EXIT

.ENABL	LSB

90$:	ERROR	PDO,<"PUSH-DOWN LIST OVERFLOW">

1$:	CMP	PDL(F),SCHBUF(F)	;PUSHING TOO FAR?
	BHIS	90$			;YEP
	ADD	F,(SP)			;NOPE, MAKE OFFSET ABSOLUTE
	MOV	@(SP)+,@PDL(F)		;NOW SAVE IT
	ADD	#2,PDL(F)		;AND GO TO NEXT LOCATION
PUSH:	MOV	(E)+,-(SP)		;GET THE OFFSET
	BPL	1$			;NOT END OF LIST YET
2$:	TST	(SP)+			;GET RID OF FLAG
	RTS	E			;AND EXIT

POP:	MOV	(E)+,-(SP)		;GET THE OFFSET
	BMI	2$			;GET OUT IF END
	SUB	#2,PDL(F)		;BACK UP THE LIST
	ADD	F,(SP)			;MAKE ABSOLUTE
	MOV	@PDL(F),@(SP)+		;RESTORE VALUE
	BR	POP			;AND CONTINUE

.DSABL	LSB

;THIS WILL GO AWAY
SCNUPP:	JSR	PC,SCAN			;SCAN FIRST
UPPERC:	CMP	A,#140			;ALREADY OK?
	BLO	1$			;YES
	BIC	#40,A			;NO, SO CORRECT IT
1$:	RTS	PC			;AND EXIT

QSKP:	JSR	PC,QCHK			;CHECK FOR A QUOTE CHARACTER
	MOV	(F),OSCANP(F)		;AND SAVE "SCANP"
1$:	JSR	PC,SCAN			;NOW SCAN
	CMP	A,QUOTE(F)		;MATCH?
	BNE	1$			;NOPE
	RTS	PC			;NOW EXIT
.ENABL	LSB

BZCHK:	CMP	A,ZZ(F)		;TOO BIG?
	BLOS	1$			;NOPE
	ERROR	POP,<"POINTER OFF PAGE">;YEP

NOTRCE:	MOV	TFLG(F),TFGTMP(F)	;SAVE TRACE FLAG
	CLR	TFLG(F)		;THEN TURN OFF TRACE
1$:	RTS	PC			;EXIT

.DSABL	LSB

;THIS WILL GO AWAY
ENTRCE:	MOV	TFGTMP(F),TFLG(F)	;RESTORE TRACE FLAG
	RTS	PC			;AND EXIT

.ENABL	LSB

20$:	MOV	#1,A			;PRETEND WE SAW A ONE
	JSR	PC,NCOM			;AND COMPUTE ON IT
GETN:	MOV	N(F),A		;GET THE NUMBER
	INC	NFLG(F)		;REALLY THERE?
	BNE	20$			;NOPE
	RTS	PC			;YES

.DSABL	LSB
.ENABL	LSB

TERMS:	CMP	A,#FF+1		;TERMINATOR TEST
	BHIS	11$			;TOO BIG, RETURN C=0
10$:	CMP	#LF-1,A		;SET CARRY ON LOW RANGE
11$:	RTS	PC			;AND EXIT

NUMER:	CMP	A,#'9+1		;NUMERIC TEST
	BHIS	1$			;RETURN CARRY CLEAR IF HIGH
	CMP	#'0-1,A		;SET CARRY ON LOW RANGE
1$:	RTS	PC			;AND EXIT

RAD50:	CMP	A,#'.			;.?
	BEQ	10$			;YES
	CMP	A,#'$			;$?
	BEQ	10$			;YES
ALPHAN:	JSR	PC,NUMER		;CHECK FOR NUMERIC FIRST
	BCS	2$			;EXIT IF SO
ALPHA:	CMP	A,#'Z+1		;ALPHABETIC TEST
	BHIS	2$			;RETURN C=0 IF TOO HIGH
	CMP	#'A-1,A		;SET CARRY ON LOW RANGE
2$:	RTS	PC			;AND EXIT

TSTNXT:	MOV	(F),A			;GET COMMAND POINTER
	CMP	A,QLENGT(F)		;END OF COMMAND?
	BHIS	20$			;YES, SO EXIT (C=0)
	ADD	QBASE(F),A		;NO, ADD COMMAND OFFSET
	ADD	QRSTOR(F),A		;AND MAKE ABSOLUTE
	MOVB	(A),A			;FETCH CHARACTER
	JSR	PC,UPPERC		;AND MAKE UPPER CASE
	CMP	A,(E)			;MATCH?
	BNE	20$			;NO, EXIT (C=0)
	INC	(F)			;YES, BUMP POINTER
	TST	(E)+			;SKIP ARGUMENT
	SEC				;INDICATE ALL OK
	RTS	E			;AND EXIT

20$:	TST	(E)+			;SKIP ARGUMENT
	RTS	E			;AND EXIT

.DSABL	LSB
NLINES:	INC	CFLG(F)		;WAS THERE A COMMA?
	BEQ	1$			;YES
	MOV	P(F),M(F)		;NO, SO SAVE . IN "M"
	JSR	PC,@'L*2+TECOCH		;AND MOVE . FORWARD "N" LINES
	MOV	P(F),N(F)		;"N" IS THE NEW .
	MOV	M(F),P(F)		;RESTORE THE ORIGINAL .
1$:	CLR	NFLG(F)		;USE UP THE NUMBER
	MOV	N(F),A		;GET NTH CHARACTER POSITION
	CMP	A,M(F)		;IS IT AFTER MTH CHARACTER?
	BHIS	2$			;YES
	MOV	M(F),N(F)		;NO, SO SWITCH
	MOV	A,M(F)		; N AND M
	MOV	N(F),A		;AND GET NTH POSITION AGAIN
2$:	JSR	PC,BZCHK		;IN RANGE?
	SUB	M(F),A		;FIND DISTANCE BETWEEN N AND M
	RTS	PC			;THEN EXIT

ZEROD:	MOV	(E)+,TEMP(F)		;PICKUP OUTPUT ROUTINE ADDRESS
	MOV	E,(SP)			;THEN SET THE RETURN ADDRESS
	MOV	N(F),-(SP)		;GET NUMBER
	BPL	1$			;IT IS +
	TST	NMRBAS(F)		;IT IS -, BUT IS RADIX OCTAL?
	BNE	1$			;IF OCTAL, THEN NO SIGN
	MOV	#'-,A			;IF DECIMAL, THEN SIGNED
	JSR	PC,@TEMP(F)		;OUTPUT MINUS SIGN
	NEG	(SP)			;AND MAKE +
1$:	MOV	(SP)+,A		;RESTORE THE NUMBER
	MOV	#8.,C			;RADIX = 8?
	TST	NMRBAS(F)		;THIS TELLS US...
	BNE	2$			;YES
	TST	(C)+			;NO, RADIX = 10.
2$:	JSR	PC,DIVD			;NOW DIVIDE
	MOV	B,-(SP)		;SAVE REMAINDER
	TST	A			;MORE TO GO?
	BNE	2$			;YES
3$:	MOV	(SP)+,A		;GET BACK A DIGIT
	CMP	A,#9.			;DIGIT OR RETURN ADDRESS?
	BHI	4$			;RETURN ADDRESS
	ADD	#'0,A			;DIGIT
	JSR	PC,@TEMP(F)		;OUTPUT IT
	BR	3$			;AND LOOP

4$:	JMP	(A)			;EXIT
.SBTTL	SEARCH

.ENABL	LSB

SEARCH:	JSR	PC,GETN			;GET THE NUMBER
	MOV	A,-(SP)		;NOW SAVE THE NUMBER
	JSR	PC,QCHK			;SET UP FOR ANY QUOTED STRING
	MOV	SCHBUF(F),E		;GET SEARCH BUFFER START
	MOV	#SCHSIZ-1,D		; AND ITS SIZE
5$:	CLR	C			;GET INPUT FROM SCAN
10$:	TST	C			;WHERE DO THEY COME FROM?
	BNE	25$			;A Q-REG IF NON-0
	JSR	PC,SCAN			;PICKUP A CHARACTER TO SEARCH FOR
	CMP	A,QUOTE(F)		;END OF SEARCH STRING?
	BEQ	50$			;YES
	CMP	A,#'Q-100		;CTRL/Q?
	BNE	30$			;NOPE
	JSR	PC,SCAN			;YES, SO GET NEXT LITERALLY
	BR	40$			;AND STORE IT IN SEARCH BUFFER

20$:	TST	C			;^E - ARE WE IN Q-REG FETCH?
	BNE	35$			;YES, USE AS NORMAL ^E
	TSTNXT	'Q			;NO, IS IT Q-REG FETCH?
	MOV	#'E-100+200,A		;RESTORE IT AS CTRL/E
	BCC	40$			;NO, ENTER IT AS SPECIAL
	JSR	PC,QREF			;YES, REFERENCE THE Q-REG
	ADD	QRSTOR(F),C		;MAKE SOURCE ABSOLUTE
	MOV	(B),B			;GET THE COUNT IN B
25$:	DEC	B			;ANYTHING LEFT IN Q-REG?
	BMI	5$			;NO, GO CLEAR FLAG
	MOVB	(C)+,A		;YES, GET A BYTE
30$:	CMP	A,#'E-100		;CTRL/E?
	BEQ	20$			;YES
	CMP	A,#'N-100		;CTRL/N?
	BEQ	35$			;YES, THAT IS SPECIAL
	CMP	A,#'S-100		;CTRL/S?
	BEQ	35$			;YES, THAT IS SPECIAL
	CMP	A,#'X-100		;CTRL/X?
	BNE	40$			;NOPE, SO NORMAL SEARCH CHARACTER
35$:	BIS	#200,A			;FLAG THE SPECIAL CHARACTERS
40$:	MOVB	A,(E)+		;STORE IN SEARCH BUFFER
	MOVB	#-1,(E)		; AND MARK END OF BUFFER
	DEC	D			;MORE ROOM?
	BGT	10$			;YES, SO CONTINUE
	ERROR	STL,<%SEARCH STRING "%<-1>%" TOO LARGE%>

50$:	MOV	(SP)+,C		;GET THE REPEAT COUNT

.DSABL	LSB
.ENABL	LSB

.SURCH:	MOV	#1,-(SP)		;GUESS AT FORWARD TYPE SEARCH
	TST	C			;GOOD GUESS??
	BPL	30$			;YES, MOVE . BY +1 EACH FAILURE
	NEG	(SP)			;NO, MOVE . BY -1 EACH FAILURE
	NEG	C			;AND GET A POSITIVE HIT COUNTER
30$:	CLR	LSCHSZ(F)		;SET LAST STRING SIZE TO 0
	MOV	P(F),B		;GET .
	ADD	TXSTOR(F),B		;AND MAKE IT ABSOLUTE
	ADD	TXSTOR(F),ZZ(F)	;NOW MAKE END OF TEXT ABSOLUTE ALSO
40$:	MOV	B,D			;GET STARTING POINT
	MOV	SCHBUF(F),E		;AND SEARCH STRING START
.SUR.Y:	CMP	D,ZZ(F)		;END OF TEXT?
	BLO	50$			;NOPE
	CMPB	(E),#-1		;YEP, BUT DOES IT MATCH END OF STRING?
	BEQ	62$			;YES, SO ALL DONE (FOUND)
	TST	(SP)			;NO, SEARCHING BACKWARDS??
	BMI	.SUR.N			;IF BACKWARDS THEN MOVE . IF POSSIBLE
47$:	CLRB	(SP)			;INDICATE FAILURE (0 OR 177400)
	CMP	CLNF(F),#-2		;SPECIAL TYPE SEARCH?
	BEQ	65$			;YES, SO KEEP .
	CLR	P(F)			;NO, SO .=0
	BR	65$			;AND EXIT

50$:	MOVB	(E)+,A		;GET A STRING CHARACTER
	BMI	60$			;IT WAS A SPECIAL
	CMPB	A,(D)+		;MATCH?
	BEQ	.SUR.Y			;YES, SO CONTINUE
.SUR.N:	ADD	(SP),B			;NOPE, MOVE . ONE POSITION
	CMP	CLNF(F),#-2		;SPECIAL SEARCH?
	BEQ	47$			;YES, ALWAYS INDICATE FAILURE
55$:	CMP	B,TXSTOR(F)		;NO, IS . TOO SMALL NOW??
	BHIS	40$			;. IS O.K., KEEP SEARCHING
	BR	47$			;. IS TOO SMALL, SEARCH FAILS

60$:	INCB	A			;WAS SPECIAL THE END FLAG?
	BNE	.SUR.S			;NOPE, REAL SPECIAL
62$:	MOV	B,PST(F)		;SAVE (ABS) STARTING POSITION
	MOV	B,E			;COPY (ABS) START AGAIN TO
	SUB	D,E			;GET "START"-"END" = -("LENGTH")
	MOV	D,B			;SET NEXT START IF FORWARDS
	TST	(SP)			;IS SEARCH GOING FORWARDS??
	BPL	63$			;YES, SO NEW START IS SET
	ADD	E,B			;NO, BACKWARDS, SO GO BACK AND
	ADD	E,B			; BACK AGAIN FOR NEW START
63$:	DEC	C			;SEARCH ANOTHER TIME??
	BGT	55$			;YES, SO SEARCH AGAIN ALREADY
	MOV	E,LSCHSZ(F)		;NO, DONE, STORE -("LENGTH")
	SUB	TXSTOR(F),D		;MAKE ENDING . RELATIVE
	MOV	D,P(F)		; AND SET THAT ENDING .
	SUB	TXSTOR(F),PST(F)	;MAKE STARTING . RELATIVE
	MOV	#-1,(SP)		;INDICATE SUCCESS (-1)
65$:	SUB	TXSTOR(F),ZZ(F)	;MAKE END OF TEXT RELATIVE
	MOV	(SP)+,B		;SET CC'S AND RETURN INDICATOR
	RTS	PC			;AND EXIT

.DSABL	LSB
.SUR.S:	CMPB	A,#'S-100+200+1	;WAS SPECIAL CTRL/S?
	BEQ	80$			;YES (IT IS CTRL/S)
	BHI	85$			;NO (IT IS CTRL/X)
	CMPB	A,#'E-100+200+1	;NO, IS IT CTRL/E?
	BEQ	81$			;YES
	TSTB	(E)			;NO (IT IS CTRL/N)
	BMI	75$			;NEXT AS SPECIAL IS VERY SPECIAL
	CMPB	(E)+,(D)+		;MATCH? (CTRL/N)
	BNE	.SUR.Y			;NO MATCH IS GOOD HERE
	BR	.SUR.N			;MATCH IS BAD...

75$:	CMPB	(E),#'S-100+200	;IS IT CTRL/N THEN CTRL/S ??
	BNE	.SUR.N			;NO, OTHERS FAIL
	MOV	#ALPHAN,-(SP)		;SET ROUTINE ADDRESS
76$:	MOVB	(D)+,A		;GET A TEXT CHATACTER
	JSR	PC,@(SP)+		;GO TEST CHARACTER
78$:	INC	E			;BUMP SEARCH BUFFER POINTER
	BCS	.SUR.Y			;MADE IT
	BR	.SUR.N			;NO GO

80$:	MOVB	(D)+,A		;GET A TEXT CHARACTER
	JSR	PC,ALPHAN		;ALPHANUMERIC?
	BCC	.SUR.Y			;NO, SO OK
	BR	.SUR.N			;YES, SO NO

81$:	CMPB	(E),#'S		;CTRL/E AND "S"?
	BEQ	87$			;YES
	MOV	#ALPHA,-(SP)		;SET FOR A
	CMPB	(E),#'A		;A?
	BEQ	76$			;YES
	MOV	#NUMER,(SP)		;SET FOR D
	CMPB	(E),#'D		;D?
	BEQ	76$			;YES
	MOV	#TERMS,(SP)		;SET FOR L
	CMPB	(E),#'L		;L?
	BEQ	76$			;YES
	TST	(SP)+			;NO, POP ADDRESS
	CMPB	(E),#'X		;X?
	BNE	.SUR.N			;NOTHING, SAY NO MATCH
	INC	E			;CTRL/E & X MEAN ANY MATCH
85$:	INC	D			;CTRL/X IS ANY MATCH
	BR	.SUR.Y			;INDICATE SUCCESS

87$:	MOV	D,-(SP)		;SAVE POINTER TO TEXT
88$:	CMP	D,ZZ(F)		;END OF TEXT?
	BHIS	89$			;YES, QUIT
	MOVB	(D)+,A		;NO, GET CHARACTER
	CMP	A,#SPACE		;SPACE?
	BEQ	88$			;YES
	CMP	A,#TAB			;TAB?
	BEQ	88$			;YES
89$:	DEC	D			;CORRECT TEST POINTER
	CMP	(SP)+,D		;AND CHECK FOR NON-NULL
	BR	78$			;NOW EXIT
.SBTTL	SIZING (SHUFFLING) ROUTINE

SIZE:	MOV	A,-(SP)		;SAVE A
	MOV	(E)+,A		;GET OFFSET TO MAX TO CHANGE
	CMP	B,#077740		;IS REQUEST AT ALL REASONABLE?
	BHIS	99$			;NOPE [BHIS=BCC => FAILURE]
	MOV	B,-(SP)		;SAVE B
	MOV	C,-(SP)		; AND SAVE C
	MOV	A,C			;SAVE THE MAX'S OFFSET VALUE
	ADD	F,A			;MAKE A ABS PTR TO MAX
	SUB	(A),B			;FIND CHANGE AMOUNT
	BLO	98$			;ALREADY DONE [BLO=BCS => OK]
	ADD	#40,B			;FUDGE UP REQUEST A LITTLE
	MOV	D,-(SP)		;SAVE D
	SUB	#ZMAX,C		;GET WHICH AREA IS CHANGING
	MOV	C,-(SP)		;0=>TEXT; <>0=>QREGS
	MOV	B,-(SP)		;SAVE ORIGINAL DELTA AMOUNT
	JSR	PC,40$			;SEE IF CURRENT FREE DOES IT
	MOV	#QMAX,C		;NO, SO GET OTHER AREA'S MAX
	MOV	QZ(F),D		; AND CURRENT IN USE
	TST	2(SP)			;QREGS ARE OTHER AREA IF 0
	BEQ	1$			;WE ARE CHANGING TEXT
	MOV	#ZMAX,C		;ELSE GET REAL OTHER AREA'S
	MOV	ZZ(F),D		; MAX AND CURRENT IN USE
1$:	NEG	D			;GET -(IN USE)
	ADD	F,C			;ABS PTR TO OTHER MAX
	ADD	(C),D			;FREE = MAX -(IN USE)
	SUB	#200.,D		;FIND THE PUNISH AMOUNT
	BLOS	10$			;NOT ENOUGH FREE TO PUNISH
	SUB	D,(C)			;ELSE PUNISH THE OTHER MAX
	ADD	D,CURFRE(F)		;AND UPDATE FREE SPACE
	TST	2(SP)			;WHICH AREA ARE WE CHANGING
	BEQ	3$			;IF TEXT, THEN JUST PUNISHED QREGS
	MOV	QRSTOR(F),C		;PTR TO OLD BEG
	NEG	D			;-(PUNISH)
	ADD	C,D			;PTR TO NEW BEG (LOWER)
	MOV	D,QRSTOR(F)		;SET NEW BEGINNING
	MOV	E,-(SP)		;SAVE E
	MOV	C,E			;PTR TO OLD BEG
	ADD	QMAX(F),E		;PTR TO OLD END +1
	MOVB	-(E),-(SP)		;SAVE @ OLD END
	CLRB	(E)			;THEN FLAG IT AS NULL BYTE
2$:	MOVB	(C)+,(D)+		;FROM OLD BEG TO NEW BEG
	BNE	2$			;CANNOT BE END IF NON-NULL
	CMP	C,E			;OLD BEG+? CAUGHT OLD END??
	BLOS	2$			;NOT YET
	MOVB	(SP)+,-(D)		;YES, SO RESTORE @ NEW END
	MOV	(SP)+,E			;RESTORE E
3$:	JSR	PC,40$			;WILL FREE SPACE DO IT NOW?
10$:	JSR	PC,SIZER		;ASK WHOEVER FOR MORE PLEASE
	BCC	3$			;WE GOT IT!
	MOV	(SP)+,D		;GET BACK ORIGINAL DELTA
	SUB	B,D			;FIND WHAT WE GAVE OF FREE SPACE
	ADD	D,CURFRE(F)		;AND RETURN IT TO FREE SPACE
	TST	(SP)+			;DUMP THE AREA DETERMINATION
	BR	97$			;AND EXIT
40$:	MOV	CURFRE(F),D		;GET CURRENT FREE AMOUNT
	CMP	B,D			;WILL IT DO THE TRICK?
	BHI	41$			;NOPE, BUT WILL HELP SOME
	MOV	B,D			;YEP, SO DON'T USE IT ALL
41$:	SUB	D,CURFRE(F)		;WE GAVE AT THE OFFICE
	SUB	D,B			;CORRECT DELTA CHANGE AMOUNT
	BEQ	50$			;ALL DONE
	RTS	PC			;ELSE RETURN FOR MORE WORK

50$:	TST	(SP)+			;DUMP THE RETURN ADDRESS
	MOV	(SP)+,B		;GET ORIGINAL DELTA
	ADD	B,(A)			;AND CORRECT THE MAX
	TST	(SP)			;WHICH AREA IS CHANGING?
	BNE	96$			;QREGS, SO VERY EASY
	MOV	QRSTOR(F),A		;TEXT, SO GET OLD BEG PTR
	ADD	B,QRSTOR(F)		;UPDATE QREG PTR
	MOV	A,C			;COPY OLD BEG PTR
	ADD	QMAX(F),A		;HAVE OLD END PTR +1
	ADD	A,B			;HAVE NEW END PTR +1 (HIGHER)
	MOVB	(C),D			;SAVE @ OLD BEG
	CLRB	(C)			;THEN FLAG AS A NULL BYTE
51$:	MOVB	-(A),-(B)		;MOVE OLD END TO NEW END
	BNE	51$			;CANNOT BE END IF NON-NULL
	CMP	C,A			;CAUGHT UP YET?
	BLO	51$			;NOPE, SO CONTINUE
	MOVB	D,(B)			;RESTORE @ NEW BEG
96$:	COM	(SP)+			;DUMP AREA FLAG AND CARRY=1
97$:	MOV	(SP)+,D			;RESTORE D
98$:	MOV	(SP)+,C			;AND C

	MOV	(SP)+,B			;AND B
99$:	MOV	(SP)+,A			;AND A
	RTS	E			;FINALLY EXIT
.SBTTL	CHARACTER LIST FOR " COMMANDS

.TABLE	.CND
.ENTRY	A
.ENTRY	C
.ENTRY	D
.ENTRY	E
.ENTRY	F
.ENTRY	G
.ENTRY	L
.ENTRY	N
.ENTRY	R
.ENTRY	S
.ENTRY	T
.ENTRY	U
.WORD	-1
.SBTTL	CHARACTER LIST FOR E COMMANDS

.TABLE	.EEE
.ENTRY	A
.ENTRY	B
.ENTRY	C
.ENTRY	F
.ENTRY	G
.ENTRY	H
.ENTRY	P
.ENTRY	R
.ENTRY	S
.ENTRY	T
.ENTRY	W
.ENTRY	X
.WORD	-1
.SBTTL	COMMAND CHARACTER LIST

.TABLE	.CMD
.WORD	BELL,	.CMDBL
.WORD	'U-100,	.CMDCU
.WORD	ALTMOD,	.CMDAM
.WORD	SPACE,	.CMDSP
.WORD	'*,	.CMDST
.WORD	'?,	.CMDQM
.WORD	RUBOUT,	.CMDRO
.WORD	-1
.SBTTL	CHARACTER TABLES FOR "SKPSET"

.TABLE	.CSM
.WORD	'A-100,	.CSMY	;CTRL/A
.WORD	'I-100,	.CSMQ	;TAB
.WORD	'R-100,	.CSM2Q	;CTRL/R
.WORD	'U-100,	.CSMU	;CTRL/U
.WORD	'^-100,	.CSMD	;CTRL/^
.WORD	'!,	.CSMY	;!
.WORD	'",	.CSMDQ	;"
.WORD	'%,	.CSMD	;%
.WORD	'<,	.CSMI	;<
.WORD	'>,	.CSMO	;>
.WORD	'@,	.CSMA	;@
.WORD	'E,	.CSME	;E (EB, ER, EW)
.WORD	'F,	.CSMF	;F (FR, FS, FN)
.WORD	'G,	.CSMD	;G
.WORD	'I,	.CSMQ	;I
.WORD	'M,	.CSMD	;M
.WORD	'N,	.CSMQ	;N
.WORD	'O,	.CSMQ	;O
.WORD	'Q,	.CSMD	;Q
.WORD	'S,	.CSMQ	;S
.WORD	'U,	.CSMD	;U
.WORD	'X,	.CSMD	;X
.WORD	'^,	.CSMUA	;^
.WORD	'_,	.CSMQ	;_
.WORD	-1

.TABLE	.CSME
.WORD	'B,	.CSMQ	;EB
.WORD	'R,	.CSMQ	;ER
.WORD	'W,	.CSMQ	;EW
.WORD	-1
.SBTTL	F CHARACTER LIST

.TABLE	.FFF
.ENTRY	N
.ENTRY	R
.ENTRY	S
.WORD	-1
.SBTTL	FINAL FIXUPS...

.CSECT	TECOER
.EVEN

.END
