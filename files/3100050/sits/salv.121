	.TITLE "SALVAGER" FOR THE SITS FILE SYSTEM
	.STITL PARAMETERS
	.ABS

;WHEN INITING THE MOVING HEAD DISK
;RUG WANTS BLOCKS 0,4-23, AND 54-217 ON DISK 0
;LOGO WANTS 100-1100 FOR SWAPPING ON DISK 1

;WHEN INITING THE FIXED HEAD DISK
;RUG WANTS BLOCKS 0,4-23, AND 54-217
;LOGO WANTS 500-1777 FOR SWAPPING



	A=%0
	B=%1
	C=%2
	D=%3
	E=%4
	F=%5
	P=%6
	PC=%7
	.XCREF A,B,C,D,E,F,P,PC

	DISKWR==3
	DISKRD==5
	DISKWC==7
	WCERR==1

	TBUFLN==100

	SWB=177570	;DATA SWITCHES

	RKER=177402	;MOVING HEAD DISK REGS
	RKCS=177404
	RKWC=177406
	RKBA=177410
	RKDA=177412

	PLATR1==20000
	PLATR2==40000
	PLATR3==60000

	DSKS=177460	;FIXED HEAD DISK REGS
	DSKWC=177462
	DSKCA=177464
	DSKA=177466
	DSKAE=177470
	DSKDBR=177472

	NRETRY==30



;STACK FRAME OFFSETS
	FFBCKP==0	;BY DEFINITION; POINTS TO PREV. STACK FRAME
	FENTRP==FFBCKP+2	;ORIG. ADDR OF THIS ENTRY; FOR ALFORD
	FNXNTRY==FENTRP+2	;NEXT ENTRY OF PUSHED DIRECTORY
	FDDESC==FNXNTRY+2	;DESCRIPTOR OFFSET IN THIS ENTRY
	FDBYTES==FDDESC+2	;DESCRIPTOR LENGTH
	FENTRY==FDBYTES+2	;START OF ACTUAL ENTRY

;ENTRY TYPES (TIMES 2 FOR DISPATCHING)
;A TYPE AS SEEN HERE, * 1000, = A TYPE AS IN TYPE FIELD
	PARENT==0
	DIREC==2
	FILE==4
;	LAST==6	
	SELF==10
	LINK==12
	ALFORQ==14
	BITS==16

;BITS IN FLAG BYTE
	MFISTB==1	;BLOCK EXISTS BIT (EOF POINTS TO EXISTING BLOCK)
	TYPEM==177761	;TYPE FIELD MASK
	SHRB==20	;SHARED BLOCK FLAGS (DON'T CLEAR IN BIT TABLE)
	ACCB==100	;ACCESS CODES EXIST
	EOFB==200	;EOF, DATE-TIME EXISTS	

;DESCRIPTOR BYTE TYPES
	DTYPEF==300	;TYPE-OF-DESCRIPTOR-BYTE FIELD
	DTSKP==0	;SKIP N AND GRAB 1 BLOCK
	DTCNT==100	;GRAB N+1 BLOCKS
	DTHOL==140	;HOLE OF N+1 BLOCKS
	DTSADR==200	;GRAB N+1 BLOCKS STARTING AT X (SET ADDR)
	DTSKCT==300	;SKIP N1 AND GRAB N2+1 BLOCKS
	DTCNTF==77	;FOR FIRST THREE TYPES, THE N FIELD
	DTSCSK==70	;FOR SKIP/COUNT, THE SKIP FIELD N1
	DTSCCT==7	; "      "    , THE COUNT FIELD N2

;CACHE CODING CONSTANTS
	SSR0=177572
	SSR1=177574
	SSR2=177576
	SSR3=172516
	KIAR=172340
	KIDR=172300
	KDAR=172360
	KDDR=172320

	SGMNTR==1	;1 MEANS SEGMENTER ON; 0 MEANS OFF
	BEBRV=4		;BUS ERROR BPT VECTOR

	MYPAG==5	;I-SPACE PAGE CHOSEN FOR ALTERATION
	MYPAR==KIAR+<MYPAG*2>	;ADDR OF PAGE ADDR REG (PAR) CORRES TO MYPAG
	MYADDR==MYPAG*20000	;BEG. LOC OF MYPAG
	MYOPAD==MYPAG*200	;BASE ADDR (IN PAR) OF MYPAG



	.STITL MACROS
.MACRO	FPUSH X
	.XLIST
	MOV X,(F)+
	.LIST
.ENDM

.MACRO	PUSH X
	.XLIST
	MOV X,-(P)
	.LIST
.ENDM

.MACRO	POP X
	.XLIST
	MOV (P)+,X
	.LIST
.ENDM

.MACRO	TEXT X
	.XLIST
	.ASCII /X/
	.BYTE 0
	.EVEN
	.LIST
.ENDM

.MACRO	TYPEIT X
	.XLIST
	JSR F,TXTYPE
	TEXT ^/X/
	.LIST
.ENDM

.MACRO	ERROR X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/ERROR--'X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	ENTERR X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/ERROR--ENTRY /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	TYPEIT ^/X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	BUG X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/BUG--'X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	MSG X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	FLTEXT X
	.XLIST
	.IRPC XC,^/X/
	.IFNZ .LENGTH ^/X/,-<.IRPCN+1>
		.LIST
		.BYTE ''XC
		.XLIST
	.IFF
		.LIST
		.BYTE 200+''XC
		.XLIST
	.ENDC
	.ENDM
	.LIST
.ENDM
	.STITL SET TRAP VECTORS TO HALT
.=0
.REPT 100
.XLIST
.+2
HALT
.LIST
.ENDR
	.STITL VARIABLES AND THINGS
	.=1000
	JMP SALV
	.=2000
PDL==.
;PDP10 COMMUNICATION AREA
;NOTE THAT THE 10 ACTS AS A SLAVE TO THE 11
COMPNT==40	;POINTER TO 10-11 COM AREA
.=<.!77>+1	;COM AREA MUST START ON MULTIPLE OF 100 BOUNDARY
ELVRDY:	0,0		;NON-ZERO IMPLIES 11 HAS DATA TO TRANFER
			;OR IS READY FOR NEXT TRANSFER
TENFUN:	0,0		;DIRECTION OF TRANSFER
			;0=> NO TRANSFER
			;1=> WRITE TO PDP10
			;-1=> READ FROM PDP10
TENRDY:	0,0		;NON-ZERO IMPLIES TEN HAS DATA TO TRANSFER
			;OR IS READY FOR NEXT DATA
TENBUF:	0,<DSKBUF_-6>&1777	;BUFFER ADDRESS

.IFNZ SGMNTR
LCSLOT:	-1		;NEXT SLOT TO THROW SOMEONE OUT OF
NCBLKS:	0		;NUMBER OF BLOCKS TO USE FOR CACHE
MEMHGH:	0		;HIGHEST MEMORY ADDRESS
CBLKTB:	.BLKW 200.	;GREATEST NO. CACHE BLKS POSSIBLE ON ANY PDP-11
.ENDC
DSKEM:	0		;EXTENDED MEMORY BITS FOR DISK ROUTINES
ERRCNT:	0	;COUNT OF ERRORS ON THIS CHECK
BACKCN:	203.*12.
BACKIN:	1
BACKTL:	-1000
RUGDSK:	0	;SET WHEN INITING A RUG DISK
OLDDSK:	0	;OLD DISK FUNCTION TO REPEAT ON WRITE CHECK ERROR
NDISK:	0	;NEW DISK POSITION
NBLOKS:	0	;COUNT OF BLOCKS IN FILE
DSCEOF:	0	;END OF DISK DESCRIPTOR FILE
TOFIND:	0	;ADDR OF ENTRY NAME TO BE FOUND
DIREND:	0	;END OF DIRECTORY (AS SET BY LOADIR)
FBACKP:	0	;POINTS TO PARENT ENTRY OF THIS DIRECTORY
NEXTF:	0	;POINTS TO NEXT AVAILABLE F-STACK FRAME
ENTRYP:	0	;POINTS TO CURRENT ENTRY IN CURRENT DIRECTORY
NXNTRY:	0	;TO NEXT ENTRY IN CURR. DIR.
ETYPE:	0	;TYPE * 2 OF THIS ENTRY
NBYTES:	0	;LENGTH OF ENTRY
FLAGS:	0	;RANDOM FLAGS IN ENTRY
DDESCR:	0	;OFFSET OF DISC BLOCK DESCRIPTOR
DBYTES:	0	;LENGTH OF DESCRIPTOR
DSCEND:	0	;POINTS TO END OF DESCRIPTOR
		;(CAN BE FOUND BY FTYPE)

VN:	0	;SLOT FOR VERSION NUMBER, IN ALFORD.
OENTRY:	0	;PTS TO PREV. ENTRY IN CURR. DIR., FOR ALPH. ORD.
OTYPE:	0	;IS IT A PARENT OR SELF ENTRY
OFLAGS:	0	;HAS IT A VERSION NUMBER
OVN:	0	;ITS VERSION NUMBER

BITFND:	0	;BIT FOUND SET IN BITTABLE 2 BY CKBIT2
BITLIM:	0	;FIRST !BYTE! AFTER END OF BIT TABLE
BITSAT:	0	;HOW MUCH OF BIT TABLE YOU'VE TRANSFERRED SO FAR
DIRCNG:	0	;HAS THE DIRECTORY BEEN MODIFIED
DISKIO:	0	;DIRECTION OF TRANSFER (DISKRD OR DISKWR)
BLOKNO:	0	;BLOCK NUMBER OF CURRENT DISK BLOCK
BLKLIM:	0	;FIRST BLOCK NO. NOT ON DISK
RNG01F:	.BYTE 0	;FLAGS FOR BCOMP, TO MANAGE GROUPING OF BITS
RNG10F:	.BYTE 0	; THAT DISAGREE IN OLD AND NEW BIT TABLES.
		;0 = NO SEQUENCE, 1 = SINGLETON,
		;2 = SEQ OPEN, BE SURE TO CLOSE IT
RANYBQ:	0	;STAYS 0 IF NO BAD BITS SEEN.
WCHDSK:	0	;WHICH PLATTER: 0=FIXED  20000=REMOVABLE
BLOKDO:	0	;WHAT TO DO WHEN DMARCH SAYS "BLOCK # N"
RETRYS:	0	;# RETRYS LEFT BEFORE COMPLAINT
DSKERR:	0	;DISK ERROR WORD
ERNTRYP:0	;POINTS TO LAST STACKED ENTRY VISITED BY BACKTRACE
BKFBKP:	0	;BACKTRACE'S STACK POINTER AS IT TRACES BACK

NCHR:	0	;NUMBER OF CHARS IN TYPEIN BUFFER
TBUFPT:	0	;PTR INTO BUFFER: FILLING AND EMPTYING
RUBING:	0	;NON-0 MEANS RUBBING OUT CHARS


TRNSLE:	-1000	;TRANSFER LENGTH
DOWHAT:	0	;ADDRESS OF DISPATCH TABLE FOR ENTRY TYPES

	.SBTTL DISPATCH TABLES
DSPTAB:	SALVQ	;^@
	SALVQ	;^A
	SALVQ	;^B
	COPY	;^C
	CNTLD	;^D
	SALVQ	;^E
	FRMT	;^F
	SALVQ	;^G
	SALVQ	;^H
	SALVQ	;^I
	SALVQ	;^J
	SALVQ	;^K
	SALVQ	;^L
	SALVQ	;^M
	SALVQ	;^N
	SALVQ	;^O
	SALVQ	;^P
	SALVQ	;^Q
	SALVQ	;^R
	SCAN	;^S
	TENCOM	;^T
	CNTLU	;^U
	SALVQ	;^V
	SALVQ	;^W
	SALVQ	;^X
	SALVQ	;^Y
	SALVQ	;^Z
	SALVQ	;^[
	SALVQ	;^\
	SALVQ	;^]
	SALVQ	;^^
	SALVQ	;^_
	SALVQ	; 
	SALVQ	;!
	SALVQ	;"
	SALVQ	;#
	SALVQ	;$
	SALVQ	;%
	SALVQ	;&
	SALVQ	;'
	SALVQ	;(
	SALVQ	;)
	SALVQ	;*
	SALVQ	;+
	SALVQ	;,
	SALVQ	;-
	SALVQ	;.
	SALVQ	;/
	SALVN	;0
	SALVN	;1
	SALVN	;2
	SALVN	;3
	SALVN	;4
	SALVN	;5
	SALVN	;6
	SALVN	;7
	SALVQ	;8
	SALVQ	;9
	SALVQ	;:
	SALVQ	;;
	SALVQ	;<
	SALVQ	;=
	SALVQ	;>
	SALVQ	;?
	SALVQ	;@
	SALVQ	;A
	BLOCKT	;B
	CHECK0	;C
	SALVQ	;D
	SALVQ	;E
	FXB0I0	;F
	GOGOGO	;G
	SALVQ	;H
	INIT0	;I
	SALVQ	;J
	SALVQ	;K
	SALVQ	;L
	SALVQ	;M
	SALVQ	;N
	SALVQ	;O
	SALVQ	;P
	SALVQ	;Q
	SALVQ	;R
	SALVQ	;S
	TRACKT	;T
	SALVQ	;U
	SALVQ	;V
	SALVQ	;W
	SALVQ	;X
	SALVQ	;Y
	ZERO	;Z
	SALVQ	;[
	SALVQ	;\
	SALVQ	;]
	SALVQ	;^
	SALVQ	;_
	SALVQ	;`
	SALVQ	;a
	BLOCKT	;b
	CHECK0	;c
	SALVQ	;d
	SALVQ	;e
	FXB0I0	;f
	GOGOGO	;g
	SALVQ	;h
	INIT0	;i
	SALVQ	;j
	SALVQ	;k
	SALVQ	;l
	SALVQ	;m
	SALVQ	;n
	SALVQ	;o
	SALVQ	;p
	SALVQ	;q
	SALVQ	;r
	SALVQ	;s
	TRACKT	;t
	SALVQ	;u
	SALVQ	;v
	SALVQ	;w
	SALVQ	;x
	SALVQ	;y
	ZERO	;z
	SALVQ	;{
	SALVQ	;|
	SALVQ	;}
	SALVQ	;~
	SALVQ	;Š
CKTAB1:	CKPAR	;DISPLATCH TABLE FOR PASS 1 (FIND SHARED BLOCKS)
	CKDIR
	CKFILE
	CKLAST
	CKSELF
	CKLINK
	ALFORD	;YES, CHECK ALPHABETICAL ORDER
	SETB12	;SET BIT TABLE 1, "OVERFLOW" TO TABLE 2

CKTAB2:	C2PAR	;DISPATCH TABLE FOR PASS 2 (MARK FILES SHARING BLOCKS)
	C2DIR
	C2FILE
	C2LAST
	C2SELF
	C2LINK
	SKPPNM	;SKIP PAST THE NAME
	CKBIT2	;SET DON'T DELETE FLAGS IF TABLE 2 SET


LOADX:	LODSKP
	LODCNT
	LODSAD
	LODSC

RTSPC:	RTS PC

BITSE:	FLTEXT ^/BITS/	;NAME OF BIT TABLE FILE
DESCRE:	FLTEXT ^/DESCR/	;NAME OF DISK DESCRIPTOR FILE
	.EVEN

TBUF:	.=.+TBUFLN
	0	;JUST IN CASE
	.STITL !THE! !SALVAGER!!!
SALV:	RESET		;INIT THE BUSS
	MOV #PDL,P	;INIT THE STACK POINTER
	MOV #-1000,TRNSLE	;INIT TRANSFER LENGTH

.IFNZ SGMNTR
	JSR PC,SEGSET	;TURN ON SEGMENTER
	JSR PC,MEMTST	;FIND NO. 512-WORD BLKS IN HIGH MEMORY
.ENDC
	JSR PC,ITYI	;INIT THE TYI
	TYPEIT ^/_SALV /	;_ MAKES A CRLF
	MOV #%FNAM2,B
	JSR PC,DECOUT
SALV2:	TYPEIT ^/_*/
SALV5:	JSR PC,TYI1
	MOV A,B
	ASL B
	JSR PC,@DSPTAB(B)
	BR SALV2

SALVN:	SUB #'0,A
	ASH #13.,A	;PUT IT INTO THE RIGHT PLACE
	MOV A,WCHDSK	;SET THE VARIABLE
	BR SALV5
SALVQ:	MOV #PDL,P
	TYPEIT ^/ ?/
	BR SALV2

FXB0I0:	TYPEIT ^/IXED HEAD DISK BLOCK 0 INIT_SURE? /
	JSR PC,TYI1
	CMP #' ,A
	BEQ GOFXB0
	CMP #'Y,A
	BNE SALVQ
GOFXB0:	JSR PC,CRLF
	JMP FXINIT

INIT0:	TYPEIT ^/NIT_SURE?/
	JSR PC,TYI1
	CMP #' ,A
	BEQ GOINIT
	CMP #'Y,A
	BNE SALVQ
GOINIT:	JSR PC,CRLF
	JMP INITD

CHECK0:	TYPEIT ^/HECK_/
	JSR PC,CHECK
	JMP SALV2

GOGOGO:	MOV #4,-(P)
	CLR WCHDSK	
1$:	JSR PC,CHECK
	ADD #20000,WCHDSK
	DEC (P)
	BNE 1$
	JMP 157002	;EXIT TO SITS

	.STITL WRITE OUT AN INITIAL BLOCK 0 ON FIXED HEAD DISK.
FXINIT:	MOV #FHIDIR,A	;POINT TO THE IMAGE
	MOV #DSKBUF,B	;WHERE TO PUT IT
	MOV #<<FHIDIZ-FHIDIR>/2>,C	;THE LENGTH IN WORDS
	MOV #2000,D	;THE LENGTH OF A DISK BLOCK
	MOV (A)+,(B)+	;COPY IT
	SOB C,.-2
	CLR (B)+	;CLEAR OUT THE REST
	SOB D,.-2
	PUSH WCHDSK	;SAVE THE DISK
	CLR BLOKNO	;WRITE BLOCK 0
	MOV #-1,WCHDSK	;SAY THE FIXED DISK
	JSR PC,DSKWR1	;WRITE IT
	POP WCHDSK
	JMP SALV2	;ALL DONE, THIS DISK CAN'T WRITE-CHECK.


	.STITL CHECK THE FILE SYSTEM
CHECK2:	MOV #FBASE,F
	MOV F,NEXTF
	MOV F,FBACKP
	MOV F,ERNTRYP
	MOV #-1,BLKLIM	;ALLOW ANY BLOCK # TILL YOU GET THE BIT TABLE
	MOV #46,BLOKNO
	JSR PC,DIRBLR	;GET FIRST BLOCK OF HEADER
	MOVB DIR+1,FLAGS	;GET ROOT HEADER FLAGS
	MOV #DIR,B	;GET THE END OF THE DIRECTORY
	ADD 6(B),B	;ADD THE EOF WORD TO THE POINTER
	MOV B,DIREND	;SAY IT IS THE END OF THE DIRECTORY
	MOV #DIR,ENTRYP	;POINT TO THE SELF ENTRY
	JSR PC,TYPEWD	;GET READY TO PUSH IT ONTO THE F STACK
	JSR PC,SKIPVN	;MAKE SURE THERE IS A DIRID
	ADD #10,E	;SKIP EOF AND DATE TIME
	JSR PC,SKPACC	;SKIP THE ACCES CODES
	JSR PC,SKPNAM	;SKIP THE NAME
	JSR PC,ATDESC	;ALL SET TO STACK
	MOV #DIR+14,A
	MOV #DIR+4,B	;KLUDGE FIRST DIRECTORY ENTRY
	MOV DDESCR,C
	ADD #DIR,C	;POINT TO THE FIRST OF DESCR.
CHECK1:	MOVB (A)+,(B)+	;COPY IT
	CMP A,C
	BLO CHECK1
	MOVB #200,(B)+
	MOVB #46,(B)+
	CLRB (B)+	;FAKE DESCRIPTOR
	CLRB (B)+
	BIC #1,B	;ROUND IT
	MOVB B,DIR	;FAKE LENGTH
	BIC #EOFB*400,DIR	;ELIMINATED THE EOF WORD
	JSR PC,TYPEWD
	JSR PC,SKIPVN
	JSR PC,SKPACC
	JSR PC,SKPNAM
	JSR PC,ATDESC
	JSR PC,PSHDIR	;SET UP BASE OF F-STACK
	MOV #-1,BLKLIM	;ALLOW ANY BLOCK #
	JSR PC,LOADIR	;GET WHOLE ROOT DIRECTORY
	MOV #BITSE,TOFIND
	JSR PC,FINDE	;FIND BITS FILE
	BEQ CKSYS1
	ERROR ^/NO BITS FILE/
CKSYS1:	MOV #FSTBLK,BLOKDO
	JSR PC,EDMARCH
	MOV DSKBUF,BLKLIM	;FIRST WORD OF FILE IS DISK LENGTH
	JSR PC,DESRF	;SET UP DESCRIPTOR FILE
CKSYS2:	RTS PC

DESRF:	MOV #DESCRE,TOFIND
	JSR PC,FINDE	;FIND DISK DESCRIPTOR FILE
	BEQ CKSYS4
	ERROR ^/NO DISK DESCRIPTOR/
CKSYS4:	JSR PC,L1BLKF	;LOAD 1-BLOCK FILE
	MOV B,DSCEOF	;L1BLKF RETURNS EOF ADDR IN B
	MOV #DSKBUF+2,E	;START AFTER THE BASE YEAR
	MOV #2,D	;2 SWAP AREAS
SRES1:	MOV (E)+,BLOKNO	;AREA STARTING AT BLOCK NO.
	MOV (E)+,C	;SO MANY BLOCKS
	BEQ SRES3	;NO BLOCKS
SRES2:	JSR PC,BTADR	;SET BIT FOR ONE BLOCK
	BISB A,DBITS2(B)
	INC BLOKNO
	SOB C,SRES2
SRES3:	SOB D,SRES1

SRES4:	CMP E,DSCEOF	;RESERVED BLOCKS WORDS TO END OF FILE
	BNE CKIT1	;EOF: BIT TABLE ALL SET!
	RTS PC
CKIT1:	BLO SRES5
	ERROR ^/DISK DESCRIPTOR EOF OUT OF SYNC?/
SRES5:	MOV (E)+,B	;WORD OFFSET IN BIT TABLE
	MOV (E)+,A	;MASK OF RESERVED BLOCKS
	BIS A,DBITS2(B)	;SET WHOLE WORD
	BR SRES4



CHECK:
.IIF NZ SGMNTR, JSR PC,CACHNT	;INITIALIZE CACHE BLK NO. TABLE
	CLR ERRCNT	;NO ERRORS SO FAR
	MOV #DBITS1,A	;CLEAR BOTH BIT TABLES
	MOV #20000,B	;2*4K WORDS
	CLR (A)+
	SOB B,.-2
	JSR PC,CHECK2
	TYPEIT ^\CHECKING DISK \
	MOV #DIR,B
	JSR PC,NAMOUT
	JSR PC,CRLF
CKIT:	MOV #CKTAB1,DOWHAT	;CHECK THE WORLD PASS 1!
	JSR PC,DOROOT
	MOV #DBITS2,A	;GET ALL THE USED BLOCKS -> TABLE 1
	MOV #DBITS1,B
	MOV #10000,C	;EACH TABLE 4K WORDS LONG
	BIS (A)+,(B)+	;.OR. TABLE 2 INTO TABLE 1
	SOB C,.-2
	MOV #CKTAB2,DOWHAT	;CHECK FOR SHARED BLOCKS!
	JSR PC,DOROOT
			;FINALLY:
		;1:  COMPARE BIT TABLE 1 WITH DISK.
	MOV BLKLIM,A	;GET LENGTH OF BIT TABLE IN BYTES
	DEC A		;(JUST FOR DMARCHING)
	ASH #-3,A
	INC A		;FIRST BYTE AFTER BIT TABLE
	BIC #160000,A	;CLEAR SIGN EXTEND
	MOV A,BITLIM

	MOV #BITSE,TOFIND
	JSR PC,FINDE

	MOV #BITSRD,BLOKDO
	JSR PC,BITSIO	;READ IN THE BIT TABLE INTO TABLE 2

	CLR RANYBQ
	CLR C		;DO THE COMPARE: STOP WHEN BLOCK NO. = BLKLIM
	CLR RNG01F	;ASSERT NO 0->1 OR 1->0 (CLRS BOTH FLAGS)
	MOV #DBITS1,D
	MOV #DBITS2,E

BCOMP1:	MOV (D),A
	MOV (E),B
	BIC (E)+,A	;GET DBITS1 - 2: MARKING A "FREE" BLOCK
	BIC (D)+,B	;GET DBITS2 - 1: MARKED BUT NOT FOUND

	MOV #20,F
BCOMP2:	ASHC #-1,A	;RIGHT SHIFT ONE BOTH
	BCC 1$
	JSR PC,BAD10	;FOUND A 2-1 (1 -> 0)
	BR BCOMP4
1$:
	TST B
	BGE 2$
	JSR PC,BAD01	;FOUND A 1-2 (0 -> 1) BAD NEWS
	BR BCOMP4
2$:
	JSR PC,BCGOOD

BCOMP4:	INC C		;COUNT THE BLOCK
	CMP C,BLKLIM	;EXIT IF ALL BLOCKS DONE ON DISK
	BHIS BCOMP3
	SOB F,BCOMP2
	BR BCOMP1

BCOMP3:	JSR PC,BCGOOD
	TYPEIT ^/_DISK /
	MOV #FBASE+FENTRY,B
	JSR PC,NAMOUT
	TYPEIT ^/ REFRESHED_/
	TST RANYBQ	;CHANGED ANY BITS?
	BEQ NWRITE
	TST ERRCNT	;ANY ERRORS?
	BEQ WRITEB
	TYPEIT ^/WRITE BIT TABLE?  /
	JSR PC,TYI1
	CMP #'Y,A
	BNE NWRITE		;DO IT
	TYPEIT ^/ARE YOU SURE YOU KNOW WHAT YOU ARE DOING?/
	JSR PC,TYI1
	CMP #'Y,A
	BNE NWRITE		;DO IT

WRITEB:	JSR PC,CRLF

		;2:  STORE TABLE 1 AS NEW BIT TABLE
	MOV #BITSWR,BLOKDO
	JSR PC,BITSIO	;WRITE OUT NEW BIT TABLE


	TYPEIT ^/WRITTEN_/
NWRITE:	RTS PC

SCAN:	TYPEIT ^/SCAN/
.IFZ 105
;SCAN DISK A TRACK AT A TIME FOR BAD BLOCKS
	MOV WCHDSK,-(P)	;BLOCK TO START WITH
;THE TOP OF THE STACK IS ALWAYS THE FIRST BLOCK THAT MIGHT HAVE AN ERROR
TRKLOP:	MOV #1,RKCS	;RESET THE WORLD
	MOV (P),RKDA
	MOV #DSKBUF,RKBA
	MOV #-24.*256.,RKWC	;A WHOLE TRACK
	MOV #4405,RKCS	;READ, BUT DON'T INCREMENT ADDRESS
			;AND STOP ON SOFT ERROR
	TSTB RKCS
	BPL .-4		;WAIT FOR THE TRANSFER TO FINISH
	TST RKCS	;IS THERE ANY ERROR?
	BLT ERRLOP	;YES, CHECK IT OUT
	MOV RKDA,(P)
	BR TRKLOP
ERRLOP:	MOV #256.,C	;NUMBER OF TIMES TO DO THIS
	BIT #100,RKER	;IS IT THE END OF THE DISK?
	BNE NOSCN1	;YES, DONE
	PUSH (P)	;RECOPY THE DISK ADDRESS
ERLP2:	MOV #1,RKCS
	MOV #-256.,RKWC		
	MOV #4405,RKCS	;READ BUT DONT INC
	TSTB RKCS
	BPL .-4
	TST RKCS	;ERROR
	BGE ERLP1	;NO
	BIT #100,RKER	;END OF DISK?
	BNE NOSCN1	;YES
	TYPEIT ^/_SCAN ERROR RKDA=/
	MOV RKDA,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/RKER=/
	MOV RKER,B
	JSR PC,OCTOUT
	JSR PC,CRLF
ERLP1:	MOV RKDA,(P)	;GET NEW 
	SOB C,ERLP2
	TST (P)+
	JMP TRKLOP
NOSCN1:	ADD #4,P	;POP ARGS
.ENDC
	CLR -(P)
SCANLP:	CMP #313*12.,(P)
	BEQ SCANL1
	MOV (P),B
	JSR PC,DBFRED
	INC (P)
	BR SCANLP
SCANL1:	TST (P)+
	JMP SALV2
;GIVEN A LAST-CHAR-FLAGGED STRING IN (A)+,
;FIND A FILE WITH THAT NAME.
FINDE:	MOV #DIR,ENTRYP
FINDE1:	JSR PC,FIND
	BEQ FOUNDE
FIND1:	RTS PC

FIND:	JSR PC,TYPEWD
	JSR PC,SKIPVN
	BIT #EOFB,FLAGS
	BEQ 1$
	ADD #10,E
1$:	BIT #ACCB,FLAGS
	BEQ 2$
	JSR PC,SKPACC
2$:	MOV TOFIND,C
	JSR PC,CMPNAM
	BEQ FIND1
	CMP NXNTRY,DIREND
	BEQ NFOUND
	BLO FINDE2
	ENTERR ^/ OVERSHOT DIRECTORY END/
	BPT
FINDE2:	MOV NXNTRY,ENTRYP
	BR FIND

FOUNDE:	JSR PC,ATDESC
	SEZ
	RTS PC

NFOUND:	CLZ
	RTS PC

FILLEN:	MOV #CNTBKN,BLOKDO
	CLR A
	CLR B
	JSR PC,EDMARCH
	MOV A,B
	RTS PC

CNTBKN:	INC A
	RTS PC




LENFIL:	MOV #CNTBLK,BLOKDO
	CLR A
	CLR NBLOKS
	JSR PC,EDMARCH
	MOV NBLOKS,B
	BEQ LENFL2
	MOV ENTRYP,A	;POINT TO ENTRY
	ADD #4,A	;POINT TO EOF WORD
	MOV (A)+,C	;GET THE PAGE NO.
	MOV (A)+,D	;GET THE BYTE COUNT
	ASH #3,D	;GET IT LINED UP
	ASHC #-13.,C	;GET THE NUMBER OF BLOCKS
	BIT #MFISTB,FLAGS	;BLOCK EXIST?
	BEQ 1$
	INC D
1$:	CMP D,B		;THE SAME?
	BEQ LENFL2	;YES
	ENTERR ^/ BAD LENGTH FILE/
LENFL2:	RTS PC

CNTBLK:	INC NBLOKS	;COUNT A BLOCK
	RTS PC
	;DMARCH ROUTINE TO GET THE FIRST BLOCK OF A FILE
FSTBLK:	MOV #DSKBUF,B
	JSR PC,DSKRED
	ADD #6,P	;CROCK!!!
			;POP OUT OF FSTBLK, DOBLOK, @LOADX(B), DMARCH
	RTS PC		;BACK TO JSR PC,DMARCH


L1BLKF:	MOV #L1BLK,BLOKDO	;LOAD A ONE-BLOCK FILE
	JSR PC,EDMARCH
	MOV ENTRYP,D	;POINT TO THE ENTRY
	MOV 6(D),B	;GET THE EOF
	ADD #DSKBUF,B
	RTS PC		;B POINTS TO END OF FILE

L1BLK:	MOV #ER1BLK,BLOKDO
	MOV #DSKBUF,B
	JSR PC,DSKRED
	RTS PC

ER1BLK:	ERROR ^/DESCR FILE TOO LONG/
	BPT
	BR .-2
BITSIO:	JSR PC,EDMARCH	;CALLED BEFORE AND AFTER BCOMP
	CMP BITSAT,BITLIM	;TO I/O THE BIT TABLE
	BHIS BITSI1
	ERROR ^/BIT TABLE TOO SHORT/
BITSI1:	RTS PC


BITSRD:	MOV #DSKBUF,B	;READ IN FIRST BLOCK OF BIT TABLE
	JSR PC,DSKRED

	PUSH C
	MOV #777,C	;BLT 1000-1 WORDS
	MOV #DSKBUF+2,A	;SKIPPING BLKLIM WORD
	MOV #DBITS2,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #1776,BITSAT	;WE'VE READ IN THIS MANY BYTES
	MOV #BITSR2,BLOKDO	;NEXT BLOCK, DO THIS
	RTS PC

BITSR2:	CMP BITSAT,BITLIM	;READ IN NEXT BLOCK IF NOT OVERSHOT
	BLO BITSR3
	ERROR ^/BIT TABLE TOO LONG/

BITSR3:	MOV #DSKBUF,B
	JSR PC,DSKRED

	PUSH C
	MOV #1000,C	;BLT 1000 WORDS
	MOV #DSKBUF,A
	MOV #DBITS2,B
	ADD BITSAT,B	;TO CURRENT PLACE IN BIT TABLE 2
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	ADD #2000,BITSAT	;WE READ IN THIS MANY MORE BYTES
	RTS PC

BITSWR:	MOV BLKLIM,DSKBUF	;WRITE FIRST BLOCK OF BIT TABLE:
				;FIRST WORD IS # BLOCKS ON DISK
	PUSH C
	MOV #777,C
	MOV #DBITS1,A	;BLT TABLE 1 TO DSKBUF+2, 1000-1 WORDS
	MOV #DSKBUF+2,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #DSKBUF,B
	JSR PC,DSKWRT	;WRITE THE BLOCK

	MOV #1776,BITSAT	;THIS MANY BYTES TRANSFERED
	MOV #BITSW2,BLOKDO	;DO THIS TO NEXT BLOCK
	RTS PC

BITSW2:	CMP BITSAT,BITLIM	;WRITE NEXT BLOCK UNLESS OVERSHOT
	BLO BITSW3
	ERROR ^/BIT TABLE TOO LONG/

BITSW3:	PUSH C
	MOV #1000,C	;NOW BLT 1000 MORE WORDSG OUT
	MOV #DBITS1,A
	ADD BITSAT,A	;FROM WHERE YOU LEFT OFF
	MOV #DSKBUF,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #DSKBUF,B
	JSR PC,DSKWRT	;WRITE THE BLOCK

	ADD #2000,BITSAT	;YOU'VE DONE THIS MANY MORE BYTES NOW
	RTS PC
	;COMPLAIN ABOUT OLD BIT TABLE
BAD01:	JSR PC,CLOS10
	JSR PC,OPEN01
	RTS PC

BAD10:	JSR PC,CLOS01
	JSR PC,OPEN10
	RTS PC

BCGOOD:	JSR PC,CLOS01
	JSR PC,CLOS10
	RTS PC


OPEN01:	TSTB RNG01F	;IS THIS RANGE ALREADY OPEN?
	BNE OPN01B
	JSR PC,BBFOUN
	JSR PC,RNGEDG	;NO, TYPE ITS OPENING NUMBER
	INCB RNG01F	;ASSERT JUST OPENED
	RTS PC
OPN01B:	CMPB #2,RNG01F
	BLE 1$
	INCB RNG01F	;ASSERT LONG RANGE
1$:	RTS PC		;(OR ALREADY LONG RANGE)

OPEN10:	TSTB RNG10F	;IS THIS RANGE OPEN?
	BNE OPN10B
	JSR PC,BBFOUN	;BAD BIT FOUND: SET RANYBQ ("ANY BADBIT?")
	JSR PC,TAB	;NO, GO TO 1->0 COLUMNL
	JSR PC,RNGEDG	;AND TYPE ITS OPENING NUMBER
	INCB RNG10F	;ASSERT NOW JUST OPENED
	RTS PC
OPN10B:	CMPB #2,RNG10F
	BLE 1$
	INCB RNG10F	;NEW LONG RANGE
1$:	RTS PC

BBFOUN:	TST RANYBQ	;FIRST BAD BIT?
	BNE BBFOU1
	TYPEIT ^/_0 -> 1  1 -> 0_/
	INC RANYBQ	;NO MORE FIRST BAD BITS.
BBFOU1:	RTS PC

CLOS01:	DECB RNG01F	;IS THIS RANGE MORE THAN 1 LONG?
	BLE CLS01B	;NO, JUST CLEAR IT.
	TST RANYBQ
	BNE 1$
	BPT		;SHOULDN'T CLOSE IF NOT OPENED!!
1$:	TYPEIT ^/  TO_/	;ELSE STATE IT'S A LONG RANGE
	DEC C
	JSR PC,RNGEDG	;AND IT ENDS 1 BEFORE HERE
	INC C
CLS01B:	CLRB RNG01F	;AND CLEAR IT
	RTS PC

CLOS10:	DECB RNG10F	;IS THIS RANGE MORE THAN JUST BEGUN?
	BLE CLS10B	;NO, JUST CLEAR ITL
	TST RANYBQ
	BNE 1$
	BPT		;NOT IF NOT OPENED!
1$:	JSR PC,TAB	;ELSE (IN 1->0 COLUMN)
	TYPEIT ^/  TO_/	;STATE IT'S A LONG RANGE
	JSR PC,TAB
	DEC C
	JSR PC,RNGEDG	;AND IT ENDS 1 BEFORE HERE
	INC C
CLS10B:	CLRB RNG10F	;AND CLEAR IT
	RTS PC

TAB:	TYPEIT ^/        /	;6 SPACES + 2 FOR MARGIN
	RTS PC

RNGEDG:	PUSH A
	PUSH B
	MOV C,B		;TYPE OUT BLOCK NUMBER IN C
	JSR PC,OCTOUT	;(MAY BE DIDDLED)
	JSR PC,CRLF
	POP B
	POP A
	RTS PC
	.STITL CRUNCH A DIRECTORY
DOROOT:	JSR PC,DODIRA	;DO THE DIRECTORY AS USUAL
	MOV DOWHAT,A	;EXCEPT WHEN IT COROUTINES BACK
			;AFTER DOING THE HEADER,
	JSR PC,@BITS(A)	;ALSO SET/CHECK THE HEADER'S BLOCK BITS.
	JSR PC,@(P)+	;NOW RETURN TO DODIRA
	RTS PC		;AND WHEN IT RETURNS, YOU'RE ALL DONE.

DODIR:	JSR PC,DODIRA	;DO THE DIRECTORY
	JSR PC,@(P)+	;DOING NOTHING EXTRA AFTER THE HEADER
	RTS PC		;AND DONE

DODIRA:	JSR PC,LOADIR	;USES PUSHED ENTRY ON F-STACK,
			;SETS DIREND
	MOV #DIR,ENTRYP
	JSR PC,TYPEWD	;SETS E,TYPE,NBYTES,NXNTRY,FLAGS,DSCEND
	CMP #SELF,ETYPE	;HEADER ENTRY?
	BEQ DODIR1
	ENTERR ^/ FIRST BUT NOT SELF ENTRY, GIVING UP ON THIS DIR/	;UGH, GROSSLY CLOBBERED
	JMP DODONE
DODIR1:	MOV DOWHAT,A	
	JSR PC,@SELF(A)	;PROCESS THE HEADER
	JSR PC,@(P)+	;COROUTINE WITH NEXT LEVEL UP--
			;ASK TO DO AFTER THE HEADER.
DODIR2:	MOV NXNTRY,ENTRYP
	JSR PC,TYPEWD
	CMP #PARENT,ETYPE
	BEQ DODIR3
	ENTERR ^/ SECOND BUT NOT PARENT, GIVING UP ON THIS DIR/
	JMP DODONE
DODIR3:	MOV DOWHAT,A
	JSR PC,@PARENT(A)	;PROCESS PARENT HEATER

DOENTRY::	CMP NXNTRY,DIREND
	BNE 1$
	JMP DODONE	;HIT END OF DIRECTORY
1$:	BLO DOENT3
	ENTERR ^/ OVERSHOT DIRECTORY END/
	BPT
	BR .-2

DOENT3:	MOV ENTRYP,OENTRY	;SAVE LAST ENTRY POINTER
	JSR PC,TYPEWD	;GET LAST ENTRY'S TYPE AND FLAGS AGAIN!
	MOV ETYPE,OTYPE	;SAVE THEM
	MOV FLAGS,OFLAGS

	MOV NXNTRY,ENTRYP	;NOW FOR NEXT ENTRY!!
	JSR PC,TYPEWD
	CMP #SELF,ETYPE
	BNE DOENT2	;CAN'T HAVE TWO HEADERS
	ENTERR ^/ IS 2ND SELF ENTRY/
	BR DODONE	;PRETEND END OF DIR
DOENT2:	CMP #PARENT,ETYPE
	BNE DOENT4
	ENTERR ^/ IS 2ND PARENT ENTRY/
	BR DODONE
DOENT4:	MOV DOWHAT,A	;CHECK ALPHABETICAL ORDER (ON PASS 1)
	JSR PC,@ALFORQ(A)	;ALWAYS SKIPS VERSION NUMBER,EOF,AND ACCESS CODES
	JSR PC,SKPACC
	MOV DOWHAT,A
	ADD ETYPE,A	;DISPATCH ON TYPE OF ENTRY
	JSR PC,@(A)	;PROCESS THIS ENTRY
	JMP DOENTRY

DODONE:	JSR PC,PUTDIR	;IF DIRECTORY MODIFIED, REWRITE IT.
	RTS PC
	.STITL PASS 1 CRUNCH-ENTRY ROUTINES
CKSELF:	BIT #EOFB,FLAGS
	BNE CKSLF3
	ERROR ^/NO EOF IN SELF ENTRY/
	RTS PC
CKSLF3:	MOV FBACKP,D
	MOV D,C
	ADD #FENTRY+4,C	;POINT TO THE DIRECTORY ENTRY
	JSR PC,SKIPVN
	ADD #10,E	;SKIP THE  EOF AND DATE
	JSR PC,CMPNAM	;NAMES THE SAME?
	BEQ CKSLF1	;YES
CKSLF2:	ERROR ^/SELF ENTRY DOESN'T DESCRIBE SELF/
	RTS PC
CKSLF1:	JSR PC,ATDESC
CKSLF4:	JSR PC,CMPDSR
	BNE CKSLF2
	RTS PC

CKPAR:	BIT #EOFB,FLAGS	;IS THERE A EOF
	BEQ CKPAR4	;NO,GOOD
	ERROR ^/PARENT HAS EOF BIT/
	RTS PC
CKPAR4:	BIT #ACCB,FLAGS	;ARE THERE ACCESS CODES
	BEQ CKPAR5
	ERROR ^/PARENT HAS ACCESS CODE/
	RTS PC
CKPAR5:	MOV FBACKP,D	;GET OWN DIRECTORY ENTRY (ON STACK)
	MOV (D),C	;GET THE 
	MOV C,D		;COPY IT
	ADD #FENTRY+4,C	;GET NAME FROM ENTRY
	JSR PC,SKIPVN	;SKIP THE VERSION NUMBER
CKPAR3:	JSR PC,CMPNAM	;(COMPARE NAMES IN (C)++ AND (E)++)
	BNE CKPAR2	;NOT THE SAME
	JSR PC,ATDESC	;SET DDESCR (=OFFSET), DBYTES FOR HEADER DESCR
			;(DESCRIBES PARENT)
	BVS CKPWIN
CKPAR6:	MOV D,C
	ADD #FENTRY,C	;GO TO START OF ENTRY
	ADD FDDESC(D),C	;AND TO START OF DESCRIPTOR
	JSR PC,CMPDSR	;ARE THE DESCRIPTORS THE SAME
	BEQ CKPWIN	;SAME, WE ARE WINNERS
CKPAR2:	ERROR ^/PARENT ENTRY DOES NOT DESCRIBE PARENT/
CKPWIN:	RTS PC

SKPPNM:	JSR PC,SKIPVN
	BIT #EOFB,FLAGS
	BEQ 1$
	ADD #10,E
1$:	JSR PC,SKPACC
	JSR PC,SKPNAM
	RTS PC

C2PAR:	JSR PC,SKIPVN
	JSR PC,SKPNAM
	JSR PC,ATDESC
	RTS PC

C2SELF:	JSR PC,SKIPVN
	ADD #10,E
	JSR PC,SKPACC
	JSR PC,SKPNAM
	JSR PC,ATDESC
	RTS PC

C2LINK:
CKLINK:	ENTERR ^/ IS A LINK; FEATURE NOT IMPLEMENTED/
	RTS PC

C2LAST:
CKLAST:	ENTERR ^/ IS A LAST, FEATURE FLUSHED/
	RTS PC


C2FILE:
CKFILE:	BIT #EOFB,FLAGS
	BNE CKFIL1
	ERROR ^/NO EOF IN FILE ENTRY/
CKFIL1:	JSR PC,ATDESC	;SET DDESCR AND DBYTES FOR DESCRIPTOR
	BVS CKFIL2
	JSR PC,LENFIL	;CHECK FOR REASONABLE LENGTH OF FILE
	MOV DOWHAT,A
	JSR PC,@BITS(A)	;SET BITS IN TABLE 1; IF SET, SET TABLE 2
CKFIL2:	RTS PC		;ALL DONE!!

C2DIR:
CKDIR:	BIT #EOFB,FLAGS
	BEQ CKDIR1
	ERROR ^/EOF IN DIRECTORY ENTRY/
	RTS PC
CKDIR1:	BIT #ACCB,FLAGS
	BEQ CKDIR2
	ERROR ^/ACCESS CODES IN DIRECTORY ENTRY/
	RTS PC
CKDIR2:	JSR PC,ATDESC	;DDESCR AND DBYTES
	BVS CKDIR3
	MOV DOWHAT,A
	JSR PC,@BITS(A)	;SET BITS
	JSR PC,PUTDIR	;REWRITE DIRECTORY IF MODIFIED
	JSR PC,PSHDIR	;PUSH THIS ENTRY ONTO THE F-STACK
	JSR PC,DODIR	;CRUNCH THE DIRECTORY
	JSR PC,POPDIR	;POP ENTRY
	JSR PC,LOADIR	;RELOAD CURRENT DIRECTORY
CKDIR3:	RTS PC

	.STITL WALK-THROUGH-AN-ENTRY ROUTINES
TYPEWD:	;GIVEN AN ENTRYP, GETS TYPE, NBYTES, NXNTRY, FLAGS, AND DSCEND
	;AND SETS E POINTING TO THE VERSION NUMBER OR DIRID
	MOV ENTRYP,E
	MOVB (E)+,C	;SET UP THE NUMBER OF BYTES
	MOVB C,NBYTES	;SET IN NUMBER OF BYTES
	MOVB (E)+,A	;GET FLAGS BYTE
	MOV A,B		;COPY IT
	BIC #TYPEM,A	;GET JUST TYPE
	MOV A,ETYPE
	ADD ENTRYP,C	;POINT TO NEXT ENTRY
	CMP C,DIREND
	BLOS TYPEW2
	ENTERR ^/ OVERFLOWS DIRECTORY/
	MOV DIREND,C	;MAKE NXNTRY = DIREND
TYPEW2:	MOV C,DSCEND	;SET UP DESCRIPTOR END POINTER
	INC C
	BIC #1,C	;ROUND IT UP
	MOV C,NXNTRY
	MOV B,FLAGS
	RTS PC

SKPNAM:	JSR PC,EBYTE	;GET BYTE OF ENTRY
	BVS NAMERR	;COMPLAIN ON ENTRY OVERFLOW
	TSTB A		;IS THE CHAR FLAGGED?
	BGE SKPNAM	;SKIP TO NEGATIVE BYTE (LAST OF NAME)
	RTS PC


CMPDSR:	JSR PC,EBYTE
	BEQ CMPDS1	;GOT LAST BYTE
	BVS CMPDS2	;NO BYTE
	CMPB (C)+,A	;IS IT THE SAME
	BNE CMPDS2	;NO
	BR CMPDSR
CMPDS1:	CMPB (C)+,A
	BNE CMPDS2
	SEZ
	RTS PC
CMPDS2:	CLZ
	RTS PC

CMPNAM:	JSR PC,EBYTE
	BVS NAMERR
	CMPB (C)+,A
	BNE CMPNMF	;MISMATCH
	TSTB A
	BGE CMPNAM	;200 BIT ENDED BOTH NAMES
	SEZ
	RTS PC		;RETURN WITH Z-BIT SET
CMPNMF:	TSTB A
	BLT 1$
	JSR PC,SKPNAM
1$:	CLZ
	RTS PC
NAMERR:	ENTERR ^/: NAME OVERFLOWS ENTRY/
	CLZ
	RTS PC

ALFCMP:	JSR PC,EBYTE	;GET BYTE OF FIRST NAME
	TSTB (C)	;HAS THE SECOND ENDED
	BLT ALFCM1	;YES
	CMPB (C)+,A	;ARE THE BYTES THE SAME
	BEQ ALFCMP	;NO
	PUSH A
	BLT 1$
	JSR PC,SKPNAM
1$:	POP A		;HAS FIRST ENDED
	BMI ALFCM2	;YES
	CMPB -(C),A	;COMPARE THEM
	RTS PC
ALFCM2:	BIC #177600,A	;GET THE CHARACTER
	CMPB -(C),A	;CMP THEM
	RTS PC
ALFCM1:	PUSH A		;SAVE IT
	BLT 1$		;YES
	JSR PC,SKPNAM	;SKIP THE REST OF THE NAME
1$:	CMPB (C),(P)+	;ARE THEY THE SAME
	RTS PC


SKIPVN:	JSR PC,EBYTE
	BVS SKPVNE
	JSR PC,EBYTE
	BVC SKPVN1
SKPVNE:	ENTERR ^/: VN OVERFLOWS ENTRY/
SKPVN1:	RTS PC

SKPACC:	BIT #ACCB,FLAGS	;ACCESS SHOULD NOT APPEAR AT FIRST
	BEQ SKPVN1
SKPAC2:	JSR PC,EBYTE	;GOOD ACCESS CODES COME IN THREES
	BVS SKPACE
	JSR PC,EBYTE
	BVS SKPACE
	JSR PC,EBYTE
	BVS SKPACE
	TSTB A	;NEG. THIRD BYTE IS LAST TRIPLET
	BGE SKPAC2
	RTS PC
SKPACE:	ENTERR ^/: ACCESS OVERFLOWS ENTRY/
	RTS PC

ATDESC:	MOV E,DDESCR
	SUB ENTRYP,DDESCR	;GET OFFSET OF DESCRIPTOR IN ENTRY
	MOV DSCEND,DBYTES
	SUB E,DBYTES	;AND LENGTH OF DESCRIPTOR
	BGE ATDES1
	ENTERR ^/: NO ROOM FOR DESCRIPTOR/
	SEV
ATDES1:	RTS PC

EBYTE:	MOVB (E)+,A	;GET A BYTE OF ENTRY
	CMP DSCEND,E	;COMPLAIN ON OVERFLOW
	BHIS 1$
	SEV
1$:	RTS PC
	;THIS ENTRY MUST FOLLOW THE LAST IN ALPHABETICAL ORDER


ALFSR1:	POP C
	MOV NXNTRY,ENTRYP
ALFSRT:	CMP ENTRYP,DIREND
	BEQ ALFSR2
	JSR PC,TYPEWD
	MOV ENTRYP,OENTRYP
	PUSH C
	JSR PC,ALFCMP
	BGT ALFSR1
	POP C
ALFSR2:	RTS PC



ALFORD:	JSR PC,SKIPVN
	BIT #EOFB,FLAGS
	BEQ 1$
	ADD #10,E	;POINT AFTER EOF WORD
1$:	JSR PC,SKPACC	;SKIP ACCESS CODES
	CMP #SELF,OTYPE	;DON'T COMPARE IF LAST ENTRY WAS HEADER
	BNE ALFOR5	;OTHERWISE DO COMPARE
ALFRET:	JSR PC,SKPNAM	;SKIP THE NAME
	RTS PC
ALFOR5:	CMP #PARENT,OTYPE	;DONT COMPARE IF LAST WAS PARENT
	BEQ ALFRET
ALFOR1:	MOV OENTRY,C	;LAST NAME TO THE STARTING LINE
	TST (C)+	;(SKIP TYPE AND FLAGS)
	MOV (C)+,OVN	;GET OLD VERSION NUMBER
	CMP OTYPE,#DIREC	;IS IT A DIRECTORY?
	BNE 1$		;NO , THEN GOOD VERSION NUMBER
	MOV #-1,OVN	;NO REAL VERSION NUMBER, JUST DIRID
1$:	BIT #EOFB,OFLAGS	;EOF?
	BEQ 2$
	ADD #10,C	;SKIP THEM
2$:	BIT #ACCB,OFLAGS	;ARE THERE ACCESS CODES
	BEQ ALFOR2	;NO
ALFOR3:	ADD #2,C	;SKIP FIRST WORD	
	TSTB (C)+	;IS THIS THE LAST
	BMI ALFOR3	;NO
ALFOR2:	JSR PC,ALFCMP	;WHICH IS BIGGER
	BEQ ALFOR4	;THE SAME, CHECK THE VERSION NUMBERS	
	BLE ALFOR9		;THE OLD ENTRY WAS BIGGER!!!!!!
ALFOR6:	ERROR ^/ENTRY OUT OF ORDER/
	RTS PC
ALFOR4:	MOV ENTRYP,A	;POINT TO THE START OF THIS ENTRY
	TST (A)+	;SKIP HEADER
	MOV (A)+,VN	;GET THE VERSION NUMBER
	CMP ETYPE,#DIREC	;IS IT A DIRECTORY
	BEQ ALFOR6	;IF IT IS, THEN THE VERSION # IS -1, AND AT LEASE EQUAL TO
			;PREVIOUS ONE
	CMP OVN,VN
	BGE ALFOR6	;OLD >= NEW NO GOOD
ALFOR9:	RTS PC

	.STITL PUSH AND POP DIRECTORY STACK
PSHDIR:	MOV NEXTF,F	;GET NEXT SLOT
	MOV FBACKP,(F)	;SAVE BACK POINTER FROM HERE
	MOV F,FBACKP	;AND BACK POINTER TO HERE
	TST (F)+
	FPUSH ENTRYP	;FOR ALPHABETIZING
	FPUSH NXNTRY	;WHEN DONE WITH THIS DIRECTORY ENTRY
	FPUSH DDESCR	;OFFSET OF DESCRIPTOR IN SAVED ENTRY
	FPUSH DBYTES	;LENGTH OF DESCRIPTOR
	MOV ENTRYP,E
	MOV NBYTES,A
	INC A
	ROR A		;PUSH ENTRY BY WORDS
PSHDR2:	FPUSH (E)+	;NEXT WORD OF ENTRY
	SOB A,PSHDR2
	CMP F,#FEND-100
	BHIS 1$
	MOV F,NEXTF	;NEXT SLOT IS AFTER THE ENTRY
	RTS PC
1$:	ERROR ^/OVERPUSH/
	BPT
	RTS PC

POPDIR:	CMP #FBASE,FBACKP
	BLO POPDR2
	BUG ^/OVERPOP?/
POPDR2:	MOV FBACKP,F	;ENTRY IS POPPED
	MOV F,NEXTF	;FREE POPPED SLOT
	MOV (F),FBACKP	;STEAL BACK POINTER OUT OF POPPED ENTRY
	CMP F,ERNTRYP	;POPPED BACK TO ERRORSTUMP?
	BHI POPDR4	;ERRORSTUMP STILL BELOW YOU
	BEQ POPDR3	;SAW OFF ERRORLIMB AS YOU CLIMB BACK.
	BUG ^/ERRORLIMB LEFT HANGING??/
POPDR3:	MOV FBACKP,ERNTRYP	;MOVE IT DOWN THE STACK
POPDR4:	MOV FENTRP(F),ENTRYP	;GET OLD ENTRYP FOR ALPHABETICALS
	MOV FNXNTRY(F),NXNTRY	;AND NEXT ENTRYP
	RTS PC		;I THINK ALL THE REST PUSHED HAS BEEN USED.
	.STITL DISK-BLOCK FUNNIES (LOAD/REWRITE, SET/CHECK BIT TABLE)
;ALWAYS DO LOADIR, PUTDIR IN MATCHED PAIRS:
;LOADIR (DODIR)
;PUTDIR  (CKDIR.1)
; LOADIR (DODIR)
; PUTDIR (DODONE)
;LOADIR  (CKDIR.2)
;PUTDIR (DODONE)
;ETC.
;NOT NESTED PAIRS.  PUT THE DIR WHENEVER YOU'RE ABOUT TO LOAD ANOTHER
;AS AT CKDIR AND DODONE.
;THIS MAKES DIRCNG ACT PROPERLY AT PUTDIR.

PUTDIR:	TST DIRCNG	;REWRITE DIRECTORY IF MODIFIED
	BEQ PUTDI1

	TYPEIT ^/REWRITING DIR /
	PUSH A
	JSR PC,BACKTR
	JSR PC,CRLF
	POP A

	MOV #DIRBLW,BLOKDO	;REWRITE DIRECTORY
	JSR PC,IODIR
	CLR DIREND
PUTDI1:	RTS PC

LOADIR:	CLR DIRCNG	;USED IN NEXT PUTDIR
	MOV #DIRBLR,BLOKDO	;LOAD A DIRECTORY
	JSR PC,IODIR
	MOV DIR+6,B
	ADD #DIR,B
	MOV B,DIREND
	RTS PC

IODIR:				;FOR EACH BLOCK, LOAD OR PUT IT.
	MOV FBACKP,E	;GET DESCRIPTOR FROM PUSHED ENTRY
	MOV E,D		;SETUP DESCRIPTOR
	ADD #FENTRY,D
	ADD FDDESC(E),D
	MOV FDBYTES(E),E
	JSR PC,DMARCH	;CRUNCH DESCRIPTOR!!
	MOV FBACKP,E
	RTS PC


SETB12:	;SET BITS IN BIT TABLE 1;
	;IF ONE ALREADY SET, SET IT IN BIT TABLE 2.
	MOV #BTS12,BLOKDO	;DO THIS FOR EACH BLOCK
	JSR PC,EDMARCH
	RTS PC

CKBIT2:	;CHECK BIT TABLE 2; IF ONE SET, RETURN NOT-EQUAL
	MOV #BTT2,BLOKDO	;FOR EACH BLOCK
	CLR BITFND	;IF ZERO ON RETURN, FILE OK.
	JSR PC,EDMARCH
	MOV ENTRYP,A
	INC A		;SET UP TO MUNG REAL FLAG BYTE
	TST BITFND
	BNE CKBIT3
	BITB #SHRB,(A)	;NO SHARED BLOCKS: CAREFUL-CLEAR NODELF
	BEQ CKBIT9
	BICB #SHRB,(A)	;ELSE CLEAR IT AND SAY DIR. MODIFIED
	INC DIRCNG
	TYPEIT ^/ENTRY /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	TYPEIT ^/ NO LONGER SHARES BLOCKS, IS DELETABLE_/
CKBIT9:	RTS PC
CKBIT3:	BITB #SHRB,(A) 	;SHARED BLOCKS: SET DON'T DELETE THEM FLAG
	BNE CKBIT9
	BISB #SHRB,(A)
	INC DIRCNG	;DIRECTORY CHANGED
	RTS PC
EDMARCH: MOV ENTRYP,D
	ADD DDESCR,D
	MOV DBYTES,E
	JSR PC,DMARCH	;DMARCH THIS ENTRY
	RTS PC

;DMARCH NEEDS (WHAT TO DO WITH EACH BLOCK) IN BLOKDO,
;	(ADDR OF DISK BLOCKS DESCRIPTOR) IN D,
;	AND (# BYTES OF DESCR) IN E.
DMARCH:	CLR BLOKNO
	TST E		;ANY DESCRIPTOR?
	BNE DNEXT	;YES
	RTS PC
DNEXT:	MOVB (D)+,C	;BYTE OF DESCRIPTOR
	MOV C,B
	BIC #-DTYPEF-1,B
	ASH #-5,B
	JSR PC,@LOADX(B)	;CRUNCH DESCR BYTE
	SOB E,DNEXT
	RTS PC

;LOADX DISPATCHES TO THESE 4 ROUTINES
LODSKP:	BIC #-DTCNTF-1,C	;GET COUNT FIELD FOR SKIP
	BEQ LODSK1		;"SKIP 0" = .BYTE 0; NO-OP, SPECIAL CASE.
	ADD C,BLOKNO	;SKIP N BLOCKS
	JSR PC,DOBLOK	;CRUNCH ONE BLOCK
LODSK1:	RTS PC

LODCNT:	BIC #-DTCNTF-1,C	;GET COUNT FIELD
	INC C		;GET N+1 BLOCKS
	CMP C,#40	;IS IT MORE THAN 32 BLOCKS?
	BLE LODCT2	;NO, IS JUST GRAB DESCR.
	SUB #40,C	;IS A HOLE TYPE, GET THE NUMBER OF BLOCKS IN HOLE
	ADD C,NBLOKS	;INCREMENT COUNT OF BLOCKS
	RTS PC		;RETURN, NOTHING TO DO
LODCT2:	JSR PC,DOBLOK	;CRUNCH ONE BLOCK AFTER ANOTHER
	SOB C,LODCT2	;UNTIL N+1
	RTS PC

LODSAD:	CMP #3,E	;THREE BYTES LEFT?
	BGT LSADER	;NO, COMPLAIN
	MOVB (D)+,BLOKNO	;FROM NEXT TWO BYTES,
	MOVB (D)+,BLOKNO+1	;SET UP BLOCK NUMBER
	SUB #2,E
	BIC #-DTCNTF-1,C	;GET THE NUMBERS
	INC C
	BR LODCT2	;AND CRUNCH N+1 BLOCKS (N IN FIRST BYTE)
LSADER:	ENTERR ^/(?): NO ROOM FOR DESC. SET-ADDR/
	RTS PC

LODSC:	MOV C,B
	BIC #-DTSCSK-1,B
	ASH #-3,B	;SKIP N1 BLOCKS
	ADD B,BLOKNO
	BIC #-DTSCCT-1,C	;AND CRUNCH ONLY N2+1 BLOCKS
	BR LODCNT

DOBLOK:	CMP BLOKNO,BLKLIM	;IS IT ON THE DISK?
	BHIS DOBLER
	JSR PC,@BLOKDO
	INC BLOKNO
	RTS PC

DOBLER:	JSR PC,ERRORX
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ NOT ON DISK; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	RTS PC

ENTOUT:	TYPEIT ^/ENTRY = /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	RTS PC
RFBLK:	CMP #DISKWC,DISKIO
	BEQ RFBLK1
	MOV TRNSLE,DSKWC	;THE TRANSFER LENGTH
	MOV B,DSKCA	;THE BUSS ADRESS
	CLR A
	MOV BLOKNO,B
	ASHC #9.,A	;GET THE EXTENSION BITS
	MOV B,DSKA	;THE DISK ADRESS
	MOV A,DSKAE	;THE EXTENSION BITS
	MOV DISKIO,DSKS	;THE FUNCTION
	TSTB DSKS
	BGE .-4
RFBLK1:	POP B
	POP A
	TST DSKS
	BLT DBERR
	RTS PC


DBLERR:	ERROR ^/DIRECTORY TOO LONG/
	RTS PC
DIRBLR:	MOV #DBLERR,BLOKDO	;DIR'S ARE ONE BLOCK
	MOV #DIR,B
.IIF NZ SGMNTR, JMP CACHE	;USE CACHE TO HOLD DIR. BLKS
DSKRED:	CLR DSKEM	;NO EXTENDED MEMORY
DSKRD1:	MOV #NRETRY,RETRYS
	MOV #DISKRD,DISKIO
	MOV DISKIO,OLDDSK	;SET UP THE OLD FUNCTION
	JSR PC,DSKBLK
	MOV #DISKWC,DISKIO	;NOW A WRITE CHECK TO VERIFY THAT WE READ IT RIGHT.

DSKBLK:	MOV #NRETRY,RETRYS	;READ IN A BLOCK FROM DISK
DSKBL1:	MOV BLOKNO,SWB
	PUSH A
	PUSH B
	TST WCHDSK	;IS IT A RK11 DISK
	BMI RFBLK	;NOPE
	MOV TRNSLE,RKWC	;TRANSFER LENGTH
	MOV B,RKBA	;CORE ADDR
	MOV BLOKNO,B	;GET DISK ADDR
	ASL B		;DOUBLE IT:  2 SECTORS/BLOCK
	CLR A
	DIV #12.,A	;12 SECTORS/TRACK-SURFACE
	ASH #4,A
	ADD A,B		;ALL DONE FOR FIXED PLATTER
	ADD WCHDSK,B
	MOV B,RKDA	;DISK ADDR
	MOV DSKEM,RKCS	;INSERT EM BITS INTO RKCS
	BIS DISKIO,RKCS	;START TRANSFER
	TSTB RKCS	;TEST READY BIT
	BGE .-4		;WAIT
	POP B
	POP A
	TST RKCS	;TEST ERROR BIT
	BLT DBERR
	RTS PC

DBERR:	DEC RETRYS
	BGT DSKBL1
DBERR2:	SUB #2,P	;CREATE A CELL
	PUSH A
	PUSH B
	TYPEIT ^/DISK /
	MOV WCHDSK,B
	ASH #-13.,B
	BIC #177770,B
	JSR PC,OCTOUT
	TYPEIT ^/ ERROR ACCESSING BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TST WCHDSK
	BMI DBERR3
	TYPEIT ^/_RKER = /
	MOV RKER,B
DBERR4:	MOV #1,RKCS	;POWER CLEAR THE DISK
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/(I)GNORE, (T)RY AGAIN_?/
	JSR PC,TYI1	;GET A CHAR
	MOV A,4(P)	;THE CELL CREATED ABOVE
	POP B
	POP A
	CMP #'I,(P)
	BNE .+6
	MOV #RTSPC,(P)
	CMP #'T,(P)
	BNE .+6
	MOV #DBERR5,(P)
	BITB #177,1(P)
	BEQ .+4
	JMP @(P)+
	BPT
	BR .-4		;TRY TO RETURN


DBERR5:	CMP #DISKWC,DISKIO
	BEQ .+6
	JMP DSKBLK
	MOV OLDDSK,DISKIO	;THE OLD FUNCTION
	JSR PC,DSKBLK
	MOV #DISKWC,DISKIO
	JMP DSKBLK


DBERR3:	SUB #2,P	;CREATE A WORK CELL
	PUSH A
	PUSH B
	TYPEIT ^/_DAE=/
	MOV DSKAE,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/DCS=/
	MOV DSKS,B
	BR DBERR4


DIRBLW:	MOV #DBLERR,BLOKDO
	MOV #DIR,B
.IFNZ SGMNTR		;REMOVE BLOKNO FROM CACHE BLK TABLE
	PUSH C
	PUSH D
	MOV NCBLKS,D	;NO. CACHE BLKS
	MOV #CBLKTB,C	;BEG. OF CACHE BLK TABLE
1$:	CMP BLOKNO,(C)+	;SEE IF THIS BLOKNO IN TABLE
	BEQ 2$
	SOB D,1$
	TYPEIT ^/BLOKNO NOT IN CACHE/
	BR 3$
2$:	MOV #-1,-(C)	;INDICATE SLOT EMPTY
3$:	POP D
	POP C
.ENDC
DSKWRT:	CLR DSKEM
	PUSH A
	PUSH B
	TYPEIT ^/WRITING BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	POP B
	POP A
DSKWR1:	MOV #DISKWR,DISKIO
	MOV DISKIO,OLDDSK
	JSR PC,DSKBLK
	MOV #DISKWC,DISKIO
	JSR PC,DSKBLK
	RTS PC


DBFRED:	PUSH BLOKNO
	MOV B,BLOKNO
	MOV #DSKBUF,B
	JSR PC,DSKRED
	POP BLOKNO
	RTS PC

DBFWRT:	PUSH BLOKNO
	MOV B,BLOKNO
	MOV #DSKBUF,B
	JSR PC,DSKWRT
	POP BLOKNO
	RTS PC

	.STITL COPY DISK IN FILE FORMAT

NDSKWR:	MOV #DSKBUF,B	;BLOCK TO WRITE IS IN DSKBUF
NDKWR1:	PUSH BLOKNO	;SAVE OLD BLOKNO
	PUSH WCHDSK	;SAVE OLD DISK
	MOV NDISK,WCHDSK	;MOV DISK TO WRITE ON TO WCHDSK
	MOV A,BLOKNO	;MOVE BLOCK TO WRITE ON INTO BLOKNO
	JSR PC,DSKWR1	;DO THE WRITE
	POP WCHDSK	;RESTORE OLD DISK
	POP BLOKNO	;RESOTORE ALD BLOCK NO
	RTS PC

NDSKRD:	MOV #DSKBUF,B	;BLOCK IS READ INTO DSKBUF
NDKRD1:	PUSH BLOKNO	;SAVE OLD BLOCK NO.
	PUSH WCHDSK	;SAVE OLD DISK
	MOV NDISK,WCHDSK	;NDISK IS THE DISK TO READ FROM
	MOV A,BLOKNO	;A CONTAINS BLOCK NO. TO BE READ
	JSR PC,DSKRED	;READ THE BLOCK
	POP WCHDSK	;RESTORE THE WORLD
	POP BLOKNO
	RTS PC

BREAD:	PUSH B
	JSR PC,DBFRED	;THIS IS WHERE TO $G IN RUG;
	POP B
	BPT 		;SET B TO BLOKNO FIRST.

BWRITE:	PUSH B
	JSR PC,DBFWRT	;(SIM)
	POP B
	BPT
BTADR:	MOV BLOKNO,B	;BLOKNO -> BIT TABLE BYTE OFFSET, BIT IN BYTE
BTADR1:	PUSH B
	BIC #177770,B
	MOV #1,A
	ASH B,A		;BIT IN BYTE
	POP B
	ASH #-3,B
	BIC #160000,B	;BYTE OFFSET
	RTS PC

BTSET1:	JSR PC,BTADR
	BISB A,DBITS1(B)
	RTS PC


BTSTST:	PUSH B
	JSR PC,BTADR1
	BITB A,DBITS1(B)
	BEQ BTST1
	POP B
	CLZ
	RTS PC
BTST1:	POP B
	SEZ
	RTS PC


BTSET:	PUSH B
	JSR PC,BTADR1
	BISB A,DBITS1(B)
	POP B
	RTS PC


BTS12:	;BIT TABLE SET
	JSR PC,BTADR
	BITB A,DBITS1(B) 	;1 CLEAR?
	BEQ BTS0.
	BISB A,DBITS2(B) 	;NO,SET 2
	RTS PC		;DONE
BTS0.:	BITB A,DBITS2(B) 	;1 CLEAR: 2 SET?
	BNE BTS01
	BISB A,DBITS1(B) 	;NO, JUST SET 1
	RTS PC
BTS01:	JSR PC,ERRORX	;1 CLEAR, 2 SET: RESERVED BLOCK
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ RESERVED; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	RTS PC

BTT2:	;BIT TABLE 2 TEST
	JSR PC,BTADR
	BITB A,DBITS2(B) 	;2 SET?
	BEQ BTT9
	JSR PC,ERRORX	;FILE HAS SHARED BLOCK.
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ SHARED; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	INC BITFND
BTT9:	RTS PC

	.STITL CACHE ROUTINES
.IFNZ SGMNTR
;MAIN CACHE ROUTINE:TRANSFERS A BLK FROM CACHE INTO LOWER CORE
;B CONTAINS LOWER CORE ADDR
CACHE:	PUSH A
	PUSH C
	PUSH D
	PUSH E
	PUSH F
CACH1:	MOV NCBLKS,D	;NO BLKS IN CACHE
	MOV #CBLKTB,C	;POINT TO BEG. OF CACHE BLK TABLE
1$:	CMP BLOKNO,(C)+	;IS DESIRED BLOKNO IN CACHE?
	BEQ 2$		;YES
	SOB D,1$	;NO, TEST NEXT SLOT
	JMP RICACH	;BLK NOT IN CACHE, SO READ IT IN
2$:	SUB #CBLKTB+2,C	;GET SLOT NO. IN TABLE
	ASR C
;GET NEW PAF POINTING INTO CACHE AREA
	ASH #4,C	;MULT. BY 20(00) I.E., NO. BYTES/PAGE
	ADD #1600,C	;ADD BASE ADDR
	MOV C,MYPAR	;RESET CHOSEN PAR
;TRANSFER DATA TO ADDR IN B
	MOV #MYADDR,D	;VIRT. ADDR OF 0'TH BYTE OF CHOSEN PAGE
	MOV #512.,E	;INDEX
3$:	MOV (D)+,(B)+	;TRANSFER 1 WORD
	SOB E,3$	;REPEAT
	MOV #MYOPAD,MYPAR	;REPLACE OLD PAF
	POP F
	POP E
	POP D
	POP C
	POP A
	RTS PC

;ROUTINE TO READ A BLOCK FROM DISK INTO CACHE AREA
RICACH:	INC LCSLOT	;INCREMENT LAST SLOT NO. IN CBLKTB
	CMP LCSLOT,NCBLKS	;HAVE GONE BEYOND END OF TABLE?
	BLO 1$		;BRANCH IF NOT
	CLR LCSLOT	;START OVER
1$:	MOV LCSLOT,F	;GET PAF FOR THIS SLOT:
	ASH #4,F	;BASE ADDR + 20 * SLOT NO.
	ADD #1600,F

	CLR E		;GET PHYSICAL ADDR
	ASHC #6,E	;SHIFT OFF MEM. EXTEN. BITS
	ASH #4,E	;SHIFT THEM TO POSITIONS 4 & 5
	MOV E,DSKEM	;AND SAVE THEM
	PUSH B
	MOV F,B		;REST OF PHYS. ADDR IN F; SET UP FOR SUBROUT.
	JSR PC,DSKRD1	;READ BLOCK
	POP B
	MOV LCSLOT,E	;GET DISPLACEMENT INTO CBLKTB
	ASL E
	MOV BLOKNO,CBLKTB(E)	;PUT BLOKNO INTO CACHE BLK TABLE
	JMP CACH1


;DETERMINE HOW MUCH MEMORY, IN 512-WORD CHUNKS, CAN BE USED AS CACHE
	;IT IS DIFF. BETWEEN 28K WORDS AND THE END OF MEMORY
MEMTST:	MOV #CORCHK,BEBRV	;SET UP FOR INTERRUPT CODING
	MOV #1600,MYPAR	;PUT BASE ADDR CORRES. TO 28K IN CHOSEN PAR
1$:	INC MYPAR	;INC ADDR BY 32 WORDS
	MOV A,MYADDR	;TRY TO REFEFENCE NEW LOC
	BR 1$		;LOOP TERMINATED BY INTERRUPT
	MOV MYPAR,MEMHGH ;SAVE HIGHEST 32-WORD ADDR
	MOV #MYOPAD,MYPAR ;REPLACE OLD BASE ADDR FOR PAGE

	MOV MEMHGH,B	
	SUB #1600,B	;MEMHGH - 28K
	ASH #-4,B	;GET NO. 512-WORD BLKS	
	DEC B		;CAN'T USE LAST MEM LOC, SO 1 BLK LESS
	MOV B,NCBLKS	;SAVE NO. OF BLOCKS
	MOV #BEBRV+2,BEBRV	;REPLACE EXIT LOC IN TRAP VECTOR
	RTS PC

CORCHK:	ADD #2,(P)	;INCREMENT PROG. COUNTER
	RTI		;SKIP NEXT INSTRUCTION

;SEGMENT LOWER MEMORY UP TO 28K WORDS
;IGNORE D-SPACE
SEGSET:	CLR SSR0	;TURN OFF SEGMENTATION INITIALLY
	MOV #10,C	;DO FOR 8 KERNAL I-SPACE PAGES	
	CLR D		;D=0
	MOV #KIDR,A	;POINT TO PDR'S
SEGST1:	MOV D,KIAR-KIDR(A)	;PUT BASE ADDR'S IN PAR'S
	ADD #200,D
	MOV #77406,(A)+	;SET PDR'S: PAGE LEN=128 32-WORD BLKS
			;WITH READ/WRITE ACCESS
	SOB C,SEGST1
	MOV #7600,KIAR+16	;LAST PAR POINTS TO I/O PAGE
	MOV #1,SSR0	;ENABLE MEMORY MANAGEMENT
	RTS PC

CACHNT: MOV NCBLKS,D	;INITIALIZING ROUTINE
	MOV #CBLKTB,C	;POINT TO BEG. OF CACHE BLK TABLE
1$:	MOV #-1,(C)+	;FILL EA. SLOT WITH -1
	SOB D,1$	;REPEAT TILL END
	RTS PC
.ENDC


	.STITL ERROR ROUTINES
ERRORX:	INC ERRCNT	;ONE MORE ERROR ON THIS DISK
	PUSH A
	JSR PC,ERFROM	;TYPE ADDRESS OF ERROR CALL
	POP A
	JSR PC,@(P)+	;CALL BACK TO TYPE ERROR MESSAGE
	PUSH A
	JSR PC,CRLF
	JSR PC,BACKTR	;PRINT BACK TRACE OF DIRECTORY TREE
	.IFZ 1
	TYPEIT ^/_GO ON?  /
	JSR PC,TYI1
	CMP #15,A
	BEQ ERRX1
	CMP #'Y,A
	BNE ERRX2
	.ENDC
	JSR PC,CRLF
ERRX1:	POP A
	RTS PC
ERRX2:	BPT
	JMP SALV

TXTYPE:	PUSH A
TXTYP2:	MOVB (F)+,A	;TYPE MESSAGE
	BEQ TXTYP3
	CMP #'_,A
	BNE 1$
	MOV #15,A	;PRINT CRLF FOR _
1$:	JSR PC,TYPE
	BR TXTYP2
TXTYP3:	INC F		;RETURN-ADDR IS TO AFTER STRING
	BIC #1,F
	POP A
	RTS F


BACKTR:	TYPEIT ^/IN DIR /
	CMP #FBASE,NEXTF
	BNE BKTR0
	TYPEIT ^/(NIL)/
	RTS PC		;NO BACKTRACE
BKTR0:	PUSH B
	MOV #FBACKP,BKFBKP  
BKTR1:	MOV @BKFBKP,B	;CLIMB DOWN TREE TO A BRANCH YOU'VE SEEN BEFORE
	MOV B,BKFBKP
	ADD #FENTRY,B
	JSR PC,NAMOUT	;TYPE DIRECTORY NAME
	CMP BKFBKP,ERNTRYP	;FOUND OLD ERRORSTUMP?
	BEQ BKTR2
	MOV #'<,A	;NO, KEEP GOING
	JSR PC,TYPE
	BR BKTR1
BKTR2:	MOV FBACKP,ERNTRYP	;YES, DONE; MAKE THIS THE ERRORTWIG.
	POP B	 	;;;WHEN POPDIR POPS THE ERRORLIMB IT SAWS IT OFF.
	RTS PC


ERFROM:	PUSH B
	MOV 6(P),B	;GET ERROR RETURN ADDRESS:  A PUSH A,
			;ANOTHER JSR AND A PUSH B ARE ON TOP OF IT NOW
	SUB #4,B	;GET REAL JSR PC,ERRORX ADDR.
	JSR PC,OCTOUT
	MOV #' ,A
	JSR PC,TYPE
	POP B
	RTS PC

OCTOUT:	PUSH C
	MOV #6,C
	CLR A
	ASHC #1,A	;FIRST DIGIT IS TOP BIT
OCOLUP:	ADD #'0,A
	JSR PC,TYPE
	CLR A
	ASHC #3,A
	SOB C,OCOLUP	;PRINT 6 DIGITS
	POP C
	RTS PC


DECOUT:	PUSH C
	CLR C		;0 DIGITS SO FAR
	TST B
	BEQ DECOT0	;TYPE 0
DECOT1:	INC C		;NEXT DIGIT:
	CLR A
	DIV #10.,A
	PUSH B		;PUSH REMAINDER
	MOV A,B		;# 10'S TO B
	BNE DECOT1	;UNTIL NO 10'S
DECOT2:	POP A		;POP A REMAINDER
	ADD #'0,A	;ENCODE IT
	JSR PC,TYPE
	SOB C,DECOT2	;TYPE ALL THE REMAINDERS
	POP C
	RTS PC

DECOT0:	MOV #'0,A	;TYPE '0
	JSR PC,TYPE
	POP C
	RTS PC


NAMOUT:	PUSH C
	PUSH (B)+	;SAVE FLAGS WORD
	MOV #16.,C	;CURTAIL AFTER 16 LETTERS
	PUSH (B)+
	BITB #EOFB,3(P)
	BEQ 1$
	ADD #10,B
1$:	BITB #ACCB,3(P)
	BEQ NAMOU2
NAMOU6:	ADD #2,B
	TSTB (B)+
	BMI NAMOU6
NAMOU2:	MOVB (B)+,A
	JSR PC,TYPE
	TSTB A
	BLT NAMOU3
	SOB C,NAMOU2
	TYPEIT ^/.../	;NAME CURTAILED
	BR NAMOU4	;DON'T LOOK FOR VN

NAMOU3:	BIT #4*400,2(P)	;HAVE WE A VERSION NO. TO PRINT?
	BEQ NAMOU4
	TST (P)		;IS IT A VALID ONE?
	BLE NAMOU4	;NO
	TYPEIT ^/ #/	;YES
	POP B
	JSR PC,DECOUT	;(TYPE NUMBER)
	BR NAMOU5

NAMOU4:	POP C
NAMOU5:	POP C
	POP C
	RTS PC
	.STITL INITIALIZE THE DISK
ROTMID:	.BYTE ENDP-ROTMID,DIREC+1	;RUG'S POINT DIRECTORY
	-1
	FLTEXT ^/./
	.BYTE 200,45,0
ENDP==.
	.EVEN
BITBEG==.
	.BYTE BITEND-BITBEG,FILE+200	;BITS FILE IS IN WHOLE BLOCKS
	.WORD -1,0,2000,-1,-1
	FLTEXT ^/BITS/
	.BYTE DTSKP+47
BITEND==.
	.EVEN

DESBEG==.
	.BYTE DESEND-DESBEG,FILE+201	;DISK DESCRIPTOR FILE
	.WORD -1,0
DESLEN:	0				;LENGTH OF DESCRIPTOR PUT HERE
	.WORD -1,-1
	FLTEXT ^/DESCR/
	.BYTE DTSKP+50
DESEND==.
	.EVEN
ROTEND:
SYMBEG==.				;THE SYMBOL FILE FOR RUG
	.BYTE SYMEND-SYMBEG,FILE+200
	.WORD -1,3,12000,-1,-1		;FILE IS <201-144>*2000 BYTES LONG
	FLTEXT ^/SYMS/
	.BYTE DTSADR+34			;SET THE ADDRESS TO 144
					;AND GRAB 35 BLOCKS
	.BYTE 144,0
SYMEND==.
	.EVEN
ROTEN1:

RUGBEG:
	.BYTE RUGND-RUGBEG,SELF+201
	.WORD -1,0,0,-1,-1
	FLTEXT ^/./
	.BYTE 200,45,0
RUGND==.
	.EVEN
RUGEND::
COPY:	TYPEIT ^/_MASS COPY FROM:	/
	JSR PC,DECIN
	BNE .+6
COPY1:	JMP SALVQ
	CMP B,#3
	BHI COPY1
	ASH #13.,B
	MOV B,WCHDSK
	TYPEIT ^/TO:	/
	JSR PC,DECIN
	BEQ COPY1
	CMP B,#3
	BHI COPY1
	ASH #13.,B
	MOV B,NDISK
	JSR PC,BACKUP
SLV2:	JMP SALV2

CNTLU:	TYPEIT <DOUBLE DENSITY MASS COPY UP?>
	CLR WCHDSK
	MOV #40000,NDISK
DDMCPY:	JSR PC,TYI1
	CMP #'Y,A
	BNE SLV2
	JSR PC,BACKUP
	ADD #20000,WCHDSK
	ADD #20000,NDISK
	JSR PC,BACKUP
	JMP SALV2

CNTLD:	TYPEIT <DOUBLE DENSITY MASS COPY DOWN?>
	CLR NDISK
	MOV #40000,WCHDSK
	BR DDMCPY

BLOCKT:	TYPEIT <LOCK AT A TIME COPIES>
	MOV #-1000,BACKTL
	MOV #203.*12.,BACKCN
	MOV #1,BACKIN
	JMP SALV2

TRACKT:	TYPEIT <RACK AT A TIME COPIES>
	MOV #-14000,BACKTL
	MOV #203.,BACKCN
	MOV #12.,BACKIN
	JMP SALV2


BACKUP:	MOV BACKTL,TRNSLE	;LENGTH OF A CYLINDER
	MOV BACKCN,E	;NUMBER OF CYLINDERS ON A DISK
	CLR BLOKNO	;START AT BLOCK 0
BCKUP1:	MOV #DSKBUF,B	;WHERE TO PUT DATA
	JSR PC,DSKRED	;READ A CYLINDER
	MOV BLOKNO,A	;WHERE TO PUT IT
	JSR PC,NDSKWR	;WRITE IT ON THE OTHER DISK
	ADD BACKIN,BLOKNO	;GET THE NEXT CYLINDER
	SOB E,BCKUP1	;DO IT FOR ALL THE CYLINDERS
	MOV #-1000,TRNSLE	;RESTORE THE BLOCK LENGTH
	RTS PC

ZERO:	TYPEIT <ERO A TRACK THEN READ IT?>
	JSR PC,NOABRT	;ABORT IF NO
	MOV #DSKBUF,A
	MOV #512.,B
1$:	CLR (A)+
	SOB B,1$
	MOV #-1000,TRNSLE
	CLR DSKEM
	CLR BLOKNO
	MOV #12.,E	;NUMBER OF BLOCKS ON A TRACK
2$:	MOV #DSKBUF,B
	JSR PC,DSKWR1
	INC BLOKNO
	SOB E,2$
	CLR BLOKNO
	MOV #-14000,TRNSLE
3$:	JSR PC,DSKRED	;READ THE ZERO TRACK
	BR 3$

FFCMPE:	TYPEIT <FF COMPARE ERRORî>
	INC A
	CMP #10.,A
	BLT .+4
	RTS PC
	TYPEIT <I GIVE UPî>
	JMP SALVQ

FRMT:	JSR PC,FORMAT
	JMP SALV2

NOABRT:	JSR PC,TYI1
	CMP #'Y,A
	BEQ NOABR1
	CMP #'y,A
	BEQ NOABR1
	JMP SALVQ
NOABR1:	RTS PC

FORMAT:	TYPEIT <FORMAT?>
	JSR PC,TYI1
	CMP #'Y,A
	BEQ FORMA1
	CMP #'y,A
	BNE NOFMT
FORMA1:	CLR B
	MOV #313*2,D
FFLP1:	MOV #12.,C
FFLP2:	MOV B,DSKBUF
	MOV #77776,DSKBUF+2
	MOV WCHDSK,RKDA
	BIS B,RKDA
	MOV #-2,RKWC	;LARGE NEGATIVE NUMBER=>OVERFLOW ENDS XFER
	MOV #DSKBUF,RKBA
	MOV #2003,RKCS
	TSTB RKCS
	BPL .-4
	TST RKCS
	BMI FMTER
	INC B
	SOB C,FFLP2
	BIC #17,B
	ADD #20,B
	SOB D,FFLP1
	CLR A
	CLR B
	MOV #313*2,D
FFLP3:	MOV #12.,C
FFLP4:	MOV WCHDSK,RKDA
	BIS B,RKDA
	MOV #-2,RKWC	;LARGE NEGATIVE NUMBER=>OVERFLOW ENDS XFER
	MOV #DSKBUF,RKBA
	MOV #2005,RKCS
	TSTB RKCS
	BPL .-4
	TST RKCS
	BMI FMTER
	CMP B,DSKBUF
	BEQ FFLP5
	JSR PC,FFCMPE
FFLP5:	CMP #77776,DSKBUF+2
	BEQ FFLP6
	JSR PC,FFCMPE
FFLP6:	INC B
	SOB C,FFLP4
	BIC #17,B
	ADD #20,B
	SOB D,FFLP3
NOFMT:	JSR PC,CRLF
	RTS PC

FMTER:	TYPEIT <ERROR TRYING TO FORMAT DISK>
	JMP SALVQ

INITD:	JSR PC,FORMAT
	MOV #-1,BLKLIM
	MOV #DBITS1,A
	MOV #20000,B
	CLR (A)+	;CLEAR 2*4K WORDS (BOTH BIT TABLES)
	SOB B,.-2
	CLR RUGDSK	;NOT A RUG DISK UNLESS HE ASKS
	TYPEIT ^/_RUG DISK?/
	JSR PC,TYI1
	CMP #'Y,A
	BNE INITD1	;NO
	COM RUGDSK	;SET FLAG
	MOV #DBITS1+14,A	;POINT TO THE BIT TABLE
	MOV #-1,B	;TO MARK BLOCKS WITH
	MOV #177760,(A)+	;MARK BLOCKS 144-157
	MOV B,(A)+	;MARK BLOCKS 160-177
	MOV #1,(A)+	;MARK BLOCK 200
INITD1:	BIS #740,DBITS1+4	;MARK BLOCKS 45-50
	MOV #4604,BLKLIM	;NO. BLOCKS ON DISK
	TST WCHDSK	;IS IT THE FIXED DISK
	BPL XDESCR	;NOPE
	MOV #2000,BLKLIM
XDESCR:	JSR PC,CLRBUF
	MOV #DSKBUF,D

BASEYR:	.IFZ 105
	TYPEIT ^/_BASE YEAR:  /
	JSR PC,ITYI	;RESET TYI BUFFER
	JSR PC,DECIN
	BEQ BASEYX	;NO NUMBER TYPED IN--NO GOOD
	CMP #15,A	;FOLLOWING CHAR = CR?
	BNE BASEYX
.ENDC
	MOV B,(D)+	;# IS BASE YEAR
	BR AREA1
BASEYX:	TYPEIT ^/ ?/	;BAD SYNTAX
	BR BASEYR

AREA1:	JSR PC,AREAN
	TYPEIT ^/1/	;BACK FOR "SWAP AREA 1:  "
	JSR PC,@(P)+	;CONTINUE
	BVS AREA1	;BAD SYNTAX:  "?" ALREADY TYPED
	BNE AREA2	;# BLOCKS = 0?
	CMP (D)+,(D)+	;YES, JUST CR TYPED: SKIP AREA 2
	BR RESRVD

AREA2:	JSR PC,AREAN
	TYPEIT ^/2/	;BACK FOR "SWAP AREA 2:  "
	JSR PC,@(P)+	;CONTINUE
	BVS AREA2

RESRVD:	TST RUGDSK	;IS IT A RUG DISK?
	BEQ RESRV1	;NO
	CLR C		;BLOCK 0
	MOV #1,B	;ONE BLOCK WORTH
	JSR PC,SETMSK	;SET IT IN
	MOV #4,C	;NOW THE INVIOLATE PORTION OF RUG
	MOV #24-4,B	;THAT MANY BLOCKS
	JSR PC,SETMSK
	MOV #54,C	;THE CORE IMAGE OF RUG
	MOV #144-54,B	;RIGHT UP TO THE START OF THE SYMS FILE
	JSR PC,SETMSK	;SET UP THE MASK
	MOV #201,C	;START RIGHT AFTER THE SYMS FILE
	MOV #220-201,B	;RESERVE UP TO 217
	JSR PC,SETMSK	;OKAY ALL DONE WITH THE INITIAL STUFF
RESRV1:	TYPEIT ^/_RESERVED:  /
	JSR PC,ITYI
	JSR PC,RANGIN
	BVS RSRVX1	;BAD RANGE SYNTAX
	CMP #15,A	;CR AFTER FIRST RANGE?
	BEQ RSRVCR
	CMP #',,A	;COMMA AFTER FIRST RANGE?
	BNE RSRVX1	;MUST BE ONE OR THE OTHER
	TST B
	BEQ RSRVX1	;NO RANGE FOLLOWED BY COMMA NO GOOD
	JSR PC,SETMSK	;SET BITS AND MAKE OFFSET/MASK FOR THIS RANGE
	BR RESRVC

RSRVCR:	TST B
	BEQ DESCWR	;NO RANGE ON LINE -> ALL DONE.
	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVD	;ANOTHER LINE OF "RESERVED:  "

RSRVX1:	TYPEIT ^/ ?/	;LINE SYNTAX  NO GOOD
	BR RESRVD	;TRY LINE AGAIN


RESRVC:		;AFTER A COMMA:
	JSR PC,RANGIN
	BVS RSRVX2	;BAD RANGE SYNTAX
	TST B
	BEQ RSRVX2	;AFTER A COMMA YOU MUST HAVE A RANGE
	CMP #15,A
	BEQ RSVCR2	;ENDED WITH CR
	CMP #',,A
	BNE RSRVX2	;MUST HAVE EITHER THAT OR COMMA
	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVC	;ANOTHER RANGE ON THIS LINE

RSVCR2:	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVD	;ANOTHER LINE

RSRVX2:	TYPEIT ^/ ?_BAD SYNTAX AFTER COMMA/
	BR RESRVD	;TRY LINE AGAIN

DESCWR:	SUB #DSKBUF,D
	MOV D,DESLEN		;SAVE THE DESRIPTOR LENGTH
	MOV #50,B
	JSR PC,DBFWRT	;WRITE BLOCK 50:  DESCR FILE DONE
XBITS:	JSR PC,CLRBUF
	MOV BLKLIM,DSKBUF	;NO. BLOCKS ON DISK
	MOV #777,C		;BLT 1000-1 WORDS INTO DSKBUF+2
	MOV #DBITS1,A
	MOV #DSKBUF+2,B
	MOV (A)+,(B)+
	SOB C,.-2
	MOV #47,B	;WRITE THIS FILE
	JSR PC,DBFWRT	;STILL ONLY ALLOW 17760 BLOCKS ON DISK

XROOT:	JSR PC,CLRBUF
	MOV #DSKBUF+1,B
	MOVB #SELF+201,(B)+	;ROOT HAS WORD LEFT FOR LENGTH
	MOV #-1,(B)+		;SET IN THE DIRID
	ADD #10,B		;SKIP EOF, AND DATE AND TIME
	JSR PC,GETNAM		;GET NAME OF DISK
	MOVB #200,(B)+
	MOVB #46,(B)+		;SAY BLOCK 46
	TSTB (B)+		;THE LENGTH OF ROOT
	MOV B,A
	SUB #DSKBUF,A
	MOVB A,DSKBUF	;HEADER LENGTH BYTE
	INC B
	BIC #1,B	;ROUND IT
	MOV #DSKBUF+14,C	;SKIP HEADER AND DIRID
	MOVB DSKBUF,F		;COPY THE LENGTH
	SUB #10,F	;THE EOF AND DATE/TIME DONT EXIST
	MOVB F,(B)+	;SET IN THE LENGTH INTO PARENT ENTRY
	MOVB #PARENT+1,(B)+	;SET IN THE TYPE
	MOV #-1,(B)+	;AND DIRID
	SUB #3,F	;SKIP THE HEADER AND DIRID
	ASR F		;TURN INTO WORD COUNT
	MOV (C)+,(B)+	;COPY THE ENTRY
	SOB F,.-2
	MOV #ROTMID,A
	MOV #<ROTEND-ROTMID>/2,C
	TST RUGDSK	;IS IT A RUG DISK?
	BEQ XROOT1	;NO
	MOV #<ROTEN1-ROTMID>/2,C	;ADD IN THE SYMS FILE
;FALLS THROUGH
;FALLS IN
XROOT1:	MOV (A)+,(B)+	;FILL IN POINT, BITS AND DESCR ENTRIES (FIXED)
	SOB C,.-2
	SUB #DSKBUF,B	;NUMBER OF BYTES INROOT
	MOV B,DSKBUF+6
	MOV #46,B
	JSR PC,DBFWRT

XPOINT:	MOVB DSKBUF,F		;THE LENGTH OF THE SELF ENTRY
	SUB #10,F		;NO EOF/DATE/TIME
	MOV F,E			;THE NUMBER OF WORDS TO TRANSFER
	INC E
	ASR E
	MOV #DIR,C		;PLACE TO SAVE ENTRY
	MOV #DSKBUF+14,B	;POINTER TO NAME OF ROOT
	MOV #<PARENT+1>*400,(C)	;SAVE THE TYPE
	ADD F,(C)+		;SET IN THE LENGTH
	MOV #-1,(C)+		;SET IN THE DIRID
	DEC E			;DONT TRANSFER THE HEADER EITHER
	DEC E
	MOV (B)+,(C)+		;COPY THE ENTRY
	SOB E,.-2
	JSR PC,CLRBUF
	MOV #DSKBUF,B		;THE PLACE TO CONSTRUCT POINT
	MOV #RUGBEG,A
	MOV #<RUGEND-RUGBEG>/2,C	;THE LENGTH OF STARTING ENTRY
	MOV (A)+,(B)+		;COPY THE SELF ENTRY
	SOB C,.-2
	MOVB DIR,C		;THE LENGTH OF NEW ENTRY
	INC C
	BIC #1,C
	MOV C,F
	ASR C
	MOV #DIR,A		;POINT TO IT
	MOV (A)+,(B)+		;COPY THE PARENT ENTRY
	SOB C,.-2
	INC F
	BIC #1,F
	MOVB DSKBUF,E
	ADD E,F
	INC F
	BIC #1,F
	MOV F,DSKBUF+6
	MOV #45,B
	JSR PC,DBFWRT
INITDX:	JMP SALV2
CLRBUF:	MOV #DSKBUF,A
	MOV #1000,B	;512 WORD IN BUFFER
	CLR (A)+
	SOB B,.-2
	RTS PC

GETNAM:	TYPEIT ^/_DISK NAME:  /
	JSR PC,ITYI
GETNM2:	JSR PC,TYI
	CMPB #15,A	;CR ENDS NAME
	BEQ GETNMR
	MOVB A,(B)+	;NEXT CHAR OF HEADER ENTRY
	BR GETNM2
GETNMR:	MOV #12,A	;ECHO CRLF
	JSR PC,TYPE
	TSTB -(B)	;FLAG PREVIOUS CHAR AS LAST CHAR OF NAME
	BISB #200,(B)+
	RTS PC
DECIN:	CLR B		;Z IF NO DIGITS TYPED;
	JSR PC,DECDIG	;# IN B, END CHAR IN A
	BNE DECIN2
	SEZ		;NO NUMBER
	RTS PC
DECIN2:	JSR PC,DECDIG
	BNE DECIN2
	CLZ		;NON-DIGIT SEEN
	RTS PC

DECDIG:	JSR PC,TYI	;Z IF NOT DIGIT;
	CMP #'0,A	;CHAR IN A, ACCUM'ED # IN B
	BGT DECDGX
	CMP #'9,A
	BLT DECDGX
	SUB #'0,A
	MUL #10.,B
	ADD A,B
	CLZ		;THIS WAS A DIGIT
	RTS PC
DECDGX:	SEZ
	RTS PC		;NOT A DIGIT


RANGIN:			;GET A RANGE, C = STARTING BLOCK, B = # BLOCKS
			;SET V IF BAD SYNTAX
	JSR PC,OCTIN
	BEQ RANGE0	;NO RANGE
	MOV B,C		;FIRST BLOCK OF GROUP GOES IN C
	CMP #'-,A	;ONE BLOCK OR GROUP?
	BEQ RANGI2
	MOV #1,B	;JUST ONE NUMBER- LENGTH OF GROUP IS 1
	RTS PC
RANGE0:	CLR B		;NO RANGE:
	CLR C
	RTS PC		;FIRST NUMBER NOT TYPED--B=0 IS FLAG

RANGI2:	JSR PC,OCTIN	;GET LAST BLOCK NUMBER
	BEQ RANGIX	;BAD SYNTAX--NO END #
	SUB C,B		;MAKE B NUMBER OF BLOCKS
	INC B		;FROM FIRST AND LAST BLOCKS
	BLT RANGIX	;FIRST MUST NOT BE > LAST
	RTS PC
RANGIX:	SEV		;BAD RANGE SYNTAX
	RTS PC


OCTIN:	CLR B		;Z IF NO DIGITS; # IN B, BREAK CHAR IN A
	JSR PC,OCTDIG
	BNE OCTIN2
	SEZ		;NO NUMBER
	RTS PC
OCTIN2:	JSR PC,OCTDIG
	BNE OCTIN2
	CLZ		;NON-DIGIT SEEN
	RTS PC

OCTDIG:	JSR PC,TYI	;Z IF NOT A DIGIT;
	CMP #'0,A	;CHAR IN A, ACCUM'ED # IN B
	BGT OCTDGX
	CMP #'7,A
	BLT OCTDGX
	SUB #'0,A
	ASH #3,B
	ADD A,B
	CLZ		;WE GOT A DIGIT
	RTS PC
OCTDGX:	SEZ		;NOT A DIGIT
	RTS PC
AREAN:	TYPEIT ^/_SWAP AREA /
	JSR PC,@(P)+	;GO BACK TO TYPE SWAP AREA #
	TYPEIT ^/:  /	;HELLO AGAIN
	JSR PC,ITYI
	JSR PC,RANGIN
	BVS AREANX	;BAD RANGE SYNTAX
	CMP #15,A	;MUST BE CR AFTER RANGE
	BNE AREANX
	JSR PC,SETAREA	;SET RANGE IN BIT TABLE AND DESCR FILE
	RTS PC		;IF B = 0 BLOCKS IT WAS JUST CR;
			;Z IS SET AND CALLER WILL GO TO RESRVD.
AREANX:	TYPEIT ^/ ?/	;SYNTAX BAD
	SEV
	RTS PC


SETAREA: MOV C,(D)+	;GIVEN A GROUP OF BLOCK, FIRST ONE IN C,
	MOV B,(D)+	;# OF BLOCKS IN B, PUT THEM IN DESCR AND
	BNE .+4		;SET THEIR BITS IN DBITS1
	RTS PC		;BUT IF B = 0 DON'T BOTHER
	MOV C,BLOKNO
	MOV B,C		;GOOD PLACE FOR COUNTER

SETAR2:	CMP BLOKNO,BLKLIM
	BHIS NDISKX	;BLOCK FELL OFF DISK:  FATAL ERROR
	JSR PC,BTADR	;BLOKNO -> BIT IN A, BYTE OFFSET IN B
	BITB A,DBITS1(B)
	BEQ 1$
	JSR PC,BALRES	;BLOCK ALREADY RESERVED
1$:	BISB A,DBITS1(B)	;RESERVE THE BLOCK
	INC BLOKNO	;LOOP TO NEXT BLOCK
	SOB C,SETAR2	;COUNT OUT # OF BLOCKS
	RTS PC
SETMSK:	MOV C,BLOKNO	;GIVEN A GROUP OF BLOCKS, SET UP OFFSET/MASK PAIRS
	MOV B,C		;IN DESCR AND RESERVE THE BLOCKS IN DBITS1
	BR SETMS3	;THERE SHOULD BE NO B=0 CASES

SETMS2:	BIT #17,BLOKNO	;RUNNING INTO NEW MASK WORD?
	BNE SETMS4
	TST (D)+	;YES, BE DONE WITH OLD ONE,
SETMS3:	JSR PC,OFFSET	;MAKE NEW OFFSET WORD
SETMS4:	CMP BLOKNO,BLKLIM
	BHIS NDISKX	;BLOCK FELL OFF DISK--FATAL ERROR
	JSR PC,BTADR	;BLOKNO -> BIT IN A, BYTE OFFSET IN B
	BITB A,DBITS1(B)	;BLOCK RESERVED?
	BEQ .+6
	JSR PC,BALRES	;"BLOCK N ALREADY RESERVED"
	BISB A,DBITS1(B)	;RESERVE THE BLOCK
	BIT #10,BLOKNO	;ODD BYTE?
	BEQ .+4
	SWAB A		;IF ODD TEN THEN PUT IN ODD BYTE
	BIS A,(D)	;SET NEW BIT IN MASK

	INC BLOKNO
	SOB C,SETMS2
	TST (D)+	;END LAST MASK WORD
	CMP D,#DSKBUF+2000
	BHIS DESCRX	;DESCR OVERFLOW--FATAL
	RTS PC


OFFSET:	CMP D,#DSKBUF+1776
	BHIS DESCRX	;DESCR FILE OVERFLOW--FATAL ERROR
	MOV BLOKNO,A
	ASH #-3,A	;BLOCK # -> BYTE OFFSET
	BIC #1,A	;-> WORD OFFSET IN BIT TABLE
	MOV A,(D)+	;MAKES OFFSET WORD OF DESCR FILE
	RTS PC

DESCRX:	TYPEIT ^/_DESCR FILE OVERFLOWED_/
	HALT		;INITD NO GOOD
	BR .-2



BALRES:	PUSH A		;BLOCK ALREADY RESERVED
	PUSH B
	TYPEIT ^/_BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ ALREADY RESERVED_/
	POP B
	POP A
	RTS PC


NDISKX:	TYPEIT ^/_BLOCK NOT ON DISK_/
	HALT		;INITD NO GOOD

;PDP10 COMMUNICATION
TENCOM:	CLR COMPNT	;SET OF COM POINTER
	MOV #<ELVRDY_-6>&1777,COMPNT+2	;SO TEN POINTS AT THE COM AREA
	CLR TENFUN	;NULL FUNCTION
	CLR TENRDY	;TEN NOT READY
	CLR ELVRDY	;SAY NOT READY
	MOV #10.,E	;TRY 10 TIMES
1$:	JSR PC,DELAY	;WAIT A SEC
	COM ELVRDY	;GIVE THE 10 A FLASH
	TST TENRDY	;IS THE TEN READY?
	BNE 2$		;YES, IT GOT THE MESSAGE
	SOB E,1$
	TYPEIT <THE 10 ISN'T THERE!>
	JMP SALVQ

2$:	CLR ELVRDY	;I'M NOT READY
	CLR TENRDY	;AND NEITHER IS THE 10
	TYPEIT <GOT THE 10!_(R)EAD FROM 10 OR (W)RITE TO 10?>
	JSR PC,TYI1
	CMP #'R,A
	BEQ TENRED
	CMP #'W,A
	BEQ TENWRT
	COM ELVRDY	;SAY WE ARE READY FOR ZERO FUNCTION (E.G. DONE)
	JMP SALVQ	;AND QUIT

TENRED:	MOV #-1,TENFUN	;SAY WE WANT TO READ
	JSR PC,TENWAIT
	CLR BLOKNO
	MOV #203.*12.,F
TENRE1:	JSR PC,TENWAIT	;WAIT FOR A BLOCK FROM THE 10
	MOV #DSKBUF,B
	JSR PC,DSKWR1	;WRITE IT SILENTLY
	INC BLOKNO
	SOB F,TENRE1
	CLR TENFUN	;DONE
	JSR PC,TENWAIT
	RTS PC

TENWRT:	MOV #1,TENFUN	;SAY WE WANT TO WRITE
	JSR PC,TENWAIT	;GO SAY WE ARE READY AND WAIT FOR TEN
	CLR BLOKNO
	MOV #203.*12.,F	;NUMBER OF BLOCKS TO TRANSFER
TENWR1:	MOV #DSKBUF,B
	JSR PC,DSKRED	;READ A BLOCK
	JSR PC,TENWAIT	;TELL TEN TO READ IT
	INC BLOKNO
	SOB F,TENWR1
	CLR TENFUN	;TELL TEN WE ARE DONE
	JSR PC,TENWAIT	;LET IT CONFIRM
	RTS PC		;RETURN TO COMMAND LOOP

DELAY:	MOV A,-(P)
	CLR A
	SOB A,.
	MOV (P)+,A
	RTS PC

TENWAI:	CLR TENRDY
	MOV #-1,ELVRDY
1$:	TST TENRDY
	BEQ 1$	
	CLR TENRDY
	RTS PC	

	.STITL TYI & TYO
CRLF:	MOV #15,A
	JSR PC,TYPE
	RTS PC

ECHO:	TST RUBING	;RUBBING OUT CHARS?
	BEQ TYPE
	PUSH A		;YES, LEAVE RUBBING MODE
	MOV #'\,A
	JSR PC,TYPE
	CLR RUBING
	POP A

TYPE:	TSTB %TPS
	BPL TYPE
	MOVB A,%TPB
	CMP #15,A
	BEQ .+4
	RTS PC
	PUSH A
	MOV #12,A
	JSR PC,TYPE
	CLR A
	JSR PC,TYPE
	JSR PC,TYPE
	POP A
	RTS PC

TYI1:	TSTB %TKS
	BPL TYI1
	MOVB %TKB,A
	BIC #177600,A
	CMP #'G-100,A	;BELL?
	BEQ TYIRUG
	CMP #'Z-100,A	;^Z?
	BEQ TYIRUG
	CMP #'A+40,A
	BGT TYI2
	CMP #'Z+40,A
	BLT TYI2
	SUB #40,A
TYI2:	CMP #177,A	;RUBOUT?
	BNE .+6
	SEV
	RTS PC		;IF RUBOUT THEN 1) SET V 2) DON'T ECHO
	JSR PC,ECHO	;ECHO
	RTS PC
TYIRUG:	BPT
	BR TYI1

ITYI:	CLR NCHR
	RTS PC

TYI:	DEC NCHR	;ONE LESS CHAR TO READ
	BLT TYLINE	;IF IT'S THERE
	MOVB @TBUFPT,A	;THEN HERE IT IS
	INC TBUFPT
	RTS PC

TYLINE:	CLR NCHR	;OUT OF CHARS: GET A NEW LINE
	CLR RUBING	;NOT RUBBING OUT
	MOV #TBUF,TBUFPT	;READ INTO BUFFER
TYLIN2:	CMP #TBUFLN,NCHR	;ROOM IN BUFFER?
	BLOS LINERR
	JSR PC,TYI1	;GET A CHAR
	BVS TYLRBO	;RUBOUT
	MOVB A,@TBUFPT	;STORE CHAR
	INC TBUFPT
	INC NCHR	;ONE MORE CHAR IN BUFFER
	CMP #15,A	;CR?
	BNE TYLIN2	;NO, KEEP LISTENING
	MOV #TBUF,TBUFPT 	;YES, BUFFER READY: FEED HIM THE FIRST CHAR
	BR TYI

TYLRBO:	DEC NCHR	;RUB IT OUT: ONE LESS CHAR
	BLT TYLINE	;NO CHARS TO RUB OUT: RESET LINE
	DEC TBUFPT
	TST RUBING	;ALREADY IN RUBBING MODE?
	BNE TYLRB2	;YES
	MOV #'\,A
	JSR PC,TYPE
	INC RUBING
TYLRB2:	MOVB @TBUFPT,A	;TYPE RUBBED OUT CHAR
	JSR PC,TYPE
	TST NCHR	;FIRST CHAR RUBBED OUT?
	BNE TYLIN2	;NO, DONE WITH RUBOUT
	MOV #'\,A	;YES, CLOSE RUBBING MODE
	JSR PC,TYPE
	BR TYLINE

LINERR:	TYPEIT ^/ ?_TYI BUFFER FULL, TRY IT ALL OVER/
	BPT
	JMP SALV2


PATLOC:
PATCH:	.=.+400

;*************
;FIXED HEAD DISK BLOCK 0 BOOTSTRAP FOR LOGO AND RUG
;
FHIDIR:	MOV #DSKAE,B
	CLR (B)
	MOV #4000,-(B)
	MOV #120000,-(B)
	MOV #160000,-(B)
	MOV #DISKRD,-(B)
	TSTB (B)
	BPL .-2
	CMP #177000,@#SWB
	BEQ .+6
	JMP @#120000	;CLEAR SWITCHES TO GET RUG
	JMP @#120002	;LEAVE SWITCHES UP FOR LOGO
FHIDIZ:
;*************

	FBASE=<.!1777>+1
	FEND==FBASE+4000
	DBITS1=FEND
	DBITS2=DBITS1+20000
	DIR=DBITS2+20000
	DIRBUF==DIR+20000
 	DSKBUF=DIR+20000

.END SALV
