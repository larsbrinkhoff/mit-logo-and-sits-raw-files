.IFNZ DPM1
MAKEWINDOW:		;FIRST DO ARGUMENT DECODING, DEFAULT PARAMETERS, BOUNDRY CHECK 
	JSR PC,G2ARG	;FA_W SIZE
	SETI		;FB GETS W SIZE Y 
	SETF
	STF FA,FF	;COPY
	STF FB,FE	;SIZE
	LDCIF #2.,FC
	DIVF FC,FA
	DIVF FC,FB
	LDF DCURX,FC	;PRESENTLY W CENTER IS HOME
	LDF DCURY,FD
	STCFI FC,C
	STCFI FD,A
	SUBF FA ,FC	;W RT EDGE=W CENTER X-SIZE/2
	SUBF FB,FD	;LIKEWISE FOR BOTTOM
	JSR PC,TVBOUN	;CHECK BOUNDS
	LDF FC,FA	;STORE THE EDGES
	LDF FD,FB
	ADDF FF,FC	;CALC. OTHER EDGES
	ADDF FE,FD
	JSR PC,TVBOUN	;CHECK BOUNDS
	JSR PC,TVSCAL	;CONVERT [FA,FB] TO TV COORDINATES
	JSR PC,ROUND	;ROUND OFF
	STCFI FA,E
	STCFI FB,D
	LDF FC,FA	;THE SAME FOR OTHER EDGES
	LDF FD,FB
	JSR PC,TVSCAL
	JSR PC,ROUND
	STCFI FA,B
	STCFI FB,F

	SAVE <F,E,A,C> ;PUSH TOP, LEFT,W CENTER Y,WCENTER X

   ;NOW CALCULATE DIMENSIONS OF WINDOW AND LENGTH OF ARRAY NEEDED
;EMULATE THE ARGUMENT SET UP OF DEFAR SO AS TO BE ABLE TO JUMP INTO
;THE MIDDLE AND HAVE IT BIND AND ALLOCATE THE ARRAY

	SUB E,B		;#OF BITS (W LT EDGE-W RT EDGE)
	CLR A		;SET UP DIVIDE
	DIV #16.,A
	MOV B,-(P)	;PUSH LEFTOVER (REMAINDER)
	BEQ 1$
	INC A		;X DIM.=QUOITIENT+1 UNLESS NO LEFTOVER
1$:	SUB F,D		;Y DIM.=W BOTTOM-W TOP
	MOV D,F	
	MUL A,D		
	;LENGTH OF ARRAY NOW IN D
	SAVE <F,A>
	SAVE <#MAKEW1,F,A,#2>	;PUSH RETURN ADDRESS,Y DIM,X DIM,ARRAY TYPE	
	JMP WALLOC	;DO ARRAY BINDING AND ALLOCATION

  ;SET UP THE ARRAY HEADER WITH NECASSARY WINDOW INFORMATION

MAKEW1:	MOV TOPS,F	;F GETS A POINTER TO THE ARRAY
	ADD #4,F	;F NOW POINTS TO WORD ALLOCATED FOR THE # DIM
	MOV #2,(F)+	;FILL HEADER- #OF DIM
	MOV (P)+,(F)+	;XDIM
	MOV (P)+,(F)+	;YDIM
	MOV (P)+,(F)+	;SINCE THERE IS NO Z DIM I CAN STORE THE LEFTOVER IN IT
	REST <A,E>	;POP W CENX,W CENY
	MOV A,(F)+	;PUT W CENX
	MOV E,(F)+	;AND W CENY INTO ARRAY HEADER
	MOV (P),B
	SUB A,B		;DISTANCE FROM W CENTER TO LEFT EDGE
	MOV B,(F)+	;PUT IT INTO HEADER
	SPOP B
	MOV (P),D
	SUB E,D		;DISTANCE FROM W CENTER TO TOP EDGE
	MOV D,(F)+	;PUT IT IN HEADER
	SPOP D		;HEADER NOW FULL,STACK EMPTY,


;SET UP FOR TRANSFER.   THE TRANSFER IS DONE BY TWO NESTED DO LOOPS
;THE INNER LOOP READS AND SHIFTS AND STORES ONE LINE OF THE WINDOW EXCEPT
;FOR THE LAST WORD OF THE LINE WHICH NEEDS A MASK FOR THE LAST #LEFTOVER
;BITS. WHEN THE INNER LOOP IS FINISHED IT IS REINITIALIZED BY ADDING THE
;NUMBER OF WORDS ACROSS THE SCREEN MINUS THE #OF WORDS IN THE X DIM OF THE W
;TO THE POINTER INTO DISPLAY MEMORY AND PUTTING #OF WORDS IN THE X DIM OF THE W
;MINUS 1 INTO THE COUNTING REGISTER FOR THE INNER LOOP. THE OUTER LOOP DOES THIS 
;THE NUMBER OF LINES IN THE WINDOW (Y DIM)

;;Replace mask-creating code with masks from STARMSK, STOPMSK.
	CLR A		;MAKE MASK
	COM A		;OF THE #LEFTOVER
	ASH -10.(F),A	;LOW ORDER BITS
	COM A
	SPUSH A		;PUSH MASK
;	MOV -14.(F),C	;C GETS XDIM
;	SPUSH C		;PUSH INIT. VALUE OF COUNTER FOR INLUP
	SPUSH -14.(F)
	CLR A
	DIV #16.,A
	MUL #36.,D	;CALCULATE THE FIRST WORD OF WINDOW
	ADD A,D
	ASL D		;CONVERT TO BYTES
;	ADD #DISAD,D
	SPUSH D
	SPUSH B
	MOV -12.(F),C	;COUNTER FOR OUTER LOOP GETS YDIM
 ;NOW DO THE TRANSFER AND SHIFT FROM WINDOW TO THE ARRAY

;	JSR PC,TVMON
;	MOVB #1., TVINCR		;Increment address a word at a time.
;	MOV D, TVRADR
	CLRB	TVINCR
OUTLUP:	MOV 4(P),E	;(RE)SET COUNT1

INLUP:	MOV D,TVRADR
	MOV TVRWIN, A			;Pick up next two words of display memory.
	ADD #2.,D
	MOV D,TVRADR
	MOV TVRWIN,B			;Address increments a word at a time. 
;	MOV (D)+,B	;READ NEXT
;	MOV (D),A	;TWO WORD OF DISPLAY MEMORY


	ASHC (P),A	;SHIFT
	COM A		;STORE THE WINDOW IN COMPLEMENTED FORM 
	MOV A,(F)+	;PUT THE WORD INTO THE WINDOW ARRAY
	SOB E,INLUP	;ITERATE
	BIS 6.(P),-2(F)	;MASK THE EXTRANEOUS BITS

	ADD #BYTLINE, 2(P)		;Point to word in next line. 
;	MOV 2(P), TVRADR		;Less 2 because address incremented each read.
	MOV 2(P),D

	SOB C,OUTLUP	;ITERATE
	ADD #8.,P	;CLEAR STACK
	SEZ
	RTS PC


SHWERR:	ERROR+WNA
	;FIRST DECODE ARGS


HIDEWINDOW:
	JSR PC,AMAKE	;B GETS A POINTER TO WINDOW ARRAY
	MOV #TVSET, A			;Display window in eraser mode.
	CLR D
	BR DISWIN

SHOWWINDOW:				;Display window in IOR mode.
	JSR PC,AMAKE
	MOV #TVIOR, A
	BR DRAWIN

XORWINDOW:
	JSR PC,AMAKE
	MOV #TVXOR, A			;XOR mode.

DRAWIN:	MOV #-1.,D
DISWIN:	
	MOV 2(P), C			;Gobble down number of arguments.
	MOV (P)+, (P)
	SAVE <WINDATA, TVSEL>	;Bind drawmode over display of window.
	MOV D, WINDATA
	JSR PC, DRAWMODE

;	JSR PC,AMAKE
;	REST C				;Number of arguments in C.
WINDOW:	
	DEC C
	BEQ 1$		;NO ARGS INADDITION TO NAME PUT IT AT IT'S CENTER
	CMP #2,C
	BNE SHWERR	;MUST BE TWO ARGS IF NONE
	SPUSH B
	JSR PC,G2ARG	;XCEN IN A,Y CEN IN B
	SETI
	SETF
	JSR PC,TVBOUN
	JSR PC,TVSCAL
	STCFI FA,C
	STCFI FB,D
	SPOP B
	BR 2$
1$:	MOV 12.(B),C	;XCEN IN C
	MOV 14.(B),D	;YCEN IN D
2$:	;NOW SET UP STACK AND REGISTERS FOR TRANSFER
;	SPUSH #36.
;	SUB 6(B),(P)
;	ASL (P)		;CONVERT TO BYTES
;	SPUSH 6(B)	;PUSH,RESET DIPLAY MEM POINTER,INITIAL VALUE OF COUNTER (XDIM)
	MOV 16.(B),F	;DIST. FROM ORIGINAL WCENT TO LEFTEDGE
	ADD C,F		;F GETS BIT POSITION OF LEFT EDGE
	CLR E		;FOR DIVIDE
	DIV #16.,E
	NEG F		;SHIFT IS IN OPPOSITE DIRECTION
 	ADD 18.(B),D
	MUL #36.,D	;CALCULATING THE FIRST WORD IN DISPLAY MEMORY
	ADD E,D
	ASL D		;CONVERT TO BYTES
;	ADD #DISAD,D
;	SAVE <8.(B)>
	SAVE <STARMS(F),D,6.(B),F>   ;SAVE POINTER TO DISPLAY MEM, X INDEX(XDIM),SHIFT
	MOV 8.(B),A	;A GETS Y INDEX (YDIM)
	ADD #HEADER,B
;	JSR PC,TVMON	;TURN ON TVMAP
;	JMP A

;	SPOP A
;
;	MOVB #1., TVINCR
;	SUB #2., 4(P)			;Because TVINCR adds 2 to TVRADR.
;	MOV D, TVRADR	
	CLRB TVINCR

LOOP1:	MOV 2(P),C	;A:counter y,B:pointer into array C:counter x
;D: pointer into display mem. E:,F: used for shift
;stack @P shift,2(P) counter x needed to restore,4(P) points to next line of disp. mem.
LOOP2:	MOV #-1,E		;SET ALL THE BITS IN E FOR THE SHIFT	MOV (B)+,F
	MOV (B)+,F
	ASHC (P),E
	BIS 6.(P),E
;	COM F				;Write words in F and E on screen.
	MOV E, TVMSK			;(This loop can be optimized...)
	MOV D,TVRADR
	MOV WINDATA, TVRWIN
	ADD #2.,D
;	COM E
	MOV F, TVMSK
	MOV D,TVRADR
	MOV WINDATA, TVRWIN
;	BIS F,(D)+
;	BIS E,(D)

	SOB C,LOOP2
	ADD #BYTLIN,4(P)
	MOV 4(P),D
;	ADD 4(P), TVRADR
;	ADD 4(P),D
	SOB A,LOOP1

	ADD #8.,P	;CLEAR STACK
	REST <TVSEL, WINDATA>
	SEZ 
	RTS PC

