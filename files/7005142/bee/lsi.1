	.TITLE SIMPLE LSI HACK
.INSRT SITS;SITMAC >

TKS==177560
TKB==177562
TPS==177564
TPB==177566

ATODCS==176770
ATODB==176772

;ATOD INTERRUPT VECTOR
.=130
ATODBK
200

CONCHN==0	;THE CONTROL CHANNEL
INTCHN==1	;THE INTEGRATOR CHANNEL
NCHANS==2	;NUMBER OF CHANNELLS

NINTS==NCHANS	;WELL, NO NEED FOR MORE THAN ONE INTEGRATOR/CHANNEL
NSHAPE==NCHANS*2	;AVERAGE OF 2 SHAPERS/CHANNEL

.MACRO VARCONS A,B,C	;CONS UP A VARIABLE
A'B'C
.ENDM

.MACRO VARDEF A,B,C	;DEFINE A VARIABLE
VARCONS A,B,C'=.+VAROFF
.ENDM


.=400
JMP START	;STARTING ADDRESS

.BLKW 20
PDL:
PAT::
PATCH:	.BLKW 40

INITBG:	;START OF THE INIT BLOCK

.REPT NCHANS	;VARIABLES ON THE PER CHANNEL BASIS
VARDEF SM,\.RPCNT,TIM
1	;DEFINE THE SAMPLE TIMES FOR THE CHANNELS
.ENDR

.REPT NCHANS
VARDEF TIM,\.RPCNT,
0	;DEFINE THE TIMERS FOR THE CHANNELS
.ENDR

.REPT NCHANS
VARDEF BUFP,\.RPCNT,
VARCONS BUF,\.RPCNT	;DEFINE THE BUFFER POINTERS FOR EACH CHANNEL
.ENDR

.REPT NCHANS
VARDEF BUFEN,\.RPCNT,
VARCONS BFEND,\.RPCNT	;THE END OF THE BUFFERS FOR EACH CHANNEL
.ENDR

.REPT NCHANS
VARDEF BUFBG,\.RPCNT,
VARCONS BUF,\.RPCNT,	;THE BEGINNING OF THE BUFFERS FOR EACH CHANNEL
.ENDR

.REPT NINTS
VARDEF INT,\.RPCNT,CH
0	;THE CHANNEL THAT THIS INTEGRATOR IS ASSIGNED TO
.ENDR

.REPT NINTS
VARDEF INT,\.RPCNT,
.BLKW 2	;THE INTEGRATOR 
.ENDR

.REPT NINTS
VARDEF IN,\.RPCNT,LEN
1	;THE LENGTH OF THE INTEGRATION
.ENDR

.REPT NSHAPE
VARDEF SH,\.RPCNT,CHN	;DEFINE THE CHANNEL NUMBER OF THE SHAPER
0
.ENDR

.REPT NSHAPE
VARDEF SH,\.RPCNT,MXT	;DEFINE THE MAXIMUM TIMES FOR THE SHAPES
			;IF < MIN TIMES, => MAX TIME = INFINITY
2
.ENDR

.REPT NSHAPE
VARDEF SH,\.RPCNT,MNT	;DEFINE THE MINIMUM TIMES FOR THE SHAPES
1
.ENDR

.REPT NSHAPE
VARDEF SH,\.RPCNT,MXV	;DEFINE THE MAXIMUM VALUES FOR THE SHAPER
1000
.ENDR

.REPT NSHAPE
VARDEF SH,\.RPCNT,MNV	;DEFINE THE MINIMUM VALUES FOR THE SHAPER
-1000
.ENDR

VAROFF==.-INITBG

VARS::
.=.+VAROFF	;RESERVE STORAGE FOR THE VARIABLES


BUG:	HALT
CMDTAB:	BUG
.REPT NCHANS
VARCONS SMP,\.RPCNT,TM	;SETS OF THE SAMPLE TIME FOR THE CHANNELS
.ENDR			;FOUND AT SMP0TM...

.REPT NINTS
VARCONS IN,\.RPCNT,CHN	;SETS OF THE INTEGRATOR CHANNELS
.ENDR			;FOUND AT IN0CHN:...

.REPT NINTS
VARCONS INT,\.RPCNT,TM	;SETS OF THE INTEGRATION TIMES FOR THE INTEGRATORS
.ENDR			;FOUND AT INT0TM:

.REPT NINTS
VARCONS VAL,\.RPCNT,IN	;RETURNS OF THE INTEGRATION VALUES
.ENDR			;FOUND AT VAL0IN:

.REPT NINTS
VARCONS VAL,\.RPCNT,DF	;RETURNS OF THE DIFFERENTIATORS VALUES
.ENDR			;FOUND AT VAL0DF:

.REPT NSHAPE
VARCONS SHPCH,\.RPCNT	;SET THE CHANNEL FOR THE SHAPERS
.ENDR			;FOUND AT SHPCH0:

.REPT NSHAPE
VARCONS SHVMX,\.RPCNT	;SET OF THE MAXIMUM VALUES FOR THE SHAPERS
.ENDR			;FOUND AT SHVMX0:

.REPT NSHAPE
VARCONS SHVMN,\.RPCNT	;SET OF THE MINIMUM VALUES FOR THE SHAPERS
.ENDR			;FOUND AT SHVMN0:

.REPT NSHAPE
VARCONS SHTMX,\.RPCNT	;SET OF THE MAXIMUM TIMES FOR THE SHAPERS
.ENDR			;FOUND AT SHTMX0:

.REPT NSHAPE
VARCONS SHTMN,\.RPCNT	;SET OF THE MINIMUM TIMES FOR THE SHAPERS
.ENDR			;FOUND AT SHTMN0:

.REPT NSHAPE
VARCONS SHAP,\.RPCNT,P	;RETURN TRUE OR FALSE OF THIS SHAPER
			;(0 <= FALSE 1 <= TRUE)
.ENDR			;FOUND AT SHAP0P:

MAXCMD==<.-CMDTAB>/2

START:	RESET
	MOV #PDL,P
	MOV #INITBG,A	;POINTERS TO INITIAL VARIABLES
	MOV #VAROFF/2,B	;LENGTH
	MOV #VARS,C	;POINTERS TO THE ACTUAL VARIABLES
INITLP:	MOV (A)+,(C)+	;COPY THEM
	SOB B,INITLP
	MTPS #0		;INTERRUPT ENABLE
	MOV #102,ATODCS	;SET ITS INTERRUPT ENABLE, AND CONVERT A CHANNEL
TTYLOP:	JSR PC,TYI	;GET A CHARACTER
	BEQ TTYLOP	;0 COMMAND
	CMP A,#MAXCMD	;IS THE COMMAND TO BIG
	BHIS TTYLOP	;IGNORE
	ASL A
	JSR PC,@CMDTAB(A)	;DO THAT COMMAND
	BR TTYLOP

ATODBK:	TST ATODCS	;ERROR?
	BMI ATODER	;ERROR
	SAVE <A,B,C>
	MOVB ATODCS+1,C	;GET THE CHANNEL NUMBER
	CMP C,#NCHANS-1	;POINTS TO THE LAST CHANNEL?
	BEQ ATDHGH	;YES
	INCB ATODCS+1	;NEXT CHANNEL
	BR ATDNXT	;HANDLE THIS ONE
ATDHGH:	CLRB ATODCS+1	;RESET TO CHANNEL 0
ATDNXT:	ASL C		;TURN INTO INDEX
	MOV ATODB,B	;GET THE DATA
	ADD B,INT0+2(C)	;ADD IT INTO THE ACCUMULATOR FOR THIS CHANNEL
	ADC INT0(C)	;DOUBLE PRECISION WITH A KLUDGE
	TST B		;NEGATIVE?
	BPL 1$
	DEC INT0(C)	;BECAUSE NORMALLY ADDED -1 TO THIS
1$:	INC TIM0(C)	;INCREMENT THE TIME FOR THIS ONE
	CMP TIM0(C),SM0TIM(C)	;TIME TO PUT INTO THE BUFFER YET
	BLO ATODDN	;NO, JUST FORGET IT FOR NOW
	MOV INT0(C),A	;GET THE HIGH PART OF THE SUM
	MOV INT0+2(C),B	;AND THE LOW ORDER
	DIV TIM0(C),A	;GET THE AVERAGE INTO A
	CLR INT0(C)	;CLEAR THE INTEGRATORS
	CLR INT0+2(C)
	MOV BUFP0(C),B	;GET POINTER TO THE BUFFER
	MOV A,(B)+	;PUT IT IN
	CMP BUFEN0(C),B	;IS IT PAST THE END
	BHI BUFOK	;NO, MUST BE OKAY
	MOV BUFBG0(C),B	;RESET THE POINTER
BUFOK:	MOV B,BUFP0(C)	;PUT BACK THE POINTER
	CLR TIM0(C)	;RESET THE COUNTER	
ATODDN:	REST <C,B,A>	;GET BACK REGS
	RTT
ATODER:	TST ATODB	;CAUSE ANOTHER CONVERSION ON ERROR
	RTT	

.REPT NINTS
VARCONS VAL,\.RPCNT,IN:
VARCONS ^/MOV INT/,\.RPCNT,^/CH,F/	;CONS UP MOV INT0CH,F
	BR VALIN	;AND BRANCH TO EVALUATOR
.ENDR

VALIN:	MOV BUFP0(F),A	;GET POINTER TO THE FIRST BUFFER
	MOV A,B		;COPY IT
	SUB BUFBG0(F),B	;THE NUMBER OF BYTES BEFORE RESETTING VALUE
	ASR B		;DIVIDE BY TWO
	MOV BUFEN0(F),C	;THE VALUE TO RESET IT TO
	MOV IN0LEN(F),D	;THE NUMBER OF VALUES TO GET
	JSR PC,VALINT	;GET THE INTEGRATION VALUE FOR THIS
	JMP WORDO	;AND OUTPUT IT

;CLOBBERS ALL REGISTERS
VALINT:	SAVE D		;NUMBER OF INTEGRATION VALUES WE ARE TAKEINGING
	CLR F		;ACCUMULATE THE INTEGRATION HERE
	CLR E		;FOR DIVIDE PURPOSES
	TST B		;ANY VALUES?
	BEQ VALRST	;NO, RESET THE POINTER
INTLOP:	ADD -(A),F	;ADD IN THIS VALUE
	ADC E		;ADD IN THE OVERFLOW
	TST (A)		;GET THE NEXT VALUE
	BPL 1$		;EVERYTHING IS FINE
	DEC E		;WE WOULD NORMALLY ADD A -1 IF THIS WAS REAL DOUBLE PRES.
1$:	DEC D		;DONE INTEGRATING?
	BEQ INTDON	;YES
	SOB B,INTLOP	;NUMBER OF VALUES TO TAKE BEFORE RESETTING
VALRST:	MOV D,B		;SO THAT WE NEVER RESET AGAIN
	MOV C,A		;RESET THE POINTER
	BR INTLOP	;KEEP ON INTEGRATING
INTDON:	DIV (P)+,E	;DIVIDE TO GET THE AVERAGE
	MOV E,A		;THE WORD TO SEND
	RTS PC


.REPT NINTS
VARCONS VAL,\.RPCNT,DF:
VARCONS ^/MOV INT/,\.RPCNT,^/CH,F/	;CONS UP MOV INT0CH,F
	BR VALDIF	;AND BRANCH TO EVALUATOR
.ENDR

VALDIF:	MOV BUFP0(F),A	;GET POINTER TO THE FIRST BUFFER
	SAVE A		;SAVE IT FOR LATER
	MOV A,B		;COPY IT
	SUB BUFBG0(F),B	;THE NUMBER OF BYTES BEFORE RESETTING VALUE
	ASR B
	MOV BUFEN0(F),C	;THE VALUE TO RESET IT TO
	MOV IN0LEN(F),D	;THE NUMBER OF VALUES TO GET
	SAVE F		;SAVE THE INDEX
	JSR PC,VALINT	;GET THE INTEGRATION VALUE FOR THIS
	REST F		;GET BACK THE INDEX
	REST B		;GET BACK THE VALUE THAT WE STARTED AT
	SAVE A		;AND SAVE THE NEW INTEGRATION
	SUB IN0LEN(F),B	;MAKE THE POINTER POINT TO THE START OF THE PREVIOUS INTEGRATION
	SUB IN0LEN(F),B
	CMP B,BUFBG0(F)	;HAS IT RUN OFF THE END?
	BHIS 1$		;NO, MUST BE OKAY
	SUB BUFBG0(F),B	;GET THE OFFSET FROM THE START OF THE BUFFER
	ADD BUFEN0(F),B	;AND MAKE IT POINT TO THE END OF THE BUFFER
1$:	MOV B,A		;SAVE THE POINTER
	SUB BUFBG0(F),B	;AND FIND OUT HOW MUCH IS THERE
	ASR B
	MOV BUFEN0(F),C	;AS ABOVE
	MOV IN0LEN(F),D	;DITTO
			;HERE WE ARE DONE WITH THE INDEX, SO LET IT GET CLOBBERED
	JSR PC,VALINT	;THE OLD INTEGRATION VALUE INTO A
	SUB (P)+,A	;AND GET DERIVATIVE
	NEG A		;BUT WE WANT NEW-OLD, NOT THE OTHER WAY
	JMP WORDO	;AND SEND IT

;INT0TM: MOV #IN0LEN,F
;	BR SETVAR

.REPT NINTS
VARCONS INT,\.RPCNT,TM:
VARCONS ^/MOV #IN/,\.RPCNT,^/LEN,F/
	BR SETVAR
.ENDR

;SMP0TM: MOV #SM0TIM,F
;	BR SETVAR

.REPT NCHANS
VARCONS SMP,\.RPCNT,TM:
VARCONS ^/MOV #SM/,\.RPCNT,^/TIM,F/
	BR SETVAR
.ENDR

;SHVMX0: MOV #SH0MXV,F
;	BR SETVAR
;SHVMN0: MOV #SH0MNV,F
;	BR SETVAR
;SHTMX0: MOV #SH0MXT,F
;	BR SETVAR
;SHTMN0: MOV #SH0MNT,F
;	BR SETVAR

.REPT NSHAPE
VARCONS SHVMX,\.RPCNT,:
VARCONS ^/MOV #SH/,\.RPCNT,^/MXV,F/
	BR SETVAR

VARCONS SHVMN,\.RPCNT,:
VARCONS ^/MOV #SH/,\.RPCNT,^/MNV,F/
	BR SETVAR

VARCONS SHTMX,\.RPCNT,:
VARCONS ^/MOV #SH/,\.RPCNT,^/MXT,F/
	BR SETVAR

VARCONS SHTMN,\.RPCNT,:
VARCONS ^/MOV #SH/,\.RPCNT,^/MNT,F/
	BR SETVAR

.ENDR

SETVAR:	JSR PC,WORDI
	MOV A,(F)
	RTS PC

;IN0CHN: MOV #INT0CH,F
;	BR SETCHN

.REPT NINTS
VARCONS IN,\.RPCNT,CHN:
VARCONS ^/MOV #INT/,\.RPCNT,^/CH,F/
	BR SETCHN
.ENDR

;SHPCH0: MOV #SH0CHN,F
;	BR SETCHN
.REPT NSHAPE
VARCONS SHPCH,\.RPCNT,:
VARCONS ^/MOV #SH/,\.RPCNT,^/CHN,F/
	BR SETCHN
.ENDR

SETCHN:	JSR PC,WORDI
	ASL A		;SO IT IS A CHANNEL INDEX
	MOV A,(F)
	RTS PC

;SHAP0P: MOV SH0CHN,F	;SET UP INDEX
;	BR SHPVAL	;GET THE VALUE

.REPT NSHAPE
VARCONS SHAP,\.RPCNT,P:
VARCONS ^/MOV SH/,\.RPCNT,^/CHN,F/
	BR SHPVAL
.ENDR

SHPVAL:	MOV BUFP0(F),A	;GET THE POINTER TO THE FIRST BUFFER
	MOV A,B		;COPY IT
	SUB BUFBG0(F),B	;THE NUMBER OF BYTES BEFORE RESETTING THE VALUE
	ASR B		;FROM BYTES TO WORDS
	MOV SH0MNT(F),C	;THE MINIMUM TIME TO LOOK FOR
	MOV SH0MNV(F),D	;THE MINIMUM VALUE FOR SAMPLES
	MOV SH0MXV(F),E	;THE MAXIMUM VALUE FOR SAMPLES
	TST B		;SAMPLES BEFORE RESETTING
	BNE SHPLP1	;> 0
	JSR PC,SHPRST	;RESET THE POINTERS
SHPLP1:	CMP -(A),D	;IS IT < THE MINIMUM VALUE
	BLT SHPLOS	;YES, LOSER RETURN FALSE
	CMP (A),E	;> MAX VALUE?
	BGT SHPLOS	;YES, MUST LOSE
	DEC B		;ONE LESS SAMPLE BEFORE RESETTING
	BGT SHPLP2	;CHECK TO SEE IF DONE
	JSR PC,SHPRST	;RESET THE VALUES
SHPLP2:	DEC C		;DECREMENT THE TIME
	BNE SHPLP1	;DONE IF 0
	MOV SH0MXT(F),C	;GET THE MAXIMUM TIME
	BMI SHPWIN	;NEGATIVE, THEN WE ARE DONE, AND IT MUST BE TRUE
	SUB SH0MNT(F),C	;SUBTRACT THE NUMBER OF SAMPLES STILL TO LOOK FOR
	BMI SHPWIN	;MAX < MIN TIMES, THUS WE ARE DONE (SAME AS MAX TIME < 0)
;NEXT LOOP CHECKS TO MAKE SURE IT EXCEEDS MAX OR IS < MIN IN THE SLOP AREA
SHPLP3:	CMP -(A),D	;IS IT < MIN VALUE
	BLT SHPWIN	;YES, THEN WE WIN
	CMP (A),E	;IS IT > MAX VALUE?
	BGT SHPWIN	;YES, THEN WE WIN
	DEC C		;STILL IN SLOP AREA?
	BEQ SHPLOS	;NO, SO WE HAVE LOST
	DEC B		;SHOULD WE RESET?
	BGT SHPLP3	;NO
	JSR PC,SHPRST	;RESET THE VALUES
	BR SHPLP3	;CONTINUE LOOKING
SHPLOS:	CLR A		;LOSER
	BR SHPDN1
SHPWIN:	MOV #1,A	;IT IS TRUE
SHPDN1:	JMP WORDO	;OUTPUT IT
SHPRST:	MOV #BUFLEN,B	;THE NUMBER OF WORDS IN BUFFER
	MOV BUFEN0(F),A	;THE VALUE OF THE END OF BUFFER
	RTS PC

TYI:	TSTB TKS
	BPL TYI		;NOTHING YET
	MOV TKB,A	;GET THE BYTE
	RTS PC

TYO:	TSTB TPS	;READY?
	BPL TYO
	MOV A,TPB	;SEND IT OUT
	RTS PC

WORDO:	JSR PC,TYO
	ASL A		;TO CHOP OF THE TOP TWO BITS
	SWAB A
	JSR PC,TYO
	RTS PC

.REPT 0
;SHOULD LOOK LIKE THIS
	JSR PC,TYO	;SEND FIRST CHARACTER
	SWAB A		;GET THE NEXT ON
	JSR PC,TYO
	RTS PC
.ENDR

WORDI:	JSR PC,TYI	;GET CHARACTER
	SAVE A
	JSR PC,TYI	;GET NEXT CHARACTER
	SWAB A
	BIS A,(P)	;PUT INTO THE TOP BYTE
	REST A
	RTS PC

PRGEND==.
TSPACE==<17400-.>/2	;TOTAL AMOUNT OF SPACE FOR BUFFERS IN WORDS
BUFLEN==TSPACE/NCHANS	;MAKE IT NUMBER OF WORDS/BUFFER

.REPT NCHANS

VARCONS BUF,\.RPCNT,:	;DEFINE THE START OF THE BUFFERS
.BLKW BUFLEN		;BUFLEN NUMBER OF WORDS LONG

VARCONS BFEND,\.RPCNT,=.	;AND DEFINE THE END OF THE BUFFERS

.ENDR

.END START
