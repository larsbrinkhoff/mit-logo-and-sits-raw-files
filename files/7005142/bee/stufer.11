	.TITLE STUFFER
.INSRT SITS;SITSS SYMS
.INSRT SITS;SITMAC >
.=400
PDL:
	.BLKW 10	;INTERRUPT PROCESS PDL
INPDL:
LSICAP:	0		;CAPABILITY TO LSI
TTYNUM:	12.		;TTY NUMBER OF THE LSI
FILCAP:	0		;CAP TO FILE
DONFLG:	0
TXT==TEXTBG		;BEGINNING OF TEXT
.MACRO TYPEIT TEXT
	MOV #TXT,-(P)
	MOV #<-<<.LENGTH ^ÔEXT¬>+1>>,-(P)
	MOV #2,-(P)
	.BLKO
.IF2
FOO==.
.=TXT
.ASCII ÔEXTŠ.BYTE 15
TXT==.
.=FOO
.ENDC
.ENDM

.MACRO ERROR TEXT
	BNE .+<11*2>
	TYPEIT ^ÔEXTŠ	BPT
.ENDM


START:	MOV #PDL,P
	SAVE <,#.TLIPM!.TIRST!.TORST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;SET THE TTY STATUS FOR THIS TERMINAL
	SAVE <#-1,TTYNUM,#.TTCAP*400>
	.INVOK		;CREATE THE LSI CAPABILITY
	ERROR <LSI PORT IN USE>
	REST LSICAP
	SAVE <,#27303,#.TTSPD*400>
	MOVB LSICAP,(P)	;SET IN LSI CAP NUMBER
	.INVOK		;SET SPEED TO 9600, 8 BITS, NO PARITY
	BNE STARTL	;START LOAD
	TYPEIT <CANT SET SPEED, CONTINUING ANYWAY>
STARTL:	SAVE <,#.TIMGI!.TIMGO.!.TIRST!.TORST,#.TTMOV*400>
	MOVB LSICAP,(P)	;SET THE LINE TO IMAGE IN AND OUT
	$INVOK
	SAVE <,#4,#.TBRAK*400>	;TRANSMIT BREAK ON LINE
	MOVB LSICAP,(P)
	$INVOK		;CAUSE THE BREAK TO HAPPEN
	SAVE <#15,LSICAP>	;TRANSMIT CR.
	$BYTO		;SEND IT
	MOV #10.,A	;10 ITERATIONS OF SLEEPING FOR 1/10 SEC
WAIT1:	SAVE <,,#.TTPEK*400>	;PEEK AT THE LINE
	MOVB LSICAP,(P)	;GET CHARACTERS?
	$INVOK		;PEEK AWAY
	TST (P)+	;GOT ANY?
	BPL GOTCHR	;GOT A CHARACTER
	SAVE <#0,#6>	;TAKE A SNOOZE
	$SLEEP		;ZZZZZZ
	SOB A,WAIT1	;WAIT AWAY
	TYPEIT <NO RESPONSE FROM LSI11 TRY AGAIN?>
	SAVE <,#.TIRST!.TORST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;RESET TTY INTO CHARACTER AT A TIME MODE
	SAVE #2		;INPUT CHARACTER
	$BYTI		;GET IT
	SAVE <,#.TLIPM!.TIRST!.TORST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;SET THE TTY STATUS FOR THIS TERMINAL
	CMPB (P)+,#'Y	;YES?
	BEQ STARTL	;TRY IT AGAIN
	BPT
GOTCHR:	SAVE LSICAP	;READ UNTIL YOU GET AN @
	$BYTI		;READ CHARACTER
	CMPB (P)+,#'@	;FOUND IT?
	BNE GOTCHR	;NOPE
	TYPEIT <LSI READY>
GETLIN:	MOV #LINBUF,A	;LINE BUFFER
	MOV #LINLEN,B	;LENGTH OF BUFFER
CHRLOP:	SAVE #2		;READ CHARACTER
	$BYTI		;GET BYTE
	CMPB (P),#15	;CR?
	BEQ GETFIL	;DONE
	MOVB (P)+,(A)+	;GO PUT IT INTO BUFFER
	SOB B,CHRLOP	;OUTPUT IT
	TYPEIT <LINE TOO LONG, RETRY>
	BR GETLIN	;TRY TRY AGAIN
GETFIL:	CLRB (A)	;MAKE SURE IT IS ZERO
	MOV #LINBUF,F	;POINTER TO THE BUFFER
	SUB F,A		;GET THE CHARACTER COUNT
	DEC A		;ONE LESSU
	MOV #LINBUF+1,C	;POINTER TO THE BUFFER+1 FOR PARSE FOR ";
DSKLOP:	CMPB (C)+,#';	;PARSE FOR ;
	BEQ FNDDSK	;FOUND DISK SPEC.
DSKLP1:	SOB A,DSKLOP
	MOV #4,D	;THE BASE CAPABILITY
	BR MUTFIL	;GO TO THE MUTATE DIRECTLY
FNDDSK:	MOVB -2(C),D	;GET THE CHARACTER BEFORE ;
	BIC #177400,D	;LOSING REGISTER CRUD
	SUB #'0,D	;TURN IT INTO NUMBER IF IT IS ONE
	BMI DSKLP1	;KEEP ON TRYING
	CMP D,#4	;IS IT TO BIG?
	BHI DSKLP1	;KEEP TRYING
	ADD #10,D	;GET THE START TO BE THAT DISK'S ROOT
	MOV C,F		;POINTER TO THE BUFFER
MUTFIL:	SAVE <#-1,,D>	;COPY THE STARTING CAPABILITY
	BIS #.CPYCP,(P)
	.INVOK		;TRY TO COPY IT
	BNE 1$
	TYPEIT <CANT COPY DEFAULT, RETYPE>
	BR GETLIN	;GET LINE AGAIN
1$:	REST FILCAP	;CAP TO FILE
	SAVE <#0,F,FILCAP>	;MUTATE IT
	BIS #.FAMU,(P)
	.INVOK		;AWAY
	BNE 2$		;WON
	TYPEIT <CANT MUTATE TO FILE, RETYPE NAME>
	BR GETLIN
2$:	SAVE #INTPRS	;START PROCESS AT INTPRS
	$FORK		;FOR DETECTING A QUIT SIGNAL
	SAVE <#LSILOD,#-LSILEN,LSICAP>	;OUTPUT LOAD COMMAND
	$BLKO		;SEND IT TO LSI
LLOP:	SAVE LSICAP	;LOOP UNTIL L SEEN
	$BYTI
	CMPB (P)+,#'L	;L YET?
	BNE LLOP	;NOPE
	SAVE <#0,#5*60.>
	$SLEEP
	SAVE <#LSIBOT,#-LSIBLN,LSICAP>	;OUTPUT THE ABSOLUTE LOADER
	$BLKO		;GOT IT
ATLOP:	SAVE LSICAP	;WAIT FOR @ TO COME BACK
	$BYTI
	CMPB (P)+,#'@
	BNE ATLOP	;NOT YET
	SAVE <#'P,LSICAP>	;OUTPUT P FOR PROCEDE
	$BYTO		;AND SEND IT
PLOP:	SAVE LSICAP	;WAIT FOR P
	$BYTI
	CMPB (P)+,#'P
	BNE PLOP
	SAVE <#3400,,#27*400+377,#.CRWRT+1>	;GET PAGE BELOW FILE PAGE
	$MAP		;MAP IT IN
	CLR A		;PAGE COUNTER FOR MAPS
	CLR C		;NUMBER OF BYTES WE ARE WORKING ON
MAPLOP:	SAVE <#177400,A,FILCAP,#.CRRD+1>	;MAP IN THE FILE (AS MUCH AS POSSIBLE
	MOVB #27,3(P)	;PAGE IS TOP PAGE IN CORE
	$MAP		;SHOULDN'T LOSE
	INC A		;SO THAT WE GET THE NEXT PAGE
	MOV #20000,B	;THE LENGTH OF A PAGE
BLKLOP:	CMP C,B		;MORE THAN A PAGE WORTH TO DO?
	BGE SNDPAG	;SEND THE PAGE, AND CONTINUE
	TSTB 160000(C)	;PADDING FOR BLOCK?
	BNE 3$		;NO
	INC C		;NEXT BYTE
	BR BLKLOP
3$:	CMP C,#20000-4	;COUNT ON THIS PAGE?
	BLE 1$		;YES, EVERYTHING IS OKAY
	MOV C,D		;COPY POINTER
	ADD #140000,D	;POINT TO PREVIOUS PAGE TO COPY DATA
2$:	MOVB 20000(D),(D)+	;PUT THE BYTE AWAY
	CMP D,#160000	;AT END OF PAGE?
	BLO 2$		;NO
	BR SNDPAG	;SEND THIS PAGE, WE WILL CHECK LENGTH NEXT TIME
1$:	MOVB 160003(C),D	;GET THE TOP BYTE OF THE LENGTH
	SWAB D		;PUT INTO TOP BYTE
	BIC #377,D	;CLEAR LOW BYTE
	BISB 160002(C),D	;SET IN LOW PART OF LENGTH
	ADD D,C		;ADD TO BYTE COUNT TO SEND
	INC C		;ONE FOR THE CHECKSUM
	CMP D,#6	;DONE?
	BNE BLKLOP	;NO, CONTINUE
LODDON:	MOV C,B		;THE NUMBER OF BYTES TO SEND
	MOV #-1,DONFLG	;SAY WE ARE DONE
SNDPAG:	NEG B		;NUMBER OF BYTES TO SEND
	SAVE <#160000,B,LSICAP>	;SEND BYTES
	$BLKO		;BLOCKOUT
	SUB #20000,C	;MAKE IT 1 PAGE LESS
	TST DONFLG	;DONE?
	BEQ MAPLOP	;NO
	TYPEIT <FINISHED!!!>
DONE:	BPT
INTPRS:	MOV #INPDL,P
	SAVE <,#.TIRST!.TIECM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;SET TTY TO CHARACTER AT A TIME
WAITI:	SAVE #2		;GET CHAR
	$BYTI
	CMPB (P)+,32	;CTL-Z?
	BNE WAITI	;NOPE
	BPT
	BR WAITI

SNOOZE:	SAVE <#0,#60.>	;TAKE A SNOOZE
	$SLEEP		;ZZZZZZ
	RTS PC

LINBUF:	.BLKW 60
LINLEN==.-LINBUF
LSILOD:	.ASCII /177560L/
LSILEN==.-LSILOD
LSIBOT:
.INSRT BEE;ABS >
LSIBLN==.-LSIBOT
.EVEN
TEXTBG==.
.END START
