.TITLE FPSW
.SBTTL MACROS

.INSRT GLD;MACROS >
.IRP OP,<ADD,SUB>
.MACRO OP'V V1,V2
.IF B V1
	.IF B V2
	ASL A
	ASL B
	ASL C
	.IFF
	OP A,V2'X
	OP B,V2'Y
	OP C,V2'Z
	.ENDC
.IFF
	.IF B V2
	OP V1'X,A
	OP V1'Y,B
	OP V1'Z,C
	.IFF
	OP V1'X,V2'X
	OP V1'Y,V2'Y
	OP V1'Z,V2'Z
	.ENDC
.ENDC
.ENDM
.ENDM

.MACRO SAVEV V
.IF NB V
	SAVE <V'Z,V'Y,V'X>
.IFF
	SAVE <C,B,A>
.ENDC
.ENDM

.MACRO FLUSHV
	ADD #6,P
.ENDM

.MACRO LDV V
	MOV V'X,A
	MOV V'Y,B
	MOV V'Z,C
.ENDM

.MACRO STV V
	MOV A,V'X
	MOV B,V'Y
	MOV C,V'Z
.ENDM

.MACRO NEGV V
.IF NB V
	NEG V'X
	NEG V'Y
	NEG V'Z
.IFF
	NEG A
	NEG B
	NEG C
.ENDC
.ENDM

.MACRO VECTOR V
V'X:	0
V'Y:	0
V'Z:	0
.ENDM

.SBTTL DATA

	.BLKW 100
PDL:

DISCAP:	0
COUNT:	0
DELAY:	1

DIST:	200.
OLDX:	0
OLDY:	0
DRAWF:	0

DLIST:	9.


.IRPC Z,<012345678>
.XPNT'Z:	0
.YPNT'Z:	0
.ENDM

	9.

.IRPC Z,<012345678>
.XPN.'Z:	0
.YPN.'Z:	0
.ENDM

	0

ODLIST:	.BLKW 100

TINC:	4000
RINC:	1000

HEAD:
RIGHT:
RIGHTX:	37777
RIGHTY:	0
RIGHTZ:	0
UP:
UPX:	0
UPY:	37777
UPZ:	0
BACK:
BACKX:	0
BACKY:	0
BACKZ:	37777

ROTS:
PITCH:	0
YAW:	0
ROLL:	0

THRUST:	0

POSX:	0	;HI WORDS
POSY:	0
POSZ:	50.

POSAX:	0	;LO WORDS
POSAY:	0
POSAZ:	0

VELX:	0	;LO WORDS
VELY:	0
VELZ:	0

VELBX:	0	;HI WORDS
VELBY:	0
VELBZ:	0

.HEAD:
.RIGH:
.RIGHX:	37777
.RIGHY:	0
.RIGHZ:	0
.UP:
.UPX:	0
.UPY:	37777
.UPZ:	0
.BACK:
.BACKX:	0
.BACKY:	0
.BACKZ:	37777

.ROTS:
.PITCH:	0
.YAW:	0
.ROLL:	4000


.SLEN:	20.
.SLEN1:	14.
.TLEN:	4.

.SBTTL EXECUTIVE LOOP

GO:	MOV #PDL,P	;INIT STACK PTR
	CREATE .DSCAP,#140002	;CREATE A TV DISPLAY CAPABILITY
	REST DISCAP	;PUT CAP # IN DISPLAY
	INVOK #TTYCAP,<#.TTMOV*400>,#.TICTM+.TIMGO	;SET TTY STATUS

GO1:	BYTO #TTYCAP,#14	;CLEAR SCREEN
	BYTO #TTYCAP,#10	;AND RUB OUT RESULTING *
	BYTO #TTYCAP,#'N-100	;FLUSH CORSOR
	CLR DRAWF	;DISABLE DISPLAY FOR INITIAL ERASE

LOOP:	INC COUNT	;FOR CHECKING TIME CONSUMPTION
	JSR PC,TTREAD	;READ TTY CHAR, OBEY COMMAND
	JSR PC,UPDATE	;UPDATE THE UNIVERSE
	JSR PC,UPDISP	;CREATE NEW DLIST
	JSR PC,ERASE	;ERASE SCREEN VIA OLD DLIST, THEN MAKE NEW ONE OLD
	JSR PC,REFRES	;DISPLAY NEW SCREEN VIA NEW OLD DLIST

	JMP LOOP

.SBTTL TELETYPE COMMAND INTERPRETER

TTREAD:	INVOK #TTYCAP,#.TTPEK*400	;CHAR TYPED SINCE WE LAST LOOKED?
	TST (P)+
	BMI 1$		;NO, NOOP
	BYTI #TTYCAP	;YES, GET IT
	REST A
	ASL A
	JSR PC,@DISP(A)	;AND OBEY IT
1$:	RTS PC

DISP:	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTQUIT	;0-7 ^G
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;10-17
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;20-27
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;30-37
	TTXXXX,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;40-47 SPACE
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTPD,  TTNOOP,TTYRPD,TTNOOP	;50-57 , .
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTRL	;60-67 7
	TTRX,  TTRR,  TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;70-77 8 9
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;100-107
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;110-117
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;120-127
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;130-137
	TTNOOP,TTNOOP,TTNOOP,TTC,   TTNOOP,TTNOOP,TTNOOP,TTNOOP	;140-147 c
	TTTX  ,TTPU,  TTYL,  TTYXPX,TTYR  ,TTYLPD,TTTR,  TTYRPU	;150-157 h i j k l m n o
	TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTYLPU,TTNOOP,TTNOOP	;160-167 u
	TTNOOP,TTTF  ,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP,TTNOOP	;170-177 y

TTNOOP:	RTS PC

TTQUIT:	BYTO #TTYCAP,#'B-100	;RESTORE CURSOR
	BPT
	MOV #PDL,P
	JMP GO1

TTC:	CLR COUNT	;INIT LOOP COUNT
	RTS PC

TTTF:	ADD TINC,THRUST
	RTS PC

TTTR:	SUB TINC,THRUST
	RTS PC

TTXXXX:
TTTX:	CLR THRUST
	RTS PC

TTYR:	SUB RINC,YAW
	RTS PC

TTYL:	ADD RINC,YAW
	RTS PC

TTPU:	SUB RINC,PITCH
	RTS PC

TTPD:	ADD RINC,PITCH
	RTS PC

TTRR:	ADD RINC,ROLL
	RTS PC

TTRL:	SUB RINC,ROLL
	RTS PC

TTYRPU:	SUB RINC,YAW
	SUB RINC,PITCH
	RTS PC

TTYRPD:	SUB RINC,YAW
	ADD RINC,PITCH
	RTS PC

TTYLPU:	ADD RINC,YAW
	SUB RINC,PITCH
	RTS PC

TTYLPD:	ADD RINC,YAW
	ADD RINC,PITCH
	RTS PC

TTYXPX:	RTS PC
TTRX:	RTS PC

.SBTTL UPDATE-THE-UNIVERSE ROUTINE

;CLOBBERS ALL REGISTERS

UPDATE:	MOV #HEAD,A	;PTR TO HEADING MATRIX IN A
	MOV #ROTS,B	;PTR TO ROLL, PITCH, & YAW PARAMETERS
	JSR PC,TURN	;DO AN INCREMENTAL ROTATION

	ADD VELX,POSAX	;ADD VELOCITY TO POSITION
	ADC POSX
	ADD VELBX,POSX
	ADD VELY,POSAY
	ADC POSY
	ADD VELBY,POSY
	ADD VELZ,POSAZ
	ADC POSZ
	ADD VELBZ,POSZ

	MOV THRUST,E	;ADD THRUST*HEADING TO VELOCITY
	MOV #BACK,D
	JSR PC,MULV
	SUB A,VELX
	SBC VELBX
	TST A
	SXT D
	SUB D,VELBX
	SUB B,VELY
	SBC VELBY
	TST B
	SXT D
	SUB D,VELBY
	SUB C,VELZ
	SBC VELBZ
	TST C
	SXT D
	SUB D,VELBZ
	
	MOV #.HEAD,A	;PTR TO FORIEGN HEADING MATRIX IN A
	MOV #.ROTS,B	;PTR TO ROLL, PITCH, & YAW PARAMETERS
	JSR PC,TURN	;DO AN INCREMENTAL ROTATION

	RTS PC

;CALLED WITH SCALAR IN E, PTR TO VECTOR IN D
;LEAVES PRODUCT IN A,B,C, CLOBBERING F
;ONE MULTIPLIER IS TAKEN TO REPRESENT 2**-15 * THE ACTUAL FIXED POINT NUMBER, SO THE
; HIGH WORD OF THE PRODUCT, *2 , IS TAKEN AS THE RESULT OF EACH COMPONENT MULTIPLY

MULV:	SAVE E
	MOV (D),E
	MUL (P),E
	ASHC #2,E
	MOV E,A
	MOV 2(D),E
	MUL (P),E
	ASHC #2,E
	MOV E,B
	MOV 4(D),E
	MUL (P),E
	ASHC #2,E
	MOV E,C
	REST E
	RTS PC

;SAME AS MULV BUT VECTOR MULTIPLICAND IS IN A,B,C AND SCALAR MULTIPLIER IS IN D

MULVR:	MOV A,E
	MUL D,E
	ASHC #2,E
	MOV E,A
	MOV B,E
	MUL D,E
	ASHC #2,E
	MOV E,B
	MOV C,E
	MUL D,E
	ASHC #2,E
	MOV E,C
	RTS PC

;CLOBBERS F

TURN:	JSR PC,TURN1	;ROTATE 1ST COLUMN OF MATRIX
	ADD #2,A
	JSR PC,TURN1	;THEN 2ND
	ADD #2,A
	JSR PC,TURN1	;THEN 3RD
	RTS PC


X=	0
Y=	6
Z=	6*2

PIT=	0
YAA=	2
OLL=	4

;CLOBBERS E,F

TURN1:	MOV Y(A),E
	MUL OLL(B),E
	SUB E,X(A)	;X <= X - ROLL*Y

	MOV X(A),E
	MUL OLL(B),E
	ADD E,Y(A)	;Y <= Y + ROLL*X

	MOV Z(A),E
	MUL YAA(B),E
	SUB E,X(A)	;X <= X - YAW*Z

	MOV X(A),E
	MUL YAA(B),E
	ADD E,Z(A)	;Z <= Z + YAW*X

	MOV Z(A),E
	MUL PIT(B),E
	SUB E,Y(A)	;Y <= Y - PITCH*Z

	MOV Y(A),E
	MUL PIT(B),E
	ADD E,Z(A)	;Z <= Z + PITCH*X

	RTS PC

.SBTTL DISPLAY-UPDATE ROUTINES

;CLOBBERS

UPDISP:	MOV .SLEN,E	;LENGTH OF SIDE
	MOV #.UP,D	;PTR TO UP VECTOR
	JSR PC,MULV	;SCALE BY LENGTH OF SIDE
	SUBV POS	;SUBJECTIVE TRANSLATION
	SAVEV
	MOV P,E		;PTR TO VECTOR TO ROTATE
	MOV #HEAD,D	;PTR TO OUR HEADING MATRIX
	JSR PC,CONVRT	;SUBJECTIVE ROTATION
	MOV A,.XPNT0	;UPPER POINTS
	MOV B,.YPNT0
	MOV A,.XPNT8
	MOV B,.YPNT8
	JSR PC,REARPT
	MOV A,.XPN.0
	MOV B,.YPN.0
	MOV A,.XPN.8
	MOV B,.YPN.8
	FLUSHV

	LDV .UP
	ADDV .RIGH,
	MOV .SLEN1,D
	JSR PC,MULVR
	SUBV POS
	SAVEV
	MOV P,E
	MOV #HEAD,D
	JSR PC,CONVRT
	MOV A,.XPNT1	;UPPER-RIGHT POINT
	MOV B,.YPNT1
	JSR PC,REARPT
	MOV A,.XPN.1
	MOV B,.YPN.1
	FLUSHV

	MOV .SLEN,E
	MOV #.RIGH,D
	JSR PC,MULV
	SUBV POS
	SAVEV
	MOV P,E
	MOV #HEAD,D
	JSR PC,CONVRT
	MOV A,.XPNT2	;RIGHT POINT
	MOV B,.YPNT2
	JSR PC,REARPT
	MOV A,.XPN.2
	MOV B,.YPN.2
	FLUSHV

	LDV .RIGH
	SUBV .UP
	MOV .SLEN1,D
	JSR PC,MULVR
	SUBV POS
	SAVEV
	MOV P,E
	MOV #HEAD,D
	JSR PC,CONVRT
	MOV A,.XPNT3	;LOWER RIGHT POINT
	MOV B,.YPNT3
	JSR PC,REARPT
	MOV A,.XPN.3
	MOV B,.YPN.3
	FLUSHV
			;FALLS THRU

			;FALLS IN
	MOV .SLEN,E
	MOV #.UP,D
	JSR PC,MULV
	NEGV
	SUBV POS
	SAVEV
	MOV P,E
	MOV #HEAD,D
	JSR PC,CONVRT
	MOV A,.XPNT4	;LOWER POINTS
	MOV B,.YPNT4
	JSR PC,REARPT
	MOV A,.XPN.4
	MOV B,.YPN.4
	FLUSHV

	LDV .RIGH
	ADDV .UP
	NEGV
	MOV .SLEN1,D
	JSR PC,MULVR
	SUBV POS
	SAVEV
	MOV P,E
	MOV #HEAD,D
	JSR PC,CONVRT
	MOV A,.XPNT5	;LOWER LEFT POINTS
	MOV B,.YPNT5
	JSR PC,REARPT
	MOV A,.XPN.5
	MOV B,.YPN.5
	FLUSHV

	MOV .SLEN,E
	MOV #.RIGH,D
	JSR PC,MULV
	NEGV
	SUBV POS
	SAVEV
	MOV P,E
	MOV #HEAD,D
	JSR PC,CONVRT
	MOV A,.XPNT6	;LEFT POINTS
	MOV B,.YPNT6
	JSR PC,REARPT
	MOV A,.XPN.6
	MOV B,.YPN.6
	FLUSHV

	LDV .UP
	SUBV .RIGH
	MOV .SLEN1,D
	JSR PC,MULVR
	SUBV POS
	SAVEV
	MOV P,E
	MOV #HEAD,D
	JSR PC,CONVRT
	MOV A,.XPNT7	;UPPER LEFT POINTS
	MOV B,.YPNT7
	JSR PC,REARPT
	MOV A,.XPN.7
	MOV B,.YPN.7
	FLUSHV

	RTS PC

REARPT:	MOV .TLEN,E	;THICKNESS
	MOV #.BACK,D	;PTR TO BACK VECTOR
	JSR PC,MULV	;SCALAR MULTIPLY
	ADD A,2(P)	;ADD PRODUCT TO VECTOR SAVED BY OUR CALLER (SORRY ABOUT THIS)
	ADD B,4(P)
	ADD C,6(P)
	MOV P,E
	ADD #2,E	;PTR TO SAVED VECTOR
	MOV #HEAD,D	;PTR TO OUR HEADING MATRIX
	JSR PC,CONVRT
	RTS PC

;CALLED WITH POINTER TO HEADING MATRIX IN D, PTR TO VECTOR IN E
;RETURNS WITH SCREEN COORDS OF VECTOR PROJECTION IN A,B
;CLOBBERS ALL REGS

CONVRT:	JSR PC,DOT	;DOT CONVERTEE WITH RIGHT VECTOR
	MOV F,A

	ADD #6,D	;THEN WITH UP VECTOR
	JSR PC,DOT
	MOV F,B

	ADD #6,D	;FINALLY WITH BACK VECTOR
	JSR PC,DOT
	MOV F,C		;A,B,C NOW HOLDS SUBJECTIVE-COORDINATES VECTOR

	TST C		;NOW FOR CONVERSION TO SCREEN COORDS
	BGE OFSCRN	;IF DISTANCE IS ZERO OR POSITIVE, POINT CAN'T BE SEEN
	MOV A,E		;GET X-COORD
	MUL DIST,E	;SCALE BY DISTANCE OF VIEW PLANE
	DIV C,E		;AND BY INVERSE DISTANCE OF POINT
	MOV E,A		;RETURN X-COORD IN A
	MOV B,E		;NOW DO THE SAME FOR Y-COORD
	MUL DIST,E
	DIV C,E
	MOV E,B
	NEG A		;'CUZ WE'RE LOOKING *DOWN* THE Z-AXIS
	NEG B

	RTS PC

OFSCRN:	MOV #10000,A
	MOV #10000,B
	RTS PC

VECTOR	Q		;TEMPORARY VECTOR STORAGE FOR CONVRT

;CALLED WITH POINTER TO VECTOR IN E, POINTER TO OTHER VECTOR IN D
;PUTS DOT PRODUCT IN F
;CLOBBERS C
DOT:	SAVE E
	MOV (E),E
	MUL (D),E
	ASHC #2,E
	MOV E,C

	MOV (P),E
	MOV 2(E),E
	MUL 2(D),E
	ASHC #2,E
	ADD E,C

	MOV (P),E
	MOV 4(E),E
	MUL 4(D),E
	ASHC #2,E
	ADD E,C

	MOV C,F
	REST E
	RTS PC

.SBTTL DRAWING ROUTINES

REFRES:	MOV #ODLIST,A	;PUT PTR TO DISPLAY POINTS IN A
	MOV (A)+,B	;1ST WORD SHOULD BE # OF POINTS IN 1ST CURVE
	DEC B
	BLE 2$
	CMP -(P),-(P)	;RESERVE STACK SPACE FOR ARGS

11$:	MOV (A)+,(P)
	MOV (A)+,2(P)
	JSR PC,SET

1$:	MOV (A)+,(P)
	MOV (A)+,2(P)
	JSR PC,DRAW
	SOB B,1$

	MOV (A)+,B	;# OF POINTS IN NEXT CURVE
	DEC B
	BGT 11$
	CMP (P)+,(P)+	;FLUSH SAVED COORDS
2$:	RTS PC


ERASE:	MOV DELAY,A	;LEAVE STUFF ON SCREEN FOR A WHILE
	SOB A,.

	TST DRAWF
	BEQ 3$
	JSR PC,REFRES	;SAME CODE AS TO DRAW

3$:	MOV #DLIST,A	;THEN MAKE OLD POINTS NEW
	MOV #ODLIST,B
	MOV (A),C
	BEQ 2$
	MOV (A)+,(B)+	;1ST WORD IS # OF PTS IN 1ST CURVE

1$:	MOV (A)+,(B)+	;XFER THAT MANY POINTS
	MOV (A)+,(B)+
	SOB C,1$

	MOV (A),C	;NUMBER OF POINTS IN NEXT CURVE
	MOV (A)+,(B)+
	BNE 1$

2$:	MOV #1,DRAWF	;ENABLE DRAWING (DRAWING SKIPPED VERY FIRST TIME AROUND)
	RTS PC

;CALLED WITH X, THEN Y STACKED JUST UNDER RETURN ADDRESS
;SET PEN POSITION AND OLDX,OLDY TO X,Y

SET:	MOV 2(P),OLDX	;POP NEW X,Y POSITIONS INTO PLACE
	MOV 4(P),OLDY
	SAVE <2(P),6(P)>	;RE-PUSH X,Y FOR SYSTEM CALL
	ADD #576./2,2(P)	;CONVERT TO FUNNY SITS SCREEN COORDS
	NEG (P)
	ADD #454./2,(P)
	SAVE DISCAP
	BIS #.TVDSS*400,(P)
	.INVOK		;SET PEN POSITION
	BNE 1$		;IF OK, RETURN WITH Z CLEAR
	ADD #6,P	;FLUSH LOSING ARGS
	SEZ		;SIGNAL LOSS
1$:	RTS PC

;CALLED WITH X, THEN Y STACKED JUST UNDER RETURN ADDRESS
;DRAWS LINE FROM OLD PEN POSITION TO X,Y AND SETS OLDX,OLDY TO X,Y

DRAW:	SAVE <OLDY,OLDX>
	JSR PC,SET	;MAKE SURE PEN IS SET TO WHERE IT WAS LAST SPOZED TO BE
	BNE 2$		;IF THAT WORKED, PROCEED
	ADD #4,P	;IF NOT, WE CAN'T VERY WELL TRY TO DRAW THE LINE, CAN WE?
	BR 1$		;NO.

2$:	MOV 6(P),2(P)	;STACK X FOR SITS
	MOV 10(P),(P)	; THEN Y
	SUB OLDX,2(P)	;SITS WANTS DELTAS HERE
	NEG (P)		;(DELTA Y NEGATIVE CUZ SITS Y-COORD IS UPSIDE-DOWN)
	ADD OLDY,(P)
	SAVE DISCAP
	BIS #.TVDSX*400,(P)
	.INVOK
	BNE 1$
	ADD #6,P
1$:	MOV 2(P),OLDX
	MOV 4(P),OLDY
	RTS PC

.END GO
