	VERN=VERN+%FNAM2
	.STITL READ A STRING
RDSTR1:	PRCR	;OUTPUT - PTR ON S, SKIP UNLESS EMPTY OR BREAK
RDSTR:	CLR NBKTS
	CLR	BRAKE(U)
	CMP #TYI,GCHR	;WILL CHARS BE COMING FROM TTY?
	BNE RLINE1	;NO
	MOV PRMTCH,D
	BEQ	RLINE
	TST ALEVN
	BEQ RLINE2
	BIT #BRKF,FLAGS
	BEQ RLINE2
	MOV FUNLEV,A
	BEQ RLINE2
	MOV #'L,D
	JSR PC,TYO
	JSR PC,PRDN
	MOV PRMTCH,D
RLINE2:	JSR PC,TYO
RLINE:	TST USER
	BLT RLINE1
	PUSH	U
	MOV	USER,U
	MOV	#FRTYIH,FLSRES(U)
	JSR	PC,FLUSH
	JSR	PC,RUNME
	POP	U
RLINE1:	JSR PC,BLSTI
RDSTR2:	JSR PC,@GCHR
	TST	BRAKE(U)
	BNE	RDSTR7
	CMP #EOFCHR,D
	BNE RDSTR9
	MOV #TYI,GCHR	;NON-TTY INPUT DONE
	MOV #'],D	;FILL IN MISSING ]'S
	TST NBKTS
RDSR10:	BLE RDSTR4
	JSR PC,BLST
	DEC NBKTS
	BR RDSR10
RDSTR9:	CMP TBKCH,D	;BREAK TYPED?
	BEQ RDSTR7	;YES
	TST NBKTS	;IN A LIST?
	BGT RDSTR3	;YES
	CMP #15,D	;CR?
	BEQ RDSTR4
RDSTR3:	CMP #'[,D
	BNE RDSTR6
	INC NBKTS
RDSTR6:	CMP #'],D
	BNE RDSTR5
	DEC NBKTS
RDSTR5:	JSR PC,BLST
	BR RDSTR2
RDSTR4:	BIC #RBRKF,TFLAGS
	JSR PC,BLSTF
RDSTRR:	RTS PC	;NO CHARS TYPED
	PUSHS TOPS
	CLR TOPS
RDSTSR:	SKPRET
RDSTR7:	BIS #RBRKF,TFLAGS
	RTS PC
	.STITL REQUEST, FILE READ & WRITE
RQUEST:	PUSH #ORT	;INPUT A LIST FROM TTY
RQU1:	PUSH PRMTCH
	JSR PC,INPUTL
	BR RQU5
	MOV E,C	;E POINTS TO LAST NODE OF STRING
	JSR PC,.LOADC	;NEED TO ADD A "]", IS THERE ROOM?
	BIT #177400,B
	BNE RQU2	;YES
	BIS #']*400,B	;NO - PUT A "]" THERE
	JSR PC,.STORE
RQU3:	MOV @S,GNCN
	BIC #170000,GNCN
	JSR PC,RDLST
	POPS TOPS
RQU4:	MOV TOPS,@S
	CLR TOPS
RQUR:	POP PRMTCH
	RTS PC
RQU2:	MOV #'],B
	JSR PC,GRBAD1
	BR RQU3
RQU5:	MOV #LIST,@S
	BR RQUR
INPUTL:	MOV #'<,PRMTCH
	MOV USER,U
	MOV UTTY(U),A
	TST CHARNO(A)
	BEQ .+6
	CLR PRMTCH
	JSR PC,RDSTR
	BR IPUL1
	SKPRET
IPUL1:	BIT #RBRKF,TFLAGS
	BEQ IPUL3
	POP PRMTCH	;THE RETURN
	SPOP PRMTCH	;NOW THE OLD PRMTCH
	ERROR+BRK
IPUL3:	PUSHS #LSTR
	RTS PC
TYPEIN:	JSR PC,RQU1	;INPUT A WORD FROM TTY
	BIT #7777,@S
	BNE TYPIN2
	MOV #LSTR,@S
	JMP ORT
TYPIN2:	JMP FIRST
	PUSH PRMTCH
	JSR PC,INPUTL
	BR RQUR
	MOV @S,GNCN
	BIC #170000,GNCN
TYPIN1:	JSR PC,GNC
	CMP #' ,D
	BEQ TYPIN1
	JSR PC,RDST
	BR RQU4
	BR RQU4
FREAD:	JSR F,G1FN
	FNAME
FRDER:	ERROR+IFN	;INVALID FILE NAME
	JSR PC,READF
	JSR PC,FILERR
	CLR CT
	CLR CT+2
	MOV #READCH,GCHR
	JMP NORT
FWRITE:	JSR F,G1FN
	FNAME
	BR FRDER
	JSR PC,WRITEF
	JSR PC,FILERR
	MOV #WRITEC,PCHR
	JSR PC,SHOWAL
	BR .+2
	JSR PC,WRITCU
	MOV #TYO,PCHR
	JSR PC,FILERR
	JMP NORT
	.STITL DELETE, UNDELETE (!!), USE
DELETE:	JSR F,G1FN
	FNAME
	BR FRDER
	JSR PC,DELETF
	JSR PC,FILERR
	JMP NORT
UNDELE:	JSR F,G1FN
	FNAME
	BR FRDER
	JSR PC,UDELEF
	JSR PC,FILERR
	JMP NORT
USE:	JSR F,G1FN
	DIRNAM
	BR FRDER
	JMP NORT
G1FN:		;GET A FILE NAME (4 CHARS)
		;PUT INTO ((P)) AND ((P)+2)
	MOV (F)+,C
	JSR PC,GNT
	BIT #CRF,FLAGS
	BEQ .+4
	ERROR+MFN	;MISSING FILE NAMES
	BIC #7777,A
	CMP #SSTR,A
	BLO G1FN3
	CMP #UFUN,A
	BNE G1FN5
	JSR PC,.LOAD
	BR G1FN4
G1FN3:	MOV #LSTR,A
	JSR PC,CONVER
G1FN2:	RTS F
G1FN4:	JSR PC,.LOAD
	MOV B,(C)+
	CLR B
	BIT #7777,A
	BEQ G1FN1
	MOV A,B
	JSR PC,.LOAD
G1FN1:	MOV B,(C)
G1FN6:	TST (F)+
	RTS F
G1FN5:	BLO G1FN2	;IS IT SFUN OR INFIX?
	CMP (B)+,(B)+	;YES - NOW IT POINTS TO ASCIZ
	MOV (B)+,(C)+	;GET 1ST TWO CHAR
	CLR (C)	;IN CASE SECOND CHAR IS 0
	TSTB -1(C)	;IS IT?
	BEQ G1FN6	;YES -  DONE
	MOV (B)+,(C)+	;NO - GET NEXT TWO CHARS
	BR G1FN6
FILERR:	JMP .+4(A)
	RTS PC
	ERROR+FNF
	ERROR+DRF
	ERROR+FAE
	ERROR+DFU
	ERROR+IUN
	.STITLE  READ -

READ:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	CLR RDFLAG
	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F
READA:	JSR PC,RDWRD
	BR READB
	BIS #SEPF,RDFLAG
	JSR PC,CKDOTF
READC:	JSR PC,LISTB
	BIT #SEPF,RDFLAG
	BEQ READA
READB:	BIC #SEPF,RDFLAG	;CHECK SPECIAL CHAR IN D
	JSR PC,CKDOTF	;FIRST CHECK FOR PENDING ":"
	CMP #15,D
	BEQ READR	;C-R
	CMP #'",D
	BEQ READS	;STRING
	CMP #'[,D
	BEQ READL	;LIST
	CMP #'],D
	BNE .+4
	ERROR+COP	;CHAR (]) OUT OF PLACE
	CMP #':,D
	BEQ READD	;DOTS
	BITB #OPERF,DTBL(D)	;IS CHAR AN OPERATOR
	BEQ READA	;NO
	MOVB DTBL2(D),A
	ASL A
	MOV SOBLSU(A),B
		;SET TYPE TO SFUN OR INFIX
	MOV @B,A	;THIS CROCK WORKS BECAUSE #SFUN=0
	BIC #-INFIX-1,A	; AND #INFIX=10000
	BR READC
READR:	POPS A
	CLR	TOPS
	TST	F
	BNE	READR1
	JMP RETF
READR1:	MOV A,@S
	JMP SRETF

READS:	JSR PC,GNC
	JSR PC,RDST
	BR .+2	;RDST ALWAYS SKIPS
	BIS #SEPF,RDFLAG
	BR READC
READL:	JSR PC,RDLST
	POPS TOPS
	BIC #SEPF,RDFLAG
	BR READC
READD:	BIS #DOTF,RDFLAG
	BR READA
	.STITLE READ - READ WORD
	;READ CHARS UP THRU NEXT SEPARATOR CHAR.  IF JUST A SEP,
	;RETURN WITH IT IN D.  OTHERWISE NUMBERIFY OR INTERN CHAR STRING,
	;SKIP RETURN WITH TOKEN IN A,,B
RDWRD:	CLRB RDFLAG
	JSR PC,BLSTI
RDWA:	JSR PC,GNC
	MOVB DTBL(D),A	;GET FLAGS IN A
	BIT #SEPF,A	;IS THIS CHAR A SEPARATOR?
	BNE RDWB	;YES
	BISB A,RDFLAG
	JSR PC,BLST
	BR RDWA
RDWB:	JSR PC,BLSTF	;FINISH OFF STRING
	RTS PC	;NO CHARS SEEN BEFORE SEP
	BIT #NNUMF,RDFLAG
	BNE RDWC	;NOT A POSSIBLE NUMBER
	MOV TOPS,B
	MOV #LNUM,A
	JSR PC,CONVER	;TRY MAKING A #
	SKPRET	;LOST SO LEAVE AS LSTR
	MOV B,TOPS	;PROTECT FROM GC UNTIL ADDED TO LIST
	SKPRET	;OK
RDWC:	MOV #UFUN,A	;TRY TO INTERN STRING IN TOPS AS A SYSTEM OR USER FUNCTION
	BIT #DOTF,RDFLAG	; UNLESS DOTF ON, THEN AS USER VARIABLE
	BEQ RDWD
	MOV #UVAR,A
	BIC #DOTF,RDFLAG
RDWD:	JSR PC,.INTRN	;RDSTR COMES HERE ALSO
	BR RDWE
	JSR PC,FRELST
RDWE:	BIS A,B
RDWR:	SKPRET
	.STITLE READ - READ STRING
	;READ CHAR UP TO NEXT SPACE OR ] IF INSIDE
	;A LIST.  DONT ALLOW ] OR [.
	; SKIPS UNLESS EMPTY STRING
RDST:	CLRB RDFLAG
	JSR PC,BLSTI
	BR RDSB
RDSA:	JSR PC,GNC
RDSB:	MOVB DTBL(D),A
	BIT #SEPF,A
	BEQ RDSE
	CMP #' ,D
	BEQ RDSX
	CMP #'],D
	BEQ RDSC
	CMP #'[,D
	BEQ RDSX
	CMP #15,D
	BEQ RDSX
RDSE:	BIS A,RDFLAG
	JSR PC,BLST
	BR RDSA
RDSC:	TST LISTBD	;ARE WE IN LIST
	BNE RDSX	;YES
RDSD:	ERROR+COP	;CHAR (D) OUT OF PLACE
RDSX:	MOV #LSTR,A
	MOV #LSTR, B
	JSR PC,BLSTF
RDSR:	RTS PC	;EMPTY STRING
	MOV #LSTR,A
	MOV TOPS,B
	BIT #NNUMF,RDFLAG
	BEQ RDWR	;IT IS A POSSIBLE NUMBER
	BIT #SEPF,RDFLAG
	BNE RDWR	;IT HAS A SEP CHAR IN IT
	MOV #ATOM,A
	JMP RDWD	; INTERN IT
	.STITL READ - READ LIST
	;READ THRU MATCHING ] MAKING A LIST AS U GO
RDLST:	CLRB RDFLAG
	JSR PC,SLISTB
RDLA:	JSR PC,GNC
	CMP #' ,D
	BEQ RDLA	;SKIP OVER SPACES
	CMP #'[,D
	BEQ RDLB	;READ A LIST
	CMP #'],D
	BEQ RDLY	;DONE
	JSR PC,RDST	;READ A STRING
	BR .+2	;RDST ALWAYS SKIPS
RDLX:	JSR PC,LISTB	;ADD THIS NODE TO LIST
	CMP #'[,D
	BEQ RDLB
	CMP #'],D	;AT END?
	BNE RDLA	;NO, GET NEXT ELEMENT
RDLY:	JSR PC,FLISTB
	RTS PC
RDLB:	JSR PC,RDLST
	POPS TOPS
	CLR D
	BR RDLX
	.STITLE READ - MISC
CKDOTF:	BIT #DOTF,RDFLAG
	BEQ LISTBR
	BIC #DOTF,RDFLAG
	PUSH A
	SPUSH B
	MOV #SFUN,A
	MOV #$DOTS,B
	JSR PC,LISTB
	JMP RETB
LISTB:	MOV F,C	;BUILD A LIST, ADD NODE IN A,,B TO
	JSR PC,GRBAD1	;LIST WHOSE LAST NODE PTR IS IN F
	TST F
	BNE LISTB1
	PUSHS	C
	BIS #LIST,@S
LISTB1:	MOV C,F
LISTBR:	RTS PC
SLISTB:		;START LISTB
	PUSHS F	;SAVE CURRENT LAST NODE PTR
	CLR F
	INC LISTBD
	RTS PC
FLISTB:	TST F
	BNE FLSB1
	PUSHS #LIST
FLSB1:	POPS B	;THIS IS THE OUTPUT
	MOV @S,F	;RESTORE OLD LAST NODE PTR
	MOV B,@S	;THE RESULT
	MOV #LIST,A
	DEC LISTBD
	RTS PC
BLSTI:	CLR NCHR
	CLR E
	CLR TOPS
BLSTI1:	BIS #100000,E
	RTS PC
BLST:		;BUILD STRING - CHAR IN D, USES E
	TST	USER
	BGE	.+6
	JMP	STYO
				;DESTROYS A,B,C
	PUSH A
	SPUSH B
	SPUSH C
	BIT #200,D	;CHECK IF IGNORE BIT ON
	BNE BLSTRT
	BIT #177,D	;CHECK IF NULL
	BEQ BLSTRT
	INC NCHR	;WE HAVE A CHAR
	ADD #40000,E
	BGE BLST2	;IS IT  THE SECOND
	MOVB D,TEMP	;NO, 1ST
BLSTRT:	JMP RETC
BLST2:	MOVB D,TEMP+1	;IT IS THE SECOND CHAR
	MOV TEMP,B
	;STORE THE CHARACTERS
BLST3:	JSR PC,BSAN
	BIS #100000,E
	BR BLSTRT
BLSTF:	;FINISH BUILDING STRING, PUT PTR IN TOPS.
		; DONT SKIP IF EMPTY STRING (TOPS=0)
	TST NCHR
	BEQ BSANR	;EMPTY STRING
	ADD #40000,E
	BGE .+4	;IS LAST NODE USED
	SKPRET
	PUSH A
	SPUSH B
	SPUSH C
	MOVB TEMP,B	;YES
	JSR PC,BSAN
BLSTF1:	JMP SRETC
BSAN:	MOV E,C
	MOV #SSTR,A
	JSR PC,GRBAD1
	TST E
	BNE BSAN1
	MOV C,TOPS	;SAVE NEW STRING PTR ON S
	BIS #LSTR,TOPS
BSAN1:	MOV C,E
BSANR:	RTS PC
	.STITL GNC - GET NEXT CHAR
GNC:	PUSH A		;GET NEXT CHAR INTO D
	SPUSH B		;INITIALIZE BY MOVING LSTR PTR INTO GNCN
GNC4:	MOVB GNCN+2,D	;    AND CLEARING TYPE FIELD (#170000)
	MOV GNCN,B	;SKIPS UNLESS NO MORE CHAR
	BLT GNC1	;JUST GOT 2ND CHAR
	BNE GNC3
	MOV #15,D
	JMP RETB	;NONE LEFT
GNC3:	JSR PC,.LOAD	;GET NEXT NODE
	BIS #100000,A	;SET "STILL ANOTHER CHAR" BIT
	MOV A,GNCN
	MOVB B,D	;FOR OUTPUT
	SWAB B
	MOVB B,GNCN+2
GNC2:	TST D
	BEQ GNC4	;IGNORE NULL CHARS
	JMP RETB
GNC1:	BIC #170000,GNCN	;CLEAR "STILL ..." BIT
	BR GNC2
	.STITL PRINT ROUTINES

PRLO:	PUSH A	;PRINT LAST OPERATOR
	SPUSH B
	MOV LO,A
	BEQ EMPTY
	MOV LO+2,B
	BR PRCO1
PRCO:	PUSH A,	;PRINT CURRENT OPERATOR
	SPUSH B
	MOV CO,A
	MOV CO+2,B
	BEQ EMPTY
PRCO1:	SPUSH D
	JSR PC,PROAB
	SPOP D
	JMP RETB
PROAB:	CMP A,#UFUN	;PRINT OPERATOR IN A,B
	BLO PRCO2
	JMP PPNAME	;PRINT PNAME
PRCO2:	MOV B,A	;SYSTEM FUNCTION
	CMP	(A)+,(A)+
	BR	PRAS	;PRINT ASCIZ PNAME
NOTPRO:	ERROR+NTP
EMPTY:	PRTXT ^\ EMPTY \
	JMP RETB

ERTAS:	JSR	PC,PRAS
	ASR	A	;CALLED WITH JSR A,
	ADC	A
	ASL	A
	RTS	A

PRAS:	SPUSH	D	;PRINT ASCIZ STRING POINTED TO BY A
	BR	.+6
PRAS1:	JSR	PC,@PCHR
	MOVB	(A)+,D
	BNE	PRAS1
	SPOP	D
	RTS	PC

PRON:	BIC #TF2,TFLAGS	;PRINT OCTAL NO., NO. IN A
	BR PRON1	;CALL-	JSR PC,PRON
PRONL:	BIS #TF2,TFLAGS
PRON1:	PUSH A		;PRON DOESN'T PRINT LEADING ZEROS, PRONL DOES
	SPUSH D
	CLR D
	SEC
	ROL A	;TO TELL WHEN WE ARE DONE
	BR PRON2
PRON3:	CLR D
	ASL A
	BEQ PRON5
	ROL D
	ASL A
	ROL D
	ASL A
PRON2:	ROL D
	BNE PRON4
	BIT #TF2,TFLAGS
	BEQ PRON3
PRON4:	BIS #TF2,TFLAGS
	BIS #60,D
	JSR PC,@PCHR
	BR PRON3
PRON5:	BIS #60,D
	BIT #TF2,TFLAGS
	BNE .+6	;IF NOTHING HAS BEEN TYPED, TYPE A ZERO
	JSR PC,@PCHR
	SPOP D
	SPOP A
	RTS PC
PRDNL:	BIS #TF1,TFLAGS
	BR .+10
PRDN:	BIC #TF1,TFLAGS	;PRINT DECIMAL NO. IN A
	PUSH B
	SPUSH D
	MOV #10,B
	MOV A,MQ
	BGE PRDN1
	NEG MQ	;ITS NEGATIVE
	MOV #'-,D
	JSR PC,@PCHR
PRDN1:	MOV DTOTB(B),DIVIDE
	BIT #TF1,TFLAGS
	BNE PRDN2
	BITB #MQZ,EAESR	;> ZERO?
	BNE PRDN3	;NO
	BIS #TF1,TFLAGS
PRDN2:	MOV MQ,D
	ADD #'0,D
	JSR PC,@PCHR
PRDN3:	MOV AC,MQ
	SUB #2,B
	BNE PRDN1
	MOV MQ,D
	ADD #'0,D
	JSR PC,@PCHR
	POP D
	SPOP B
	RTS PC
DTOTB:	1.
	10.
	100.
	1000.
	10000.
EMPTY1:	JMP EMPTY
PRS1:	PUSH A	;PRINT TOP ELEMENT OF SS
	SPUSH B
	MOV #IS,A	;COMPUTE RELATIVE S PD PTR
	SUB S,A
	ADD SPRBAO,A
	CMP A,CSPDLP
	BLOS EMPTY1
	MOV @S,B
	SPUSH D
	JSR PC,PNODAB
	SPOP D
	JMP RETB
PNODAB:	MOV B,A
	BIC #7777,A
	CMP #SSTR,A
	BEQ PRS11
	CMP #SNP,A
	BLOS PRS11
	ERROR+INVN	;INVALID NODE
PRS11:	JSR PC,PRDATA
	RTS PC
PRCT:	PUSH A	;PRINT CURRENT TOKEN
	SPUSH B
	SPUSH D
	MOV CT,A
	MOV CT+2,B
	JSR PC,PRTAB
	SPOP D
	JMP RETB
PRTAB:	BIC #7777,A	;PRINT TOKEN IN A,B
	CMP A,#UVAR
	BHIS .+6
	JMP PROAB
	CMP A,#UVAR
	BEQ PRUV
	BR PRDATA
PRATM:	BIS #PQF,FLAGS2	;PRINT ATOM IN A,B
	BR PRUV1
PRUV:	MOVB #':,D	;PRINT USER VARIABLE IN A,B
	JSR PC,@PCHR
PPNAME:	BIC #PQF,FLAGS2	;PRINT PNAME - UOE PTR IN B
PRUV1:	JSR PC,.LOAD
	JMP PRLSTR	;PRINT PNAME
PRDATA:	CMP #INUM,A	;PRINT DATA IN A,B. 7777 FIELD OF A IS 0000
	BEQ PRINUM	;NUMBER
	CMP #SNUM,A
	BEQ PRSNUM
	BIS #PQF,FLAGS2	;SET PRINT QUOTE FLAG
	CMP #ATOM,A
	BEQ PRUV1
	CMP #LSTR,A
	BEQ PRLSTR	;LONG STRING
	CMP #SSTR,A
	BEQ PRSSTR	;SHORT STRING
	BIC #PQF,FLAGS2
	CMP #LIST,A
	BEQ PRLST
	TST	DSKNCH	;IS THIS GOING TO THE DISC?
	BEQ	PRSNP	;YES
	PRTXT	^/" /	;OUTPUT EMPTY
	BR	PRSRET
PRSNP:	PRTXT ^\%SNAP%\	;CANT PRINT A SNAP
	BR PRSRET
PRLSTR:	JSR PC,.LOAD	;PRINT LONG STRING
PRSSTR:	JSR PC,PRQQ	;PRINT SHORT STRING
PRSTR2:	MOVB B,D
	BLE	PRSTR3	;NULL CHAR
	JSR PC,@PCHR
PRSTR3:	SWAB B
	MOVB B,D
	BLE	PRSTR4	;NULL CHARACTER
	JSR PC,@PCHR
PRSTR4:	MOV A,B
	BIC #170000,B
	BEQ PRSRET
	JSR PC,.LOAD
	BR PRSTR2
PRSRET:	RTS PC
PRQQ:	BIT #PQF,FLAGS2	;PRINT ' " ' IF PQF=1
	BEQ PRSRET
	BIT #DPQF,FLAGS2
	BNE PRSRET
	MOVB #'",D
	JMP @PCHR
PRSNUM:	CLR A	;PRINT SNUM
	TST B
	BGE PRINM1
	COM A
	BR PRINM1
PRINUM:	JSR PC,.LOAD	;PRINT INUM
PRINM1:	PUSH C
	MOV E,TMPBLK+2
	MOV F,TMPBLK+4
	JSR PC,.CINST	;CONVERT INUM IN A,,B TO STRING ON P
	MOV TMPBLK+2,E
	MOV TMPBLK+4,F
	MOV P,A
	MOVB (A)+,D
	BNE PRINM3
PRINM2:	MOVB (A)+,D
	BEQ PRINM4
PRINM3:	JSR PC,@PCHR
	BR PRINM2
PRINM4:	INC A	;TO MAKE IT EVEN (??)
	MOV A,P
	POP C
	RTS PC
PRLST:	PUSH A	;PRINT LIST, PTR IN B
	SPUSH B
	SPUSH C
	TST NBKTS
	BEQ PRL4
	MOV #'[,D
	JSR PC,@PCHR
PRL4:	INC NBKTS
	MOV B,C
PRL1:	SPUSH FLAGS2
	BIT #7777,C	;EMPTY LIST
	BEQ PRL2	;YES, DONE
	BIS #DPQF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
	BR PRL3
PRL6:	SPACE
PRL3:	JSR PC,.LOADC	;GET THIS NODE
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	JSR PC,PRTAB
	BIT #7777,C
	BNE PRL6
PRL2:	DEC NBKTS
	BEQ PRL5
	MOV #'],D
	JSR PC,@PCHR
PRL5:	BIC #DPQF,FLAGS2
	SPOP C	;GET OLD FLAGS2
	BIC #<-DPQF-1>,C	;MASK ALL BUT DPQF
	BIS C,FLAGS2	;AND SET IT
	JMP RETC
PRNODE:	PUSH A	;PRINT NODE POINTED TO BY B
	SPUSH B
	SPUSH D
	JSR PC,.LOAD
	JSR PC,PRON
	SPACE
	MOV B,A
	JSR PC,PRON
	SPOP D
	JMP RETB
SHOWAL:	JSR PC,SHALPR	;SHOW ALL PROCEDURES
	BR .+2
	JSR PC,SHALNA	;SHOW ALL NAMES
	BR .+2
	SKPRET
SHOW:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE SHOW00	;YEP
	MOV TOPRNM,B
	BNE SHOW0
	ERROR+SHW
SHOW00:	JSR PC,GTUOEB
	BR SHOW1
SHOW0:	MOV TOPRNM,ERPRNM
	MOV #PSHOW,SHWHAT
GOSHOW:	JSR PC,@SHWHAT
SHOW5:	ERROR+PNH	;PROCEDURE NOT HERE
SHOWE:	JMP NORT
SHOW1:	MOV	TOPRNM,ERPRNM
	CMP #SFUN,A
	BNE SHOW5
	TST B	;IS IT CR?
	BNE SHOW12	;NO
	MOV TOPRNM,B
	BEQ SHOWE1
	BR SHOW0
SHOW12:	CMP #$ALL,B
	BEQ SHOW2
	CMP #$FILE,B
	BEQ SHOW3
	CMP #$TITLE,B
	BEQ TITHIS
	CMP #$LINE,B
	BEQ SHLINE
	CMP #$INDEX,B
	BEQ SAFL
SHOWE1:	ERROR+SHW	;SHOW WHAT??
SHOW2:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE SHOW22
	MOV #SHOWAL,SHWHAT
	BR GOSHOW
SHOW22:	JSR PC,GTUOEB
	BR .+4
SHOWE2:	ERROR+SAW	;SHOW ALL WHAT??
	CMP #SFUN,A
	BNE SHOWE2
	MOV #SHALPR,SHWHAT
	CMP #$PROCE,B
	BEQ GOSHOW
	CMP #$NAMES,B
	BNE SHOW23
SAN:	MOV #SHALNA,SHWHAT
	BR GOSHOW
SHOW23:	MOV #RJLCRK,SHWHAT
	CMP #$RJLDS,B
	BEQ GOSHOW
	MOV #SHALUS,SHWHAT
	CMP #$USERS,B
	BEQ GOSHOW
	CMP #$TITLS,B
	BNE SHOWE2
SATI:	MOV #SHALTI,SHWHAT
	BR GOSHOW
SAFL:	MOV #SHALUF,SHWHAT
	BR GOSHOW
SHOW3:	JSR F,G1FN
	FNAME
	ERROR+IFN
	JSR PC,READF
	JSR PC,FILERR
SHOW4:	JSR PC,READCH
	CMP #EOFCHR,D
	BEQ SHOWE
	JSR PC,@PCHR
	BR SHOW4
PSHOW:	;SHOW (B).  SKIP UNLESS (B) NOT A USER PROC
	JSR PC,SHTITL	;SHOW TITLE LINE, SKIPS IF PROC THERE
	RTS PC
	BIT #7777,A
	BEQ PSHOW4
	MOV A,C
	PUSHS #0
PSHOW3:	JSR PC,.LOADC
	MOV A,C
	MOV B,@S
	JSR PC,PRLN
	BIT #7777,C
	BNE PSHOW3
	POPS A
PSHOW4:	PRTXTC ^\END\
	SKPRET
TITHIS:	MOV TOPRNM,B	;SHOW THIS TITLE
	TST TOPRNM
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	JSR PC,SHTITL
	.BUG.
	JMP NORT
SHLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GEN LINE NO. FROM NEXT TOKEN INTO B
	ERROR+SHW	;SHOW WHAT??
	JSR PC,GTLP	;GET POINTER TO LINE
	ERROR+LDE	;LINE DOESNT EXIST
	JSR PC,.LOADC
	PUSHS B	;FOR PRLN
	JSR PC,PRLN	;PRINT LINE
	POPS C
	JMP NORT
SHALNA:		;SHOW ALL NAMES
		;USES A-F
	JSR PC,GNOLEI
SHALN1:	JSR PC,GNOLE	;GET NEXT UOE
	SKPRET	;NONE LEFT
	MOV B,F
	JSR PC,.BNDVN
	BR SHALN1	;NO THING FOR THIS UOE
	MOV B,C	;SAVE VALUE PTR
	MOV F,B	;GET UOE PTR
	TST DSKNCH	;IS THIS GONG TO DISC?
	BEQ SHALN2	;NO
	SPUSH B
	PRTXT ^/MAKE "/	;YSE
	SPOP B
	JSR PC,PPNAME	;PRINT THE NAME
	PRTXT ^\ (\
SHALN3:	SPACE
	SPUSHS C
	INC NBKTS
	JSR PC,PRS1
	ADD #2,S
	TST DSKNCH
	BEQ SHALN4
	PRTXT ^\ )\
SHALN4:	PRCR
	BR SHALN1
SHALN2:	JSR PC,PRUV	;PRINT THE NAME
	PRTXT ^/ IS/
	BR SHALN3
SHALPR:		;SHOW ALL PROCEDURES
		;USES A-F
	JSR PC,GNOLEI
SHALP1:	JSR PC,GNOLE
	SKPRET	;DONE
	JSR PC,PSHOW
	BR SHALP1
	BR SHALP1
RJLCRK:	JSR E,CLISTF
	LSTALF
	SKPRET
SHALUF:	JSR E,CLISTF
	LSTAUF
	SKPRET
SHALUS:	CLR @DBUFAD
	JSR E,CLISTF
	LSTAUS
	SKPRET
SHALTI:	;SHOW ALL TITLES
	JSR PC,GNOLEI
SHATI1:	JSR PC,GNOLE
	SKPRET
	JSR PC,SHTITL
	BR .+2
	BR SHATI1
CONTEN:	;MAKE A LIST OF ALL ATOMS THAT HAVE A PPROCEDURE
	JSR PC,SLISTB
	JSR PC,GNOLEI
CONTN1:	JSR PC,GNOLE
	BR CONTN2	;DONE
	MOV B,D
	JSR PC,.BINDF	;A PROCEDURE
	BR CONTN1	;NOPE
	MOV D,C
	JSR PC,.LOADC	;GET PNAME
	MOV #LSTR,A
	JSR PC,LISTB
	BR CONTN1
CONTN2:	JSR PC,FLISTB
	JMP ORT
SHTITL:		;INPUT - UOE PTR IN B
		;OUTPUT - "SHOWS" TITLE LINE
		;	-A POINTS TO LLP NODE FOR 1ST LINE
		;	- SKIPS UNLESS NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF
	JMP RETC
	MOV A,4(P)
	PRTXT ^\TO \
	MOV 2(P),B
	JSR PC,PPNAME
	MOV 4(P),C
	JSR PC,.LOADC
	MOV A,4(P)	;SAVE PTR TO NEXT NODE
	JSR PC,.LOAD	;#ARGS IN B
	TST B
	BEQ SHTI1
	MOV A,C
SHTI2:	SPACE
	JSR PC,.LOADC	;NEXT ARG
	MOV A,C
	JSR PC,PRUV	;PRINT ITS PNAME
	BIT #7777,C
	BNE SHTI2
SHTI1:	PRCR
	JMP SRETC
PRLN:	PUSH A	;PRINT PROC LINE ON S
	SPUSH B
	SPUSH C
	SPUSH D
	INC NBKTS	;PRINT OUTER LIST BRACKETS
	BIC #DPQF,FLAGS2	;DO PRINT QUOTE BEFORE STRINGS
	MOV @S,C
	JSR PC,.LOADC	;PRINT LINE #
	MOV A,C
	JSR PC,PRTAB
	BIT #7777,C
	BEQ PRLN3	;DONE
	JSR PC,.LOADC	;CHECK FOR TYPE = SNUM
	MOV A,C	;THIS MEANS 2ND TOKEN IS A CLGN & SHOULDNT PRINT
	BIC #7777,A
	CMP #SNUM,A
	BNE PRLN4
	BR PRLN2
PRLN1:	JSR PC,.LOADC
	MOV A,C
PRLN4:	SPACE
	JSR PC,PRTAB
PRLN2:	BIT #7777,C	;DONE?
	BNE PRLN1	;NO
PRLN3:	PRCR
	DEC NBKTS
	JMP RETD
	.STITLE ERASE
ERASE:	JSR PC,GTUOEB	;ERASE ...
	BR ERASE1	;NOT A PROCEDURE
	MOV #ERPR,SHWHAT
	MOV TOPRNM,ERPRNM
GORASE:	JSR PC,@SHWHAT
ERASER:	ERROR+PNH	;PROCEDURE NOT HERE
	JMP NORT
ERASE1:	MOV TOPRNM,ERPRNM
	CMP #SFUN,A
	BNE ERASER
	CMP #$ALL,B
	BEQ ERASE2
	CMP #$TRACE,B
	BNE ERAS11
ERTR:	MOV #ETRACE,SHWHAT
	BR GORASE
ERAS11:	MOV #ERFI,SHWHAT
	CMP #$FILE,B
	BEQ GORASE
	CMP #$LINE,B
	BNE ERASE3
ERL:	MOV #ERLINE,SHWHAT
	BR GORASE
ERASE3:	ERROR+ERW	;ERASE WHAT
ERASE2:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE ERAS21	;YES
	MOV #ERALL,SHWHAT
	BR GORASE
ERAS21:	JSR PC,GTUOEB
	BR .+4
ERASR2:	ERROR+EAW	;ERASE ALL WHAT??
	CMP #SFUN,A
	BNE ERASR2
	MOV #ERALPR,SHWHAT
	CMP #$PROCE,B
	BEQ GORASE
	CMP #$NAMES,B
	BNE ERASR2
EAN:	MOV #ERALNA,SHWHAT
	BR GORASE
ERALL:		;ERASE ALL
	JSR	PC,ERALPR
	BR	.+2
	JSR	PC,ERALNA
	BR	.+2
	SKPRET

ERLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	ERROR+ERW	;ERASE WHAT??
	NEG B		;SO ADLN WILL ERASE IT
	MOV #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	PUSHS C
	JSR PC,ADLN
	ADD #2,S	;POP S
	SKPRET
ERPR:		;ERASE PROCEDURE (B)
	BIC #170000,B
	BIS #UFUN,B
	CMP B,TOPRNM
	BNE .+4
	ERROR+PBE	;PROCEDURE IS BEEN EDITED (UGH!!!)
	MOV #FBIND,A
	JMP .UNBND
ERALPR:		;ERASES ALL PROCEDURES
	TST TOPRNM
	BEQ .+4
	ERROR+PBE	;PROC BEING EDITED
	JSR PC,GNOLEI
	MOV #FBIND,A
ERALP1:	JSR PC,GNOLE	;GET NEXT UOE
	SKPRET	;DONE
	JSR PC,.UNBND
	BR ERALP1
	BR ERALP1
ERALNA:		;ERASE ALL NAMES
	JSR PC,GNOLEI
ERALN1:	JSR PC,GNOLE
	SKPRET	;DONE
	MOV #VBIND,A
	JSR PC,.UNBND
	BR ERALN1	;EVENTUALLY HAVE TO CHECK FOR SVBIND
	BR ERALN1
ERFI:	JSR F,G1FN
	FNAME
	BR .+4
	BR .+4
	ERROR+IFN
	JSR PC,DELETF
	JSR PC,FILERR
	SKPRET
STRACS:	BIT #TRACEF,FLAGS2
	BEQ STRT
	SPACE
	BR STRA1
STRACE:	BIT #TRACEF,FLAGS2	;SYSTEM TRACE
	BNE .+4
STRT:	RTS PC
STRA1:	INC NBKTS
	PUSH A
	PRTXT ^/CT=/
	BIC #DPQF,FLAGS2
	JSR PC,PRCT
	PRTXT ^/ CO=/
	JSR PC,PRCO
	PRTXT ^/ S=/
	BIC #DPQF,FLAGS2
	JSR PC,PRS1
	PRCR
	CLR NBKTS
	POP A
	RTS PC

ETRAC1:	BIC #TF6,TFLAGS
	BR TRACE1
TRACE:	BIS #TF6,TFLAGS
TRACE1:	MOV TOPRNM,ERPRNM
	JSR PC,TRA1
	ERROR+PNH	;PROC NOT HERE
TRAN:	JMP NORT
ETRACE:	BIC #TF6,TFLAGS
TRA1:	JSR PC,GTUOEB
	BR TRA5
	JSR PC,.BNDFS
TRA5:	RTS PC
	MOV B,C	;B POINTS TO LIST OF GOODIES. FIRST IS FLAGS,,#ARGS
	JSR PC,.LDP2
	BIC #TPTF,A
	BIT #TF6,TFLAGS
	BEQ TRA2
	BIS #TPTF,A
TRA2:	JSR PC,.STP2
	SKPRET

SETSTF:	JSR PC,CKSST
	BIS #TRACEF,FLAGS2	;SET SYSTEM TRACE FLAG
	BR	TRAN

CLRSTF:	JSR PC,CKSST
	BIC #TRACEF,FLAGS2
	BR	TRAN

FLEV:	MOV FUNLEV,B	;RETURN USER PROC CALL DEPTH
FLEV1:	JMP R1NARG
NODES:	;OUTPUT NO. OF NODES IN FREE STG LIST
	MOV NNIFSL,B
	BR FLEV1
.STITL	UTILITY ROUTINES

GOODBYE:	JSR PC,RUNME
	CPRTXT ^/AND A PLEASANT DAY TO YOU!/
	BR HELLO2

HELLO:	JSR PC,RUNME	;IN CASE CALLED BY GUN
HELLO2:	PRCR
	JSR	E,LCUGRB
	GCLOCK
	JSR	E,LCUGRB
	LOCKUS
	JSR	PC,NODEV
	MOV USER,U
	MOV #FRNEWU,FLSRES(U)
	CLR FLSADR(U)
	CLR BRAKE(U)
	MOV SPDLP,P
	JMP NEXTUS

;***BUG:  WHY DO YOU HAVE TO GUN TWICE?  --ROGER

GUN:	JSR	PC,G1NARG
	TST	B
	BGE	.+4
GUNE:	ERROR+IFN
	CMP	B,NUSERS
	BGE	GUNE
	MOV	B,MQ
	MOV	#LUBLK,MULTIP
	MOV	MQ,U
	CLR	FLSRES(U)
	CLR	FLSADR(U)
	MOV	#GOODBYE,UPC(U)
	MOV PC,BRAKE(U)
	JMP	NORT


CASESW:	;COMPLEMENT STATE OF CONVERT LOWER CASE TO UPPER SWITCH
	JSR	PC,TICASE
	BR	CASES1	;IF OFF
	PRTXTC	^/CONVERT LOWER CASE TO UPPER/
	RTS PC
CASES1:	PRTXTC	^/DON'T CONVERT CASE/
	RTS PC
VERSN:	MOV LVERNF,B
	BR	RANDO1
RANDOM:	MOV #MQ,A
	MOV RNSEED,(A)+	;GET OLD SEED
	MOV #71275,(A)	;MUL SEED BY GOOD NUMBER!!
	ADD #13713,-(A)	;ADD ANOTHER GOOD NUMBER (!!) TO LOW ORDER PART
	MOV (A),RNSEED	;THIS IS THE NEW SEED
	CLR -(A)	;CLEAR THE HIGH ORDER PART
	MOV #10.,MULTIP	;MUL LOW ORDER PPART BY 10.
	MOV (A),B	;THE HIGH ORDER PART IS THE DESIRED DIGIT
	ADD #5,B
RANDO1:	JMP R1NARG
BELL:	MOV #7,D
	BR .+6
CR:	MOV #1,D
	JSR PC,TYO
	JMP NORT
DEBUGL:	TST ALEVN
	BEQ DEBUG1
	PRTXTC ^\OFF\
	CLR ALEVN
	JMP ERTL2
DEBUG1:	PRTXTC ^\ON\
	MOV #1,ALEVN
DEBUG2:	RTS PC
SGCF:	JSR PC,CKSST
	BIS #MGCF,FLAGS2
	RTS PC
CGCF:	JSR PC,CKSST
	BIC #MGCF,FLAGS2
	RTS PC
STATUS:	BIT #SSF,FLAGS2
	BNE	STATU2	;IF ON TURN OFF
	JSR PC,NECH
	JSR PC,RDSTR	;READ A STRING
	BR	STATU2	;EMPTY OR BREAK
	MOV @S,B	;SEE IF EQUAL TO "SECRET
	MOV #SECRET,C
	JSR PC,EQUAL1
	BR STATU1	;NOPE
	BIS #SSF,FLAGS2	;YES
	POPS A	;POINTER TO STRING READ IN
	PRTXTC	^\ON\
	BR	STATU3
STATU1:	POPS	A
STATU2:	PRTXTC	^\OFF\
	BIC	#SSF,FLAGS2
STATU3:	JSR	PC,ECH
	RTS PC

CKSST:	TST DEBSW
	BNE CKSST1
	BIT #SSF,FLAGS2
	BEQ .+4
CKSST1:	RTS PC
	ERROR+HNM1

SPNF:			;SET PRINT NODES FLAG
	BIS #PNNLF,FLAGS2
	RTS PC
CPNF:	BIC #PNNLF,FLAGS2	;CLEAR IT
	RTS PC

;EXAMINE AN ABSOLUTE LOCATION
EXAMINE:	JSR	PC,GLWANE	;GET A WORD OF ARGUMENT
	ERROR+WTAB
	MOV	#SNUM,A
	MOV	#8.-10.,ABASE
	JSR	PC,CONVERT	;CONVERT ARGUMENT TO OCTAL NUMBER IN B
	ERROR+WTAB
	JSR	PC,PLOCB	;PRINT LOCATION & CONTENTS
	CLR	ABASE
	RTS PC

;DEPOSIT IN AN ABSOLUTE LOCATION
DEPOSIT: JSR PC,CKSST	;MAKE SURE USER IS PRIVILEGED
	JSR PC,EXAMINE	;PRINT LOCATION
	PUSH B		;SAVE LOCATION
	SPUSH	(B)	;AND FORMER CONTENTS
	JSR PC,RDSTR	;READ A LINE FROM THE TTY
	BR	DEPOS1	;EMPTY
	MOV #INUM,A
	MOV @S,B
	MOV	#8.-10.,ABASE	;MAKE FOLLOWING CONVERSION OCTAL
	JSR PC,CONVERT	;CONVERT TO NUMBER
	ERROR+WTAB	;CONVERSION FAILED
	MOV B,C
	JSR PC,.LDP2	;GET NUMBER BACK IN A
	POP D		;FORMER CONTENTS
	SPOP B		;LOCATION
	MOV A,(B)	;DEPOSIT
	CMP	(B),D
	BEQ	DEPOS1	;BR IF LOCATION NOT CHANGE
	TST USER
	BLE DEPOS1	;IF USER ALREADY ON SYSTEM CONSOLE
	JSR PC,SPRINT
	JSR PC,PLOCB	;PRINT LOC AND NEW CONTENTS
	PRTXT ^/ WAS: /
	MOV D,A
	JSR PC,PRON	;PRINT OLD CONTENTS
	SPREND
DEPOS1:	CLR	ABASE	;SET CONVERT BASE BACK TO DECIMAL
	RTS PC		;DONE.
	.STITL ERRORS AND HANDLER
EMTBK:	MOV #SRET,@P	;FAKE IT OUT
	RTI
ERRBK:	PUSH A
	;	*** RON'S DISC CLEANUP STUFF
	CMP #WRITEC,PCHR	;AM I DOING DISC OUTPPUT?
	BNE ERBK2	;NO
	JSR PC,WRITCU	;CLOSE THE FILE
	JSR PC,DELETF	;DELETE IT
ERBK2:	JSR E,LCUGRB	;RLEASE PAPER TAPE
	PGRAB
	JSR E,LCUGRB
	GCLOCK
	CLR DSKNCH	;CLOSES READ OR WRITE
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	MOV 2(P),LASTER
	MOV 2(P),A
;	BIT #PADERF,FLAGS2
;	BEQ ERBK1
	TST NOADDR
	BNE ERBK1
	JSR PC,PRONL	;PRINT ADDR WHERE ERROR OCCURED
	SPACE
ERBK1:	MOV -2(A),A	;GET ERROR #
	BIC #177400,A
	CMP #FSTNER,A
	BLE NEWERR
	ASL A
	MOV ERTAB(A),A	;POINTS TO LIST FOR THIS ERROR
	JMP @A	;XFER TO LIST
NEWERR:	ASL A
	.IFZ NEWERS
	MOV ERTAB(A),ERRPNT
	.ENDC
	.IFNZ NEWERS
	SPUSH 	B
	SPUSH A
	JSR PC,SYDRBG
	CLR (A)+
	SPOP B
	MOV ERTAB(B),(A)
	SUB ERTAB+2(B),(A)
	ASR (A)+
	MOV DBUFAD,(A)+
	CLR 2(A)
	MOV ERTAB(B),(A)
	ASR (A)
	ADD ERBASE,(A)+
	ADC (A)
	ADD ERBASE+2,(A)+
	TST (A)+
	MOVB #DREADC,(A)
	JSR PC,DSKWAI
	MOV DBUFAD,ERRPNT
	SPOP B
	.ENDC
NEWER1:	MOVB @ERRPNT,D
	BEQ ERTLN
	BGT NEWER2
	BIC #177600,D
	ASL D
	MOV ROTTAB(D),A
	JSR PC,(A)
NEWER3:	INC ERRPNT
	BR NEWER1
NEWER2:	JSR PC,TYO
	BR NEWER3
ERRRT:	POP A
	RTI

PPLACE:	MOV FUNLEV,A
	BEQ PPLAC1
	CPRTXT ^\AT LEVEL \
	JSR PC,PRDN
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRTXT ^\  IN \
	MOV CPP,B
	JSR PC,PPNAME
PPLAC1:	JMP .CRLF
EXIT:	JSR PC,PRS1
	POPS A
ERTLN:			;ERR RETURN TO LEVEL N
	TST ALEVN
	BEQ ERTL0
	BIS #ERRF+BRKF,FLAGS
	MOV USER,U
	CLR BRAKE(U)
ERTLN1:	JSR PC,PPLACE
	JMP MLOOP
ERTL0:			;ERR RETURN TO LEVEL 0
	MOV	USER,U
	CLR	BRAKE(U)
ERTL01:	JSR PC,PPLACE
ERTL2:	TST FUNLEV	;POP UP TO LEVEL 0
	BLE ERTL3
	MOV #ERTL2,PSTOPR
	JMP PSTP15
ERTL3:	CLR A	;CLEAR OUT PDLS
	JSR PC,PPTA
	CLR A
	JSR PC,PSTA
	MOV #ERCLR1,A
	MOV #<ERCLR2-ERCLR1>/2,B
	CLR (A)+
	DEC B
	BGT .-4
	BIC #EDTIF+ERRF+BRKF,FLAGS
	JMP MLOOP
	.MACRO ERMM AA
	.IFG FOO-AA'.E
	.ERROR ERROR AA IN WRONG ORDER
	.ENDC
FOO==AA'.E
AA==ERMNO
ERMNO==ERMNO+1
	AA'.E
	.ENDM

	.MACRO BEGER A
A'.E:
	.ENDM

.MACRO	ENDER
	JMP ERTLN
.ENDM
	.MACRO NENDER
	.BYTE 0
	.EVEN
	.ENDM

	.MACRO ENDER0
	JMP ERTL0
	.ENDM
	.MACRO ERROT A
A'.R:
	.ENDM

	.MACRO ERRM A
A'.N==ERRNO
ERRNO==ERRNO+1
	A'.R
.ENDM
	.MACRO EROT A
	.BYTE A'.N
	.ENDM
	.MACRO JROT A
A'.R==A
	.ENDM
ERRNO==200
ERMNO==0
ROTTAB:	ERRM PNAB
	PNAB.R==PNODAB
	ERRM PRLO
	JROT PRLO
	ERRM TYO
	JROT TYO
	ERRM PROAB
	JROT PROAB
	ERRM PRCO
	JROT PRCO
	ERRM PRS1
	JROT PRS1
	ERRM PRCT
	JROT PRCT
ERTAB:	FOO==0
	ERMM BRK	;BREAK!!
	ERMM BSS	;BAD SS
	ERMM BUG	;SYSTEM BUG!!!
	ERMM CTIT	;CANT "TO" IN "TO"
	ERMM FBUG	;FATAL SYSTEM BUG
	ERMM HNM	;.(B). HAS NO MEANING
	ERMM LDE	;LINE ..(B).. DOESN'T EXIST
	ERMM PAE	;PROCEDURE ..(TOPRNM).. ALREADY EXISTS
	ERMM PAE1	;PROCEDURE (TEMP) ALREADY EXIXTS
	ERMM PNH	;PROCEDURE .(CT). NOT HERE
	ERMM PNH1	;PROCEDURE .(CPP). NOT HERE
	ERMM TMAP	;TOO MANY ARGS (PROC BEING TO'ED)
	ERMM WTA	;..(CO)..DOESN'T LIKE..(CT)..AS INPUT
	ERMM WTAA	;..(CO)..DOESN'T LIKE..(A)...AS INPUT
	ERMM WTAB	;..(CO)..DOESN'T LIKE..(B)...AS INPUT
FOO==0
FSTNER==ERMNO	;NEW STYLE ERRORS START HERE
	ERMM CDF	;CAN NOT DELETE THAT FILE
	ERMM COP	;CHAR (D) OUT OF PALCE
	ERMM DFU	;DISC FULL
	ERMM DIU	;DEVIVE IN USE
	ERMM DNR	;DEVICE NOT READY
	ERMM DOR	;DURATION OUT OF RANGE
	ERMM DRF	;DIRECTORY FULL
	ERMM EAW	;ERASE ALL WHAT??
	ERMM ELW	;EDIT LINE WHAT?
	ERMM ERP	;EXTRA RIGHT PAREN
	ERMM ERW	;ERASE WHAT??
	ERMM FAE	;FILE ALREADY EXISTS
	ERMM FNF	;FILE NOT FOUND
	ERMM HNM1	;..CT.. HAS NO MEANING
	ERMM HNV	;.(CT). HAS NO VALUE
	ERMM IFN	;A,,B IS INVALID FILE NAME
	ERMM INF1	;INFIX IN THE WRONG PLACE
	ERMM INVN	;INVALID NODE
	ERMM IPN	;..(CT).. IS AN INVALID LOGO NAME.
	ERMM ITN	;INVALID TURTLE NUMBER
	ERMM IUN	;INVALID USER NAME
	ERMM IVV	;INVALID VOICE NUMBER
	ERMM LCE	;LINE ... CHANGED BY EDIT
	ERMM LNTB	;LINE # TOO BIG
	ERMM LNTS	;LINE # TOO SMALL
	ERMM MFN	;MISSING FILE NAMES
	ERMM NDU	;NOT A DISPLAY USER
	ERMM NEC	;NOT AN EDITING COMMAND
	ERMM NIP	;NOTHING INSIDE PARENS
	ERMM NOG	;NOTE OUT OF RANGE
	ERMM NOU	;NO OUTPUT
	ERMM NSL	;NO STORAGE LEFT
	ERMM NTF	;(S) NOT "TRUE" OR "FALSE"
	ERMM NTL	;NUMBER TOO LONG
	ERMM NTP	;NOT A PROCEDURE
	ERMM NUD	;(CO) ONLY VALID WHEN USING A DISPLAY
	ERMM OIP	;ONLY IN PROCEDURE
	ERMM OIPD	;ONLY IN PROCEDURE DEFINITION
	ERMM OOB	;OUT OF BOUNDS
	ERMM OOP	;(CO) OUT OF PLACE
	ERMM OOT	;OUT OF TOKENS
	ERMM PBE	;PROCEDURE IS BEING EDITED
	ERMM RTB	;RESULT TOO BIG
	ERMM SAW	;SHOW ALL WHAT??
	ERMM SHW	;SHOW WHAT??
	ERMM SMB	;SOMEONE ELSE IS USING THE MUSIC BOX
	ERMM STD	;SNAP TOO DEEP
	ERMM TGDZ	;TURTLE GETTING DIZZY
	ERMM TIP	;TOO MUCH INSIDE PARENS
	ERMM TMAC	;TOO MANY ARGS (CURRENT PROC)
	ERMM TML	;TOO MANY LINES
	ERMM TNA	;TURTLE NOT AVAILABLE
	ERMM TNR	;TURTLE NOT RESPONDING
	ERMM UBL	;USED BY LOGO
	ERMM UEL	;UNEXPECTED END OF LINE
	ERMM UELX	;...(CO) NEEDS ARGS
	ERMM VTD	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE OR A DISPLAY
	ERMM VTU	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE
	ERMM WDW	;YOU DON'T SAY WHAT TO DO WITH...
	ERMM WIT	;(CT) IS WRONG INPUT TO "TO"
	ERMM WNA	;WRONG NUMBER OF ARGUMENTS TO ..(CO)
ERTEND:	ERREND
	.STITLE - ERROR ROUTINES
		; ****  THESE ARE NOW ALPHABETIZED   *****


	.MACRO ETEXT AA
	.ASCII \AA\
	.ENDM

BRK.E:
	MOV USER,U
	MOV BRAKE(U),A
	CLR BRAKE(U)
	TST A
	BLT BRK.1
BRK.2:	JSR PC,BRAKR
	PRTXT ^\BREAK\
	JMP ERTL01
PAUSE:
BRK.1:	TST ALEVN
	BEQ BRK.2
	BIS #BRKF,FLAGS
	PRTXT ^\PAUSE \
	JMP ERTLN1
	BEGER BSS
	PRTXT ^/BAD SS./
	ENDER

	BEGER BUG
	TST	DEBSW
	BNE	BUG.1	;BR IF DEBUGGING
	DEC NSYBUG
	BGE .+4
	ERROR+FBUG
BUG.1:	PRTXT ^/HELP!!!  SYSTEM BUG VER=/
	MOV #VERNF,A
	JSR PC,PRDN
	JSR PC,.SPACE
	PUSH	E
	SPUSH	U
	MOV	USER,U
	MOV	UTTY(U),E
	TST	TOTN(E)
	BGT	.-4	;WAIT TILL TYO BUF EMPTY
	POP	U
	SPOP	E
	SPOP A
	TST	DEBSW
	BEQ	.+4
BUGBPT:	BPT	;BRK IF IN DEBUG MODE
	ENDER

	BEGER CTIT
	PRTXT ^\YOU ARE ALREADY DEFINING \
	MOV TOPRNM,B
	JSR PC,PPNAME
	ENDER

	BEGER FBUG
	PRTXT ^/FATAL SYSTEM BUG!/
	JMP GOODBY

	BEGER HNM
	MOV #UFUN,A
	JSR PC,PROAB
	PRTXT ^/ HAS NO MEANING./
	ENDER

	BEGER LDE
	PRTXT ^\LINE \
	MOV B,A
	JSR PC,PRDN	;LINE # SHOULD BE IN A
	PRTXT ^\ DOESN'T EXIST.\
	MOV JPLN,CPLN	;MAKE JUMPED-FROM LINE = POINT OF ERROR
	ENDER

	BEGER PAE
	MOV #UFUN,A
	MOV TOPRNM,B
	PRTXT ^/PROCEDURE /
	JSR PC,PROAB
	PRTXT ^/ ALREADY EXISTS./
	MOV ERPRNM,TOPRNM
	ENDER

	BEGER PAE1
	MOV #UFUN,A
	MOV TEMP,B
	PRTXT ^/PROCEDURE /
	JSR PC,PROAB
	PRTXT ^/ ALREADY EXISTS./
	ENDER

	BEGER PNH
	MOV ERPRNM,TOPRNM
	PRTXT ^/PROCEDURE /
	JSR PC,PRCT
	PRTXT ^/ NOT HERE/
	ENDER

	BEGER PNH1
	MOV CPP,B
	MOV #UFUN,A
	PRTXT ^/PROCEDURE /
	JSR PC,PROAB	;PRINT OPERATOR IN A,,B
	PRTXT ^/ HAS BEEN ERASED!!??/
	ENDER

	BEGER TMAP
	PRTXT ^\A PROCEDURE CAN'T TAKE > 32 ARGS.\
	JMP ERRRT	;RETURN!!
	BEGER WTA
ERWTA:	JSR PC,PRCO
	PRTXT ^/ DOESN'T LIKE /
	JSR PC,PRS1
	PRTXT ^/ AS INPUT./
	ENDER

	BEGER WTAA
	PUSHS A
	BR	ERWTA
	ENDER

	BEGER WTAB
	PUSHS B
	BR	ERWTA
	ENDER

	.IFNZ NEWERS
	.MACRO NERRS
	.OFFSE 0-.
	.ENDC

	BEGER CDF
	ETEXT ^/CAN NOT DELETE THAT FILE./
	NENDER

	BEGER COP
	ETEXT ^\CHAR \
	EROT TYO
	ETEXT ^\ OUT OF PLACE.\
	NENDER

	BEGER DFU	;DISC FULL
	ETEXT ^/DISC FULL./
	NENDER

	BEGER DIU
	ETEXT ^/DEVICE IN USE./
	NENDER

	BEGER DNR
	ETEXT ^/DEVICE NOT READY./
	NENDER

	BEGER DOR
	ETEXT ^/DURATION OUT OF RANGE/
	NENDER

	BEGER DRF	;DIRECTORY FULL
	ETEXT ^/DIRECTORY FULL./
	NENDER

	BEGER EAW
	EROT PRCT
	ETEXT ^/ - ERASE ALL WHAT??/
	NENDER

	BEGER ELW
	EROT PRCT
	ETEXT ^/ - EDIT LINE WHAT?/
	NENDER

	BEGER ERP
	ETEXT ^/EXTRA RIGHT PAREN/
	NENDER

	BEGER ERW
	EROT PRCT
	ETEXT ^/ - ERASE WHAT??/
	NENDER

	BEGER FAE
	ETEXT ^/FILE /
	ETEXT ^/ ALREADY EXISTS./
	NENDER

	BEGER FNF
	ETEXT ^/FILE /
	ETEXT ^/ NOT FOUND./
	NENDER

	BEGER HNM1
	EROT PRCT
	ETEXT ^\ HAS NO MEANING.\
	NENDER

	BEGER HNV
	EROT PNAB.N
	ETEXT ^/ HAS NO VALUE./
	NENDER

	BEGER IFN
	EROT PRCO
	ETEXT ^/ IS INVALID FILE NAME./
	NENDER

	BEGER INF1
	EROT PRCO
	ETEXT ^/ IS IN THE WRONG PLACE./
	NENDER

	BEGER INVN
	ETEXT ^\INVALID NODE.\
	NENDER

	BEGER IPN
	EROT PRCT
	ETEXT ^/ IS AN INVALID PROCEDURE NAME./
	NENDER

	BEGER ITN
	ETEXT ^/INVALID TURTLE NUMBER/
	NENDER

	BEGER IUN	;INVALID USER NAME
	ETEXT ^/INVALID USER NAME./
	NENDER

	BEGER IVV
	ETEXT ^/INVALID VOICE NUMBER/
	NENDER

	BEGER LCE
	ETEXT ^\LINE ... CHANGED BY EDIT.\
	NENDER

	BEGER LNTB
	ETEXT ^\LINE NUMBER TOO BIG.\
	NENDER

	BEGER LNTS
	ETEXT ^\LINE NUMBER TOO SMALL.\
	NENDER

	BEGER MFN
	ETEXT ^/MISSING FILE NAMES./
	NENDER

	BEGER NDU
	ETEXT ^/YOU DON'T HAVE A DISPLAY CONSOLE/
	NENDER

	BEGER NEC
	EROT PRCT
	ETEXT ^/ IS NOT AN EDITING COMMAND./
	NENDER

	BEGER NIP
	ETEXT ^/NOTHING INSIDE PARENTHSES./
	NENDER

	BEGER NOG
	ETEXT ^/NOTE OUT OF RANGE/
	NENDER

	BEGER NOU
	EROT PRLO
	ETEXT ^/ DIDN'T OUTPUT!/
	NENDER

	BEGER NSL
	ETEXT ^/NO STORAGE LEFT./
	NENDER

	BEGER NTF
	EROT PRS1
	ETEXT ^/ NOT "TRUE OR "FALSE ./
	NENDER

	BEGER NTL
	ETEXT ^/NUMBER TOO LONG/
	NENDER

	BEGER NTP
	EROT PRCT
	ETEXT ^/ IS NOT A PROCEDURE NAME./
	NENDER

	BEGER NUD
	EROT PRCO
	ETEXT ^/ IS ONLY VALID WHEN USING A DISPLAY/
	NENDER

	BEGER OIP
	ETEXT ^\ ONLY WHEN IN A PROCEDURE.\
	NENDER

	BEGER OIPD
	EROT PRCO
	ETEXT ^/ONLY IN PROCEDURE DEFINITION./
	NENDER

	BEGER OOB
	ETEXT ^/OUT OF BOUNDS/
	NENDER

	BEGER OOP
	EROT PRCO
	ETEXT ^/ OUT OF PLACE./
	NENDER

	BEGER OOT
	ETEXT ^/OUT OF TOKENS./
	NENDER

	BEGER PBE
	EROT PRCT
	ETEXT ^/ IS BEING EDITED./
	NENDER

	BEGER RTB
	ETEXT ^\ARITHMETIC RESULT TOO BIG.\
	NENDER

	BEGER SAW
	EROT PRCT
	ETEXT ^/ - PRINTOUT ALL WHAT??/
	NENDER

	BEGER SHW
	EROT PRCT
	ETEXT ^/ - PRINTOUT WHAT??/
	NENDER

	BEGER SMB
	ETEXT ^/SOMEONE ELSE IS USING THE MUSIC BOX/
	NENDER

	BEGER STD
	ETEXT ^/SNAP TOO DEEP/
	NENDER

	BEGER TGDZ
	ETEXT ^/INPUT TO RIGHT OR LEFT TOO LARGE/
	NENDER

	BEGER TIP
	ETEXT ^/TOO MUCH INSIDE PARENS./
	NENDER

	BEGER TMAC
	ETEXT ^\"\
	EROT PRCO
	ETEXT ^\" CAN'T TAKE > 32 ARGS. \
	NENDER

	BEGER TML
	ETEXT ^/TOO MANY LINES/
	NENDER

	BEGER TNA
	ETEXT ^/TURTLE NOT AVAILABLE/
	NENDER

	BEGER TNR
	ETEXT ^/HELP! TURTLE NOT RESPONDING./
	NENDER

	BEGER UBL
	EROT PRCT
	ETEXT ^/ IS USED BY LOGO./
	NENDER

	BEGER UEL
	ETEXT ^/UNEXPECTED END OF LINE./
	NENDER

	BEGER UELX
	EROT PRCO
	ETEXT ^/ NEEDS MORE INPUTS./
	NENDER

	BEGER VTD
	EROT PRCO
	ETEXT ^/ ONLY VALID IF YOU HAVE A TURTLE OR A DISPLAY/
	NENDER

	BEGER VTU
	EROT PRCO
	ETEXT ^/ ONLY VALID IF YOU HAVE A TURTLE/
	NENDER

	BEGER WDW
	ETEXT ^/YOU DON'T SAY WHAT TO DO WITH /
	EROT PRS1
	NENDER

	BEGER WIT
	EROT PRCT
	ETEXT ^/ CAN'T BE AN INPUT./
	NENDER

	BEGER WNA
	ETEXT ^/WRONG NUMBER OF ARGUMENTS TO/
	EROT PRCO
	NENDER

ERREND==.
	.IFNZ NEWERS
	.OFFSE 0
	.ENDM
	.ENDC
