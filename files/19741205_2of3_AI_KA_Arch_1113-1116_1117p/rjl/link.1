vL@Dk @5ЉXALINKEK&Ih+0c0Fw	COPYRIGHT 1970,1971,1972$Ǔf QUIPM OATION񢝠A     -AG 72BWTTLE	L3bjAE 1
cE.pfLOE,.COQV.rX]tYTT,.DELET,.DTCVT,.D2BIN
.MCALL	.EXIT,.INIT,.MONF,.OPEN,BRDPK,.READ,.RLSE,.RSTU]̙	.STATCVT,.TRAN,.TRAPT,.WRITE,.!ə,.LOOcE;
	.aҟ5SON
	.ASCII	/V11A01/񢄮NDM

;

;
	.IFDbEƊOiE	.ENDC
;
;	DEgEAQcɧTERSNƊR0=%0
	R1=%1
	R2=%CE	3=%3Bi4{%4
	R5=%5
	SP=%6
4!K7
;
;	DEFINE PARAM"ҧ񢝍b`Ӈ2PCARACTERS
0=c5
	LF=12
	VT=,Ɗa=c1
	FF=14			;FOSPFED
	LANG=;<
	PgG{76			otF{005015
	L=114

;NӳATABLE PARAMETERcE;BaP3^a.		;# YTES PER SYMBOLq^]			;D4ACE TO BASE  SECTION
1AoZ		;DISTANCE TO FLAGS A ENTRY
	VALR=6			;D4ACE TO RELOCATABPVLUE OF AN ENTRY
	NAY=e			;DISTANqPT 2ND WORD ON ANgT#E	BJMN=DwOBJECT MOD"AME
4éN=1			;SECTION NAMEBiٛN=4		.ٛBOL ENTRY
	ABSREL=40		;ABS/REL BIT (0/1)
	UNDEF=10		;UNDEFINED/DEFINED (0/1)
2gTLB=100		;INTERNAL/GLOBAL (0/1)
	MONCND=1		;MONITOR ROUTINE pgDDATE
	LOC3		;LOCAL SECTION NAME
	IgT{6			;IDENT DIRECTIVE.
񢝍bjX MODIFICATION COMMANƊw
	TCMD1=1			;INTERN3RION
	TCMD2=2			;GLOBAL R'ÃTION
	TCMD3=3			;INTERNAL DISPLACEE	CMD4=4			;'L DISPLACED
	TCMD5=5			;GLOBA ĉ5$֋ԇMD6=6			;GAbDkEADISPLACEDBjC޹]		;GENERAT&IITS

;
bhCAMODIF0ԓON CO`ΉS
;
	PCM^		;SET PC
	PCMD2=8."D$Ƴ PC
bfɧCELLANEOUS񢆊t&E=100.		;ST0堙ENGTH񢆊3'ħZ=320"]sUE LOADER SIZE
	HGHM^m384.		;HIGH MEMADR +#E;
;	MONITOR IO COMMANDSNƊINIT=E	PEN=1E	PENI=E	PENO=2
	Ru)T{41
	d{1
	Rb=iץ5"e
	CLOSE=17
	R"=7
	TRAPV=41
	CSI1=56
	CSI2=57
1{41
	CONV=42
	fE=21
	TRANX	STATY	GET=Fj=i#E	CTION0abDw"ëTE LOAD MOE+ƉF	BLKIO
	.GLOBL	REAj,EADST,CLOSRD,INITRD
	.GLOBL	RLSRD,"ΥD,READIU,XXREADgAYINB,OBJDEV񢄮LOBL	Bk'ADR
+ΉC

;
;	II DATA MODES
;
	FASoX	FBIN=1
	UFBIN=3
;
;	MONITOR IO O BITS
;
	EOF=,;
;	BLOCK,Ћ COMMANDS
;
	GSDBLK=1
	TXTB޳BiLS%i
	ISDBLK=5
	M"Ή=6
	GSDEND=2
	STBB޹]
	STBEND=10.
;
;	JUMP aL MAX 3IES.
cE	WSMAX`{3		;SPLNK57
	GSDl=m.ŋӉ05
	PMAX=6		;SPSMDT
	CMDMAX=14.	;SE)CDT
	ERMAX=3		;SEE ERTABNßMD SIQP(YTES)ßMDSZ=36
	IND=6		;INDEX INTO F3";	MISCELLANEOUS
	Ba4.	;52 WORDS FOR CSI BUFFS.
	DETACZ0;DETACH BIT FOR"ERS
	MXDVva00.	;4՛a WORDh& SIZE FORBDw"RVER AND BUFFER.
	OCI{4	;OCTAL TO BINARY CODE
	DETOBI=2	q"ÓMAL TO BINARY C"	RATOBI=0	tēX50 TO BINARY CODE
	DOTBLK=120tēX OR ".  "
	BLANtް;RADIX50 FOR "   "
2gC{256.
	ERR10=1444	;F044-ETAIN FOU)A COMM3 TRINGԑ4SURCE T&IKER C3BSEMBLED INTO TWO UNI5bERSIONS:
;1.  IF TH)ٛBOL "NOSEG" IS DEFINED, TFw    R̩ING ORé MODULE IS THE FULL
;    LINKh A********************J*U************
;2.  IF THE SYMBOL "NE IS NOT DEFINEDEw    THE REufTNG PArǋi LINKw HAT UfICQPOERLAYS FROM THEөEM
;    DEVICE TO CONSERVE ON SYMBTBLE SPACE.
;񢝉HIS VERSIO'ATHE LINKER
;	UTILIZES CORE OVAh#R*H SYSTEM
;	DEVIqPT CONSERVE ON SYMBOL aL SPACE.
;
;THE OVERLAY iSON OF$EALINKEH$ASELF sT3;IN  A5I ITS  iLY BUILDER.
;
;WHEN$EASYMBOL "OVRBLD" IS D΋D, THE
;RESULTING OBJECTgīLE IS$EABUILD;
;WHEN THE SYMBOL "OVRBLD" Ih'O"ƓNED, THE
;RESULTINGJCT MODULE IS THE RESIDENT LINKER.
cE;HEN LINKED, THEəDER'S TOP r'ՙD BE ,4mwEXECUgGA"UILDEI頙b *̋
;VIA THE MONI OMMAND RUN
;CAUSES THE CREATION OF$E;CONTIGUOUS FIPO OVERLAYSNLNK11.OVR) ON THE SYSTEM DEVICEԑ'Ǔ*ɇ.
;
;WHEN LINqb,ATHE RESIDENT LINKER'h*O SHOULD ALSO BE XXX460.
pj UN TIV HE RErbET LINqitѫIRES "iLYS TO*H SYSTEM DEVICE
;WIT#IE NAME LINK11.OVR AN&OIN OR [1,1]UIC.
;
	.CSEu.IFDF3ӋG
OVPD{1			;PORTIONS OF
L1=0				;BUISu$ϝ
L2=0				;ARE NEEDE3=0				;SET ALL SYMBOLS
L4=0
L5=0"DwUSED IN ADJUSTIƊ6=0
L7=0	"DDDRESqi+ϥK
L8/X			;INElQca1=0			;ENVIRONMBEGO02=0			;TO 0.
BEGO03=0
BEGO04EGO05=0
BEGO06EGO07=0
Bq=0
BEGO09=0
BEGOVR=0
	.ENDC񢝍j*USELAY PROCEDURES*J*;
;THE NUMBER OF B5"AALLOCATED FOR THE
;OVERL6PAEA
Oԩɵ=2000.ذe4 DEC3`AVjE
;TH'UBER OF WORAFR THE
;OVERLAYiE
OVRWRD=1000	;512 aɛAL WORDS
;
;IF THE SYMB"VRBLDH$AcI(IA A
;PARAMETER ASSIGNMENT) TPRufTOJECTNω"ILL CONSIST OF:
;		OVERL6PB3"E񢝉OVERL6P#c
;		OVERLAY #2
;		.
;	+w		.
;		OVERLAY #N
bDϭA AREA񢝉RESID 3c1
;NH RUN fAΧFER ADDRESS WIL!ENS4BE IN TPOERLAYəi;
;IF THEͅOL "OVRBLDH$A EFINED
;THE RESULTING OBQaAMODUL+əL
;CONSIS'u
;		OVERLAY AREA
;		RESIDENT LINK-11
;
;THE RUN TIME TRANSFER ADDRESS WILL
;BE "LNK" IN RESIDENT LINK-11
;
;
;
;PARAMETER ASSIGNMENTS
WTCMD=1				;.WAIT
OPN=16				;.OPEN
DLT=21				;.DELETE
RLS=7				;.RELEASE
R6=%6				;REGISTER 6
R7=%7				;REGISTER 7
ERR9=1640			;NOT ENOUGH ROOM AT BUILD TIME
				;TO ALLOCATE CONTIGUOUS FILE
ERR8=2207			;EOD OR DEVICE ERROR ON OUTPUT
				;.TRAN OR DEVICE ERROR ON
				;INPUT .TRAN
;
;
;IF IN RSX PROCESS RTH ALWAYS
;
	.IFDF	RSX
	RTH=1
	.ENDC
	.IFDF	OVRBLD
	.IFNDF	NOSEG
	.TITLE	LINKOB
;
;THE FOLLOWING TABLE CONTAINS THE
;STARTING CORE ADDRESS OF EACH OVERLAY
;IN THE ORDER OF ASCENDING LOCATIONS.
;A 0 WORD TERMINATES THE ENTRIES.
;AS NEW OVERLAYS ARE CREATED THEIR
;POINTERS MUST BE ADDED TO THE END
;OF THE TABLE AND THE OVERLAY ITSELF
;PUT IN THE SAME POSITION
;RELATIVE TO THE OTHER OVERLAYS.
;
OVRTAB:	.WORD	BEGO01		;OVERLAY #1
	.WORD	BEGO02		;OVERLAY #2
	.WORD	BEGO03		;OVERLAY #3
	.WORD	BEGO04		;OVERLAY #4
	.WORD	BEGO05		;OVERLAY #5
	.WORD	BEGO06		;OVERLAY #6
	.WORD	BEGO07		;OVERLAY #7
	.WORD	BEGO08		;OVERLAY #8
	.WORD	BEGO09		;OVERLAY #9
	.WORD	0
;
;OVERLAY DEVICE OUTPUT TRAN BLOCK
;
OVRTBO:	.WORD	0		;DEVICE BLOCK NUMBER
OVROSA:	.WORD	0		;MEMORY START ADDRESS
	.WORD	OVRWRD		;WORD COUNT
OVRERR:	.WORD	2		;FUNCTION (WRITE)
	.WORD	0		;NUMBER OF WORDS NOT TRAN'D.
;RESTART ADDRESS OF OVERLAY BUILDER---
;RELEASE OVERLAY DEVICE IF STILL INIT'D.
AGAIN:	TST	OVRLB		;IS DATA SET INIT'D
	BEQ	STARTB		;NO
	.RLSE	#OVRLB		;YES-RELEASE IT
;
;STARTING ADDRESS OF OVERLAY BUILDER
STARTB:	MOV	#OVRTAB,R6	;INITIALIZE THE STACK
	START=STARTB		;SET UP TRANSFER ADRESS
	;SET UP RESTART ADDRESS
	.RSTRT	#AGAIN
;
;USE THE COMMAND STRING INTERPRETER (CSI)
;TO DETERMINE THE SYSTEM DEVICE AND
;UNIT OF THIS SYSTEM.
;
	MOV	#ONCE,R0	;ADDRESS OF ONCE ONLY FLAG.
	TSTB	(R0)+		;BRANCH IF ALREADY
	BEQ	OVER		;DONE ONCE.
;THE FLAG AT ONCE IS CLEARED BY CSI
;DUE TO ITS PROXIMITY TO OVRFB.
;R0 NOW POINTS TO OVRBLK.
	.CSI1	@R0		;ADDRESS OF CMDBUF
;THE LINE IS SYNTACTICALLY ACCEPTABLE, THUS
;THE RETURN FLAG ON TOP OF STACK IS IGNORED.
	MOV	R0,@R6		;ADDRESS OF OVRBLK
	EMT	57		;CSI2
	TST	(R6)+		;CORRECT STACK
OVER:
	MOV	#OVRLB,R1	;LINK BLOCK
	CLR	@R1		;FOR ^C BEGIN
	MOV	#OVRFB,R2	;FILE BLOCK
	MOV	#OVRTBO,R3	;OUTPUT TRAN BLOCK
;.INIT OVERLAY DEVICE
	.INIT	R1
;OBTAIN DEVICE STATUS
	.STAT	R1
	CMP	(R6)+,(R6)+	;CORRECT STACK.
				;PHYSICAL BLOCK SIZE
	MOV	@R6,R4		;(IN WORDS) OF OVERLAY DEVICE
	MOV	#OVRWRD,-(R6)
	JSR	R7,DIVIDE
	MOV	(R6)+,R5	;NUMBER OF PHYSICAL
				;BLOCKS PER OVERLAY
	CLR	-(R6)
	MOV	#OVRTAB,R0
BLDR01:	TST	(R0)+		;TOP OF STACK
	BEQ	BLDR02		;CONTAINS TOTAL
	ADD	R5,@R6		;NUMBER OF PHYSICAL
	BR	BLDR01		;BLOCKS REQUIRED.
BLDR02:	MOV	#64.,-(R6)	;DIVIDE PHYSICAL BLOCK
	MOV	R4,-(R6)	;SIZE BY 64 (DECIMAL)
	JSR	R7,DIVIDE	;QUOTIENT ON STACK.
	MOV	(R6)+,R0	;NUMBER OF 64'S IN
				;PHYSICAL BLOCK
	MOV	@R6,R4		;TOTAL NUMBER OF
				;PHYSICAL BLOCKS REQUIRED

BLDR03:	DEC	R0
	BEQ	BLDR08		;TOTAL NUMBER OF
	ADD	R4,@R6		;64 (DECIMAL) WORD BLOCKS
	BR	BLDR03		;REQUIRED ON TOP OF
				;STACK
;DELETE FILE IF ALREADY EXISTING
BLDR08:	MOV	#BLDR04,-4(R2)	;ERROR RETURN
	.DELET	R1,R2
BLDR04:	CLR	-4(R2)		;ERRORS TO MONITOR
;ALLOCATE THE NECESSARY SPACE FOR ONE
;CONTIGUOUS FILE.
	MOV	R2,-(R6)	;FILE BLOCK
	MOV	R1,-(R6)	;LINK BLOCK
	EMT	15
	TST	(R6)+
	BLT	BLDR09		;SPACE AVAILABLE?
	CLR	-(R6)		;NO.
	MOV	#ERR9,-(R6)	;FATAL ERROR.
	BR	BLDR10
;
;DETERMINE THE PHYSICAL STARTING BLOCK
;OF THE CONTIGUOUS FILE AND PLACE IT
;IN THE 1ST WORD OF THE OUTPUT TRAN BLOCK.
BLDR09:	.LOOK	R1,R2,1
	MOV	(R6)+,@R3	;STARTING BLOCK.
	CMP	(R6)+,(R6)+	;CORRECT STACK
;THE ONE CONTIGUOUS FILE WILL CONTAIN
;N OVERLAYS WITH EACH BEGINNING AT THE
;START OF A PHYSICAL BLOCK ON THE DEVICE
;
	MOV	#OVRTAB,R0
BLDR07:	MOV	(R0)+,OVROSA	;MEMORY START ADDRESS
	BEQ	BLDR05
;TRAN OUT AN OVERLAY.
;
	.TRAN	R1,R3
;WAIT FOR COMPLETION OF TRANSFER
;
	.WAIT	R1
;CHECK FOR ERROR ON TRANSFER
;
	BIT	#140000,OVRERR
	BEQ	BLDR06
;ERROR ON TRANSFER
	MOV	OVRERR,-(R6)	;PUSH STATUS BYTE
	BIC	#377,@R6	;INTO LOW INFO BYTE
	SWAB	@R6		;AND CLEAR THE REST.
	MOV	#ERR8,-(R6)	;ERROR CODE

BLDR10:	IOT
	.EXIT			;RETURN TO MONITOR
BLDR06:	ADD	R5,@R3		;CHANGE BLOCK NUMBER
				;IN TRAN BLOCK FOR
	BR	BLDR07		;NEXT OVERLAY TRANSFER
;
;ALL OVERLAYS HAVE BEEN TRAN'D OUT.
;
BLDR05:	.RLSE	R1
;
;RETURN TO THE MONITOR
	.EXIT
;*****OVERLAYS BEGIN HERE*****
;
;	OVERLAY #1
L1=BEGOVR-BEGO01		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO01:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START1		;ENTRY1
	.ENDC
;
;	CREATE COMD
;
;	INIT THE OUTPUT DATA SET TO HSP.
;
;
;	INITIALIZE LOAD MODULE DATA SET
;
START1:	TST	LODDEV+6-L1	;ANY LOAD MOD OUTPUT?
	BEQ	LINK24		;NO--
;	INIT OUTPUT DATA SET, DELETE OUTPUT FILE
;	OPEN OUTPUT FILE
	MOV	#OPLOD-BEGO01+BEGOVR,LODADR-4-L1	;SET UP ERROR RETURN
	.INIT	#LODDEV		;INIT THE DATA SET
	TST	LODADR+4-L1
	BNE	.+10
	MOV	#0,LODADR+4-L1
	.=.-4
	.RAD50	/LDA/
	.=.+2
	.DELET	#LODDEV,#LODADR
;	IF THE FILE ALRbYA$өI WASNċjEgDACONTROL WAS RETURNED
;	NW;	IF "3"ID NO"ؓST, TPEROR
biEURN "&OH+ TAKEˆw񢝉g OAD M*̋̋񢝍&O:	CLR	LODADR-4-L1	;NOW LET MON HANDLE ERRORS
	INCB	LOD#-"]ɝDICATE LOAD MODULE OgEԧT	LOD1)+i-L1
	BNE	.+10͟V	#0,LODADJ-1	;SE"EAULT *Erg	.=.-4
	.RAD50	/LD+Ɗ.=.+2
	.OPEN	#LODDE̟bRNɝ5O*;
LINK24:	IOO"DwqjSAR0,R1'ROPER BUFFER
;
;	SU THE UcFR AND DUMP IT.  USE LRc AS POINTERS.
;
	MbS)0S.ũ BC
;	SET͉ LOAD ADDRESS
3gR-L1,-(SP)	;ASSbOWADR IS OkCMP	PTڋ-L1,#sħB]ɧ PROGRAM SMALLER THA!ϛƊBHIS	LINK15		;NqPLbR	CLR*)S		;ASSUME 0 AS A1"RSS.
0TOPMEM-L1,p͉SZ	;IS TOP'A	BLO	LINK15		;YES -iA0 AS LOAD ADDRESS
		OPMEM-L1,(SP)	;1i[ PUT COMD UP AGAINST']
	SUB	#CO)Y(SP)	;CALCULATEҥ DDRESkINK15:	MOV*)S+,(R1*ĻET LOAD ADDRESS FOR s]
	MOQa01,(R1)+	;SET COMMAND FOR 12. GENERAL WORDS.
	MOV	LOWADR-L1,(R1)+	;SET PROGRAM 렃DDRESS
	.IFDF	RTH		;BRTH20
	TSTB	RTF-L1		;RTH WITH MODULE?Q	.+16		;NFSUB	SS-L1,-2(R1)	;YES, LA [ STACK SIZE
	SUB	#2,-2(R*FgD			;ERTH20
	MOV	PRS61,(R1)+	;SET PROGRAMڋ񢄮FDF	RTH		;BRTH21
	TSTB	Rc		;RTH WITH MODULE?
	BEQ	LNK177		;֍	TSTB	NOIOf1	BEQ	.+10
	ADD	RTHSIZ-L1,-2(LT+ΉbDwERTH21
LطoBfϭ5)A[L1,(R1)+	;qj PFMOV	TRADDTQR1)+	;DDT 1"RSS
	s)	QR1)+	.O LOAD-TIME̟CATABLE
	MOV	SYMC-L+)2Bfϭ	(R2)kRc)+	;SET MOfEAf	MOV	(R2)kRc)+
	cD4H	;BRT5)ԅ	RTF-L1
	BEQ	LNK179ԧTB	NOIOF-L1
	BEQ	LNl[	TSTB	CSIN-L1		;NAME FRO!ӓ
	BNfN178		vb[
	MOVQR1),NAM1-L"]Ο-FILL͋ FROM͉͟VQR1),NAM2-L1
	BBfN179
LNK178:	MOV	NAM1-L1,-4(R1)	;NO̙ NAME FROM COMD͟V	NAM2-L1,Rc)
LNl[u	CLRB3ɟf1BWEDC			qiTLw񢝉ET .IDENTNƊ1"	GBPSYM,R2	;R2 POINTS FAG WORD OF NEXT
				;ENTRY IN SYMBTBLE
	CMP	(R2),l0a	;IS .IDEN)ЋCIFIEƊSc$		;NFCMP	-(R2),)2S.ŧ-SET R2 TO .IDENT INͩAB
	MOV	(R2)+,(R1)+	;SET .IDENT
		QR2)+,(R1)+
	BR,;
;	SET T3bF DAY WHEN MODULE LINKED
;
1ÙBTRc*ĉwCLEAR AREA OF .1"Ω IN COMD
	CLR	(R1)+$u	MOV	#104,-(SP)
	EMT	41Bfϭ	(SP)kRc)+	;STME
		QtY(R1)+񢝍;	SET DATEEgīPLNKED IN JULIANNƊMOV	#103,-(SP)
	EMT-	MOV	(SP)+,(R1)+	;SET DATE	OV	R1	MOV	l(1)+
	MOV	SSYME-L1,R3
LNK119:0LUYME-L1
	BHIS	LNK120ÛP	-4(R0),(R0)
	BLE	LNK126
	BIT	#MΉ,FLAGS(R3)
	BE"fN125
	MOV	PiQR3),(LTB`ĉ	#INC)2S
	ADD	#2,)Bfϭ	R3,R4
	SQUISH
	SUBQ¡SYM,USYME-L1
	BR	LNK119
LNK125:	APSYM,R3
	BR	LNlXLNK126:	3	TSTB	IOOPER-L1
	BEQ	.+6
LNl[0u2gKe5-L1
	ADD	-4(R
VLWADR-L1
	MOV	LOWADRQR1)+
	MOV	R1,R2
	MOV	#2)1S+
	Mi,(R0)¥	LNK1.Fزa:	MOV*)0STS)
	Ae)S
	CMP	-4(R0),(SP)+BaG	LNK127
	IOOP
	TSTBdϟPER-L1
	BNE	LNK160
	ADD+Z(0),LObR[L1
		OWADR-L1,(R1)+
	ADD	#2,(R0)
eD	#2,(R0)
	CLR	(R1)bDND OF COMD
	IOOP			;PUT OUT THE COTSTB	IOOPER-L1	.ȋCK FOR ERRBNE	Lضa"]ًS.
		(UR0-L1.)0Bfϭ	R1,PUTR1-L1	;ARc FOR NEXT PUT.
	TSTB	FORTRF-L1		;Ch#RM FORTRAN?
	BE"X		;NO-
	MGCS-L1,CMDBUF-L1	;YES-
	BR	2$񢘤u3gfɩ-L1,CMDBUF-L1	;Qiũ CSI POINTER
2$:	CMiӳME-L1,USYME-L1
	BEQ	.+4Bbҥ23
	Sh	INK73	.IFNΟqc	.EOT;4"e
ENDTڟ01=ENDO01-BEGO01
;N*U**OVERLAY #2*****
LOaEOVR-BEGO02		;COMPUTE OFFSFOM
	"DUN TIPOERLAY AREA
BEGO02:
;JUMP TABPTgTY POINTS
;IN THIS OiLY.
;
	JMP	START2		;ENTRY1
	.ENDC񢝍;	RESET-CLOSE &̋ASE ALL OPAFILES	I5"ADATA qjSNƊTART2BjS2gCf2	;IS KB INITED?Q	RESE06		;NO-
	.RLSE	#INCMD		;RELiAKB
	.RLSE	#OUTsb	;RELEASE T"ХINTER
RESE06:	TST	OBJDEV-L2		riRD$ΓTED?
	BEQ	RESEDwNO-
	IOIC
RESE01:		GMAPDEV,R0
	TSTB	MAPOPF-LBDS MAPE?
	BDҋSE02	.O[񢄮LOSE	Lw1iLOSE 3 "E
RESE02:	TST	@R0		riT INITED?
	BEQ	RESEĉwNO-
	.RLSE	R0
RESE03:	MODDEV	TSTB3'ğPF-L2		;IS LOD DEV OPEN?
	BEQ4ӋwNO-
	.CLOSE	R0		;YEka̟SE AND RELEASE IT
	.DELET	R0,#LODAELETE LOAD MODUPFLE
RESE0ԧT	@R0"]ɧj NITEDE	DҋSE05	.O[񢄮≥0		;YES-
RESE0ԧTB	STBOPF-L2	;IS STB DEV OPEN?
	BE"iEE08		;NO-
	.CLGSTBDEV		;YÙOSE AND RELEASE
RESE08:	TST	SE0RESE07
	.RLSE	tBEV
RESE07:	MOV	#STCRa	;GET START OF AREA TO BEERED
)	LR	(R
U;CLEAH$A3&	CMP	L#NDCLR	;ONE҉j0O1$		;A TIME
	MűT-L2,STBDEV+2-L2
	MċV-L2,STBDEV+6-L2
	MOV	FIf2YSTBADKf2Bfϭ3[L2,STBADR+2-L2
;
;	INITIALIZ%ųS҉ ԃ SETNƊgI	#INCMD
;
;	INITIALIZE fE4"5 ET
;񢄮NIT	#OUTCMD
;
	.RSTRT	#gK	;RESTART
;
;	PRINFw
	MOQ̝KNM,RE	4";
;	u ҩ PASSFwIK66:
	JMP	LINKe񢄮ӢFNOSEG񢆊NDO02CESS2{ENDO02-BEG;
;*****OiL(U****
L3=BEGOVR-BEGO03		;sЫTE OFAFROM
				tATIME OVERLAY AREA
BEGO03:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	STRT31		;ENTRY1
	JMP	STRT32		;ENTRY2
	.ENDC
;
; PROCESS OUTPUT SPECIFICATIONS AND SET MONITOR TOP.
;
STRT31:	.MONF
	MOV	(SP)+,MONTOP-L3	;INITIALIZE AT CURRENT SIZE
	MOV	CMDBUF-L3,BLKO-L3
	MOV	#2,@CMDBUF-L3	;PREPARE FOR OUTPUT FIELD
	.CSI2	#BLKO		;GET FIRST OUTPUT FIELD
	.IF NDF	RSX
	MOV	#LODADR,R0	;ADDRESS OF FILE NAME BLOCK
	MOV	#NAME,R1	;ADDRESS OF ASCII STRING STORAGE
	UNPACK			;CONVERT IT TO ASCII
	MOV	#LODADR,R0	;ADDRESS OF FILE NAME
	TST	(R0)+		;IGNORE
	BEQ	1$		;BLANK NAME
	TST	(R0)+
	TST	@R0		;IS THE EXTENSION NULL??
	BNE	1$		;NO
	MOV	#.-.,@R0	;MOVE IN THE PROPER EXTENSION
.=.-2
	.RAD50	/LDA/		;EXTENSION IS LDA
1$:	INC	R1		;SKIP OVER "."
	UNPACK			;UNPACK THE EXTENSION
	MOVB	#' ,R0
	MOVB	R0,-(R1)	;CLEAR
	MOVB	R0,-(R1)	;POTENTIAL
	MOVB	R0,-(R1)	;TRASH
	.ENDC
	TST	LODDEV+6-L3
	BNE	2$
	INCB	NOOUTP-L3
2$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	3$		;NO-
	INCB	BIT2F-L3	;YES-
3$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	4$		;NO-
	ERR19			;YES-
4$:	ASR	(SP)+
	BCS	LINK86		;ODD=>NO MAP FOLLOWS
	MOV	CMDBUF-L3,BLKM-L3	; GET MAP FILE
	.CSI2	#BLKM
	TSTB	MAPDEV+6-L3
	BEQ	5$
	INCB	MAPF-L3		;SET MAP FLAG
5$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	6$		;NO-
	INCB	BIT2F-L3	;YES-
6$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	7$		;NO-
	ERR19			;YES-
7$:	ASR	(SP)+
	BCS	LINK86
	MOV	CMDBUF-L3,BLKS-L3
	.CSI2	#BLKS
	TST	STBDEV+6-L3	;SYMBOL TABLE TO BE OUTPUT?
	BEQ	8$		;NO-
	INCB	SYMTAB-L3	;YES-
8$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	9$		;NO-
	INCB	BIT2F-L3	;YES-
9$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	10$		;NO-
	ERR19			;YES-
10$:	ASR	(SP)+
	BCS	LNK157
	ERR20
LINK86:	TSTB	NOOUTP-L3
	BEQ	.+12
	CLRB	NOOUTP-L3
	INCB	NOONOM-L3
LNK157:	TSTB	NOONOM-L3
	BEQ	.+12
	CLRB	NOONOM-L3
	INCB	NOMMS-L3
	CLR	@CMDBUF-L3
	MOV	CMDBUF-L3,BLKI-L3
	.CSI2	#BLKI
	TST	OBJDEV+6-L3
	BNE	LNK136
	ASR	(SP)+
	BCS	LNK135
	ERR17
LNK135:	TSTB	NOMMS-L3
	BEQ	.+6
	JMP	LNK145-L3
	ERR02
LNK136:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	1$		;NO-
	INCB	BIT2F-L3	;YES-
1$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	2$		;NO-
	ERR19			;YES-
2$:	TST	LODDEV+6-L3
	BEQ	LINK35
	MOV	#LODADR,R0
	TST	(R0)
	BNE	LINK35
	MOV	#OBJADR,R1
	MOV	(R1)+,(R0)+
	MOV	(R1),(R0)
LINK35:	JMP	LNK128-L3
;
; OBTAIN ADR OF HIGHEST WORD IN CORE
;
STRT32:	.CORE
	MOV	#ALODSZ,-(SP)
	SUB	(SP)+,(SP)
	ADD	#2,(SP)
	MOV	(SP)+,TOPMEM-L3
	JMP	LINK84-L3
	.IFNDF	NOSEG
ENDO03:
SIZO03=ENDO03-BEGO03
;
;*****OVERLAY #4*****
L4=BEGOVR-BEGO04		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO04:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	LINK13		;ENTRY1
	.ENDC
LINK13:
	.IFDF	RSX
	INCB	FLAG-L4
	MOVTAB
	CLRB	FLAG-L4
	.ENDC
	MOV	SYME-L4,R0	;GET BEGINNING OF UNDEFINES
	MOV	R0,SSYME-L4	;SAVE FOR PMAP
LINK27:	CMP	R0,USYME-L4	;ANY UNDEFINES LEFT?
	BHIS	LNK112		;NO-GO SEE ABOUT MAP.
	.IFNDF	RSX
	CMP	#DOTBLK,NAME2(R0) ;IS 2ND WORD ".  "?
	BEQ	LNK111		;YES-GO CHANGE ".  " INTO "   "
	BIT	#MONCND,FLAGS(R0) ;MONCND FLAG SET?
	BEQ	LNK130		;NO-
	TST	BASE(R0)	;YES-EMT FILLED IN?
	BNE	LNK116		;YES-
	BIC	#MONCND,FLAGS(R0) ;NO-
	MOV	#DOTBLK,NAME2(R0)
	BR	LNK130
	.ENDC
LNK130:	BIC	#ABSREL,FLAGS(R0)	;NO-MAKE ABSOLUTE
	BIS	#UNDEF+INTGLB,FLAGS(R0)	;MAKE DEFINED & GLOBAL
	MOVB	#SYMN,FLAGS+1(R0)	;MAKE IT A SYMBOL DEFINITION
	CLR	VALR(R0)
	CLR	BASE(R0)
LNK116:	ADD	#BPSYM,R0		;UPDATE R0 TO NEXT SYMBOL
	BR	LINK27
	.IFNDF	RSX
LNK111:	MOV	#BLANKS,NAME2(R0) ;CHANGE ".  " INTO "   "
	BIS	#MONCND,FLAGS(R0) ;FLAGS ENTRY: MON ROUTINE CAND
	CLR	BASE(R0)	;CLEAR SPACE OF EMT
	BR	LNK116
	.ENDC
LNK112:
	.IFNDF	RSX
	TSTB	SECTIM-L4
	BNE	LNK131
	INCB	MONLIB-L4	;IN MON LIB SEARCH
	JMP	LINK80-L4	;CHECK FOR ROOM FOR COM ST
LNK131:	CLRB	SECTIM-L4
	.ENDC
;	INITIALIZE FOR PASS 2
	CMP	SYMC-L4,SYME-L4	;ANY SYMBOLS?
	BNE	.+6		;YES
	JMP	LINK-L4		;NO, RESTART!
	MOVB	#1,TMP1-L4		;SET ADDRESS REPEAT FLAG
	MOV	TOPMEM-L4,CURPC-L4	;GET TOP OF MEMORY INTO CURRENT
;	ASSIGN ADDRESSES, CALCULATE TOTAL SIZE, KEEP LOWEST ADDRESS LOADED.
LINK63:	CLR	PRSIZE-L4	;0 TO PROGRAM SIZE
	.IFDF	RTH		;BRTH2
	TSTB	RTF-L4		;RTH?
	BEQ	LNK182		;NO-
	MOV	SS-L4,PRSIZE-L4	;YES-
	ADD	#2,PRSIZE-L4
	TSTB	TMP1-L4
	BEQ	LNK184
	SUB	SS-L4,CURPC-L4
	SUB	#2,CURPC-L4
	BR	LNK182
LNK184:	ADD	SS-L4,CURPC-L4
	ADD	#2,CURPC-L4
	.ENDC			;ERTH2
LNK182:	MOV	SYMC-L4,R0	;SET PTR TO FIRST MODULE NAME.
	MOV	R0,PTRG-L4
	BR	LINK17
LINK16:	ADD	#BPSYM,R0	;MOVE TO NEXT ENTRY
LINK17:	CMP	R0,SYME-L4	;DONE?
	BHIS	LINK18		;YES-GET OUT

	MOVB	FLAGS+1(R0),R1	;GET FLAG TO HIGH BYTE (ENTRY TYPE)
	MOVB	FLAGS(R0),R2	;GET FLAG LOW BYTE
	CMPB	#OBJMN,R1	;OBJ-MODULE NAME?
	BEQ	LINK16		;YES-IGNORE
LNK170:	CMPB	#SYMN,R1	;SYMBOL ENTRY?
	BEQ	LINK19		;YES-GO
	CMPB	#SECTN,R1	;SECTION NAME?
	BEQ	LINK20		;YES-GO
	CMPB	#LOCAL,R1	;LOCAL SECTION NAME?
	BEQ	LINK20		;YES-GO
	BR	LINK16		;IGNORE ALL OTHER THINGS.
;
;	ENTRY POINT
LINK19:	BITB	#ABSREL,R2	;ABS OR REL?
	BEQ	LINK33		;ABS
	MOV	PTSECT-L4,R3
	MOV	BASE(R3),BASE(R0)	;GET SECTION BASE
	ADD	VALR(R0),BASE(R0)	;RELOCATE
	BR	LINK16		;DO NEXT ENTRY
LINK33:	MOV	VALR(R0),BASE(R0) ;SET ABS VALUE
	BR	L3m񢝍biŇTION fNƊ3a:	BITB	#ABSREL,R2	;ABS ORE	LINlq砓F RELÙR	BAS)0S	;SETӋ ANDBḁ5̥(R0)	tڋ'a¥	LINKLgKe.͟kAR(R0),R3	;GET SECTION SIZE
	MOV	R3,-(SP)	;MAKE SIZE EV4	3
	MOV	(SP)+,R3
	AgD	R3,ɵE-L4	;SUM UP FOH*OAL SIZE
	cD	RTH	.RH3
	sh	(T-L4,R0	;PROCESSING R	BHI	.+6		;NO-
	MOV4)ɵ	w1i)AT RTH SIZE FROMͩ0.ENDC"DRTH3
	TSTB	TMP1-L4	.ATHIS iS TIME?
	BNE	LINK78	.IST
	MOV	CURPC-L4,BAqTRa"]ӋsD[ABASE
	ADD4URPC-L4	;ADJUST!0	INK22
LINK78:	ua	3,CURPC-L4.ĕUST Ph!YASIZE.͟aեPC-L4,BASE(R0)	;SET PiASCTION TO NEW PCEL2u3gR0,PTqa[L4	;SAVE PTR TO$IéION.BaRLINK16		;D'ET ONE.
;S$Η.;

;	IF BOTTOM SET!CULATE NEW TOP AND NSIGN ADDRESSES 1ɝ.
	TSTB	TMP1-L4
	BD̝K183
	.IFҩH		;BRTH4
	TSTBgOi	;RTHƊBEQ	LNK183"]Ο-
	AҩHSIZ-L4,PRSIZE-L4	;Y֍	SUB	U$SZ-L4,CURPC-L4
	.ENDC			;ERTH4
LNK183:	TSTB	BOTF-L4
	BEQ	LINK77		;NO BOTTOM.
0R	BOTF-L4
	SUB	CURPC-L4,TOPMEM-L4	;CALCULATE NEW TOP AS
	ADaOMEM-L4,TOPf4	;  TOP-(CURRENT-BOTTOM)LNK77:	TSTB	TMP1-L4		;DONE+ɇƊBEQ	LINK64		;YES
	C	MP1-L4
	MOV	TOPMEM--QtwCALCULATE LOWADR
	SUB	PRrmE[L4,(SP)
	MOV	(SP),CURPC-L4
	.IFDF4H	;BRTH5
	BRTF-L4		;RTH?
	BEQ	LNK185		;NF1"	kf4Y(SP)	;YES-QY)	.ENDC			qiTELK185:	MOV	)W,LOWADR-L4ʛP	LINm;	FIN3$ڋ THE TRANSi DDRESS
;
LINK64:	Cԟb[L4,PRrmE[L4
	BHIS	2gC	BELOW0-L4ԧTB	TR1i"]ɧ THER'΋E	NE	LINK60		;YES
	MOQYTRA-L4	;ASSUME 1
	BBfIK61
LINK60:	TSTB	FTRA-L4"]׃S ONE҇ED?
0ELINK6"DES-
	TSTB4R-L4		sjө WE SiCE	D̓NK30		;NO-
	MOQYR0		;YES- SEARCH
	MOV	#TRABLK+4,R4ӥGLOB
	MOV	R0,RE	OV	R4,TRA-BR	LI1LINl:	GK,R4Biқ'	.ŃRCH FOR MOfEAf	BR	LINK32		;FOUNDBbҥ12			;MODULE NAME MUST BE THERE.
L3e:	MOV	R4,PTRG-L]ӋT PTRG TO uiRNT NAW3g#TRABմYR4
	GETSEbDwq`҇H FOR SECTION NAME.Bbҥ13			;MUST BE THERE.
	ADD	BASE(R4))A[L4	;CALCULATE TPFw  FINALIZE"TATRA
LINK61:	TSTB	SDDTRA-L4	;H5)ŋ'΋?
	BEQ	LINK31	.O[
	MOV	#DDTTRA,R4	;YƓX IT UP
	SRMODN
	BR	.+4ťR12
3gR4,PTQi
	MOQĉ)AW4,R4BcũSEC
	ERR1cE	qTRi),TRADDT-L4
LIٱu	MOV	SYMC-L4,PTRG-L4.ũ PTRG
	MOV	TRA-L4,R0	;PR3 SG--TPVLW ADR,TC
	MOV	#TRAMA,R1
	OTOA
	MOfO1)-4,R0
	.IFDF	RTH		;BU$6	TSTB	RTF-L4		;PROCESSING RTH ?
	QhNK172		;NO-
	Sӧ-L4,R0	;YEk&A{LA-SSӫBQYR0
	gD			;ERTH6S'Kc	OV	#TRAMB,R1
	OTOABfϭ	TOPMEM-L4,R0
	.IFDF	RTH		;BRTH7
5)ԅ	NOIOF-L4	;CREAgGARTH?
	BEQ3'Kc73		;NO-
	MOV	CURPC-L4,R0
	MaAi	;SAVE RTH LOADbD
	ADD	RTHSIZ-L4,R0	vbY HI=HI+RTHSIZE
	.ENDC			qiT7
Lطg:	MOV(RMC,R1ϩFJMP	ELi	.IFNΟqc
ENDO04:
SIZO04=E'i-BEGO04
;
;*****OiLY #5*****
L5=BEGOVR-BEGODwCOMPUPOFSET ԧ				;RUN TIME OVERLAY AREA
BkCE;UMP TABLE TO ENTRY PgT
;IN THIS OVERLAY.
	JMP	START5		;R1
	.ENDC
;
;񢝉ET GSD (GGq;
;	Q`A FF A hEA3 UILDSPSAaL.
;
;
START5BiREG			;SAVE REGISTER
	TSTB	LIBF-L5"]ԋST LIB FLAG
	BDǏSD22		;IN i EARCH
	MOVTAB			;INPUT INIT. AL #E	OV	#INA,IN-L5
+ƉF	BLKIO
	JSR	PC,@#RbI	;INITIATE READ ON INA
	gD
	.IӢFBLKIO񢄮EAD	#DɝA
	.CQӉ26:	Ice3:	BITB	#EOF,-1(R0)	qiRR?
	BNE	GGSDEX		;YEkGT OUT
	CMPB	#STBBLK,(R1).ATHIS u!?	BNE+	;NO-
	JMP	BEGSTB-L5	;YES-GO ËtI.
	CMPB	#GSDBLK,(R1"]ɧ THIS GSD?
	BEQ	.+4		;YES, OK
	ERL	;ERROR IF NOT .	CMPB	#OBSg,o(R1)	ric NTRY  NME?
0	vbY OK
	ERR04			;)Y ERROR.
GGSD01:	BITB	#EOF,-1(R0)	u"ө STATUS FOR ERR	BNE	GGSDEDRROR - EXIT AND IGNORE
	INCB	Bwpg' INPUT CORE LIBh γ MORE
GGSD02:	MOV	(LTYR2	;GET BLOCK TYPE
	SUB	l(0)		;aҋMENT PƊCMPB	qąRe	;GSD"cǧD03		vbBWIDF	RTH		;BRTH8
	TSTBiT-L5		;PROCESSING RTHE	EQ	GGSD29		;NO-
	CMPB	#T!L,R2	;1i[ TEXTE	NE	GGSD04		;NO - GET ANOTHER BBjSB	CSISS-L5	;YES - SSO CSI?
	BNE	GGSDEX		;YES-
	MOV	22(LTS-L5	;NO - EXTR0 S FROM O.ME	OV	SS[);ODD u ×ڋ
	ASBTS*ƊPቋVEN		;EVEN
	INbi[L5		;ODD, MAKE EVEN
EVEN:	TSTB	CSIf5	;NAME FROM CSIE	NE	GGSDEX	.OA-
	MOV	40(R1),NAM2-L5	;YES - *RuNPFOM O.B.
	MOV	4J)1S,NAM1-L5
	BR	GGSDEX"]ǋT OUT.
	.ENDC			;ERTH8
e9:	TS̓BF-L5E	GGS3gօ	TAPEkf5Y-(SP)
	BIpß[V(P)+
	BNE	GGSD0DGNORE GSDEND IF EITH			;  TAPES OR CONCAT ON.ǧD30:	shBqċRe	;GSD END
	BNE	GGSD04		;NO
GEBiEQc	;YESPE5TSTB	LIBF-L5		;TEST LIB Fc0Eċ1		;I"I SEARCH
	IOIC			;CLOSE ORé MODULE FILE
GGSDE1BiT4!GGSD2NԧTB	SBQk"]̓TCH IN LINEE	DǏSD24		;YES - FI*ARg"BdϓG			;-AGET N* 	BR	GGSD2cEGSD24:	CMP(,k
	BNE	GGSD04
	MOV	IN-L5	CMP	)W,(R0)+
	Ma,R1
	TST	(R1)+
	DEC	CNT-L5
	BR	GGSD23
GGSD04:	CMP	#1,CNT-L5
	BNE	GGSD25
	MOV	INSAVE-L5,IN-L5
	CLR	CNT-L5
	CLRB	SBBF-L5
GGSD25:	IOIG
	BR	GGSD01
GGSD03:	SUB	#8.,(R0)	;ANY ENTRY LEFT?
	BLT	GGSD04		;NO - GO GET ANOTHER BLOCK
	MOV	R1,R4		;SET R4 TO THE ENTRY
	ADD	#8.,R1		;MOVE R1 TO NEXT ENTRY.
	MOVB	FLAGS+1(R4),R2	;GET ENTRY TYPE
	CMP	R2,#GSDMAX
	BLE	.+4
	ERR14
	ASL	R2
	JMP	@GGSD05-BEGO05+BEGOVR(R2)	;DISPATCH
GGSD05:	+GGSD06-BEGO05+BEGOVR	;MODULE NAME
	+GGSD07-BEGO05+BEGOVR	;SECTION NAME
	+GGSD03-BEGO05+BEGOVR	;ISD SIZE (IGNORE)
	+GGSD08-BEGO05+BEGOVR	;TRA SPECIFICATION
	+GGSD09-BEGO05+BEGOVR	;SYMBOL
	+GGSD07-BEGO05+BEGOVR	;LOCAL SECTION NAME
	+GGSD32-BEGO05+BEGOVR	;IDENT DIRECTIVE
;
;	MODULE NAME
;
GGSD06:	CLRB	SAMECS-L5
	MOV	R4,R2		;SAVE R4
	SRMODN			;CHECK IF MODULE NAME IS UNIQUE
	BR	GGSD10		;ERROR IF NOT UNIQUE
GGSD31:	MOV	R2,R4
	MOV	SYME-L5,PTRG-L5	;SET PTR TO MODULE NAME
	INSYME			;INSERT AT SYME + UPDATE PTRS
	BR	GGSD03		;DO NEXT ENTRY
GGSD10:	CMP	(R2),MAIN1-L5	;MODULE NAME NOT UNIQUE
	BNE	ASBEF1		;MODULE NAME MAIN.?
	CMP	2(R2),MAIN2-L5
	BNE	ASBEF1		;NO-
	CMP	SYMB-L5,SYMC-L5	;YES - PROCESSING CORE LIBS?
	BEQ	ASBEF1		;NO-
	TSTB	MAINF-L5	;YES - WAS ONE MAIN. SEEN ALREADY?
	BNE	PREPAR		;YES - PRINT ERROR AND ABORT OBJ MOD.
	INCB	MAINF-L5	;NO - MARK FIRST MAIN. WAS SEEN.
	BR	GGSD31		;AND DON'T PRINT ERROR AND CONTINUE
				;PROCESSING OBJECT MODULE.
PREPAR:	CLRB	MAINF-L5
	BR	ASBEF3
ASBEF1:	CMP	(R2),DATA1-L5	;MODULE NAME DATA.?
	BNE	ASBEF3
	CMP	2(R2),DATA2-L5
	BNE	ASBEF3
	CMP	SYMB-L5,SYMC-L5	;PROCESSING CORE LIBS?
	BEQ	ASBEF3
	TSTB	DATAF-L5	;WAS 1 DATA. SEEN ALREADY?
	BNE	1$
	INCB	DATAF-L5
	MOV	R4,-(SP)
	MOV	R2,R4
	SRMODN
	BR	.+4
	ERR25
	MOV	#126423,(R4)
	MOV	(SP)+,R4
	BR	GGSD31
1$:	CLRB	DATAF-L5
ASBEF3:	ERR05			;ERROR-MODULE NAME NOT UNIQUE
	TSTB	CONCAT-L5
	BEQ	GGSD27
GGSD28:	IOIG
	BITB	#EOF,-1(R0)
	BNE	GGSDEX
	CMPB	#MODEND,(R1)
	BEQ	.+4
	BR	GGSD28
	JMP	GGSD26
GGSD27:	JMP	GGSDEX
;
;	SECTION NAME
;
GGSD07:	MOV	R4,R2		;GIND THE GLOBAL + GET
	PTGLOB			;PTR (R4) TO IT.
	BR	GGSD11		;NOT FOUND, GO INSERT IT.
	BITB	#UNDEF,FLAGS(R4) ;IS IT DEFINED
	BNE	GGSD12		;YES
	SQUISH			;NO - REMOVE THE UNDEFINED SYMBOL
	SUB	#BPSYM,USYME-L5
GGSD11:	MOV	R2,R4		;INSERT AT SYME-L5 AND UPDATE PTRS.
	MOV	SYME-L5,PTRH-L5
	INSYME
	BR	GGSD14
GGSD12:	CMPB	FLAGS+1(R4),#SECTN ;IS IT A SECTION NAME?
	BEQ	GGSD33
	CMPB	FLAGS+1(R4),#LOCAL	;LOCAL SECTION NAME?
	BNE	GGSD13		;NO - ERROR - MULT DEFINITION.
GGSD33:	TSTB	SCOUNT-L5	;READ AT LEAST 1 SYMTAB?
	BEQ	LNK163		;NO-
	TSTB	NSTBF-L5	;YES-FINISHED READING SYMTABS?
	BEQ	LNK163		;NO-
	INCB	SAMECS-L5	;YES-SET FLAG TO AID IN
				;CHECKING FOR EXTRA ENTRIES
LNK163:	CMPB	FLAGS+1(R4),#LOCAL
	BEQ	GGSD11
	MOV	R4,PTRH-L5
	CMP	VALR(R4),VALR(R2) ;WHICH SIZE IS BIGGEST
	BHIS	GGSD14
	TSTB	SAMECS-L5
	BEQ	.+8.
	CMP	R4,SYMC-L5
	BLO	.+10.
	MOV	VALR(R2),VALR(R4) ;GET BIGGEST SIZE.
	BR	GGSD14
	ERR26			;W323,CSECT SIZE TOO LARGE
LNK193:	BR	GGSD14		;GO DO NEXT ENTRY

;
;	TRA SPECIFICATION
;
GGSD08:	TSTB	DDTF-L5		;IS THIS THE DEBUG FILE?
	BEQ	GGSD20		;NO-
	INCB	SDDTRA-L5
	MOV	#DDTTRA,R2
	BR	GGSD21
GGSD20:	TSTB	UTRA-L5		;SHOULD WE USE THIS ONE?
	BEQ	GGSD18
	CLRB	UTRA-L5
	INCB	TRAF-L5
	BR	GGSD19
GGSD18:	TSTB	TRAF-L5		;IS THERE ONE ALREADY?
	BNE	GGSD14		;YES, GET OUT
GGSD19:	MOV	#TRABLK,R2
;	GET CURRENT OBJ MODULE NAME
GGSD21:	MOV	PTRG-L5,R3
	MOV	(R3)+,(R2)+
	MOV	(R3),(R2)+
;	GET TRA SPEC
	MOV	(R4)+,(R2)+	;SECTION NAME
	MOV	(R4)+,(R2)+
	TST	(R4)+		;SKIP FLAGS
	MOV	(R4)+,(R2)+	;CONSTANT
	MOVB	DDTF-L5,-(SP)	;IS THIS THE DDT TRA?
	CLRB	DDTF-L5
	TSTB	(SP)+
	BNE	GGSD14		;YES-DO NOT TEST FOR ODD VALUE
	BIT	#1,-(R2)	;IS IT ODD
	BNE	GGSD14		;YES - IGNORE
	INCB	TRAF-L5		;NO - SET FLAG
GGSD14:	JMP	GGSD03

;
;	SYMBOL DEFINITION
;

GGSD09:	MOV	R4,R2		;SAVE R4
	BITB	#UNDEF,FLAGS(R2) ;REF OR DEF?
	BEQ	GGSD15		;REF
	PTGLOB			;SEARCH FOR IT AND SET R4
	BR	GGSD16		;NOT FOUND
	BITB	#UNDEF,FLAGS(R4) ;FOUND, IS IT DEFINED
	BNE	GGSD13		;YES - ERROR
	SQUISH
	SUB	#BPSYM,USYME-L5
GGSD16:	TSTB	SAMECS-L5
	BEQ	.+8.
	CMP	PTRH-L5,SYMC-L5
	BLO	.+8.
	MOV	R2,R4
	INPTRH
	BR	GGSD14
	ERR06			;W342,TOO MANY ENTRIES IN CSECT
	BR	GGSD14
;
;	MULTIPLY DEFINED SYMBOL--BROADCAST IT
;
GGSD13:	MOV	R0,CONVER-L5	;SAVE R0,R1
	MOV	PTRG-L5,R0	;MOVE ADR OF MOD NAME TO R0
	CMP	(R0),MAIN1-L5	;IS IT MAIN.?
	BNE	ASBEF2		;NO-
	CMP	2(R0),MAIN2-L5
	BNE	ASBEF2		;NO-
	CMP	SYMB-L5,SYMC-L5	;YES - PROCESSING CORE LIBS?
	BEQ	ASBEF2		;NO-
	CMP	(R4),MAIN1-L5	;YES - IS GLOBAL MAIN.?
	BNE	ASBEF2		;NO-
	CMP	2(R4),MAIN2-L5
	BNE	ASBEF2		;NO-
	CMP	MAINF-L5,#1	;1ST MAIN. GLOBL?
	BNE	ASBEF2		;NO-
	INCB	MAINF-L5	;YES-MARK IT: MAINF=2
	MOV	#126423,(R4)	;GLOB NAME IN COR LIB STB =$$$N.
	MOV	R0,R4
	SRMODN
	BR	.+4
	ERR25
	MOV	#126423,(R4)	;MOD NAME IN COR LIB STB =$$$N.
	MOV	CONVER-L5,R0
	BR	GGSD16		;INSERT MAIN. GLOBAL INTO SYM TAB
	BR	NOMES		;YES - DON'T PRINT MESSAGE.

ASBEF2:	MOV	R1,-(SP)
	MOV	#MULMSA,R1	;ADR OF ASCII CHAR
	MOV	R4,R0		;ADR OF MOD40#
	UNPACK
	MOV	#MULMSB,R1	;MODULE NAME
	MOV	PTRG-L5,R0

5gPrƊ	QSP)+,LDO)1]
	MOV	#MULMSG,R0

	TYPE	c302,R]ß^g02
Bḁ	-(SP#E	OV	R0TS)
	Ibu	MOV	sVKf5YLBR	GGqNƊw4ƋQgC TO A GLOBAL
;
GGSD15:	PTGLOB
	BR	GGSD17		;NOT THEREPIqiTAIT.
	BR	GGSD14		;IF$EINOREQӉ17:	MOV	R2,R4
2gUYM			;INSEUA UNDEgE SYMBTǏSD14
;
;	IDENT DIRIE
;
;	PLACE BLOCK .gTA1E$EAS'× OF THE CORRESPIE;.TITL$ATHE SYMBOL TABLE
;QӉ32:	S5E
	MOV	R4,-(SP)	;SAV)4ATHE POINTER TO ENNTR#E	"]ɝƍER
	CMP	P5,SYMC-L5	;1ST bEƊBNE	1$		;NO-
		QSP),R0		;YDRESS NPUT 3Ra͟V	#ID,R1		;ADDRESS O'թj N R1
	UNPACK
)	u!	k		; .1"Ω INTO SYMTAB?
0IwYES-Ba͡	PTRG-L5,S3a5	;1ST .ID?BaE	2$		;YES-
	TST	(SP*ĉwNO-POP R4 OFF STACKBaR3$
2$:	MOV	PTRf5YR4	;YES-OBTAIN POINTT CURRENT
"DwOBJECT MODULE N3b0bD#BPSY)4;MAKE R4 PgTAAFTERj	UNSQUISH		;MAKE A H"HERE MPINTS
				;NOTE-R4 STILL CONTAINS ADDRESS OF
				;BEGINNING OF HOLE IN SYMBOL T0E	MOV	(SP)+,R3	;SET INTO R3 THE POINTER TO THE
				;ENTRY I)ED BUFFER
3g(R3)+,(R4)+	;MOVE BLOCK OIENT
	MOV	(R3)+,(R4)+	;AFi AOF .TITLE
	MOV	(R3)kRi)+
	MOV	(R3)+,(R4)+Q¡SYM,SYME-L5	;UPDATE SYMTAH(ONTERS
	ADD	#BPSYM,USYME-L5
3$:	REt	JMP	GGSDƊ.IFNDF	NOSEG
	.EOT
;TAPE 3ΉTڟ05=ENDO05-QcaE;N*U**OVERLAY m*UJ6=BEGOVR-Bm		;COMPUTEFET FRF			;RTME OVERLAYiE
BEGO06:
;JUMP TABPTgTY POI);IN THIS OiL+w
	JMP	STAU	;ENTR,FgD
;
bfIPiYASEARCHING ROUTINE
;񢝉NITIALIZATION
;
;NҋGISTER ASSIGNMENTS
;
;	AREGISiSAARE AtÓATED jHAA LIBRARY iETORYNωD REG4Eh ҋiӟCIATED WITH A S3aO TABLE.
;	R0	DIRECTORY POINTER
;	LDӳMBOL TABLE POINi;	R2	SIZE DRECTOVPSGMENT񢝉biɵ'ASYMBO*AFw4	URRENT DIRO()ٛBOL
;	R5	CURRENT UNcIED FROM SYMBOL TABLE
;
START6:	MOiԅC-L6,R3	;GET SY ABC
	BEQ	O;NO U"Ɠb LOBALh$ASYMT
	MOV4B-L6	;SAVE SYMTAB BCBfϭ	FDATA-L6,R0	;GET PTR TO 1ST DATA If	MOV	BC-L6,R2	;j IR BC
	ADQYR2
	MOV	SYME-L6,R1	;SET UP SY A)3g(R0)+,R4	;GET N* IRECTORY SYMBOL
	MOTRc)+,R5	;GET NEXT UNDEFINEDg YMBOL E
	.1FOLDLUcE	]1D	RSXBjSB	MONLIB-LE	DԧgD	.ENDC
	.ENDCϛP1:	CMP	R4,R5		;COMP4YMTAB SYMBOL TO DIRECTORY񢄉	;SYMS	BEQ	jC1		;IF SYMBOLS MATCH GO TO 2ND͡񢆊w
;	MISMATCH
;	ATThTATO INCREMENT INDEX OF SYMBOL TABLENƊISM1:	TST	(SP)	.OP
TRYINC:0bD#12,RbDEENT S3aO TABLE COUSNCTAB		;IF MORE SYMB)N SYMTAB GO TO
				;INCREMENT INDEE;;	REACHED THE  F THE UNDEgES IN SYMBOL TABLE
;
	.IFNDF	T5)ԅ3gΙIB-L6
	BNE	INC؍	.ENDC
	ADD	#10,R2	.·REMENT DIRECTORY COUNT
OBR	OUUT5:	Sh	INI
+ƝҧX
INsau񢄮FNDF	"LcE	DD	#2,R2
	.ENDC
	.1FOLDLUK
	ADD	#16,R2BWEDC
	.ENDC
OUT6:	BGE	FIN"DINISHI NO MYMBOLS IN DIRECTORY
;
;	DID  aATHE END OF THE DIRECY;
	.IFNDF	RSX
	TSTB	MONLIB-L6
	SNCE1
	.ENDC
	1"	G6,R0		;POIT NEXT$AR
	BR3e񢄮FNDF	T3cCE	]IFNDF	OLDLUK
	3NDEX-L6	;UPDATE MRT TABLE INDEX
	.C	.IFDF	OLDLUKB`ĉ	#14,R0
	gD
	.ENDC
OUT2:	MOV	(R0)+,R4	;j * 4éORY SYMBOL
;	RAT UNDEFINEDS IN SYMBTBLE
	MOV	SVSTBC-L6,R3	;RASYMBO*ALE SIQPCUNT
3gvf[L6,R1.EԓON TH(O"AIN R1 TO
				;THE BΝING OF THE SYMBOL TAS"	MOV	(R1)+,R5	;GET NEXT U"ƓNED I)ٛBOL T0E	BR	COMP1		;GO TO COMPARE FIRuUcIED
				;IN SYMBOL T0E;	INDEX UNDEFINEDS IN SYMBOL TABLE񢝍INCTAB:	ADD	#10;POINT TO lTASYMTAH"ΩVFMOV	(LTYMFBR	COq砩!ϛPARE FIRST UNDEgE
MATCH1:
	.IFNDF	OLDLUK
	TSTB	MI-L6	;1ST PARTS jCED
	BEQ	Ch2	MOV	(R1)+,R5
	TST	R5
	BEQ	jCCE	BfɧM2
	.ENDC
COM	OV	(R0)+,R4	;PREPAREA2ND MATCHING
	MOV	(R1)+,MFCMP	R)5	BEQ3`ԇH2		;S 4SAMATCHie:				sSdӛ3:		
TRYIN2:	ADD	#1K)3	;TRY INCR SYMTAB CO	BNE	INCT2		;SYMTAB ENDEDE	]IFNDF4	TSTBfϝLIB-L6
	BNE	INCM2
	.ENDC
	Ac)2	;YES-TRY INCR DIR CgT	BR	OUT3
	.IFNDF	RSX
INCM2:
	.IӢFOLDLUK
	ADD	#2	.ENDC
	.1FOLDLUcE	c6,R2BWEƊ.ENDCթncII		;DIR ENDED?BWINDF	RSX
	TSTB	MONLIB-L6
	BNE	INCECE	]ENDC
	ADD	#4,RDO- GET NEX"I ENTRY
	BR	OUT4
	.IFNDF	RSXRgCNcNF	OLDLUK
	INC	3E-L6	;UPDATE MRT TABL$ΉEX
	.ENDC
	.IFDF	OLDLUKD	#12	.ENDcE	]ENDCSiBfϭ	(R0)k)4	MOV	SVSTPmwQiԃRT UNDEFINES
		YME-L6,R1	;IN SYMTAB͟V	(R1)+,R5
	BR	COMP1
INu:ADD	#)1.OT NEXT SYMTAB ENTRY
	MOV	(R1)+wvfԃH"I NOT  TSTB	MONLIB-L6	;MONITOR SiCaϛP1		;1iAENTRY IS CORRECT
	CMP	-(L[(R0)	;RESTART DIR ENө PART͟V	(R0*Ri.ASYMBO(AR
	BBaϛF			;IN SYMBOL T0ENƊw4ͅOLS M5!ȋD
;C&r:	.IFNDF	RvTSTB	MONLIKf6BaN	MONLT3
	.ENDC
	MOVB	(R
UBYTE-BITB	#10,LVjE[L6
	BEQ	INTERM		;UNDEF
	MOVB	(R0)+,HBYTE-L6	;DEFINED
	CMPB	#1,HBYTE-L6	;IS IT A SECTION,OR A SYMBOL?
	BEQ	MATCH3		;MATCHED A SECTION NAME
	CMPB	#4,HBYTE-L6	;MATCHED A SYMBOL
	BEQ	MATCH3
	TST	-(R0)
	BR	MISM3
	.IFNDF	RSX
MONLT3:	BITB	#1,(R1)
	BNE	MONMAT
	BR	MISM3
	.ENDC
INTERM:	TSTB	-(R0)
	BR	MISM3
	.IFNDF	RSX
MONMAT:
	.IFNDF	OLDLUK
	MOV	INDEX-L6,4(R1)
	SUB	#2,4(R1)	;MAKE THE EMT VALUE CORRECT
	.ENDC
	.IFDF	OLDLUK
	CMP	6(R0),4(R1)
	.ENDC
	CMP	-(R1),-(R1)
	BR	INCM2
	.ENDC
MATCH3:	MOV	#1,DIRSRV-L6
	BR	FINI1
	.IFDF	OLDLUK
	.IFNDF	RSX
TSTEND:	TST	R4
	BEQ	FINI
	JMP	COMP1
	.ENDC
	.ENDC
FINI:	MOV	#0,DIRSRV-L6
FINI1:	RTS	PC
	.IFNDF	NOSEG

ENDO06:
SIZO06=ENDO06-BEGO06
;
;*****OVERLAY #7*****
L7=BEGOVR-BEGO07		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO07:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START7		;ENTRY1
	JMP	PMAP10		;ENTRY2
	.ENDC

;
;	SUBROUTINE TO PRINT THE LOAD MAP (PMAP)
;
;	OUTPUT TO MAPSL
;	INIT MAPSL TO DEVICE CODE IN MAPDEV
;
;	SET POINTERS TO SYMBOL TABLE
START7:	SAVREG
	MOV	SP,SSP-L7	;SAVE SP
	MOV	SYMB-L7,R2	;BEGINNING OF TABLE
;
;	INITIALIZE MAP OUTPUT DEVICE
;
	MOV	#ERRET3-BEGO07+BEGOVR,MAPADR-4-L7	;SET UP
						;ERROR RETURN
	.INIT	#MAPDEV		;INIT THE DATA SET
	TST	MAPADR+4-L7
	BNE	.+10
	MOV	#0,MAPADR+4-L7
	.=.-4
	.RAD50	/MAP/
	.=.+2
	.DELET	#MAPDEV,#MAPADR
ERRET3:	CLR	MAPADR-4-L7	;NOW LET MONITOR HANDLE ERRORS
	INCB	MAPOPF-L7	;INDICATE MAP OPEN
	TST	MAPADR+4-L7
	BNE	.+10
	MOV	#0,MAPADR+4-L7	;SET DEFAULT EXTENSION
	.=.-4
	.RAD50	/MAP/
	.=.+2
	.OPEN	#MAPDEV,#MAPADR
	.RSTRT	#PMAP14		;SET UP ABORTING ADDRESS
	.IFNDF	RSX
	.DTCVT	#DATE		;GET TODAY'S DATE
	.TMCVT	#TIME		;AND THE TIME
	MOVB	#' ,R0
	MOV	#DATE,R1
	MOVB	R0,-(R1)
	MOVB	R0,-(R1)
	.ENDC
	MOV	#PMAP86,R0	;PRINT HEAD
	MAPTYP
;
;	CLEAR ID
;
	MOV	#100040,-(SP)
	MOV	(SP),ID-L7
	MOV	(SP),ID-L7+2
	MOV	(SP),ID-L7+4
	MOV	(SP)+,ID-L7+6
	.IFDF	RTH		;BRTH9
	TSTB	RTF-L7		;TYPE RTH IN LOAD MAP ?
	BEQ	.+10		;NO-
	MOV	#RTHB,R0
	MAPTYP
	.ENDC			;ERTH9
;	MSG TRAM IS ALREDY FORMATTED
	MOV	#TRAM,R0
	MAPTYP
	MOV	#4,-(SP)	;SET COUNT FLAG TO NON-GLOBAL
	BR	PMAP01		;GO TO PRINT LOOP
;	UPDATE POINTER AND LOOK FOR END OF TABLE.
PMAP02:	ADD	#BPSYM,R2
PMAP01:	CMP	R2,SSYME-L7	;DONE
	BHIS	PMAP09		;YES - GO DO UNDEFINES
	MOVB	FLAGS+1(R2),R3	;NO - GET ENTRY TYPE
	MOV	#PMAP82+6,R1	;ADR OF OUTPUT BUFFER
	CMP	R3,#PMAX
	BLE	.+4
	ERR14
	ASL	R3
	JMP	@SCMDT-BEGO07+BEGOVR(R3) ;DISPATCH
;
;	TEST FOR & LIST UNDEFINES
;
PMAP09:	JSR	PC,FINLIN	;TERMINATE LAST LINE
	TST	(SP)+		;DISCARD COUNT FLAG
	MOV	SSYME-L7,R0	;ANY UNDEFINES?
	CMP	USYME-L7,R0
	BEQ	PMAPX1		;NO - GET OUT
				;YES - PRINT THE HEADING
;
;	PRINT HEADING
;
	MOV	R0,-(SP)
	MOV	#PMAP80,R0	;PRINT SOME STARS
	MAPTYP
	MAPTYP			;MORE STARS
	MOV	#PMAP84,R0	;"UNDEFINED REFS"
	MAPTYP
	MOV	(SP)+,R0
	CLRB	PMAP11-L7
;
;	PRINT VARIABLES, ONE PER LINE.
;
PMAP16:	BIT	#MONCND,FLAGS(R0)
	BEQ	PMAP10
	ADD	#BPSYM,R0
	CMP	R0,USYME-L7
	BLO	PMAP16
	BR	PMAPX1

PMAP10:	MOV	#PMAP82+6,R1
	UNPACK
	MOVB	#CR,(R1)+
	MOVB	#LF,(R1)+
	MOV	#8.,PMAP82+4-L7	;SET BC
	MOV	R0,-(SP)
	MOV	#PMAP82,R0
	TSTB	PMAP11-L7
	BEQ	PMAP12
	TYPE
	BR	PMAP13
PMAP12:	MAPTYP
PMAP13:	MOV	(SP)+,R0
	ADD	#BPSYM,R0	;UPDATE PTR TO NEXT SYMBOL
	CMP	R0,USYME-L7	;DONE?
	BLO	PMAP16		;NO - DO IT AGAIN
;	DONE
PMAPX1:	.RSTRT	#LINK
	RESREG			;RESTORE REGISTERS
;
;	CLOSE MAP FILE
;
	TSTB	PMAP11-L7	;DO NOT CLOSE IF
	BNE	PMAP15		;LISTING UNDEFINES
	CLRB	MAPOPF-L7	;CLEAR MAP DEV OPEN FLAG
	.CLOSE	#MAPDEV
;
;	RELEASE MAP DATA SET
;
	.RLSE	#MAPDEV
PMAP15:	RTS	PC		;EXIT
;	SCMDT--SYMBOL TABLE ENTRY TYPE DISPATCH TABLE.
;	COMMANDS ARE:  OBJ-MOD NAME, PROG-SECT NAME, INT-SYM NAME,
;		      TRA-SPEC, SYMBOL ENTRY
;
SCMDT:	.WORD	PMAP03-BEGO07+BEGOVR
	.WORD	PMAP04-BEGO07+BEGOVR
	.WORD	PMAP05-BEGO07+BEGOVR
	.WORD	PMAP05-BEGO07+BEGOVR
	.WORD	PMAP06-BEGO07+BEGOVR
	.WORD	PMAP04-BEGO07+BEGOVR
;	CNTRL-C RETURN SEEN DURING MAP
;		ABORT IT.
;
PMAP14:	MOV	SSP-L7,SP	;RESTORE SP
	BR	PMAPX1		;GET OUT
;
;	OBJ-MOD NAME
PMAP03:	JSR	PC,FINLIN	;FINISH LAST LINE
	MOV	#PMAP80,R0	;PRINT STARS
	MAPTYP
;MOVE IN "MODULE"
	MOV	#"MO,(R1)+
	MOV	#"DU,(R1)+
	MOV	#"LE,(R1)+
	MOVB	#TAB,(R1)+	;PUT TAB IN BUFFER
	MOV	R2,R0		;R0=ADR OF NAME
	UNPACK			;DO MOD40 UNPACK
;
;	IF .IDENT IS SPECIFIED THEN INSERT .IDENT
;	AFTER THE OBJECT MODULE NAME IN LOAD MAP
;
	ADD	#BPSYM,R2	;ADVANCE POINTER TEMPORARILY
				;TO NEXT ENTRY AFTER NAME
	MOVB	FLAGS+1(R2),HBYTE-L7
	CMPB	HBYTE-L7,#6	;IS NEXT ENTRY .IDENT?
	BNE	1$		;NO-
	MOVB	#TAB,(R1)+	;YES-INSERT .IDENT
	MOV	R2,R0		;R0=ADR OF NAME
	UNPACK
	BR	PMAP07
1$:	SUB	#BPSYM,R2	;RETRACT POINTER TO NAME
PMAP07:	CMP	(SP),#4		;ARE WE IN NON GLOBAL MODE?
	BEQ	3$		;YES, DO NORMAL ENDING
	CMP	(SP),#2		;HAS THE LINE OVERFLOWED?
	BGE	1$		;YES
	INC	(SP)		;ADVANCE COUNT
	MOVB	#TAB,(R1)+
	MOVB	#VT,(R1)+	;STORE VERTICAL TAB
	BR	2$
1$:	CLR	(SP)
3$:	MOVB	#CR,(R1)+	;PUT IN CR
	MOVB	#LF,(R1)+	;   AND LF
2$:	MOV	#PMAP82,R0	;
	SUB	#PMAP82+6,R1	;GET THE BYTE COUNT
	MOV	R1,PMAP82+4-L7	;SAVE I ׃#E	4*Y
;PR3 )AA`ēNG IF OBJ-MODULE
	CMP	SC*-o+BEGOԔRg+ЛAP03-Qca7+BEG	BNE	,R	MOV	t&Ra
	MA,LXu2PMAP0BD#Ogҋ񢝍;	PROG-SECTION NAME
;
PMAP04:	JSR	PC,FINLIN	;TERMINAT(Rgէ LINE IF NECESSARY
3gօ(AG,(R1*ĻAMOV IN "<"
	MOi2YR0
	UNPACbDwMOD40gPCK
3gօ(AG,(R1)+
	CMPB	FLAGSlTRe),#LOCAL
	BNE	PMAP1E		GRc*Ɗh1o:	MOVB	#TAB,(R1*Ɗ	ASE(RJVRa	;GET BASE VALUE INT)0	OTO"DwOCTAL TO ASCII CONVETϝ
	MOVB	#TAB,(R1)+	;3ť 0	ALR(R2),R0.ũ SIZE
	OTOA			q'ESION
	BR	PMAP0E;
;	INTERf YMBOLh Ή TRA 4"ǃL
PMAP05:	JSR	PC,FI$Bbҥ07
;
;	ENTRY vfE;T&06:	CP),#4		;NON GLOPf "	BNE,R	;NO
	CLR	)	;YES , CLi PFAG
1$:	MOVB	#TAB,(R*UwINSERT TAB
	MOV	R2,LUNPACK			;MOD40gPCK
	MOVB	#TAB,(R1)+͟V	BASE(R2)	OTOA			;CONVER §*ԋ VALU*OAASCII
	BR4&07
;t"ÓAL LINE TERMINATOR
gLN:	CMY(P),#4	;WAS IT GLOBAL
	BEQ	1$		;YES
	TST	2(SP)
	BEQ	2$
	MOV	#4,2(SP)	;RESET Fc	MOV	#2,DUMIN+4-L7
	MOV	#CRLF,DUMIN+6-L7
	MOV	#DUMIN,R0
3`ЩYP
	CLR	DdW4-L7
	CLR	DUMIN+6-L7
1$BiT	PC
2$:	MOV	#4,2(SP)
	RЇ񢝍
	.IFNDF	NOSEG
ENDSIZO07=ENDO07-BEGO0ENƊw*****OVERLAY #9*****
L9=QcϭR-BEGO09		;COMPUTE OFFSET FROM
			.U TIME OVERlREA
BEGO09:
;JUMP TABLE TO E)YAΩcE;N THIS OVES NƊSh	ONE		;ENTR,FgD
;
;	ALLJAMODULES HAPBEN RE1 ACREAT*R BLOCK
;	TE LOAD MODULE, FOLLOb (*RILER.OE:
	.IFDF4H.RH10
	TSTB3ɟF-L9	pEPRH?
	QhH	;NO-
	SAVREG			;YEcE	OV	#38.,@PUTR0-L9
		G19.,R4
	MOV	PUTR1-L9,R5VҥTH:	C5)+
1"R4
	Q	ERRTH
;
h A     #IL IN U$cE	uQR5)
	TSTB	CSICf9;CALL NO FROM CSI ?
	BEQ	LNK181		;֠SE DEFAULT 
	MÝ-L9,(R5)	;1i	CLRBaӓCN-L9¥3'KcFNK181Bfϭ3'׃s,(R5)	;USE'׃A DEFAULT CN
LNK189:3gNAM1-L9,-2(R5)	;FILL IN NAME
	MOV	f[L9,-4(R5)
	CLPçIN-L9
	MOjR-L9,--Rk"]ƓLL IN)AAADR
	MOV	Kf9Y-16(R5)	;PUT LOW LIM ROG
	MOV	LOWADR-L9,-(SP)	;PREPARE u × LIMIT
	SUB	SSQSP)
	SUB	l(P)
	MOV	(SP)+,-22(R5)	;FILL I)ԃrLj	MOV	PRIOR-L9,-MRk)	;FILL IN PRIORITYBfϭ	MT-L9,-30(R5)	;FILL IN M6TME
		GFIO1,MET PTH*OAS INTO	SRGLOB			trFH#OTRAN INP A PTRBaRLNK191		;NOT FOUND
3gR4,-42(R5)	;FOUND- FILL IELK191:3gSLARTf9Y-44(R5) ;FILL IN LOAD ADDRESS  IOOP
	TSTB	IOOPER-L#E	EQ	.+6
	JMP	LINK25-L9
	MOV	R0,PUTLs
	MOV	R1,PUTR1	RESREG
	gD			;EU$1aOTH:	MЫTR0-L9,R0	qA)' TO OUTPUT BUFFER.
3gPUTR1-L9,R1
	MOV	#2,(R0)		;SET BCBfϭ	TRA-L9,(R1)	;STA
	IOOP		.UP
	TSTB	IOOPER-L9
	BEQ	.+6
2gKef9;
;	CLOSE LOA&ωULE FILE
;
	TST	LO"W6-L9	;ANY LOAD MOD OUTPUTE	EQ	LI5	;NO-E	LRB	L'Ѝ;CLEAH&O"AOPEN  Bfϭ	#LODDEV,-(SP)
	MOV*)S,-(SP)
	EMT	CLOSE
cE;RELEASE LOAD MODULE DATA qj;
	EҋLEASNƊw	CLOSE KEYBOARD FILE
;
LINK]	NCMD,-(SP)
	MOV	(SP+P)
	EMT	CLOSE
;
;	RELEASE KEYBOAQDTA SET
;
	EMT4̋AS
;
;	CATELET4"3";
	M!͉,-(SP#E	
V-QSP)
	EMT	CLOSE񢝍;	RELEASE TELETYPE DATA SET
;
	EMiEEASE

	TSTB	O!9		;LINKIN'֋RLAYS?
	BLE	1$		;NO-
	TSTB	O#-"DבAT SECTION?
	BDI
	CLRB	OVLF-L9		;RErbET-CLEAR FLAG
	MOV	SYMB-L+)ӳMB-L9.E RES1"Ω
;		"D3aO TABLE	ӳME-L9ӳVs	;POINTERS
	MOV	LOW1)-9,-(SP)	;SAVE RES LObR[2,
	MOV	(SP),OVLTOP-L9
0	i$
3$Bfϭ	OVLTs,-(SP)	;OVERLAYS
4$:	SUB	#2,(tu$EADEFAULT TOP OF MEM
3g(SP)+,@SASYME-L9	;FOR THE OVERLAYSLR:TSTB	GOF-L9		;EaթE LOAD MODE	EQ	2$"]ΟE	]IFNDF3ӋE	OV	#OԦBY)S.EEASE OVERLAY DAiũ
	EMT	RELEAS
	.ENDC
	MOV	#RUNBLKTS)	;YES-ISSUE GE"ͩ
	EMT	GET$u	JMP	LINK-L9		;RESTART LINKERBWI#	
ENDO09:
SIZNDO09-BEGO09

	.E!	.ENDC			;END OF OVRBLD
+ƝDF	NOqc
	.té
;BEgNO OVERlQ`;THE rmEATE OVERLAY AREA IS DEiMNED
;BY THE SYMBOL SRIZ"
;
BEGOVR:
;THE BEG3IG REG4ES OF a;OVERLAY CONTAIN JMP'S TO THEŝOINTS OF THE OVERLAY񢆊NTRY1=.
ENTRY2=.+4
ENTRY3=.+10
E)Yi=.+14
ENTRY5=.lENTRY6=.+2EETRY7=ٰQgTY8=.+m)Ys=.+40񢄮!񢄮FDF	OVRBLD		;B3E	]IFNDF NOSEG
;
;*****OVERLAY #8***J8=BEGOVR-BEGO08"]ßMPUTE OFFSFOM
				;RUN TIME OVERLAY AREAE:NUP TABLE TO ENTR((ONTS
;IN THIS OVERLA+w
	JMP	START8		;ENTRY1
	gD
;
bhRCESSIFR PASlwԃRT8:	BLIBF-L8
	S3BdϓI			;INPUT INIT)ũ R0,R1 TO BUFFER.
L5u	CLR	GENDF-L8	;NO GSD ENDŝ.
LI۶u0ԅ(ύ,-1(R0)	;ERROR?
	BEQ	.+6
	JMfImYvbYIGNOR$ΡCMPB	#GSDBLK,(R1)	;IS THIh qB	BEQ	gKi2		;
	ERR03			;ERROR-MOD"UST START
				;WITHA ODULE͋
LI2u0Ѕ	#OBJ7QR1)	;4T4TE NAME?
	BEQ	L3gťL		;ERRLINK4n͟hTG-L8,R2		;qj 2 TO NAME 3SATABLE
	TST	(R1)+		;ADVANqPPINTER'ODULE NAMEÛP	(R2)+,(R1)+	;IS THE NAME OK?
	BNE	LINK44		;NO-ERROR
	CMP	(R2),(R1)	;TRY SECOND WORD.
	BNE	LINK44		;ERROR.
	CLRB	FILEOR-L8
;	START READING THE NON-GSD BLOCKS.
LINK45:	GNGSD			;GET A NON-GSD BLOCK
				;R0 POINTS TO BC.
				;R1 POINTS TO FIRST BYTE OF BUFFER.
	SUB	#2,(R0)		;DECREMENT BC.
	MOV	(R1)+,R2	;GET BLOCK TYPE
	BITB	#EOF,-1(R0)	;INPUT ERROR?
	BNE	LNK169		;YES,TREAT AS MODULE END
	CMP	#TXTBLK,R2	;TXT?
	BEQ	LINK46		;YES.
	CMP	#MODEND,R2	;MODULE END?
	BEQ	LINK47		;YES
	CMP	#GSDEND,R2	;GSD END?
	BNE	.+6
	INC	GENDF-L8
	CMP	#RLDBLK,R2	;RLD?
	BNE	LINK45		;NO-IGNORE ALL OTHER BLOCKS.
	MOVB	#3,T-L8		;SET T SWITCH TO 3.
	CMP	-(SP),-(SP)	;FAKE DOUBLE PUSH.
	JMP	LINK48		;GO PROCESS RLD.
LNK169:	BR	LINK47
;
;	MODULES OUT OF ORDER
;
LINK44:
	.IFDF	BLKIO
	JSR	PC,@#READST	;GET DEVICE STATUS
	.ENDC
	.IFNDF	BLKIO
	.STAT	#OBJDEV
	.ENDC
	TST	(SP)+
	BPL	LNK151
	CMP	(SP)+,(SP)+
	INCB	FILEOR-L8
	TSTB	CONCAT-L8
	BEQ	LNK150
LNK141:	IOIG
	BITB	#EOF,-1(R0)
	BEQ	.+10
	CLRB	FILEOR-L8
	BR	LNK150
	CMPB	#MODEND,(R1)
	BEQ	.+4
	BR	LNK141
	JMP	LINK75
LNK150:	JMP	LINK53
LNK151:	CMP	(SP)+,(SP)+
	MOV	PTRG-L8,R0
	MOV	#ORDRER,R1
	UNPACK
	MOV	#ORDRM,R0
	TYPE
	CLR	-(SP)
	MOV	#406,-(SP)	;CODE=A006
	IOT
	.IFDF	BLKIO
	JSR	PC,@#CLOSRD	;CLOSE AND RELEASE INPUT
	.ENDC
	.IFNDF	BLKIO
	MOV	#OBJDEV,-(SP)	;CLOSE & RELEASE INPUT
	MOV	(SP),-(SP)
	EMT	CLOSE
	EMT	RELEASE
	.ENDC
	BR	START8		;TRY AGAIN
LNK03:	IOIG
	BR	LNK05
;
;	TXT BLK
;
;	MOVE TXT BLOCK TO A SAVE AREA
;
LINK46:	MOV	#TXTSVB,R2	;ADR OF TXT SAVE AREA
	MOV	R2,-(SP)
	MOV	(R0),(R2)	;MOVE IN BC
	SUB	#2,(R2)+
	SUB	#2,(R0)
	MOV	CURPC-L8,(R2)+	;MOVE IN CURRENT PC
	MOV	R2,-(SP)
	TST	(R1)+		;ADVANCE PTR TO 1-ST
				;  DATA WORD.
LINK59:	DEC	(R0)		;DONE?
	BLT	LINK49		;YES
	MOVB	(R1)+,(R2)+	;MOVE IN A BYTE
	BR	LINK59
LINK49:	CLRB	T-L8
	GNGSD			;GET NEXT NON-GSD BLOCK.
	MOV	(R1)+,R2	;GET BLK TYPE.
	SUB	#2,(R0)
	BITB	#EOF,-1(R0)	;ERROR?
	BNE	LINK62		;YES,TREAT AS MODULE END
	CMP	#RLDBLK,R2	;RLD?
	BEQ	LINK48		;YES
	CMP	#TXTBLK,R2	;TXT
	BEQ	LINK50		;YES
	CMP	#GSDEND,R2	;GSD END?
	BNE	.+6
	INC	GENDF-L8
	CMP	#MODEND,R2	;MODULE END
	BNE	LINK49		;NO-IGNORE ALL ELSE
LINK62:	MOVB	#2,T-L8		;TXT FOLLOWED BY MODULE END.
	BR	LINK51
LNK06:	JMP	LNK10-L8
;
;	ADVANCE TO NEXT MODULE (MOVE PTRG IN SYMBOL TABLE).
;
LINK47:	MOV	PTRG-L8,R2		;GET PTRG
	ADD	#5,R2		;SET TO FLAGS OF A SYMBOL.
LINK52:	ADD	#BPSYM,R2	;MOVE TO NEXT ENTRY.
	CMP	R2,SYME-L8		;TOO FAR
	BHIS	LINK53		;YES
	CMPB	(R2),#OBJMN	;IS ENTRY AN OBJ MODULE NAME?
	BNE	LINK52		;NO-TRY NEXT ONE
	SUB	#5,R2		;YES,DO ANOTHER
	MOV	R2,PTRG-L8	;INPUT FILE
	TSTB	LIBF-L8
	BNE	LNK186
	MOVB	TAPES-L8,-(SP)
	BISB	CONCAT-L8,(SP)+
	BNE	LINK75		;IGNORE GENDF-L8 IF TAPES OR 
				;CONCAT IS ON.
LNK186:	TST	GENDF-L8	;SEEN GSD END?
	BEQ	LINK75		;NO, STAY IN SAME FILE
LINK53:	TSTB	LIBF-L8
	BNE	LNK06
LNK152:	IOIC			;CLOSE OBJECT MODULE FILE
				;AND RELEASE ITS DATA SET
				;IN SECOND PASS
	JMP	LINK97-L8		;YES, DO NEXT FILE		
LINK75:	IOIG		;GET NEXT BLOCK
	JMP	LINK76		;   AND PROCESS.
;
;	TXT FOLLOWED BY TXT
;
LINK50:	MOVB	#1,T-L8
;
;	UPDATE CURPC BY SIZE OF LAST TXT BLK
;
	ADD	@2(SP),CURPC-L8	;USES STACKED R0 FOR POINTER TO
				;LAST TXT BLK BC.
	BR	LINK54		;GO OUTPUT LAST TXT BLK.
;
;	TXT FOLLOWED BY RLD
;
LINK48:	JSR	PC,PRLD00	;PROCESS RLD
LINK51:	CMPB	#3,T-L8		;ANY TXT TO OUTPUT?
	BEQ	LINK55		;NO
;
;	OUTPUT TXT
;
LINK54:	MOV	(SP),R3		;PTR'S TO TXT DATA
	MOV	2(SP),R2	;AND TO TXT BC
	MOV	PUTR0-L8,R4	;PTR'S TO OUTPUT BC
	MOV	PUTR1-L8,R5	;AND TO OUTPUT DATA.
	MOV	-2(R3),(R5)+	;GET LOAD ADDRESS
	ADD	#2,(R4)		;UPDATE OUTPUT BC.
LINK56:	MOVB	(R3)+,(R5)+	;MOVE A DATA BYTE
	INC	(R4)		;OUTPUT BC UPDATE.
	DEC	(R2)		;DONE
	BGT	LINK56		;NO-DO ANOTHER.
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	.IFDF	RTH		;BRTH11
	TSTB	RTF-L8		;DOING RTH?
	BEQ	LNK174		;NO-
	CMP	RTHPTR-L8,PTRG-L8 ;RTH NEXT?
	BNE	LNK174		;NO-
	TST	-(R5)		;YES
	MOV	LOWADR-L8,-(SP)	;PREPARE STACK LIMIT
	SUB	SS-L8,(SP)
	SUB	#2,(SP)
	MOV	(SP)+,-22(R5)
	CLRB	CSISS-L8
	TSTB	CSIMT-L8	;MT FROM CSI?
	BEQ	.+14		;NO-
	MOV	MT-L8,-30(R5)	;YES-
	CLRB	CSIMT-L8
	TSTB	CSICN-L8	;CN FROM CSI?
	BEQ	LNK190		;NO-
	MOV	CN-L8,(R5)	;YES-
	CLRB	CSICN-L8
LNK190:	TSTB	CSIP-L8		;PRIOR FROM CSI?
	.EOT
;TAPE 4
	BEQ	.+14		;NO-
	MOV	PRIOR-L8,-24(R5) ;YES
	CLRB	CSIP-L8
	TSTB	CSIN-L8		;NAME FROM CSI?
	BEQ	LNK171		;NO-
	MOV	NAM1-L8,-2(R5)	;YES-
	MOV	NAM2-L8,-4(R5)
	CLRB	CSIN-L8
LNK171:	MOV	TRA-L8,-14(R5)	;FILL IN TRA ADR
	MOV	LOWADR-L8,-16(R5)	;FILL IN LOW LIM OF PROG
	MOV	#FIO1,R4	;SET PTR TO $OTSV INTO R4
	SRGLOB			;SEARCH FOR IT
	BR	LNK174		;NOT FOUND
	MOV	R4,-42(R5)	;FOUND - FILL IN.
	.ENDC			;ERTH11
LNK174:	IOOP			;OUTPUT THE BUFFER
	TSTB	IOOPER-L8		;OUT ERROR?
	BEQ	.+6
	JMP	LINK25-L8
	MOV	R0,PUTR0-L8	;SAVE R0,R1
	MOV	R1,PUTR1-L8	;FOR NEXT OUTPUT
	MOV	(SP)+,R1
	MOV	(SP)+,R0
LINK55:	CMP	(SP)+,(SP)+	;REMOVE THE STACKED R0,R1
	MOVB	T-L8,R2
	CMP	R2,#TMAX	;INDEX OK?
	BLE	.+4		;YES
	ERR14
	ASL	R2
	JMP	@LINK57-BEGO08+BEGOVR(R2)
LINK57:	.WORD	LINK45-BEGO08+BEGOVR
	.WORD	LINK46-BEGO08+BEGOVCE	]DgKi7-BEG+֥񢄮ORD	LINK45-BEGO08+BEGOVRCECE;;	SUTթ3O PROqiARLD
cE;INPUTV;		R0*SARD BCNĉ((T'YTE F&O3Bh+ϥD
;		STACKED R0 AND R1 POINT TO PREVIOUS TXT BLOCK (IFgYSE;PRLD00:	TST	(R0)		;EAjHARLD?BaG	PRLD01		;NO -B`ĉ	@4(SP),CUT!wYES, "AE CURQgTAƊRLDEX:	RTS	PC
;
;	ËSS NEXT COMMAND
;
Da.͟Є*UB]ǋT CMD
	MOVB	(R*Ub]ǋT OFFqj NTO TXT
	MOV	R3,OFFqj	wSAVE 5SUB	#2,OFFSET
	ADD	J)S,R3	;ADD PUSHED TXT ΩTQi,R3		;FORMaԫAL ADDRESS
	MOi2Y)S	;STACK CMD
	B0ģc77600,R2	;pkEALOW 7ԧ
	MOhT,5
	CMP	R2,#CMDMAX
0EPRLD06:	ERR14
0iLSh	RCMDT);GO EXECUTE PROi 3LR
RC*:+PRLD06,CMVCD2,CMD3,CMCVCD6
	+CMD7,CMD8,CMD9e,PRLD06,CMD4,CMD5,CM;
;	CMD #1 -- 3ENAL RELOC
;
CMD1:		QR1)+,R4	;GRL VALUE
	ADD	B4⨥VRi	;RELԋ IT
	TXTPRLD02BiՅ	#4,(R0)
	BR	PRLD00񢝍;	CMD [- GLOBAL RELOC

;
CMD2:	MOV	R1,R4		;SET ADR OF NAME
	CMP	(R1)+,(R1)+
	SRGL;SEARCH FOR GLOBAL NAME
	ERR09		;ERROR
	TXTPUT
PRLD04:	SUBQY(R0)
	BR	Da0

;
;	CMD #3 -- INTERf ISPLACED RELOC
;
CMD3:	jP"DET PC AT CURRENT PLAqW	NEG	R4
	ADD	(R1)+,MQX - (.+2))
	BR	PRLD02-2NƊw	CMD #4 -- GLOBAL DISPLACED RELOC
cECD4:	GETPC	"]ǋT PC NOW
	MOV	R4,TMP1
	MOV	R+)4Ba͡*)1S+,(R1)+
	t̟BDwj LOBAL VALUE	T9	;ERROR
PS"0k:	SUB	TMP1	;FORM
,-Q.+2))¥	PRLD04-2NƊw	CMD #5 -- GLOBAL ADjI)EOC
;͉5:	MOV	R1,Mt̟B			;GET GA VALUE	T9	;ERRsh	QR1)+,(R1)+
	ADD	(R1*Ri	;ADDITIVE CONSTANTBiՅ	#2,(R0)
	BR	PRLD04-2
;񢝉MD #6VLOBALbDTIVE iЙACED
;
C:GETPC"DET PCBfϭ4,MP1
	MOV	R1,R4ÛP	(R1)+,(R1)+
	SRGLOB
	ERR09		;ERS	ADD	(R1)+,R4
4#2,(R0)
	TХLD05NƊ;	CMD۠[)ũ!;
CM	c	CMP	(R1)+)1ScE	ETSEC			;GET SECTION'ɝTER
	ERR11		;FATAL ERROR
	MOV	R4,)ŇT	;SET PTSECT
3gR4,R5
	SUBQY(R0)BaRsb8;
;0A#8 -- PC M$ƓpjIN
;
CMD8:	MOV	BASEYR4	;GET SECTION BASE VALUE
	ADD	(R*U4	;MODIFY
	MOV4,URPC
	TST*)S+
	SUB	#4,(R0)
;	PC COMMANDSjө4 N RLD
	BLE	PRLl;	IF NOT DONE, NEXT s̓ND MUST ALSO BE PC TYPE
0Ѕ	#PCMV(1)
	QhRLD00ÛCMD2,	BEQ	PRLDw񢝉TA--- CMD MUST BE!YPE.
;
	ERR10		;FAf RROR
;
;	CMD #9---SET PS҃M LIM5);
CM]	OV	LOWADR,R4	;SET LOW LIMIT
		Qt[(SP)	;GET TWO COPIES LAG
	TXTPUT
	MOV	TOPMEM,R4	;SET H1 IMIT

	.IFDF	U$	;BRTH12
	BRTF		tFA3 OT NO3?	BEQ	.+14ԧΟIOF		;RTH WAS PREASSaLD?
	BNE	.+6		;NO-
	SUB	RTHSIZ,R4	vb[SUBSTRUCT ITS S6	.ENDC			;Hc2
	TXTPUT
	SUB	#2,(R0)		;ADJ cE	ХLD00
	.IFNDF	ŏ
ENDO08:
SIZO08=EN8[BEGO08
	.ENDC
	.ENDC			qY
	.1D NOSEE	]=BEGOԕϭT;OVES AkIE LINh!LrƊw
	.WORD	0		;ERROR R*ҝ ADDRESS
OVRLB:	.WOQ	;LINK POINTER (DDB)
	.R1/OVR/"]̟GICAL ԃ SET NAME
	.BYTE	1		;DEVICE Saɍ1b	.BYTE	0		;UNIT NUMB.RAD50	/SY/		;DEVICE NAME
;
;OVERlEVICE FILE BLOCcE;	.WORD	0	.ҥOR REiNA1"RSS
	Ьԋ,Y;HOW "AsAEC)
	.BYTE	0		;O RETURN CODE
OVRFB:	.RAD50	/LIN/		q̋NAME AND EXTENS3	.RAD50	/K,W;IN RADIX 50
	.RAD50	/OVR/		;A3ғD:	.WORD	0		;USI CODE
	.BYTE	233		;ԋCT CODE
ONCE:	.BYTE	377	.·E ONL(#LG
;Nӓ BLOCh#OELAY DË ԃ SETNƊԡL:	.WORD	CMDB		;ADDREtO CSI BUFFER (7 WORDS#E	]WORD	OVRLB		;ADDRESS OF L3LOCKBWWRD	OVQ	;ADDRESS OF FILE BLOCK
;
;OVA"֓CE INPUT TRAN BLOCKNƊVRTBI:	.WORD	0		;DEVICE BLOCK NUMBECE	]WORD	BEGOVR		;Mgҳ START ADDQi	.WOQϭUD	;WOR!ϫVRIERBWWQ.UCTION (READ)
	҉	0		;NUMBER OF WORDS NOT TRAN'D

t¥OUTINE TO DIVID*H TOP WORD wTHE STACK BY THE NEXT WORD. EX5)uԑ$EAQUOTIENT ON TOP HE
;STACK. THE QUOT1gTAIS INCREMENTED BY
;ONE I*HRE ISPRMAIND;	CALgGAqhՋNCE:NĉēVISORTRm#E;	MOV	DIVIDEND,-(R6)NĉSR	R7,DIVIDE
;		MOV*)6S+,QUOTIENT
;R0 IS DESTRO1bDIVID͟V	#1,LwQUOTIENT AT LEAST 1

DIVID.ӫBZ(6),2(R6)	;SUBTRACT D5ӟR FROM DIVIDEND
	BLE	DIVID2		;DONEE	NC	R0		;NO.
	BBbIID1
DIVIDN͟V	R0,)6S.՟TIENT͟TRm)+,@R]oҩbi7;
;THE FOLLOW3ABLE IN THE RESIDENT
;LINKER CONTA3 ONE WORD ENTRYƟR EACH OF " OVERLAYS. THE
;1ST WORD OF TPTS"ANS N*2.
;AS NE'֋RLAYS ARE CREATED, E)IS
;MUST BE ADDED TO THE  F THE E.
;"ATHE L3ťԧ CONTS T
;"LNK",j 3& aATHE STARTING
;,ӓCAL BLOCK NUMBER OF aAOVERLAY
;IN THE RESPECTIPETRY.NHǝA(BIT 15) OF EACH ENTRY WILL
;3I5"jHR OR  PASOCIATED
;OVERLAY IS IN sEu񢝉cӓDENTNİ{NOT RESIDENT
;
RUNTAB:	҉	RUNEND-RUNTAB	;N*2BWWQ	;OVES A#1
	҉,wOVERL6P#e
	.W	a"]ϭERLAY #3
	.WORX	sElG4
	.D0		;OiL(	.WORD	0	.֋RLAY #6
	҉,wOVERLAY #7
	.WORD	0		;OVA #8
UgED:	.WORD	0"]ϭERLAY #9
;
;SUBROUTINE TO TRANSFER A REQUESTED
;  OVERLAY FROM THE SYSTEM DEVICE TO THE OVERLAY AREA.
;CALLING SEQUENCE:
;		CONTRL
;		.WORD	N	;WHERE N IS
;				;THE OVERLAY NUMBER
;
;IF THE REQUESTED OVERLAY IS ALREADY RESIDENT,
;CONTROL IS RETURNED IMMEDIATELY TO THE CALLER.
;


;
;IF THE REQUESTED OVERLAY IS NOT RESIDENT:
;	1.  IT IS TRAN'D IN (.TRAN, .WAIT)
;	2.  A CHECK IS MADE FOR ERRORS
;	    DURING TRANSFER
;	3.  RUNTAB IS UPDATED TO REFLECT
;	    WHICH OVERLAY IS NOW RESIDENT
;	4.  RETURN TO CALLER
;
;CONTRL:
SUBR46:	SAVREG			;SAVE REGISTERS 0 THRU 5
	MOV	@16(R6),R1	;OVERLAY NUMBER TO R1
	ASL	R1		;ADJUST TO WORD OFFSET
	MOV	#RUNTAB,R2	;BASE OF TABLE
	ADD	R2,R1		;ADDRESS OF REQUESTED ENTRY
	MOV	@R1,OVRTBI	;SET UP TRAN BLOCK
	BLT	CONTR1		;OVERLAY ALREADY IN
	MOV	#OVRTBI,-(R6)	;.TRAN IN
	MOV	#OVRLB,-(R6)	;THE OVERLAY
	EMT	10
;UPDATE RUNTAB
	MOV	(R2)+,R3	;N*2
CONTR3:	SUB	#2,R3
	BLT	CONTR4		;MORE ENTRIES?
	BIC	#100000,(R2)+	;YES, CLEAR IN FLAG
	BR	CONTR3
CONTR4:	BIS	#100000,@R1	;SET NEW IN FLAG
	RESREG			;RESTORE REGISTERS
	MOV	#OVRLB,-(R6)	;WAIT FOR
	EMT	WTCMD		;COMPLETION
;CHECK FOR ERROR ON TRANSFER
	BIT	#140000,OVRIER
	BEQ	CONTR2
;ERROR ON TRANSFER
	MOV	OVRIER,-(R6)	;PUSH STATUS BYTE
	BIC	#377,@R6	;INFO INTO LOW
	SWAB	@R6		;INFO BYTE AND
	MOV	#ERR8,-(R6)	;CLEAR THE REST.
	JMP	ERROUT
CONTR1:	RESREG			;RESTORE REGS. 0 THRU 5
CONTR2:	ADD	#2,@R6		;INCREMENT PAST ARGUMENT
	RTS	R7		;RETURN TO CALLER
	.ENDC

;
;	BEGIN MAIN PROGRAM
;
;

	.CSECT
LNK:
	.IFDF	DEBUG
	JSR	PC,REPORT
	.ENDC
	BR	5$		;COMMAND STRINGS THROUGH CSI
	INCB	FORTRF		;COMMAND STRINGS FROM FORTRAN
	MOV	SP,BEGCS	;SAVE POINTER TO COMMAND STRING
	;
	;	GET BYTE COUNT OF FORTRAN COMMAND STRING
	;
	MOV	SP,R1
	CLR	R0
3$:	MOVB	(R1)+,CHAR
	CMPB	#LF,CHAR
	BEQ	4$
	INCB	R0
	BR	3$
4$:	INCB	R0
	MOV	R0,FORTBC
5$:	CLR	INCMD
	CLR	OBJDEV
	CLR	MAPDEV
	CLR	LODDEV
	CLR	STBDEV
	CLRB	STBOPF
	CLRB	MAPOPF
	CLRB	LODOPF
	MOVB	#377,NOINIT	;INIT OVERLAY DEVICE FLAG
	.IFNDF	NOSEG
	CLR	OVRLB		;FOR ^C BEGIN
	.ENDC
	.IFNDF	OVRBLD		
	START=LNK		;TRANSFER ADDR.
	.ENDC
	.IFDF	NOSEG
START=LNK
	.ENDC
LINK:	TSTB	FORTRF	;CS FROM FORTRAN?
	BEQ	1$		;NO-
	CMPB	FORTRF,#1	;1ST TIME?
	BEQ	2$		;YES-
	.EXIT			;NO-
2$:	INCB	FORTRF		;MARK 1ST TIME
1$:	DEC	OVLC		;LINKING OVERLAY FILES?
	BLT	INIT1		;NO-
	MOV	SSYMB,SP	;YES-SET STACK POINTER
	MOV	SP,SB		;SET STACK BASE
	;
	;	RESET STACK BASE TO NEW VALUE
	;
	MOV	SB,-(SP)	;NEW STACK BASE ON THE STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;CLEAN RETURN VALUE FROM STACK
	;
	;
	MOV	SP,SYMB		;    AND RESTORE SAVED
				;    RESIDENT SYMBOL
	MOV	SASYME,-(SP)	;    TABLE POINTERS
	MOV	(SP),SYMC
	MOV	(SP),SYME
	MOV	(SP),USYME
	MOV	@(SP)+,TOPMEM	;SET DEFAULT TOP OF MEM
	MOV	LIMIT,ENDM	;SET END OF FREE CORE
	BR	INIT2

INIT1:	MOV	LIMIT,SP	;SET SP
	MOV	SP,SB		;SET STACK BASE
	TSTB	FORTRF		;CS FROM FORTRAN?
	BEQ	1$		;NO-
	MOV	BEGCS,SP	;YES-RESET STACK TO NOT TO
				;    DESTROY COMMAND STRING
	;
	;	RESET STACK BASE
	;
1$:	MOV	SB,-(SP)	;PUSH NEW STACK BASE TO STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;POP RETURN VALUE FROM STACK
	MOV	SP,ENDM		;CALCULATE SYMBOL TABLE
	SUB	#200.,SP
	MOV	SP,USYME	;INITIAL VALUE FOR END OF SYMBOLS
	MOV	SP,SYMB
	MOV	SP,SYME
	MOV	SP,SYMC
INIT2:
;
;	TRAP HANDLER VECTOR
;
	.TRAP	#0,#TRAPH
	.IFNDF	NOSEG
;
;USE THE COMMAND STRING INTERPRETER (CSI)
;TO DETERMINE THE SYSTEM DEVICE AND
;UNIT OF THIS SYSTEM.
;
	MOV	#ONCE,R0	;ADDRESS OF ONCE ONLY FLAG.
	TSTB	(R0)+		;BRANCH IF ALREADY
	BEQ	OVER2		;DONE ONCE.
;THE FLAG AT ONCE IS CLEARED BY CSI
;DUE TO ITS PROXIMITY TO OVRFB.
;R0 NOW POINTS TO OVRBLK.
	.CSI1	@R0		;ADDRESS OF CMDBUF
;THE LINE IS SYNTACTICALLY ACCEPTABLE, THUS
;THE RETURN FLAG ON TOP OF STACK IS IGNORED.
	MOV	R0,@R6		;ADDRESS OF OVRBLK
	EMT	57		;CSI2
	TST	(R6)+		;CORRECT STACK
OVER2:

;*****SET UP FOR OVERLAYS*****
;
	TSTB	NOINIT		;OVERLAYS ALL
	BEQ	RUN01		;SET UP?
				;NO
	MOV	#OVRLB,R1	;LINK BLOCK
;.INIT OVERLAY DEVICE
	.INIT	R1
;OBTAIN DEVICE STATUS
	.STAT	R1
	CMP	(R6)+,(R6)+	;CORRECT STACK
	;PHYSICAL BLOCK SIZE (WORDS) ON TOP OF STACK

;DIVIDE BLOCK SIZE INTO OVERLAY SIZE TO
;DETERMINE NUMBER OF BLOCKS PER OVERLAY
	MOV	#OVRWRD,-(R6)	;OVERLAY SIZE
	JSR	R7,DIVIDE
	MOV	(R6)+,R5	;BLOCKS PER OVERLAY
;
;DETERMINE THE PHYSICAL STARTING BLOCK
;OF THE CONTIGUOUS FILE.
RUN05:	MOV	#OVRFB,-(R6)	;FILE BLOCK
	CLR	-(R6)
	MOV	R1,-(R6)	;LINK BLOCK
	EMT	14		;.LOOK
	MOV	(R6)+,R4	;STARTING BLOCK
	BNE	RUN03		;DOES FILE EXIST?
	CMP	(R6)+,(R6)+	;CORRECT STACK
	CMP	USERID,#401
	BEQ	RUN04		;ALL DONE.
	MOV	#401,USERID	;TRY [1,1]
	BR	RUN05
RUN04:	MOV	#OVRFB,-(R6)	;LINK11.OVR NOT PRESENT.
	MOV	R1,-(R6)	;PERFORM .OPENC TO FORCE
	EMT	OPN		;FATAL ERROR
RUN03:	CMP	(R6)+,(R6)+	;CORRECT STACK.
;
;PLACE STARTING PHYSICAL BLOCK NUMBER OF
;EACH OVERLAY IN THEIR RESPECTIVE RUNTAB
;ENTRY.  SIGN BIT SET TO 0 FOR NON-RESIDENCY.
;
	MOV	#RUNTAB,R2
	MOV	(R2)+,R3	;NUMBER OF OVERLAYS *2
RUN02:	SUB	#2,R3
	BLT	RUN01		;MORE OVES ٧E	OV	R4,(R2)+	;YES.  STARTING BLOCK # TO
	ADD	R5,R4		;ENAgCiAS'× #
	TҫN02		;BY BLOCKS PER OVERL6FUN01:񢄮FDF	DEBUG
	JSR	PC,REPORT
	.ENDC

	CONTRL񢄮ORD	2		;OVERLAY #2
2R1
	.ENDC
	.IFDF	NOqc2START2
	.ENDCCE3a:	TSTBcO	pAFROM T3	BEQ	1$		;֍	.IFNҧE	STB	MI		;IN MON LIB SEARCH?
	BNE	1$		;YES-
	.ENDC
	MOV	BEGCS,-(SP)	;YES-
	SUB	#20.,(SP)
	BR	2$
1$:	MOV	ENDM,-(SP)	; CHECK FOR ROOM FOR 
	SUB	#BUF,(SP)	; ANOTHER COMMAND STRING
2$:	CMP	USYME,(SP)
	BLO	LINK81
	TST	(SP)+		;NO ROOM- FATAL ERRORBbҥ18
LINK81:	MOV	(SP),ENDM	; GOT ROOM. FIX ENDM,
	MOV	(SP),CMDBUF	; CMDBUF & CINBUF
	MOV	(SP),-(SP)	;PLACE COMMAND BUFFER ON THE STACK
	ADD	#14.,(SP)
	MOV	(SP),CINBUF
	MOV	(SP),R1
	MOV	#84.,(R1)+	;SET MAX BC
	TSTB	FORTRF		;CSI FROM FORTRAN?
	BEQ	1$
	.IFNDF	RSX
	TSTB	MONLIB		;IN MON LIB SEARCH?
	BNE	1$		;YES-
	.ENDC
	MOV	FORTBC,2(R1)	;GET FORTRAN BC
1$:	CLR	(R1)		;SET MODE TO FORMAT ASCII
	.IFNDF	RSX
	TSTB	MONLIB		;IN MON LIB SEARCH?
	.IF DF	OLDLUK
	.IFF
	BNE	LNK200
	.IFT
	BEQ	LINK36		;NO-
	MOV	#4.,2(R1)
	CMP	(R1)+,(R1)+
	MOV	-2(R1),R2	;SET COUNTER TO 20.
	MOV	#MONL+6,R0	;POINT R0 TO CANNED MESSAGE
LNK114:	MOVB	(R0)+,(R1)+	;MOVE CANNED MESSAGE INTO CINBUF
	DEC	R2		;DECREMENT COUNT
	BEQ	LNK115		;GO PROCESS MON LIB
	BR	LNK114
	.ENDC
LINK36:	JMP	LNK113
	.IF DF	OLDLUK
LNK115:	TST	(SP)+
	.CSI1	(SP)
	TST	(SP)+
	MOV	#2,@CMDBUF
	MOV	CMDBUF,BLKI
	.CSI2	#BLKI
	.IFF
LNK200:	CMP	(SP)+,(SP)+
	.ENDC

;
;	INIT INPUT DEVICE
;
	INCB	FLAG
	MOVTAB
	CLRB	FLAG
	.IF NDF	OLDLUK
	CLRB	OBJDEV+5	;SET UNIT ZERO
	MOV	#75250,OBJDEV+6	;SET UP 'SY' ENTRY
	.ENDC
	.IFDF	BLKIO
	JSR	PC,INITRD	;INIT THE INPUT DEVICE
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV
	.ENDC
	.IF NDF	OLDLUK
;
;GET MONITOR LIBRARY STARTING BLOCK AND FIND PROPER ENTRY
;
	.GTCIL			;GET LIBRARY ADDRESS
	MOV	(SP),MSTART	;REMEMBER IT
	MOV	(SP)+,TRNBLK	;SET UP AN ADDRESS FOR THE TRAN
	MOV	INA,-(SP)	;GET THE BYTE COUNT
	CLC			;AND
	ASR	(SP)		;CONVERT IT TO A WORD COUNT
	MOV	(SP)+,TRNBLK+4	;WORD COUNT TO TRANSFER
	MOV	#INA+6,TRNBLK+2	;CORE ADDRESS
	.TRAN	#OBJDEV,#TRNBLK	;DO THE TRAN AND PRAY THAT
	.WAIT	#OBJDEV		;WE READ ENOUGH TO USE!!!!
	MOV	#INA+6,R0	;GET BUFFER POINTER
	MOV	#1,R1		;GET NEEDED CONSTANT
1$:	CMP	(R0)+,R1	;IS THIS THE START OF THE CIL LINE?
	BNE	1$		;NO, SKIP OVER TRASH
	ADD	(R0),R0		;POINT TO THE SECOND ENTRY
2$:	CMP	(R0)+,R1	;FIND THE START
	BNE	2$		;ENTRY
	ADD	(R0),R0		;NOW SKIP TO THE THIRD ENTRY
3$:	CMP	(R0)+,R1	;NOW MAKE SURE
	BNE	3$		;WE ARE THERE
	ADD	#14.,R0		;POINT TO THE PROPER DISK ADDRESS
	ADD	(R0),MSTART	;NOW WE HAVE THE ABSOLUTE BLOCK POINTER
	.ENDC
;
;	OBTAIN CURRENT MONITOR TOP
;
	.MONF
	MOV	(SP)+,MONTOP
	ADD	#200,MONTOP
	.IFNDF	OLDLUK
	MOV	MSTART,TRNBLK
	.ENDC
	.IFDF	OLDLUK
	MOV	#4,TRNBLK
	.ENDC
;
;	OBTAIN DEVICE STATUS
;	AND ALLOCATE BUFFER SPACE FOR TRAN
;
	.IFDF	BLKIO
	JSR	PC,READST	;GET THE INPUT STATUS
	.ENDC
	.IFNDF	BLKIO
	.STAT	#OBJDEV
	.ENDC
	CMP	(SP)+,(SP)+
	MOV	(SP)+,BUFSIZ	;BLOCK SIZE
	MOV	SP,SPTEST	;SAVE STACK POINTER
	SUB	MONTOP,SPTEST	;DISTANCE FROM MONTOP TO SP
	MOV	BUFSIZ,TRNBLK+4	;SET WORD COUNT
	ASL	BUFSIZ		;MULTIPLY BLOCK SIZE BY TWO
	CMP	SPTEST,BUFSIZ	;IS THERE BUFFER SPACE?
	BHI	LNK118		;YES-
	ERR18			;NO-

LNK118:	MOV	MONTOP,TRNBLK+2	;SET CORE STARTING ADDR FOR TRAN
	.IFDF	OLDLUK
	MOV	BUFSIZ,BC	;PREPARE MONLIB BC
	NEG	BC
	.ENDC
	MOV	MONTOP,-(SP)
	.IFNDF	OLDLUK
	MOV	(SP),TSIZE	;MRT TABLE SIZE IN BYTES
	ADD	#2,(SP)
	MOV	(SP)+,FDATA
	ADD	#2,INDEX	;SKIP EMT 0,1.
	.ENDC
	.IFDF	OLDLUK
	ADD	#2,(SP)
	MOV	(SP)+,FDATA
	.ENDC
;
;CALCULATE SYMTAB BC
;
	MOV	USYME,-(SP)
	MOV	SYME,-(SP)
	SUB	(SP)+,(SP)
	MOV	(SP)+,STBC
	NEG	STBC
;
;	TRANSFER ABSOLUTE BLOCK AND WAIT ON IT
;
LNK124:
	.TRAN	#OBJDEV,#TRNBLK
	.WAIT	#OBJDEV
	BITB	#EOF,TRNBLK+7
	BEQ	2$
	ERR21
	.IFNDF	OLDLUK
2$:	CMP	@TSIZE,BUFSIZ
	BLT	1$
	SUB	BUFSIZ,@TSIZE	;DECREMENT MRT TABLE SIZE
				;BY BUFSIZ
	BR	LNK122
1$:	TST	TSIZE
	BEQ	LNK123		;DONE WITH MONITOR LIBRARY SEARCH
	CMP	#2,INDEX
	BEQ	3$
	MOV	MONTOP,FDATA
3$:	INCB	LASTDB		;NO MORE TO READ
;
;	NOTE THE ASSUMPTION THAT THE MRT SIZE IS AT MOST TWO 
;	DEVICE BUFFER FULL.
;
	.ENDC
	.IFDF	OLDLUK
2$:	TST	@TE	D̝K121
	.ENƊزeCE	]IFNDF	OLDLUK
	MOV	@TSIZE,BC	;l C
	NEG	BC
	.ENDC
1$ҧBDwNO-
	TSTB	LASTDB		;3O READ?
	BNE	LNK123		;NO-
	.IFNDF	OLDLUK
	INC	MSTART		;YES-
	MOV	Mu ҩ)NLK
	.ENDC
	.IFDF	OLDLUK
	MOV	@MONTOP,BK
	.ENDC
	BR	e4		;G*OAREAD lTABOX.

	cD	OLDLƊNK121:	MOVB	#1,LASTDB
	BR	LNK122
+ΉC
LNlY3u
	.IFNDF	"LK
	CLR	INDEX		;REINITIALIZE MUTBLE I"	CLRB	LAS!	.ENDC
	.1FBLKIO
	JSR	PC,S)҉	;RELEASE 3U"֓CE
	.ENDC
	.IFNDF	S%ɟ
	.RGOBJDEV		;RELEAS$ΡUT DEVICE
	.ENDC
	ADD	#BUF,ENDM	;RECLA3PSACE FS栙AST CrPBѢ]
	MOVB	#1,SECTIM	;GET PREPARE*O	MOV	SSYME,SYME	;RE Ë "   " BYBWINDF	N	;".  "
	sTL
	.D4
	JMP	EN	.ENƊ.IFDF	NOSEE	MP	LINK13
	.ENƊ.ENDCN113:	TSTB	FORTRF		;CSI FROM FORTRAN?
	BEQ	1$		;NO-
	MOV	@#CMDBUF,-(SP)	;YES-
	BR	LINK82
1$:	MOV	#NO,R0		; TYPE "#"
	TYPE
	CLRB	BIT2F
	MOV	(SP),R0		; READ COMMAND STRING
	MOV	#INCMD,-(SP)
	EMT	READ
	.WAIT	#INCMD
	BIT	#060000,2(R0)
	BNE	STOP
;
;NOTE- PTR TO BUFFER STILL ON STACK
;      -IT WAS PUT THERE AFTER LINK81-

LINK82:	EMT	CSI1		;DO SYNTAX CHECK
	TST	(SP)
	BEQ	LINK83		;ERROR?
	TSTB	FORTRF		;CS FROM FORTRAN?
	BEQ	1$		;NO-
	MOV	#ERR10,-(SP)	;YES-PRINT F044 EXIT TO MON
	IOT
	.EXIT
1$:	CMPB	#CR,@(SP)
	BEQ	.+4
	INCB	(SP)		;YES - MOVE ?, VT INTO CINBUF
	MOVB	#77,@(SP)
	INCB	(SP)
	MOVB	#13,@(SP)
	MOV	@#CINBUF,R0	;UPDATE: BC=4+LENGTH
	MOV	(SP)+,4(R0)	;END =(SP), BASE =R0+6
	MOV	R0,-(SP)	;LENGTH=END-BASE
	ADD	#5,(SP)
	SUB	(SP)+,4(R0)	;4(R0)=(SP)-(R0+6)
	TYPE
	MOV	#5015,6(R0)	;MOV CR,LF INTO CINBUF
	MOV	#2,4(R0)	;UPDATE BYTE COUNT.
	TYPE			;TYPE A BLANK LINE
	TYPE
	MOV	CMDBUF,-(SP)	;PREPARE STACK
	JMP	LINK81
STOP:	.EXIT
LINK83:	TST	(SP)+
	TSTB	PASS
	BNE	LNK137		; PASS 2 -
	TSTB	FLINE
	BNE	LNK137
	.IFNDF	NOSEG
	CONTRL
	.WORD	3		;OVERLAY #3
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	STRT31
	.ENDC
LNK137:	JMP	LINK84

LNK128:	MOVTAB
	IOIC
	.CSI1	@#CMDBUF
	TST	OVLC		;IN OVERLAY SECTION OF
				;ASSOCIATED LINK?
	BGE	LINK84		;YES- TOP OF MEM IS
				;SET ALREADY
	.IFNDF	NOSEG
	CONTRL			;NO-SET TOP OF MEM
	.WORD	3		;OVERLAY #3
	JMP	ENTRY2
	.ENDC
	.IFDF	NOSEG
	JMP	STRT32
	.ENDC


; START PROCESSING THE INPUT FILES FROM COMMAND STRING
;
; CHECK IF PROCESSING MULTIPLE TAPES
;
LINK84:	TSTB	TAPES		; /TA SWITCH ?
	BEQ	LINK89		; NO-
	TST	TAPCT		; YES- COUNT =0 ?
	BNE	LINK90		; NO-
LINK89:	CLR	@CMDBUF		;ASSUME INPUT
	TSTB	FLINE
	BEQ	LINK91
	MOV	CMDBUF,BLKI	;CHECK FOR "<"
	.CSI2	#BLKI
	TST	OBJDEV+6
	BEQ	LINK37
	ERR16			;MULTIPLE "<" IN CSI
LINK37:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	13$		;NO-
	INCB	BIT2F		;YES-
13$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	14$		;NO-
	ERR19			;YES-

14$:	ASR	(SP)+
	BCS	LINK38		;ODD=>NO MULT "<" IN CSI
	ERR16			;EVEN=> MULT "<" IN CSI
LINK38:	MOV	#2,@CMDBUF	;CHANGE TO OUTPUT ON ALL LINES EXCEPT

				;FIRST
LINK91:	MOV	CMDBUF,BLKI	; SET UP INPUT BLOCK
	.CSI2	#BLKI
LNK159:	MOV	(SP),SCSIRV	; SAVE THE RETURN VALUE
	BIC	#177776,SCSIRV	;SAVE LAST BIT ONLY
	TST	OBJDEV+6	;WAS THERE AN INPUT DEVICE?
	BNE	LINK39		;YES -
	TST	OBJDEV+10	;NO - WAS THERE A SWITCH?
	BNE	LINK39		;YES -
	ASR	(SP)+		;NO -
	BCS	LNK139
	ERR17			;MISSING INPUT SPEC.
LNK139:	TSTB	NOMMS
	BEQ	LNK140
LNK145:	CLRB	NOMMS
LNK140:	MOV	#CRLF,DUMIN+6
	MOV	#2,DUMIN+4
	MOV	#DUMIN,R0
	TYPE
	MOV	CMDBUF,-(SP)
	JMP	LINK81
LINK39:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	15$		;NO-
	INCB	BIT2F		;YES-
15$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	LNK142		;NO-
	ERR19			;YES-

;
;  PROCESS PRESWITCHES
;
LNK142:	CLRB	TAPES
	CLR	TAPCT
	CMP	#63320,OBJDEV+6
	BNE	LINK92
	INCB	TAPES
	MOV	#1,TAPCT

LINK92:	MOV	#OBJDEV+8.,R1	; PTR TO SWITCH SIZE
LINK95:	TST	(R1)
	BEQ	LINK90		; DONE- NO MORE SWITCHES
	MOV	#PRESW,R0
	SWSR			; RET DISPATCH ADR IN R0
	TST	R0		; IGNORE IF DON'T RECOGNIZE THE SWITCH.
	BEQ	LINK93		;ASSUME IT IS A POST SWITCH.
LINK94:	JSR	PC,(R0)		; GO PROCESS SWITCH
LINK93:	MOV	(R1),-(SP)	; ADVANCE R1 TO NEXT SWITCH
	ASL	(SP)
	ADD	(SP)+,R1	; R1=R1+2*N
	TST	(R1)+
	BR	LINK95
LNK02:	CLRB	LIBF
	CLRB	TAPES
	CLR	TAPCT
	BR	LINK98
LNK180:				;GO CREATE RTH
	.IFNDF	NOSEG
	CONTRL
	.WORD	9.		;OVERLAY #9
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	DONE
	.ENDC
LINK90:
	.IFDF	RTH		;BRTH13
	TSTB	NOIOF		;STAND ALONE SW?
	BEQ	.+14		;NO-
	TSTB	PASS
	BNE	LNK180
	JMP	LINK98
	.ENDC			;ERTH13
	TSTB	PASS		;DON'T TRY TO ADVANCE
	BEQ	LNK164		;CSI PTR IN 1ST PASS
LNK168:	DECB	SCOUNT		;ADV CSI PTR THROUGH CLIB
	BLT	LNK165		;SYMTAB FILE SPECS IN 2ND PASS
	INCB	CLFLAG		;CURRENTLY PROCESSING CORE LIBS.
	TSTB	TAPES		;MORE SYMTABS COME. IN TAPES?
	BEQ	LNK166		;NO-
	DEC	TAPCT		;YES-REDUCE TAPE COUNT.
	BLE	LNK167		;END OF TAPE COUNT -GO CLEAR TAPES
	BR	LNK168		;GO TO REDUCE SCOUNT AGAIN

LNK165:	TSTB	TAPES		;LAST SYMTAB COUNTED.FROM TAPES?
	BEQ	LNK164		;NO- START PROCESSING TASKS
	TSTB	CLFLAG		;YES-CLFLAG ON?
	BEQ	LNK164		;NO- START PROCESSING TASKS
	CLRB	CLFLAG		;YES-CLEAR CLFLAG
	TST	TAPCT		;IS TAPE COUNT=0?
	BNE	LNK164		;NO-
	CLRB	TAPES		;YES- CLEAR TAPES
	BR	LNK164		;PROCESS TASKS
LNK167:	CLRB	TAPES		;CLEAR TAPES
LNK166:	TST	SCSIRV		;END OF CSI LINE?
	BNE	.+6		;YES-
	JMP	LINK89		;NO-ISSUE DUMMY CALL TO CSI2
	INCB	FLINE		;INDICATE THAT CURRENT CSI LINE
				;IS NOT THE 1ST LINE
	BR	LINK73		;GO GET NEXT CSI LINE
LNK164:TSTB	LIBF		;TEST LIB. FLAG
	BNE	LNK02
	TSTB	PASS
	BEQ	.+6
	JMP	LINK40		;PASS 2
	GGSD			;GET GSD
LINK97:	TSTB	TAPES		; DOING TAPES ?
	BEQ	LINK98		; NO-
	DEC	TAPCT		;YES- DECREMENT COUNTER
	BGT	LINK90		; IF >0 , DO ANOTHER TAPE
	CLRB	TAPES
;
;  PROCESS POST SWITCHES
;
LINK98:	CLRB	CONCAT		;NO MORE CONCATENATION
	MOV	#OBJDEV+8.,R1	; ADR OF FIRST SWITCH
LINK99:	TST	(R1)		; DONE WITH SWITCHES ?
	BEQ	LINK70		; YES-
	MOV	#POSTSW,R0
	SWSR
	TST	R0		; FIND IT ?
	BNE	LINK71		; YES-
;
; 2 ILLEGAL SWITCH!!
;
	ERR19	
	BR	LINK79
LINmغT	C,(R0)		; PROCESS THE SWITCH
LINK79:	MOV	(R1),-(SP)
	4	Qt0bD)W,R1	;L^c+2*N
	TST	(R1)+
	BR	LINn\; DO lTASWITCH
;
;   CHECK FOR END OF COMMAND STRINE;LINK70:	TST	SCSIRV	.C堥ETURN VALUE FROM CSICE	D̓NK72		; END-
	Sh	3i		; NEF3e:	INCBcLDw COUNT TO lTALINEBjSBhAS		; $Ñ PASS?
	BNE	LINK73		; PASS 2-
	JMP	LINK80		; PASS 1-
LINK73:	TSTB	FORTRF		;CS FROM FORTRAN?
	BEQ	1$		;NO-
	SUB	#20.,CMDBUF	;YES-
	BR	2$
1$:	SUB	#BUF,CMDBUF
2$:	MOV	CMDBUF,-(SP)
	JMP	LINK82
	.EOT


;TAPE 5

;
;   PROCESSING FOR)EWITCHES
;
;   DISPATCH TABLE
;
PRESW:	.BYTE 'T,0		;TOP
	+LINK68
	.BYTE 'B,0		;BOTTOM
	+LINK67
	.BYTE	'L,0		;LIBRARY
	+LINK06
	.BYTE 'O,'D		;DDT
	+LINK65
	.BYTE 'T,'R		;TRANSFER ADDRESS
	+LINK69
	.BYTE 'T,'A		;TAPES
	+LINK58
	.BYTE 'C,'C		;CONCATENATED FILE
	+LINK74
	.BYTE	'O,'V		;OVERLAY
	+LNK194
	.BYTE	'I,'D		;IDENT
	+LNK196
	.IFDF	RTH		;BRTH24
	.BYTE	'R,'T		;RTH
	+LNK175
	.ENDC			;ERTH24
	-1			;END OF TABLE
BEGSTB:	INCB	SCOUNT		;INCREMENT SYMTAB COUNT
	TSTB	NSTBF		;READ A TASK ALREADY?
	BEQ	.+4		;NO-OK
	ERR24			;YES-ERROR
	CMP	(R0),#2		;ANY SYMTAB TO INPUT?
	BLO	LNK153		;NO-
	MOV	SYME,R3		;YES-
LNK154:	CMPB	#STBEND,(R1)	;REACHED END OF SYMTAB?
	BEQ	LNK153		;YES-
	CMPB	#STBBLK,(R1)	;NO-SYMTAB BLOCK?
	BEQ	.+4		;YES-OK
	ERR25			;NO-ERROR
	MOV	R3,-(SP)
	ADD	(R0),(SP)

	CMP	(SP),ENDM	;CLEAN STACK LATER
	BLOS	.+4		;THERE IS ROOM FOR BLOCK
	ERR18			;S223, NO ROOM FOR BLOCK.
	TST	(R1)+		;IGNORE CONTROL INFO.
	SUB	#4,(SP)		;UPDATE BC
LNK156:	CMP	R3,(SP)		;STB BLOCK COMPLETED?
	BHI	LNK155		;YES-GO GET ANOTHER BLOCK.
	MOV	(R1)+,(R3)+	;NO-TRANSFER 1 WORD
	BR	LNK156		;GO CHECK, BLOCK FINISHED?
LNK155:	IOIG			;GET ANOTHER BLOCK
	TST	(SP)+		;CLEAN STACK NOW
	BR	LNK154		;GO PROCESS NEW BLOCK.
LNK153:	IOIC			;CLOSE INPUT FILE
	TST	-(R3)
	MOV	R3,SYMC		;UPDATE
	MOV	R3,SYME		;SYMBOL TABLE
	MOV	R3,USYME	;POINTERS
	MOV	(R3),TOPMEM	;SET DEFAULT TOP OF MEM
	RESREG			;SAVREG IN GGSD
	RTS	PC
;
;TOP
;
LINK68:	TSTB	PASS

	BNE	LNK01		;GET OUT IF PASS 2
	ONEVAL
	.O2BIN	2(R1)		;CONVERT OCTAL TO BINARY
	INCB	TOPF
	CLRB	BOTF
	MOV	(SP),TOPMEM	;SET NEW TOP
	ASR	(SP)+
	BCC	.+4
	ERR19
LNK04:	TST	(SP)+		;IGNORE PTR TO ASCII.
LNK01:LNK11:
	MOV	(R1),-(SP)	;FORM ADDRESS OF SWITCH
	ASL	(SP)
	ADD	R1,(SP)
	CLR	@(SP)+		;CLEAR THE SWITCH
LINK02:	RTS	PC
	.IFDF	RTH		;BRTH14
;
;REAL TIME
;
LNK175:	MOV	R1,R2		;SAVE PTR TO SW SIZE
	MOV	(R1),R5
	CMP	R5,#SWSMAX
	BLE	.+4
	ERR14
	ASL	R5
	JMP	@SWSDT(R5)	;GO TO PROPER SWITCH VALUE
SWSDT:	+SWSER,SWS1,SWS2,SWS3,SWS4,SWS5,SWS6
SWS6:	MOV	#SS,R3		;NO-PROCESS STACK SIZE
	MOV	#SWS5,RTADR
	RTVALS
	INCB	CSISS		;SS FROM CSI
	MOV	SS,-(SP)	;ODD STACK SIZE ?
	ASR	(SP)+
	BCC	SWS5		;EVEN
	INC	SS		;ODD, MAKE EVEN
SWS5:	MOV	#MT,R3
	MOV	#SWS4,RTADR	;PROCESS MAX TIME
	RTVALS
	INCB	CSIMT		;MT FROM CSI
SWS4:	MOV	#CN,R3
	MOV	#SWS3,RTADR	;PROCESS CALL NO
	RTVALS
	INCB	CSICN		;CN FROM CSI
SWS3:	MOV	#PRIOR,R3
	MOV	#ENDCH,RTADR	;PROCESS PRIORITY
	RTVALS
	INCB	CSIP		;PRIOR FROM CSI
ENDCH:	TST	-2(R3)		;PRIORITY < OR = 0?
	BLE	.+12		;YES-ERROR
	CMP	#4,-2(R3)	;NO-PRIORITY >4?
	BGE	SWS2		;NO-OK
	ERR27			;YES-ERROR
SWSER:	MOV	#REMDER,R0	;PRINT /RT SW REMINDER
	TYPE
	TST	(SP)+
	MOV	CMDBUF,-(SP)	;ASK FOR CSI AGAIN
	JMP	LINK81
SWS2:	MOV	#NAM1,R3
	CMPB	#72,@2(R1)	;IS VALUE:?
	BEQ	FIXFL		;YES
	MOV	2(R1),-(SP)	;NO- PROCESS NAME
	MOV	#RATOBI,-(SP)	;DO A RADIX 50 PACK
	EMT	CONV
	MOV	(SP)+,(R3)+
	MOV	#RATOBI,-(SP)	;2ND WORD
	EMT	CONV
	MOV	(SP)+,(R3)+
	TST	(SP)+
	INCB	CSIN		;NAME FROM CSI
FIXFL:	INCB	RTNOVA

SWS1:	INCB	RTF
	TST	OBJADR		;FILE NAME GIVEN?
	BEQ	.+4		;NO-
	BR	SAVPTR		;YES-DO IO
	MOV	#106,-(SP)	;NO-GET SYSTEM DEV.
	EMT	41
	CMP	(SP)+,OBJDEV+6	;SYST DEV=CURRENT INP DEV?
	BEQ	.+4
	BR	SAVPTR		;NO- DO IO
	INCB	NOIOF		;YES-NO IO
	MOV	#44,RTHSIZ	;SET RTH SIZE.
	BR	CLRSW
SAVPTR:	TSTB	PASS		;SET PTR TO RTH IN SYMTAB
	BNE	.+10
	MOV	SYME,RTHPTR
CLRSW:	TSTB	RTNOVA
	BNE	.+4
	TST	-(R1)
	CLRB	RTNOVA
	CMP	(R1)+,(R1)+	;CLEAR THE SWITCH
	CLR	(R1)
	RTS	PC
	.ENDC			;ERTH14
;
;	IDENT
;
;	IF THIS SWITCH IS SET WITH THE 1ST INPUT FILE SPECIFICATION
;	THEN THE .IDENT FROM THIS SPECIFICATION IS PUT INTO THE
;	LINKER'S SYMBOL TABPA&O& AND ALL SţgTNĮDENTS ARE IGNORED BY THE LINKEK$. THEY ARE NEITHER
baϡ1b NTO THE SYMBOL TABLEAΩED IN THE LOAD MAP
;
LNK196:	INCB	IDF		;SET ID FLAG
	NOVAL
	JMP	LI1C;
;  BOTTOM
;
LINK67:	TSTB	PASS
	SNK176		;IGNORE 1PSS 2 TP SETϝEVAL
	.O2Rg	e(R1)	.ϝVERT OCTAL TO BINARY
	INCB	BOTF		;qj LAG ACLRB	TOPFBfϭ	(SP),BOTMEM	;    VALUE
	ASR	)W
	BCbW+i
	ERR19
2LINK04		;R*ҝ
LNK176:	JMP	L1;
;	OVERlcELK194:	INCB	OVLF		;SE'֙F FLAE	UB	#BUF,ENDM	;PSIE SPACE FOR 1ST CSI BUF
				;FOR 1ST OV#IE OF 4χ LINKԧЃSS
	BNE	LNK176		;IGNORE IF PAt2	ONEVAL
	.D2BIN	2(LT;CONVERT D̓L TO RgAY
	MOV	(S
UVLC	;qj OUNT
	JMP3$Η04		;QjUN
	INBLN=3-NA
;
;	LIBRAR#E;LINK	NCB	FREADF		;THIS IS THE 1ST READ
	INCB	LIBF		;SET LIB FLAG
	MOV	R1,SWSIZE	;SAVE PTR TO SW SIZE
	NOVAL
	MOV	(SP),SPRETV	;SAVE STACK RET VALUE
	TSTB	PASS

	BEQ	LNK129
	.IFDF	BLKIO
	JSR	PC,INITRD	;INIT INPUT DATA SET
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV		;INIT OBJ. MOD. DATA SET
	.ENDC
	MOV	#ERRETL,OBJADR-4
	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4	;SET DEFAULT EXT
	.=.-4
	.RAD50	/OBJ/
	.=.+2
DOOVER:
	.IFDF	BLKIO
	JSR	PC,OPENRD	;OPEN THE READ DATA SET
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
	BR	LINK07
ERRETL:	CMP	#401,OBJADR+6
	BNE	.+14
	CLR	OBJADR-4
	CLR	OBJADR+6
	BR	DOOVER
	MOV	#401,OBJADR+6
	BR	DOOVER
LNK129:	MOVTAB
	MOV	#INA,IN
	.IFDF	BLKIO
	JSR	PC,READIT	;DO A
	.ENDC
	.IFNDF	BLKIO

	.READ	#OBJDEV,#INA
	.WAIT	#OBJDEV
	.ENDC
LINK41:	TSTB	FREADF		;LOOP,1ST READ COMMING?
	BEQ	LINK96		;NO-
	CLRB	FREADF		;CLEAR 1ST READ FLAG
LINK23:	MOV	IN,-(SP)
	ADD	#INBLN,(SP)
	CMP	(SP)+,#INB
	BLOS	LNK109
LNK105:
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.ENDC
	MOV	#INA,IN
	BR	LINK96
LNK109:
	.IFDF	BLKIO
	JSR	PC,READIU
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INB
	.ENDC
	MOV	#INB,IN
LINK96:
	.IFNDF	BLKIO
	.WAIT	#OBJDEV
	.ENDC
	MOV	IN,R0
	CMP	(R0)+,(R0)+	;IGNORE FORM. BIN. CODE
	READER
	MOV	(R0)+,BC	;GET BYTE COUNT
	NEG	BC		;GET  -BC
	CMP	#10,(R0)	;DIR ENDED?
	BEQ	LINK26		;YES-GET OUT
	CMP	#1,(R0)		;GSD BLOCK?
	BNE	LINK23		;NO-
	ADD	#7,R0		;YES-OBJ MOD NAME BLOCK?
	MOVB	(R0)+,HBYTE
	CMPB	HBYTE,#0
	BNE	LNK100		;NO-
	MOV	-6(R0),FNAME	;YES-SAVE CURRENT OBJ MOD. NAME
	MOV	-4(R0),SNAME	;IN DIRECTORY
	MOV	IN,INSAVE
	INCB	FBBF		;MARK THIS BLOCK AS 1ST READ
LNK100:	TST	(R0)+		;
	ADD	#10,BC		;PREP BC
	MOV	R0,FDATA	;SAVE PTR TO 1ST DATA
	MOV	USYME,-(SP)
	MOV	SYME,-(SP)
	SUB	(SP)+,(SP)	;SAVE SYMTAB BC
	MOV	(SP)+,STBC
	NEG	STBC
	DIRSR
	TST	DIRSRV		;RET VAL: 0=FAIL,1=SUCCEED
	BEQ	LNK101		;FAILED-GO TO READ NEXT BLOCK
	BR	LNK102		;SUCCEEDED

LINK07:	JMP	LNK117
LINK26:	JMP	LNK110
LNK101:	TSTB	FBBF
	BEQ	LNK108
	CLRB	FBBF
	INCB	SBBF
	MOV	#2,CNT
	BR	LINK23
LNK108:	TSTB	SBBF
	BEQ	LINK23
	CLRB	SBBF
	BR	LINK23
LNK102:	TSTB	FBBF		;IS 1ST BB FLAG STILL ON?
	BNE	LNK103		;YES-GO GET GGSD,"IN" OK
	TSTB	SBBF
	BNE	LNK106
	BR	LNK107
LNK106:	MOV	IN,-(SP)
	MOV	INSAVE,IN
	MOV	(SP)+,INSAVE
	BR	LNK103
LNK107:	JSR	R5,RDEOT
	TSTB	TAPES
	BEQ	.+4
	ERR28
	IOIC			;CLOSE & RELEASE OBJ DEV
	.IFDF	BLKIO
	JSR	PC,INITRD
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV		;INIT,OPEN INPUT
	.ENDC
	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4

	.=.-4
	.RAD50	/OBJ/
	.=.+2
	.IFDF	BLKIO
	JSR	PC,OPENRD
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
LNK104:
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.WAIT	#OBJDEV
	.ENDC
	MOV	#INA,IN
	MOV	IN,R0
	CMP	(R0)+,(R0)+	;IGNORE 1ST 2 WORDS OF HEADER
	READER
	MOV	(R0)+,BC
	NEG	BC		;GET BC
	CMP	#1,(R0)+	;GSD BLOCK?
	BNE	LNK104		;NO-HADE TO BE GSD END
	CMP	(R0)+,FNAME	;YES-1ST PART OF SYMBOL MATCH?
	BNE	LNK104		;NO-
	CMP	(R0)+,SNAME	;YES-2ND PART OF SYM MATCH?
	BNE	LNK104		;NO-
	TSTB	(R0)+		;YES
	MOVB	(R0)+,HBYTE	;WAS SYMBOL OBJ MOD NAME?
	CMPB	HBYTE,#0

	BNE	LNK104		;NO-
LNK103:	GGSD			;YES-GO GET GGSD "IN" OK
	JMP	LINK96		;GO TO WAIT ON LAST READ
LNK110:	JSR	R5,RDEOT
	IOIC			;CLOSE & RELEASE OBJ DEV
	MOV	SWSIZE,R1	;SAVE PTR TO LIB SW SIZE
	MOV	(R1),-(SP)	;FORM ADDRESS OF SWITCH
	ASL	(SP)
	ADD	R1,(SP)
	CLR	@(SP)+		;CLEAR THE SWITCH
	MOV	SPRETV,(SP)	;RESTORE STACK RET VALUE
	RTS	PC
LNK117:	TSTB	FREADF		;1ST READ?
	BEQ	LNK10		;NO-
	CLRB	FREADF		;YES-
LNK08:	MOV	#INA,IN
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.WAIT	#OBJDEV
	.ENDC
	MOV	IN,R0
	CMP	(R0)+,(R0)+
	READER
	TST	(R0)+
	CMP	#10,(R0)
	BNE	LNK08
LNK09:
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.ENDC
	MOV	#INA,IN
LNK10:
	.IFNDF	BLKIO
	.WAIT	#OBJDEV
	.ENDC
	MOV	IN,R0
	ADD	#3,R0
	MOVB	(R0)+,HBYTE
	BITB	#100,HBYTE	;EOF OF LIBR SEEN?
	BNE	LNK110
	BITB	#EOF,HBYTE
	BEQ	.+4
	ERR15
	TST	(R0)+
	CMP	#1,(R0)		;GSD?
	BNE	LNK09		;NO-
	MOV	PTRG,R1		;YES-
	TST	(R0)+		;ADVANCE PTR IN READIN BUFF
	CMP	(R0)+,(R1)+	;1ST MATCH?
	BNE	LNK09		;NO-
	CMP	(R0)+,(R1)+	;YES-2ND MATCH ALSO?
	BNE	LNK09		;NO-
	TSTB	(R0)+
	MOVB	(R0)+,HBYTE
	CMPB	HBYTE,#0
	BNE	LNK09		;LIB ENTRY NOT OMN
LINK40:	.IFNDF	NOSEG
	CONTRL
	.WORD	8.		;OVERLAY #8
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	START8
	.ENDC
;
;	CC SWITCH--CONCATENATION
;

LINK74:	INCB	CONCAT
	NOVAL
	BR	LINK01

;
;  TAPES
;
LINK58:	ONEVAL
	.D2BIN	2(R1)		;CONVERT DECIMAL TO BINARY
	INCB	TAPES
	MOV	(SP)+,TAPCT	;SET COUNT
LINK04:	JMP	LNK04		;EXIT
LINK01:LINK11:	JMP	LNK01
;
;	TRANSFER ADDRESS
;
LINK69:	CMP	(R1),#2		;DOES IT HAVE A VALUE?
	BLO	LINK08		;NO VALUE-
	ONEVAL
	TSTB	PASS
	BNE	LINK01		;IGNORE IF PASS 2
	CMPB	@2(R1),#'A	;IS FIRST CHAR A # OR A LETTER?
	BLO	LINK09		;NUMBER-
	.RADPK	2(R1)		;DO A RAD50 PACK
	MOV	(SP)+,TRABLK+4
	MOV	#RATOBI,-(SP)	;SECOND WORD
	EMT	CONV
	MOV	(SP)+,TRABLK+6
	INCB	STRA
	INCB	TRAF
	BR	LINK04
;	NaELINK09:	.O2BIN	2(R1)		;CONVERT OCTAL
	MOV	(SP),TRA
	At
U0	ERR1#E	NCB	FTRA
	INCB	TRAF
	BR3$Η04
L3q:	TSTB	PASS		;IGNORE ON PASS 2
	BNE	LINK11
2gC	UTRA
	BR	LINK11
;񢝉_PDBUG FILE
;
LINK65:2gC3T
	TSTB	PASS
	S3c
	NOf2gC1"T
	BR3$Η,F
;
;  PSŧSING   WITCHƊw
;  DISPATCH TABLE
;
POSTSW:	.BYTE	'E,0		;EXIT
	+LINK12
	.BYTE	'U,0		;UNDEFINES
	+LINK10
	.BYTE	'G,'O		;GO
	+LNK195
	.WORD	0		; PRESWITCH
	+LINK02
	-1			;END OF TABLE
;
;  U SWITCH- LIST UNDEFINES
;
LINK10:	NOVAL
	MOV	R0,-(SP)	;S50,R1
	MOV	R1,-(SP)
	MOV	SYME,R0
	MOV	R0,R1
	CMP	USYME,R0	;ANY UNDEFINES?
	BEQ	LINK03		;NO-
	JSR	PC,LINK14	;YES- GO PRINT THEM
LINK03:	MOV	(SP)+,R1
	MOV	(SP)+,R0
	JMP	LINK02		;EXIT
;
;  USE PART OF PMAP TO PRINT UNDEFINES
;
LINK14:	INCB	PMAP11
	SAVREG
	MOV	#PMAP84,R0	;PRINT HEADING
	TYPE
	MOV	R1,R0		;GET PTR TO END OF SYMBOLS
	.IFNDF	NOSEG
	CONTRL
	.WORD	7		;OVERLAY #7
	JMP	ENTRY2
	.ENDC

	.IFDF	NOSEG
	JMP	PMAP10
	.ENDC
;
;	GO
;
LNK195:	INCB	GOF		;SET GO FLAG


;
;	E SWITCH-FORCE UNDEFINES TO 0 AND PROCEED TO PASS 2.
;
LINK12:	NOVAL
	TST	(SP)+		;IGNORE RETURN ADDRESS
	TSTB	PASS
	BNE	LNK07		;SPECIAL ACTION ON PASS 2
	.IFNDF	NOSEG
	CONTRL
	.WORD	4
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	LINK13
	.ENDC
LNK07:
	.IFNDF	NOSEG
	CONTRL
	.WORD	9.		;OVERLAY #9
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	DONE
	.ENDC
	.IFNDF	NOSEG
	CONTRL
	.WORD	4		;OVERLAY #4
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	LINK13
	.ENDC
EXOVL4:	TSTB	MAPF		;WANT A MAP
	BEQ	.+4		;NO
	PMAP			;PRINT IT

;	DON'T PRINT IF A MAP WAS PRINTED
	TSTB	MAPF
	BNE	OUTPST
	.IFDF	RTH		;BRTH15
	TSTB	RTF
	BEQ	.+10
	MOV	#RTHB,R0
	TYPE
	.ENDC			;ERTH15
	MOV	#TRAM,R0
	TYPE

OUTPST:	TSTB	SYMTAB		;IS SYMBOL TABLE TO BE OUTPUT?
	BEQ	LINK29		;NO -
	MOV	#STBER,STBADR-4	;SETUP ERR RET
	.INIT	#STBDEV		;INIT SYMTAB OUTPUT
	TST	STBADR+4
	BNE	.+10
	MOV	#0,STBADR+4
	.=.-4
	.RAD50	/STB/
	.=.+2
	.DELET	#STBDEV,#STBADR
STBER:	CLR	STBADR-4
	INCB	STBOPF		;OPEN SYMTAB FILE
	TST	STBADR+4
	BNE	.+10
	MOV	#0,STBADR+4
	.=.-4
	.RAD50	/STB/
	.=.+2
	.OPEN	#STBDEV,#STBADR
OUTBL=OUTB-OUTA
	IOOI
	MOV	SYMB,R2		;SET UP SYMTAB POINTER.
	CMP	R2,SYME		;ANYTHING TO OUTPUT?
	BHIS	LINK28		;NO -
LNK148:	MOV	#9.,(R1)+	;PUT SYMTAB CODE
	INC	(R0)
	INC	(R0)		;INCREMENT BC

LNK149:	MOV	(R2)+,(R1)+	;MOVE ENTRY FROM
	MOV	(R2)+,(R1)+	;SYMTAB TO OUTPUT
	MOV	(R2)+,(R1)+	; BUFFER
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	ADD	#BPSYM,(R0)	;UPDATE BC
	MOV	(R0),-(SP)
	ADD	#BPSYM,(SP)	;IS COUNT + 10 <
	CMP	(SP)+,#172	;BUFFER LENGTH?
	BHI	LNK158		;YES -
	MOV	R2,-(SP)	;NO - IS CUMMULATING
	ADD	#BPSYM,(SP)	;COUNT + 10 < SYME?
	CMP	(SP)+,SYME
	BHI	.+4		;YES - GO TO OUTPUT BUFFER
	BR	LNK149		;NO - GO TO MOVE NEXT EXTRY
LNK158:	IOOP			;OUTPUT A BUFFER OF SYMTAB
	TSTB	IOOPER		;CHECK FOR OUTPUT ERROR
	BEQ	.+6
	JMP	LINK25
	MOV	R2,-(SP)	;IS CUMMULATIVE COUNT
	ADD	#BPSYM,(SP)	;+10. > SYME?
	CMP	(SP)+,SYME
	BLOS	LNK148		;NO - GO TO START TO FILL NEXT BUF
	MOV	LOWADR,-(SP)
	SUB	#2,(SP)
	MOV	#9.,(R1)+	;OUTPUT THE DEFAULT TOP
	ADD	#4,(R0)		;OF MEM AS THE LAST BLOCK
				;OF THE SYMBOL TABLE
	MOV	(SP)+,(R1)+
	IOOP
	TSTB	IOOPER
	BEQ	.+6
	JMP	LINK25
	MOV	#10.,(R1)+	;YES - PUT SYMTAB END CODE
	INC	(R0)
	INC	(R0)
	IOOP			;OUTPUT LAST BUFFER
	TSTB	IOOPER
	BEQ	.+6
	JMP	LINK25
;
;CLOSE SYMBOL TABLE FILE AND RELEASE DATA SET.
;
LINK28:	MOV	#STBDEV,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
	EMT	RELEASE
	CLRB	STBOPF
	CLRB	SYMTAB

LINK29:	TSTB	BELOW0
	BEQ	.+4
	ERR22
	INCB	PASS
	CLRB	FLINE		;BACK TO FIRST LINE
	.IFNDF	NOSEG		;OF CSI INPUT
	CONTRL
	.WORD	1		;OVERLAY #1
	JMP	ENTRY1
	.ENDC
	.IFDF	NOSEG
	JMP	START1
	.ENDC

;
;	LOAD MODULE OUTPUT ERROR--DIE
;
LINK25:	MOVB	IOOPER,HBYTE
	MOV	#CONVER,R0
	INCB	NOTINP
	ERR15

;
;	TRAP HANDLER AND JUMP TABLE
;
TRAPH:	MOV	@SP,2(SP)	;STACK RTN ADDRESS.
	SUB	#2,@SP		;FORM ADR OF TRAP INSTRUCTION
	MOV	@(SP)+,-(SP)	;GET TRAP INSTRUCTION.
	BIT	#1,(SP)		;ERROR DIAGNOSTIC?
	BNE	ERRMSG		;YES
	ADD	#JTABLE-TRAP,@SP	;GET TABLE INDEX.
	MOV	@(SP)+,PC	;GO TO SUBROUTINE.
ERRMSG:	SUB	#TRAP+1,(SP)	;GET TABLE POSITION
	CMP	(SP),#BIGMSG	;IS THIS A SPECIAL?
	BHI	1$		;YES
	ASL	(SP)		;TIMES TƊ1"	GԃB,(SP)	;AD)ԃUAӧ OF TABLE
3$:	CLR	-(SP)		;ISSFMOV	@2(SP),-(SP)	;TH&ŧpc	IOT
	ADD	#2,(SP)	.OT DISPATCH ADDRESS
	TST	@(SP)		;IS IT A SIMPLE RETURN?
	BNE	2$		;NO
5))W
	RTS	PC		;YES

2$:	MOV	@(SP)+,-(SP).ũ THE ROUTINE ADӧ
	JM`(P)+		q砯HERE THE Uqi ANTSLR:ADD	#BIGTAB-BIGMSG-1,(SP) ;GET ACTU3ADRESS¥	2$		;GO T*H ROUTINE
;
;	JUMP TABLE
;
U E:	JTCEUPACK=.-JT+		;MOD40 U ×
	.WORD	UNPA00ԟA=.-JT+TRADwA TO ASCII CONVERRSIOE	]WORD	'a0
SAVREG=.-JT+		;SAVE REGISTERS
	.WORD	SAVR00
RESREGʩ+TRAP"DESTOR)E4ES
	.WORD	RESR00
TXTPUT=.-JT+		;PUT INTO TXT BLOCcE	]WORD	TXTP0EGTPC=.+RAP			;GETҥENT Ph+AUE
	.WORD1ԡ00
T4"]-JT+TRAP		.YE A BUFFER ON TF.WORD5,Ћ00
SQUISH=.-JT+TRAP			;REMOVE WORDS FROM TABLE
	.WORD	SQUI00
UNSQUISH=.-JT+TRAP			;MAKE A HOLE IN TABLE
	.WORD	UNSQ00
PMAP=.-JT+TRAP			;PRINT LOAD MAP
	.WORD	PMAP00
MAPTYP=.-JT+TRAP		;TYPE ON MAP DEVICE
	.WORD	MAPT00
IOII=.-JT+TRAP			;OBJ MODULE INPUT INIT.
	.WORD	IOII00
IOIG=.-JT+TRAP			;OBJ MODULE INPUT GET
	.WORD	IOIG00
IOIC=.-JT+TRAP			;OBJ MODULE INPUT CLOSE AND RELEASE
	.WORD	IOIC00
IOOI=.-JT+TRAP			;LOAD MODULE OUTPUT INIT
	.WORD	IOOI00
IOOP=.-JT+TRAP			;LOAD MODULE OUTPUT PUT.
	.WORD	IOOP00
GGSD=.-JT+TRAP			;GET GSD
	.WORD	GGSD00
GNGSD=.-JT+TRAP			;GET NON-GSD BLOCK.
	.WORD	GNGS00
SRGLOB=.-JT+TRAP			;GET VALUE OF GLOBAL
	.WORD	SRGL00
PTGLOB=.-JT+TRAP			;GET PTR TO GLOBAL
	.WORD	PTGL00
INSYME=.-JT+TRAP			;INSERT AT SYME
	.WORD	INSY00
SRMODN=.-JT+TRAP			;SEARCH FOR MODULE NAME
	.WORD	SRMO00
INUSYM=.-JT+TRAP			;INSERT UNDEFINED SYMBOL
	.WORD	INUS00
SYMOVF=.-JT+TRAP			;CHECK FOR SYMBOL OVERFLOW (FATAL)
	.WORD	SYMO00
GETSEC=.-JT+TRAP			;GET SECTION NAME POINTER

	.WORD	GETS00
SWSR=.-JT+TRAP		;SWITCH SEARCH
	.WORD	SWSR00
INPTRH=.-JT+TRAP	;INSERT AT PTRH
	.WORD	INPT00
DIRSR=.-JT+TRAP		;DIRECTORY SEARCH
	.WORD	DIRS00
MOVTAB=.-JT+TRAP
	.WORD	MOVT00
NOVAL=.-JT+TRAP
	.WORD	NOV00
ONEVAL=.-JT+TRAP
	.WORD	ONEV00
READER=.-JT+TRAP
	.WORD	READ00
	.IFNDF	NOSEG
CONTRL=.-JT+TRAP		;RUN TIME OVERLAY CONTROLLER.
	.WORD	SUBR46
	.ENDC
	.IFDF	RTH		;BRTH23
RTVALS=.-JT+TRAP		;CONVERTS AND SAVES
	.WORD	RTVA00		;VALUES OF /RT SW
CONSAV=.-JT+TRAP		;CONVERTS & SAVES
	.WORD	CONS00		;VALUES OF SWITCHES.
	.ENDC			;ERTH23

;
;ERROR MESSAGE PROTOTYPES GO HERE
;
ERR02=TRAP+1
ERR03=ERR02+2
ERR04=ERR03+2
ERR06=ERR04+2
ERR07=ERR06+2
ERR09=ERR07+2
ERR10=ERR09+2
ERR11=ERR10+2
ERR12=ERR11+2
ERR13=ERR12+2
ERR14=ERR13+2
ERR16=ERR14+2
ERR17=ERR16+2
ERR18=ERR17+2
ERR19=ERR18+2
ERR20=ERR19+2
ERR22=ERR20+2
ERR23=ERR22+2
ERR24=ERR23+2
ERR25=ERR24+2
ERR26=ERR25+2
ERR27=ERR26+2
ERR28=ERR27+2
;
;THE FOLLOWING MESSAGES HAVE SPECIAL HANDLING
;
BIGMSG=ERR28-TRAP
ERR01=BIGMSG+TRAP+2

ERR05=ERR01+2
ERR08=ERR05+2
ERR15=ERR08+2
ERR21=ERR15+2
;
;THE TABLE MSGTAB MUST PARALLEL THE ERROR TABLE EXACTLY IN ORDER
;
MSGTAB:
	2243,LINK	;2
	2213,ERMF	;3-NO GSD
	2214,ERMF	;4-FIRST IN GSD NOT OBJ MOD. NAME
	1324,0		;6-TOO MANY CSECT ENTRIES
	2210,ERMF	;7-SYMBOL TABLE ERROR
	2211,ERMF	;9-GLOBAL SEARCH FAILURE IN RLD
	2212,ERMF	;10-PC MOD NOT LAST IN RLD
	2215,ERMF	;11-CAN'T FIND SECTION NAME
	2216,LINK	;12-CAN'T FIND TRA
	2217,LINK	;13-CAN'T FIND SECTION FOR TRA
	2220,LINK	;14-JUMP INDEX OUT OF RANGE
	2226,LINK	;16-BAD SYNTAX IN CSI LINE
	2206,LINK	;17-MISSING INPUT SPEC
	2223,LINK	;18-NO ROOM IN CSI BUFFER
	2203,LINK	;19-TOO MANY SWITCHES
	2204,LINK	;20
	2205,LINK	;22
	1322,0		;23
	2250,LINK	;24-BAD CORE LIB. POSITION
	2253,LINK	;25-CATCH ALL
	1323,0		;26-CSECT TOO LARGE
	1325,0		;27-BAD RTH
	2255,LINK	;28-

BIGTAB:	ER0100		;1-SYMBOL OVERFLOW
	ER0500		;5-MODULE NAME NOT UNIQUE
	ER0800		;8
	ER1500		;15
	.IFNDF	RSX
	ER2100		;21
	.ENDC
	.EOT




;TAPE 6
RDEOT:	TSTB	TAPES		;PAPER TAPE LIBRARY?
	BEQ	CLREL		;NO-GO TO CLOSE & RELEASE
REREAD:	IOIG			;YES-READ UNTIL EOT.
	.IFNDF	BLKIO
	.WAIT	#OBJDEV
	.ENDC
	BITB	#EOF,-1(R0)	;END OF TAPE?
	BEQ	REREAD		;NO-KEEP ON READING
CLREL:	RTS	R5		;YES-CLOSE & RELEASE OBJ DEV
MOVT00:	SAVREG
	MOV	ENDM,D1


	SUB	USYME,D1


	MOV	USYME,D2


	SUB	SP,D2

	MOV	USYME,R4
	MOV	R4,R0
	MOV	D1,R1
	ADD	R1,R0		;R0 CONTAINS NEW USYME
	ASR	R1		;INCREMENTS IN WORDS
	MOV	D2,R2
	ASR	R2
	BGT	LINK87		;DONE?
LINK88:	ASL	R1		;YES-
	ADD	R1,SP
	ADD	R1,SB
	;
	;	RESET STACK BASE TO NEW VALUE
	;	IN THE MONITOR SYSTEM VECTOR TABLE
	;
	MOV	SB,-(SP)	;NEW STACK BASE ON THE STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;CLEAN RETURN VALUE FROM STACK
	;
	;
	ADD	R1,SSYMB
	ADD	R1,SASYME
	ADD	R1,SYMB
	ADD	R1,SYMC
	ADD	R1,SYME
	ADD	R1,SSYME

	ADD	R1,USYME
	ADD	R1,PTRG
	ADD	R1,PTRH
	.IFDF	RTH		;BRTH16
	ADD	R1,RTHPTR
	.ENDC			;ERTH16
	BR	LNK132
LNK138:	RESREG
	RTS	PC
LINK87:	MOV	-(R4),-(R0)	;NO-
	DEC	R2
	BGT	LINK87
	BR	LINK88
ERRET1:	CMP	#401,OBJADR+6
	BNE	.+14
	CLR	OBJADR-4
	CLR	OBJADR+6
	BR	LNK144
	MOV	#401,OBJADR+6
	BR	LNK144
LNK132:	TSTB	FLAG
	BNE	LNK138
	.IFDF	BLKIO
	JSR	PC,INITRD
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV
	.ENDC
	JSR	PC,DEVCH
	TSTB	ODTF
	BNE	LNK192
	TSTB	LIBF
	BEQ	LNK143
LNK192:	MOV	#ERRET1,OBJADR-4
	TST	OBJADR
	BNE	LNK143
	MOV	#57164,OBJADR

LNK143:	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4
	.=.-4
	.RAD50	/OBJ/
	.=.+2
LNK144:
	.IFDF	BLKIO
	JSR	PC,OPENRD
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
	CLR	OBJADR-4
	CLRB	ODTF
	MOV	#102,-(SP)
	EMT	FMS
	MOV	(SP)+,MONTOP
	ADD	#SPLEN,MONTOP
	MOV	SP,D1
	SUB	MONTOP,D1	;MON CHECKED FOR OVF ALREADY
	.IFNDF	RSX		;BRSX
	SUB	#1000,D1	;ALLOW FOR FILE MANAGER
	.ENDC			;ERSX
	BHIS	LINK34		;AT CLOSE TIME
	ERR18			;NO SPACE FOR FILE MANAGER
LINK34:	MOV	SP,R4
	MOV	R4,R0
	MOV	D1,R1
	SUB	R1,R0
	SUB	R1,SP
	SUB	R1,SB
	;
	;	RESET STACK BASE TO NEW VALUE
	;	IN THE MONITOR SYSTEM VECTTS"	;
	MOV	SB,-(SP)	;NEW STACK BASE ON THE STACK
	MOV	#4TS"]ҋ5bөċ
	EMcթ		;EMT CALL
	TST	(SP)+		pER RET ALUE FROM STACK
	;
	;
	SUB	R1,SSYMB
	SUB	LVSSYME
	SUB	R1,SYMB
4LVSMC
	SUB	R1,SYME
BiՅ4SYME
	SUB	R1,P4R1,PTRcD4H	;BRT[4R1,RTHPTRBWEDC			qiT-ƊASR	R#E	OV	D2,R2
	ASR	R2
	BLE	LNK134
LNK133:	MOV	(R4)+,(R0)+
	DEC	R2
	BGT	LNK133
LNK134:	RESREG
	RTS	PC

;
;	TEST FOR NO VALUE
;
NOV00:	CMP	(R1),#1
	BR	VALUE
;
;	TEST FOR ONE VALUE
;
ONEV00:	CMP	(R1),#2
VALUE:	BEQ	.+4
	ERR19
	RTS	PCNƊw	READ ERROR CHECK
;
READ00:	MOVB	-1(R0),-(SP)
	BIC	#-3-1,(SP)+
	BEQ	.+4
	ERR15
	BITB	#EOF,-1(R0)	;ERROR?
	BEQ	.+4
	ERR15			;YES -
	RTS	PC		;NO -
;
;	IO EXEC FOR OBJ MODULE AND LOAD MODULE
;
;
;	INPUT INIT
;
	INBLN=INB-INA

IOII00:
	MOV	#INA,IN		;SET INPUT BUFFER POINTER
;
;	INITIALIZE OBJECT MODULE DATA SET
;
	.IFDF	BLKIO
	JSR	PC,INITRD
	.ENDC
	.IFNDF	BLKIO
	.INIT	#OBJDEV
	.ENDC
	JSR	PC,DEVCH
;
;	OPEN OBJECT MODULE FILE
;
	TSTB	ODTF
	BEQ	LNK147
	MOV	#ERRET2,OBJADR-4
	TST	OBJADR
	BNE	LNK147
	MOV	#57164,OBJADR
LNK147:	TST	OBJADR+4
	BNE	.+10
	MOV	#0,OBJADR+4	;SET DEFAULT EXTENSION
	.=.-4
	.RAD50	/OBJ/
	.=.+2
LNK146:
	.IFDF	BLKIO
	JSR	PC,OPENRD
	.ENDC
	.IFNDF	BLKIO
	.OPEN	#OBJDEV,#OBJADR
	.ENDC
	CLR	OBJADR-4
	CLRB	ODTF
	.IFDF	BLKIO
	JSR	PC,READIT
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA	;START FIRST READ
	.ENDC
	BR	IOIG00

ERRET2:	CMP	#401,OBJADR+6
	BNE	.+14
	CLR	OBJADR-4
	CLR	OBJADR+6
	BR	LNK146
	MOV	#401,OBJADR+6
	BR	LNK146

;
;	INPUT GET
;
IOIG00:	MOV	R2,-(SP)	;SAVE R2
	MOV	IN,R2		;GET BUFFER POINTER
	MOV	R2,R0
	CMP	(R0)+,(R0)+	;SET R0 = IN+4
	MOV	R0,R1
	TST	(R1)+		;SET R1=IN+6
	ADD	#INBLN,R2	;ADVANCE POINTER TO NEXT BUFFER.
	CMP	R2,#INB		;TOO FAR?
	BLOS	IOIG01		;NO
	MOV	#INA,R2		;READ INTO INA
IOIG01:	MOV	R2,IN		;READ INTO INB
	.IFDF	BLKIO
	JSR	PC,XXREAD
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,R2
	.ENDC

	MOVB	-1(R0),R2	;GET LAST STATUS
	BIC	#-47-1,R2	;SAVE LOW 3 BITS, AND BIT 5
	BEQ	.+4
	ERR15
	MOV	(SP)+,R2	;RESTORE R2
	RTS	PC


;
;	SUBROUTINE IOIC
;
;	CLOSE INPUT FILE AND RELEASE INPUT DEVICE
;
;	CLOSE INPUT FILE
IOIC00:
	.IFDF	BLKIO
	JSR	PC,CLOSRD
	.ENDC
	.IFNDF	BLKIO
	MOV	#OBJDEV,-(SP)

	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE INPUT DEVICE
;
	EMT	RELEAS
	.ENDC
	RTS	PC

;
;	OUTPUT INIT
;
IOOI00:	CLRB	OUTB+3
IOOI02:	MOV	#OUTA,R0	;SET OUTPUT POINTER
	MOV	R0,OUT
IOOI01:	CMP	(R0)+,(R0)+	;R0=OUT+4
	CLR	(R0)		;INITIALIZE BC
	MOV	R0,R1
	TST	(R1)+		;R1=OUT+6
	TSTB	SYMTAB		;WHAT TO OUTPUT NEXT?
	BEQ	LNK161		;LOAD MODULE-
	MOV	STBDEV+6,TEST	;SYMTAB - PREPARE TO
	MOV	#STBDEV,PUT	;OUTPUT SYMTAB
	BR	LNK162
LNK161:	MOV	LODDEV+6,TEST	;PREPARE TO OUTPUT
	MOV	#LODDEV,PUT	;LOAD MODULE
LNK162:	RTS	PC
;
;	OUTPUT PUT
;

IOOP00:	MOV	OUT,R0		;GET PTR TO CURRENT BUFFER
	CLRB	IOOPER
	CMP	R0,#OUTA	;BUFFER A?
	BEQ	IOOP01
	TST	TEST		;ANY OUTPUT?
	BEQ	IOOP02		;NO--
	.WRITE	PUT,#OUTB
	MOVB	OUTA+3,IOOPER
	BR	IOOP02
IOOP01:	TST	TEST		;ANY OUTPUT?
	BEQ	IOOP02		;NO--
	.WRITE	PUT,#OUTA
	MOVB	OUTB+3,IOOPER
IOOP02:	BICB	#-147-1,IOOPER ;SAVE BITS 0,1,2,5,6
	ADD	#OUTBL,R0	;ADVANCE TO NEXT BUFFER
	MOV	R0,OUT
	CMP	R0,#OUTB	;TOO FAR
	BLOS	IOOI01		;NO
	BR	IOOI02		;YES


;
;	GNGSD--GET NON GSD BLOCK
;
GNGS00:	IOIG
	CMPB	#GSDBLK,(R1)	;GSD BLOCK?
	BEQ	GNGS00		;YES - IGNORE
	RTS	PC		;ELSE - EXIT.

;
;RESIDENT READ GSD
GGSD00:	.IFNDF	NOSEG
	CONTRL
	.WORD	5		;OVERLAY #5
	JMP	ENTRY1
	.ENDC

	.IFDF	NOSEG
	JMP	START5
	.ENDC


;
;	RESIDENT PRINT LOAD MAP
PMAP00:	.IFNDF	NOSEG
	CONTRL
	.WORD	7
	JMP	ENTRY1
	.ENDC

	.IFDF	NOSEG
	JMP	START7
	.ENDC

;
;	SWITCH SEARCH ROUTINE
;
;	INPUT-R0=ADR OF DISPATCH TABLE
;	     -R1=ADR OF SWITCH HEAD TO SEARCH FOR
;	OUTPUT-R0=ADR OF SWITCH ROUTINE. IF CAN'T FIND THE SWITCH,
;	          RETURN R0=0.
;
SWSR00:	SAVREG
	MOV	(R1),-(SP)
	ASL	(SP)		; SWITCH CHARACTERS
	ADD	(SP)+,R1
	CLR	(SP)		;INITIAL CLEAR OF SAVED R0
SWSR02:	CMP	(R1),(R0)+	;IS IT THIS ONE?
	BEQ	SWSR01		;YES-
	TST	(R0)+		;NO-SKIP ADR
	TST	(R0)		;END OF TABLE?
	BPL	SWSR02		;NO-
SWSR03:	RESREG		;YES-EXIT
	RTS	PC

SWSR01:	MOV	(R0),(SP)	;SET SAVED R0 TO ADDRESS
	BR	SWSR03		;  H&E	EIT.

;
biiE4ES
;

SAVR00:	MOV	R5,-(SP)	;pkEATHEM
	MOV	R4,-(SP)Bfϭ4[(SP)
	MOV	R2,-(SP)Bfϭ4[(SP)
	MOV	R0,-(SP)
	JMP	@12.(SP)	;EXIT.
;
;	RESTORE REGISTERS
;
EL:MOV	(SP)+,12.(SP)	;STACK RETURN ADDRESSBfϭ	(SP)+,R0	;RESTHEM
3g(SP)+	MOV	(SP)+	MOV	)W,R3
	MOV	(SP)+,R4
	MOV	(SP)+,R5
4SPC		;$;SUBROUTIPOOA (OCTAL TO ASCII CONVERSION)񢝉SSUMEbXA NUMBER INǓSTER ON EN0)
;		2)  BUFFSORAGE REQD(TA(R1)
;		3)  STACK TRTHER  A3RD REG.
;	ON $u    CONVERSION IN BUFFER, PTR AT NEXT BYFw		   ͅER REiԋH!̋ARED
;		    TOP OF STACK CLEAE;OTOA00:	MOV	#2230,-);SET LP CN cST DI!IS
OTOA01:0iR0		;j IT FROM NU]..
	SB@SP		;...&g֋ INTO ASCII DIG5BCC	Oc		;MARKER j T OTHEƊB,QR1)+	;IF SO STORE CHAR IN BUFFER
	MOVB	#23,@SP
	ASL	@SP		;DONE 6 DIGITS?
	BCC	OTOA01
	TST	(t	;YES-CLEAN UP STACK
	RTS	PC		;... & EXIT
;
;	RċNT LIBRARY SEARCH ROUTINE
DIRS00:	.IFNDF	NOSEG
	CONTRL
	.WORD	6		;OVERLAY #6
	JMP	ENTR,F.ENDC

	.IFDF	NOSEG
	JMP	START6
	.ENDC


;
;	MOD40 UNPACK
;
;	INPUT:	R0=ADR OF MOD4'UQi Q2 WORDS)
;		R1=ADR OF ASCII STRING (6 BYTES)
;
;	OUTPUT:	R1 POINTS ONE PAST LAST GENERAb HARACTER
;
;
;	IF N IS THE MOD40 NUMBER, TgbD{C1*50^2+C2*50+C3
;	THUS, N/50^2 IS C1 AND THE REMAINDER IS C2*50+C3
;	THE REMAINDER IS D5ċ!YA50 TO GET C2 ETC.
;
UNPA00:	SAVREG
	MOV	#-K)4	;MAJOR LOOP COUNT
UNPA07:	MOV	#-3,R5		sdΟH&OP COUNT
	MOV	(R0),R0		;GET MOD40 WORD
3g#COEFF,R2	;PTR TO COEFFICIENT TABLE
UNPA06:	CLR	R3		;0 QUOTIENT
;	DIVIDE BY COEFFICIENTS

U eBa͡	R0,(R2)	;DONE WITH DIVIDE
	BLO	UNPA01	.ŧ
	SUB	(R2),R0		;NO-SUBTRACT COEFF.
	INC	R3		;ADDPT QUOTIENT
	BR	UNPA02
;	DIVIDE DONE.  Q )3Y REMAINDER IN R0
;	CONVERT TO AN ASCII CHARACTER

UNPA01:	TSTB	R3
	BEQ	UNPA03		;"BLANK"
	CMPB	R3,#33
	BEQ	UNPA05		;"$"
	BGT	UNPA04		;"." OR "0-9"
	ADD	#40,R3		;"A-Z"
UNPA03:	ADD	#16,R3
UNPA04:	ADD	#11,R3
UNPA05:	ADD	#11,R3
	MOVB4QR1)+	;STORE CHARACTER
	TST	(R2)+		;ADVANCE TO NEXT COEFF.
	INC	R5		;DONE 3 CHARS?
	BLT	UNPA06		;NO-DO MORE
	MOV	(SP),R0		;RESTORE ORIGINAL R0 AND
	TST	(R0)+		;MOVE TO NEXT WORD

	INC	R4		;DONE 2 WORDS
	BLT	UNPA07		;NO

;	DONE--PUT CURRENT R1 ONTO THE STACK
	MOV	R1,2(SP)
	RESREG
	RTS	PC
;
;	COEFFICIENT TABLE
;
COEFF:	+1600.			;40.^2
	+40.			;40.^1
	+1.			;40.^0


;
;	SUBROUTINE TXTPUT
;
;	PUT INFO INTO TXT BLOCK
;	THE RLD COMMAND IS STACKED
;
;		THIS ROUTINE REMOVES 1 WORD
;		FROM THE STACK,SP

TXTP00:	TST	2(SP)		;BYTE OR WORD COMMAND
	BMI	TXTP01		;GO IF BYTE COMMAND.
	MOVB	R4,(R3)+	;PUT IN FIRST BYTE
	SWAB	R4		;PREPARE FOR SECOND BYTE.
TXTP01:	MOVB	R4,(R3)+	;PUT IN BYTE
	TST	2(SP)		;BYTE OR WORD?
	BPL	TXTP02		;WORD
	SWAB	R4
	BEQ	TXTP02		;OK.
	ERR08			; BYTE RELOC ERROR!
TXTP02:  
	MOV	(SP)+,(SP)	;MOVE RETURN ADDRESS DOWN
	RTS	PC		;RETURN

;
;	SUBROUTINE GETPC
;	GET PC FOR CURRENT PLACE IN TXT BLOCK
;
GETP00:	MOV	CURPC,R4	;GET PC AT ENTRY TO BLOCK
	ADD	OFFSET,R4	;ADD CURRENT PLACE.
	RTS	PC

;
;	SYMOVF---SYMBOL TABLE OVERFLOW CHECK
;
SYMO00:	MOV	ENDM,-(SP)
	SUB	#BPSYM,(SP)
	CMP	USYME,(SP)+

	BLO	SYMO01
	ERR01			;DIE!!
SYMO01:	RTS	PC		;OK.

;
;	SRMODN---SEARCH FOR A MODULE NAME.
;
;	INPUT:	R4 POINTS TO MOD4O NAME
;	OUTPUT: R4 POINTS TO THE NAME IF FOUND
;
;	CALL:	SRMODN
;		BR		;FOUND
;		BR		;NOT FOUND
;
SRMO00:	SAVREG	
	MOV	SYMB,R0		;GET POINTER TO START OF TABLE
SRMO01:	CMP	R0,SYME		;DONE
	BLO	SRMO02		;NO
	RESREG			;YES - NOT FOUND
	ADD	#2,(SP)		;ADJUST RETURN ADDRESS
	RTS	PC		;EXIT
SRMO02:	CMPB	#OBJMN,FLAGS+1(R0) ;IS THIS AN OBJ MODULE NAME?
	BEQ	SRMO03		;YES - SEE IF NAME IS SAME
SRMO04:	ADD	#BPSYM,R0	;NO - TRY NEXT ONE
	BR	SRMO01
SRMO03:	CMP	(R4),(R0)	;FIRST WORD OK?
	BNE	SRMO04		;NO - GO TO NEXT ENTRY
	CMP	2(R4),2(R0)	;SECOND WORD OK?
	BNE	SRMO04		;NO - GO TO NEXT ENTRY
;	FOUND!!
	MOV	R0,8.(SP)	;PUT CURRENT R0 ONTO STACK
	RESREG
	RTS	PC

;
;	PTGLOB---SEARCH FOR GLOBAL & RETURN A POINTER TO IT.
;
;	INPUT:  R4=POINTER TO NAME
;	OUTPUT:  R4=POINTER TO ENTRY IF FOUND.
;
;	CALL	PTGLOB
;
;		BR		;NOT FOUND
;		BR		;FOUND

PTGL00:	SAVREG
	MOV	(R4),R0		;IS THIS THE SPECIAL
	BIS	2(R4),R0	;CASE OF 6 BLANKS?
	BEQ	PTGL01		;YES
	MOV	SYMB,R0		;SET LIMITS FOR SEARCH
	BR	PTGL02
PTGL01:	MOV	PTRG,R0		;START AT CURRENT OBJ MODULE IF 6 BLANKS
PTGL02:	CMP	R0,USYME	;DONE SEARCHING
	BLO	PTGL03		;NO-
	RESREG			;YES - EXIT
	RTS	PC
PTGL03:	CMP	(R4),(R0)	;CHECK FIRST WORD
	BNE	PTGL04		;NO MATCH.
	CMP	2(R4),2(R0)	;TRY SECOND WORD
	BNE	PTGL04		;NO MATCH.
;	MATCH---
	CMPB	#OBJMN,FLAGS+1(R0) ;FILTER OUT OBJ MODULE NAMES.
	BEQ	PTGL04
	MOV	R0,8.(SP)
	RESREG
	ADD	#2,(SP)
	RTS	PC
;	NO MATCH--
PTGL04:	ADD	#BPSYM,R0	;ADVANCE R0 TO NEXT ENTRY
	BR	PTGL02		;TRY AGAIN.
;
;	GETSEC--GET POINTER TO SECTION NAME.
;
;	INPUT:  R4 PTS TO NAME.
;	OUTPUT:  R4 PTS TO PROPER ENTRY
;
;	CALL:	GETSEC
;		BR		;NOT FOUND

;
GETS00:	PTGLOB			;FIND GLOBAL NAME
GETS01:	RTS	PC		;NOT FOUND.
;	FOUND, INSURE THAT IT IS A SECTION NAME.
	CMPB	#SECTN,FLAGS+1(R4)
	BEQ	GETS02
	CMPB	#LOCAL,FLAGS+1(R4)
	BNE	GETS01		;NOT A SECTION NAME
GETS02:	ADD	#2,(SP)		;SECT NAME. ADJUST RETURN
	RTS	PC
	.EOT


;	TAPE 7
;
;	SRGLOB---SEARCH FOR GLOBAL AND RETURN VALUE IN R4
;
;	INPUT:  R4=ADR OF GLOBAL NAME
;	OUTPUT:  R4=VALUE
;
;	CALL	SRGLOB
;		BR		;NOT FOUND
;
;
SRGL00:	PTGLOB			;GET POINTER TO GLOBAL
	RTS	PC		;NOT FOUND
	MOV	BASE(R4),R4	;FETCH VALUE
	ADD	#2,(SP)
	RTS	PC		;EXIT

;
;	INUSYM--INSERT AS UNDEFINED
;
;	INPUT:  R4=ADR OFA'NSERT INTO UNDEFINEDiE
;
cEIUS00:	MOV	R0,-(SP)	;STACK R0
	MOV	USYME,R0
3g(R4)+,(R0)+	;MOVE IN$EAUNDEFINED SYMBOL
	MOV	(R4)+,(R0)+
	MOV	(R4)kRa)+
	MOV	(MY(R0)+
	ADD	#BPSYM,Uvf	SYMOVF			;OVERFLOW?
	MOV	(S
U0
	RTS	PC
;
bdΧ3b;
;	3ťT AN R AT SYME.  R4 PgT TO THE EN;	ADJUST Ω3bND USYME
cE;CEISY00:4֥EG
	MOV	R)2	MOV	SYME,R4
INSY01:	UNSQUISH		;M2⠃'̋j YME
	ADD	pS)ٛE	YUSYME

	MOV	(R2)+,(R4)b]͟PI THE SYMBOL
	M2)+,(R4)+Bfϭ	(R2)+,(R4*Ɗ	QLY(R4)+
	SYMOVF			;SYAҍLOW?
	RESQc	RTS	PC
;񢝉ҩg NTRY AT (P)WBPSYM
;	INSERT THE ENTRY ALPHABETICALLY񢝉(ONTS TO THE ENTR#E;UPDATE POINTERS SYMEiٛE;INPT00:	SAVREG͟V	R4,LwSET P	MOV	PTRH,R4
INPT01B`ĉ(P3VRi.ԃRT LOOP LOOKING FOR  F SECTIONBD;OR AN ENTVPW0 oHN PRESENT 񢄉	;ENTVFsh	)ٛDaAFOR EO SYMBOLS
	BHIS2gP02
	shB ǧlTRi),#SYSNPT02
	CMTRi),(R2"DOUBLE PREC͡I	INP	BLO	INPT01
	CQR4),2);IF 1ST WORDS EQUAL,TRY 2ND WORDS
	BLOS	INPT01		;TRY AdNɝqiTAAT (RF*0eBa͡	R4,PTRG	;"A(TG IF INSERTING BELOW PTRG
	BHI	.+1E	DD	#BYPTRGBaRINSY0"DO INS )4CE;N՝tjɧH---MAKE A HOLE IN T0ENƊw2gPT:  R4 POI)HERE TO MAqPHLE.
;
CEUSQ00:4֥EG
		vfYR0	;SiC POINTER
	MOV	R0,R1
	ADD	#BPvf"]ԋST POINTERΧQ01:	sh	0,R4		;DONE?
	BHI	UNSQ02		;NO
	RESREG
	RTS4!UNSQ0N͟V	-(R0),-(R1)	;S'× MOVE͟V	-(R0),-(R1)
3g-(R0),-(R1)
	MOV	-(R0),-(R1)
	MOV	-(R0),-(R1)
	BR	UNSQ01		;DO NEXT ONE.NƊw	SQUISH---REMOVE AN ENTRYO TABLw
;	I*u  R4=ADR OF WHEQPT REMOPETRY
;

SQUI00:	SAVREG
	MOV	R4,R0
	MOV	#BPSYM,R1
	ADD	R1,R0
	ASR	R1
tja1:	CMi0YUSYME.OE
	BӣUI02	.O[-
	RE			;YES-EXIT
	U)C
SQUI02:	MOV	LVRe		;SET COUNTER = BPSYM/2TՓ03:	M0)+,(M;BLOCK TRANSFERċC	R2
	BGT	SQUI03
	BR	SQX1	;DO lTAONE.
;
;
;
;	COPY THE$YICAL DEVICE NAME
;	FROM THE MONITOR TO THE OBJDEV.
;	THIS WAY THE OBJDEV WILL BE CONSISTENT
bkɩH THE MONITOR I!E THE OBJDEV
;5AASSIGNED TO A SPECIFIC PHYSICAE;kIEQ"ևH:
	cD0KE	SR	PC,READST
	.ENDC
	.IӢFBLKIO
	.STAT	#DV
	.C	TST*)S+
	MOV	(SP)+,ORE+6
	TST	(SP)+
	RTS	PC

;0ΝMtǋcELKNM:	s'KMA-LNKNM-6		;<CRLF>LINK-11<CRLF>
	Ьԋ1Ӈ+LNKNV̝KNM-6
	.ASCII	$Η /
	VRSIOE	]BYTE	tL
LNKNMA:	.EVEN
;

;
;	BUFFER CONdΓNG "#"
;
NO:	+NOA-NO-6		;  #
	.BYTE	FASC,0񢄫OA-NO-6
	.ASCII	/#/
	.BYTE	VT
NOA:	.EVEN

;
;	SYMS iF-AFATAL񢝍ER010ӫB	#8.,R4		;PTR SMBOL
	MOV	PTRG	;ADR MDULE f	MOV(ӛA,R1
	UNPACK		.Ρ0堛ODULE NAME
	MOV	R4,R0
	MOV	#USMB,LFUNPACK			;UNPACK SYMBOL NAME
3g#USM,LTYPE			;TYPE MEtǋ
	ERL\	;RESTART

ERM΄͟V	#OBJADR,R0
	MOV	#ERFILA,R1
	UNPACK
	MOV	AR+4,CONVER
	CLR	CONVER+2
	MOV	#COբYL	GERFILB,R1
	UNP0	CLR	sVR
	MOV	OBJDEV+!ϝVER+2͟V	#COբYR0
		GERFILk)1	UNP0	MOV	#ERFIL,R0
	TYPE
	J̓Ɗw񢝉NME NOT UNIQUE
cEEX0u	MOV	LRa		;PTR TO NAMEBfϭ(ΝUA,R1
	UNa	MOV	#MNNU,R0
	TYPE
	CLR	-(t3g#1300TS)
	IRTS	PC
;
;	BYTE RELOCAgAERRORVFf;
ER0800:	SAVREG
	GETPC"DUT CUTΩ PC I'4
	SUB	#2,R4
	MOV	R4,-(t	MOV	lYc,-(SP#E	OT
	QiҋG
	RTS	PC"]ҋTURN

;
;	INPUT CHECKSUM ERS ϥ INPU!Ui iFOW
;
ER1:MOV	-J)0S,-(SP)
	BIC	#3@P
	Sa	SP
		G2202,-(SP)	;CODE=S202
	IOT
	TSTB	IE	NE	ER1501
	JMP	ERMF

ER150.ÙRB	NOTINP
	JMP	LINK񢄮ӢFRSX
ER2100:	MOV	TRNBLK+6,-(SP)
	BIC	#377,@SP
	SWAB	@tMOV	#L7Y-(SP)	;CODE=S20E	]CERROUT:	IOT			;PRIN"ҥMSSAGE.
	JMP	LIƊ

+ADF	RTH
;SOTINE U+AS: CONVERTS VALUES O)T;		    SWITCH Z SAVTEM
;		R3:sT3TR TO SAVE REGNĉ4:CONdΧ*RAEIT
Ra:	CMPBQe,@2(R1)		;IS VAbu?
	BDW14			;YES-
	TST	(R3)+
	TST	(R1)+BjS	(SP)+
	JMP	@RTADR
	CONSAV		"]Ο-CONVERT & SAVE
	TST	(R1*ƊRTS	PcE;OgEACONSAΡϝiT	SiALUE OF SWITCHES
;	4ONTAINS PTH*OApkEAREG.
CONS	QLT[)	MOV	#DET[(SP)
	EMT0έ͟TS)+,(R3)+
5))W
	RTS	PC
REMD+EMDRA-REMDER-6			;/R)AFORMAT REM3E
	.B5"ASC,0
	+RbR͉ER-6
	.BYTE	CR,LF
	.ASCII	'/RT:NAME:PRIORITY:CALL NO:MAX T3bO
	.ASCII	'STACK SIZE/E'
	.BYTE	CR,LF
REMDR.gU$Bu	+RTHiTB-6
	.BYTE	FASk	+RTHE-RTHB-6
	.ASCII	/RTH/
	.BYTE	CR,LF
R"kE񢄮NDC		.ҩH18
;
;	SUBRO$΋ TYPE
;
;	TYP&ӏ Fw		PTRg 0
;
TYPE00:	.ԋ	#OUTCMD,R0
	.WAIT	#OUTC
MAPRTS	PC		;Ej;
;	TYPE MSG ON MAP DEVICE
;"hT IN RE;MAPT	]WRITE	#MAPDEV,RE	]WAIT	#MAPDEV
	RjB#EOF,j)0S	;ANY ERROR?
	BEQ	MAPT03		;NO
	CMP	(R0)+,(R
U	INCB3ԓNP
	ERR15
;
;	DEF3k DATA SET gKAS'×kw
;
;	LINK BLOCK FOR KEYS҉ (INP;
	0·MD:	0
	.RAD50	/CMI/		;KE0D
	1񢄮AD50	/KB/		;KEYS҉

NƊw	LINKOK FOR TELETYPE ԡUT)
;
	0թsb:0
	.Pb5a	/CMO/		;TELETYPE
	#E	]RAD50+_		;TELETYPE;N̓NK BLOCK FOR MA"EICE (OUTPUT)
;
	0			;ERROR RETURN
MAPDEV:	0
	.Pb5a+DAP OUTPUT kIE
	1
	.RAD50	/LP/		;LINE PRINTER
;
;	LINK BLOCK FOR OBJECT MODULE (INPUT)
;
	0			;ERROR RETURN

OBJDEV:	0
	.RAD50	/I1/		;OBJECT MODULE INPUT DEVICE
	31.
	.RAD50	/PR/		;HIGH SPEED P.T. READER
	.=.+60.			;ROOM FOR 30 WORDS OF SWITCHES.
;
;	LINK BLOCK FOR LOAD MODULE (OUTPUT)
;
	0			;ERROR RETURN
LODDEV:	0
	.RAD50	/O1/		;LOAD MODULE OUTPUT DEVICE
	1
	.RAD50	/PP/		;HIGH SPEED P.T. PUNCH
;
;	LINK BLOCK FOR SYMBOL TABLE OUTPUT
;
	0
STBDEV:	0
	.RAD50	/STB/
	1
	.RAD50	/PP/
;
;	PTR BLOCKS FOR CSI2
;
;	LOAD MODULE
;
BLKO:	0			;FILLED IN DYNAMICALLY TO POINT
				;TO CURRENT CSI BUFFER
	+LODDEV
	+LODADR
;
;	MAP
;
BLKM:	0
	+MAPDEV
	+MAPADR
;
;	INPUT
;
BLKI:	0
	+OBJDEV
	+OBJADR
;
;	SYMBOL TABLE
;
BLKS:	0
	+STBDEV
	+STBADR
;
;	RUN BLOCK USED BY GET EMT
;
RUNBLK:	+ACTION			;ADDRESS OF ACTION WORD
	+LODADR			;ADDRESS OF FILE BLOCK
	+LODDEV			;ADDRESS OF LINK BLOCK



;
;	DEFINE 5 DATA SET FILE BLOCKS.
;
;
;	FILE BLOCK FOR MAP DEVICE
;
	0			;ERROR RETURN
	OPENO

MAPADR:	0
	0
	0
	0
	0
;
;	FILE BLOCK FOR OBJECT MODULE
;
	0			;ERROR RETURN
	OPENI
OBJADR:	0
	0
	0
	0
	0


;
;	FILE BLOCK FOR LOAD MODULE
;
	0			;ERROR RETURN
	OPENO
LODADR:	0
	0
	0
	0
	0
;
;	FILE BLOCK FOR SYMBOL TABLE OUTPUT FILE
;
	0
	OPENO
STBADR:	0
	0
	0
	0
	0
	.IFNDF	RSX
;
;	TRAN BLOCK
;
TRNBLK:	4			;STARTING BLOCK #
	0			;STARTING ADDRESS IN CORE
	100			;# OF WORDS, PRESET FOR DF
	4			;INPUT
	0			;FOR MONITOR USE
	.ENDC
;
;	DATA AREA
;

SB:	0			;STACK BASE
SYMB:	0			;SYMBOLS BEGINNING
SYMC:	0			;TASK SYMBOLS BEGINNING
SYME:	0			;SYMBOLS END
USYME:	0			;SYMBOLS END OF UNDEFINES
ENDM:	0
OVLTOP:	.WORD	0		;TOP OF OVERLAYS
OVLC:	.WORD	0		;THE NUMBER OF OVERLAY FILES
SSYMB:	.WORD	0		;SAVED RESIDENT SYMB,RES SYMB BEG
SASYME:	.WORD	0		;SAVED RESIDENT SYME
NOINIT:	.BYTE	0		;INIT OVERLAYS IF NON-ZERO
OVLF:	.BYTE	0		;CURRENT LOAD MODULE IS THE RESIDENT
FORTRF:	.BYTE	0		;COMMAND STRING FROM FORTRAN
CHAR:	.BYTE	0		;BYTE REGISTER USED TO OBTAIN
				;BYTE COUNT OF COMMAND STRING
				;FROM FORTRAN
	.EVEN
FORTBC:	.WORD	0		;FORTRAN COMMAND STING BYTE COUNT
BEGCS:	.WORD	0		;SAVED POINTER TO BEGINNING
				;OF FORTRAN COMMAND STING
;
;START OF DATA AREA WHICH IS CLEARED
;
STCLR:
;
	.IFNDF	RSX
MONLIB:	.BYTE	0		;MON LIB SEARCH FLAG
SECTIM:	.BYTE	0		;CHANGE "   " TO ".  "
LASTDB:	.BYTE	0		;LAST DIR BOX FLAG
	.ENDC
	.EVEN
PTRH:	0			;POINTER TO CURRENT SECTION
SSYME:	0			;SAVED SYME FOR PMAP
RTHPTR:	0			;POINTER TO PTH
PASS:	.BYTE	0		;PASS FLAG
MAPF:	.BYTE	0		;MAP LIST FLAG
				;MAP DEVICE CODE
IOOPER:	.BYTE	0		;OUTPUT MODULE ERROR FLAG
CONCAT:	.BYTE	0		;CONCATENATION FLAG
PTRG:	0			;PTR TO MODULE NAME
CURPC:	0			;CURRENT PC
PRSIZE:	0			;PROGRAM SIZE IN BYTES
PTSECT:	0			;PTR TO CURRENT SECTION LEADER
LOWADR:	0			;LOWEST ADDRESS LOADED.
PUTR0:	0			;SAVE AREA FOR R0,R1 OF
PUTR1:	0			;OUTPUT BUFFERS
T:	.BYTE	0		;T SWITCH (SEE LABEL LINKS7).
PMAP11:	.BYTE	0		;SWITCH FOR LISTING UNDEFINES

OFFSET:	0		;OFFSET FOR RLD TXT COMMAND.
TMP1:	0
				;LOAD MODULE DEVICE
TRAF:	.BYTE	0		;TRA FLAG (0=NONE SEEN YET)
TAPES:	.BYTE	0		;TAPES SWITCH
	TAPCT:	0			;TAPE COUNTER
SSP:	0		;SAVED SP FOR PMAP
BOTMEM:	0		;BOTTOM OF MEMOTY
TOPF:	.BYTE	0	;TOP SPECIFIED FLAG
BOTF:	.BYTE	0	;BOTTOM FLAG
GENDF:	0		;GSD END SEEN FLAG
DDTF:	.BYTE	0		;D SWITCH
SDDTRA:	.BYTE	0		;DDT TRA SEEN FLAG
FLINE:	.BYTE	0		;FIRST CSI LINE FLAG
UTRA:	.BYTE	0		;USE THIS FILE FOR TRA

FTRA:	.BYTE	0		;FORCED TRA
STRA:	.BYTE	0		;SYMBOLIC TRA
MAPOPF:	.BYTE	0		;MAP OPEN FLAG
LODOPF:	.BYTE	0		; LOAD MOD OPEN FLAG
FREADF:	.BYTE	0		;1ST READ FLAG
REINIT:	.BYTE	0		;INIT OR OPEN NEXT?
INTMOV:	.BYTE	0		;MOVE SYMTAB AWAY FROM NEWMT
FLAG:	.BYTE	0
LIBF:	.BYTE	0		;LIBRARY FLAG
FILEOR:	.BYTE	0		;DEVICE IS FILE ORIENTED
BELOW0:	.BYTE	0		;PROGRAM TO BE LINKED BELOW 0
ODTF:	.BYTE	0		;TRY TO OPEN ODT FILE
NOTINP:	.BYTE	0		;EOM NOT IN INPUT
NSTBF:	.BYTE	0		;1ST NON STB FILE WAS SEEN
STBOPF:	.BYTE	0		;SYMBOL TABLE DEVICE IS OPEN
NOMMS:	.BYTE	0		;NO OUTPUT, MAPE, OR SYMTAB
SYMTAB:	.BYTE	0		;SYMBOL TABLE OUTPUT FLAG
SCOUNT:	.BYTE	0		;# OF SYMTABS READ IN 1ST PASS
SAMECS:	.BYTE	0		;LARGER SIZE SAME NAMED CSECT F
CLFLAG:	.BYTE	0		;CURRENTLY PROCESSING COR LIBS
BIT2F:	.BYTE 0			;CSI2 FILLED IN SYSTEM DEV
				;FOR DEFAULT DEV
GOF:	.BYTE	0		;EXECUTE LOAD MODULE FLAG
IDF:	.BYTE	0		;ONLY HANDLE 1ST .IDENT
	.IFDF	RTH		;BRTH19
RTF:	.BYTE	0		;RTH
NOIOF:	.BYTE	0		;NO I/O.
RTNOVA:	.BYTE	0		;=1 IF /RT SW WITH NO VALUE
CSISS:	.BYTE	0		;STACK SIZE FROM CSI
CSIMT:	.BYTE	0		;MAX TIME FROM CSI
CSICN:	.BYTE	0		;CALL NO FROM CSI
CSIP:	.BYTE	0		;PRIORITY FROM CSI
CSIN:	.BYTE	0		;NAME FROM CSI
	.EVEN
;DO NOT SEPARATE NEXT 4 WORDS.
SS:	.WORD	0		;STACK SIZE
MT:	.WORD	0		;MAX TIME
CN:	.WORD	0		;CALL NO
PRIOR:	.WORD	0		;PRIORITY
NAM1:	.WORD	0		;LOAD MODULE
NAM2:	.WORD	0		;NAME
RTADR:	.WORD	0		;REG USED IN /RT SW PROCESSING
SLARTH:	.WORD	0		;RTH LOAD ADR
	.ENDC			;ERTH19
	.EVEN
TEST:	.WORD	0		;AID IN IOOP
PUT:	.WORD	0		;AID IN IOOP
D1:	0			;ENDM-USYME
D2:	0			;USYME-SYMB
FBBF:	0			;1ST BINARY BLOCK FLAG
SBBF:	0			;2ND BINARY BLOCK FLAG
FNAME:	0			;S5A4 ART OF O. M. N.
SNAME:	0			;SAVED 2ND PART OF O. M. N.
INSAVE:	0			;SAVED IN
CNT:	0			;COUNT FOR PREREAD BUFFERSUSIZ:	DwBUFFEH)ɵE FOR TRAN
NEWMT:	0			;NMNITOR'SPTEST:	0"DAVED VALUE OF SP
BCBWWRD	0	.CA 4SARCHCwDON'T SEPARATE NEXT 3 WORDS
LBYTE:	.BYTX	;LOW BYTE
HBYTE:	.BYTE	0		;HIBTE
CE:	0,0			;2 WORDS TO AID TO CONVERT
				;1 WORD FROM MOSVSTBnORD	0		;SAVED SYMTAB BC
קIZE:	҉,wpkE LIB SW SIZE
SPRETV:	.WORD	0		;STArRT VALUE
DIRSRV:	.WORD	0	.I SEARCH RET VALFDATA:	.WORD	0
STBC:	.WORD	0
թP:	.BYTE	0		;NO OUTPRQUESTED
NOBWBD	;NO OUTPU'OAMAP REQUESTED
T		;TO'AIOR
CMDBUF:	0		.T TO CURRENT CSIƍER
CINBUF:	0		.T TO CSI LINE BUѢAHEADER
SCSIRV:,;SAVED CSIԫSVLUE
MAINF:	.BYD;TWO MAIN. (OVES ٧)
DATAF:	Ьԋ,DTA. (OVERL6iU,TVB:	0wpkEAAREA FOR TXT BLMSTART:	.WORD	DONLIB.SYS u ҩ3LOCK
TSIZE:	.W	a		;DECREASING MUTS"IZE
3EBWWRD	0		;INCREASIIDEX IN MRT E	]=.+128.
;
;EN'AAREA TO BEEQb;
ENDCLR:
;
MM:	HGHMEM-ALODSBDOP OF MEMOVF3du	.LIMIT
	.IF DF	RTH
FIO1:	.RAD50	/$OT/		;$OTSV,FORTRAN IMPURE AREA
FIO2:	.RAD50	/SV /		;PTR IN RAD50
RTHSIN	a		;RTH SIZE	]CFIL:	.RADIi;DEFAULT
fԠkWIM/		;SYMBO*ALE
EXT:	.RAD50+ԅ/		;OUTPUT
DEVBWRD50	/SY/		;PARAMETERS
MA3.RAD50	/MA+ĉwd]g ADIX 50
M2g2u	.RAD50	/N. /
jAc:	.RAD50	/DAT/	.AA. IN RADIX 50Q ԃ2:	.R1W _
;
;	MESpcA񢝍	.IF ϙ*MONL:	+MONLA-M-m		;SYSgΙIB.LD6جc]<CRLF>
	.BYTE1Ӈ,0
	+MONLA-MON[	.ASCII	'SY:MONa.DA[1,1]'
+Ӈ2D_E'
	.BYTE0,EMNLA:	.EVEN
	.E!;
TRAM:	+TRAMX)A-6
	.BYTE1Ӈ+TRAMX-TRAM-6
+YE	CR,LF
	iÓ"WԥANSFER ADDRESS: /

TRAMA:	.=.+6BWBTE	CR,LF
	.ASC2DOW LIMIT: /
TRAMB:	.=.+6
	.BYTE	CR,LF
	.ASCII	/HIGH fɩ: /
TRAMCBW=]mЬԋ	CR,LF
TR3l:kE


;
;	SAVE AREA FOR TRANSi DDRESS
TRABLK:	.=.+10.
	TRA=.-2		;TRA IS IN ө WORD
;

;	DDT TR3ƋR ADDR

*TA:	.=ذ]
	TRADDT=.-2
񢆊N:	0

INA:	INBLN-6			;MAX
	.BYTE	FBIN,0		;MODE
	0			;BC
;
;THE FOLLOgGACSI BE AND gEAUcFR 
;WILL QPIPUT O⠩O THEATO CA;THE SET UP OF THE OVERLA("EICE LINK
pOh+ɩH THE DEFAULT (SYSTEPDa]
;
+ANDF	NCMDB:	.WOQ.թPUT DATA SET SPECIFICATION.
	.=.+14			;RESERP6AWORDS.
	.WORD	-wMAXIMPBTE COUNT.
	.WORD	0		;FORMATTED ASCII MODE.
	.WORD	14	.éUAL B5"OUNT.񢄮SCII	$Η11.OVR/	;FILENAME/EXTENSI	.BYTX	;CARR`ǋ RETUS	.BYTX	;LIN#ED.
	.ENDC
	.=ظm.		;DATA
3:INBLN-6			;MAX
	.BYTE	FBIN,0	.ωE
	0			;BC
	.q6.		;DATAOUT:	0

OUTA:	OUTBL-6
	.BYTE	FBIN,0
	0
	.=.+128.CUTB:	OUTBL-6
	.BYTE	FBIN,0
	0
	.=.+128.M&ӏ:	MULMSE-MULMSGwl	.BYTE	FASC,0		;MODEͫLMSE-fMG-6		p	.BYTaYLF
MULMSB:	.=.+6
	.ASCI"W_
MULMSA:	.=.+6
	.BYTE	CR,LFSj̛q]	]EVEN
;
;	OUTPBFFERSAPMAP
;
PMAP80BWWRD	PMAP81-PMAP8[	wMAX
+YE	FASk	sgċ/STATUS
	҉	PMAPVЛAP80-6	;BC
	.Ap/****J*U*/	;O(U MESS1+YaYLF
Ph8cBWEEN
PMAP82:	.WORD	PM43[`q2-6	;MAX
+YcAk	sgċ/STATƊ҉	0		;BC
	.=.+7Kq ԃMP83:	kEM:.WORD4&85-PM44[6	;MAX
	.BYTE	FASC,E	]WORD	PMAP8hM-m.C	.ASrd_E3AREFERŧ/
	.VjECR,LF
PMAP85:	.EVEN
PMAP86:	PMAP87-PMAP86-6
	.B5"4a
	+PMAP87&86-6
	.BYTE	CR,LF
	.IFNDF	RSE	]ASCII	/LOAD MAP  /
NAME:	.ASCII	/X,X./
EXTEN:	.ASCII	/XXX  /
ID:	.ASCII	/        /
TIME:+ӇII	/00u00  /AE:	.Ap/00-Xa/
	.CBWIҧX
	.ASCII	/LOAD MAP/
	.C	.BYDå,LF
`qgPMAP88:	PM49[PMAP88-6
+YcAC,0
*MMAP88.ASCI"WӋu$ϝ	     	ADDRESS	SIZE/
	.BYTE	CK&FPMAP89:	.EVENC CEcE;SYMBO'֋QObӧAGE
cEUM:	USVէ[	.BYTE	FASk	USME-USM-6
	.BYTE	CR,LFӛA:	.=.+6
	.ASCII	/,EUMB:	.	.BYTE	CR,LF
u+֋N
;
;	LOAD MOfEAjPT ERROR
;ME:	LMOEE-Lm
	.B5"ASC,0̛bm
	.B5"K&FBWACII	/?LOADgīPEM/
	.BYTE0,ELb.EVEN񢆊;
;	MODULE NAME NOT UNI5b;
MNNU:	MNNUE-MNNU-E	]VjEFASC,0
	MNNUE-U[6
	.BYTE	CR,LFΝUA:	.=.+6
	.BYTE	CR,LF
MNNUE:	.EVEN


ORDRM:	ORDRM+g҉RM-6BWBTE	FAp0	ORDS`RDRM-E	]BYTE	tL
ORDQi:.ASCI"WA     /
	.BYTE	CR,LF҉RMA:	kE
;	DUMMY INPUT BUFFFHC#>DUMI΄e"D6B
	.B5"ASC,0		;FORMATTACII
	0		;BC
	DATA
;
;	ERROR MESS1⠯ITH FILE NAME
;
ERFIL:	ERFILE-ERFIL-6BWBTE	FAp0	ERF3"RFIL-6
	.BYTE	CR,LF
ERFILC:	.=.+6
	.ASCII	ERFILA:	.=.+6
	.ASCII	/./
ERFILB:+WE	]VjECR,LFҍILE:	.EVEN
	.END	START	;u ҩING ADDRESS=LNK OR SiT

񢆊```````````````````````````````