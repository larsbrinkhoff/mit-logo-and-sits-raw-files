.TITLE FLOPPY DISK DIAGNOSTIC
VERN==%FNAM2
.INSRT SITS;SITMAC >
.INSRT RJL;FLOPDF >

.MACRO TYPE STRING
	JSR F,TYPES
	.ASCIZ /STRING/
	.EVEN
.ENDM

.MACRO ACSAV
	SAVE <A,B,C,D,E,F>
.ENDM

.MACRO ACRES
	REST <F,E,D,C,B,A>
.ENDM

TKS==177560
TKB==TKS+2
TPS==TKB+2
TPB==TPS+2
TKBRV=60
CLKTV=100
EMTTV=30

.=0
.REPT 100
	.+2
	0
.ENDR

.=300
	JMP START
.=SMSTV
	SMSBRK
	340
.=CLKTV
	CLKBRK
	340
.=EMTTV
	EMTBRK
	0
.=TKBRV
	TKBRK
	340

.=500
PDL:
PAT:	.BLKW 200
DISK:	0	;SELECTED DISK
ERRAD:	0	;PLACE TO STORE ADDRESS OF ERROR
ERRDAT:	0	;PLACE TO STORE DATA BYTE ON ERROR
ERRST:	0	;PALCE TO STORE TYPE OF ERROR DATA
TRACK:	0	;TRACK BEING HACKED
STRACK:	0	;TRAKC HEADS ARE OVER
SECTOR:	0	;SECTOR BEING HACKED
FUNC:	0	;FUNCTION TO CALL
SEEKRD:	READS	;DISPATCH FOR SEEK TEST
TIME:	0	;INC'ED BY CLKBRK
	0
;FOLLOWING 5 WORDS MUST BE IN ORDER
TICKS:	0	;1/60 SECS
SEX:	0
MINS:	0
HOURS:	0
	0	;OVERFLOW AFTER 60 (!) HOURS
CLKWAI:	0	;IF NON-ZERO CLOCK INT IS LEGAL
INTWAI:	0	;IF NON-ZERO SMS INTERUPT IS LEGAL
SECBUF:	.BLKB 512.	;SECTOR BUFFER
TRKPT:	TRKTB
SECCNT:	0
RETRYS:	0	;COUNT OF TRYS SO FAR
TRKTB:	.BYTE 60.,7.,40.,73.,20.,22.,53.,0.,33.,66.,13.,46.,26.,59.
	.BYTE 6.,39.,72.,19.,55.,52.,32.,65.,12.,45.,2.,25.,58.,5.
	.BYTE 38.,71.,18.,51.,31.,64.,11.,35.,44.,24.,57.,4.,37.,70.
	.BYTE 17.,50.,30.,63.,68.,10.,43.,76.,23.,56.,3.,36.,15.,69.
	.BYTE 16.,49.,29.,62.,9.,48.,28.,42.,61.,8.,41.,74.,21.,54.
	.BYTE 1.,34.,67.,14.,47.,75.,27.
TRKTBE::
	.EVEN
PASSCN:	0			;PASS COUNT
ZEROS::			;START OF STUFF TO ZERO ON START OF TEST
SERTAB:	.BLKW 77.*52.		;SOFT ERROR COUNT ON THIS SECTOR
HARDTB:	.BLKW 77.*52.		;HARD ERROR COUNT ON THIS SECTOR
SEKETB:	.BLKW 77.		;SEEK ERRORS ON THIS TRACK
SERCNT:	0			;COUNT OF SOFT ERRORS
HARDCN:	0			;COUNT OF HARD ERRORS
SEKECN:	0			;COUNT OF SEEK ERRORS
RETRY:	0			;RETRYS BEFORE HARD ERROR
ZEROE::		;END OF STUFF TO ZERO
HRDRTY==10.			;HOW BIG TO LET RETRY GET BEFORE HARD ERROR
HLT==EMT
STAT==HLT+1
SECSIZ:	128.			;SECTOR SIZE
SECINC:	2
NSECS:	26.			;NUMBER OF SECTORS (IMPLIED BY SECSIZ AND DENSE)
INITCM:	0			;COMMAND THAT WILL SET US TO ABOVE SECTOR SIZE AND DENSITY
DBLSCT:	.BYTE 52.,31.,16.,9.	;SECTORS PER TRACK FOR EACH SIZE
DBLSCI:	.BYTE 4,31.,4,3		;SECTOR INCREMENTS

START:	MOV #PDL,P
	MOV #SMSCSR,F		;COMMONLY USED CONSTANT
LOOP:	BIS #SMSRSB,(F)

	RESET			;TURN OFF THE DISK
	MTPS #0			;ENABLE INTERUPTS
	TYPE <
FLOPTS.>
	MOV #VERN,B
	JSR PC,PRDN
	TYPE <
Whaduhyawant?  >
	JSR PC,TYI
	TYPE <
>
	CMP #'0,A
	BHI 1$
	CMP #'3,A
	BLO 1$
	SUB #'0,A
	MOV A,DISK
	JMP LOOP

1$:	CMP #'?,A
	BNE 2$
	MOV #'H,A

2$:	SUB #'A,A	;RELATIVE TO A
	BLT NOPE
	CMP #26.,A
	BLE NOPE
	ASL A
	JSR PC,@CTAB(A)
	JMP LOOP

NOPE:	TYPE <Nope, try ? for help>
	JMP LOOP

CTAB:	NOPE	;A
	NOPE	;B
	CHECK	;C
	DENSIT	;D
	NOPE	;E
	FORMAT	;F
	GETDEN	;G
	CMDS	;H
	NOPE	;I
	NOPE	;J
	NOPE	;K
	PRETTY	;L
	NOPE	;M
	NOPE	;N
	NOPE	;O
	PERRS	;P
	NOPE	;Q
	READ	;R
	SEEK	;S
	TEST	;T
	NOPE	;U
	NOPE	;V
	WRITE	;W
	NOPE	;X
	NOPE	;Y
	NOPE	;Z

CMDS:	TYPE <Commands are:
0,1,2,3 Select disk drive to use
D  Density setting
G  Get the density of the mounted diskette
C  Check disk that should have pattern on it (continues)
F  Format
L  Pretty lights
P  Print error counts so far
Q  Should interrupt test
R  Read disk
S  Random seeks+reads (continues)
T  Write, read, seek  (continues)
W  Write patern on disk, read it back
>
	RTS PC

PRETTY:	JSR PC,ITEST
	MOV #5.,A
1$:	MOV #10000.,B	;ABOUT 1/20 SECOND
	SOB B,.
	SOB A,1$
	MOV C,SMSLGT
	INC C
	BR PRETTY	


ITEST:	BIS #SMSPWR!SMSRSB,(F)	;RESET THE WORLD AND POWER UP
	MOV #-1,STRACK
	CLR A
	MOV #30.,B
1$:	BIT #SMSFDO,(F)
	BEQ 9$
	SOB A,1$
	SOB B,1$
	TYPE <Disk won't turn on????
>
	BR ITEST
9$:	BIT #SMSDNE,(F)
	BNE 2$
	TYPE <Controller not done?
>
	BR ITEST
2$:	BIT #SMSCMW,(F)
	BNE 8$
	TYPE <Controller not ready?
>
	BR ITEST
8$:	CLR D
6$:	JSR PC,REQST	;GET DISK STATUS
	BIT #SMSDNR,A	;DRIVE READY?
	BEQ 7$		;READY?
	SOB D,6$
	TYPE <Drive not ready?
>
	HLT
7$:	JSR PC,SETDEN		;SET TO THE CURRENT DENSITY
	CLR TRACK		;SEEK TO TRACK ZERO
	JSR PC,SEEKT
INTTST:	MOV PC,INTWAI		;SAY WE EXPECT AN INTERUPT
	BIS #SMSINT,(F)		;TRY TO CAUSE ONE
	240
	240
	TST INTWAI		;INT ROUTINE CLEARS INTWAI
	BEQ 1$
	TYPE <Failed to interupt
>
	STAT
	CLR INTWAI
1$:	BIC #SMSINT,(F)
	BIT #SMS60H,SMSPRE	;50/60 HZ BIT
	BEQ 9$
	TYPE <60Hz machine, boot from disk >
	BR 10$
9$:	TYPE <50Hz machine, boot from disk >
10$:	MOV SMSPRE,B
	BIC #SMSBDM,B
	ASH #-SMSBDS,B
	JSR PC,PRDN
	MOV #OPROM,A
	JSR PC,PROMTS
	BNE 2$
	TYPE < old controller PROM
>
	BR CLKTST
2$:	MOV #NPROM0,A
	JSR PC,PROMTS
	BNE 3$
	TYPE < new controller PROM, disk 0
>
	BR CLKTST
3$:	MOV #NPROM1,A
	JSR PC,PROMTS
	BNE 30$
	TYPE < new controller PROM, disk 1
>
	BR CLKTST
30$:	MOV #DPROM0,A
	JSR PC,PROMTS
	BNE 31$
	TYPE < single&double controller PROM, disk 0
>
	BR CLKTST
31$:	MOV #DPROM1,A
	JSR PC,PROMTS
	BNE 32$
	TYPE < single&double controller PROM, disk 1
>
	BR CLKTST


32$:	TYPE < PROM not correct?
>


CLKTST:	CLR TIME
	CLR TIME+2
	MOV PC,CLKWAI
	BIS #SMSCLE,(F)	;ENABLE CLOCK
	CLR A
1$:	TST TIME
	BNE 2$
	SOB A,1$
	TYPE <Clock didn't interupt
>
2$:	BIS #100,TKS	;ENABLE INTERUPT FOR QUIT
	MOV #ZEROS,A
3$:	CLR (A)+
	CMP #ZEROE,A
	BNE 3$
	RTS PC

PROMTS:	MOV #173000,B
	MOV #177,C
1$:	CMP (A)+,(B)+
	BNE 3$
	SOB C,1$
	SEZ
3$:	RTS PC

TKBRK:	ACSAV
	MOV TKB,A
	BIC #177600,A
	CMP #'a,A
	BHI 3$
	CMP #'z,A
	BLO 3$
	SUB #40,A
3$:	CMP #'P,A
	BNE 1$
	JSR PC,PERRS
	BR 5$
1$:	CMP #'Q,A
	BNE 2$
	JMP START
2$:
5$:	ACRES
	RTT











FORMAT:	JSR PC,ITEST	;MAKE SURE THE WORLD IS ALIVE
	JSR PC,TYPDEN
	TYPE <Format disk?  >
	JSR PC,TYI
	CMP #'Y,A
	BEQ 1$
	RTS PC
1$:	MOV #76.,E	;TRACK COUNTER
FORMA1:	MOV E,TRACK	;FOR ERROR PRINTOUT
	JSR PC,SEEKT
FORMA2:	JSR PC,REQST	;GET DISK STATUS
	BIT #SMSSIP,A	;SEEK STILL GOING?
	BNE FORMA2	;YUP, WAIT FOR IT TO END

	MOV #SMSFMT,A	;FORMAT THIS TRACK
	JSR PC,DCMD
	MOV E,A		;LABEL THE TRACK CORRECTLY
	JSR PC,CMD2
	JSR PC,GETST	;GET STATUS OF OPERATION
	BNE 1$
	HLT
1$:	DEC E
	BGE FORMA1	;DO NEXT TRACK
	RTS PC		;DONE FORMATTING


;READ THE WHOLE DISK, NOT CHECKING THE DATA
;THIS IS TO FIND BAD HEADERS ON A DISK, ETC.
READ:	JSR PC,CHKDEN
	MOV #READS,FUNC
	JSR PC,ITER	;PERFORM READS ON EVERY SECTOR
	RTS PC


WRITE:	JSR PC,CHKDEN
	CLR PASSCN
1$:	INC PASSCN
	JSR PC,WRITEP		;WRITE AND CHECK PATTERN
	BR 1$

WRITEP:	MOV #WRTPAT,FUNC	;WRITE PATTERN ON THE DISK
	JSR PC,ITER
CHECKP:	MOV #REDPAT,FUNC	;READ AND CHECK THE PATTERN
	JSR PC,ITER
	RTS PC

WRTPAT:	SAVE <A,B,C,D>
	MOV #SECBUF,A
	MOV TRACK,B
	MOV SECTOR,C
	MOV #64.,D
1$:	MOVB B,(A)+
	MOVB C,(A)+
	INC B
	INC C
	SOB D,1$
	REST <D,C,B,A>
	JSR PC,WRITES	;WRITE OUT THE SECTOR
	RTS PC

REDPAT:	JSR PC,READS	;READ THE SECTOR
	SAVE <A,B,C,D>
	MOV #SECBUF,A
	MOV TRACK,B
	MOV SECTOR,C
	MOV #64.,D
1$:	CMPB B,(A)+
	BNE REDERR
	CMPB C,(A)+
	BNE REDERR
	INC B
	INC C
	SOB D,1$
REDPA1:	REST <D,C,B,A>
	RTS PC

REDERR:	TYPE <Got a data error
>
	BR REDPA1

;ROUTINE TO ITERATE OVER THE WHOLE DISK CALLING THE ROUTINE IN FUNC
;FOR EVERY SECTOR, INCREMENTING BY SECINC BETWEEN SECTORS
;SECINC MUST BE A FACTOR OF NSECS
ITER:	CLR TRACK
	MOV #77.,D	;TRACK COUNTER
ITER1:	MOV NSECS,E	;SECTOR COUNTER
	MOV #1,SECTOR
ITER2:	JSR PC,@FUNC
	ADD SECINC,SECTOR
	CMP NSECS,SECTOR
	BGE 1$
	SUB NSECS,SECTOR
	INC SECTOR
1$:	SOB E,ITER2
	INC TRACK
	SOB D,ITER1
	RTS PC

;READ THE CURRENT SECTOR INTO SECBUF
;USE TWO ALTERNATE TECHNIQUES TO READ FROM THE BUFFER
READS:	SAVE <A,B,C>
	MOV #2,SMSLGT	;FOR SCOPING THIS LOSSAGE
	CLR RETRYS
	JSR PC,SEEKT	;SEEK TO TRACK
READRT:	INC RETRYS
	CMP #8,RETRYS
	BGE 2$
	REST <C,B,A>
	CLZ
	RTS PC
2$:	MOV #SMSRED!SMSDTB,A	;READ INTO BUFFER
	JSR PC,DCMD
	MOV SECTOR,A
	JSR PC,CMD2
1$:	TSTB (F)
	BPL 1$		;WAIT FOR DONE
	JSR PC,GETST	;GET STATUS WHEN DONE
	BEQ READER	;GO PROCESS READ ERROR
	MOV #1,SMSLGT
	MOV #SMSRED!SMSHTB,A	;READ BUFFER INTO US
	JSR PC,DCMD
	JSR PC,CMD2	;SECOND BYTE DOESN'T MATTER

READFS:	MOV #SECBUF,A
	MOV #SMSDBF,B
	MOV SECSIZ,C
5$:	BIT #SMSXFW,SMSCSR
	BEQ 5$
1$:	MOVB (B),(A)+
	SOB C,1$
	MOV #10.,C
4$:	BIT #SMSST1!SMSST0,(F)	;STATUS NOW AVAILABLE?
	BNE 2$
	SOB C,4$
	TYPE <Fast mode read lost
>
	HLT
2$:	JSR PC,GETST
	BNE 3$
	HLT
3$:	REST <C,B,A>
	CLR SMSLGT
	CLZ
	RTS PC

;THERE ARE TWO TYPES OF ERRORS WE WILL TRY TO RECOVER FROM:
;SEEK ERRORS AND READ ERRORS.( INCLUDING CRC, DAM AND SUR)
; ALL OTHERS KILL US DEAD
READER:	CMP #3,ERRST	;OPERATION ERROR?
	BNE BADER	;NOPE
	BIT #SMSHPE!SMSDAM!SMSSUR,ERRDAT	;"SEEK" TYPE ERROR?
	BNE READSE	;YUP
	BIT #SMSCRC,ERRDAT	;SIMPLE CRC?
	BNE REDCRC	;YUP
BADER:	HLT

READSE:	STAT
	JSR PC,SEEKER	;PROCESS A SEEK ERROR
	BR REDCR1	;SEEK ER IS ALSO SOFT ERR
REDCRC:	STAT
REDCR1:	JSR PC,SOFERR	;PROCESS A SOFT ERROR
	BR READRT

SOFERR:	MOV TRACK,B
	MUL NSECS,B
	ADD SECTOR,B
	DEC B
	ASL B
	INC SERTAB(B)
	INC SERCNT
	CMP #8,RETRYS
	BGT 1$
	INC HARDTB(B)
	INC HARDCN
1$:	RTS PC

SEEKER:	MOV TRACK,A
	ASL A
	INC SEKETB(A)
	INC SEKECN
	SAVE TRACK
	CLR TRACK
	JSR PC,SEEKT
	REST TRACK
	JMP SEEKT

;WRITE A SECTOR, USING TWO ALTERNATE BUFFER TRANSFER TECHNIQUES
WRITES:	SAVE <A,B,C>
	JSR PC,SEEKT	;SEEK TO TRACK
	MOV #SMSWRT!SMSHTB,A	;TRANSFER TO BUFFER
	JSR PC,DCMD
	JSR PC,CMD2	;SECOND BYTE IGNORED
2$:	BIT #SMSXFW,(F)	;READY TO TRANSFER?
	BEQ 2$
	MOV #SECBUF,A
	MOV #SMSDBF,B
	MOV SECSIZ,C
1$:	MOVB (A)+,(B)
	SOB C,1$
	MOV #10.,C
4$:	BIT #SMSST1!SMSST0,(F)	;STATUS SHOULD BE AVAILABLE
	BNE WRTS1	;GO GET IT
	SOB C,4$
	TYPE <Fast host to buffer transfer lost
>
	HLT

WRTS1:	JSR PC,GETST
	BNE 1$
	HLT
1$:	CLR RETRYS
WRTRT:	INC RETRYS
	CMP #8,RETRYS
	BGE 2$
	HLT
2$:	MOV #SMSWRT!SMSBTD,A
	JSR PC,DCMD
	MOV SECTOR,A
	JSR PC,CMD2
	JSR PC,GETST
	BEQ WRTER
	REST <C,B,A>
	RTS PC

;ONLY TYPE OF ERROR WE TRY TO RECOVER ON WRITE IS SEEK
WRTER:	CMP #3,ERRST	;OP ERROR?
	BNE BADWER
	BIT #SMSHPE!SMSDAM!SMSSUR,ERRDAT	;SEEK TYPE OF ERROR?
	BEQ BADWER	;NOPE
	STAT		;TYPE ERROR INFO
	JSR PC,SEEKER	;PROCESS SEEK ERROR
	JSR PC,SOFERR	;KEEP ERROR COUNT
	BR WRTRT

BADWER:	HLT

;SEEK TO THE CURRENT TRACK ADDRESS
SEEKT:	CMP TRACK,STRACK
	BEQ 2$		;DO NOTHING IF ALREADY THERE
	MOV #SMSSEK,A
	JSR PC,DCMD
	MOV TRACK,A
	MOV A,STRACK
	JSR PC,CMD2
	JSR PC,GETST
	BNE 1$
	HLT
1$:	JSR PC,REQST	;GET STATUS OF DRIVE
	BIT #SMSSIP,A	;STILL SEEKING?
	BNE 1$
2$:	RTS PC	

;SEEK AROUND ON THE DISK
;USING SOMEWHAT RANDOM PATTERN
SEEK:	MOV #READS,SEEKRD
	CLR PASSCN
	JSR PC,CHKDEN
1$:	INC PASSCN
	JSR PC,SEEKTS
	BR 1$

SEEKTS:	MOV #SEEKR,FUNC
	MOV #TRKTB,TRKPT
	MOV #1,SECCNT
	JSR PC,ITER	;WE WILL COVER THE WHOLE DISK
	RTS PC

SEEKR:	MOVB @TRKPT,TRACK
	MOV SECCNT,SECTOR
	INC TRKPT
	CMP #TRKTBE,TRKPT
	BHI 1$
	MOV #TRKTB,TRKPT
	INC SECCNT
	CMP NSECS,SECCNT
	BGE 1$
	MOV #1,SECCNT
1$:	JSR PC,@SEEKRD	;HACK THE SECTOR
	RTS PC


;TRY VARIOUS THINGS
TEST:	CLR PASSCN
	JSR PC,CHKDEN
1$:	INC PASSCN
	JSR PC,WRITEP	;WRITE THE DISK	
	MOV #REDPAT,SEEKRD
	JSR PC,SEEKTS	;RANDOM READS CHECKING PATTERN	
	BR 1$

CHECK:	CLR PASSCN
	JSR PC,CHKDEN
1$:	INC PASSCN
	JSR PC,CHECKP
	BR 1$	

DENSIT:	TYPE <Single or double?>
	JSR PC,TYI
	CMP #'D,A
	BEQ SETDBL
	MOV #SMS128,INITCM
	JSR PC,TYPDEN
SETDV:	BIT #SMSDBL,INITCM	;DOUBLE DENSITY?
	BNE 1$			;YES
	MOV #26.,NSECS
	MOV #128.,SECSIZ
	MOV #2,SECINC
	RTS PC

1$:	MOV INITCM,A
	BIC #177774,A
	MOV #128.,B
	ASH A,B
	MOV B,SECSIZ
	MOVB DBLSCT(A),NSECS
	MOVB DBLSCI(A),SECINC
	RTS PC

TYPDEN:	BIT #SMSDBL,INITCM
	BNE 1$
	TYPE <
Single density, >
	BR 2$
1$:	TYPE <
Double density, >
2$:	MOV INITCM,A
	BIC #177774,A
	MOV #128.,B
	ASH A,B
	JSR PC,PRDN
	TYPE < byte sectors.
>
	RTS PC
SETDBL:	MOV #SMSDBL!SMS512,INITCM
	JSR PC,TYPDEN
	BR SETDV

GETDEN:	SAVE INITCM
	JSR PC,DENGET
	BNE 1$
	REST INITCM
	RTS PC

1$:	JSR PC,TYPDEN
	TYPE <Set density to that? >
	JSR PC,TYI
	CMP #'Y,A
	BNE 2$
	TST (P)+
	JMP SETDV
2$:	REST INITCM
	RTS PC

DENGET:	JSR PC,ITEST
	MOV #SMS128,INITCM	;TRY SINGLE DENSITY
	JSR PC,GETDE1
	BNE 1$
	MOV #SMS128!SMSDBL,INITCM
	JSR PC,GETDE1
	BNE 1$
	TYPE <Disk gets errors on both single and double density.
>
	SEZ
1$:	RTS PC

GETDE1:	JSR PC,SETDEN
	MOV #SMSRID,A		;TRY TO READ THE ID
	JSR PC,DCMD
	JSR PC,CMD2
1$:	BIT #SMSXFW,SMSCSR
	BEQ 1$
	TST SMSCSR		;ERROR?
	BLT 2$			;YES, TRY FOR DOUBLE DENSITY
3$:	JSR PC,GETBYT
	JSR PC,GETBYT
	MOV #30.,A
4$:	BIT #SMSXFW,SMSCSR	;READY TO XFR?
	BNE 5$			;YUP
	SOB A,4$		;WAIT
	CLR A			;SINGLE DENSITY ONLY CONTROLER
	BR 6$
5$:	JSR PC,GETBYT
6$:	MOV A,INITCM
	CLZ
	RTS PC
2$:	JSR PC,GETBYT		;GET THE ERROR BYTE
	SEZ
	RTS PC

GETBYT:	BIT #SMSXFW,SMSCSR
	BEQ GETBYT
	MOV SMSDBF,A
	RTS PC

SETDEN:	MOV #SMSRST!SMSINI,A
	JSR PC,DCMD
	MOV INITCM,A
	JSR PC,CMD2
1$:	BIT #SMSFDO,SMSCSR	;SINGLE DENSITY GETS RESET
	BNE 1$			;WAIT FOR IT TO BE READY
	RTS PC

CHKDEN:	SAVE INITCM
	JSR PC,DENGET	;GET THE DENSITY
	CMP (P),INITCM
	BNE 2$
	TST (P)+
	BR 1$
2$:	TYPE <Currently set density doesn't agree with diskette.
Diskette is >
	JSR PC,TYPDEN
	TYPE <Set density to that?
>
	JSR PC,TYI
	REST B		;OLD INITCM
	CMP #'Y,A
	BEQ 1$
	MOV B,INITCM
1$:	JSR PC,SETDV
	JSR PC,SETDEN
	RTS PC


;ROUTINES TO INTRACT WITH THE DISK ON A LOW LEVEL

;GET THE STATUS OF THE SELECTED DISK
REQST:	MOV #SMSSTS,A	;GET STATUS
	JSR PC,DCMD	;ISSUE REQUEST FOR STATUS
	JSR PC,CMD2	;SECOND BYTE IGNORED
	JSR PC,GETST	;GET THE STATUS
	BNE 1$
	HLT
1$:	RTS PC

;ISSUE THE FIRST COMMAND BYTE (IN A), ORING IN THE DISK NUMBER
DCMD:	SAVE A		;SAVE THE COMMAND BYTE
	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW!SMSDNE,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	TYPE <Controller not in good state to get command
>
	HLT
1$:	MOV DISK,A
	ASH #3,A
	BIS (P)+,A
	MOV A,SMSCMD	;GIVE COMMAND
	RTS PC

;ISSUE THE SECOND BYTE OF A COMMAND
CMD2:	SAVE <A,B>		;SAVE THE COMAND BYTE
	MOV #30,B
2$:	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	SOB B,2$
	TYPE <Controller not ready for second byte
>
	HLT
1$:	REST <B,SMSCMD>	;GIVE IT THE BYTE
	RTS PC


GETST:	CLR A	;TO TIME OUT
GETST1:	BIT #SMSST1!SMSST0,(F)	;STATUS AVAILABLE?
	BNE GETST2
	SOB A,GETST1
	TYPE <Timed out waiting for status
>
	HLT
GETST2:	BIT #SMSERR,(F)	;ERROR?
	BNE 3$		;YUP
	BIT #SMSXFW,(F)	;WAITING TO TRANSFER?
	BNE 4$
	TYPE <Status available but not waiting for xfr????
>
	HLT
4$:	MOV SMSDBF,A	;GOBBLE STATUS
	CLZ
	RTS PC

3$:	JSR PC,ERRGBL	;GOBBLE ERROR STATUS
	SEZ
	RTS PC

ERRGBL:	BIT #SMSST1!SMSST0,(F)	;ANYTHING THERE?
	BEQ ERRGB1		;NOPE, KEEP OLD ERROR
	MOVB 1(F),A		;GET NEW ERROR TYPE
	BIC #177774,A		;FLUSH EXTRA STUFF
	MOV A,ERRST
	BIT #SMSXFW,(F)		;WAITING FOR XFR?
	BNE 1$
	TYPE <Status available but not waitng for xfr????
>	
	HALT			;TO AVOID RECURSIVE LOOP
1$:	MOV SMSDBF,ERRDAT
ERRGB1:	RTS PC

;GENERAL ERROR PRINTOUT ROUTINE
EMTBRK:	REST <ERRAD,>	;POP THE ADDRESS AND PS
	ACSAV
	TYPE <
Error @ >
	MOV ERRAD,A
	TST -(A)
	JSR PC,PRONL
	TYPE <  CSR: >
	MOV SMSCSR,A
	JSR PC,PRONL
	TYPE < TRK: >
	MOV TRACK,A
	JSR PC,PRONB
	TYPE < SEC: >
	MOV SECTOR,A
	JSR PC,PRONB
	JSR PC,ERRGBL	;GOBBLE UP THE ERROR STATUS IS THERE IS ONE
			;OTHERWISE LEAVE BEHIND THE OLD STATUS	
	TYPE < ETYP: >
	MOV ERRST,A	;THE BITS THAT GIVE THE TYPE OF ERROR
	JSR PC,PRONB
	TYPE < EDAT: >
	MOV ERRDAT,A
	JSR PC,PRONB
	TYPE <
>
	MOV ERRST,A
	ASL A
	JMP @.+4(A)
	NOERR
	CMDERR
	DRVERR
	OPERR

NOERR:	TYPE <  No error available
>
	JMP EMTBR1

CMDERR:	TYPE < Cmd err: >
	BIT #SMSITA,ERRDAT
	BEQ 1$
	TYPE <Invalid track  >
1$:	BIT #SMSISA,ERRDAT
	BEQ 2$
	TYPE <Invalid sector  >
2$:	BIT #SMSIBS,ERRDAT
	BEQ 3$
	TYPE <Invalid buffer spec>
3$:	TYPE <
>
	JMP EMTBR1

DRVERR:	TYPE < DRIVE ERROR: >
	BIT #SMSDNR,ERRDAT
	BEQ 1$
	TYPE <Drive not ready  >
1$:	BIT #SMSDUS,ERRDAT
	BEQ 2$
	TYPE <Drive unsafe  >
2$:	BIT #SMSDWP,ERRDAT
	BEQ 3$
	TYPE <Write protected  >
3$:	BIT #SMSNAM,ERRDAT
	BEQ 4$
	TYPE <No address marks  >
4$:	BIT #SMSSIP,ERRDAT
	BEQ 5$
	TYPE <Seek in progress>
5$:	TYPE <
>
	JMP EMTBR1

OPERR:	TYPE <Op error:  >
	BIT #SMSRWA,ERRDAT
	BEQ 1$
	TYPE <Read/write abort  >
1$:	BIT #SMSHPE,ERRDAT
	BEQ 2$
	TYPE <Head pos err  >
2$:	BIT #SMSDAM,ERRDAT
	BEQ 3$
	TYPE <Data address mark missing  >
3$:	BIT #SMSDOV,ERRDAT
	BEQ 4$
	TYPE <Overrun  >
4$:	BIT #SMSSUR,ERRDAT
	BEQ 5$
	TYPE <Sector unrecoverable  >
5$:	BIT #SMSCRC,ERRDAT
	BEQ 6$
	TYPE <Crc err  >
6$:	BIT #SMSRWC,ERRDAT
	BEQ 7$
	TYPE <Read/write complete  >
7$:	BIT #SMSDDR,ERRDAT
	BEQ 8$
	TYPE <Deleted data>
8$:	TYPE <
>

EMTBR1:	MOV ERRAD,A
	BIT #1,-(A)
	BNE 1$
	HALT
1$:	ACRES
	JMP @ERRAD



SMSBRK:	TST INTWAI	;IS MAIN PROGRAM WAITING FOR THIS?
	BEQ 1$		;NOPE, UGH
	CLR INTWAI
	RTT

1$:	TYPE <Spurious disk interupt
>
	HLT

CLKBRK:	TST CLKWAI	;IS MAIN PROGRAM WAITING FOR THIS?
	BEQ 1$		;NOPE
	INC TIME
	BNE 2$
	INC TIME+2
2$:	SAVE A
	MOV #TICKS,A
4$:	INC (A)
	CMP #60.,(A)
	BNE 3$
	CLR (A)+
	BR 4$			
3$:	REST A
	RTT

1$:	TYPE <Spurious clock interupt
>
	HLT

PERRS:	ACSAV
	TYPE <
Pass: >
	MOV PASSCN,B
	JSR PC,PRDN
	TYPE < @ >
	JSR PC,PRTIME
	TYPE <
Error counts:
Hard: >	
	MOV HARDCN,B
	JSR PC,PRDN
	TYPE < soft: >
	MOV SERCNT,B
	JSR PC,PRDN
	TYPE < seek: >
	MOV SEKECN,B
	JSR PC,PRDN	
	TYPE <
>
	ACRES
	RTS PC




PRTIME:	MOV HOURS,B
	JSR PC,PRDN
	TYPE <:>
	MOV MINS,B
	JSR PC,PRDN
	TYPE <:>
	MOV SEX,B
	JSR PC,PRDN
	RTS PC

;GENERAL PRINT NUMBER ROUTINE
;CALL WITH A CLEAR, NUMBER TO BE PRINTED IN B
;MINIMUM NUMBER OF DIGITS TO PRINT IN C
;AND RADIX TO PRINT IN (=< 10.) IN D
PRN:	DIV D,A
	SAVE <B,#PRNDIG>
	MOV A,B
	CLR A
	DEC C
	BGT PRN
	TST B
	BNE PRN
	RTS PC		;RETURN TO PRNDIG

PRNDIG:	REST D		;DIGIT TO PRINT
	ADD #60,D
	SAVE A
	MOV D,A
	JSR PC,TYO
	REST A
	RTS PC
	
;PRINT A DECIMIAL NUMBER IN B
PRDN:	SAVE <A,B,C,D>
	MOV #10.,D
	CLR A
	CLR C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONL:	SAVE <A,B,C,D>
	MOV #8.,D
	MOV A,B
	CLR A
	MOV #6,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONB:	SAVE <A,B,C,D>
	MOV #8.,D
	MOV A,B
	CLR A
	MOV #3,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC





TYI:	SAVE TKS
	BIC #100,TKS
2$:	TSTB TKS
	BPL 2$
	MOV TKB,A
	REST TKS
	BIC #177600,A
	CMP #'a,A	;LOWER CASE?
	BGT 1$		;NOPE
	CMP #'z,A
	BLT 1$
	SUB #40,A	;MAKE UPPER
1$:

TYO:	TSTB TPS
	BPL TYO
	MOVB A,TPB
	RTS PC		;NOP THIS TO SLOW DOWN TYO
	SAVE A
	MOV #1000.,A
	SOB A,.
	REST A
	RTS PC

TYPES:	SAVE A
1$:	MOVB (F)+,A
	BEQ 2$
	JSR PC,TYO
	BR 1$
2$:	INC F
	BIC #1,F
	REST A
	RTS F

NPROM1:	401,414,12706,1000,405,12637,4,5005,5725,776,4767,177762
5745,5015,5,5067,167144,12704,177200,12714,44000,32714,4,1375,12700
17,4767,214,4767,174,32700,1,1367,12700,11,4767,174,5000,4767,166
4767,134,10506,5002,12705,1,4767,42,12703,200,113722,177202,77303
4767,102,62705,2,22705,33,3362,2403,12705,2,756,5007,12700,11,4767
74,12700,1,4767,64,4767,32,12700,112,4767,50,10500,4767,42,4767
10,12700,212,167,24,105714,100376,5714,2415,32714,1,1775,13700
177202,207,4717,32714,20,1775,10037,177204,207,10605,4067,16,44504
45523,42440,51122,51117,5015,0,105737,177564,100375,112037,177566
1372,624,177777,177777,177777,177777,177777,177777

NPROM0:	401,414,12706,1000,405,12637,4,5005,5725,776,4767,177762,5745,5015
5,5067,167144,12704,177200,12714,44000,32714,4,1375,12700,7,4767
214,4767,174,32700,1,1367,12700,1,4767,174,5000,4767,166,4767,134
10506,5002,12705,1,4767,42,12703,200,113722,177202,77303,4767,102
62705,2,22705,33,3362,2403,12705,2,756,5007,12700,1,4767,74,12700
1,4767,64,4767,32,12700,102,4767,50,10500,4767,42,4767,10,12700
202,167,24,105714,100376,5714,2415,32714,1,1775,13700,177202,207
4717,32714,20,1775,10037,177204,207,10605,4067,16,44504,45523,42440
51122,51117,5015,0,105737,177564,100375,112037,177566,1372,624
177777,177777,177777,177777,177777,177777

OPROM:	401,414,12706,1000,405,12637,4,5005,5725,776,4767,177762,5745,5015
5067,167146,12704,177200,12714,44000,32714,4,1375,12700,7,4767,172
4767,152,32700,1,1367,10506,5002,12705,1,4767,42,12703,200,113722
177202,77303,4767,102,62705,2,22705,33,3362,2403,12705,2,756,5007
12700,1,4767,74,12700,1,4767,64,4767,32,12700,102,4767,50,10500
4767,42,4767,10,12700,202,167,24,105714,100376,5714,2415,32714,1
1775,13700,177202,207,4717,32714,20,1775,10037,177204,207,4067,16
44504,45523,42440,51122,51117,5015,0,105737,177564,100375,112037
177566,1372,637,177777,177777,177777,177777,177777,177777,177777
177777,177777,177777,177777,177777,177777,177777,177777,177777,177777

DPROM0:	401,413,12706,1000,405,12637,4,5005,5725,776,4767,177762,5045,5
10700,62700,324,20003,1001,22020,10003,10506,12704,177200,10701
62701,216,12714,44000,32714,4,1375,12700,7,4711,4767,152,32700,1
1370,12700,200,116305,2,4711,5005,4767,102,5002,12705,1,12700,102
4711,4767,74,12700,202,4711,11346,32714,1,1775,113722,177202,5316
1374,4767,42,105713,1001,122525,122525,126305,3,3347,2403,12705
2,743,5007,4717,12700,1,4711,5205,105714,100376,5714,2416,32714
1,1775,13700,177202,207,4717,32714,20,1775,10037,177204,10500,207
10605,32703,4,1641,4067,10,71105,67562,6562,12,105737,177564,100375
112037,177566,1372,624,200,15400,1000,10406,177777,177777,177771

DPROM1:	401,413,12706,1000,405,12637,4,5005,5725,776,4767,177762
5045,5,10700,62700,324,20003,1001,22020,10003,10506,12704,177200
10701,62701,216,12714,44000,32714,4,1375,12700,17,4711,4767,152
32700,1,1370,12700,200,116305,2,4711,5005,4767,102,5002,12705,1
12700,112,4711,4767,74,12700,212,4711,11346,32714,1,1775,113722
177202,5316,1374,4767,42,105713,1001,122525,122525,126305,3,3347
2403,12705,2,743,5007,4717,12700,11,4711,5205,105714,100376,5714
2416,32714,1,1775,13700,177202,207,4717,32714,20,1775,10037,177204
10500,207,10605,32703,4,1641,4067,10,71105,67562,6562,12,105737
177564,100375,112037,177566,1372,624,200,15400,1000,10406,177777,177777,177773

.END START

