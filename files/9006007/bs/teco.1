
STATE:	.WORD	0		;MUST BE FIRST!!!
TBUFX:	.WORD	0
BOQ:	.WORD	0		;START OF Q REGISTER AREA
BOB:	.WORD	0		;START OF TEXT BUFFER (END OF Q REGS)
ENBF.4:	.WORD	0		;END OF BUFFER AREA - 4
ENBF:	.WORD	0		;END OF BUFFER AREA
NUM:	.WORD	0
STKSV:	.WORD	0		;STACK PTR SAVE
STKLIM:	.WORD	0		;STACK LIMIT
LIMBF:	.WORD	0		;LIMIT FOR TEXT
CMDLOC:	.WORD	0		;DEBUG
CSTART:	.WORD	0		;PLACE TO PUT START OF Q-MACRO
CEND:	.WORD	0		;END OF CURRENT COMMAND STR
CVAL:	.WORD	0		;VALUE OF EXP
CVAL1:	.WORD	0		;FIRST OF TWO ARGS
FFLAG:	.WORD	0		;1=>DO SECOND HALF OF F OPERATION FROM EVAL
MVAL:	.WORD	0
ERNDX:	.WORD	0
QNDX:	.WORD	0
QLEN:	.WORD	0
LLEN:	.WORD	72.		;LINE LENGTH OF MY TTY IN CHARS
PAGSIZ:	.WORD	29.		;SIZE OF PAGE IN LINES
ITTER:	.WORD	0		;ITERATION COUNT
COVAL:	.WORD	0		;FOR :
COVAL1:	.WORD	0
CTRLX:	.WORD	0
CTRLY:	.WORD	0
INCNT:	.WORD	0
ERRSAV:	.WORD	0
MPTR:	.WORD	0
BOTTOM:	.WORD	10.		;BOTTOM MARGIN AS % OF SCREEN
TOP:	.WORD	10.		;TOP MARGIN AS % OF SCREEN
CENTER:	.WORD	40.		;WHERE TO PUT CURSOR AS % FROM TOP
.IF NZ DATAP
OHPOS:	.WORD	0
OVPOS:	.WORD	0
.ENDC
HPOS:	.WORD	0		;HORIZONTAL POSITION OF CURSOR
VPOS:	.WORD	0		;VERTICAL POSITION OF CURSOR
WINDOW:	.WORD	0		;CHAR NUMBER OF SCREEN 0,0
RMODE:	.WORD	0		;1=>IN ^R MODE, 0=>IN NORMAL MODE
RMODE1:	.WORD	0		;CONTROL KLUDGE, TELLS PEOPLE HOW TO JUMP
REXPT:	.WORD	1		;EXPT FOR R MODE COMMANDS
RMARK:	.WORD	0		;USED BY MACROS AS THE MARK POSITION
LASTCH:	.WORD	0		;CONTAINS THE LAST CHAR READ IN ^R MODE
KIDID:	.WORD	0		;ID OF CHILD PROCESS
TTFLAG:	.WORD	0		;TTFLAG OF TTY STATUS
TTFLG2:	.WORD	0
TTFLG3:	.WORD	0
WAITLK:	.BYTE	0
COSTAT:	.BYTE	0
COCOP:	.BYTE	0
DEBSW:	.BYTE	0	;DEBUG SW
QPDS:	.BYTE	0	;Q PUSH DOWN POINTER
FFLG:	.BYTE	0	;FORM FEED FLAG
SCHSW:	.BYTE	0
UCSW:	.BYTE	0
DOSW:	.BYTE	0
INPFLG:	.BYTE	0
OUTFLG:	.BYTE	0
ERNUM:	.BYTE	0
BAKFLG:	.BYTE	0
FFSW:	.BYTE	0
GOSW:	.BYTE	0
ITCNT:	.BYTE	0
ATSW:	.BYTE	0
COLSW:	.BYTE	0
QMODE:	.BYTE	0
COP:	.BYTE	0
RBOUT:	.BYTE	0
COLFLG:	.BYTE	0
ATFLG:	.BYTE	0
ERREG:	.BYTE	-1
INCHR:	.BYTE	0
QFLG:	.BYTE	0
QREG:	.BYTE	0
QFREG:	.BYTE	0
QARG:	.BYTE	0
SFLG:	.BYTE	0
INITFL:	.BYTE	0
CRLFSW:	.BYTE	0	; CR/LF SWAP FLAG, HAS PRECEDENCE OVER AMSW
AMSW:	.BYTE	0	; CR/ALTMODE SWAP FLAG.
ECHOSW:	.BYTE	0	;SWITCH TO TURN OFF ECHOING ON TYPIN
GRAPHM:	.BYTE	0	;ENABLE TTY GRAPHICS
SAVSW:	.BYTE	0
MFLG:	.BYTE	0
;;WAITLK:	.BYTE	0	;1=>SUPERIOR PROCESS WAITING SO IGNORE QUITS
SAVFIL:	.BLKB	50.
EMFLG:	.BYTE	0
EMPDS:	.BYTE	0
EMFIL:	.BLKB	50.
EMBUF:	.BLKB	100.
ERCMD:	.BYTE	'M
	.BYTE	'.,'G,33,33
	.EVEN
KIDSTA:	.BYTE	0		;STATUS OF CHILD PROCESS
KIDERR:	.BYTE	0		;ERROR CODE OF CHILD PROCESS
OUPFH:	.BLKW
INPFH:	.BLKW
FILNAM:	.BLKB	50.
BAKFIL:	.BLKB	50.
TMPFIL:	.BLKB	50.
TTYMAX=80.
TTYBUF:	.BLKB	TTYMAX
TTYEND:
TTYCNT:	.BLKB
TTYM:	.BLKB
TTYBP:	.BLKW
TTYEP:	.BLKW
TTYINP:	.BLKW
TTYOUP:	.BLKW
PINMAX=512.			;LENGTH OF INPUT BUFFER
PINBUF:	.BLKB	PINMAX
PINCNT:	.BLKW
PINPTR:	.BLKW
EXBUF:	.BLKB	EXBLEN		;BUFFER FOR EU COMMAND STRINGS

;TIMING VARIABLES

PUT:	.BLKW	2
PST:	.BLKW	2
CUT:	.BLKW	2
CST:	.BLKW	2
;	.CSECT	PGM,IPURE

TECO:	JSR	PC,CRLF		;TYPE A NL BEFORE THE STAR
	JSR	PC,INTTY		;INITIALIZE THE TTY
	MOVB	#1,INITFL	;SAY THAT WE ARE DOING INTIALIZATION
	MOV	EOA,R1		;COPY OUR INITIAL COMMAND INTO COMMAND BUFFER
	CLRB	(R1)+
;	JSR	PC,GETINIT	;COPY INITIAL COMMAND AT R1 LEAVE R1 AT ZERO
;	BEQ	STRTUP		;IF THERE WAS NO LOGIN DIRECTORY
;	DEC	R1		;FIX THE POINTER TO END OF INITIAL COMMAND
;	JMP	GOMAN		;NOW EXECUTE INITIAL COMMAND



;THE THEORY OF THE STARTUP IS TO COPY THE MESSAGE ENFOOBAR$$ TO A COMMAND
;BUFFER AND THEN EXECUTE THAT BUFFER.

STRTUP:	CLRB	INITFL		;FROM NOW ON INIT IS OVER
	TSTB	SAVFIL		;DID WE HAVE A COMMAND ARGUMENT
	BEQ	3$		;NO JUST START EXECUTING NORMAL COMMANDS
	MOV	EOA,R1		;GET POINTER TO COMMAND BUFFER
	TSTB	(R1)+		;EVERYTHING UP TO EOA IS COMMAND
	MOV	#STRTCMD,R0	;POINTER TO STARTUP COMMAND
1$:	MOVB	(R0)+,(R1)+	;COPY THE COMMAND
	BNE	1$		;WHILE NOT EQUAL TO ZERO
	DEC	R1		;BACK UP OVER THE ZERO
	MOV	#SAVFIL,R0	;NOW COPY THE FILE NAME INTO THE COMMAND BUFFER
2$:	MOVB	(R0)+,(R1)+
	BNE	2$		;AGAIN, WHILE NOT ZERO
	DEC	R1		;AGAIN, BACK UP OVER THE ZERO
	MOVB	#MESC,(R1)+	;FINALLY FINISH THE STRING WITH A PAIR OF ALT'S
	MOVB	#MESC,(R1)
	JMP	GOMAN		;AND EXECUTE THE COMMAND

3$:	JMP	NEXT		;READ IN A NEW COMMAND BUFFER


;	.CSECT	STACK
STRTCMD:.ASCIZ	"EN"		;WE WILL EXECUTE THIS COMMAND TO FILE
	.EVEN
;	.CSECT	PGM



GETFIL:	CMPB	(R1),#MESC
	BNE	2$
	MOV	#FILNAM,R0
	MOV	#BAKFIL,R2
1$:	MOVB	(R2)+,(R0)+
	BNE	1$
	BR	GETFL1
2$:	JSR	PC,SETFNM
GETFL1:	CLRB	FFLG
	JSR	PC,BACKT
	BCC	3$
	JSR	PC,PPINIT
	BCC	2$
	RTS	PC

2$:	MOV	R1,-(R6)
	MOV	#FILMSG,R1
	MOV	#FILMEN,R2
	JSR	PC,TYPER
	MOV	(R6)+,R1
4$:	CCC
	RTS	PC

3$:	JSR	PC,IPUT
	BR	4$



	CEXIT	Z

	TSTB	GRAPHM			;ARE WE IN ^R MODE?
	BEQ	22$			;NO
	JSR	PC,RCLR			;MAKE SURE WE GO OUT
	CLR	RMODE			;TELL EVERYBODY WE'RE OUT
	CLR	RMODE1			;JUST TO MAKE SURE

22$:	TSTB	MFLG
	BNE	44$


	SUB	CSTART,CMDLOC
	MOV	CMDLOC,ERNDX
	MOV	R1,ERRSAV
	MOVB	QMODE,QREG
	CLRB	QMODE
	INCB	SAVSW
	MOV	CEND,R0
	SUB	CSTART,R0
	MOV	R0,QLEN
	CLR	QNDX
	MOVB	QREG,R0
	BEQ	1$
	JSR	PC,FINDQ2
	BNE	1$
	CLR	QLEN
1$:	MOVB	#'?,R0
	JSR	PC,STUFF
ERRPRT=.
	MOVB	QREG,ERREG
	CLRB	SAVSW

44$:	MOV	STKSV,SP
	BR	ERPRT

	JSR	PC,FINDQ2
	BLE	ERPRT
	CLR	R5
	MOV	#ERRST,R1
	MOV	#ENDER,R2
	CMP	R1,ERRSAV
	BEQ	55$
50$:	CLR	R0
	JSR	PC,SSTR
	INC	R0
	CMP	R0,ERRSAV
	BEQ	55$
	MOV	R0,R1
	INC	R5
	BR	50$
55$:	MOVB	R5,ERNUM
	JSR	PC,FIXUP
	MOV	EOA,R1
	CLRB	(R1)+
	MOV	#ERCMD,R2
60$:	MOVB	(R2)+,(R1)+
	BNE	60$
	DEC	R1
	JMP	GOMAN

ERPRT=.
CTLZ:	MOV	ERRSAV,R1
	JSR	PC,RSTTY
	MOV	#'?,R0
	JSR	PC,TYO
	CLR	R0
	MOV	#ENDER,R2	;WORST CASE END
	JSR	PC,SSTR		;FIND THE NULL
	MOV	R0,R2		;SET UP END
	JSR	PC,TYPER			;TYP THE ERROR SHORT FORM

CONT:
REDO:	JSR	PC,CRLF
NEXT:	JSR	PC,FIXUP
	CLRB GOSW
	TSTB	INITFL
	BEQ	1$
	JMP	STRTUP

1$:	CLRB	(R1)+
	CLRB	@R1
	JSR	PC,RSTTY
	MOV	ENBF,LIMBF
	MOV	#'*,R0
NTY:	JSR	PC,TYO			;OUTPUT A * PROMPT
NCHR:	CMP	R1,ENBF.4	;STILL ROOM IN INPUT BUFFER?
;ENBF CONTAINS END OF BUFFER, ENBF.4 CONTAINS END - 4
	BLO	BAKG		; YES
	MOV	R1,-(SP)	;SAVE IT
	JSR	PC,GETMEX
	MOV	(SP)+,R1
	TST	R0
	BNE	NCHR
	MOV	R1,-(SP)	;SAVE IT FOR A SEC
	MOV	#WATCH,R1	;WARNING MSG
	MOV	#WATCHN,R2	;END OF IT
	JSR	PC,TYPER			;ZAP IT
	MOV	(SP)+,R1	;GET IT BACK
	CMP	R1,ENBF	;LAST CHANCE?
	BLO	BAKG		;STILL LUCKY
	ERROR	<NO.ROOM>		; NO. GIVE ERROR
BAKG:	JSR	PC,TYI			;GET A CHAR INTO R0
	TSTB	GOSW		;SHOULD WE STOP HERE?
	BNE	.CONT		;YES, MUST HAVE TYPED ^B OR ^Q
	JSR	PC,RSTTY
	CMP	R0,#RUBOUT
	BEQ	CTA
	CMP	R0,#XCTU	;DELETE LINE CHAR?
	BEQ	CTU
	TST	R0		;NULL?
	BEQ	CTU		;YES
	CMP	R0,#'R-'@	;CONTROL R?
	BEQ	CTR		;YES
	MOVB	R0,(R1)+
	CMPB	1(EOA),#'?
	BNE	2$
	JSR	PC,CRLF
	TSTB	ERREG
	BLT	REDO
	BEQ	3$
	CMPB	ERREG,#60
	BGE	5$
	MOV	#QMSGE,R1
	MOV	#QMSGN,R2
	JSR	PC,TYPER
	CLR	R0
	MOV	#EMFIL,R1
	MOV	R1,R2
	ADD	#50.,R2
	JSR	PC,SSTR
	MOV	R0,R2
	JSR	PC,TYPER
	BR	6$
5$:	MOV	#QMSG,R1
	MOV	#QMEN,R2
	JSR	PC,TYPER
	MOVB	ERREG,R0
	JSR	PC,TYO
6$:	JSR	PC,CRLF
3$:	MOVB	#'?,R0
	JSR	PC,FINDQ2
	MOV	R2,R1
	TST	(R2)+
	ADD	(R2)+,R2
	CMP	(R1)+,(R1)+
	ADD	ERNDX,R1
	JSR	PC,TYPER
	JMP	REDO

2$:	CMP	R0,#MESC	;IS IT AN ESCAPE CHAR?
	BNE	NCHR		; NO- JUST LOOP FOR MORE CHARS.
	CMPB	R0,-2(R1)	; IS THE PREVIOUS AN ESC??
	BEQ	GO2IT
	JMP	NCHR

.CONT:	JMP	CONT
CTR:	MOV	R1,R2		;END
	MOV	EOA,R1		;START OF INPUT
	INC	R1
	CMP	R1,R2
	BEQ	.CONT
	JSR	PC,CRLF
	MOV	#'*,R0
	JSR	PC,TYO
	JSR	PC,TYPER			;PUT IT
	MOV	R2,R1		;RESTORE
	BR	CTA3

;CONTROL U (^U) (DELETE INPUT LINE)

CTU:	MOV	#'U-'@,R0	;TYPE ^U
	JSR	PC,TYO
1$:	CMPB	-(R1),#15
	BEQ	2$
	CMP	R1,EOA
	BHI	1$
	JMP	CONT

2$:	INC	R1
	JSR	PC,CRLF
	BR	CTA3

CTA:	TSTB	RBOUT
	BNE	CTA1
	INCB	RBOUT
	MOV	#'\,R0
	JSR	PC,TYO
CTA1:	MOVB	-(R1),R0
	CMP	R1,EOA
	BHI	CTA2
	INC	R1
CTA3:	JMP	NCHR
CTA2:	JMP	NTY
GO2IT:	JSR	PC,CRLF
GOMAN:	CLRB	ITCNT
	CLRB	GOSW
	MOV	#1,CTRLX
	MOV	#1,CTRLY
	MOV	ENBF,R0
1$:	MOVB	-(R1),-(R0)	;MOVE INPUT BUFFER TO THE
	CMP	R1,EOA		;END OF THE WORLD, THUS LEAVING
	BHI	1$		;THE MOST ROOM FOR MAIN BUFFER.
	INC	R0
	MOV	R0,R1
	MOV	R0,LIMBF
	JSR	PC,SETST
	JSR	PC,CMDX		;NOW DISPATCH ON COMMANDS.
	CMP	R1,ENBF	;DID IT END UP PROPER?
	BNE	2$
	JMP	NEXT

2$:	ERROR	<CMD.END>		; NO- TELL HIM.

	CEXIT

	TST	FFLAG
	BEQ	CMDX
	JMP	CHF2

NULL:
CMDX:	MOV	R1,CMDLOC
	CMP	SP,STKLIM	;STACK OVERFLOW??
	BLOS	OVFL
	CLR	STATE
	CLRB	ATSW
	CLRB	COLSW
	MOV	#1,CVAL	;DUMMY VALUE OF 1
	CEXIT	A
	TST	FFLAG
	BEQ	CMDX1
	JMP	CHF2		;DO THE SECOND PART OF AN FS OR FN OPERATION
CMDX1:	TST	RMODE1		;ARE WE IN ^R MODE?
	BEQ	CMDX2		;NO
	JMP	RCHCNT		;EXECUTE ^R COMMANDS, THIS FINISHES A MACRO
CMDX2:	JSR	PC,CHECKC		;MAKE SURE GOSW=0, ELSE JMP TO BAKG
	JSR	PC,GETCHU		;GET AN UPPER CASE CHAR TO DISPATCH ON INTO R0
	CMP	R0,#'|
	BEQ	VERTB
	CMP	R0,#'^
	BNE	2$
	JSR	PC,GETCHU
	SUB	#100,R0
	CMP	R0,#40
	BHIS	NONE
2$:	CMP	R0,#'_
	BHI	NONE
	ASL	R0
	JMP	@DTAB(R0)	;DISPATCH ON COMMAND

OVFL:	ERROR	<STACK>

NONE:	ERROR	<NO.CMD>

VERTB:	CMP	R1,CEND
	BHIS	1$
	CMPB	(R1)+,#15
	EXIT	BEQ
	BR	VERTB
1$:	DEC	R1
	EXIT
;COMMAND +

CHPL:	BIT	#7,STATE
	EXITA	BEQ
CHOP:	BIT	#2,STATE
	BNE	EXPER1
	MOVB	-1(R1),COP
CHPL1:	BIS	#2,STATE
	EXITA

;COMMAND -

CHMI:	BIT	#7,STATE
	BNE	CHOP
	NEG	CVAL
	BR	CHPL1

CHMUL:
CHDIV:
CHAND:
CHOR:	BIT	#7,STATE
	BNE	CHOP
EXPER1:	ERROR	<EXP>

;COMMAND ,

CHCOM:	JSR	PC,ARG.7
	MOV	#10,STATE
	MOV	CVAL,CVAL1
	CLR	CVAL
	EXITA

CHAT:	TSTB	ATSW
	BNE	1$
	INCB	ATSW
	EXITA

1$:	ERROR	<AT.ERROR>

CHCOL:	TSTB	COLSW
	BNE	1$
	INCB	COLSW
	MOVB	STATE,COSTAT
	MOVB	COP,COCOP
	MOV	CVAL,COVAL
	MOV	CVAL1,COVAL1
	CLR	STATE
	EXITA

1$:	ERROR	<COLON.ERROR>


;ROUTINE TO READ A NUMBER FROM POINTER IN BUFFER

CHBS:	CMP	STATE,#4	;DO WE HAVE A NUMBER ARGUMENT?
	BEQ	1$		;YES, THEN HE WANTS TO PUT IT INTO BUFFER
	MOV	R1,-(SP)
	MOV	CPTR,R1		;WHERE TO START READING THE NUMBER
	MOV	EOA,R2		;BOUND ON WHERE THE END OF NUMBER CAN BE
	CMPB	@R1,#'-
	BEQ	3$
	CMPB	@R1,#'+
	BNE	4$
	INC	R1
4$:	JSR	PC,DECIN
5$:	CMP	R1,EOA
	BHI	2$
	MOV	R1,CPTR
	MOV	(SP)+,R1
	JMP	EVAL

3$:	INC	R1
	JSR	PC,DECIN
	NEG	R0
	BR	5$

1$:	JMP	CHBS2

2$:	ERROR	<BSLASH>

CTUP:	JSR	PC,GETCH
	BR	EVAL

CTT:	JSR	PC,TYI
	CMP	R0,#'B-'@
	BNE	EVAL
	JMP	CONT

CHQ:	JSR	PC,FINDQ
	BEQ	QRERR
	MOV	2(R2),R0
	BR	EVAL

CHPER:	JSR	PC,FINDQ
	BPL	QRERR
	MOV	2(R2),R0
	INC	R0
	MOV	R0,2(R2)
	BR	EVAL

QRERR:	ERROR	<Q.REG>

CTE:	MOVB	FFLG,R0
	BR	EVAL
CHRP:	JSR	PC,ARG.7
	RTS	PC

CHLP:	TSTB	COLSW	;IN COLON?
	BEQ	1$		;NO
	MOVB	COSTAT,-(SP)	;STATE AND COP
	MOVB	COCOP,1(R6)
	MOV	COVAL,-(SP)
	MOV	COVAL1,-(SP)
1$:	MOVB	ATSW,-(SP)
	MOVB	COLSW,1(R6)
	MOVB	STATE,-(SP)
	MOVB	COP,1(SP)
	MOV	CVAL,-(SP)
	MOV	CVAL1,-(SP)
	MOVB	ITCNT,-(SP)
	CLRB	ITCNT
	JSR	PC,CMDX
	CMPB	-1(R1),#')
	BNE	2$
	MOV	CVAL,R0
	MOVB	(SP)+,ITCNT
	MOV	(SP)+,CVAL1
	MOV	(SP)+,CVAL
	MOVB	1(SP),COP
	MOVB	(SP)+,STATE
	MOVB	1(R6),COLSW
	MOVB	(SP)+,ATSW
	TSTB	COLSW
	BEQ	EVAL
	MOV	(SP)+,COVAL1
	MOV	(SP)+,COVAL
	MOVB	1(R6),COCOP
	MOVB	(SP)+,COSTAT
	BR	EVAL

2$:	ERROR	<PAREN.END>



CTRX:	MOV	CTRLX,R0
	BR	EVAL

CTRY:	MOV	CTRLY,R0
	BR	EVAL


CTLH:	MOV	NUM,R0
	NEG	R0
	BR	EVAL


CTLF:	MOV	ERNDX,R0
	BR	EVAL

CTLK:	MOV	ERREG,R0
	BR	EVAL

CTLN:	MOVB	ERNUM,R0
	BR	EVAL

CTB:	BPT
	EXIT
;COMMAND B (BEGINNING OF BUFFER)

CHB:	CLR	R0
EVAL:	ADD	STATE,PC
	BR	CHB1
	BR	CHB2
	BR	TRP3
	BR	CHB3
	BR	CHB1
	BR	CHB2
	BR	TRP3
	BR	CHB3

CHB3:	MOVB	COP,R2	;OP
	CMP	R2,#'-
	BNE	CHB4
	SUB	R0,CVAL
CHB6X:	BIC	#2,STATE
	EXITA

CHB4:	CMP	R2,#'+
	BNE	1$
	ADD	R0,CVAL
	BR	CHB6X

1$:	CMP	R2,#'*
	BNE	2$
	MOV	R1,-(SP)
	MUL	CVAL,R0
	MOV	R1,CVAL
	MOV	(SP)+,R1
	BR	CHB6X

2$:	CMP	R2,#'/
	BNE	3$
	MOV	R1,-(SP)
	MOV	R0,-(SP)
	CLR	R0
	MOV	CVAL,R1
	DIV	(SP)+,R0
	MOV	R0,CVAL
	MOV	(SP)+,R1
	BR	CHB6X

3$:	CMP	R2,#'&
	BNE	4$
	COM	R0
	BIC	R0,CVAL
	BR	CHB6X

4$:	CMP	R2,#'#
	BNE	5$
	BIS	R0,CVAL
	BR	CHB6X
5$:	ERROR	<OPR>

CHB1:	MOV	R0,CVAL	;REPLACE DUMMY
	BIS	#4,STATE
	EXITA

CHB2:	NEG	R0
	MOV	R0,CVAL
	ADD	#2,STATE
	EXITA

;COMMAND H (ALL)

CHH:	JSR	PC,ARG.5
	CLR	CVAL1
	MOV	#10,STATE

;COMMAND Z

CHZ:	MOV	EOA,R0
	SUB	BOB,R0
	BR	EVAL

;COMMAND PERIOD (.)

CHPD:	MOV	CPTR,R0
	SUB	BOB,R0
	BR	EVAL


;COMMAND NUMBER (IE 0-9)

CHNM:	MOVB	(R1)+,R0
	JSR	PC,GETUC
	CMPB	R0,#'A
	BEQ	7$
	SUB	#2,R1		;WHERE TO START READING NUMBER
	MOV	CEND,R2		;BOUND ON END OF NUMBER
	JSR	PC,DECIN
	BR	EVAL

7$:	CLR	R0
	CMP	CPTR,EOA	;LAST??
	BEQ	1$		;YES
	MOVB	(CPTR),R0
1$:	BR	EVAL

TRP3:	ERROR	<EXP>
;COMMAND ESCAPE ($)

CMESC:	CMP	R1,CEND
	BHIS	1$
	CMPB	@R1,#MESC
	EXIT	BNE
	INC	R1
1$:	RTS	PC

CHA:	TSTB	COLSW
	BNE	1$
	TST	STATE
	BEQ	2$
	ERROR	<ARG5>
2$:	JSR	PC,IPUT
	EXIT

1$:	JSR	PC,FINDQ
	BGE	4$
	ERROR	<A.ARG>

4$:	MOVB	QFREG,-(R6)
	JSR	PC,SETLIM
	MOVB	(R6)+,QFREG
	JSR	PC,APPEND
	EXIT
;ROUTINE TO APPEND TO THE END OF A QREGISTER

APPEND:	PUSH	<R0>		;SAVE REGISTER
	PUSHR1
	MOVB	QFREG,R0
	JSR	PC,FINDQ2
	BMI	ABAD1
	BEQ	APP3
	MOV	R2,R1
	MOV	QLEN,R2
	BIT	#1,2(R1)
	BEQ	6$
	INC	R2
6$:	BIC	#1,R2
	MOV	R2,-(R6)
	TSTMEM	R2,ABAD
	MOV	R2,-(R6)
	MOVB	QFREG,R0
	JSR	PC,FINDQ2
	TST	(R2)+
	MOV	R2,-(R6)
	ADD	(R2)+,R2
	BIC	#1,R2
	TST	(R2)+
	MOV	2(R6),R1
	MOV	(R6)+,(R6)
	MOV	EOA,R0
	MOV	R1,EOA
1$:	MOVB	-(R0),-(R1)
	CMP	R0,R2
	BHI	1$
	MOV	(R6)+,R0
	MOV	R0,R1
	ADD	(R1)+,R1
	ADD	QLEN,(R0)
	ADD	(R6),BOB
	ADD	(R6),BOQ
	ADD	(R6)+,CPTR
	TSTB	EMFLG
	BEQ	7$
	MOV	#EMBUF,R0
	BR	8$
7$:	JSR	PC,QSET
8$:	MOV	QLEN,R2
	BEQ	4$
2$:	MOVB	(R0)+,(R1)+
	SOB	R2,2$
	MOVB	#MESC,(R1)
4$:	JSR	PC,SETST
	POPR1
	POP	<R0>		;RESTORE
	RTS	PC

ABAD:	ERROR	<A.ROOM>
ABAD1:	ERROR	<A.REG>

APP3:	MOVB	QFREG,R0
	JSR	PC,STUFF
	TST	(R6)+
	POP	<R0>		;RESTORE
	RTS	PC

;COMMAND J (JUMP)

CHJ:	JSR	PC,ARG.1
	BNE	1$
	CLR	CVAL	;ALLOW FOR DUMMY ARG
1$:	MOV	CVAL,R0
	ADD	BOB,R0
	MOV	R0,CPTR
	CMP	CPTR,EOA
	EXIT	BLOS
	MOV	EOA,CPTR
	EXIT

;COMMAND R

CHR:	TSTB	COLSW
	BEQ	1$
	JSR	PC,ARG.1A
	BNE	2$
	CLR	CVAL
2$:	MOV	CVAL,INCNT
	MOVB	(R1)+,INCHR
	JSR	PC,IPUT1
	EXIT

1$:	NEG	CVAL

;COMMAND C (ADVANCE PTR)

CHC:	JSR	PC,ARG.2		;FIX THE ARGS
	MOV	R0,CPTR
	EXIT
;COMMAND L (NEXT LINE)

CHL:	TSTB	COLSW
	BNE	CHL1
	JSR	PC,ARG.3		;GET RESULT
	MOV	R0,CPTR
	EXIT

CHL1:	MOV	R1,-(R6)
	MOV	#41,R5
	JSR	PC,CRLF

1$:	CMP	R5,#200
	BEQ	11$
	MOV	R5,R0
	JSR	PC,FINDQ2
	BEQ	10$
	BGT	3$
	JSR	PC,TYO
	MOV	#40,R0
	JSR	PC,TYO
	JSR	PC,TYO
	MOV	#'N,R0
	JSR	PC,TYO
	MOV	#11,R0
	JSR	PC,TYO
	MOV	2(R2),R0
	JSR	PC,CEQ1
	BR	15$

3$:	JSR	PC,TYO
	MOV	#11,R0
	JSR	PC,TYO
	MOV	R2,-(R6)
	MOV	2(R2),R0
	BLT	21$
	JSR	PC,CEQ1
	BR	22$
21$:	JSR	PC,DECOUX
	MOVB	(R6)+,R2
23$:	MOVB	(R6)+,R0
	JSR	PC,TYO
	DEC	R2
	BGT	23$
22$:	MOV	(R6)+,R2
	MOV	#11,R0
	JSR	PC,TYO
	TST	2(R2)
	BEQ	15$
	MOV	#25.,R1
	TST	(R2)+
	CMP	(R2),R1
	BHIS	6$
	MOV	(R2),R1
6$:	TST	(R2)+
7$:	MOVB	(R2)+,R0
	CMP	R0,#15
	BEQ	15$
	CMP	R0,#11
	BNE	8$
	SUB	#7,R1
	BLE	15$
8$:	JSR	PC,TYO
	SOB	R1,7$

15$:	JSR	PC,CRLF
10$:	INC	R5
	BR	1$

11$:	MOV	(R6)+,R1
	EXIT

;COMMAND T (TYPE)

CHT:	TSTB	COLSW		;SHOULD WE TYPE A QREGISTER?
	BNE	1$		;YES
	TSTB	ATSW		;SHOULD WE DO WINDOW DISPLAY?
	BNE	4$		;YES
	JSR	PC,ARG.11		;GET BOUNDS
	MOV	R1,-(SP)	;SAVE IT
	MOV	R0,R1		;SWITCH
	JSR	PC,TYPER
	MOV	(SP)+,R1	;RESTORE
	EXIT

1$:	JSR	PC,FINDQ
	BMI	2$
	BNE	3$
	JMP	QBAD
2$:	MOV	2(R2),R0
	JSR	PC,CEQ1
	JSR	PC,CRLF
	EXIT

3$:	MOV	R1,-(R6)
	MOV	R2,R1
	ADD	#4,R1
	ADD	2(R2),R2
	ADD	#4,R2
	JSR	PC,TYPER
	JSR	PC,CRLF
	MOV	(R6)+,R1
	EXIT


;^R MODE SCREEN HACKERY

4$:	TST	STATE		;WERE THERE ANY ARGUMENTS
	BNE	5$		;YES, MUST HAVE BEEN
	JSR	PC,UPDATE	;SET CURSOR TO . ON SCREEN AND MAYBE NEW WINDOW
	EXIT

5$:	CMP	STATE,#14	;ARE WE IN TWO ARG MODE?
	BNE	6$		;NO, MUST BE IN ONE ARG MODE
	JSR	PC,ARG.10	;OK FIX THE ARGUMENTS INTO R0 AND R2
	JSR	PC,GTYPER	;TYPE EVERYTHING BETWEEN R0 AND R2
	BNE	7$		;CAN'T ERROR
	EXIT

6$:	JSR	PC,ARG.7	;MAKE SURE ARGS ARE CORRECT
	MOV	CVAL,R0		;ONE ARGUMENT, TYPE FROM HERE TO BOTTOM
	ADD	BOB,R0		;MAKE IT ABSOLUTE
	JSR	PC,TYPSCN	;TYPE EVERYTHING FROM R0 TO BOTTOM OF SCREEN
	BNE	7$		;CAN'T, ERROR
	EXIT

7$:	ERROR	<WINDOW>

;ROUTINE TO SET THE CURSOR TO . ON SCREEN. IF . IS OFF THE SCREEN, THEN
;A NEW WINDOW WILL BE CHOSEN AND THE SCREEN REDISPLAYED

UPDATE:	PUSH	<R0,R1>		;GET SOME REGISTERS
	MOV	CPTR,R0		;OTHERWISE SET SCREEN CURSOR TO DOT
	JSR	PC,SETPOS	;SET HPOS AND VPOS TO POSTION R0
	BNE	2$		;CAN'T, PICK A NEW WINDOW
	MOV	TOP,R0		;PERCENTAGE OF FORBIDDEN ZONE AT TOP OF WINDOW
	MUL	PAGSIZ,R0	;FIND NUMBER OF FORBIDDEN LINES
	DIV	#100.,R0	;LINES INTO R0, REMAINDER INTO R1
	CMP	VPOS,R0		;WOULD WE BE IN FORBIDDEN ZONE?
	BHIS	1$		;NO
	TST	WINDOW		;ARE WE AT THE TOP OF BUFFER?
	BNE	2$		;NO BETTER PICK A NEW WINDOW

1$:	MOV	BOTTOM,R0	;PERCENTAGE OF FORBIDDEN ZONE AT BOTTOM
	MUL	PAGSIZ,R0	;FIND NUMBER OF FORBIDDEN LINES
	DIV	#100.,R0	;LINES INTO R0
	MOV	PAGSIZ,R1	;NUMBER OF LINES ON SCREEN
	SUB	R0,R1		;FIND BOTTOM LINE OF FORBIDDEN ZONE
	CMP	VPOS,R1		;WOULD WE BE BELOW IT
	BHIS	2$		;YES, BETTER PICK A NEW WINDOW
	JSR	PC,SETCUR	;OK, GO AHEAD AN SET CURSOR
	POP	<R1,R0>		;CLEAN UP
	RTS	PC

2$:	JSR	PC,SETWIN	;PICK A NEW WINDOW
	MOV	WINDOW,R0
	ADD	BOB,R0		;MAKE IT ABSOLUTE
	JSR	PC,TYPSCN	;TYPE EVERYTHING FROM R0 TO BOTTOM OF SCREEN
	MOV	CPTR,R0		;NOW SET THE CURSOR
	JSR	PC,SETPOS	;SET HPOS AND VPOS TO CURSOR LOCATION
	JSR	PC,SETCUR	;NOW ACTUALLY MOVE THE CURSOR
	POP	<R1,R0>		;CLEAN UP
	RTS	PC

;ROUTINE TO PICK A NEW WINDOW LOCATION.  FOR NOW JUST ASSUME SCREEN LINES
;EQUAL CHAR LINES AND BACK UP %CENTER FROM DOT.

SETWIN:	PUSH	<R0,R1>		;GET SOME REGISTERS
	MOV	CENTER,R0	;% OF SCREEN FROM TOP TO SET CURSOR
	MUL	PAGSIZ,R0	;GET IT IN LINES
	DIV	#100.,R0	;SINCE CENTER IS IN %
	MOV	R0,R1		;GET COUNT OF LINES
	NEG	R1		;SINCE WERE GOING BACK
	MOV	CPTR,R0		;OUR CURRENT POSITION
	JSR	PC,LINE		;MOVE R0 BACK R1 LINES
	SUB	BOB,R0		;MAKE IT RELATIVE TO BOB
	MOV	R0,WINDOW	;THIS WILL BE OUR NEW WINDOW
	POP	<R1,R0>		;CLEAN UP
	RTS	PC


;ROUTINE TO TYPE EVERYTHING BETWEEN R0 AND BOTTOM OF SCREEN, WHERE R0
;IS INTERPRETED AS A CHAR POINTER. ROUTINE WILL FAIL IF R0 IS LESS THAN
;WINDOW. CLEARS Z IF IT SUCCEEDS.

TYPSCN:	MOV	WINDOW,-(SP)	;FIND ABSOLUTE ADDRESS OF WINDOW
	ADD	BOB,(SP)
	CMP	R0,(SP)+	;MAKE SURE ITS REALLY ON THE SCREEN
	BLT	1$		;NO, BEFORE WINDOW HENCE OFF THE SCREEN
	PUSH	<R1,R2,R0>	;NEED SOME REGISTERS
	MOV	PAGSIZ,R1	;HOW MANY LINES TO TYPE
	JSR	PC,LINE		;MOVE R0 DOWN PAGSIZ LINES
	MOV	R0,R2		;THIS WILL BE END POINTER
	POP	<R0>		;RESTORE THE START POINTER
	JSR	PC,GTYPER	;OK, NOW TYPE EVERYTHING FROM R0 TO R2
	JSR	PC,KILLSC	;KILL TO BOTTOM OF SCREEN
	POP	<R2,R1>		;CLEAN UP
	SEZ			;SIGNAL NO ERRORS
	RTS	PC

1$:	CLZ			;SIGNAL AN ERROR
	RTS	PC

;ROUTINE TO TYPE PORTIONS OF THE SCREEN. IT EXPECTS A STARTING CHAR NUMBER
;IN R0 AND LAST CHAR POINTER IN R2.  IT WILL SET THE CURSOR TO SCREEN
;POSITION OF R0'TH CHAR, THEN TYPE EVERYTHING IN BUFFER BETWEEN R0 AND R2,
;THEN RESTORE THE CURSOR TO IT'S ORIGINAL POSITION. CLEARS Z IF R0 IS NOT
;ON THE SCREEN.

GTYPER:	JSR	PC,SETPOS	;SET HPOS AND VPOS TO R0 ON SCREEN
	BNE	1$		;CAN'T, IT WOULD BE OFF THE SCREEN
	JSR	PC,SETCUR	;OK, PUT THE CURSOR THERE
	PUSH	<R0,R1,R2>	;GET A REGISTER
	MOV	R0,R1		;JSR	PC,TYPER LIKES STARTING CHAR HERE
	JSR	PC,TYPER	;TYPE IT
	POP	<R2,R1,R0>	;CLEAN UP
	SEZ			;SIGNAL NO ERRORS
	RTS	PC

1$:	CLZ			;SIGNAL ERROR
	RTS	PC



;ROUTINE TO SET HPOS AND VPOS TO THE SCREEN POSITION OF CHAR POINTED
;TO BY R0. WILL CLR Z IF THIS POSITION IS NOT ON THE SCREEN.

SETPOS:	PUSH	<R0,R1,R2,R5>	;SAVE SOME REGISTERS
	SUB	BOB,R0		;MAKE RELATIVE TO BOB
	CMP	R0,WINDOW	;IS AFTER THE FIRST CHAR ON SCREEN?
	BLO	1$		;NO, MUST BE OFF THE SCREEN
	MOV	R0,R5		;COPY THIS LOCATION
	SUB	WINDOW,R5	;GET NUMBER OF CHARS
	MOV	WINDOW,R0	;SET BEGINNING POINTER TO WINDOW
	ADD	BOB,R0
	CLR	R1		;0 INITIAL SCREEN LINE
	CLR	R2		;0 INITIAL SCREEN COLUMN
	JSR	PC,COUNT	;SET R1 TO FINAL LINE AND R2 TO FINAL COLUMN
	CMP	R1,PAGSIZ	;IS IT OFF THE BOTTOM OF SCREEN?
	BHIS	1$		;YUP, ERROR
.IIF NZ DATAP,	JSR	PC,RECCUR
	MOV	R1,VPOS		;SET VERTICAL POSITION
	MOV	R2,HPOS		;SET HORIZONTAL POSITION
	POP	<R5,R2,R1,R0>	;CLEAN UP
	SEZ			;SIGNAL NO ERROR
	RTS	PC

1$:	POP	<R5,R2,R1,R0>	;CLEAN UP
	CLZ			;SIGNAL ERROR
	RTS	PC

;ROUTINE TO TYPE FROM BEGINNING OF LINE

CHV:	JSR	PC,ARG.1		;TEST IT
	BNE	1$
2$:	MOV	#4,STATE	;FAKE IT
	CLR	CVAL	;0L
	JSR	PC,ARG.9
	INC	CVAL
3$:	MOV	R0,-(SP)	;SAVE IT
	JSR	PC,ARG.9		;GET END
	MOV	(SP)+,R0	;SWITCH
	MOV	R1,-(SP)
	MOV	R0,R1
	JSR	PC,TYPER			;ZAP IT
	MOV	(SP)+,R1	;POP
	EXIT

1$:	TST	CVAL
	BLE	2$
	MOV	#4,STATE
	NEG	CVAL
	JSR	PC,ARG.9
	NEG	CVAL
	BR	3$
CHX:	JSR	PC,ARG.11		;GET BOUNDS
	JSR	PC,QINSRT
	EXIT

QINSRT:	SUB	R0,R2		;HOW MANY??
	TSTB	COLSW
	BNE	1$
	SUB	BOB,R0	;MAKE OFFSET
1$:	MOV	R0,-(SP)	;AND SAVE IT
	MOV	R2,-(SP)	;SAVE IT
	MOV	R2,-(SP)	;SAVE IT
	JSR	PC,FINDQ		;GET THE Q REGISTER
QINSR1:	BEQ	6$		;NOT THERE
	BMI	10$		;NUMERIC
	CMP	2(R2),@SP	;LARGER?
	BHIS	7$
	SUB	2(R2),@SP	;GET DIFFERENCE
	BR	10$		;SKIP OVER

6$:	CLR	R2		;USE IT AS A FLAG
10$:	ADD	#12,@SP
	TSTMEM	@SP,XBAD
7$:	MOV	R2,(SP)+	;GET RID OF JUNK AND TEST R2
	BEQ	11$		;SKIP IF NON-EXISTENT
	MOVB	QFREG,-(R6)
	JSR	PC,KILLQ		;KILL THE OLD
	MOVB	(R6)+,QFREG
11$:	MOV	@SP,R2		;RESTORE
	ADD	#6,R2		;HEADER AND TRAILER
	BIC	#1,R2		;WORDS
	MOV	R2,-(SP)	;SAVE IT
	ADD	EOA,R2		;GET END
	MOV	R2,-(SP)	;SAVE IT
	BR	3$

21$:	MOVB	-(EOA),-(R2)	;MOVE DOWN
3$:	CMP	EOA,BOB	;DONE??
	BHI	21$		;NO
	MOV	(SP)+,EOA	;FIX IT
	MOV	R2,BOB
	CLR	-(R2)		;FIX BOQ WORD
	MOV	R2,BOQ
	ADD	@SP,CPTR
	SUB	(SP)+,R2	;ADDRESS TO PUT Q
	MOVB	QFREG,(R2)	; FILL IN NAME
	MOVB	(R2)+,(R2)+	;MOVE IN NON-ZERO POSITIVE NUMBER
	MOV	@SP,(R2)+	;COUNT
	BEQ	2$
	MOV	2(SP),R0	;RESTORE
	TSTB	COLSW
	BNE	22$
	ADD	BOB,R0	;FIX IT BACK
22$:	TSTB	QFLG
	BEQ	23$
	TSTB	EMFLG
	BEQ	25$
	MOV	#EMBUF,R0
	BR	23$
25$:	MOV	R2,-(R6)
	JSR	PC,QSET
	MOV	(R6)+,R2
23$:	MOVB	(R0)+,(R2)+	;MOVE IN TEXT
	DEC	@SP		;FINISHED??
	BNE	23$		;NO
2$:	MOVB	#MESC,(R2)+	;ESC AT END
	ADD	#4,SP		;GET RID OF JUNK
	RTS	PC			;AND LEAVE


XBAD:	TSTB	SAVSW
	BEQ	XBAD1
	JMP	ERRPRT
XBAD1:	ERROR	<Q.ROOM>
CHLBR:	JSR	PC,ARG.5	;NO ARGS
	DECB	QPDS	;ANOTHER NAME
	BVS	2$
	MOV	#4,-(SP)
	JSR	PC,FINDQ
	BNE	1$
	CLR	R2
	BR	5$

1$:	TST	@R2		;CORRECT?
	BMI	5$		;YES
	ADD	#2,@SP		;FIX IT
	ADD	2(R2),@SP	;COMME CA
	BIC	#1,@SP		;WORDS
5$:	MOV	@SP,-(SP)	;SAVE IT
	TSTMEM	@SP,XBAD
	MOV	@SP,R0		;GET END
6$:	MOVB	-(EOA),-(R0)	;MOVE DOWN
	CMP	EOA,BOQ	;DONE?
	BHI	6$		;NO
	MOV	R0,BOQ	;FIX THAT
	TST	R2
	BNE	10$
	MOVB	QPDS,(EOA)+
	MOVB	#-2,(EOA)+
	CLR	(EOA)+
	BR	8$

10$:	CMPB	QMODE,QFREG
	BNE	4$
	MOV	(R2)+,(EOA)+
	MOV	CSTART,R5
	SUB	#4,R5
	MOVB	QPDS,(R5)
	MOVB	QPDS,QMODE
	BR	7$

4$:	MOV	(R2)+,(EOA)+	;MOVE IN STUFF
	MOVB	QPDS,-2(EOA)	;NEW NAME
7$:	MOV	(R2)+,(EOA)+	;MOVE IT IN
	CMP	EOA,R0		;DONE?
	BLO	7$		;NO
8$:	MOV	(SP)+,EOA	;NEW END
	ADD	@SP,CPTR	;FIX THESE
	ADD	(SP)+,BOB	;COMME CA
	EXIT			;LA FIN

2$:	INCB	QPDS	;FIX IT
	ERROR	<Q.PDS>

QBAD:	ERROR	<Q.REG>

CHU:	JSR	PC,ARG.7
	JSR	PC,FINDQ		;FIND THE OLD Q
	BEQ	2$		;NOT THERE
	BPL	3$		;TEXT
	MOV	CVAL,2(R2)	;PUT IT IN
	EXIT			;AND LEAVE

3$:	JSR	PC,KILLQ		;KILL THE OLD
2$:	MOV	#4,R2
	TSTMEM	R2,XBAD
	MOV	R2,R0
	BR	5$		;SKIP OVER

4$:	MOVB	-(EOA),-(R0)
5$:	CMP	EOA,BOB
	BHI	4$
	MOV	R2,EOA
	CLR	-(R0)
	MOV	R0,BOQ
	ADD	#4,CPTR
	ADD	#4,BOB
	MOV	CVAL,-(R0)
	MOVB	#-1,-(R0)
	MOVB	-1(R1),-(R0)
	EXIT

;GET A Q REGISTER
CHG:	JSR	PC,ARG.5
	JSR	PC,FINDQ		;FIND THE Q REGISTER
	BLE	QBAD		;BAD NEWS
	TST	(R2)+		;SKIP NAME
	MOV	(R2)+,-(SP)	;GET COUNT
	BEQ	7$
	TSTMEM	@SP,GBAD2
	MOV	@SP,R0
	BR	2$

1$:	MOVB	-(EOA),-(R0)	;MOVE IN THE TEXT
2$:	CMP	EOA,CPTR	;DONE??
	BHI	1$		;NO
	MOV	R0,CPTR		;NEW ONE
3$:	MOVB	(R2)+,(EOA)+	;MOVE IT IN
	CMP	EOA,R0		;FINISHED??
	BLO	3$		;NO
	MOV	(SP)+,EOA	;SET IT UP
	EXIT			;AND RETURN

7$:	TST	(SP)+
	EXIT

GBAD2:	ERROR	<G.ROOM>
CHM:	JSR	PC,FINDQ		;FIND IT
	BLE	QBAD		;NOT ALPHA
CHM3:	MOV	MPTR,-(R6)
	CMPB	R0,#'?
	BNE	1$
	INCB	MFLG
1$:	PUSHR1
	MOVB	QMODE,-(R6)
	MOVB	ITCNT,1(R6)
	MOV	R6,MPTR
	MOV	CTRLX,-(R6)
	MOV	CTRLY,-(R6)
	MOVB	ATSW,-(R6)
	MOVB	COLSW,1(R6)
	MOVB	QARG,-(R6)
	MOV	MVAL,-(R6)
	MOV	RMODE1,-(R6)	;SAVE STATE OF RMODE
	TST	STATE
	BNE	3$
	MOV	#1,CTRLX
5$:	MOV	#1,CTRLY
	BR	CHM4

3$:	CMP	STATE,#4
	BNE	4$
	MOV	CVAL,CTRLX
	BR	5$

4$:	CMP	STATE,#14
	BNE	CHM1
	MOV	CVAL1,CTRLX
	MOV	CVAL,CTRLY

CHM4:	MOVB	@R2,QMODE	;RESET IT
	JSR	PC,SETST	;SET UP CSTART AND CEND TO QREG NAMED BY QMODE
	MOV	CSTART,R1
	CLRB	ITCNT
	CLRB	QARG
	CLR	MVAL
	CLR	RMODE1		;MACROS ARE INITIALLY OUT OF RMODE
	JSR	PC,CMDX		;GO TO IT
	MOV	MVAL,QLEN
	MOV	(R6)+,RMODE1	;RESTORE RMODE STATE
	MOV	(R6)+,MVAL
	MOVB	(R6)+,CVAL
	MOVB	1(R6),COLSW
	MOVB	(R6)+,ATSW
	MOV	(R6)+,CTRLY
	MOV	(R6)+,CTRLX
	CMPB	-(R1),#MESC
	BNE	MBAD2		;NO
	MOVB	QMODE,CVAL1
	MOVB	1(R6),ITCNT
	MOVB	(R6)+,QMODE
	JSR	PC,SETST	;RESET CSTART AND CEND TO QREG NAMED BY QMODE
	POPR1
	CMPB	CVAL1,EMPDS
	BNE	25$
	MOVB	CVAL1,R0
	JSR	PC,FINDQ2
	JSR	PC,KILLQ
	DECB	EMPDS

25$:	MOVB	#MESC,R0
	TSTB	ATSW
	BEQ	17$
	MOVB	(R1)+,R0
17$:	MOVB	R0,ATSW
	TSTB	QARG
	BEQ	20$
19$:	MOVB	ATSW,R0
	JSR	PC,SSTRX
	MOV	R0,R1
22$:	DECB	QARG
	BLE	24$
	INC	R1
	BR	19$
24$:	CMPB	ATSW,#MESC
	BEQ	20$
	INC	R1

20$:	MOVB	CVAL,QARG
	MOV	(R6)+,MPTR
	TSTB	COLSW
	EXIT	BEQ
	MOV	QLEN,CVAL
	CMPB	(R1),#MESC
	BNE	CHM2
	INC	R1
CHM2:	CLRB	ATSW
	CLRB	COLSW
	MOV	#4,STATE
	EXITA			;AND LEAVE

CHM1:	ERROR	<M.ARG>
MBAD2:	ERROR	<M.RETURN>	;BAD RETURN


CHRBR:	JSR	PC,ARG.5		;NO ARGS
	MOVB	QPDS,R0	;GET NAME
	BEQ	1$		;NONE ON STACK
	JSR	PC,FINDQ2		;FIND IT
	BEQ	1$		;LOSE AGAIN
	JSR	PC,FINDQ		;FIND WHERE TO POP
	BEQ	2$		;NONE
	JSR	PC,KILLQ		;KILL IT
2$:	MOVB	QPDS,R0
	JSR	PC,FINDQ2		;ENCORE
	BEQ	1$
	CMPB	1(R2),#-2
	BNE	3$
	JSR	PC,KILLQ
	BR	4$

3$:	MOVB	-1(R1),@R2	;CHANGE NAME
4$:	INCB	QPDS
	EXIT			;QUIT

1$:	ERROR	<Q.POP>


CTLV:	JSR	PC,ARG.7
	MOV	CVAL,MVAL
	EXIT
;DELETE

CHD:	JSR	PC,ARG.8
CHD1:	JSR	R7,DELE		;SKIP OVER
	EXIT

;KILL

CHK:	TSTB	COLSW
	BNE	1$
	JSR	PC,ARG.11
	BR	CHD1

1$:	JSR	PC,FINDQ
	BNE	2$
	ERROR	<Q.REG>
2$:	JSR	PC,KILLQ
	EXIT

DELE:	CMP	R0,R2
	BHIS	6$
	CMP	R0,CPTR
	BHIS	3$
	CMP	R2,CPTR
	BLO	4$
	MOV	R0,CPTR
	BR	3$

4$:	SUB	R2,CPTR
	ADD	R0,CPTR
	BR	3$

2$:	MOVB	(R2)+,(R0)+
3$:	CMP	R2,EOA
	BLO	2$
	MOV	R0,EOA
6$:	RTS	R7
;COMMAND E (ER & EY & ED & EW & EF & EM)

CHE:	JSR	PC,GETCHU
	CMP	R0,#'M
	BEQ	CHEM
	JSR	PC,ARG.5
	CMP	R0,#'R
	BNE	CHEW
	JSR	PC,SETFNM	;SET UP THE FNM
	JSR	PC,PRINIT			;AND OPEN THE FILE
C2$:	BCC	C1$		; GOOD.

CHERWE:	JSR	PC,QSET
	MOV	R0,R1
	JSR	PC,TYPER
	JSR	PC,CRLF			;AND A CR/LF
	ERROR	<FILE.ERROR>		;AND ERROR

C1$:	CLRB	FFLG		;START AFRESH
	EXIT

CHEW:	CMP	R0,#'W		;FOR ME?
	BNE	CHEV		; NO
	JSR	PC,SETFNM
	JSR	PC,PPINIT			;OPEN FIL FOR OUTPUT
	BCS	CHERWE		;ERROR
	EXIT

CHEV:	CMP	R0,#'V
	BNE	CHED		;TRY DELETE
	JSR	PC,SETFNM		;GET THE NAME
	JSR	PC,DELIT		;TRY DELETING BUT IGNORE ERRORS
	JSR	PC,PPINIT			;TRY OPEN
	BCS	CHERWE		;LOSE
	EXIT

CHED:	CMP	R0,#'D
	BNE	CHEA
	JSR	PC,SETFNM
	JSR	PC,DELIT
	BCS	CHERWE
	EXIT

CHEA:	CMP	R0,#'A
	BNE	CHET
	JSR	PC,SETFNM
	JSR	PC,APPIT
	BCS	CHERWE
	EXIT

CHET:	CMP	R0,#'T
	BNE	CHEU
;	JSR	PC,SETFNM
;	JSR	PC,TMPIT
;	BCS	CHERWE
;	EXIT
.IFNZ SITS
	JSR PC,FILUNM		;GET FILE NAME COMPLETE WITH SPACES
	JSR PC,SETDIR
	BCS CHERWE
	EXIT
.ENDC

;COMMAND TO FORK AND CREATE AN INFERIOR PROCESS TO EXECUTE COMMANDS

CHEU:	CMP	R0,#'U		;WAS IT A "EU" COMMAND?
	BNE	CHEY		;NOPE, TRY EY
.IF Z LSI
	BPT
	EXIT
.IFF
	JSR	PC,SETEXC	;COPY COMMAND STRING INTO QREG " AND EXBUF
	BCS	1$		;IF COMMAND STRING WAS TOO LONG TO FIT EXBUF
	TSTB EXBUF		;ANY STRING?
	BEQ 2$			;NO, JUST DIE
	MOVB EXBUF,R0
	SUB #60,R0
	BLT 1$
	CMP #4,R0
	BLE 1$
	JSR PC,UNMOUNT
	EXIT

;	JSR	PC,RUNIT	;RUN THE CHILD
;	EXIT
;
1$:	JSR	PC,QSET		;SET UP SOME POINTERS
	MOV	R0,R1		;POINTER TO START OF STRING
	JSR	PC,TYPER			;TYPE THE COMMAND STRING
	JSR	PC,CRLF			;TYPE JSR	PC,CRLF
	ERROR	<EXEC.ERROR>	;COMPLAIN

2$:	HALT
	EXIT
.ENDC
;ROUTINE TO READ AND MACRO A FILE

CHEM:	CMPB	EMPDS,#40	;40 IS MAXIMUM DEPTH OF EM MACROS
	BEQ	6$		;WE HAVE REACHED MAXIMUM DEPTH, ERROR
	INCB	EMPDS		;ADVANCE DEPTH COUNTER
	JSR	PC,SETFN		;READ FILE NAME FROM COMMAND STRING INTO FILNAM
	JSR	PC,EMOPEN	;OPEN THE FILE
	BCS	4$		;CAN'T
	MOV	R0,-(SP)	;SAVE THE FILE HANDLE
	MOVB	#1,EMFLG	;SIGNAL THAT WE ARE READING FROM FILE

1$:	MOV	(SP),R0		;GET A FRESH COPY OF FILE HANDLE
	JSR	PC,EMREAD	;READ 100. BYTES OF FILE INTO EMBUF
	BCS	2$		;PROBLEMS...
	MOV	R0,QLEN		;R0 HAS ACTUAL NUMBER OF BYTES READ
	BEQ	2$		;NOTHING TO APPEND
	MOVB	EMPDS,QFREG	;USE THIS NUMBER AS QREG TO PUT IT IN
	JSR	PC,APPEND		;COPY STUFF FROM EMBUFF TO QREG
	CMP	R0,#100.	;DID WE REALLY READ 100. BYTES?
	BEQ	1$		;YES, THERE MUST BE SOME MORE THEN

2$:	MOV	(SP)+,R0	;POP FILE HANDLE
	JSR	PC,EMCLOSE	;CLOSE THE EMFILE
	INC	R1		;FIX THE COMMAND POINTER
	TSTB	ATSW
	BEQ	3$
	SUB	#2,R1
3$:	CLRB	EMFLG
	MOVB	EMPDS,R0	;THIS IS THE QREG WE PUT IT IN
	JSR	PC,FINDQ2		;SET UP POINTERS TO THIS QREG
	JMP	CHM3		;NOW GO AND MACRO IT

4$:	TSTB	INITFL		;IS THIS PART OF THE STARTUP?
	BEQ	5$		;NO, GIVE AN ERROR
	JMP	STRTUP		;ELSE, CONTINUE WITH STARTUP

5$:	ERROR	<EM.OPEN>
6$:	ERROR	<EM.NEST>
CHY:	JSR	PC,ARG.5
	BR	CHYX

CHEY:	CMP	R0,#'Y
	BNE	CHEF
CHYX:	MOV	BOB,EOA
	JSR	PC,IPUTC
	MOV	BOB,CPTR	;RESET POINTER TO BEGINNING
	EXIT

CHEF:	CMP	R0,#'F		;IS COMMAND EF??
	BNE	CHEB		; NO
	JSR	PC,CLO			;CLEAR OUTPUT
	EXIT	BCC

	ERROR	<EF.ERROR>

CHEB:	CMP	R0,#'B		;BACKUP??
	BNE	CHEX		;NO
	JSR	PC,SETFNM		;SET UP FILE NAME
	JSR	PC,BACKT			;DO THE WHOLE THING
	JMP	C2$

CHEX:	CMP	R0,#'X
	BNE	CHEN		;NOT EX
	JSR	PC,CLRTTY	;GO BACK TO OLD TTY MODE
	MOV	#1,QLEN

CHEX1=.
1$:	MOV	BOB,R0
	MOV	EOA,R2		;BUFFER LIMITS
	CMP	R0,R2		;ANY THERE?
	BEQ	3$		;NO
	TST	OUTFLG		;MAKE SURE WE HAVE AN OUTPUT FILE
	BEQ	23$		;NO, OK FIX UP THE TTY, AND COMPLAIN
	JSR	PC,OPUT		;OUTPUT IT
	MOV	BOB,EOA	;RESET
	TSTB	FFLG
	BGT	2$		;NO
	BEQ	4$
	MOV	#14,R0
	JSR	PC,PPO
4$:	TSTB	INPFLG	;INPUT FILE?
	BEQ	2$
	JSR	PC,IPUTC		;GET MORE
	BR	1$

3$:	TSTB	FFLG
	BLE	4$
2$:	JSR	PC,CLO			;CLOSE IT
	BCS	23$
	TST	QLEN
	BEQ	6$
	JMP	FINISH			;LEAVE

23$:	JSR	PC,INTTY	;OH-OH BETTER GO BACK TO TECO TTY MODE
	ERROR	<EXN.ERROR>

6$:	MOV	BOB,CPTR
	JSR	PC,GETFIL
	EXIT	BCC
	JMP	CHERWE


CHEN:	CMP	R0,#'N
	BNE	CHES
	CLR	QLEN
	BR	CHEX1

CHES:	CMP	R0,#'S
	BNE	CHEC
	JSR	PC,GETCHU
	CMPB	R0,#'D
	BNE	1$
	MOV	#401,UCSW
	EXIT

1$:	CMPB	R0,#'U
	BNE	2$
	BISB	#1,UCSW
	EXIT

2$:	CMP	R0,#'F
	BNE	3$
	BISB	#1,FFSW
	EXIT

3$:	CMP	R0,#'A
	BNE	4$
	BISB	#1,AMSW
	EXIT

4$:	CMP	R0,#'S
	BNE	5$
	MOVB	#1,SFLG
	EXIT

5$:	CMP	R0,#'R		;SHOULD WE GO INTO ^R MODE?
	BNE	CHE3A		;NO
	PUSHR1			;SAVE R1 RELATIVE TO CSTART SO IF WE EXPAND..
	PUSH	RMODE		;SAVE OUR CURRENT STATE
	TST	RMODE		;ARE WE ALREADY IN ^R MODE?
	BNE	6$		;YES, NO NEED TO SET PARAMS AGAIN
	CLR	HPOS
	CLR	VPOS		;SET TO TOP OF SCREEN
.IF NZ SITS
.IIF NZ DATAP,	MOV	#35,R0	;OUTPUT HOME UP
.IIF Z DATAP,	MOV	#25,R0
	JSR	PC,TTPUTC
	JSR	PC,TTFLSH
.ENDC
	JSR	PC,RSET		;SET PARAMETERS FOR ^R MODE
6$:	MOV	#1,RMODE	;ENABLE ^R MODE
	JSR	PC,RCHL		;DRAW A NEW WINDOW
	JSR	PC,RCH		;START EXECUTING ^R MODE COMMANDS
	POP	RMODE		;RESTORE PREVIOUS STATE
	POPR1			;RESTORE RELATIVE TO CSTART INCASE IT MOVED
	TST	RMODE		;ARE WE STILL IN ^R MODE?
	BNE	7$		;YES, NO REASON TO LEAVE
	JSR	PC,RCLR		;OK BETTER CLEAN UP A LITTLE
7$:	EXIT


CHEC:	CMP	R0,#'C
	BNE	CHEL
	JSR	PC,GETCHU
	CMPB	R0,#'D
	BNE	1$
	CLR	UCSW
	EXIT

1$:	CMP	R0,#'U
	BNE	2$
	CLRB	UCSW
	EXIT

2$:	CMP	R0,#'F
	BNE	3$
	CLRB	FFSW
	EXIT

3$:	CMP	R0,#'A
	BNE	4$
	CLRB	AMSW
	EXIT

4$:	CMP	R0,#'S
	BNE	5$
	CLRB	SFLG
	EXIT

5$:	CMP	R0,#'R		;WHAT ABOUT ^R MODE?
	BNE	CHE3A		;NO, MUST BE ERROR
	CLR	RMODE		;JUST LEAVE A MESSAGE FOR SOMEBODY ELSE
	EXIT

CHEL:
.IFNZ SITS
	CMP #'L,R0
	BNE CHEI
	JSR PC,FILUNM		;GET FILE NAME COMPLETE WITH SPACES
	JSR PC,SETDIR
	BCC 1$
CHERWX=.
2$:	JMP CHERWE
1$:	JSR PC,POI
	BCS 2$
	EXIT

CHEI:	CMP #'I,R0
	BNE CHEP
	JSR PC,FILNAM
	JSR PC,CRINDX
	BCS CHERWX
	EXIT

CHEP:	CMP #'P,R0
	BNE CHE3A
	JSR PC,PRINTP
	BCS CHERWX
	EXIT

.ENDC




CHE3A:	ERROR	<E.ERROR>
;COMMAND P & PW (OUTPUT CURRENT BUFFER AND READ NEXT ONE.)

CHP:	MOVB	@R1,R0		;CHECK FOR PW
	JSR	PC,GETUC
	CMPB	R0,#'W		;??
	BEQ	4$		;YES
	CMP	STATE,#14	;TWO ARGS?
	BEQ	1$		;YES
	JSR	PC,ARG.6	;GET ARGS
2$:	JSR	PC,PAGE		;WRITE OUT CURRENT PAGE, AND FETCH NEW ONE
	DEC	CVAL		;FIN??
	BGT	2$		;NO
	EXIT			;RTS	PC

1$:	JSR	PC,ARG.10	;GET RANGE
	JSR	PC,OPUT		;ZAP IT
	EXIT			;AND QUIT

4$:	JSR	PC,GETCH	;JUST CHECKING
	CMP	STATE,#14	;TWO ARGS?
	BEQ	1$		;YES - SAME AS P
	JSR	PC,ARG.6	;GET ARG
5$:	MOV	BOB,R0		;START
	MOV	EOA,R2		;END
	CMP	R0,R2		;NOTHING?
	BEQ	6$		;YUP
	JSR	PC,OPUT		;ZAP IT
	MOV	#14,R0		;FF
	JSR	PC,PPO
	DEC	CVAL		;DONE?
	BGT	5$		;NO
6$:	EXIT




;ROUTINE TO OUTPUT ONE PAGE AND FETCH THE NEXT ONE, CLOBBERS R0 AND R2

PAGE:	MOV	BOB,R0		;START
	MOV	EOA,R2		;END
	CMP	R0,R2		;NOTHING?
	BEQ	1$		;YES
	MOV	R0,EOA		;RESET
	MOV	R0,CPTR		;COMME CA
	JSR	PC,OPUT		;DO IT TO IT
	MOV	#14,R0		;AND FF
	JSR	PC,PPO

1$:	JSR	PC,IPUTC	;GET NEXT BUFFER
	RTS	PC
;COMMAND S (SEARCH)

CHS:	JSR	PC,ARG.4
	JSR	PC,SCBF
	BCS	CHSLOSE
2$:	DEC	CVAL
	BLE	CHSWIN
	JSR	PC,SCBFX
	BCC	2$
CHSLOSE:
	MOVB	ATSW,R0
	TST	FFLAG
	BEQ	1$
	CLR	FFLAG
	JSR	PC,SSTRX
	MOV	R0,R1
	INC	R1
CHSWIN=.
	MOVB	ATSW,R0
1$:	JSR	PC,SSTRX
	MOV	R0,R1
	MOVB	SCHSW,R0
	TSTB	COLSW
	BEQ	2$
	INC	R1
	SUB	FFLAG,R1
	CLRB	ATSW
	CLRB	COLSW
	MOVB	COSTAT,STATE
	MOVB	COCOP,COP
	MOV	COVAL,CVAL
	MOV	COVAL1,CVAL1
	JMP	EVAL

2$:	CMPB	@R1,#MESC
	BEQ	3$
	INC	R1
	SUB	FFLAG,R1
3$:	BISB	ITCNT,R0	;TEST FOR ITER OR SUCCESS
	EXIT	BNE
	ERROR	<SEARCH>
CHN:	JSR	PC,ARG.4
	JSR	PC,SCBF
	BCS	5$
2$:	DEC	CVAL
	BGT	1$
	BR	CHSWIN

8$:	MOV	#14,R0
	JSR	PC,PPO
3$:	JSR	PC,IPUTC		;GET NEXT PAGE
1$:	JSR	PC,SCBFX
	BCC	2$
5$:	MOV	BOB,R0	;GET START
	MOV	EOA,R2		;AND END
	CMP	R0,R2
	BEQ	4$
	JSR	PC,OPUT		;PUT IT
	MOV	BOB,EOA	;RESET
	TSTB	FFLG	;FINISHED??
	BEQ	3$		;NO
	BLT	8$
	BR	CHSLOSE

4$:	TSTB	FFLG
	BLE	3$
	BR	CHSLOSE

CHBA:	JSR	PC,ARG.4
	JSR	PC,SCBF		;SEARCH BUFFER
	BCS	3$
2$:	DEC	CVAL		;FINISHED?
	BLE	CHSWIN
1$:	JSR	PC,SCBFX
	BCC	2$
3$:	MOV	BOB,EOA	;RESET
	TSTB	FFLG	;FINISHED?
	BGT	CHSLOSE		;YES
	JSR	PC,IPUTC
	BR	1$		;AND CONTINUE
;COMMAND TAB

CHTAB:	JSR	PC,ARG.5
	CMPB	-(R1),#11
	BEQ	CHI1
	MOV	#11,CVAL
	BR	CHI3

;COMMAND I (INSERT)

CHI:	TST	STATE
	BEQ	CHI0
	JSR	PC,ARG.7
CHI3:	MOV	CVAL,R0		;THE CHAR NUMBER WILL BE IN CVAL
	JSR	PC,INSERT	;INSERT THIS CHAR INTO THE BUFFER
	EXIT			;THAT'S ALL


;ROUTINE TO INSERT THE CHAR IN R0 INTO THE BUFFER

INSERT:	PUSH	<R0>		;SAVE THE CHAR
	MOV	#1,R2
	TSTMEM	R2,BMV6		;MAKE SURE WE HAVE ROOM FOR IT
	MOV	EOA,R0		;GET OTHER POINTER
	MOV	R2,EOA		;RESET IT
	BR	2$		;AND SKIP

1$:	MOVB	-(R0),-(R2)	;MOVE THE CHARS DOWN
2$:	CMP	R0,CPTR		;FINISHED?
	BHI	1$		;NO
	MOVB	(SP)+,(CPTR)+	;MOVE IN THE CHAR
	RTS	PC

CHI0:	TSTB	COLSW		;SHOULD WE INSERT INTO Q REGISTER
	BEQ	CHI1		;NO, NORMAL STRING INSERT

	MOVB	(R1)+,-(R6)	;OTHERWISE DO INSERT INTO Q REGISTER
	CMPB	(R6),#60
	BGE	1$
	ERROR	<Q.REG>

1$:	JSR	PC,SETLIM
	MOVB	(R6)+,R0
	JSR	PC,STUFF
	EXIT

CHI1:	JSR	PC,SETLIM
	MOV	QLEN,R0
	BEQ	CHI6
	MOV	R0,R2
	TSTMEM	R2,BMV6
	MOV	EOA,R0
	MOV	R2,EOA
	BR	3$

4$:	MOVB	-(R0),-(R2)
3$:	CMP	R0,CPTR
	BHI	4$
	JSR	PC,QSET
	MOV	QLEN,R2
5$:	MOVB	(R0)+,(CPTR)+
	SOB	R2,5$
CHI6:	CLR	FFLAG
	TSTB	COLSW
	EXIT	BEQ
	CLRB	COLSW
	CLRB	ATSW
	CMPB	(R1),#MESC
	BNE	2$
	INC	R1
2$:	EXITA



BMV6:	ERROR	<I.ROOM>


SETLIM:	MOVB	#MESC,R0
	TSTB	ATSW
	BEQ	1$
	MOVB	(R1)+,R0
1$:	MOVB	R0,ATSW
	JSR	PC,SSTRX
	CMPB	ATSW,#MESC
	BEQ	2$
	INC	R0
2$:	SUB	R1,R0
	MOV	R0,-(R6)
	MOVB	ATSW,R0
	JSR	PC,STRX
	MOV	(R6),R5
	ADD	(R6)+,R1
	RTS	PC
;ROUTINE TO PUT A CHAR REPRESENTATION OF A NUMBER INTO THE BUFFER

CHBS2:	JSR	PC,ARG.7		;EXACTLY 1
	MOV	CVAL,R0			;GET IT
	JSR	PC,DECOUX		;GET CHARS
	MOVB	(SP)+,R2		;COUNT
	BIC	#177400,R2		;SINCE WE DID A MOVB COUNT,-(SP)
	TSTMEM	R2,BMV6			;MAKE SURE WE HAVE ROOM FOR IT
	MOV	R2,R0			;SAVE IT
	BR	5$

3$:	MOVB	-(EOA),-(R2)	;MOVE DOWN
5$:	CMP	EOA,CPTR
	BHI	3$
4$:	MOVB	(SP)+,(CPTR)+
	CMP	CPTR,R2
	BLO	4$
	MOV	R0,EOA
	EXIT


CHF:	INC	FFLAG



CHF3:	JSR	R7,CHECKC
	JSR	R7,GETCHU
	CMP	R0,#'S
	BEQ	1$
	CMP	R0,#'N
	BEQ	1$
	CMP	R0,#'V		;GET A VARIABLE NAME
	BEQ	CHFV		;EXECUTE THE V FUNCTION
	ERROR	<F.CMD>

1$:	ASL	R0
	MOVB	COLSW,COLFLG
	MOVB	ATSW,ATFLG
	JMP	@DTAB(R0)

CHF2:	MOVB	ATFLG,ATSW
	MOVB	COLFLG,COLSW

	MOV	NUM,R0
	NEG	R0
	JSR	R7,ARG.21
	JSR	R7,LFB1
	JSR	R7,DELE

	CMPB	(R1),#MESC
	BNE	2$
	CMPB	1(R1),#MESC
	BNE	1$
	JMP	CHI6
1$:	INC	R1
2$:	JMP	CHI1



;ROUTINE TO HACK VARIALBES VIA SYMBOLIC NAMES

CHFV:	CLR	FFLAG		;SO WE DON'T GO BACK TO CHF2
	MOV	#SYMTAB,R0	;POINTER TO SYMBOL TABLE
	MOV	R1,-(SP)	;SAVE POINTER TO CHAR STRING

1$:	TST	(R0)		;ARE THERE ANY MORE SYMBOLS?
	BEQ	7$		;NO, BAD SYMBOL NAME
	JSR	PC,CMPSTR	;LOOK FOR THIS SYMBOL
	BEQ	3$		;FOUND IT!
	INC	R0
	BIC	#1,R0		;GO TO WORD BOUNDRY

2$:	ADD	(R0)+,R0	;SKIP ANY ARGUMENTS
	TST	(R0)+		;SKIP THE FUNCTION
	MOV	(SP),R1		;RESTORE POINTER TO CHAR STRING
	BR	1$		;AHH THERE IT IS, NOW CHECK NEXT SYMBOL

3$:	TST	(SP)+		;POP THE OLD R1
	CMPB	(R1)+,#MESC	;MAKE SURE THE LAST SYMBOL CHAR IS ESC
	BNE	7$		;SYMBOL ERROR IF NOT
	INC	R0		;MAKE SURE WE'RE ON WORD BOUNDRY
	BIC	#1,R0

4$:	MOV	(R0)+,R2	;GET A COUNT OF THE ARGUMENTS
	BEQ	6$		;NONE!
	ASR	R2		;SINCE COUNT IS 2*NUMBER OF VARIABLES

5$:	MOV	(R0)+,-(SP)	;PUSH AN ARGUMENT
	SOB	R2,5$		;PUSH ALL THE ARGUMENTS

6$:	JMP	@(R0)+		;NOW EXECUTE THE FUNCTION

7$:	ERROR	<SYMBOL>
	

;ROUTINE TO COMPARE TWO STRINGS.  EXPECTS POINTER TO FIRST STRING IN
;R0 AND POINTER TO SECOND IN R1.  THE COMPARISON ENDS WHEN A DIFFERENCE
;APPEARS, OR WHEN A ZERO APPEARS IN THE FIRST STRING. Z=> STRINGS EQUAL.

CMPSTR:	TSTB	(R0)+		;ARE WE AT THE END OF THE FIRST STRING?
	BEQ	2$		;YUP
	CMPB	-1(R0),(R1)+	;ELSE CHECK THE NEXT BYTE
	BEQ	CMPSTR		;EQUAL, SO KEEP LOOKING
	MOVB -1(R1),-(SP)
	CMPB #'a,(SP)
	BGT 3$
	CMPB #'z,(SP)
	BLT 3$
	SUB #40,(SP)
	CMPB -1(R0),(SP)+
	BEQ CMPSTR
	BR 1$
3$:	TST (SP)+
1$:	TSTB	(R0)+		;FIND THE END OF THE STRING
	BNE	1$		;NOT YET
	CLZ			;SIGNAL NOT EQUAL
2$:	RTS	PC

;ROUTINE TO HANDLE SIMPLE LOCAL VARIABLES

SYMLOC:	JSR	PC,SETVAR	;SET THE VARIABLES
	ADD	#4,SP		;POP THE ARGUMENTS
	JMP	EVAL		;AND CONTINUE


;ROUTINE TO GO INTO GRAPHICS MODE

SYMGRF:
.IIF NZ DATAP,	JSR	PC,RECCUR
	JSR	PC,SETVAR	;SET THE VARIABLES
	TSTB	GRAPHM		;ARE WE NOW IN GRAPHICS MODE?
	BEQ	1$		;NO, TURN OFF GRAPHICS MODE
	JSR	PC,SETCUR	;SET THE CURSOR TO RIGHT SPOT

1$:	ADD	#4,SP		;POP THE ARGUMENTS
	JMP	EVAL		;AND CONTINUE


;ROUTINE TO SET GRAPHIC VARIABLES, WHICH SHOULD ALSO AFFECT THE SCREEN

SYMCUR:
.IIF NZ DATAP,	JSR	PC,RECCUR
	JSR	PC,SETVAR	;SET THE VARIABLES
	TSTB	GRAPHM		;ARE WE IN GRAPHICS MODE?
	BEQ	1$		;YES, DO NOT ACTUALLY MOVE THE CURSOR
	JSR	PC,SETCUR	;SET THE CURSOR
1$:	ADD	#4,SP		;POP THE ARGUMENTS
	JMP	EVAL		;AND CONTINUE


;ROUTINE TO ASSIGN VALUES TO VARIABLES

SETVAR:	JSR	PC,ARG.1		;SHOULD HAVE 0 OR 1 ARGUMENT
	BEQ	2$		;NO ARGUMENTS
	TST	2(SP)		;IS IT A WORD OR BYTE?
	BEQ	1$		;WORD
	MOVB	CVAL,@4(SP)	;ASSIGN A BYTE VALUE
	BR	2$

1$:	MOV	CVAL,@4(SP)	;ASSIGN A WORD VALUE

2$:	TST	2(SP)		;IS IT A WORD OR BYTE
	BEQ	3$		;WORD
	MOVB	@4(SP),R0	;GET A BYTE VALUE
	BR	4$

3$:	MOV	@4(SP),R0	;GET A WORD VALUE

4$:	CLR	STATE		;WE ABSORBED ANY ARGS PRESENT
	RTS	PC


;COMPUTE LINSIZ, LEAVE RESULT IN R0 AS ARGUMENT TO NEXT COMMAND

SYMLIN:	JSR	PC,ARG.5	;MAKE SURE THERE'S NO ARGUMENTS
	JSR	PC,LINSIZ	;DO THE FUNCTION, LEAVE RESULT IN R0
	JMP	EVAL



;ROUTINE TO COMPUTE THE NUMBER OF SCREEN LINES IN THE LINE OF .

LINSIZ:	PUSH	<R1,R2,R5>	;FREE SOME REGISTERS
	MOV	CPTR,R0		;GET . INTO R0
	CLR	R1		;WE WANT THE BEGINNING OF THIS LINE
	JSR	PC,LINE		;MOVE R0 HERE
	PUSH	<R0>		;SAVE IT
	MOV	CPTR,R0
	MOV	#1,R1
	JSR	PC,LINE		;NOW GO FORWARD 1 LINE
	MOV	R0,R5		;LEAVE RESULTS IN R5
	POP	<R0>		;RESTOR POINTER TO BEGINNING OF LINE
	SUB	R0,R5		;COUNT THIS MANY CHARS
	CLR	R1		;INITIAL LINE COUNT 0
	CLR	R2		;INITIAL COLUMN POSITION 0
	JSR	PC,COUNT	;COUNT LINES AND COLUMNS
	MOV	R1,R0		;RETURN LINE COUNT
	TST	R2		;WAS THERE ANY OVERFLOW?
	BEQ	1$		;NO
	INC	R0		;ELSE ADD IN AS EXTRA LINE

1$:	POP	<R5,R2,R1>	;CLEAN UP
	RTS	PC


;ROUTINE TO MOVE A POINTER FORWARD OR BACKWARD LINES IN THE BUFFER.
;EXPECTS THE POINTER IN R0, AND A COUNT IN R1 WHOSE FORMAT IS JUST LIKE L.

LINE:	TST	R1		;SHOULD WE MOVE FORWARD OR BACKWARD
	BGT	3$		;FORWARDS
	NEG	R1		;CONVERT TO A POSITIVE NUMBER

1$:	CMP	R0,BOB		;LOOK FOR BEGINNING OF LINE
	BLOS	2$		;AT BEGINNING OF BUFFER
	CMPB	-(R0),#15	;LOOK FOR A NL
	BNE	1$		;KEEP LOOKING
	DEC	R1		;ONE LESS LINE
	BGE	1$		;KEEP DOING WHILE COUNT IS POSITIVE
	INC	R0		;BACK OVER NL
2$:	RTS	PC

3$:	CMP	R0,EOA		;NOW LOOK FOR END OF LINE
	BHIS	4$		;AT END OF BUFFER
	CMPB	(R0)+,#15	;LOOK FOR A NL
	BNE	3$		;KEEP LOOKING
	SOB	R1,3$		;KEEP MOV'N WHILE SOME COUNT IS LEFT
4$:	RTS	PC
;ROUTINE TO READ AND WRITE ENTRIES IN RCMAC.  RCMAC IS AN ARRAY OF FUNCTIONS
;TO BE EXECUTED BY CHARS IN CONTROL R MODE.  THE ARRAY IS INDEXED BY CHARS
;HENCE THERE ARE 128 ENTRIES.  WITH ONE ARG, THIS COMMAND RETURNS THE VALUE
;OF THE ARRAY SPECIFIED BY THE ARG WHICH SHOULD BE 0-127.  WITH TWO ARGS,
;THE FIRST ARG IS INSERTED IN THE LOCATION OF THE SECOND ARG. SEE RCH FOR
;THE INTERPRETATION PLACED ON RCMAC ENTRIES.  THIS ROUTINE IS ALSO USED
;IN A SIMILAR FASHION FOR RAMAC AND RBMAC, AS SPECIFIED BY ARGUMENT.

SYMCST:	POP	R2		;THIS SHOULD BE POINTER TO THE DISPATCH TABLE
	JSR	PC,ARG.12	;MAKE SURE ARGS ARE IN CORRECT FORMAT
	BNE	1$		;THERE WERE TWO ARGS
	MOV	CVAL,R0		;OTHERWISE, 1 ARG, GET THE ARRAY INDEX
	ASL	R0		;CONVERT TO WORD OFFSET
	ADD	R0,R2		;GET THE OFFSET INTO THE TABLE
	BR	2$		;RETURN THE INDEXED VALUE

1$:	MOV	CVAL,R0		;GET THE ARRAY INDEX
	ASL	R0		;CONVERT TO WORD OFFSET
	ADD	R0,R2		;GET THE OFFSET INTO THE TABLE
	MOV	CVAL1,(R2)	;INSERT THE FIRST ARG INTO THE ARRAY

2$:	MOV	(R2),R0		;GET THE VALUE SPECIFIED BY INDEX
	CLR	STATE		;WE ABSORBED ANY ARGS
	JMP	EVAL		;USE R0 AS ARG FOR NEXT COMMAND



;ROUTINE TO EXECUTE ONE OF THE ^R MODE FUNCTIONS. THE FUNCTION SHOULD
;BE IN THE FORMAT RETURNED BY RCMAC, NAMELY A NEGATIVE INTEGER.

SYMEXC:	JSR	PC,ARG.7	;MAKE SURE WE HAVE EXACTLY ONE ARGUMENT
	MOV	CVAL,R0		;THIS WILL BE THE FUNCTION
	PUSH	R1		;SAVE COMMAND LOCATION
	JSR	PC,RCHJMP	;EXECUTE THE FUNCTION IN RDTAB CHOSEN BY R0
	POP	R1		;GET BACK ON THE TRACK
	EXIT



;ROUTINE TO GET OR SET SOME TIMING VARIABLES
.IFZ SITS
SYMTIM:	JSR	PC,TIMER	;SET THE TIMER VARIABLES
	JSR	PC,SETVAR	;RETURN THE RIGHT THING
	ADD	#4,SP		;POP THE ARGUMENTS
	JMP	EVAL		;CONTINUE THE EVALUATION
.ENDC


;ROUTINE TO RING THE BELL

SYMBELL:JSR	PC,ARG.5	;NO ARGUMENTS PERMITTED
	JSR	PC,BELL		;RING THE BELL
	EXIT			;THAT'S ALL


;ROUTINE TO RETURN INFO ABOUT A QREG.  RETURNS -1 IF QREG IS NUMERIC,
;0 IF QREG IS ABSENT AND 1 IF IT'S A TEXT QREG.

SYMQTS:	JSR	PC,ARG.7	;EXACTLY ONE ARG
	MOV	CVAL,R0		;GET NUMERIC REPRESENTATION OF QREG
	JSR	PC,FINDQ1	;SET R2 POINTING TO QREG
	BGT	1$		;MUST BE TEXT QREG
	BLT	2$		;NO IT'S NUMERIC
	CLR	R0		;NOT TEXT OR NUMERIC, IT'S NOT THERE
	BR	3$

1$:	MOV	#1,R0		;SAY THAT IT'S TEXT
	BR	3$

2$:	MOV	#-1,R0		;SAY THAT IT'S NUMERIC

3$:	CLR	STATE		;TO ABSORB ARGUMENTS
	JMP	EVAL		;TO RETURN THE VALUE
;COMMAND LEFT BRACKET (<)

CLB:	JSR	PC,ARG.1
	BNE	1$		;ARG SPECIFIED
	NEG	CVAL	;SET TO -1
1$:	MOV	ITTER,-(SP)
	MOV	CVAL,ITTER
	BEQ	3$
	INCB	ITCNT
5$:	PUSHR1
	JSR	PC,CMDX

ITPUSH=6

	CMPB	-1(R1),#'>
	BNE	LOOPER
	DEC	ITTER
	BEQ	4$
	POPR1
	BR	5$

4$:	DECB	ITCNT
	TST	(SP)+
	MOV	(SP)+,ITTER
	EXIT

3$:	MOV	(SP)+,ITTER
	MOV	#'>+<'<*400>,R0
	JSR	PC,MSTRX
	MOV	R0,R1
	INC	R1
	EXIT

LOOPER:	ERROR	<LOOP.END>

;COMMAND RIGHT BRACKET (>)

CRB:	RTS	PC
CHDQ:	JSR	PC,ARG.7
	JSR	PC,GETCHU
	CMP	R0,#'G
	BNE	2$
	TST	CVAL
	EXIT	BGT

11$:	MOV	#''+<'"*400>,R0
	JSR	PC,MSTRX
	MOV	R0,R1
	EXIT

2$:	CMP	R0,#'L
	BNE	3$
	TST	CVAL
	EXIT	BLT
	BR	11$

3$:	CMP	R0,#'E
	BNE	4$
	TST	CVAL
	EXIT	BEQ
	BR	11$

4$:	CMP	R0,#'N
	BNE	5$
	TST	CVAL
	EXIT	BNE
	BR	11$

5$:	CMP	R0,#'C
	BNE	6$
	MOV	CVAL,R0
	JSR	PC,CHKSEP
	EXIT	BCC
	BR	11$

6$:	ERROR	<DQ.ERROR>
;COMMAND ; (??)

CSC:	JSR	PC,ARG.1
	BEQ	1$
	TST	CVAL
	BR	3$

1$:	TSTB	SCHSW
3$:	EXIT	BNE
	TSTB	ITCNT
	BEQ	2$
	MOV	#'>+<'<*400>,R0
	JSR	PC,MSTRX
	MOV	#1,ITTER
	MOV	R0,R1
	EXIT

2$:	ERROR	<SC.BAD>
CHEXPL:	MOVB	#'!,R0
	JSR	PC,SSTRX
	MOV	R0,R1
	INC	R1
	EXIT

CHO:	JSR	PC,ARG.1
	BNE	1$
	CLR	CVAL
1$:	MOV	R1,R0
	MOV	CVAL,R1
	CMPB	R1,ITCNT
	BHI	2$
	MUL	#ITPUSH,R1
	ADD	R1,SP
	CMP	SP,STKSV
	BHIS	3$
	MOV	R0,R1
	MOV	R0,-(SP)
	MOV	#MESC,R0
	JSR	PC,SSTRX
	MOV	CSTART,R1
8$:	MOV	#'!,R0
5$:	CMP	R1,CEND
	BHIS	2$
	CMPB	(R1)+,R0
	BNE	5$
	JSR	PC,SSTRX
	MOV	@SP,R2
6$:	CMP	R1,R0
	BHIS	7$
	CMPB	@R2,#MESC
	BEQ	9$
	CMPB	(R1)+,(R2)+
	BEQ	6$
9$:	INC	R0
	MOV	R0,R1
	BR	8$

7$:	CMPB	@R2,#MESC
	BNE	9$
	INC	R0
	MOV	R0,R1
	TST	(SP)+
	EXIT

2$:	ERROR	<O.ERROR>

3$:	ERROR	<SYSTEM.ERROR>
;^W TYPE A STRING

CTW:	JSR	PC,ARG.5
	MOV	#'W-'@,R0
	JSR	PC,STRX
	MOV	#'W-100,R0
	JSR	PC,SSTRX
	MOV	R0,R1
	INC	R1
	MOV	R1,-(R6)
	JSR	PC,QSET
	MOV	R0,R1
	JSR	PC,TYPER
	MOV	(R6)+,R1
	EXIT

;COMMAND ^L (ECHO A FORM FEED)

CTL:	JSR	PC,ARG.5
	MOV	#35,R0
	JSR	PC,TTPUTC
	MOV	#37,R0
	JSR	PC,TTPUTC
	EXIT

;COMMAND = (TYPE OUT VALUE)

CEQ:	JSR	PC,ARG.7
	JSR	PC,PRNUM
	JSR	PC,CRLF
	EXIT

PRNUM:	MOV	CVAL,R0
CEQ1:	JSR	PC,DECOUT
	TST	R0
	BPL	2$
	JSR	PC,DECOUX
	MOV	#40,R0
	JSR	PC,TYO
	MOVB	(SP)+,R2
1$:	MOV	(SP)+,R0
	JSR	PC,TYO
	DEC	R2
	BGT	1$
2$:	RTS	PC

CTG:	JSR	PC,GETCHU
	CMPB	R0,#MESC
	BNE	1$
	JSR	PC,GETCHU
	CMPB	R0,#MESC
	BNE	1$
	JMP	FINISH

1$:	ERROR	<CTG>

CHQUES:	JSR	PC,ARG.5
	COMB	DEBSW
	EXIT
;ROUTINE TO READ IN A Q REGISTER NAME AND RETURN A POINTER TO THE DATA.
;SETS Z BIT IF NOT FOUND, SETS N BIT IF NUMERIC. RETURNS WITH R2 POINTING
;TO FIRST WORD OF QREG HEADER.  FINDQ2 SAME EXCEPT EXPECTS NAME IN R0.

FINDQ:

1$:	JSR	PC,GETCH		;GET A CHAR INTO R0

FINDQ1=.
2$:	CMP	R0,#'@		;LOOK FOR VALID QREG NAMES
	BEQ	3$
	CMP	R0,#'?
	BEQ	3$
	CMP	R0,#'"
	BEQ	3$

	CMP	R0,#'0		;MUST BE GREATER THAN THIS
	BLO	8$		;NOPE, ERROR
	CMP	R0,#'9		;IS IT NUMERIC?
	BLOS	3$		;OK, GO AHEAD AND FIND IT
	CMP	R0,#'A		;ALPHA?
	BLO	8$		;NOPE, ERROR
	CMP	R0,#'Z		;UPPER CASE ALPHA?
	BLOS	3$		;OK!
	CMP	R0,#'a		;WHAT ABOUT LOWER CASE ALPHA
	BLO	8$		;HMM BAD
	CMP	R0,#'z		;REALLY?
	BHI	8$		;MUST BE BAD

FINDQ2=.			;WILL THIS WORK??
3$:	MOV	TBUFX,R2	;INITIALIZE THE SEARCH
	MOVB	R0,QFREG
	MOV	R0,@BOQ		;GET Q REGISTER NAME TO STOP SEARCH

4$:	CMPB	R0,@R2		;IS THIS IT?
	BNE	6$		;NO
	CMP	R2,BOQ		;REALLY FOUND?
	BEQ	5$		;NO, WE RAN OUT OF STUFF
	TST	@R2		;SET FLAG N IF NUMERIC
5$:	RTS	PC

6$:	TST	(R2)+		;NUMERIC?
	BMI	7$		;YUP
	ADD	(R2)+,R2	;ALPHA - ADD COUNT
	BIC	#1,R2		;MAKE WORDS
7$:	TST	(R2)+		;GO TO NEXT
	BR	4$		;CONTINUE

8$:	ERROR	<Q.REG>		;BAD NEWS


;ROUTINE TO DELETE A Q REGISTER

KILLQ:	MOV	#4,R0		;COUNT FOR NUMERIC
	TST	@R2		;IS IT NUMERIC??
	BMI	1$		;YES
	ADD	2(R2),R0	;GET COUNT
	BIC	#1,R0		;MAKE WORDS
	TST	(R0)+		;SKIP TO END
1$:	SUB	R0,CPTR		;RESET ALL THE POINTERS
	SUB	R0,BOB
	SUB	R0,BOQ
	SUB	R0,EOA
	ADD	R2,R0		;ADDRESS TO MOVE FROM
2$:	MOV	(R0)+,(R2)+	;MOVE THINGS UP
	CMP	R2,EOA		;DONE??
	BLO	2$		;NOPE
	TSTB	QMODE
	BEQ	3$
	PUSHR1
	JSR	PC,SETST
	POPR1
	CMP	R1,CEND	;KILL ME?
	BHIS	QK
3$:	RTS	PC

QK:	ERROR	<Q.KILLED>
;ROUTINE TO SET UP THE COMMAND START AND END POINTERS.  EXPECTS AND IMPLICIT
;ARGUMENT IN QMODE, NAMELY THE CHARACTER NAME OF THE QREG TO MACRO.  IF THIS
;CHAR IS ZERO, THE TOP LEVEL COMMAND BUFFER IS ASSUMED. WHAT A KLUDGE.

SETST:	MOVB	QMODE,R0	;THIS SHOULD BE CHAR NAME OF QREG TO MACRO
	BEQ	1$		;NONE, MUST BE AT TOP LEVEL
	JSR	PC,FINDQ2	;SET R2 POINT TO QREG
	BLE	QK		;NONE THERE
	ADD	#4,R2		;THIS WILL BE START OF TEXT
	MOV	R2,CSTART	;SO START COMMAND HERE
	ADD	-2(R2),R2	;GET THE LENGTH AND ADD TO START OF TEXT
	INC	R2		;FUDGE FACTOR
	MOV	R2,CEND		;THIS WILL BE THE END OF THE COMMAND
	RTS	PC

1$:	MOV	LIMBF,CSTART	;REMEMBER WE STARTED HERE...
	MOV	ENBF,CEND	;END ENDED HERE
	RTS	PC



;ROUTINE TO CHECK FOR MORE MEMORY

GETMEX:	MOV	R2,-(SP)
	PUSHR1
	MOV	ENBF,R0
	JSR	PC,GETMEM
	BEQ	1$
	MOV	R0,-(SP)
	MOV	ENBF,R1
	ADD	R1,R0
	MOV	R0,ENBF
	MOV	R0,ENBF.4
	SUB	#6,ENBF.4
	BR	2$

3$:	MOVB	-(R1),-(R0)
2$:	CMP	R1,LIMBF
	BHI	3$
	MOV	R0,LIMBF
	MOVB	QFREG,-(R6)
	JSR	PC,SETST
	MOVB	(R6)+,QFREG
	MOV	(SP)+,R0
1$:	POPR1
	MOV	(SP)+,R2
	TST	R0
	RTS	PC
;SEARCH FOR CHAR IN STRING
;R0=CHAR  R1=PTR  R2=END
;RETURNS WITH R0 POINTING TO THE CHAR IF FOUND, R1 AT INITIAL POSITION

SSTRX:	MOV	CEND,R2
SSTR:	MOV	R1,-(SP)
SSTR2:	CMP	R1,R2
	BHIS	SSTR1
	CMPB	R0,(R1)+
	BNE	SSTR2
SSTR3:	MOV	R1,R0
	DEC	R0
	MOV	(SP)+,R1
	RTS	PC

SSTR1:	MOV	R0,-(SP)
SSTR1X:	MOV	#'[,R0
	JSR	PC,TYO
	MOV	(SP)+,R0
	JSR	PC,TYO
	MOV	#'],R0
	JSR	PC,TYO
	ERROR	<DELIMITER>

MSTRX:	MOV	CEND,R2
	MOV	R1,-(SP)
	CLR	-(SP)
	MOV	R0,-(SP)
	SWAB	R0
1$:	CMP	R1,R2
	BHIS	SSTR1X
	CMPB	R0,@R1
	BNE	3$
	INC	2(SP)
	INC	R1
	BR	1$

3$:	CMPB	@SP,(R1)+
	BNE	1$
	DEC	2(SP)
	BGE	1$
	ADD	#4,SP
	BR	SSTR3
STRX:	MOV	CEND,R2
	PUSHR1
	MOVB	QMODE,QREG
	MOV	R1,QNDX
	SUB	CSTART,QNDX
	MOV	#-25.,-(R6)
	MOV	MPTR,-(R6)
	JSR	PC,CHEK
	JSR	PC,SSTR
	SUB	R1,R0
	MOV	R0,QLEN
STR1:	MOV	(R6)+,MPTR
	TST	(R6)+
	JSR	PC,SETST
	POPR1
	TSTB	SFLG
	BEQ	3$
	MOVB	#'",R0
	JSR	PC,STUFF
3$:	RTS	PC

CHEK:	CMP	R1,R2
	BHIS	SSTR1
CHEK1:	CMPB	(R1),#'P-100
	BEQ	2$
	CMPB	(R1),#'O-100
	BNE	1$
	MOV	#CTLO,(R6)
3$:	INC	R1
1$:	RTS	PC
2$:	MOV	#CTLP,(R6)
	BR	3$

CTLO:	MOVB	(R1),R0
	JSR	PC,FINDQ2
	BLE	CTLO1
	INC	2(R6)
	BEQ	CTLO2
	MOV	R2,R1
	CMP	(R1)+,(R1)+
	CMP	2(R2),#2
	BLT	1$
	JSR	PC,CHEK1
1$:	MOVB	(R2),QREG
	CLR	QNDX
	MOV	2(R2),QLEN
	BR	STR1

CTLO1:	ERROR	<$O.REG>
CTLO2:	ERROR	<$O.LOOP>

CTLP:	TST	MPTR
	BEQ	ZROLN
	MOVB	(R1),R0
	CMP	R0,#'1
	BLT	4$
	CMP	R0,#'9
	BLE	1$
4$:	JSR	PC,FINDQ2
	BGE	3$
	MOV	2(R2),R0
	BGT	CTLP3
	ERROR	<$P.ARG>
3$:	ERROR	<$P.REG>

1$:	SUB	#60,R0
CTLP3:	MOV	R0,-(R6)
	CMPB	R0,QARG
	BLOS	1$
	MOVB	R0,QARG
1$:	MOVB	@MPTR,R0
	ADD	#2,MPTR
	MOVB	R0,QREG
	BNE	10$
	MOV	LIMBF,R1
	MOV	R1,-(R6)
	MOV	ENBF,R2
	BR	11$

10$:	JSR	PC,FINDQ2
	CMP	(R2)+,(R2)+
	MOV	R2,-(R6)
	MOV	R2,R1
	ADD	-2(R2),R2

11$:	MOV	MPTR,R0
	MOV	(R6),R5
	ADD	(R0),R1
	TST	(R0)+
	MOV	(R0),MPTR
	MOVB	-12(R0),R0

	ADD	#MESC,R0
	CMP	R0,#MESC
	BEQ	5$
	MOVB	(R1)+,R0
5$:	MOV	R0,QLEN

	MOVB	QMODE,-(R6)
	MOVB	QREG,QMODE
3$:	MOV	QLEN,R0
	JSR	PC,SSTR
	DEC	4(R6)
	BEQ	CTLP4
	MOV	R0,R1
	INC	R1
	BR	3$

ZROLN:	CLR	QNDX
	CLR	QLEN
	JMP	STR1

CTLP4:	MOVB	(R6)+,QMODE
	SUB	R1,R0
	MOV	R0,QLEN
	CMP	(R6)+,(R6)+
	CMP	R0,#2
	BLT	1$
	JSR	PC,CHEK1
1$:	SUB	R5,R1
	MOV	R1,QNDX
	JMP	STR1

QSET:	MOVB	QREG,R0
	BNE	1$
	MOV	LIMBF,R2
	BR	2$

1$:	JSR	PC,FINDQ2
	BGT	3$
	ERROR	<Q.KILLED>
3$:	CMP	(R2)+,(R2)+
2$:	ADD	QNDX,R2
	MOV	R2,R0
	ADD	QLEN,R2
	RTS	PC

STUFF:	PUSHR1
	INCB	QFLG
	MOV	#1$,-(R6)
	TST	-(R6)
	MOV	QLEN,-(R6)
	MOV	(R6),-(R6)
	JSR	PC,FINDQ2
	JMP	QINSR1
1$:	JSR	PC,SETST
	POPR1
	CLRB	QFLG
	RTS	PC


FIXUP:	MOV	(R6)+,R5
	MOV	STKSV,R6
	CLRB	QMODE
	JSR	PC,CLRPDS
	CLRB	RBOUT
	CLR	FFLAG
	MOV	EOA,R1
	CLR	MPTR
	CLRB	EMFLG
	CLRB	MFLG
	CLRB	QFLG
	JMP	@R5
GETCHU:	JSR	PC,GETCH
	JMP	GETUC

GETCH:	CMP	R1,CEND
	BHIS	1$
	MOVB	(R1)+,R0
	TSTB	DEBSW
	BEQ	2$
	JSR	PC,TYO
2$:	RTS	PC

1$:	ERROR	<CMD.END>

CHKSEP:	CMPB	R0,#'$
	BEQ	2$
	CMPB	R0,#'.
	BEQ	2$
	CMPB	R0,#'0
	BLO	1$
	CMPB	R0,#'9
	BLOS	2$
	CMPB	R0,#'A
	BLO	1$
	CMPB	R0,#'Z
	BLOS	2$
	CMPB	R0,#'A
	BLO	1$
	CMPB	R0,#'Z
	BLOS	2$
1$:	SEC
	RTS	PC

2$:	CLC
	RTS	PC

CLRPDS:	MOVB	QMODE,-(R6)
	CLRB	QMODE
3$:	TSTB	QPDS
	BEQ	1$
	MOVB	QPDS,R0
	INCB	QPDS
	JSR	PC,FINDQ2
	BEQ	3$
	JSR	PC,KILLQ
	BR	3$

1$:	TSTB	EMPDS
	BEQ	2$
	MOVB	EMPDS,R0
	DECB	EMPDS
	JSR	PC,FINDQ2
	BEQ	1$
	JSR	PC,KILLQ
	BR	1$

2$:	MOVB	(R6)+,QMODE
	RTS	PC
IPUTC:	TSTB	FFLG
	BGT	6$
	CLRB	FFLG
IPUT=.
	MOVB	#-1,INCHR
	CLR	INCNT
IPUT1=.
	TSTB	FFLG
	BGT	6$
	TSTB	INPFLG
	BEQ	4$
	MOV	#6,R2
	TSTMEM	R2,1$
	TSTB	FFLG
	BMI	5$
	CLRB	FFLG
2$:	JSR	PC,PRI
	BCS	7$
	CMP	R0,#14
	BNE	3$
	DECB	FFLG
6$:	RTS	PC

5$:	MOV	#14,R0
	CLRB	FFLG
3$:	MOVB	R0,(EOA)+
	CMPB	R0,INCHR
	BEQ	6$
	DEC	INCNT
	BEQ	6$
	JSR	PC,CHECKC
	MOV	#400,R2
	TSTMEM	R2,,2$
	RTS	PC

4$:	ERROR	<NO.INPUT>

1$:	ERROR	<INPUT.ROOM>

7$:	INCB	FFLG		;EOF FLAG
	RTS	PC

OPUT:	TSTB	OUTFLG	;ANY OUTPUT FILE
	BNE	1$		;YES
	ERROR	<NO.OUTPUT>

1$:	MOV	R1,-(SP)
	MOV	R0,R1
	JSR	PC,PPOL
	MOV	(SP)+,R1
	RTS	PC
SCBF:	JSR	PC,SETLIM
	SUB	R5,R1
	JSR	PC,QSET
	CLR	NUM
	MOV	QLEN,R2
	BEQ	SCBFX
1$:	CMPB	(R0)+,#'C-100
	BEQ	2$
	CMPB	-1(R0),#'N-100
	BNE	3$
2$:	DEC	R2
	INC	R0
3$:	INC	NUM
	DEC	R2
	BGT	1$

SCBFX:	MOVB	#-1,SCHSW
	JSR	PC,QSET
	MOV	R1,-(R6)
	MOV	R0,-(R6)
9$:	MOV	(R6),R0
	MOV	CPTR,R2
	MOV	QLEN,R1

1$:	TST	R1
	BEQ	12$
	CMP	R2,EOA
	BHIS	13$
	CMPB	@R0,#'X-'@
	BHI	2$
	BEQ	5$
	CMPB	@R0,#'C-'@
	BNE	4$
	JSR	PC,SCHECK
	BR	2$

5$:	CMPB	(R0)+,(R2)+
20$:	DEC	R1
	BR	1$

4$:	CMPB	@R0,#'N-'@
	BNE	8$
	JSR	PC,SCHECK
	CMPB	(R0)+,(R2)+
	BNE	20$
	BR	3$

8$:	CMPB	@R0,#'D-'@
	BNE	2$
	MOV	R0,-(SP)
	MOVB	(R2)+,R0
	JSR	PC,CHKSEP
	MOV	(SP)+,R0
	INC	R0
	BCS	20$
	BR	3$

2$:	DEC	R1
	CMPB	(R0)+,(R2)+
	BEQ	1$
3$:	INC	CPTR
	BR	9$

12$:	MOV	R2,CPTR
	CLC
	BR	14$

13$:	MOV	BOB,CPTR
	CLRB	SCHSW
	SEC
14$:	MOV	2(R6),R1
	MOV	(R6)+,(R6)+
	RTS	PC
SCHECK:	INC	R0
	CMP	R1,#2
	BLT	1$
	DEC	R1
	RTS	PC
1$:	ERROR	<S.STRING>

CHECKC:
.IFNZ SITS
	TST BRAKE
	BLE 1$
	INC GOSW
	CLR BRAKE
.ENDC
	TSTB	GOSW
	BEQ	1$
	MOV	STKSV,SP
	MOV	EOA,R1
	JMP	BAKG

1$:	RTS	PC
;TYPE ONE ARGUMENT - C, R, D

ARG.8:	JSR	PC,ARG.2
LFB1:	MOV	R0,R2		;DUP IT
	CMP	R0,CPTR		;BEFORE OR AFTER??
	BHI	11$		;BEFORE
	MOV	CPTR,R2		;FIX
	RTS	PC			;AND QUIT

11$:	MOV	CPTR,R0		;LOWER ONE
	RTS	PC			;FINI

;TYPE TWO ARGUMENT - L

ARG.9:	JSR	PC,ARG.3
	BR	LFB1

;TYPE FOUR ARG - T, K,X, ...

ARG.11:	CMP	STATE,#14
	BNE	ARG.9		;LINE ORIENTED
				;DROP FOR TWO ARGS

;TYPE THREE ARG - X,Y

ARG.10:	TSTB	COLSW
	BNE	COLBAD
	MOV	CVAL,R2
	MOV	CVAL1,R0
	ADD	BOB,R0
	CMP	R0,EOA
	BHI	FXARG1
	ADD	BOB,R2
	CMP	R2,R0
	BLO	FXARG1
	CMP	R2,EOA
	BLOS	FXARG2
	MOV	EOA,R2
FXARG2:	RTS	PC

FXARG1:	ERROR	<EXP>

;TYPE 5 ARG - NO ARG - EX, ...

ARG.5:	TSTB	COLSW
	BNE	COLBAD
	TST	STATE
	BEQ	1$		;GOOD
EARG5=.
	ERROR	<ARG5>

1$:	RTS	PC
;TYPE 6 ARG - 1 OR NONE

ARG.6:	TSTB	COLSW
	BNE	COLBAD
	BIT	#13,STATE
	BEQ	1$
	ERROR	<ARG6>

1$:	RTS	PC

COLBAD:	ERROR	<COLON.ERROR>

;TYPE SEVEN ARG - EXACTLY ONE

ARG.7:	TSTB	COLSW
	BNE	COLBAD
	CMP	STATE,#4	;IS IT?
	BEQ	1$		;YUP
	ERROR	<ARG7>

1$:	RTS	PC

;TYPE 8 ARG - 0 OR 1 AND SET CODES EQ FOR 0 NE FOR 1

ARG.1:	TSTB	COLSW
	BNE	COLBAD
ARG.1A:	BIT	STATE,#13
	BEQ	1$
	ERROR	<ARG1>

1$:	TST	STATE
	RTS	PC

;TYPE 9

ARG.2:	TSTB	COLSW
	BNE	COLBAD
	CMP	STATE,#4
	BLOS	18$		;GOOD
	ERROR	<ARG2>

18$:	MOV	CVAL,R0	;GET ARG
ARG.21:	ADD	CPTR,R0	;MAKE REAL ADDR
	CMP	R0,EOA		;TOO FAR?
	BLOS	1$		;NO
	MOV	EOA,R0		;FIX IT
	RTS	PC

1$:	CMP	R0,BOB	;BEFORE BUFFER?
	BHIS	2$		;GOOD
	MOV	BOB,R0	;FIX IT
2$:	RTS	PC
;TYPE 10

ARG.3:	TSTB	COLSW
	BNE	COLBAD
	MOV	CVAL,R2	;SET UP ARG
	MOV	CPTR,R0
	CMP	STATE,#4
	BLOS	$7
	ERROR	<ARG3>

$7:	BEQ	LFQ
	TST	STATE
	BEQ	LFF
LFB:	CMP	R0,BOB
	BLOS	LFF1
	CMPB	-(R0),#15
	BNE	LFB
	INC	R2
	BLE	LFB
	INC	R0
LFF1:	RTS	PC

LFQ:	TST	R2
	BLE	LFB
LFF:	CMP	R0,EOA
	BHIS	LFF1
	CMPB	(R0)+,#15
	BNE	LFF
	DEC	R2
	BGT	LFF
	RTS	PC

ARG.4:	BIT	#13,STATE
	BEQ	1$
	ERROR	<ARG4>

1$:	RTS	PC


;TYPE 12 ARG 1 OR 2 ARGS, THE LAST ONE MUST BE IN RANGE 0-127, FOR RCMAC

ARG.12:	TSTB	COLSW		;NO COLONS
	BNE	COLBAD
	TST	STATE		;WE BETTER HAVE AT LEAST ONE ARG
	BEQ	1$		;HMM BAD
	CMP	CVAL,#128.	;MAKE SURE IT'S VALID
	BHIS	1$		;TOO HIGH
	CMP	STATE,#4	;SET Z IF WE HAVE ONE ARG
	RTS	PC

1$:	ERROR	<ARG12>

;	.CSECT	STACK

	.NLIST	BEX
INIT:	.ASCIZ	/EMTECO.INIT/<33><33>
WATCH:	.ASCII	<12>/NEARING END OF BUFFER!!/<12>
WATCHN:
FILMSG:	.ASCII	<12>/FILE CREATED/<12>
FILMEN:
QMSG:	.ASCII	/IN MACRO  Q-REG - /
QMEN:
QMSGE:	.ASCII	/IN EXTERNAL MACRO - /
QMSGN:
	.EVEN
	.LIST	BEX
;DISPATCH TABLE

DTAB:
				;CONTROL CHARS.
	.WORD	NONE	;NULL
	.WORD	NONE	;^A
	.WORD	CTB	;^B
	.WORD	NONE	;^C
	.WORD	NONE	;^D
	.WORD	CTE	;^E
	.WORD	CTLF	;^F
	.WORD	CTG	;^G
	.WORD	CTLH	;^H
	.WORD	CHTAB	;^I (TAB)
	.WORD	NULL	;^J (LF)
	.WORD	CTLK	;^K
	.WORD	CTL	;^L
	.WORD	NULL	;^M (CR)
	.WORD	CTLN	;^N
	.WORD	NONE	;^O
	.WORD	NONE	;^P
	.WORD	NONE	;^Q
	.WORD	NONE	;^R
	.WORD	NONE	;^S
	.WORD	CTT	;^T
	.WORD	NONE	;^U
	.WORD	CTLV	;^V
	.WORD	CTW	;^W
	.WORD	CTRX	;^X
	.WORD	CTRY	;^Y
	.WORD	CTLZ	;^Z
				;FUNNY CTRL & SPECIALS
	.WORD	CMESC	;ESC
	.WORD	NONE	;^\
	.WORD	NONE	;^]
	.WORD	CTUP	;^^
	.WORD	NONE	;^_
	.WORD	NULL	;SP
	.WORD	CHEXPL	; !
	.WORD	CHDQ	; "
	.WORD	CHOR	; #
	.WORD	NONE	; $
	.WORD	CHPER	; %
	.WORD	CHAND	; &
	.WORD	NULL	; '
	.WORD	CHLP	; (
	.WORD	CHRP	; )
	.WORD	CHMUL	; *
	.WORD	CHPL	; +
	.WORD	CHCOM	; ,
	.WORD	CHMI	; -
	.WORD	CHPD	; .
	.WORD	CHDIV	; /
				;NUMERALS
.REPT	10.
	.WORD	CHNM	; 0-9
.ENDR
				;MORE SPECIALS
	.WORD	CHCOL	; :
	.WORD	CSC	; ;
	.WORD	CLB	; <
	.WORD	CEQ	; =
	.WORD	CRB	; >
	.WORD	CHQUES	; ?
	.WORD	CHAT	; @
				;ALPHABETICS
	.WORD	CHA	; A
	.WORD	CHB	; B
	.WORD	CHC	; C
	.WORD	CHD	; D
	.WORD	CHE	; E
	.WORD	CHF	; F
	.WORD	CHG	; G
	.WORD	CHH	; H
	.WORD	CHI	; I
	.WORD	CHJ	; J
	.WORD	CHK	; K
	.WORD	CHL	; L
	.WORD	CHM	; M
	.WORD	CHN	; N
	.WORD	CHO	; O
	.WORD	CHP	; P
	.WORD	CHQ	; Q
	.WORD	CHR	; R
	.WORD	CHS	; S
	.WORD	CHT	; T
	.WORD	CHU	; U
	.WORD	CHV	; V
	.WORD	NONE	; W
	.WORD	CHX	; X
	.WORD	CHY	; Y
	.WORD	CHZ	; Z
	.WORD	CHLBR	; [
	.WORD	CHBS	; \
	.WORD	CHRBR	; ]
	.WORD	NONE	; ^
	.WORD	CHBA	; _


;TABLE OF SYMBOLS ACCESSIBLE TO TECO

.MACRO	DEFSYM	NAME,FUNCTION,ARGS
	.ASCIZ	NAME
	.EVEN
	NARGS = 0
	.IRP	ARG,<ARGS>
	NARGS = NARGS + 1
	.ENDR
	.WORD	NARGS*2
	.IRP	ARG,<ARGS>
	.WORD	ARG
	.ENDR
	.WORD	FUNCTION
.ENDM

SYMTAB:	DEFSYM	"%BOTTOM",SYMLOC,<BOTTOM,0>	;BOTTOM MARGIN
	DEFSYM	"%TOP",SYMLOC,<TOP,0>		;TOP MARGIN
	DEFSYM	"%CENTER",SYMLOC,<CENTER,0>	;CENTER OF WINDOW
	DEFSYM	"HEIGHT",SYMLOC,<PAGSIZ,0>	;SIZE OF SCREEN IN LINES
	DEFSYM	"WIDTH",SYMLOC,<LLEN,0>		;LINE LENGTH IN CHARS
	DEFSYM	"WINDOW",SYMLOC,<WINDOW,0>	;NUMBER OF FIRST CHAR IN WINDOW
	DEFSYM	"GRAPHM",SYMGRF,<GRAPHM,1>	;GRAPHICS MODE FLAG
	DEFSYM	"ECHOSW",SYMLOC,<ECHOSW,1>	;0=>ECHO ON, 1=>ECHO OFF
	DEFSYM	"LINESIZE",SYMLIN,<>		;NUMBER OF SCREEN LINES OF . 
	DEFSYM	"CRLF",SYMLOC,<CRLFSW,1>	;CRLF SWITCH
	DEFSYM	"CRALT",SYMLOC,<AMSW,1>		;EXCH CR AND ALT
	DEFSYM	"RHPOS",SYMCUR,<HPOS,0>		;HORIZONTAL POSITION OF CURSOR
	DEFSYM	"RVPOS",SYMCUR,<VPOS,0>		;VERTICAL POSITION OF CURSOR
	DEFSYM	"RMODE",SYMLOC,<RMODE,0>	;0=>NORMAL, 1=>^RMODE
	DEFSYM	"REXPT",SYMLOC,<REXPT,0>	;EXPONENT FOR ^R COMMANDS
	DEFSYM	"RMARK",SYMLOC,<RMARK,0>	;MARK FOR ^R COMMANDS
	DEFSYM	"RAMAC",SYMCST,<RAMAC>		;READ AND WRITE RAMAC ARRAY
	DEFSYM	"RBMAC",SYMCST,<RBMAC>		;READ AND WRITE RBMAC ARRAY
	DEFSYM	"RCMAC",SYMCST,<RCMAC>		;READ AND WRITE RCMAC ARRAY
	DEFSYM	"REXEC",SYMEXC,<>		;EXECUTE ^R MODE FUNCTIONS
	DEFSYM	"RLASTCH",SYMLOC,<LASTCH,0>	;LAST CHAR READ IN ^R MODE
;	DEFSYM	"USR_TIME",SYMTIM,<PUT+2,0>	;PROCESS USR TIME
;	DEFSYM	"SYS_TIME",SYMTIM,<PST+2,0>	;PROCESS SYSTEM TIME
;	DEFSYM	"CHILD_USR_TIME",SYMTIM,<CUT+2,0>	;CHILD USR TIME
;	DEFSYM	"CHILD_SYS_TIME",SYMTIM,<CST+2,0>	;CHILD SYS TIME
;	DEFSYM	"CHILD_STATUS",SYMLOC,<KIDSTA,1>	;STATUS OF CHILD
;	DEFSYM	"CHILD_ERROR_CODE",SYMLOC,<KIDERR,1>	;ERROR CODE OF CHILD
	DEFSYM	"BELL",SYMBELL,<>		;RING THE BELL
	DEFSYM	"QTEST",SYMQTS,<>		;RETURN STATUS OF REG
	DEFSYM	"^RMODE",SYMLOC,<RMODE,0>	;0=>NORMAL, 1=>^RMODE
	DEFSYM	"^REXPT",SYMLOC,<REXPT,0>	;EXPONENT FOR ^R COMMANDS
	DEFSYM	"^RCMAC",SYMCST,<RCMAC>		;READ AND WRITE RCMAC ARRAY
	DEFSYM	"^REXEC",SYMEXC,<>		;EXECUTE ^R MODE FUNCTIONS
	DEFSYM	"^RLASTCH",SYMLOC,<LASTCH,0>	;LAST CHAR READ IN ^R MODE
	DEFSYM	"^RHPOS",SYMCUR,<HPOS,0>	;HORIZONTAL POSITION OF CURSOR
	DEFSYM	"^RVPOS",SYMCUR,<VPOS,0>	;VERTICAL POSITION OF CURSOR
	.WORD	0				;END THE SYMBOL TABLE
	.SBTTL	^R MODE COMMANDS

;THIS SECTION PROCESSES THE ^R MODE COMMANDS.  RCH IS THE MAIN DISPATCH
;ROUTINE OF THESE COMMANDS CORRESPONDING TO CHX FOR THE NORMAL COMMANDS.
;THE CONTROL R MODE COMMANDS DIFFER FROM NORMAL COMMANDS IN THAT THEY ARE
;EXECUTED AS SOON AS THE CHAR IS READ FROM THE TTY.  NORMALLY, NON-CONTROL,
;NON-RUBOUT CHARS ARE SIMPLY INSERTED IN THE BUFFER AND SOME DISPLAY UPDATE
;IS RTS	PC.  CONTROL CHARS AND RUBOUT EXECUTE SPECIAL FUNCTION SUCH AS MOVING
;THE CURSOR AROUND, DELETING CHARS ETC.

;^R MODE DISPATCHING

;AS EACH CHAR IS READ IN, IT IS USED TO EXECUTE A COMMAND BASED ON THE
;THE R MODE DISPATCH TABLE, RCMAC.  THIS TABLE IS A VECTOR OF NUMBERS
;WHICH CAN BE MODIFIED BY THE USER VIA THE FV^RCMACRO$ COMMAND.  THE CHAR
;READ IN, DISPATCHES INTO THIS TABLE AND A NUMBER IS READ OUT. POSITIVE
;NUMBERS ARE ASSUMED TO BE THE ASCII VALUE OF A QREGISTER TO MACRO.
;THE QREGISTER IS MACRO'D VIA CHM AND RETURNS TO RCH VIA THE CHX JMP.
;NEGATIVE NUMBERS ARE FIRST CONVERTED TO POSITIVE, THEN USED TO SELECT
;A ^RMODE COMMAND VIA THE RDTAB.

;.CSECT PGM

RCH:	CLR	RMODE1		;JUST SOME INITIALIZATION FOR CONTROL KLUDGE
	TST	RMODE		;ARE WE STILL IN ^R MODE?
	BEQ	1$		;NO, RETURN TO CALLER
	MOV	#RCMAC,R1	;USE THE C TABLE FOR DISPATCHING
	JSR	PC,RCHDSP	;NOW DISPATCH
	BR	RCH		;NOW CHECK FOR MORE

1$:	RTS	PC



;DISPATCH ROUTINE.  EXPECTS R1 TO HOLD A POINTER TO A TABLE 128 WORDS LONG.
;NEGATIVE NUMBERS IN THE TABLE REFER TO RDTAB ROUTINES, POSITIVE NUMBERS
;REFER TO Q REGISTERS.

RCHDSP:	JSR	PC,TYI		;GET A CHAR INTO R0
	MOV	R0,LASTCH	;SAVE THE CHAR
	BIC	#177600,R0	;MAKE SURE IT'S 0-127
	ASL	R0		;CONVERT TO WORD OFFSET
	ADD	R0,R1		;ADD THE BASE ADDRESS OF THE TABLE
	MOV	(R1),R0		;GET THE FUNCTION TO EXECUTE
	BLE	RCHJMP		;NEGATIVE, THUS DISPATCH INTO RDTAB
	JSR	PC,FINDQ1	;SET POINTERS TO PROPER Q REGISTER
	BLE	1$		;NOT ALPHA Q REG
	MOV	#1,RMODE1	;TELL SOME PEOPLE WE ARE DOING ^R MODE
	JMP	CHM3		;OTHERWISE, MACRO THIS QREGISTER

1$:	ERROR	<Q.BAD>

RCHCNT:	RTS	PC		;CONTINUATION POINT FOR MACROS



;ROUTINE TO ACTUALLY JUMP THROUGH THE DISPATCH TABLE.  IT IS LABLED
;SEPARATELY BECAUSE IT IS ALSO CALLED BY SYMEXC TO EXECUTE FUNCTIONS.

RCHJMP:	NEG	R0		;CONVERT TO POSITIVE
	ASL	R0		;CONVERT TO WORD OFFSET
	CMP	R0,#RDSIZ	;MAKE SURE ITS A VALID FUNCTION
	BHIS	1$		;TOO HIGH
	JMP	@RDTAB(R0)	;EXECUTE THE FUNCTION

1$:	ERROR	<RMODE>
;ROUTINE TO RING THE TERMINAL'S BELL IMPLYING UNDEFINED ^R CHAR

RCHUDF:	JSR	PC,BELL		;RING THE TERMINAL'S BELL
	RTS	PC



;ROUTINE TO ESCAPE FROM ^R MODE

RCHESC:	CLR	RMODE		;JUST CLEAR THE FLAG
	RTS	PC



;ROUTINE TO SELECT A NEW DISPLAY WINDOW AND UPDATE THE SCREEN

RCHL:	JSR	PC,SETWIN	;SELECT A NEW WINDOW
	MOV	WINDOW,R0
	ADD	BOB,R0		;MAKE IT ABSOLUTE
	JSR	PC,TYPSCN	;TYPE EVERYTHING FROM R0 TO BOTTOM
	JSR	PC,UPDATE	;NOW SET THE CURSOR
	RTS	PC



;ROUTINE TO MULTIPLY THE EXPT BY 4

RCHU:	MOV	REXPT,R0	;GET THE RMODE EXPT
	MUL	#4.,R0		;MULTIPLY IT BY 4
	MOV	R1,REXPT	;PUT IT BACK
	RTS	PC



;ROUTINE TO READ A QUOTED CHAR

RCHQ:	JSR	PC,TYI			;GET A CHAR INTO R0
	JSR	PC,RSTTY	;RESET SOME TTY STUFF
	MOV	R0,LASTCH	;SAVE IT
	JSR	PC,RCHNRM	;INSERT IT INTO THE BUFFER
	RTS	PC
;ROUTINE TO INSERT NORMAL CHARS INTO BUFFER

RCHNRM:	PUSH	<CPTR>		;SAVE CURRENT CURSOR POSITION
	JSR	PC,LINSIZ	;GET THE SCREEN SIZE OF . LINE INTO R0
	MOV	R0,R1		;SAVE IT
	MOV	LASTCH,R0	;GET THE ACTUAL CHAR
	JSR	PC,INSERT	;INSERT IT INTO THE BUFFER
	JSR	PC,LINSIZ	;GET THE SCREEN SIZE OF . LINE INTO R0
	CMP	R0,R1		;HAS THE LINE GROWN?
	BNE	1$		;YES, MUST REDISPLAY REST OF SCREEN
	MOV	(SP),R0		;GET OUR OLD CURSOR POSITION
	MOV	#1,R1		;GO FORWARD ONE LINE
	JSR	PC,LINE		;ADVANCE R0 TO END OF CURRENT LINE
	MOV	R0,R2		;THIS WILL BE THE END POINTER
	MOV	(SP),R1		;OLD CHAR POSITION IS START POINTER
	PUSH	<HPOS,VPOS>	;SAVE OUR OLD POSITION
	JSR	PC,TYPER	;TYPE TO END OF LINE
	POP	<R1,R2,R0>	;SET UP THE ARGUMENTS TO COUNT
	MOV	#1,R5		;WE WANT TO COUNT 1 CHAR POSITION
	JSR	PC,COUNT	;FIGURE OUT WHERE TO LEAVE THE CURSOR
.IIF NZ DATAP,	JSR	PC,RECCUR
	MOV	R1,VPOS		;NEW VERTICAL POSITION
	MOV	R2,HPOS		;NEW HORIZONTAL POSITION
	JSR	PC,SETCUR	;PUT THE CURSOR THERE
	RTS	PC

1$:	POP	<R0>		;RESTORE OUR ORIGINAL CURSOR POSITION
	JSR	PC,TYPSCN	;TYPE EVERYTHING FROM HERE DOWN
	JSR	PC,UPDATE	;PUT THE CURSOR IN THE RIGHT SPOT
	RTS	PC




;ROUTINE TO INSERT A CR

RCHM:	PUSH	<CPTR>		;SAVE OUR CURRENT CURSOR
	MOV #15,R0
	JSR PC,INSERT
	MOV	#12,R0		;INSERT A NL IN BUFFER
	JSR	PC,INSERT
	POP	<R0>		;GET OUR OLD CURSOR POSITION
	JSR	PC,TYPSCN	;TYPE TO BOTTOM OF THE SCREEN
	JSR	PC,UPDATE	;PUT THE CURSOR IN THE RIGHT PLACE
	RTS	PC
;ROUTINE TO DELETE CHARS FROM THE BUFFER

RCHD:	MOV	REXPT,R1	;GET A COPY OF THE EXPT
	BEQ	5$		;ZERO, SO NOTHING TO DO
	CMP	CPTR,EOA	;ARE WE AT THE END OF THE WORLD?
	BHIS	RCHER1		;YES, NOTHING TO DELETE
	MOV	CPTR,R0		;NOW SEE IF WE WILL DELETE ANY NL'S

1$:	CMP	R0,EOA		;ARE WE AT THE END YET?
	BHIS	2$		;YUP, OK NOTHING LEFT TO CHECK
	CMPB	(R0)+,#15	;CHECK FOR A NEWLINE
	BEQ	6$		;FOUND ONE, DO WHOLE SCREEN UPDATE
	SOB	R1,1$		;KEEP CHECKING

2$:	JSR	PC,LINSIZ	;GET THE LENGTH OF CURRENT LINE
	PUSH	<R0>		;SAVE IT
	MOV	CPTR,R0		;GET ANOTHER COPY OF CURSOR
	MOV	R0,R2		;COPY IT
	ADD	REXPT,R2	;TO DELETE THIS MANY CHARS
	CMP	R2,EOA		;HAVE WE GONE TOO FAR?
	BLOS	3$		;NO, IT'S OK
	MOV	EOA,R2		;ELSE, PUT IT TO THE END

3$:	JSR	PC,DELE		;DELETE IT FROM BUFFER
	JSR	PC,LINSIZ	;NOW SEE HOW LONG THE LINE IS
	CMP	R0,(SP)+	;HAS IT CHANGED?
	BNE	8$		;YES, TYPE TO BOTTOM OF SCREEN
	MOV	CPTR,R0		;GET ANOTHER COPY OF CURSOR
	MOV	#1,R1		;WE WANT TO GO FORWARD 1 LINE
	JSR	PC,LINE		;MOVE R0
	MOV	R0,R2		;COPY IT
	MOV	CPTR,R0		;GET POINTER TO STARTING POSITION
	JSR	PC,GTYPER	;TYPE IT
	CMP	R2,EOA		;ARE WE AT END OF WORLD?
	BLO	4$		;NO, EVERYTHINGS OK
	JSR	PC,KILLLN	;ELSE KILL TO END OF THIS LINE
4$:	JSR	PC,UPDATE	;PUT THE CURSOR WHERE IT BELONGS
5$:	MOV	#1,REXPT	;RESET THE EXPT
	RTS	PC

6$:	MOV	CPTR,R0		;GET THE CURSOR
	MOV	R0,R2		;COPY THE CURSOR
	ADD	REXPT,R2	;DELETE THIS MUCH
	CMP	R2,EOA		;WOULD WE GO TOO FAR?
	BLOS	7$		;NO, IT'S OK
	MOV	EOA,R2		;ELSE RESET IT
7$:	JSR	PC,DELE		;DO IT

8$:	MOV	CPTR,R0		;GET COPY OF CURSOR POSITION
	JSR	PC,TYPSCN	;TYPE TO BOTTOM OF SCREEN
	JSR	PC,UPDATE	;PUT THE CURSOR WHERE IT BELONGS
	MOV	#1,REXPT	;RESET THE EXPT
	RTS	PC


;ROUTINE TO KILL REST OF A LINE

RCHK:	CMP	CPTR,EOA	;IS THERE ANYTHING TO KILL?
	BHIS	RCHER1		;NO, ERROR
	MOV	CPTR,R0		;COPY THE POINTER
	MOV	REXPT,R1	;TO GO FORWARD ONE LINE
	BLE	1$		;FOR NOW, HAD BETTER BE POSITIVE
	JSR	PC,LINE		;MOVE R0 FORWARD
	MOV	R0,R2		;THIS WILL BE END MARKER
	MOV	CPTR,R0		;COPY POINTER AGAIN
	JSR	PC,DELE		;KILL THE LINE
	MOV	CPTR,R0		;COPY POINTER ONCE MORE
	JSR	PC,TYPSCN	;TYPE TO END OF SCREEN
	JSR	PC,UPDATE	;PUT CURSOR WHERE IT BELONGS
1$:	MOV	#1,REXPT	;RESET REXPT
	RTS	PC



;ROUTINE TO RUBOUT

RCHRUB:	CMP	CPTR,BOB	;ARE WE ALREADY AT BEGINNING
	BLOS	RCHER1		;YES, NOTHING TO RUBOUT
	MOV	CPTR,R0		;GET A COPY OF THE CURSOR
	SUB	REXPT,R0	;SEE IF THIS WOULD CAUSE IT TO GO TOO FAR
	CMP	R0,BOB		;TOO FAR?
	BHIS	1$		;NO, IT'S OK
	MOV	CPTR,R0		;ELSE COMPUTE THE MAXIMUM WE CAN GO BACK
	SUB	BOB,R0		;THIS IS IT
	MOV	R0,REXPT	;USE THIS AMOUNT

1$:	PUSH	<REXPT>		;SAVE IT
	JSR	PC,RCHH		;GO BACK EXPT CHARS
	POP	<REXPT>		;NOW DELETE THIS MUCH
	JSR	PC,RCHD		;KILL THE CHAR
	MOV	#1,REXPT	;RESET THE EXPT
	RTS	PC



;ERROR ROUTINE, JUST RINGS A BELL

RCHER1:	JSR	PC,BELL		;GIVE HIM AN ERROR
	MOV	#1,REXPT	;RESET THE EXPT
	RTS	PC
;ROUTINE TO HANDLE THE SPECIAL KEYS ON A VT52. THE DEFAULT IS
;TO USE THIS TABLE TO DISPATCH ON THE $X CHARS.

RCHALT:	MOV	#RAMAC,R1	;USE THE A TABLE TO DISPATCH
	JMP	RCHDSP		;DISPATCH OFF THE NEXT INPUT CHAR	




;ROUTINE TO DISPATCH ON STILL ANOTHER TABLE.  THE DEFAULT IS
;TO USE THIS TABLE TO DISPATCH ON THE $?X CHARS IE NUMBERS ON ALT KEYPAD.

RCHQST:	MOV	#RBMAC,R1	;USE THE B TABLE TO DISPATCH
	JMP	RCHDSP		;DISPATCH OFF THE NEXT INPUT C
;ROUTINE TO MOVE BACK LINES

RCHP:	CMP	CPTR,BOB	;ARE WE AT THE BEGINNING?
	BLOS	RCHERR		;YES, NO WHERE TO GO
	NEG	REXPT		;TO MOVE BACK REXPT LINES
	BR	RCHNP		;COMMON ROUTINE



;ROUTINE TO MOVE TO NEXT LINE

RCHN:	CMP	CPTR,EOA	;ARE WE AT THE END ALREADY?
	BHIS	RCHERR		;YES ERROR

RCHNP:	MOV	CPTR,R0
	MOV	REXPT,R1	;GO DOWN EXPT LINES
	MOV	#1,REXPT	;RESET EXPT
	JSR	PC,LINE		;MOVE R0
	MOV	R0,CPTR		;RESET POINTER
	JSR	PC,UPDATE	;RESET CURSOR
	RTS	PC



;ROUTINE TO MOVE BACK CHARS

RCHH:	CMP	CPTR,BOB	;ARE WE ALREADY AT BEGINNING?
	BLOS	RCHERR		;YES, CAN'T GO BACK ANY MORE
	SUB	REXPT,CPTR	;MOVE THE CURSOR BACK
	CMP	CPTR,BOB	;DID WE GO TOO FAR?
	BHIS	RCHFH		;NO, IT'S OK
	MOV	BOB,CPTR	;ELSE FIX IT
	BR	RCHFH		;COMMON ROUTINE


;ROUTINE TO MOVE FORWARD CHARS

RCHF:	CMP	CPTR,EOA	;ARE WE AT THE END?
	BHIS	RCHERR		;YUP, NO WHERE TO GO
	ADD	REXPT,CPTR	;MOVE THE CURSOR FORWARD
	CMP	CPTR,EOA	;TOO FAR?
	BLOS	RCHFH		;NO, ITS OK
	MOV	EOA,CPTR	;ELSE FIX IT

RCHFH:	MOV	#1,REXPT	;RESET THE EXPT
	JSR	PC,UPDATE	;PUT CURSOR WHERE IT BELONGS
	RTS	PC


;COMMON ERROR ROUTINE

RCHERR:	MOV	#1,REXPT	;RESET THE EXPT
	JSR	PC,BELL		;BLEEP TO TELL HIM
	RTS	PC
;ROUTINE TO GO TO BEGINNING OF A LINE

RCHA:	CMP	REXPT,#1	;DID HE TYPE ANY ^U'S
	BNE	RCHE1		;YES, WELL THEN DO THE OPPOSITE, NAMELY ^E
RCHA1:	MOV	CPTR,R0		;GET OUR INITIAL POSITION
	CLR	R1		;THIS MEANS BEGINNING LIKE FOR L COMMAND
	JSR	PC,LINE		;GO TO BEGINNING OF LINE
	BR	RCHAEB		;JOIN COMMON ROUTINE TO UPDATE DISPLAY




;ROUTINE TO GO TO END OF A LINE

RCHE:	CMP	REXPT,#1	;DID HE TYPE ANY ^U'S
	BNE	RCHA1		;YES, DO THE OPPOSITE, NAMELY ^A
RCHE1:	MOV	CPTR,R0		;GET OUR INITIAL POSITION
	MOV	#1,R1		;GO FORWARD ONE LINE
	JSR	PC,LINE
	CMPB	-1(R0),#15	;IS THE CHAR JUST BEFORE CURSOR A NL?
	BNE	RCHAEB		;NO, MUST BE AT THE END OF WORLD
	DEC	R0		;OTHERWISE, BACK UP BEFORE NL
	BR	RCHAEB		;JOIN COMMON ROUTINE



;ROUTINE TO GO TO BEGINNING OF BUFFER

RCHB:	CMP	REXPT,#1	;DID HE TYPE ANY ^U'S
	BNE	1$		;YES, THEN HE WANT TO GO TO END OF BUFFER
	MOV	BOB,R0		;OTHERWISE, CURSOR GO TO START
	BR	RCHAEB		;JOIN COMMON ROUTINE TO UPDATE DISPLAY

1$:	MOV	EOA,R0		;SET CURSOR TO END OF WORLD


RCHAEB:	MOV	#1,REXPT	;RESET REXPT TO ITS DEFAULT VALUE
	MOV	R0,CPTR		;PEOPLE SHOULD LEAVE NEW CURSOR LOC IN R0
	JSR	PC,UPDATE	;FIX UP THE SCREEN
	RTS	PC

;ROUTINE TO INSERT A NL AND BACK OVER IT

RCHO:	MOV	REXPT,R1	;MAKE SURE THERE IS SOMETHING TO DO
	BEQ	2$		;NO

1$:	PUSH	<CPTR>		;SAVE CURSOR
	MOV #15,R0
	JSR PC,INSERT
	POP	<CPTR>		;GO BACK TO OUR CURRENT POSITION
	SOB	R1,1$

2$:	MOV	#1,REXPT	;RESET REXPT
	MOV	CPTR,R0		;ARG TO TYPSCN
	JSR	PC,TYPSCN	;TYPE FROM R0 TO END OF SCREEN
	JSR	PC,UPDATE	;PUT THE CURSOR BACK TO RIGHT SPOT
	RTS	PC



;ROUTINE TO PAGE SOME NUMBER OF TIMES

RCHV:	DEC	REXPT		;ANYTHING LEFT TO DO
	BLT	1$		;NOPE
	JSR	PC,PAGE		;WRITE OUT ONE PAGE
	BR	RCHV		;DO IT AGAIN

1$:	MOV	#1,REXPT	;RESET REXPT
	JSR	PC,RCHL		;RESET THE WINDOW AND RETYPE THE SCREEN
	RTS	PC
;TABLE ^R MODE FUNCTIONS

;THE RCM NAMES ARE THE VALUES STORED IN RCMAC
;THE RCH NAMES ARE THE ACTUAL ROUTINES

.MACRO	DEFR	NAME
	RCM'NAME = - <RDSIZ/2>
	.WORD	RCH'NAME
	RDSIZ	= RDSIZ + 2
.ENDM

RDSIZ	= 0


;.CSECT	STACK

RDTAB:	DEFR	UDF		;UNDEFINED, JUST BLEEP
	DEFR	NRM		;INSERT NORMAL CHARS
	DEFR	D		;DELETE CHARS
	DEFR	ESC		;ESCAPE FROM ^R MODE
	DEFR	L		;SELECT A NEW WINDOW
	DEFR	M		;INSERT A <CR><LF> IN ITS MODE
	DEFR	K		;KILL TO END OF LINE
	DEFR	RUB		;RUB OUT A CHAR
	DEFR	N		;GO FORWARD EXPT LINES
	DEFR	P		;GO BACK EXPT LINES
	DEFR	F		;GO FORWARD EXPT CHARS
	DEFR	H		;GO BACK EXPT CHARS
	DEFR	U		;MULTIPLY REXPT BY 4
	DEFR	Q		;INSERT ANY CHAR, QUOTED INSERT
	DEFR	ALT		;ALT MODE STUFF, TO HANDLE SPECIAL KEYS
	DEFR	A		;GO TO BEGINNING OF LINE
	DEFR	B		;GO TO BEGINNING OR END OF BUFFER
	DEFR	E		;GO TO END OF LINE
	DEFR	O		;INSERT NL AND BACK OVER IT
	DEFR	V		;PAGE
	DEFR	QST		;DISPATCH OFF OF "B" DISPATCH TABLE;CONTROL R MODE CHAR DISPATCH TABLE
;TO FIND THE FUNCTION SPECIFIED BY RCM'NAME, LOOK FOR A ROUTINE LABLED RCH'NAME

RCMAC:	.WORD	RCMUDF	;^@
	.WORD	RCMA	;^A
	.WORD	RCMB	;^B
	.WORD	RCMUDF	;^C
	.WORD	RCMD	;^D
	.WORD	RCME	;^E
	.WORD	RCMF	;^F
	.WORD	RCMUDF	;^G
	.WORD	RCMH	;^H
	.WORD	RCMNRM	;^I
	.WORD	RCMUDF	;^J
	.WORD	RCMK	;^K
	.WORD	RCML	;^L
	.WORD	RCMM	;^M
	.WORD	RCMN	;^N
	.WORD	RCMO	;^O
	.WORD	RCMP	;^P
	.WORD	RCMQ	;^Q
	.WORD	RCMUDF	;^R
	.WORD	RCMUDF	;^S
	.WORD	RCMUDF	;^T
	.WORD	RCMU	;^U
	.WORD	RCMV	;^V
	.WORD	RCMUDF	;^W
	.WORD	RCMUDF	;^X
	.WORD	RCMUDF	;^Y
	.WORD	RCMUDF	;^Z
	.WORD	RCMALT	;ESC
	.WORD	RCMUDF	;^\
	.WORD	RCMUDF	;^]
	.WORD	RCMUDF	;^^
	.WORD	RCMUDF	;^_

	.REPT	95.
	.WORD	RCMNRM	;NON-CONTROL NON-RUBOUT CHARS
	.ENDR

	.WORD	RCMRUB	;RUBOUT

;"A" DISPATCH TABLE.  NORMALLY USED TO DISPATCH ON THE CHAR FOLLOWING
;AN ALTMODE.

RAMAC:	.REPT	77	;^@ UP TO >
	.WORD 	RCMUDF	;NOTHING DEFINED FOR THESE
	.ENDR

	.WORD	RCMQST	;USED FOR FURTHER DISPATCHING ON ALT KEYPAD ($?)
	.WORD	RCMUDF	;UNDEFINED ($@)
	.WORD	RCMP	;UP ARROW KEY ($A)
	.WORD	RCMN	;DOWN ARROW KEY ($B)
	.WORD	RCMF	;LEFT ARROW KEY ($C)
	.WORD	RCMH	;RIGHT ARROW KEY ($D)

	.REPT	13	;E THROUGH O
	.WORD	RCMUDF	;NOTHING DEFINED
	.ENDR

	.WORD	RCMU	;BLUE KEY ($P)
	.WORD	RCMD	;RED KEY ($Q)
	.WORD	RCMK	;BLACK KEY ($R)

	.REPT	65	;REST OF CHARS
	.WORD	RCMUDF	;NOTHING DEFINED
	.ENDR




;"B" DISPATCH TABLE.  FOR NOW, COMPLETELY UNDEFINED. WILL BE USED FOR
;FURTHER DISPATCHING ON THE ALTERNATE KEYPAD MODE CHARS IE $?X.

RBMAC:	.REPT	200	;ALL CHARS ^@ THROUGH DEL
	.WORD	RCMUDF	;NOTHING DEFINED
	.ENDR


;	.CSECT	STACK
ERRST:
EE$CNX=0
.MACRO ERRCAL X
	E$'X
.ENDM

	.REPT	EE$CNT
EE$CNX=EE$CNX+1
	ERRCAL \EE$CNX
	.ENDR
.EVEN
ENDER:


	;TECO SUBROUTINES - DELPHI

;.INSR1 /LIB/MACRO/UNIX
;.INSR1 /LIB/MACRO/T.XX


;MACRO TO SIMULATE READCH FOR NOW

;.MACRO	READCH
;	PUSH	<R0>
;	JSR	PC,TTFLSH
;	CLR	R0
;	;SYS	S_READ,IOTMP,1
;	POP	<R0>
;	MOVB	IOTMP,-(SP)
;.ENDM
.IF NZ SITS
.MACRO READCH
	JSR PC,.REDCH
.ENDM
.ENDC

;	.CSECT	STACK

;DEFINE STORAGE FOR THE TTY OUTPUT BUFFER

TTOBUF:
TTFLDS:	.WORD	1		;FILE DESCRIPTOR FOR TTY OUTPUT FILE
TTLEFT:	.WORD	512.		;REMAINING SLOTS IN BUFFER
TTNEXT:	.WORD	TTOBFF		;POINTER TO NEXT FREE SLOT
TTOBFF:	.BLKB	512.		;BUFFER FOR ACTUAL OUTPUT



;TABLE OF SPECIAL ROUTINES FOR PROCESSING CONTROL CHARS

	.EVEN
CTRTBL:	.WORD	NTYI		;^@
	.WORD	NTYI		;^A
	.WORD	NTYI		;^B
	.WORD	NTYI		;^C
	.WORD	NTYI		;^D
	.WORD	NTYI		;^E
	.WORD	NTYI		;^F
	.WORD	NTYI		;^G
	.WORD	NTYI		;^H
	.WORD	NTYI		;^I
	.WORD	CTRJ		;^J
	.WORD	NTYI		;^K
	.WORD	NTYI		;^L
	.WORD	CTRM		;^M
	.WORD	NTYI		;^N
	.WORD	NTYI		;^O
	.WORD	NTYI		;^P
	.WORD	NTYI		;^Q
	.WORD	NTYI		;^R
	.WORD	NTYI		;^S
	.WORD	NTYI		;^T
	.WORD	CTRU		;^U
	.WORD	NTYI		;^V
	.WORD	NTYI		;^W
	.WORD	NTYI		;^X
	.WORD	NTYI		;^Y
	.WORD	NTYI		;^Z
	.WORD	CTRALT		;^[ (ALTMODE)
	.WORD	NTYI		;^\
	.WORD	NTYI		;^]
	.WORD	NTYI		;^^
	.WORD	NTYI		;^_
;TTYMOD COMMAND USED TO READ THE TTY INITIAL STATUS

GETCMD:
GFL:	.BYTE	0	;LOW BYTE OF TTFLAG
	.BYTE	4.
GFH:	.BYTE	0	;HIGH BYTE
	.BYTE	5.
GF2L:	.BYTE	0	;LOW BYTE OF TTFLG2
	.BYTE	6.
GF2H:	.BYTE	0	;HIGH BYTE
	.BYTE	7.
GF3L:	.BYTE	0	;LOW BYTE OF TTFLG3
	.BYTE	8.
GF3H:	.BYTE	0	;HIGH BYTE
	.BYTE	9.
GLL:	.BYTE	0	;LINE LENGTH
	.BYTE	12.
GPS:	.BYTE	0	;PAGE SIZE
	.BYTE	13.
	.WORD	-1


;TTYMOD COMMAND USED TO REPLACE THE TTY DATA

SETCMD:	
SFL:	.BYTE	0
	.BYTE	300!4	;REPLACE TTFLAG LOW BYTE
SFH:	.BYTE	0
	.BYTE	300!5	;REPLACE TTFLAG HIGH BYTE
SF2L:	.BYTE	0
	.BYTE	300!6	;REPLACE TTFLG2 LOW BYTE
SF2H:	.BYTE	0
	.BYTE	300!7	;REPLACE TTFLG2 HIGH BYTE
SF3L:	.BYTE	0
	.BYTE	300!8.	;REPLACE TTFLG3 LOW BYTE
SF3H:	.BYTE	0
	.BYTE	300!9.	;REPLACE TTFLG3 HIGH BYTE
	.WORD	-1



;	.CSECT	PGM

;ROUTINE TO INITIALIZE THE TTY

;INTTY:	CLR	R0		;USE FILE 0
;	;SYS	S_TTYMOD,GETCMD	;PUT TTY DATA INTO TTYSTA
;	JSR	PC,COPOLD	;COPY THE OLD DATA
;	BIC	#T.ECHO,TTFLAG	;TURN OF ECHO
;	BIS	#T.RAW,TTFLAG	;TURN ON RAW MODE
;	BIS	#T.EEI,TTFLG2	;TURN ON EEI MODE (ENABLE ^B AND ^Q INTERRUPTS)
;	JSR	PC,COPNEW	;COPY THE NEW DATA TO THE COMMAND
;	CLR	R0		;AGAIN USE FILE 0
;	;SYS	S_TTYMOD,SETCMD	;NOW PUT IN THE DATA THE TECO WANTS
;	RTS	PC
.IF NZ SITS
INTTY:	MOV	#.TIMGI!.TIMGO!.TICTM,GETCMD
				;SET STATUS TO IMAGE IN, IMAGE OUT, NO ECHO
	JSR	PC,COPOLD	;COPY THE DEFAULT
	JSR	PC,COPNEW	;AND SAVE IT
	JSR	PC,SSTAT	;SET THE STATUS TO 
	RTS PC

SSTAT:	TST	-(SP)
	MOV	SETCMD,-(SP)
	MOV	#2,-(SP)
	MOVB	#.TTMOV,1(SP)
	$INVOK
	RTS	PC
.ENDC
;ROUTINE TO RESTORE THE INITIAL TTY STATUS

CLRTTY:	JSR	PC,COPOLD	;PUT THE OLD TTY DATA BACK
	JSR	PC,COPNEW	;PUT IT IN THE COMMAND TO SET
;	CLR	R0
.IF NZ SITS
	JSR	PC,SSTAT
.ENDC
;	SYS	S_TTYMOD,SETCMD	;SET IN IN
	RTS	PC

;ROUTINE TO COPY THE DATA FROM TTSTATUS TO COMMAND TO SET TTY STATUS

;COPNEW:	MOVB	TTFLAG,SFL	;TTFLAG LOW BYTE
;	MOVB	TTFLAG+1,SFH	;TTFLAG HIGH BYTE
;	MOVB	TTFLG2,SF2L	;TTFLG2 LOW BYTE
;	MOVB	TTFLG2+1,SF2H	;TTFLG2 HIGH BYTE
;	MOVB	TTFLG3,SF3L	;TTFLG3 LOW BYTE
;	MOVB	TTFLG3+1,SF3H	;TTFLG3 HIGH BYTE
;	RTS	PC

.IF NZ SITS
COPNEW:	MOV TTFLAG,SFL
	RTS PC

COPOLD:	MOV GFL,TTFLAG
	RTS PC
.ENDC
;ROUTINE TO COPY DATA FROM GET TTY STATUS COMMAND TO SAVE LOCATIONS

;COPOLD:	MOVB	GFL,TTFLAG	;COPY THE DATA WE READ IN USEFUL PLACES
;	MOVB	GFH,TTFLAG+1
;	MOVB	GF2L,TTFLG2
;	MOVB	GF2H,TTFLG2+1
;	MOVB	GF3L,TTFLG3
;	MOVB	GF3H,TTFLG3+1
;	MOVB	GLL,LLEN
;	MOVB	GPS,PAGSIZ	
;	RTS	PC

RSTTY:	RTS	PC

;ROUTINE TO GO INTO ^R MODE

RSET:
;	BIC	#T.EEI,TTFLG2	;GO OUT OF EEI MODE
	JSR	PC,COPNEW	;COPY THE TTFLAG WORDS TO COMMAND
	CLR	R0
;	SYS	S_TTYMOD,SETCMD	;EXECUTE THE SET COMMAND
.IF NZ SITS
	JSR	PC,SSTAT
.ENDC
	MOVB	#1,ECHOSW	;DISABLE ECHOING
	MOVB	#1,GRAPHM	;ENABLE GRAPHICS MODE
	RTS	PC


;ROUTINE TO GO OUT OF ^R MODE

RCLR:
.IIF NZ DATAP,	JSR	PC,RECCUR
	MOV	PAGSIZ,VPOS	;NOW SET CURSOR TO BOTTOM OF SCREEN
	DEC	VPOS		;WE WANT LAST LINE
	CLR	HPOS		;FIRST COLUMN
	JSR	PC,SETCUR	;PUT THE CURSOR HERE
	JSR	PC,CRLF		;KILL THE LINE
.IIF NZ DATAP,	JSR	PC,RECCUR
	INC	VPOS		;MOVE BACK TO PREVIOUS LINE
	INC	VPOS		;MOV BACK ANOTHER LINE SO WE DON'T SCROLL
	JSR	PC,SETCUR	;PUT THE CURSOR HERE
;	BIS	#T.EEI,TTFLG2	;GO BACK INTO EEI MODE
	JSR	PC,COPNEW	;COPY THE TTFLAG WORDS TO SET COMMAND
	CLR	R0
;	SYS	S_TTYMOD,SETCMD	;EXECUTE THE SET COMMAND
.IF NZ SITS
	JSR	PC,SSTAT
.ENDC
	CLRB	ECHOSW		;RE-ENABLE ECHOING
	CLRB	GRAPHM		;GO OUT OF GRAPHICS MODE
	RTS	PC

;ROUTINE TO READ A CHAR FROM THE TTY

TYI:	READCH
	MOV	(SP)+,R0
	BIC	#177600,R0
	CMP	R0,#40			;IS IT A CONTROL CHAR?
	BHIS	NTYI			;NO
	ASL	R0			;CONVERT TO WORD OFFSET
	MOV	CTRTBL(R0),-(SP)	;GET THE SPECIAL ROUTINE TO EXECUTE
	ASR	R0			;RETURN R0 TO NORMAL
	JMP	@(SP)+			;NOW EXECUTE SPECIAL ROUTINE AND RETURN

NTYI:	CMP	R0,#177			;IS IT RUBOUT?
	BEQ	2$			;YES, DO NOTHING
	TSTB	UCSW			;SHOULD WE UPPER CHASE THE CHAR?
	BEQ	1$			;NOPE
	JSR	PC,GETUC		;CHANGE IT TO UPPER CASE

1$:	JSR	PC,CHKRB		;CHECK IF WE SHOULD PRINT \
	TSTB	ECHOSW			;SHOULD WE ECHO THE CHAR?
	BNE	2$			;NO
	JSR	PC,TYO			;ECHO IT

2$:	RTS	PC			;RETURN CHAR IN R0

;ROUTINE TO PROCESS LF'S

CTRJ:	TSTB	CRLFSW			;SHOULD WE SWITCH LF'S AND CR'S
	BEQ	2$			;NO, DO NORMAL ECHO
	TSTB	RMODE			;ARE WE IN ^R MODE?
	BNE	1$			;IGNORE AMSW IN ^R MODE
	TSTB	AMSW			;SHOULD WE FURTHER SWITCH TO ALT
	BEQ	1$			;NO, RETURN A CR
	MOV	#33,R0			;ELSE RETURN AN ALTMODE
	BR	2$

1$:	MOV	#15,R0			;SWITCH TO CR

2$:	JSR	PC,NTYI			;CHECK FOR RUBOUT AND ECHO
	RTS	PC


;ROUTINE TO PROCESS CR'S

CTRM:	TSTB	CRLFSW			;SHOULD WE SWITCH LF'S AND CR'S
	BEQ	1$			;NO
	MOV	#12,R0			;CONVERT TO A LF
	BR	2$

1$:	TSTB	RMODE			;ARE WE IN ^R MODE?
	BNE	2$			;YES, IGNORE AMSW IN ^R MODE
	TSTB	AMSW			;SHOULD WE SWITCH LF'S AND ALTS
	BEQ	2$			;NO, LEAVE IT ALONE
	MOV	#33,R0			;ELSE CONVERT TO ALTMODE

2$:	JSR	PC,NTYI			;CHECK FOR RUBOUT AND ECHO
	RTS	PC



;ROUTINE TO PROCESS ALTMODES

CTRALT:	TSTB	RMODE			;ARE WE IN ^R MODE?
	BNE	1$			;YES IGNORE AMSW
	TSTB	AMSW			;SHOULD WE SWITTCH LF'S AND ALT'S
	BEQ	1$			;NO
	MOV	#15,R0			;ELSE CONVERT TO CR

1$:	JSR	PC,NTYI			;CHECK FOR RUBOUT AND ECHO
	RTS	PC



;ROUTINE TO PROCESS ^U'S

CTRU:	JSR	PC,CHKRB		;FIX ANY RUBOUT STUFF
	RTS	PC

;OUTPUT A CHAR IN R0

TYO:	JSR	PC,CTYO		;PROCESS CHAR AND PUT IN BUFFER
	JSR	PC,TTFLSH			;MAKE SURE THE BUFFER IS EMPTY
	RTS	PC


;PUT CHAR IN R0 INTO THE TTY OUTPUT BUFFER

CTYO:	CMP	R0,#40		;IS IT A CONTROL CHAR
	BLO	1$		;YES, SPECIAL TREATMENT
	JSR	PC,NTYO		;TYPE AS NORMAL CHAR
	RTS	PC

1$:	CMP	R0,#33		;ALTMODE?
	BNE	2$		;NO
	MOV	R0,-(SP)	;SAVE THE CHAR
	MOV	#'$,R0		;CHANGE ALTMODES TO DOLLAR SIGNS
	JSR	PC,NTYO		;TYPE NORMALLY
	MOV	(SP)+,R0	;RESTORE THE ALTMODE
	RTS	PC

2$:	CMP	R0,#14		;FORMF?
	BNE	4$		;NOPE
	TST	RMODE		;ARE WE IN ^R MODE?
	BNE	9$		;YES, TYPE AS ^L
	TSTB	FFSW		;SHOULD WE TYPE FORMFEEDS?
	BEQ	9$		;YES, TYPE AS ^L
	BR 15$

4$:	CMP	R0,#15		;NL?
	BNE	6$		;NO
	TSTB	GRAPHM		;DO SPECIAL GRAPHICS HACK?
	BNE	5$		;YES
	PUSH	R0		;SAVE THE CR
	MOV	#12,R0		;PUT A LF INTO THE BUFFER
	JSR	PC,TTPUTC
13$:	POP	R0		;RESTORE THE CR AND PUT IT IN THE BUFFER
	BR 15$

5$:	JSR	PC,GRCRLF	;SPECIAL GRAPHIC CRLF
	RTS	PC

6$:	CMP	R0,#11		;TAB?
	BNE	9$		;NO
	TSTB	GRAPHM		;DO SPECIAL GRAPHICS HACK?
	BNE	7$		;YES
15$:	JSR	PC,TTPUTC			;PUT THE CHAR INTO THE BUFFER
	RTS	PC

7$:	PUSH	<R0,R1>		;NEED SOME REGISTERS
	MOV	HPOS,R1		;OUR CURRENT HORIZONTAL POSTION
	ADD	#8.,R1
	BIC	#7,R1		;SET R1 TO NEXT TAB STOP
	SUB	HPOS,R1		;THIS IS HOW MANY SPACES WE MUST TYPE
	MOV	#40,R0		;A SPACE
8$:	JSR	PC,NTYO		;TYPE IT
	SOB	R1,8$		;TYPE THE APPROPRIATE NUMBER OF SPACES
	POP	<R1,R0>		;CLEAN UP
	RTS	PC


9$:	MOV	R0,-(SP)	;SAVE THE ORGINAL CHAR
	MOV	#'^,R0
	JSR	PC,NTYO		;TYPE AN ^
	MOV	(SP),R0		;NOW GET THE ORIGINAL CHAR
	ADD	#100,R0		;CONVERT FROM CONTROL TO NORMAL
	JSR	PC,NTYO		;NOW TYPE AS NORMAL CHAR
	MOV	(SP)+,R0	;RESTORE THE ORIGINAL CHAR
	RTS	PC



;ROUTINE TO TYPE NORMAL CHARS AND HACK OVERFLOWS

NTYO:	TSTB	GRAPHM		;SPECIAL GRAPHIC STUFF
	BNE	1$		;YUP
	JSR	PC,TTPUTC			;PUT CHAR IN BUFFER
	RTS	PC

1$:	CMP	VPOS,PAGSIZ	;ARE WE PAST THE END OF SCREEN?
	BHIS	2$		;YUP, IGNORE ANYTHING
	MOV	LLEN,-(SP)	;GET THE LLEN OF SCREEN
	DEC	(SP)		;GET NUMBER OF LAST COLUMN
	CMP	HPOS,(SP)+	;ARE WE THERE?
	BEQ	3$		;YES, DO AN OVERFLOW
	JSR	PC,TTPUTC			;PUT CHAR IN BUFFER
	INC	HPOS		;ADVANCE TO NEXT CHAR POSITION
2$:	RTS	PC

3$:	PUSH	R0		;SAVE THE CHAR
	MOV	#'\,R0		;BACKSLASH MARKS THE OVERFLOW
	JSR	PC,TTPUTC			;PUT IT IN THE BUFFER
	POP	R0		;RESTORE THE CHAR
	JSR	PC,GRCRLF	;TYPE A NEWLINE
	JSR	PC,NTYO		;NOW TYPE THE CHAR NORMALLY
	RTS	PC


;	.CSECT STACK		;D SPACE STORAGE FOR INDIRECT EXECUTION
;TTWRIT:	;SYS	S_WRITE,TTOBFF	;TRAP AND POINTER FOR TTY OUTPUT WRITE
TTWCNT:	.WORD	0		;COUNT OF CHARS TO WRITE
;	.CSECT PGM



;ROUTINE TO DO BUFFERED OUTPUT ON THE TTY OUTPUT BUFFER

TTPUTC:	TST	TTLEFT		;ANY SPACE LEFT?
	BGT	1$		;THERE ARE SOME SLOTS LEFT
	JSR	PC,TTFLSH	;OTHERWISE FLUSH THE OUTPUT

1$:	MOVB	R0,@TTNEXT	;PUT IN THE CHAR
	INC	TTNEXT		;ADVANCE POINTER
	DEC	TTLEFT		;ONE LESS SPACE LEFT
	RTS	PC



;ROUTINE TO WRITE OUT THE BUFFER, AND RESET COUNT AND POINTER

TTFLSH:	PUSH	R0		;NEED A REGISTER
	MOV	TTFLDS,R0	;FILE DESCRIPTOR FOR THE TTY
	MOV	#512.,TTWCNT	;THE COUNT FOR THE WRITE
	SUB	TTLEFT,TTWCNT	;SUBTRACT NUMBER OF SPACES LEFT
	BEQ	1$		;IN CASE THERE WERE NONE LEFT
.IF NZ SITS
	NEG	TTWCNT
	MOV	#TTOBFF,-(SP)
	MOV	TTWCNT,-(SP)
	MOV	#2,-(SP)
	$BLKO
.ENDC
	;SYS	S_INDIR,TTWRIT	;DO THE WRITE

1$:	MOV	#TTOBFF,TTNEXT	;RESET THE NEXT POINTER
	MOV	#512.,TTLEFT	;RESET THE SLOTS LEFT COUNT
	POP	R0		;CLEAN UP
	RTS	PC

GRLF:	PUSH R0
	CMP VPOS,PAGSIZ
	BHIS 2$
	MOV #12,R0
	JSR PC,TTPUTC		;ACTUALLY MOVE DOWN ONE LINE
	INC VPOS
2$:	POP R0
	RTS PC

GRCR:	PUSH R0
	MOV #36,R0
	JSR PC,TTPUTC
	MOV #15,R0
	JSR PC,TTPUTC
	CLR HPOS
	POP R0
	RTS PC
	
;ROUTINE TO DO A SPECIAL GRAPHICS CRLF

GRCRLF:	PUSH	R0		;NEED A REGISTER
	CMP	VPOS,PAGSIZ	;HAVE WE OVERFLOWED SCREEN?
	BHIS	2$		;YUP, DON'T BOTHER TO TYPE ANYTHING
	MOV	LLEN,-(SP)	;PUSH THE SCREEN WIDTH
	DEC	(SP)		;FIND NUMBER OF LAST COLUMN
	CMP	HPOS,(SP)+	;ARE WE IN LAST COLUMN?
	BEQ	1$		;YES, DON'T BOTHER TO KILL
;	MOV	#33,R0	;KILL TO THE END OF THIS LINE
	MOV	#36,R0		;KILL TO END OF LINE
	JSR	PC,TTPUTC
;	MOV	#'K,R0
;	JSR	PC,TTPUTC
1$:	MOV	#15,R0	;NOW TYPE A CARRIAGE RETURN
	JSR	PC,TTPUTC
;	MOV	#33,R0	;FINALLY MOVE CURSOR DOWN ONE LINE
	MOV	#12,R0	
	JSR	PC,TTPUTC
;	MOV	#'B,R0	;WE USE THIS CAUSE WE DONT WANT SCROLL
;	JSR	PC,TTPUTC

2$:	CLR	HPOS		;GO TO COLUMN 0
	INC	VPOS		;ADVANCE TO NEXT LINE
	POP	R0		;CLEAN UP
	RTS	PC


;ROUTINE TO SET THE CURSOR TO THE LOCATION SPECIFIED BY HPOS AND VPOS

;SETCUR:	PUSH	R0		;NEED A REGISTER
;	MOV	#33,R0		;TYPE ESCAPE CHAR
;	JSR	PC,TTPUTC
;	MOV	#'Y,R0		;TYPE Y
;	JSR	PC,TTPUTC
;	MOV	VPOS,R0		;THE LINE ADDRESS
;	ADD	#40,R0		;THATS HOW THE VT52 LIKES IT
;	JSR	PC,TTPUTC
;	MOV	HPOS,R0		;THE COLUMN ADDRESS
;	ADD	#40,R0
;	JSR	PC,TTPUTC
;	JSR	PC,TTFLSH			;MAKE SURE THE BUFFER IS EMPTY
;	POP	R0		;CLEAN UP
;	RTS	PC

.IF NZ SITS
.IF Z DATAP
SETCUR:	MOV	HPOS,-(SP)
	MOV	VPOS,-(SP)
	MOV	#2,-(SP)
	MOVB	#.TVSET+.PRWRT,1(SP)
	$INVOK
	RTS	PC
.IFF
RECCUR:	MOV	HPOS,OHPOS
	MOV	VPOS,OVPOS
	RTS	PC

SETCUR:	PUSH	<R0,R1>
	MOV	#13,R0		;GO DOWN
	MOV	VPOS,R1
	SUB	OVPOS,R1
	BEQ	SETHOR		;NO CHANGE IN VERTICAL
	BGT	SETCUP		;SET CURSOR DOWN (OVPOS < VPOS)
	MOV	#32,R0		;GO UP
	NEG	R1
SETCUP:	JSR	PC,TTPUTC
	SOB	R1,SETCUP
SETHOR:	MOV	#30,R0		;GO BACKWARDS
	MOV	HPOS,R1
	SUB	OHPOS,R1
	BEQ	SETDON		;DONE
	BGT	SETFWD		;SET IT FORWARD (HPOS > OHPOS)
	MOV	#31,R0
	NEG	R1
SETFWD:	JSR	PC,TTPUTC
	SOB	R1,SETFWD
SETDON:	JSR	PC,TTFLSH
	POP	<R1,R0>
	RTS	PC
.ENDC
.ENDC

;ROUTINE TO KILL FROM HERE TO END OF LINE

KILLLN:	PUSH	R0
;	MOV	#33,R0	;ESCAPE CHAR TO VT52
	MOV	#36,R0	;KILL  TO END OF LINE
	JSR	PC,TTPUTC			;SEND IT
;	MOV	#'K,R0	;KILL TO END OF LINE CHAR
;	JSR	PC,TTPUTC			;SEND IT
	JSR	PC,TTFLSH			;EMPTY THE BUFFER
	POP	R0
	RTS	PC



;ROUTINE TO KILL FROM HERE TO END OF SCREEN

;KILLSC:	PUSH	R0
;	MOV	#33,R0	;ESCAPE CHAR TO VT52
;	JSR	PC,TTPUTC			;SEND IT
;	MOV	#'J,R0	;KILL TO END OF SCREEN CHAR
;	JSR	PC,TTPUTC			;SEND IT
;	JSR	PC,TTFLSH			;EMPTY THE BUFFER
;	POP	R0
;	RTS	PC

.IF NZ SITS
.IF Z DATAP
KILLSC:	PUSH	<R0,R1>
	CMP	-(SP),-(SP)
	MOV	#<.TVSET*400>+2,-(SP)	;READ CURSOR POSITION
	$INVOK
	MOV	PAGSIZ,R1
	SUB	VPOS,R1
	BLT	1$
2$:	MOV	#36,R0
	JSR	PC,TTPUTC		;CEOL
	TST	R1			;LAST LINE?
	BEQ	3$			;YES
	MOV	#12,R0			;SPACE DOWN
	JSR	PC,TTPUTC
	DEC	R1
	BR	2$
3$:	JSR	PC,TTFLSH
	MOV	#<<.TVSET+.PRWRT>*400>+2,-(SP)
	$INVOK
1$:	POP	<R1,R0>
	RTS PC
.IFF
KILLSC:	PUSH	R0
	MOV	#37,R0
	JSR	PC,TTPUTC
	JSR	PC,TTFLSH
	POP	R0
	RTS	PC
.ENDC
;ROUTINE TO RING THE TERMINAL'S BELL

BELL:	PUSH	R0
	MOV	#7,R0	;CONTROL G
	JSR	PC,TTPUTC		;SEND IT
	JSR	PC,TTFLSH		;EMPTY THE BUFFER
	POP	R0
	RTS	PC
;ROUTINE TO COUNT SCREEN POSITION OFFSETS FROM ACTUAL CHARS IN
;THE BUFFER. EXPECTS STARTING CHAR POINTER IN R0, STARTING SCREEN
;LINE IN R1, STARTING SCREEN COLUMN IN R2 AND COUNT OF CHARS IN R5.
;RETURNS FINALLY LINE IN R1 AND FINAL COLUMN IN R2.

COUNT:	TST	R5		;ANY CHARS TO COUNT?
	BEQ	10$		;NO, JUST RETURN
	MOV	LLEN,-(SP)
	DEC	(SP)		;FIND NUMBER OF LAST COLUMN

1$:	CMPB	(R0)+,#40	;IS IT A CONTROL CHAR?
	BHIS	7$		;NO, NORMAL CHAR
	CMPB	-1(R0),#33	;IS IT ESCAPE?
	BEQ	7$		;PRINTS AS "$"
	CMPB	-1(R0),#11	;TAB?
	BNE	4$		;NO
	MOV	R2,-(SP)
	ADD	#8.,(SP)
	BIC	#7,(SP)
	SUB	R2,(SP)		;FIND COUNT TO NEXT TAB STOP

2$:	CMP	R2,2(SP)	;ARE WE IN LAST COLUMN
	BLO	3$		;NO
	INC	R1		;ELSE DO CRLF
	CLR	R2

3$:	INC	R2
	DEC	(SP)		;ONE LESS SPACE IN THE TAB
	BGT	2$		;SOME MORE LEFT, KEEP COUNTING
	TST	(SP)+		;POP THE COUNT
	BR	9$		;THAT'S ALL FOR THIS TAB

4$:	CMPB	-1(R0),#15	;NL?
	BNE	5$		;NOPE
	INC	R1		;GO DOWN ONE LINE
	CLR	R2		;BACK TO COLUMN 0
	BR	9$		;THAT'S ALL FOR THIS NL

5$:	CMP	R2,(SP)		;ASSUME NORMAL CTRL CHAR, SKIP TWO SPACES
	BLO	6$		;NO, WE'RE NOT IN LAST COLUMN
	INC	R1		;ELSE GO DOWN ONE LINE
	CLR	R2		;AND BACK TO COLUMN 0

6$:	INC	R2		;ONE SPACE

7$:	CMP	R2,(SP)		;ARE WE IN LAST COLUMN
	BLO	8$		;NO, NOT IN LAST COLUMN
	INC	R1		;ELSE GO DOWN ONE LINE
	CLR	R2		;AND BACK TO COLUMN 0

8$:	INC	R2		;ONE SPACE

9$:	SOB	R5,1$		;THAT'S ALL FOR THAT CHAR
	TST	(SP)+		;POP THE LAST COLUMN NUMBER

10$:	RTS	PC

GETUC:	CMPB	R0,#140
	BLOS	1$
	CMPB	R0,#'Z+40
	BHI	1$
	SUB	#40,R0
1$:	RTS	PC



CHKRB:	TSTB	RBOUT
	BEQ	1$
	PUSH	R0
	MOV	#'\,R0
	JSR	PC,TTPUTC
	POP	R0
	CLRB	RBOUT
1$:	RTS	R7

TYO.R:	JSR	R7,CHKRB
	JSR	R7,TYO
	RTS	R7



;OUTPUT A NEW LINE

CRLF:	PUSH	<R0>		;NEED A REGISTER
	MOV #15,R0
	JSR PC,TYO
	MOV	#12,R0		;NEWLINE
	JSR	PC,TYO		;TYPE IT
	POP	<R0>		;CLEAN UP
	RTS	PC



;OUTPUT A STRING BETWEEN R1 AND R2

TYPER:	CMP	R1,R2
	BHIS	1$
	JSR	PC,CHECKC
	MOVB	(R1)+,R0
	JSR	PC,CTYO		;PUT A CHAR IN THE BUFFER
	BR	TYPER
1$:	JSR	PC,TTFLSH			;EMPTY THE BUFFER
	RTS	PC
;DECIMAL CONVERT, EXPECTS R1 POINTING TO STRING AND R2 POINTING TO MAX LENGTH

DECIN:	MOV	R3,-(SP)	;SAVE IT
	CLR	R3		;AND CLEAR
1$:	CMP	R1,R2		;ARE WE PAST BOUNDRY
	BHI	2$		;YES, GIVE UP
	MOVB	(R1)+,R0		;NEXT CHAR
	CMP	R0,#'0		;DIGIT?
	BLO	2$		;NO
	CMP	R0,#'9
	BHI	2$
	MUL	#10.,R3
	SUB	#'0,R0
	ADD	R0,R3
	BR	1$

2$:	MOV	R3,R0
	MOV	(SP)+,R3
	DEC	R1		;ADJUST
	RTS	PC



;DECIMAL OUTPUT, TYPES THE NUMBER IN R0

DECOUT:PUSH	<R0,R1>
	TST	R0		;NEGATIVE NUMBER?
	BGE	1$		;NOPE
	MOV	#'-,R0		;ELSE TYPE MINUS SIGN
	JSR	PC,TYO		;TYPE IT
	MOV	2(SP),R0	;RESTORE THE NUMBER
	NEG	R0		;CONVERT TO POSITIVE, AN TYPE AS POSITIVE

1$:	MOV	R0,R1		;DIVIDEND SHOULD BE 32 BIT NUMBER IN R0,R1
	CLR	R0		;ZERO HIGH ORDER BITS OF NUMBER
	DIV	#10.,R0		;PUT DIVIDEND IN R0, REMAINDER IN R1
	TST	R0		;ZERO REMAINDER?
	BEQ	2$		;YES, NOW UNWIND RECURSION
	JSR	PC,DECOUT	;ELSE TYPE HIGH ORDER DIGITS RECURSIVELY

2$:	MOV	R1,R0		;COPY REMAINDER
	ADD	#'0,R0		;CONVERT TO CHAR 0
	JSR	PC,TYO		;TYPE IT
	POP	<R1,R0>		;CLEAN UP
	RTS	PC

;ROUTINE TO TAKE A NUMBER IN R0 AND CONVERT TO A STRING REPRESENTATION
;WHICH IS SAVED ON THE STACK.  WHEN THIS ROUTINE RETURNS, THE FIRST
;THING ON THE STACK IS A COUNT OF CHARS IN THE NUMBER, THEN COME THE
;CHARS, WITH MOST SIGNIFICANT DIGIT ON TOP.

DECOUX:	MOV	R1,R2		;SAVE R1
	MOVB	#1,STATE+1	;THIS WILL BE THE COUNT
2$:	CMP	R0,#10.		;LESS THAN 10?
	BLO	1$		;YES, THE LAST DIGIT
	INCB	STATE+1		;ONE MORE CHAR PUSHED
	MOV	R0,R1		;GET READY FOR THE DIVIDE
	CLR	R0
	DIV	#10.,R0		;GET REMAINDER IN R1
	MOV	@SP,-(SP)	;MOVE RETURN ADDRESS DOWN
	ADD	#60,R1		;CONVERT TO ASCII DIGIT
	MOV	R1,2(SP)	;COPY THE DIGIT INTO STACK SPOT
	BR	2$		;DO ANOTHER CHAR

1$:	MOV	R2,R1		;RESTORE R1
	MOV	(SP)+,R2	;PUT THE RETURN ADDRESS IN R2
	ADD	#60,R0		;CONVERT LAST DIGIT TO ASCII DIGIT
	MOV	R0,-(SP)	;SAVE THE LAST DIGIT
	MOVB	STATE+1,-(SP)	;SAVE THE COUNT OF CHARS
	CLRB	STATE+1		;??
	JMP	@R2		;RTS SORT OF

;SET OF ROUTINES FOR DEALING WITH TECO MACRO FILES



;ROUTINE TO OPEN AN EMFILE, RETURNS FILE HANDLE IN R0

EMOPEN:	;SYS	S_OPEN,EMFIL,0	;OPEN FOR READ
.IFNZ SITS	
	MOV #EMFIL,R0
	JSR PC,OPENRF		;OPEN FOR READ, RETURN CAP IN R0
.ENDC
	RTS	PC



;ROUTINE TO READ IN A BLOCK, EXPECTS FILE HANDLE IN R0, RETURNS COUNT IN R0

EMREAD:	;SYS	S_READ,EMBUF,100.	;READ 100. BYTES INTO EMBUF
.IFNZ SITS
	PUSH <#EMBUF,#-100.,R0>
	MOV #100.,R0
	.BLKI
	BNE 1$
	TST (SP)+
	ADD (SP)+,R0
	TST (SP)+
.ENDC
1$:	RTS	PC		;RETURN ACTUAL NUMBER IN R0



;ROUTINE TO CLOSE ANY EMFILES OPEN, EXPECTS FILE HANDLE IN R0

EMCLOSE:;SYS	S_CLOSE		;CLOSE FILE SPECIFIED IN R0
.IIF NZ SITS,	JSR PC,DELCAP
	RTS	PC

.IFZ SITS			;NOT FOR SITS
;ROUTINES TO HACK INFERIOR PROCESSES

RUNIT:	PUSH	<R0,R1>		;NEED SOME REGISTERS

1$:	INCB	WAITLK		;FROM NOW ON, WE WILL BE WAITING FOR INFERIOR
	;SYS	S_FORK		;CREATE AN INFERIOR
	BR	NEW		;WHERE THE NEW PROCESS SHOULD BEGIN
	BCC	2$		;IF THERE WERE NO PROBLEMS
	CLRB	WAITLK		;RE-ENABLE QUITS FOR THE MOMENT
	MOV	#1,R0		;WE WANT TO SLEEP FOR 1 SEC
	;SYS	S_SLEEP		;GO AWAY FOR A WHILE
	BR	1$		;NOW TRY AGAIN

2$:	MOV	R0,KIDID	;ID OF OUR KID'S PROCESS

3$:	;SYS	S_WAIT		;THE FATHER WAITS FOR THE CHILD HERE
	BCS	4$		;NO INFERIORS LEFT
	CMP	R0,KIDID	;IS THIS THE KID WE WERE WAITING FOR?
	BNE	3$		;HMM, SON OF A BITCH

4$:	CLRB	WAITLK		;NO LONGER WAITING FOR INFERIOR
	JSR	PC,INTTY	;RESET THE TTY TO TECO MODE
	MOVB	R1,KIDSTA	;STATUS OF THE CHILD PROCESS
	SWAB	R1		;PUT ERROR CODE IN LOW BYTE OF R1
	MOVB	R1,KIDERR	;ERROR CODE OF CHILD PROCESS
	POP	<R1,R0>		;CLEAN UP
	TST	KIDSTA		;DID KID FINISH OK?
	BNE	5$		;NO, MUST HAVE HAD AN ERROR
	CCC			;SIGNAL NO ERRORS
	RTS	PC

5$:	SEC			;SIGNAL AN ERROR
	RTS	PC


;THE INFERIOR PROCESS STARTS HERE

NEW:	;SYS	S_SIGNAL,2,0	;QUIT ON COMMAND
	;SYS	S_SIGNAL,3,0	;BREAK ON COMMAND
	JSR	PC,CLRTTY	;GO BACK TO NORMAL TTY MODE
	;SYS	S_EXEC,KIDNAM,KIDCMD	;EXECUTE COMMAND, SHOULD NOT COME BACK
	MOV	#1,R0		;THE ERROR CODE TO RETURN
	;SYS	S_EXIT		;IN CASE THERE WAS AN ERROR WITH EXEC


;	.CSECT	STACK
KIDNAM:	.ASCIZ	"/BIN/SH"	;EXECUTE SHELL COMMAND
KARG1:	.ASCIZ	"-C"		;THIS OPTION SAYS TAKE NEXT ARG AND EX AS CMD
	.EVEN


;NULL TERMINATED LIST OF COMMAND POINTERS

KIDCMD:	.WORD	KIDNAM		;THE COMMAND WE ARE EXECUTING
	.WORD	KARG1		;OPTION TO SHELL TO EXECUTE NEXT ARG
	.WORD	EXBUF		;THE COMMAND LINE TO EXECUTE, SET UP BY SETFNM
	.WORD	0
;	.CSECT	PGM
.ENDC
;ROUTINE TO READ A BLOCK OF THE FILE INTO THE INPUT BUFFER PINBUF

PRINIT:
	PUSH	<R0>		;NEED REGISTER
	JSR	PC,CLOI		;CLOSE CURRENT INPUT FILE IF ANY
	TSTB	FILNAM		;ARE WE TRYING TO OPEN NULL FILE?
	BEQ	1$		;YES, IT WOULD OPEN DIRECTORY SO ERROR
.IFNZ SITS
	MOV #FILNAM,R0
	JSR PC,OPENRF
.ENDC
	;SYS	S_OPEN,FILNAM,0	;OPEN FILE FILNAM FOR READING
	BCS	1$		;IF CANNOT
	MOV	R0,INPFH	;SAVE FILE HANDLE
	INCB	INPFLG
	CLR	PINCNT
	POP	<R0>
	RTS	PC		;AND QUIT

1$:	POP	<R0>		;CLEAN UP
	SEC			;SIGNAL ERROR
	RTS	PC



;ROUTINE TO READ CHARS FROM FILE AND SAVE IN INPUT BUFFER

PRI:	DEC	PINCNT		;IS THERE ANYTHING TO READ?
	BGE	2$		;NO
	MOV	#PINBUF,PINPTR		;SET UP INPUT POINTER TO START
	MOV	INPFH,R0		;INPUT FILE HANDLE
.IFNZ SITS
	PUSH <#PINBUF,#PINMAX>
	NEG (SP)
	PUSH <R0>
	MOV #PINMAX,R0
	.BLKI
	BNE 3$
	TST (SP)+
	ADD (SP)+,R0	
	TST (SP)+
3$:
.ENDC
	;SYS	S_READ,PINBUF,PINMAX	;READ PINMAX BYTES INTO PINBUF
	;BCS	1$		;IF THERE WAS SOME READ ERROR
	MOV	R0,PINCNT	;MOVE COUNT OF HOW MUCH WE READ
	BNE	PRI		;GOT SOMETHING, SO RETURN IT
1$:	JSR	PC,CLOI
	SEC
	RTS	PC

2$:	MOVB	@PINPTR,R0
	INC	PINPTR
	CLC
	RTS	PC
;ROUTINE TO CREATE A FILE FOR OUTPUT.  IT IS CREATED WITH R/W ACCESS.
.IFNZ SITS
PPINNW:	PUSH <R0>
	JSR PC,CLOO
	JSR PC,OPENWN		;TRY TO CREATE A NEW FILE
	BR PPINI1
.ENDC
PPINIT:
	PUSH	<R0>		;NEED A REGISTER
	JSR	PC,CLOO		;CLOSE ANY CURRENTLY OPEN OUTPUT FILES
	TSTB	FILNAM		;SEE IS HE IS TRYING TO OPEN DIRECTORY
	BEQ	1$		;YES, ERROR
.IIF NZ SITS,	JSR PC,OPENW
	;SYS	S_OPEN,FILNAM,1	;SEE IF THERE IS A FILE WITH THAT NAME
	;BCC	1$		;THERE IS!!, BETTER NOT CLOBBER IT WITH CREATE
	;SYS	S_CREAT,FILNAM,666	;CREATE FILNAM WITH R/W ACCESS
PPINI1=.
	BCS	1$		;IN CASE WE HAVE PROBLEMS
	MOV	R0,OUPFH	;SAVE OUTPUT FILE HANDLE
	INCB	OUTFLG		;SIGNAL THAT WE HAVE OUTPUT FILE OPEN
	POP	<R0>		;CLEAN UP
	CLC			;NO ERRORS
	RTS	PC

1$:	POP	<R0>		;CLEAN UP
	SEC			;SIGNAL THAT WE COULND'T CREATE FILE
	RTS	PC



;ROUTINE TO DELETE A FILE

DELIT:	
.IIF NZ SITS,	JSR PC,DELFIL
	;SYS	S_UNLINK,FILNAM		;UNLINK FILNAM
	RTS	PC			;SIGNALS C IF IT CAN'T



;ROUTINE TO OPEN A FILE FOR APPEND

APPIT:	PUSH	<R0>			;NEED A REGISTER
	JSR	PC,CLOO			;CLOSE ANY CURRENTLY OPEN FILE
	TSTB	FILNAM			;TRYING TO OPEN A NULL FILE NAME?
	BEQ	1$			;YES, IT WOULD OPEN DIRECTORY SO ERROR
.IF NZ SITS
	MOV #FILNAM,R0
	JSR PC,OPENRF			;OPEN FILE
	BCC 13$				;FOUND OLD FILE
	JSR PC,OPENW			;CREATE NEW FILE
13$:
.ENDC
	;SYS	S_OPEN,FILNAM,1		;OPEN FILNAM FOR WRITING
	BCS	1$
	MOV	R0,OUPFH		;SAVE FILE HANDLE
	INCB	OUTFLG			;SIGNAL THAT WE HAVE OUTPUT FILE OPEN
.IIF NZ SITS,	JSR PC,SEEKEN		;SEEK TO END
	;SYS	S_SEEK,0,2		;SEEK TO END OF FILE TO APPEND
	BCS	1$			;IF SOMETHING WENT WRONG
	POP	<R0>			;CLEAN UP
	CCC				;SIGNAL NO ERRORS
	RTS	PC

1$:	POP	<R0>			;CLEAN UP
	SEC				;SIGNAL ERROR
	RTS	PC



;ROUTINE TO OPEN A TEMPORARY FILE, FOR NOW, JUST OPENS FILE

TMPIT:	JSR	PC,PPINIT		;OPEN NORMAL FILE
	RTS	PC

;ROUTINE TO OUTPUT ONE CHAR TO THE OUTPUT FILE

;PPO:	MOVB	R0,IOTMP		;SAVE THE CHAR IN IO TEMPORARY
;	MOV	OUPFH,R0		;OUTPUT FILE HANDLE
;	SYS	S_WRITE,IOTMP,1		;WRITE THIS ONE CHAR
;	BCS	1$			;IF SOMETHING WENT WRONG
;	MOVB	IOTMP,R0		;RESTORE THE CHAR
;	CCC				;NO ERROR
;	RTS	PC
;
;1$:	MOVB	IOTMP,R0		;RESTORE THE CHAR
;	SEC				;SIGNAL ERROR
;	RTS	PC
.IF NZ SITS
PPO:	PUSH <R0,OUPFH>
	.BYTO
	BEQ 1$
	CCC
	RTS PC

1$:	CMP (SP)+,(SP)+
	SEC
	RTS PC
.ENDC
;ROUTINE TO OUTPUT A BLOCK OF TEXT.  USES THE INDIRECT WRITE MECHANISM
;BECAUSE THE START AND COUNT WILL BE VARIABLES.

PPOL:	PUSH	<R0>			;NEED A REGISTER
	MOV	R1,W.PTR		;POINTER TO START OF TRANSFER
	MOV	R2,W.CNT		;POINTER TO END OF BLOCK
	SUB	R1,W.CNT		;SUBTRACT START TO GET COUNT OF CHARS
	MOV	OUPFH,R0		;THE OUTPUT FILE HANDLE
.IFNZ SITS
	PUSH <W.PTR,W.CNT>
	NEG (SP)
	PUSH <R0>
	.BLKO
	BEQ 1$
.ENDC
	;SYS	S_INDIR,W_FNC	;DO THE WRITE FUNCTION INDIRECTLY
	;BCS	1$			;IF SOMETHING WENT WRONG
	POP	<R0>			;CLEAN UP
	CCC				;SIGNAL NO ERRORS
	RTS	PC

1$:
.IF NZ SITS
	CMP (SP)+,(SP)+
	TST (SP)+
.ENDC
	POP	<R0>			;CLEAN UP
	SEC				;SIGNAL AN ERROR
	RTS	PC

;	.CSECT	STACK

	.EVEN
W.FNC:	;SYS	S_WRITE
W.PTR:	.WORD	0
W.CNT:	.WORD	0


;	.CSECT	PGM

;ROUTINE TO CLOSE ANY OPEN OUTPUT FILE.

CLO:
CLOO:	TSTB	OUTFLG			;ANY OUTPUT FILES OPEN?
	BEQ	1$			;NOTHING OPEN, JUST RETURN
	PUSH	<R0>			;NEED A REGISTER
	CLRB	OUTFLG			;NO LONGER ANYTHING OPEN
	MOV	OUPFH,R0		;OUTPUT FILE HANDLE
.IIF NZ SITS,	JSR PC,DELCAP
	;SYS	S_CLOSE			;CLOSE THE FILE
	;BCS	2$			;IF SOMETHING WENT WRONG
	POP	<R0>			;CLEAN UP
;	TSTB	BAKFLG			;DID WE HAVE A BACKUP FILE?
;	BEQ	1$			;NO, JUST RETURN
;	JSR	PC,UNBACK		;BACKUP THE INPUT FILE, RN TMP TO FILNM
;	BCS	3$			;IF WE COULDN'T
1$:	CCC				;SIGNAL NO ERRORS
	RTS	PC

2$:	POP	<R0>			;CLEAN UP
3$:	SEC				;SIGNAL THE ERROR
	RTS	PC

;ROUTINE TO CLOSE OPEN INPUT FILES

CLOI:	TSTB	INPFLG		;ANY INPUT FILES OPEN?
	BEQ	1$		;NOPE JUST RETURN
	CLRB	INPFLG		;NONE OPEN AFTER THIS..
	PUSH	<R0>		;GET A REGISTER
	MOV	INPFH,R0	;GET THE INPUT FILE HANDLE
.IIF NZ SITS,	JSR PC,DELCAP
	;SYS	S_CLOSE		;CLOSE IT
	BCS	2$		;IF SOMETHING WENT WRONG
	POP	<R0>		;CLEAN UP
1$:	CCC			;SIGNAL NO ERRORS
	RTS	PC

2$:	POP	<R0>		;CLEAN UP
	SEC			;SIGNAL AN ERROR
	RTS	PC
;	.CSECT	STACK
NAMSTR:	.ASCIZ	"TECO"
TMPSTR:	.ASCIZ	".TMP"
BAKSTR:	.ASCIZ	".BAK"
.EVEN
;	.CSECT	PGM
.IFZ SITS
;ROUTINE TO OPEN BAKFIL FOR INPUT, AND TECO.TMP FOR OUTPUT WHERE TECO.TMP
;SHOULD BE IN THE SAME DIRECTORY AS BAKFIL.

BACKT:	PUSH	<R0,R1,R2>	;NEED SOME REGISTERS
	MOV	#FILNAM,R0	;PTR TO SOURCE FIELD
	MOV	#BAKFIL,R1	;PTR TO RESULT FIELD
	MOV	#50.,R2		;SIZE OF RESULT FIELD
	JSR	PC,MOVSTR	;COPY IT SOURCE TO RESULT FIELD
	BCS	1$		;ON OVERFLOWS
	JSR	PC,PRINIT	;NOW OPEN IT FOR INPUT
	BCS	1$		;IF WE COULDN'T
;	JSR	PC,SAVMOD	;SAVE THE FILE MODE
	MOV	#BAKFIL,R0	;PTR TO SOURCE
	MOV	#TMPFIL,R1	;PTR TO DESTINATION
	MOV	#50.,R2		;SIZE OF DESTINATION
	JSR	PC,PUTDIR	;COPY DIRECTORY PART OF SOURCE TO DESTINATION
	MOV	#NAMSTR,R0	;POINTER TO STRING "TECO"
	MOV	#TMPFIL,R1	;PTR TO DESTINATION FIELD
	MOV	#50.,R2		;LENGTH OF DESTINATION FIELD
	JSR	PC,CONCAT	;CONCATENATE TECO.TMP TO DIRECTORY
	BCS	1$		;IF NAME OVERFLOWS
	MOV	#TMPFIL,R1	;PTR TO DESTINATION FIELD
	MOV	#50.,R2		;LENGTH OF DESTINATION
;	JSR	PC,APDPID	;APPEND THE PROCESS ID
;	BCS	1$		;IF NAME OVERFLOWS
	MOV	#TMPSTR,R0	;POINTER TO STRING ".TMP"
	MOV	#TMPFIL,R1	;POINTER TO DESTINATION
	MOV	#50.,R2		;LENGTH OF DESTINATION
	JSR	PC,CONCAT	;CONCATENATE TO NAME
	BCS	1$		;IF NAME OVERFLOWS
	MOV	#TMPFIL,R0	;PTR TO SOURCE
	MOV	#FILNAM,R1	;PTR TO DESTINATION
	MOV	#50.,R2		;LENGTH OF DESTINATION FIELD
	JSR	PC,MOVSTR	;COPY SOURCE TO DEST
	JSR	PC,DELIT	;DELETE ANY INSTANCES OF "TECO.TMP"
	JSR	PC,PPINIT	;OPEN FILE FOR OUTPUT
	BCS	1$		;IF PROBLEMS
	INCB	BAKFLG		;WE HAVE BACKUP FILE PENDING
	POP	<R2,R1,R0>	;CLEAN UP
	CCC			;SIGNAL NO ERRORS
	RTS	PC

1$:	JSR	PC,CLOI		;CLOSE THE INPUT FILE
	POP	<R2,R1,R0>	;CLEAN UP
	SEC			;SIGNAL THE ERROR
	RTS	PC
.ENDC
.IFNZ SITS
BACKT:	JSR PC,PRINIT		;OPEN FOR READ
	BCS 1$			;LOSE
	JSR PC,PPINNW
	BCS 1$
	RTS PC

1$:	JSR PC,CLOI
	SEC
	RTS PC
.ENDC



.IFZ SITS
;	.CSECT	STACK
	.EVEN
STATBF:	.BLKB	4		;STORAGE FOR THE FILE STATUS
OLDMOD:	.BLKB	32.		;FLAG WORD IS FIRST TWO BYTES
;	.CSECT	PGM

;ROUTINE TO READ THE MODE OF A FILE

SAVMOD:	;SYS	S_STAT,BAKFIL,STATBF	;READ THE STATUS OF BAKFIL
	MOV	OLDMOD,NEWMOD		;COPY THE MODE (SEE UNBACK FOR NEWMOD)
	BIC	#170000,NEWMOD		;WE ONLY WANT THE RELEVANT BITS
	RTS	PC
.ENDC

.IFZ SITS
;ROUTINE TO APPEND THE PROCESS ID AS A DECIMAL NUMBER TO A FIELD.
;EXPECTS POINTER TO FIELD IN R1, LENGTH OF FIELD IN R2.  SETS C
;IF THE RESULT OVERFLOWS THE FIELD. CLEARS C OTHERWISE.

APDPID:	TSTB	(R1)+		;FIND ZERO BYTE AT END OF DESTINATION
	BEQ	1$		;FOUND IT
	SOB	R2,APDPID	;CAN DO ONLY THIS MUCH
	SEC			;SIGNAL ERROR
	RTS	PC

1$:	TSTB	-(R1)		;BACK UP OVER ZERO BYTE
	PUSH	R5		;NEED A REGISTER
	MOV	R2,R5		;SAVE R2 HERE, CAUSE DECOUX CLOBBERS R2
	;SYS	S_GETPID	;GET THE PROCESS ID INTO R0
	JSR	PC,DECOUX	;PUSH CHAR REPRESENTATION OF R0 ONTO STACK
	MOV	R5,R2		;RESTORE R2
	MOVB	(SP)+,R0	;GET A COUNT OF CHARS IN THE NUMBER
	BIC	#177400,R0	;SINCE WE DID A MOVB -(SP)

2$:	DEC	R2		;ANY SPACE LEFT?
	BLT	3$		;NO
	MOVB	(SP)+,(R1)+	;COPY A CHAR INTO THE FIELD
	SOB	R0,2$		;DO IT FOR THIS MANY CHARS
	POP	R5		;CLEAN UP
	CCC			;SIGNAL NO ERRORS
	RTS	PC

3$:	TST	R0		;ANY CHARS LEFT ON STACK?
	BEQ	4$		;NO
	TSTB	(SP)+		;POP ONE
	SOB	R0,3$		;ONE LESS CHAR

4$:	POP	R5		;CLEAN UP
	SEC			;SIGNAL AN ERROR
	RTS	PC
;	.CSECT	STACK
	.EVEN
CHMOD:	;SYS	S_CHMOD,BAKFIL
NEWMOD:	.WORD	0
;	.CSECT	PGM


;ROUTINE TO RENAME THE INPUT FILE TO FILNAM.BAK AND RENAME TECO.TMP
;TO FILNAM.

UNBACK:	PUSH	<R0,R1,R2>	;NEED SOME REGISTERS
	MOV	#BAKFIL,R0	;PTR TO NAME OF INPUT FILE
	MOV	#FILNAM,R1	;PTR TO RESULT FIELD
	MOV	#50.,R2		;SIZE OF RESULT FIELD
	JSR	PC,PUTDIR	;COPY DIRECTORY NAME OF INP FILE TO RESULT
	BCS	1$		;IF IT OVERFLOWS
	CMP	R2,#15.		;MAKE SURE WE HAVE ROOM FOR FILE NAME
	BLO	1$		;NOT ENOUGH ROOM
	MOV	#11.,R2		;LEAVE ROOM FOR ".BAK" EXTENSION
	MOV	#BAKFIL,R0	;PTR TO NAME OF INPUT FILE AGAIN
	JSR	PC,PUTFIL	;NOW COPY THE FILE NAME, TRUNCATE IF TOO LONG
	MOV	#BAKSTR,R0	;POINTER TO EXTENSION ".BAK"
	MOV	#FILNAM,R1	;PTR TO DESTINATION FIELD
	MOV	#50.,R2		;SIZE OF DESITATION FIELD
	JSR	PC,CONCAT	;CONCATENATE TO FILENAME TO GIVE FILNAM.BAK
	BCS	1$		;COULDN'T... OVERFLOW ERROR
	;SYS	S_UNLINK,FILNAM	;DELETE ANY OLD COPIES OF FILNAM.BAK
	;SYS	S_LINK,BAKFIL,FILNAM	;RENAME FILNAM TO FILNAM.BAK
	BCS	1$		;PROBLEMS...
	;SYS	S_UNLINK,BAKFIL	;REMOVE THE LINK TO FILNAM
	;SYS	S_LINK,TMPFIL,BAKFIL	;RENAME TECO.TMP TO FILNAM
	BCS	1$		;PROBLEMS...
	;SYS	S_UNLINK,TMPFIL	;REMOVE THE LINK TO TECO.TMP
	;SYS	S_INDIR,CHMOD	;CHANGE MODE OF BAKFIL TO ORIGINAL MODE
	CLRB	BAKFLG		;WE NO LONGER HAVE A BACKUP PENDING
	POP	<R2,R1,R0>	;CLEAN UP
	CCC			;SIGNAL NO ERRORS
	RTS	PC

1$:	POP	<R2,R1,R0>	;CLEAN UP
	SEC			;SIGNAL ERROR
	RTS	PC
.ENDC

;SUBROUTINES FOR HACKING ASCIZ STRINGS FOR DIRECTORIES AND FILENAMES.

;ROUTINE TO CONCATENATE ONE STRING TO ANOTHER. HEAD GOES IN R1, TAIL IN R0,
;AND LENGTH OF RESULT FIELD IN R2.  TAIL IS COPIED IN HEAD FIELD.

CONCAT:	TSTB	(R1)+		;FIND THE END OF THE HEAD FIELD
	BEQ	1$		;GOT IT
	SOB	R2,CONCAT	;CAN ONLY DO THIS MUCH
	SEC			;SIGNAL ERROR
	RTS	PC

1$:	TSTB	-(R1)		;BACK UP TO ZERO BYTE, THEN FALL INTO MOVSTR



;ROUTINE TO MOVE AN ASCIZ STRING FROM ONE PLACE TO ANOTHER.

MOVSTR:	MOVB	(R0)+,(R1)+	;MOVE FROM (R0) TO (R1)
	BEQ	1$		;FOUND THE END
	SOB	R2,MOVSTR	;R2 HAS MAXIMUM LENGTH OF RESULT FIELD
	SEC			;SIGNAL ERROR
1$:	RTS	PC


;ROUTINE TO MOVE THE DIRECTORY PART OF A FILENAME TO ANOTHER FIELD
;AS AN ASCIZ STRING. R0 POINTS TO FILENAME, R1 TO FIELD, AND R2 CONTAINS
;SIZE OF THE FIELD.

PUTDIR:	PUSH	<R0>		;SAVE PTR TO BEGINNING OF DIRECTORY

1$:	TSTB	(R0)+		;LOOK FOR THE END OF THE FILENAME
	BNE	1$		;NOT THERE YET..

2$:	CMP	R0,(SP)		;ARE WE AT THE BEGINNING YET?
	BLOS	5$		;YES, MUST NOT BE ANY FILENAME
	CMPB	-(R0),#'/	;LOOK FOR LAST / IN FILENAME
	BNE	2$		;NOT FOUND YET

3$:	INC	R0		;MOVE TO CHAR AFTER /
	PUSH	<R0>		;SAVE THIS SPOT
	MOV	2(SP),R0	;RESET POINTER TO START OF FILENAME

4$:	MOVB	(R0)+,(R1)+	;MOVE A CHAR
	DEC	R2		;ONE LESS CHAR OF ROOM
	BLE	6$		;NO ROOM, OVERFLOW ERROR
	CMP	R0,(SP)		;ARE WE DONE?
	BLO	4$		;NO, STILL SOME LEFT
	POP	<R0>		;CLEAN UP A LITTLE

5$:	DEC	R2		;ROOM FOR ZERO?
	BLT	7$		;NO, SIGNAL ERROR
	CLRB	(R1)		;PUT A ZERO AT THE END
	POP	<R0>		;CLEAN UP THE REST
	CCC			;SIGNAL NO ERRORS
	RTS	PC

6$:	POP	<R0>		;CLEAN UP A LITTLE
7$:	POP	<R0>		;CLEAN UP THE REST
	SEC			;SIGNAL ERROR
	RTS	PC


;ROUTINE TO COPY JUST THE FILENAME PROPER FROM A PATHNAME.

PUTFIL:	PUSH	<R0>		;SAVE POINTER TO PATHNAME

1$:	TSTB	(R0)+		;LOOK FOR THE END OF THE PATHNAME
	BNE	1$		;NOT THERE YET

2$:	CMP	R0,(SP)		;ARE WE AT BEGINNING?
	BLOS	3$		;YES
	CMPB	-(R0),#'/	;ELSE LOOK FOR LAST /
	BNE	2$		;NOT FOUND YET
	INC	R0		;SKIP THE /

3$:	ADD	#2,SP		;CLEAN UP
	JSR	PC,MOVSTR	;PUT IN AS MUCH OF THE NAME AS WILL FIT
	CLRB	-(R1)		;MAKE SURE THERE IS A ZERO AT THE END
	RTS	PC

FILUNM:	MOV #FILNAM,R2
	CLR FILNIL		;NO ILLEGAL CHAR
	BR SETFN2

;ROUTINES TO GET A FILENAME FROM COMMAND STRING, PUT IN QREGISTER ",
;THEN COPY TO FILNAM OR EMFIL.

SETFNM:	MOV	#FILNAM,R2	;PUT THE FILENAME IN FIELD FILNAM
	BR	SETFN1

SETFN:	MOV	#EMFIL,R2	;PUT THE FILENAME IN FIELD EMFIL

SETFN1:	MOV #40,FILNIL		;SPACE IS ILLEGAL
SETFN2:	MOV	R2,-(R6)	;POINTER TO RESULT FIELD
	MOVB	ATSW,-(R6)
	JSR	R7,SETLIM	;COPY NAME STR INTO QREG ", ADVANCE R1 PAST IT
	MOVB	(R6)+,ATSW	;SETLIM CLOBBERS TO DELIMITER $ IN ATSW WAS 0
	MOV	R1,-(R6)	;SAVE POINTER TO COMMAND STRING
	JSR	R7,QSET		;SET R0 TO START OF NAME STRING, R2 TO END
	MOV	QLEN,R1		;LENGTH OF NAMESTR, SET BY QSET
	CMP	R1,#44.		;WAS IT LESS THAN OR EQUAL TO 44 CHARS?
	BLE	5$		;YES, IT'S OK
	MOV	#44.,R1		;ELSE SET IT TO 44. AS MAXIMUM
5$:	MOV	2(R6),R2	;RESTORE POINTER TO RESULT FIELD
1$:	CMPB	@R0,#33		;$ MARKS THE END OF THE FIELD, ARE WE THERE?
	BEQ	2$		;YES, DONE
	CMPB	(R0),FILNIL	;SHOULDN'T BE ANY SPACES IN FILENAMES
	BLOS	.BADF		;FOUND A SPACE OR CONTROL CHAR, BAD FILE NAME
.IFNZ SITS
	CMPB	(R0),#'Z!40	;MAKE SURE NO BRACKETS OR OTHER STRANGOS
	BHI	.BADF		;FOUND ONE
.ENDC
	CMPB #'a,(R0)		;LOWER CASE?
	BGT 12$
	CMPB #'z,(R0)
	BLT 12$
	BICB #40,(R0)
12$:	MOVB	(R0)+,(R2)+	;MOVE CHARS TO RESULT FIELD
	SOB	R1,1$		;THERE ARE R1 OF THEM
2$:	CLRB	(R2)+		;NOW PUT A ZERO AT THE END OF THE FIELD
	MOV	(R6)+,R1	;THIS PUTS POINTER AT END
	TST	(R6)+		;POP LENGTH
	RTS	PC

.BADF:	JMP	CHERWE

;ROUTINE TO COPY A EXEC STRING FROM COMMAND STRING INTO QREGISTER " AND EXBUF.
;EXPECTS R1 POINTING TO START OF STRING AND RETURNS WITH R1 POINTING AFTER.

SETEXC:	MOVB	ATSW,-(SP)	;SAVE THE ATSW
	JSR	PC,SETLIM	;COPY STRING INTO QREG " AND ADVANCE R1
	MOVB	(SP)+,ATSW	;RESTORE THE ATSW
	PUSH	<R1>		;NEED A REGISTER
	JSR	PC,QSET		;SET R0 TO START OF STRING, R1 TO LENGTH
	MOV	QLEN,R1		;GET THE LENGTH OF THE STRING
	CMP	R1,#EXBLEN	;IS IT TOO BIG?
	BHIS	3$		;YES, ERROR
	MOV	#EXBUF,R2	;POINTER TO DESTINATION FIELD

1$:	CMPB	(R0),#33	;33 MARKS THE END, ARE WE THERE?
	BEQ	2$		;YUP, STOP HERE
	MOVB	(R0)+,(R2)+	;ELSE COPY NEXT BYTE
	SOB	R1,1$		;KEEP AT IT

2$:	CLRB	(R2)+		;PUT A ZERO AT THE END
	POP	<R1>		;RESTORE POINTER TO COMMAND STRING
	CCC			;SIGNAL NO ERRORS
	RTS	PC

3$:	POP	<R1>		;CLEAN UP
	SEC			;SIGNAL AN ERROR
	RTS	PC

.IFZ SITS
;	.CSECT	STACK
	.EVEN
PTRACE:	;SYS	S_PTRACE	;PTRACE TO STOP MY PROCESS IE REQUEST 0
	.WORD	0		;REQUEST NUMBER
PTPID:	.WORD	0		;PROCESS ID OF MY PROCESS
	.WORD	0		;ADDRESS ALWAYS 0
;	.CSECT	PGM

;SIGNAL HANDLING ROUTINES

;HANDLE QUITS (^Q)

QUIT:	TST	WAITLK		;ARE WE WAITING FOR INFERIOR?
	BNE	1$		;YES, IGNORE SIGNAL COMPLETELY
	PUSH	R0		;NEED A REGISTER
	MOV	#21,R0		;^Q
	JSR	PC,TYO		;TYPE IT
	JSR	PC,CRLF	;MAKE IT PRETTY
	JSR	PC,CRLF
	JSR	PC,CLRTTY	;RESET TO NORMAL TTY MODE
	;SYS	S_GETPID	;GET MY PROCESS INTO R0
	MOV	R0,PTPID	;SAVE IT IN THE PTRACE CALL
	MOV	#1,R0		;THIS SAYS ACTUALLY STOP ME NOW
	;SYS	S_INDIR,PTRACE	;SUSPEND MY PROCESS !
	JSR	PC,INTTY	;GO BACK TO TECO TTY MODE
	POP	R0
	MOV	#CONT,(SP)	;ABORT COMMAND AND RESTART AT COMMAND LEVEL
1$:	;SYS	S_SIGNAL,2,QUIT	;RE-ESTABLISH THE HANDLER
	RTT


;HANDLE BREAKS (^B)

BREAK:	TST	WAITLK		;ARE WE WAITING FOR INFERIOR?
	BNE	1$		;YES, IGNORE SIGNAL COMPLETELY
	PUSH	R0		;NEED A REGISTER
	MOV	#2,R0
	JSR	PC,TYO		;TYPE THE ^B
	POP	R0
	MOV	#CONT,(SP)	;RETURN HERE AFTER INTERRUPT
1$:	;SYS	S_SIGNAL,3,BREAK;RE-ESTABLISH THE HANDLER
	RTT
.ENDC

;ROUTINE TO READ SYSTEM AND USER TIMES OF MY PROCESS.
.IFZ SITS
TIMER:	;SYS	S_TIMES,PUT	;READ TIMES
	RTS	PC
.ENDC

;ROUTINE TO GENERATE A COMMAND TO EM THE USER'S TECO.INIT FILE FROM HIS
;LOGIN DIRECTORY.  USES GLOBAL ROUTINE _GETCD TO GET HIS COMMAND DIRECTORY
;FROM THE USR_INFO FILE.

;	.GLOBL	_GETCD
;	.CSECT	STACK
INITHD:	.ASCIZ	"EM"
INITTL:	.ASCII	"/.TECO.INIT"
	.BYTE	33
	.BYTE	33
	.BYTE	0
.EVEN
;	.CSECT	PGM

GETINIT:MOV	#INITHD,R0	;GET POINTER TO HEAD STRING, DEST PTR IN R1
	MOV	#50.,R2		;LENGTH OF THE DESTINATION FIELD
	JSR	PC,MOVSTR	;COPY IN THE HEAD STRING
	DEC	R1		;BACK UP TO THE ZERO
	PUSH	<R1>		;SAVE THIS LOCATION
	MOV	R1,-(SP)	;POINTER OF WHERE TO PUT LOGIN DIRECTORY
;	JSR	PC,.GETCD	;COPY IN THE THE LOGIN DIRECTORY
	TST	(SP)+		;POP THE ARGUMENT
	POP	<R1>		;RESTORE POINTER TO START OF  LOGIN DIRECTORY
	TSTB	(R1)		;IF ZERO, THEN NO COMMAND DIRECTORY WAS FOUND
	BEQ	1$		;ZERO, SO USE WORKING DIRECTORY
	MOV	#INITTL,R0	;POINTER TO TAIL STRING
	MOV	#50.,R2		;LENGTH OF THE FIELD
	JSR	PC,CONCAT	;CONCATENTATE TAIL STRING
	CLZ			;SIGNAL NO ERROR
	RTS	PC

1$:	SEZ			;SIGNAL AN ERROR
	RTS	PC
;	.CSECT	STACK
	.EVEN

B.FNC:	;SYS	S_BREAK		;BREAK SYSTEM CALL, FOR INDIRECT EXECUTING
B.ADR:	.WORD	0		;THE ARGUMENT TO BREAK

MEMMSG:	.ASCII	" BYTES]"	;MESSAGE TO TYPE WHEN WE GET MORE MEMORY
	.BYTE	12		;FINISH WITH CRLF
MEMMEN:				;JUST MARK END OF MEMMSG
KMEM:	.ASCIZ	"/DEV/KMEM"	;PATH NAME OF KMEM PSEUDO FILE
.EVEN

;	.CSECT	PGM
;ROUTINE TO INITIALIZE THE BUFFER AND ASSOCIATED VARIABLES

;	.GLOBL	_END,_ETEXT,_EDATA

BFINIT:
	MOV	#.ENDX,ENBF	;THE ADDRESS OF _END SHOULD BE END OF DATA
	MOV	ENBF,EOA	;OUR INITIAL END OF ALL
	ADD	#MEMINT,ENBF	;WHAT OUR INITIAL BREAK ADDRESS SHOULD BE
;	MOV	ENBF,B.ADR	;THIS IS WHAT WE WANT FOR A BREAK
;	SYS	S_INDIR,B_FNC	;EXECUTE THE BREAK CALL INDIRECTLY
	MOV	ENBF,LIMBF	;LIMIT OF BUFFER TOO
	MOV	ENBF,ENBF.4	;ALMOST END OF BUFFER MARKER
	SUB	#6,ENBF.4	;IT'S 6 WORDS FROM REAL END
	TST	(EOA)+		;LEAVE A ZERO AT THE BOTTOM
	MOV	EOA,TBUFX	;START OF QREGISTER AREA
	MOV	EOA,BOQ		;END OF QREGISTER AREA
	TST	(EOA)+		;LEAVE A WORD TO SEPARATE QREGISTER FROM BUF
	MOV	EOA,BOB		;START OF BUFFER
	MOV	EOA,CPTR	;CURSOR
	MOV	EOA,CEND	;COMMAND END
	MOV	EOA,CMDLOC	;LOCATION OF COMMAND
	MOV	MEMLIM,STKLIM	;STACK SHOULD NOT GROW INTO BUFFER AREA
	RTS	PC
	
;ROUTINE TO GET MORE MEMORY FOR BUFFER. CALL WITH CURRENT END OF MEMORY
;IN R0. RETURN AMOUNT ADDITIONAL WE GOT IN R0

GETMEM:	ADD	#MEMINC,R0	;WE WANT THIS MUCH MORE
	CMP	R0,MEMLIM	;WOULD THIS PUT US PAST END
	BHIS	1$		;YES, DON'T DO IT
	MOV	R0,B.ADR	;WE WANT THE NEW BREAK HERE
	;SYS	S_INDIR,B_FNC	;EXECUTE BREAK CALL INDIRECTLY
	;BCS	1$		;WE COULDN'T GET THAT MUCH
	PUSH	<R1,R2>		;NEED SOME REGISTERS
	MOV	#'[,R0		;TYPE A [
	JSR	PC,TYO
	MOV	B.ADR,R0	;OUR CURRENT BREAK
	JSR	PC,DECOUT	;TYPE HOW MUCH CORE WE HAVE NOW
	MOV	#MEMMSG,R1	;POINTER TO OUR MEMORY MESSAGE
	MOV	#MEMMEN,R2	;END OF OUR MEMORY MESSAGE
	JSR	PC,TYPER	;TYPE IT
	POP	<R2,R1>		;CLEAN UP
	MOV	#MEMINC,R0	;WE GOT THIS MUCH MORE
	RTS	PC

1$:	CLR	R0		;TELL CALLER WE COULDN'T GET ANY MORE
	RTS	PC
;ROUTINE TO PROCESS ANY COMMAND ARGUMENTS THAT WE WERE GIVEN.
;SEE WRITEUP IN UNIX MANUAL FOR EXEC, FOR EXPLANATION OF THIS.

GETARG:	CMP	2(SP),#1	;WERE WE GIVEN ANY ARGUMENTS?
	BEQ	1$		;NO, JUST THE NAME "TECO"
	MOV	6(SP),R0	;THIS SHOULD BE POINTER TO ARG #1 STRING
	MOV	#SAVFIL,R1	;POINTER TO RESULT FIELD
	MOV	#50.,R2		;SIZE OF RESULT FIELD
	JSR	PC,MOVSTR	;COPY IT

1$:	RTS	PC



;PROGRAM BEGINS HERE. SET UP STACK AND PROCESS ARGUMENTS

;START:	MOV	SP,STKSV	;PUT OUR INITIAL STACK POINTER HERE
;	;SYS	S_SIGNAL,2,QUIT	;ESTABLISH THE QUIT HANDLER
;	;SYS	S_SIGNAL,3,BREAK;ESTABLISH THE BREAK HANDLER
;	CLR	R0		;
;	;SYS	S_NICE		;SET OUR PRIORITY
;	JSR	PC,GETARG	;COPY THE ARGUMENT STRING TO SAVFIL
;	JSR	PC,BFINIT	;INITIALIZE BUFFER VARIABLES
;	JMP	TECO		;START UP TECO PROPER
.IF NZ SITS
	.BLKW 20
TMPPDL:	0
START:
	MOV #TMPPDL,SP
.IFNZ LSI
	RESET
	JSR PC,LSINIT
	JSR PC,MEMCHK
	JSR PC,HINIT
.ENDC
.IF Z LSI
	JSR PC,BRKINT
	PUSH <#7*400+0,#0,#17_8.+377,#.CRWRT+1>	;CREATE
	.MAP
	BNE 9$	;LOSE?
	BPT
9$:
.ENDC
	MOV	MEMTOP,SP		;THE TOP OF MEMORY
	MOV	SP,STKSV
	JSR	PC,BFINIT
	JMP	TECO
.ENDC
;PROGRAM COMES HERE TO LEAVE TECO

FINISH:	JSR	PC,CLRTTY
	TSTB	BAKFLG			;DO WE HAVE ANY TMPFIL AROUND?
	BEQ	1$			;NO, EVERYTHING'S OK
	BPT
	;SYS	S_UNLINK,TMPFIL		;GET RID OF THE TMPFIL
1$:	MOV #3,R0
.IFNZ LSI
2$:	JSR PC,UNMOUNT
	DEC R0
	BGE 2$	
	MOV CURCAP,R0
	JSR PC,DELCAP
	CLR CURCAP
	HALT
.IFF
	BPT
.ENDC
	;SYS	S_EXIT			;EXIT

.IFNZ SITS
.REDCH:	POP <TEMP>
	PUSH #2
	$BYTI
	JMP @TEMP
TEMP:	0
.ENDC

;SITS FILES ROUTINES
.IFNZ SITS
;OPENRF	OPENR BUT RESULT MUST BE A FILE
OPENRF:	JSR PC,OPENR
	BCS 1$
	JSR PC,DIRCHK
	BNE 1$
	CLC
	RTS PC
1$:	SEC
	RTS PC

DIRCHK:	PUSH <#FILBLK,#40,R0>
	BIS #.FARI,(SP)
	$INVOK
	BIT #.FADIR,FILBLK+2
	RTS PC

;SEEKEN	CAP IN R0, SEEK TO EOF
SEEKEN:	CMP -(SP),-(SP)
	PUSH <R0>
	BIS #.FARE,(SP)
	$INVOK
	PUSH <R0>
	BIS #.FASP,(SP)
	$INVOK
	RTS PC


;OPENW	CREATE FILNAM IF IT DOESN'T EXIST
OPENW:	JSR PC,COPCUR		;COPY DIR CAP
	BCS 2$
	PUSH <#0,#FILNAM,R0>
	BIS #.FAAD,(SP)
	.INVOK
	BEQ 1$
	RTS PC

1$:	CMP (SP)+,(SP)+
	TST (SP)+
	JSR PC,DELCAP
2$:	SEC
	RTS PC


;OPENWN	CREATE FILNAM, APPENDING > IF NOT ALREADY THERE (FLUSHING #NM ALSO)
OPENWN:	PUSH <R1>
	MOV #FILNAM,R0
1$:	TSTB (R0)+
	BNE 1$
	TSTB -(R0)
	MOV R0,R1
	TSTB -(R0)
	CMPB #'>,(R0)
	BEQ 3$
2$:	CMPB #'#,-(R0)
	BEQ 4$
	CMP #FILNAM,R0
	BLO 2$
	MOV R1,R0
4$:	MOVB #'>,(R0)+
	CLRB (R0)
3$:	POP <R1>
	JMP OPENW



;DELETE FILE IN FILNAM
DELFIL:	MOV #FILNAM,R0
	JSR PC,OPENR
	BCS 1$
	CMP -(SP),-(SP)
	PUSH <R0>
	BIS #.FADL,(SP)
	$INVOK
	JSR PC,DELCAP
	CLC
1$:	RTS PC

;POINTER TO FILE NAME IN R0, RETURN CAP # IN R0
;OPEN FOR READING
OPENR:	PUSH <R1,R0>
	JSR PC,COPCUR	;RETURN IN R0 A COPY OF THE CURRENT DIR CAP
	BCS 2$
	POP <R1>	;GET BACK NAME POINTER INTO R1
	PUSH <#0,R1,R0>	
	BIS #.FAMU,(SP)
	.INVOK		;TRY TO MUTATE TO FILE
	BNE 1$		;SUCCESS
	CMP (SP)+,(SP)+
	TST (SP)+
	POP <R1>
2$:	SEC
	RTS PC

1$:	POP <R1>
	CCC
	RTS PC

COPCUR:	TST CURCAP
	BEQ 1$
	PUSH <#-1,#0,CURCAP>
	BIS #.CPYCP,(SP)
	$INVOK
	POP <R0>
	CLC
	RTS PC
1$:	SEC
	RTS PC

DELCAP:	TST R0
	BEQ 1$
	PUSH <#0,#0,R0>
	BIS #.DELCP,(SP)
	$INVOK
1$:	RTS PC

SETDIR:	PUSH <R1>
	MOV #FILNAM,R5
	TSTB (R5)
	BEQ SETDI5
	CMPB #';,(R5)+
	BEQ SETDI0
	CMPB #';,(R5)+
	BEQ SETDI1
	DEC R5
	DEC R5
SETDI9:	MOV R5,R0
	JSR PC,OPENR		;MUTATE THERE
	BCS 1$			;ERROR?
	PUSH <R0>
	MOV CURCAP,R0
	JSR PC,DELCAP
	POP <CURCAP>
SETDI5=.
	CCC
1$:	POP <R1>
	RTS PC

SETDI0:	MOV CURROT,R1
	BR SETDI2

SETDI1:	MOVB FILNAM,R1
	SUB #'0,R1
	BLT 1$
	CMP #4,R1
	BLE 1$
SETDI2=.
	JSR PC,CRTROT	
	BNE SETDI9

1$:	SEC
	POP <R1>
	RTS PC

CRTROT:	MOV R1,CURROT
	ASL R1
	MOV ROTCPS(R1),R0
	BNE CRTRO1	;WE ALREADY HAVE ONE
	MOV R1,ROTBLK
	BIS #.FARUT,ROTBLK
	PUSH <#-1,#ROTBLK,#.FACAP*400+0>
	.INVOK		;TRY TO CREATE A ROOT CAP
	BNE 1$
2$:	CMP (SP)+,(SP)+
	TST (SP)+
	SEZ
	RTS PC
1$:	POP <ROTCPS(R1)>
	JSR PC,SETROT
	JSR PC,COPCUR
	PUSH <#0,#BITS,R0>
	BIS #.FAMU,(SP)
	.INVOK
	BEQ 2$
	CMP -(SP),-(SP)
	PUSH <R0>
	BIS #.FAMB,(SP)	;THSI IS THE BIT TABLE
	.INVOK
	BEQ 2$
	JSR PC,DELCAP
	CLZ
	RTS PC

UNMOUN:	PUSH R0
	ASL R0
	MOV ROTCPS(R0),R0
	JSR PC,DELCAP
	CLR ROTCPS(R0)
	MOV (SP),R0	;GET BACK DISK NUMBER
	ASL R0
	TST CURCAP
	BEQ 1$
	CMP -(SP),-(SP)
	PUSH <CURCAP>
	BIS #.FADI,(SP)
	$INVOK
	TST (SP)+	;FREE BLOCK COUNT
	CMP R0,(SP)+	;DISK NUMBER
	BNE 1$
	MOV CURCAP,R0
	JSR PC,DELCAP
	CLR CURCAP
1$:	POP R0
	RTS PC


SETROT:	MOV CURCAP,R0
	JSR PC,DELCAP
	PUSH <#-1,#0,ROTCPS(R1)>
	BIS #.CPYCP,(SP)
	$INVOK
	POP <CURCAP>
	RTS PC

CRTRO1:	JSR PC,SETROT
	CLZ
	RTS PC


FILNIL:	0
BITS:	.ASCIZ /BITS/
	.EVEN
ROTBLK:	0
CURROT:	0	;CURRENT ROOT DISK
.IF Z LSI
CURCAP:	4
ROTCPS:	.WORD 10,11,12,13
.IFF
CURCAP:	0
ROTCPS:	.BLKW 4
.ENDC
FILBLK:	.BLKW 40




























PODIRT:	PODIRP					;PARENT
	PODIRD					;DIRECTORY
	PODIRF					;FILE
	PODIRF					;LAST FILE
	PODIRS					;SELF
	PODIRL					;LINK
	PODIRL					;NOT IMPLEMENTED
	PODIRL					;NOT IMPLEMENTED
TMPCP:	0
FREEBL:	0
DSKNUM:	0
DTEXT:	.ASCII \ FREE BLOCKS ON DISK #\
DTEXTE:
.EVEN

POI:	JSR PC,COPCUR
	BCC 1$
	RTS PC
1$:	MOV R0,TMPCP
	CMP -(SP),-(SP)
	PUSH <R0>			;GET DISK DATA
	BIS #.FADI,(SP)
	$INVOK
	POP <FREEBL,DSKNUM>
	JSR PC,PODIR				;LIST IT
	MOV FREEBL,R0				;NUMBER OF FREE BLOCKS
	JSR PC,DECOUT				;PRINT NUMBER OF FREE BLOCKS ON DISK
	PUSH <R1>
	MOV #DTEXT,R1
	MOV #DTEXTE,R2
	JSR PC,TYPER
	POP <R1>
	MOV DSKNUM,R0				;DISK NUMBER
	JSR PC,DECOUT				;PRINT DISK NUMBER
	JSR PC,CRLF				;AND CAR-RET
	JSR PC,TTFLSH
	MOV TMPCP,R0
	JSR PC,DELCAP
	CLR TMPCP
	RTS PC					;WE ARE DONE

PODIR:	PUSH <R1,R2,R3,R4>
	CLR R3					;NUMBER OF ENTRY BEING PROCESSED
PODIR0:
PODIR1:	MOV #6,R2				;WANT THE EOF WORD
	JSR PC,POSETW
	PUSH R5					;PUSH EOF WORD ON THE STACK
PODI11:	CLR R2					;SET POINTER TO BEG OF DIR
	MOV R3,R4					;SKIP SOME ENTRIES
	BEQ PODIR3
PODIR2:	CMP R2,(SP)				;CHECK EOF
	BLO PODI10
PODI12:	TST (SP)+
	POP <R4,R3,R2,R1>
	RTS PC					;NO MORE ENTRIES SO RETURN
PODI10:	JSR PC,POSETW
	INC R5
	BIC #177401,R5				;SIZE OF THIS ENTRY
	ADD R5,R2
	SOB R4,PODIR2				;SKIP ANOTHER ENTRY
	CMP R2,(SP)
	BHIS PODI12
PODIR3:	JSR PC,POSETW
	SWAB R5
	BIC #177761,R5				;GET TYPE FIELD
	PUSH R2
	JMP @PODIRT(R5)				;DISPATCH TO SERVICE ROUTINE

PODIRL:	BPT					;BUG LINKS NOT IMPLEMENTED
	BR PODIRP				;JUST SKIP THE ENTRY
PODIR4:
PODIR5:
PODIR6:	PUSH R3
	MOV #'I,R3
	JSR PC,R3TYO
	JSR PC,.SPACE
	POP R3					;INDICATES INFERIOR DIRECTORY
PODIRS:
PODIR7:	MOV #-1,R4
	JSR PC,POSETW
	JSR PC,POWRDI
	JSR PC,PODIRI				;PRINT NAME,VERSION, AND SIZE
PODIRP:	INC R3					;ENTER HERE FOR PARENT TYPE ENTRY
	POP R2
	BR PODI11				;DO THE NEXT ENTRY

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

PODIRF:
;	MOV R0,R5					;ENTER HERE FOR FILES
;	ADD #2,R5				;NUMBER OF SPACES BEFORE NAME
	JSR PC,SPAC2
;	JSR PC,PODIRB				;PRINT THE BLANKS
	JSR PC,PODIRN
	BR PODIRP				;PRINT POP OF INFORMATION
PODIRD:	MOV R0,R5					;NUMBER OF PRECEDING SPACES
	BR PODIR4				;SUPPRESS LISTING OF INFERIOR DIRECTORY

;SKIP TO BEGINNING OF NAME
;(R2)= POINTER TO BEGINNING OF ENTRY

PODIRE:	JSR PC,POSETW
	PUSH R5
	JSR PC,POWRDI
;	MOV R5,TVERN	
	ADD #4,R2
	MOV (SP),R5				;GET THE HEADER WORD BACK
;	CLR DATE				;NOW TEST BITS IN HEADER WORD
	ROL R5
	BCC 1$
	ADD #4,R2
	JSR PC,POSETW
;	MOV R5,DATE
	JSR PC,POWRDI
	ADD #4,R2
;	MOV R5,TIME
1$:	POP R5
	BIT #40000,R5
	BEQ PODIE2
PODIE1:	ADD #2,R2				;SKIP ACCESS CODES
	JSR PC,POSET
	PUSH TMPCP
	$BYTI
	TSTB (SP)+
	BLT PODIE1				;MORE ACCESS CODES?
PODIE2:	;FALLS INTO POSET

POSET:	PUSH <R2,#0,TMPCP>
	BIS #.FASP,(SP)
	$INVOK
	RTS PC

POSETW:	JSR PC,POSET

POWRDI:	PUSH TMPCP
	$WRDI
	POP R5
	RTS PC


;PRINT OUT R0 LINE OF INFORMATION ABOUT FILE
;(R2)= POINTS TO ENTRY TO PRINT
;PUSH REGISTERS R0,R1,R3

PODIRN:	JSR PC,POSETW				;SET TO HEADER AND IGNORE
	JSR PC,POWRDI				;GET VERSION #
	PUSH R5
	JSR PC,POWRDI				;GET EOF
	PUSH R5
	JSR PC,POWRDI
	ADD #1777,R5				;ROUND UP TO BLOCK BOUNDARY
	CLR R4					;CLEAR HIGH PART
	ASHC #3,R4
	ADD (SP)+,R4				;PAGE NUMBER
	ASHC #3,R4				;NOW LEGNTH IN BLOCKS
	POP R5
PODIRI:	PUSH <R0,R3,R4,R5>			;PUSH LEGNTH AND VERSION NUMBER
	JSR PC,PODIRE				;SKIP TO BEGINNING OF NAME
PODIN2:	PUSH TMPCP
	$BYTI
	MOV (SP),R3
	BIC #177600,R3				;CLEAR TOP BIT OF BYTE
	CMPB #'#,R3
	BEQ PODIN8
	CMPB #'",R3
	BEQ PODIN8
	CMPB #'>,R3
	BEQ PODIN8
	CMPB #'<,R3
	BNE PODIN9
PODIN8:	MOV #'",R3
	JSR PC,R3TYO
	MOV (SP),R3
PODIN9:	JSR PC,R3TYO				;PRINT R0 CHARACTER
	TSTB (SP)+				;LAST BYTE HAS 200 BIT SET
	BPL PODIN2
	POP <R0>				;VERSION NUMBER
	BLT PODIN3				;NO VERSION NUMBER
	MOV #'#,R3
	JSR PC,R3TYO
	JSR PC,DECOUT				;PRINT THE VERSION NUMBER
PODIN3:	POP <R0>				;PRINT THE BLOCK LEGNTH
	BLT 1$
	JSR PC,SPAC2
	JSR PC,DECOUT
1$:
;	JSR PC,PRDAT
	JSR PC,CRLF
	POP <R3,R0>
	RTS PC					;DONE WITH THIS ENTRY

SPAC2:	JSR PC,(PC)
.SPACE:	PUSH <R3>
	MOV #40,R3
	JSR PC,R3TYO
	POP <R3>
	RTS PC

.IFZ 105
;PRDAT PRINTS DATE & TIME, IF ANY
PRDAT:	JSR R5,ACSAV				;PUSH ALL REGISTERS  
	MOV #11,R3				;TAB
	JSR PC,R3TYO
	MOV DATE,R4				;PUT DATE IN R4 
	BEQ 5$					;IF NO DATE & TIME, RETURN
	CMP #-1,R4				;SEE IF INITIALIZED
	BNE PRDAT1				;GO ON IF INITIALIZED
	JSR PC,.SPACE
	MOV #'-,R3				;PRINT " -" IF NOT
	JSR PC,R3TYO
5$:	JSR R5,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;CONTROL INSTRUCTIONS FOR PRDAT2
PRDAT1:	MOV #DTTAB,R1				;POINT TO BEG. OF DTTAB	
	JSR PC,PRDAT2				;PRINT DATE IN R4
	MOV TIME, R4				;PUT TIME IN R4				
	JSR PC,PRDAT2				;PRINT TIME
	JSR R5,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;TABLE DRIVEN ROUTINE TO PRINT DATE & TIME SEGMENT BY SEGMENT
	;ZTYPE & DECOUT TAKE ARGUMENT IN R0 
PRDAT2:	MOV #3,R2				;R2 IS LOOP INDEX
PRDAT3:	MOV R4,R0					;PUT DATE OR TIME IN R0
	ASH (R1)+,R0				;SHIFT QUANTITY TO LOW BYTE
	BIC (R1)+,R0				;ZAP ALL BUT RELEVANT BITS
	ASH (R1)+,R0				;MULT. FACTOR: 0 EXCEPT FOR SEC/2
	CMP #3,R2				;FIRST TIME THRU LOOP?
	BEQ 1$				
	JSR PC,ZPRDN				;PRINT WITH LEADING 0 IF < 10
	BR 2$
1$:	JSR PC,DECOUT				;PRINT WITHOUT LEADING 0 IF < 10	
2$:	MOV (R1)+,R0				;PICK UP DELIMITER CHARACTER
	MOV R0,R3					;PUT CHARACTER IN R3
	JSR PC,R3TYO				;PRINT CHARACTER
	SOB R2,PRDAT3				;DO NEXT SEGMENT
PRDAT4:	RTS PC

.ENDC

R3TYO:	PUSH <R0>
	MOV R3,R0
	JSR PC,TTPUTC
	POP <R0>
	RTS PC


CRINDX:	MOV SP,R5
	JSR PC,COPCUR
	BCS 8$
	PUSH <#0,#FILNAM,R0>
	BIS #.FAAD,(SP)
	.INVOK		;TRY TO CREATE THE DIRECTORY
	BEQ 9$
	PUSH <#0,R0>
	.WRDO		;MAKE FILE FILE 1 BLOCK LONG
	BEQ 9$
	PUSH <#0,#0,R0>
	BIS #.FAMD,(SP)
	$INVOK		;MAKE INTO A DIR
	JSR PC,DELCAP
	CLC
	RTS PC

9$:	JSR PC,DELCAP
8$:	MOV R5,SP
	SEC
	RTS PC


.IFZ LSI
BRKINT:	PUSH <#0,#0,#.SPKIL*400+1>
	$INVOK
	PUSH <#BRKPRS>
	$FORK
	RTS PC		;MAIN PROCESS RETURNS

	.BLKW 20
BRKPDL:

BRKPRS:	MOV #BRKPDL,SP	;MY OWN SPECIAL PDL
BRKPR3:	PUSH <#0,#377*400+'G-100,#2>
	MOVB #.TTBRK,1(SP)	;TO WAIT FOR ONE OF THESE CHARS
	$INVOK		;WAIT
	CMPB #'G-100,(SP)	;WAS IT R0 BREAK?
	BNE BRKPR2
	MOV #1,BRAKE
BRKPR2:	TST (SP)+
	BR BRKPR3
.ENDC

.IFNZ LSI
MEMCHK:	SAVE 4
	MOV #MEMCH1,4
	MOV PC,R0
1$:	TST (R0)+
	BR 1$

MEMCH1:	CMP (SP)+,(SP)+
	TST -(R0)
	MOV R0,RMEMT
	SUB #40,R0	;LEAVE ROOM FOR LSI DDT
	MOV #MEMCH2,4	;NOW CHECK FOR 11/45
	TST 177570	;SWITCH REGISTER ?
	MOV #156400,R0	;WE ARE ON 11/45, LEAVE ROOM FOR RUG
	BR MEMCH3
MEMCH2:	CMP (SP)+,(SP)+	;FLUSH THE TRAP
MEMCH3:	MOV R0,MEMTOP
	SUB #10000,R0	;ALLOW FOR STACK SPACE
	MOV R0,MEMLIM
	MOV #MEMCH4,4	;NOW CHECK FOR SMS
	CLR GOTSMS
	BIS #SMSRSB,SMSCSR	;IF WE HAVE ONE, RESET IT
	MOV PC,GOTSMS	;GOT ONE
	CLR SMSLGT
.IFNZ 105
	MOV #30.,HSEC	;DEFAULT IS 60HZ
	BIT #SMS60H,SMSPRE	;IS THIS R0 60HZ MACHINE?
	BNE 1$		;YUP
	MOV #25.,HSEC	;NOPE, MUST BE R0 50
1$:	BR MEMCH5
.ENDC
MEMCH4:	CMP (SP)+,(SP)+
MEMCH5:
.IFNZ LSPRNT
	MOV #MEMCH6,4
	TST LPS		;IS THERE R0 PRINTER?
	BR MEMCH7	
MEMCH6:	CMP (SP)+,(SP)+
	CLR LPUSE	;"USED"
MEMCH7:
.ENDC
	REST 4
	RTS PC	
RMEMT:	0
GOTSMS:	0

HINIT:	BIS #100,LSRCSR	;TTY INTERUPTS
	MOV #LSIEMT,30	;EMT TRAP VECTOR
.IIF NZ LSDISK,	CLR LSDKOF	;DISK GOT TURNED OFF
.IFNZ 105
	TST GOTSMS
	BEQ 1$
	BIS #SMSCLE,SMSCSR	;ENABLE CLOCK TOO
1$:
.ENDC
	RTS PC

.ENDC
;THE EXPAND SPACE ROUTINE
.IFZ LSI
HGHPG=<<.ENDX/20000>&7>	; CURRENT HIGHEST PAGE
HGHPAG:	HGHPG
HGHLN=<<.ENDX-<HGHPG*20000>>/2000>&7
HGHPGL:	HGHLN	; CURRENT LENGTH OF HIGHEST PAGE

EXSPAC:	INC HGHPGL	;INCREASE HIGH PAGE?
	CMP #10,HGHPGL	;IS IT ALREADY 4K?
	BEQ EXSPA1	;YUP
	PUSH <#0,#0,#10_8.+374,#.CRWRT+1>	;TO EXPAND THE PAGE
	MOVB HGHPGL,7(SP)	;HOW LONG?
	BISB HGHPAG,3(SP)	;WHICH PAGE?
	.MAP 		;ATTEMPT TO EXPAND
	BNE EXSPA9	;LOSE?
	ADD #10,SP	;POP ARGS OF FAILED CALL
	DEC 2(R0)	;WE DIDN'T DO WHAT WE SET OUT TO
EXSPA3:	POP R0
	SEC
	RTS PC
EXSPA1:	DEC HGHPGL	;NOT INCREASING PAGE SIZE AFTER ALL
	CMP #6,HGHPAG	;ALREADY ON LAST PAGE?
	BEQ EXSPA3	;IF YES LOSE
	INC HGHPAG		;GO TO NEXT PAGE
	CLR HGHPGL	;START WITH 512 WORDS
	PUSH <#0,#0,#10_8.+377,#.CRWRT+1>	;TO CREATE NEW PAGE
	BISB HGHPAG,3(SP)	;WHICH PAGE?
	.MAP		;TRY TO CREATE
	BNE EXSPA9	;BR ON WINNING
	ADD #10,SP	;POP ARGS
	MOV #7,HGHPGL	;BACK UP
	DEC HGHPAG		;TO PREVIOUS PAGE
	BR EXSPA3	;GO FAIL
EXSPA9:	POP R0
	CLC
	RTS PC
.ENDC

;PRINT CURRENT BUFFER ONTO LP
PRINTP:	MOV SP,R5
	PUSH <#-1,#0,#.LPCAP*400+0>
	.INVOK
	BEQ 1$		;LOSER
	POP R0
	PUSH <BOB,BOB>
	SUB EOA,(SP)	;NEGATIVE COUNT
	PUSH R0
	.BLKO
	BEQ 2$
	JSR PC,DELCAP
	CLC	
	RTS PC

2$:	JSR PC,DELCAP
1$:	MOV R5,SP
	SEC
	RTS PC


.ENDC
.ENDX=.

	.END	START
