.IFF
;UNIX VERSION OF DIRECTORY LISTING
.ENDC

.IFNZ SITS	;THIS IS PRETTY USELESS ON THE LSI-11, EVEN WITH FLAKEY DISK
;MAIL PRIMITIVE. SENDS "MAIL" TYPED ON SCREEN TO PERSON SPECIFIED
	;BY INSERTING TEXT INTO HIS OWN MAIL FILE, IF ONE EXISTS
	;OR CREATING A NEW ONE IF ONE DOESN'T
MAIL:	JSR PC,SETCH0
	MOV #10,A	;GET CAPABILITY TO ROOT DIRECTORY
	JSR PC,COPCUR
	SAVE <#0,#MAILNM,@CURCPP> ;MUTATE TO MAIL DIR. ENTRY IN ROOT DIR.
	BIS #.FAMU,(P)	
	.INVOK
	JSR PC,.OPNA3	;OPEN MAIL FILE
	MOV #.WRTEC,PCHR	;CHARS. IN BUFFER INTO OUTPUT DEVICE
	PRTXTC ^/------/
STLANC
ENGINS	<PRTXT ^/MAIL FROM />
ENDENG
FRINS	<PRTXT ^/EN PROVENANCE DE />
ENDLAN
	SAVE <#NAME,#-1> 	
	.CRUSR		;GET SENDER'S NAME IN "NAME"
	MOV #NAME,A	
	JSR PC,PRAS	;PRINT NAME POINTED TO BY A
	JSR PC,.CRLF	;CARRIAGE RETURN, LINEFEED
	JSR PC,UDATEG	;SET THE DATE
	MOV #1,D
	JSR PC,TYPE	;PRINT THE DATE
	JSR PC,.SPACE
	JSR PC,UTIMEG	;SET THE TIME
	MOV #1,D
	JSR PC,PRINT	;PRINT THE TIME
	SPUSH PRMTCH	;SAVE NORMAL PROMPT CHARACTER
	MOV #'_,PRMTCH	;NEW ONE IS "_"
	MOV #TYO,PCHR
MAIL2:	JSR PC,RDSTR	;READ A STRING
	BEQ MAIL3	;NO CHARACTERS TYPED
	MOV @S,B	;POINTER TO STRING
	JSR PC,.LOADB	;FIRST CHARACTER
	CMP #'.,B	;IS IT A PERIOD?
	BEQ MAIL1	;YES (NO MORE INPUT)
	JSR PC,..FILP
	BR MAIL2
MAIL1:	SPOP PRMTCH	;GET BACK OLD PRMTCH ("?")
	MOV #.WRTEC,PCHR
	SPOPS A
	PRTXTC ^/------/
	MOV #TYO,PCHR
	JMP .WRTCL
MAIL3:	BR MAIL2	;BREAK CODING USED TO BE HERE
.ENDC

.IFNZ UNIX
READPT:	ERROR+TGD		;READ FROM PAPER TAPE DEVICE (SOMEDAY)
.IFF
READPT:	JSR PC,SETCH0
	JSR PC,FILCHK
	TST D		;ZERO ARGS?
	BEQ READP1	;JUST READ INTO WORKSPACE
	CMP #1,D	;EXACTLY 1?
	BEQ 1$		;YUP
	ERROR+WNA
1$:	JSR PC,..OPNW	;OPEN FILE FOR OUTPUT
	JSR PC,PTRCRT	;TRY TO CREATE A PTR
	MOV F,TMPCP	;SAVE IN THE TEMP CAP
READP3:	SAVE TMPCP
	.BYTI		;READ FROM PT
	BEQ READP2	;DONE
	REST D		;GET THE CHAR WE READ
	JSR PC,.WRTEC	;WRITE TO FILE
	BR READP3

READP2:	REST A		;FLUSH CAP
	JSR PC,DELTMP
	JSR PC,.WRTCL	;CLOSE FILE
	SEZ
	RTS PC	

READP1:	JSR PC,PTRCRT	;GET PAPER TAPE
	JSR PC,FLSCUR
	MOV F,@CURCPP
	MOV #.PREAD,GCHR
	BR .READ9

.PREAD:	SAVE @CURCPP
	.BYTI
	BNE 1$
	MOV #TYI,GCHR
	JSR PC,FLSCUR
	CLR @FILFLP
1$:	REST D
	BIC #177600,D		;FLUSH HIGH BIT
	RTS PC

PTRCRT:	SAVE <#-1,0,#.TRCAP*400>	;CREATE TAPE READER
	.INVOK		;TRY TO GET
	BNE 1$		;READ INTO WORKSPACE
	ERROR+DIU
1$:	REST F
	RTS PC
.ENDC

.READ:	JSR PC,SETCH0
	JSR PC,.READF			;OPEN THE FILE FOR READING
.READ1:	MOV #.READCH,GCHR		;WHERE TO GET THE CHARACTERS
.READ9:	MOV PC,REDFLG			;SAY WE ARE READING
	SAVE TOPRNM			;SAVE POINTER TO PROCEDURE BEING DEFINED
	BEQ 1$				;BRANCH IF THERE WAS NONE
	JSR PC,END			;FLUSH DEFINING PROCEDURE TEMPORARILY
1$:	PUSHS ILINEL			;SAVE THE ILINE FOR LATER
	JSR PC,SAVEVL			;SAVE EVAL
	PUSH #0				;THE NUMBER OF ARGUMENTS
	JSR PC,SAVPPS			;SAVE THE PDL POINTERS
	BIS #DORF,FLAGS			;SAY THIS IS A READ FRAME
	BIS #1,CPDLP			;SAY IT IS A PROCEDURE TYPE PUSH
RMLOOP:	CMP #TYI,GCHR			;ARE WE AT EOF?
	BEQ RMLOO1			;YES, FINISH UP
	JSR PC,SETCH0			;MAKE SURE WE READ FROM PROPER FILE
	JSR PC,RDSTR			;PUSH A STRING ONTO THE STACK
	BEQ RMLOO2			;TRY AGAIN
	JSR PC,MREAD1			;READ IT, AND PUT INTO THE COMMAND BUFFER
	BEQ RMLOO2			;NO TOKENS, CHECK FOR BREAK
	JSR PC,EVLINE			;EVALUATE THE LINE
	BNE RMLOOP			;NO OUTPUT, JUST CONTINUE
	ERROR+WDW			;DONT SAY WHAT TO DO WITH
RMLOO1:	TST TOPRNM			;DONE, DEFINING A PROCEDURE?
	BEQ 1$				;NO, DONT WORRY ABOUT IT
	JSR PC,END			;FINISH ITS DEFINITION
1$:	MOV #2$,DOFRET			;DITTO
	JMP POPVAR			;POP OFF THE READ FRAME
2$:	REST B				;GET BACK OLD TOPRNM
	BEQ 3$				;NO PROCDEURE?
	JSR PC,EDIT2			;REENTER PROCEDURE DEFINITION MODE
3$:	SEZ
	RTS PC
RMLOO2:	TST RBRKF			;BREAK?
	BNE 1$				;YES
	CMP #TYI,GCHR			;STILL INPUTTING FROM FILE?
	BEQ RMLOO1			;NO, FINISH UP
	BR RMLOOP			;GO BACK FOR MORE
1$:	ERROR+BRK

DELALC:	JSR PC,FLSCUR
	JMP DELTMP
.IFNZ LSI
UNMOUN:	JSR PC,G1NARG
	CMP #NDISKS,B
	BHI 1$
	ERROR+BDD
1$:	MOV #CURCAP,A
	MOV #NCHNS,F
2$:	BIT #FILNDK,FILFLG-CURCAP(A)	;IS THIS A NON-DISK CHANNEL?
	BNE 3$
	JSR PC,CMPDKN	;IS THIS CHANNEL OPEN ON THE DISK BEING UNMOUNTED?
	BNE 3$
STLANC
ENGINS <	PRTXT ^/Channel />
ENDENG
FRINS <	PRTXT ^/Le canal />
ENDLAN
	SUB #CURCAP,A
	ASR A
	JSR PC,PRDN
STLANC
ENGINS <	PRTXT ^/ is still open. Close it before unmounting./>
ENDENG
FRINS <		PRTXT ^/ est encore ouvert! Fermer le fichier avant de demonte./>
ENDLAN
	PRCR			
	ERROR+BDD
3$:	TST (A)+
	SOB F,2$
	ASL B		;GET DISK NUMBER
	MOV ROTCPS(B),A
	JSR PC,DELCAP
	MOV ROTCPS(B),F
	CLR ROTCPS(B)
	CMP F,DEFROT
	BNE 4$
	CLR DEFROT
4$:	MOV #DEFCAP,A
	ASR B
	JSR PC,DELCDK	;DETE CAP IF ON DISK(B)
	BNE 9$		;WASN'T
	CLR PATH	;NO LONGER ANY VALID PATH
9$:	SEZ
	RTS PC

DELCDK:	JSR PC,CMPDKN	;COMPARE B WITH DISK NUMBER OF CAP (A)
	BNE 1$
	JSR PC,DELCPC	;DELETE AND CLEAR
	SEZ
1$:	RTS PC

CMPDKN:	TST (A)
	BEQ 1$
	SAVE <,,(A)>
	BIS #.FADI,(P)
	$INVOK
	TST (P)+	;FREE BLOCK COUNT
	CMP B,(P)+	;DISK NUMBER
	RTS PC
1$:	CLZ
	RTS PC
.ENDC

DELCPC:	SAVE A
	MOV (A),A
	JSR PC,DELCAP
	REST A
	CLR (A)
	RTS PC

.IFNZ FILDSK
PRFN.R:	MOV #NAME,A
	JMP PRAS

GDE.R:
.IFZ UNIX
	.GERRW		;GET NEWEST ERROR WORD
	BEQ 1$
	REST <,DSKERW>
1$:
.IIF NZ ENG,	MOV #ENGDER,A
.IIF NZ FR,	MOV #FRDER,A
2$:	TSTB (A)+
	BEQ 3$		;END OF THE LINE
	CMPB DSKERW,-1(A)	;IS THIS OUR THING?
	BEQ 3$		;YUP
5$:	TSTB (A)+	;SEARCH FOR ZERO
	BNE 5$
	BR 2$
3$:	JMP PRAS	;PRINT THE STRING
.IFF
	MOV errno,A		;EXTERNAL VAR PROVIDED BY UNIX
	CMP A,sys_nerr		;NUMBER OF KNOWN ERRORS
	BGE 1$			;JUMP IF UNKNOWN
	ASL A			;MAKE INDEX INTO WORD VECTOR
	MOV sys_errlist(A),A	;GET POINTER TO TEXT STRING
	JMP PRAS
1$:	PRTXT ^/Unknown UNIX error!/
	RTS PC
.ENDC


.WRITE:	JSR PC,SETCH0
	JSR PC,..OPNW
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	SEZ
	RTS PC


.OPENR:	JSR PC,CHNSE1
.READF:	JSR PC,OPENR
	BNE 1$
	ERROR+FNF
1$:	SEZ
	RTS PC

OPENR:
.IFNZ UNIX
	JSR PC,SETNM
.IFF
	JSR PC,DSET
	JSR PC,NNFNGT
.ENDC

FREADR:
.IFZ UNIX
	JSR F,NAMMUT
	BEQ FREAD1
	JSR PC,DIRCHK		;FILE OR DIRECTORY?
	BEQ FREAD2		;FILE
	TST CHAN		;DIRETORY CAN ONLY BE OPENED ON CHANNEL ZERO
	BEQ 1$
	JSR PC,FLSCUR
	ERROR+IFN
1$:	MOV #FILDIR!FILRED,@FILFLP	;DIRECTORY
	MOV PC,DIRFLG		;THIS FLAG IS NONZERO TILL DBUF HAS GOTTEN THE END OF THE DIR
	CLR DIRIGC		;NO BYTES
	BR FREAD3
.IFF
	SYS OPEN
	#NAME
	0
	BCC 1$
	ERROR+GDE
1$:	MOV CHAN,B
	ASL B
	MOV A,.FLDSC(B)
.ENDC
FREAD2:	MOV #FILRED,@FILFLP
.IFZ UNIX
FREAD3:	TST CHAN
	BNE FREAD4
	CLR BCHNG
	MOV #DBUF,DBUFP
	MOV #DBUF,DBDEND
	CLR DBUFST
	CLR DBUFST+2		;SET UP INITIAL BUFFER
.ENDC
FREAD4:	CLZ
	RTS PC
.IFZ UNIX
FREAD1:	JSR PC,FLSCUR
	ADD #6,P
	SEZ
	RTS PC
.ENDC

.READC:	BIT #FILRED,@FILFLP	;IS ANYTHING OPEN FOR READING ON THIS CHANNEL?
	BEQ 2$			;NO
.IFNZ UNIX
	MOV CHAN,D
	ASL D
	MOV .FLDSC(D),A
	SYS READ
	#RDBYTE
	#1
	TST A
	BEQ 4$
	BGE 9$
	ERROR+GDE
9$	MOVB RDBYTE,D
	RTS PC
.IFF
	TST CHAN		;BUFFERED CHANNEL?
	BNE 3$			;NO
	CMP DBUFP,DBDEND	;HAVE WE REACHED THE END OF THE BUFFER
	BNE 1$			;GET A NEW CHAR
	JSR PC,NEWBLK
	BNE .READC		;GOT SOME CHARS
2$:	CLR REDFLG		;NO LONGER READING
.ENDC
4$:	JSR PC,.REDCL		;CLOSE THE FILE FOR READING
	MOV #EOFCHR,D
	RTS PC

.IFZ UNIX
1$:	MOVB @DBUFP,D
	INC DBUFP
	RTS PC

3$:	SAVE <@CURCPP>
	.BYTI
	BEQ 5$			;CLOSE THE FILE AT EOF
	REST D
	RTS PC
5$:	TST (P)+		;POP OFF THE CAPABILITY
	BR 4$			;AND FAIL GRACELESSLY

NEWBLK:	BIT #FILDIR,@FILFLP	;IS IT A DIRECTORY?
	BEQ 1$			;NO
	TST DIRFLG		;DONE WITH THE DIRECTORY?
	BEQ 2$			;YES, DONE
	JSR F,ACSAV		;SAVE AC'S FOR DIRECTORY
	JSR PC,DRBLKI
	JSR F,ACRES
	BR 3$
1$:	JSR PC,FLUSBF		;FLUSH THIS BUFFER
	BNE 3$			;GOT A NEW ONE, GO BACK FOR CHARACTERS
2$:	SEZ
	RTS PC
3$:	CLZ
	RTS PC

FLUSBF:	JSR PC,WRTBUF
REDBLK:	MOV #DBUF,DBUFP
	SAVE <,,@CURCPP>	;READ THE ACCESS POINTER
	BIS #.FARP,(P)		;READ THE POINTER
	$INVOK
	REST <DBUFST,DBUFST+2>
	SAVE <#DBUF,#-DBUFL,@CURCPP>
	.BLKI
	BNE 1$		;GOT A FULL BUFFER
	SAVE A
	MOV #.ERPEF,A		;ATTEMPT TO READ PAST EOF IS EXPECTED
	JSR PC,DERCHK		;ANY OTHER ERROR IS BAD
	REST A
	MOV 4(P),DBDEND		;GET POINTER TO THE END OF THE DATA
	ADD #6,P		;POP OFF THE CALL
	CMP DBDEND,#DBUF	;GET ANYTHING
	BNE 2$			;GOT SOMETHING
	SEZ			;EOF
	RTS PC
1$:	MOV #DBUF+DBUFL,DBDEND	;SET UP POINTER TO THE END OF THE DATA
2$:	RTS PC

WRTBUF:	SAVE D
	TST BCHNG		;BUFFER BEEN MODIFIED?
	BEQ 1$			;NOPE
	SAVE <DBUFST+2,DBUFST,@CURCPP>	;SET POINTER TO START OF BUFFER
	BIS #.FASP,(P)		;SET THE POINTER
	$INVOK
	MOV #DBUF,D		;GET POINTER TO THE LAST ACCURATE BYTE
	SUB DBDEND,D		;GET THE NEGATIVE BYTE COUNT
	SAVE <#DBUF,D,@CURCPP>
	.BLKO			;OUTPUT IT
	BNE 1$			;DID IT
	REST D
	JMP .WRTDF		;DISK FULL
1$:	REST D
	CLR BCHNG		;BUFFER HASN'T CHANGED
	RTS PC

				;THIS ENTIRE PAGE IS IFZ UNIZ
				;THIS GETS PUT IN PCHR WHEN .POI RUNS AS COROUTINE OF .FILER
DIRHAC:	DEC DIRIGN		;SHOULD WE IGNORE THIS CHARACTER?
	BGE 2$			;YUP
	CMP DBUFP,#DBUF+DBUFL	;END OF BUFFER?
	BHIS DRBLK1
	MOVB D,@DBUFP		;MOVE CHARACTER INTO DBUF
	INC DBUFP		;UPDATE POINTER
	INC DBDEND		;AND VALID BYTE POINTER
2$:	RTS PC

DRBLKI:	MOV #DBUF,DBDEND	;NO VALID BYTES YES
	MOV #DBUF,DBUFP		;AND POINTER
	MOV CURCPP,DIRCAP	;WE WANT .POI TO USE CURCAP, NOT TMPCP
	SAVE PCHR		;THESE NEED TO BE DIFFERENT FOR OUR COROUTINE
	MOV #DIRHAC,PCHR	;PCHR SHOULD READ INTO THE BUFFER, NOT PRINT OUT
	MOV P,DIRIGP
	MOV DIRIGC,DIRIGN
	CLR B			;TO DO POI RATHER THAN POTREE
	JSR PC,SETCH0		;SINCE WE WANT TO USE THE BUFFER
	JSR PC,..POI
	CLR DIRFLG
;NON-LOCAL RETURN FROM DIRHAC ENTERS HERE
DRBLK1:	MOV DIRIGP,P
	MOV #DBUF,DBUFP
	ADD #DBUFL,DIRIGC
	REST PCHR	;THESE SHOULD BE NORMAL WHEN CO-RTN NOT RUNNING
	MOV #TMPCP,DIRCAP	;THIS GOES BACK TO NORMAL TOO
	RTS PC
.ENDC				;END IFZ UNIX

.OPENM:	JSR PC,CHNSE1
	JSR PC,.OPNAX		;OPEN APPEND THE FILE
	BIS #FILRED,@FILFLP	;AND GIVE HIM READ ACCESS ALSO
	SEZ
	RTS PC

.OPENA:	JSR PC,CHNSE1
.OPNAX:	JSR PC,DSET		;SETS DIRECTORY
.OPNA3:	JSR PC,NNFNGT		;SET FILE NAME
	JSR F,NAMMUT
	BEQ .OPNA1
	JSR PC,DIRCHK		;DO WE HAVE A FILE OR A DIRECTORY?
	BEQ .OPNA2		;IF FILE, PROCEED
	JSR PC,FLSCUR		;IF DIRECTORY, FLUSH THE CAPABILITY
	ERROR+FNF		;AND COMPLAIN
.OPNA1:	CLRB 1(P)		;FLUSH OLD FUNCTION
	BIS #.FAAD,(P)		;TRY TO MAKE A NEW FILE
	.INVOK
	BNE .OPNA2
	ERROR+GDE
.OPNA2:	CMP -(P),-(P)		;DUMMY
	SAVE <@CURCPP>
	BIS #.FARE,(P)
	$INVOK			;READ THE END OF FILE
	TST CHAN		;CHANNEL ZERO?
	BNE 1$			;NO, DON'T DO THIS STUFF
	JSR PC,FREAD3		;CLEAR MISC STUFF
	MOV (P),DBUFST		;STORE AWAY THE BUFFER START
	MOV 2(P),DBUFST+2
1$:	SAVE <@CURCPP>
	BIS #.FASP,(P)		;SET THE POINTER TO THE END OF FILE
	$INVOK
	MOV #FILWRT,@FILFLP	;SET OPEN FILE FLAG FOR WRITE
	SEZ
	RTS PC
QUEST:	JSR PC,ONETYI
	SPUSH D			;SAVE IT
	JSR PC,.CRLF		;PRINT CR AND LINEFEED
	SPOP D			;GET CHARACTER
.IFNZ FR
	CMP #'O,D
	BEQ QUEST1
	CMP #'O+40,D
	BEQ QUEST1
.ENDC
.IFNZ ENG
	CMP #'Y,D		;IS IT "Y"?
	BEQ QUEST1
	CMP #'Y+40,D		;IS IT SMALL Y
.ENDC
QUEST1:	RTS PC

.OPENW:	JSR PC,CHNSE1		;FOR NOW
..OPNW:
.IFNZ UNIX
	JSR PC,SETNM
.IFF
	JSR PC,DSET		;SET DIRECTORY
	JSR PC,NNFNGT		;SET IT
.ENDC
.WRTF2:
.IFZ UNIX
	CLR -(P)
	SAVE <#NAME,@CURCPP>
	BNE 1$
	ERROR+NCD
1$:	BIS #.FAAD,(P)
	.INVOK			;TRY TO PUT IT INTO THE DIRECTORY
	BEQ .WRTF1
	JSR PC,FREAD3		;TO CLEAR MISC STUFF
.IFF
	SYS OPEN		;FIRST TRY TO LOOK IT UP
	#NAME
	0
	BCS 1$			;JUMP IF NO FILE FOUND
	SYS CLOSE		;FILE EXISTS, GIVE BACK DESCRIPTOR
	BR .WRTF1		;ASK USER ABOUT REPLACEMENT
1$:	SYS CREAT		;NO FILE, CREATE ONE
	#NAME
	#0777			;ANYONE MAY DO ANYTHING
	BCC 2$			;WINNING
	ERROR+GDE
2$:	MOV CHAN,B		;SAVE UNIX FILE DESCRIPTOR
	ASL B
	MOV A,.FLDSC(B)
.ENDC
	MOV #FILWRT,@FILFLP
.WRTF6:	SEZ
	RTS PC
.WRTF1:
.IFZ UNIX
	MOV #.EEAE,A	;ENTRY ALREADY EXISTS ERROR IS OK
	JSR PC,DERCHK		;SEE IF THE DIRECTORY FULL
.ENDC
STLANC
ENGINS	<PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/>
ENDENG
FRINS	<PRTXT ^/FICHIER DEJA EXISTANT. A DETRUIRE?/>
ENDLAN
	JSR PC,QUEST		;GET REPLY
	BEQ 1$			;OK, DELETE IT
	ERROR+GDE		;ENTRY ALREADY EXISTS
1$:
.IFZ UNIX
	MOV @CURCPP,A
	MOV A,TMPCP		;SO IT WILL BE DELETEED ON ERROR
	CLR @CURCPP
	JSR PC,COPCUR		;COPY OLD CURCAP INTO CURCAP
	CLRB 1(P)		;USE OLD STUFF ON STACK
	BIS #.FAMU,(P)		;BUT MUTATE INSTEAD
	.INVOK			;TRY TO GET TO OLD FILE
	BNE .+4
.WRTF9:	ERROR+GDE		;????
	SAVE <#0,#0,A>		;CABILITY TO FILE
	BIS #.FADL,(P)		;WANT TO DELETE
	.INVOK
	BEQ .WRTF9
	JSR PC,DELTMP		;FLUSH CAP TO FILE
	BR .WRTF2		;TRY AGAIN
.IFF
	SYS UNLINK		;TRY TO DELETE THE FILE
	#NAME
	BCC 3$			;JUMP IF OK
	ERROR+GDE
3$:	JMP .WRTF2		;OK, TRY AGAIN
.ENDC

.IFZ UNIX
DERCHK:	$GERRW			;READ THE ERROR WORD, SHOULD NEVER FAIL
	TST (P)+		;POP USELESS ERROR ADDRESS
	MOV (P),DSKERW		;SAVE DISK ERROR CODE
	CMP (P)+,A		;IS THIS THE PERMISSIBLE ERROR?
	BEQ 1$
	JSR PC,CLOSF
	ERROR+GDE
1$:	RTS PC
.ENDC

.WRTEC:	BIT #FILWRT,@FILFLP
	BNE 1$
	BPT
1$:
.IFZ UNIX
	TST CHAN		;ONLY CHANNEL ZERO IS BUFFERED
	BNE .WRTUB
	CMP DBUFP,#DBUF+DBUFL	;FINISHED THIS BUFFER?
	BNE 3$			;STILL STUFF LEFT
	JSR PC,FLUSBF		;GET THE NEXT BUFFER
3$:	MOV PC,BCHNG		;BUFFER CHANGED
	MOVB D,@DBUFP
	INC DBUFP
	CMP DBUFP,DBDEND	;HAVE WE WRITTEN A BYTE THAT HASN'T BEEN TOUCHED BEFORE?
	BLOS 2$			;NOPE
	MOV DBUFP,DBDEND	;UPDATE VALID DATA POINTER
2$:	RTS PC
.IFF
	MOV CHAN,A		;CHANNEL TO WRITE ONTO
	ASL A			;POINTER TO WORD
	MOV .FLDSC(A),A		;FILE DESCRIPTOR
	MOVB D,RDBYTE		;CREATE ONE-BYTE "BUFFER"
	SYS WRITE
	#RDBYTE
	1
	TST A			;-1 IF ERROR, 0 IF NO BYTES WRITTEN, 1 IF ONE WRITTEN
	BLE .WRTDF		;ANYTHING BUT 1 IS BAD
	RTS PC
.ENDC

.WRTDF:	MOV @CURCPE,A		;GET ERROR ROUTINE
	BEQ .WRDF1		;NONE
	JMP (A)
.WRDF1:	TST CHAN		;ONLY DELETE ON CHANNEL ZERO
	BNE 1$
	TST WRTFLG		;AND THEN, ONLY IF WRITING WORKSPACE
	BEQ 1$
.IFZ UNIX
	SAVE <,,@CURCPP>
	BIS #.FADL,(P)
	.INVOK
.ENDC
1$:	JSR PC,.CLSCH
	ERROR+GDE

.IFZ UNIX
.WRTUB:	SAVE <D,@CURCPP>
	.BYTO
	BEQ .WRTDF
	RTS PC
.ENDC

.REDCL:
.WRTCL:
.IFZ UNIX
	TST CHAN		;ONLY CHANNEL ZERO IS BUFFERED
	BNE .CLSCH
	JSR PC,WRTBUF		;WRITE OUT THE BUFFER IF NEEDED
.ENDC
.CLSCH:	JSR PC,FLSCUR
	SEZ
	RTS PC

FLSCUR:	SAVE A
.IFNZ UNIX
	MOV CHAN,A		;GET LOGO CHANNEL NUMBER
	ASL A			;MAKE WORD POINTER
	MOV .FLDSC(A),A		;GET UNIX FILE DESCRIPTOR
	SYS CLOSE		;CLOSE IT
.IFF
	MOV @CURCPP,A
	JSR PC,DELCAP
.ENDC
	REST A
	CLR @CURCPP
	CLR @FILFLP
	RTS PC

..FILP:	MOV #PRINT,A
	BR ..FIL2
.FILET:	MOV #TYPE,A
	BR .FILP2
.FILEP:	MOV #PRINT,A	;PRINT INTO THE FILE
.FILP2:	JSR PC,CHNSE1
..FIL2:	BIT #FILWRT,@FILFLP	;IS FILE OPEN FOR WRITE?
	BNE 1$		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
1$:	SPUSH PCHR
	MOV #.WRTEC,PCHR
	MOV #1,D	;ONE ARG FOR PRINT OR TYPE
	JSR PC,(A)	;PRINT OR TYPE THE CHARACTERS
.FILP1:	SPOP PCHR
	SEZ
	RTS PC

.FTYO:	JSR PC,CHNSE1
	BIT #FILWRT,@FILFLP	;IS FILE OPEN FOR WRITE?
	BNE 1$		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
1$:	JSR PC,G1NARG
	MOV B,D
	JSR PC,.WRTEC
	SEZ
	RTS PC

.FILEW:	JSR PC,CHNSE1
	BIT #FILRED,@FILFLP	;OPEN FOR READ?
	BNE 1$		;YES
	ERROR+NFO
1$:	JSR PC,G1NARG	;GET AN ARGUMENT
	TST B		;ANYTHING
	BGT .FILW2	;YES, AND POSITIVE, GOOD STUFF
	BEQ .FILW4	;AT LEAST IT IS 0 
	ERROR+WTA	;NEGATIVE IS USELESS
.FILW4:	SPUSHS #LSTR	;RETURN EMPTY WORD
.FILW1:	CLZ
	RTS PC
.FILW2:	JSR PC,BLSTI	;INIT THE LSTR
1$:	JSR PC,.READC	;GET A CHACTER
	BIT #FILRED,@FILFLP	;IS IT EOF?
	BEQ .FILW3	;YES, RETURN WHAT WE GOT
	JSR PC,BLST	;ADD IT
	SOB B,1$
.FILW3:	JSR PC,BLSTF	;FINISH IT
	TST TOPS	;DID WE PUT ANY CHARS IN?
	BEQ .FILW4	;NO RETURN THE EMPTY WORD
	SPUSHS TOPS
	CLR TOPS
	BR .FILW1	;AND RETURN

.FILER:	JSR PC,CHNSE0
	BIT #FILRED,@FILFLP	;IS FILE OPEN FOR READ?
	BNE 1$		;YES
	ERROR+NFO	;NO,INVALID FILE NAME
1$:	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	SPOP GCHR
	CLZ
	RTS PC

.FTYI:	JSR PC,CHNSE0
	BIT #FILRED,@FILFLP	;IS FILE OPEN FOR READ?
	BNE 1$		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
1$:	JSR PC,.READC
	MOV D,B
	BIC #-400,B
	JMP R1NARG

.CLOSF:	JSR PC,CHNSE0
.CLOS0:	MOV #TYI,GCHR	;RESET IT FOR TTY INPUT
	CLR REDFLG	;CLEAR READFLAG
	CLR WRTFLG	;CLEAR WRITE FLAG
CLOSF:	BIT #FILWRT,@FILFLP	;IS FILE OPEN FOR WRITE?
	BEQ 1$
	JMP .WRTCL
1$:	BIT #FILRED,@FILFLP	;IS IT OPEN FOR READ?
	BEQ 2$
	JMP .REDCL
2$:	RTS PC


.FILEO:	JSR PC,CHNSE0
	TST @FILFLP		;IS A FILE OPEN
	BEQ 1$			;NO
	JMP RTTRUE		;RETURN TRUE
1$:	JMP RTFALS		;RETURN FALSE


LOGIN:
.IFZ UNIX
	JSR PC,.USE		;GO DO A USE OF THE GIVEN ARGUMENT
.ENDC
				;THEN FALL IN TO READ THE INIT FILE IF ANY

RINIT:	JSR PC,SETCH0
.IFZ UNIX
	JSR PC,COPDEF
.ENDC
	MOV #NAME,A
.IFNZ UNIX
	MOV #"LO,(A)+		;UNDER UNIX, "INIT" IS TOO VAGUE
	MOV #"GO,(A)+
.ENDC
	MOV #"IN,(A)+
	MOV #"IT,(A)+
	CLR (A)
	JSR PC,FREADR		;TRY TO READ THE FILE
	BEQ RINIT1		;LOSE
	JSR PC,.READ1		;GO READ INTO LOGO
RINIT1:	RTS PC

.IFZ UNIX
;PAGENO = THE UPT SLOT WE CAN USE
;PGADD  = THE PAGE ADDRESS
;WE ALSO HAVE TO GET THE CAPABILITY
;BUFFER= THE ADDRESS OF A BUFFER
;POTREE AND POI ROUTINES

.POTREE:	MOV PC,B				;FLAG ALLOWS LISTING OF INFERIOR DIR'S.
	BR POI.1
.POI:	CLR B					;SUPRESSES LISTING OF INFERIOR DIR'S.
POI.1:	JSR PC,SETCHF
..POI:	CMP DIRCAP,CURCPP	;IF DIRCAP POINTS TO CURCAP, .POI IS BEING USED AS A
	BEQ POI.2	; A COROUTINE FOR .FILER, & WANTS THE OPEN CURCAP DIR TO STAY
	JSR PC,FILCHK	;FILE ALREADY OPNE?
	JSR PC,COPDEF
	MOV @CURCPP,TMPCP
	BNE 1$
	ERROR+NCD
1$:	CLR @CURCPP
POI.2:	CLR A					;RECURSION DEPTH COUNTER
	CMP -(P),-(P)
	SAVE <@DIRCAP>			;GET DISK DATA
	BIS #.FADI,(P)
	$INVOK
	REST <FREEBL,DSKNUM>
	MOV #1,TF7				;USED TO ACCUMULATE TOTAL BLOCKS, ALLOW FOR THIS DIR
	JSR PC,PODIR				;LIST IT
	MOV TF7,A
	JSR PC,PRDN
STLANC
ENGINS <	PRTXT ^\ blocks, \>
ENDENG
FRINS <	PRTXT ^\ blocs, \>
ENDLAN
	MOV FREEBL,A				;NUMBER OF FREE BLOCKS
	JSR PC,PRDN				;PRINT NUMBER OF FREE BLOCKS ON DISK
STLANC
ENGINS <	PRTXT ^\ free blocks on disk #\>
ENDENG
FRINS <	PRTXT ^\ blocs libres sur le disque #\>
ENDLAN
	MOV DSKNUM,A				;DISK NUMBER
	JSR PC,PRDN				;PRINT DISK NUMBER
	PRCR					;AND CAR-RET
DELTMP:	MOV TMPCP,A
	JSR PC,DELCAP
	CLR TMPCP
	RTS PC					;WE ARE DONE

FILCHK:	TST @FILFLP	;IS FILE OPEN?
	BEQ 1$		;NO
	ERROR+FAO
1$:	RTS PC

DIRCHK:	SAVE <#FILBLK,#10,@CURCPP>
	BIS #.FARI,(P)
	$INVOK		;FIND OUT IF WE'VE OPENED A FILE OR A DIRECTORY
	BIT #.FADIR,FILBLK+2	;WELL, WHICH?
	RTS PC

;STILL IFZ UNIX
;GIVEN DIRECTORY CAPABILITY, TREE FLAG AND LEVEL

PODIR:	CLR D					;NUMBER OF ENTRY BEING PROCESSED
PODIR0:
PODIR1:	JSR PC,POENTB				;SET ACCESS TO ZERO AND GET ENTRY
	SAVE ENTEOF				;SAVE EOF WORD ON THE STACK
	MOV D,E					;SKIP SOME ENTRIES
	BEQ PODI14
PODIR2:	CMP C,(P)				;CHECK EOF
	BLO PODI10
PODI12:	TST (P)+
	RTS PC					;NO MORE ENTRIES SO RETURN
PODI10:	JSR PC,POENTI
	SOB E,PODIR2				;SKIP ANOTHER ENTRY
	BR PODI14
PODIR3:	CMP C,(P)
	BHIS PODI12
	JSR PC,POENTI				;INPUT AN ENTRY
PODI14:	MOVB ENTRY+1,F				;GET TYPE BYTE
	BIC #177761,F				;GET TYPE FIELD
	SAVE C
	JMP @PODIRT(F)				;DISPATCH TO SERVICE ROUTINE

PODIRL:	BPT					;BUG LINKS NOT IMPLEMENTED
	BR PODIRP				;JUST SKIP THE ENTRY
PODIRS:	TST A					;ENTER HERE FOR SELF ENTRY
	BEQ PODIR7				;DON'T PRINT "I" AT TOP LEVEL
	MOV A,F					;LEVEL IS IN A
	SUB #2,F				;PRINT LEVEL-2 SPACES	
PODIR4:	BEQ PODIR6				;DON'T TRY TO PRINT ZERO SPACES
PODIR5:	JSR PC,PODIRB				;PRINT (F) BLANKS
PODIR6:	SAVE D
	MOV #'I,D
	JSR PC,@PCHR
	SPACE
	REST D					;INDICATES INFERIOR DIRECTORY
PODIR7:	MOV #-1,E
	JSR PC,PODIRI				;PRINT NAME,VERSION, AND SIZE
PODIRP:	INC D					;ENTER HERE FOR PARENT TYPE ENTRY
	REST C
	BR PODIR3				;DO THE NEXT ENTRY



;STILL IFZ UNIX
PODIRF:	MOV A,F					;ENTER HERE FOR FILES
	ADD #2,F				;NUMBER OF SPACES BEFORE NAME
	JSR PC,PODIRB				;PRINT THE BLANKS
	JSR PC,PODIRN
	BR PODIRP				;PRINT REST OF INFORMATION
PODIRD:	INC TF7					;ALLOW FOR BLOCK TAKEN BY THE DIR
	TST B					;ENTER HERE FOR DIRECTORY ENTRY
	BNE PODIR8
	MOV A,F					;NUMBER OF PRECEDING SPACES
	BR PODIR4				;SUPPRESS LISTING OF INFERIOR DIRECTORY
PODIR8:	MOV D,(P)
	SAVE <@DIRCAP>				;SAVE THE WORLD
	ADD #2,A				;INCREMENT THE LEVEL
	SAVE <#-1,#0,@DIRCAP>
	BIS #.CPYCP,(P)				;COPY THE CAP.
	.INVOK
	BNE 1$
	ERROR+GDE
1$:	MOV @DIRCAP,@CAPSP
	ADD #2,CAPSP
	SPOP @DIRCAP
	MOV #ENNAME,E				;PUT NAME FOR MUTATE INTO BUFFER
PODIR9:	TSTB (E)+
	BPL PODIR9				;MOVE THE NAME
	BICB #200,-1(E)				;CLEAR BIT IN LAST CHARACTER
	SAVE <A,PCHR>
	MOV TVERN,A
	BLT 1$
	MOVB #'#,(E)+
	MOV #POPRN,PCHR
	JSR PC,PRDN
1$:	REST <PCHR,A>
	CLRB (E)				;ZERO BYTE AT END OF ASCII STRING
	CLR -(P)
	SAVE <#ENNAME,@DIRCAP>
	BIS #.FAMU,(P)				;MUTATE THE NEW CAP.
	.INVOK
	BNE 2$
	ERROR+GDE
2$:	JSR PC,PODIR				;LIST INFERIOR
	CMP -(P),-(P)
	SAVE <@DIRCAP>
	BIS #.DELCP,(P)				;DELETE THE CAP.
	$INVOK
	SUB #2,CAPSP
	CLR @CAPSP
	REST <@DIRCAP,D>				;RESTORE WORLD
	SUB #2,A				;DECREMENT THE LEVEL
	INC D
	REST C
	JMP PODIR0				;CONTINUE LISTING THIS DIRECTORY

POPRN:	MOVB D,(E)+
	RTS PC


;PRINT (F) BLANKS ON THE OUTPUT DEVICE

PODIRB:	SAVE <D>
	MOV #' ,D				;PUT ASCII BLANK IN D
PODIB1:	JSR PC,@PCHR				;PRINT A CHARACTER
	SOB F,PODIB1
	REST <D>
	RTS PC

;STILL IFZ UNIX
POSET:	SAVE <C,#0,@DIRCAP>
	BIS #.FASP,(P)
	$INVOK
	RTS PC

POENTB:	CLR C					;SET TO BEGGINING OF DIR
	JSR PC,POSET
POENTI:	SAVE E
	SAVE <#ENTRY,#-4,@DIRCAP>
	.BLKI					;INPUT THE HEADER WORD AND VERN #
	BNE 2$
3$:	ERROR+GDE
2$:	MOV #TVERN+2,E				;WHERE THE REST OF THE THING GOES
	MOV ENTRY,F				;HEADER WORD
	BLT 1$					;SKIP IF EOF, TIME+ DATE EXIST
	MOV #ENNAME,E				;NOT DATE+TIME, REST OF ENTRY GOES HERE
	CLR DATE
1$:	INC F
	BIC #177401,F				;SIZE OF THIS ENTRY
	ADD F,C
	SAVE E
	SUB #4,F				;ALREADY READ THIS MUCH
	NEG F
	SAVE <F,@DIRCAP>
	SUB F,E					;GET THE END ADDRESS OF THE BUFFER
	SUB #ENTEND,E
	BLE 4$					;THERE IS ROOM FOR ALL OF IT
	ADD E,2(P)				;CAN ONLY READ PART OF IT IN
4$:	.BLKI					;INPUT THE HEADER WORD AND VERN #
	BEQ 3$					;DISK ERROR
	TST E					;DID WE READ IT ALL IN?
	BLE 5$					;YUP
	JSR PC,POSET
5$:	REST E
	RTS PC


;STILL IFZ UNIX
;PRINT OUT A LINE OF INFORMATION ABOUT FILE
;(C)= POINTS TO ENTRY TO PRINT
;SAVE REGISTERS A,B,D

PODIRN:	MOV ENTEOF,F
	ADD #1777,F				;ROUND UP TO BLOCK BOUNDARY
	CLR E					;CLEAR HIGH PART
	ASHC #3,E
	ADD ENTEFH,E				;PAGE NUMBER
	ASHC #3,E				;NOW LEGNTH IN BLOCKS
PODIRI:	SAVE <A,D,E>			;SAVE LEGNTH AND VERSION NUMBER
	MOV #ENNAME,E
2$:	MOVB (E),D
	BIC #177600,D				;CLEAR TOP BIT OF BYTE
	CMPB #'#,D
	BEQ 8$
	CMPB #'",D
	BEQ 8$
	CMPB #'>,D
	BEQ 8$
	CMPB #'<,D
	BNE 9$
8$:	MOV #'",D
	JSR PC,@PCHR
	MOVB (E),D
9$:	JSR PC,@PCHR				;PRINT A CHARACTER
	TSTB (E)+				;LAST BYTE HAS 200 BIT SET
	BPL 2$
	MOV TVERN,A
	BLT 3$				;NO VERSION NUMBER
	MOV #'#,D
	JSR PC,@PCHR
	JSR PC,PRDN				;PRINT THE VERSION NUMBER
3$:	REST <A>				;PRINT THE BLOCK LEGNTH
	BLT 1$
	SPACE
	SPACE
	ADD A,TF7				;ACCUMULATE TOTAL
	JSR PC,PRDN
1$:	JSR PC,PRDAT
	JSR PC,.CRLF
	REST <D,A>
	RTS PC					;DONE WITH THIS ENTRY

;STILL IFZ UNIX
;PRDAT PRINTS DATE & TIME, IF ANY
PRDAT:	JSR F,ACSAV				;SAVE ALL REGISTERS  
	MOV #11,D				;TAB
	JSR PC,@PCHR
	MOV DATE,E				;PUT DATE IN E 
	BEQ 5$					;IF NO DATE & TIME, RETURN
	CMP #-1,E				;SEE IF INITIALIZED
	BNE PRDAT1				;GO ON IF INITIALIZED
	SPACE
	MOV #'-,D				;PRINT " -" IF NOT
	JSR PC,@PCHR
5$:	JSR F,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;CONTROL INSTRUCTIONS FOR PRDAT2
PRDAT1:	MOV #DTTAB,B				;POINT TO BEG. OF DTTAB	
	JSR PC,PRDAT2				;PRINT DATE IN E
	MOV TIME, E				;PUT TIME IN E				
	JSR PC,PRDAT2				;PRINT TIME
	JSR F,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;TABLE DRIVEN ROUTINE TO PRINT DATE & TIME SEGMENT BY SEGMENT
	;ZTYPE & PRDN TAKE ARGUMENT IN A 
PRDAT2:	MOV #3,C				;C IS LOOP INDEX
PRDAT3:	MOV E,A					;PUT DATE OR TIME IN A
	ASH (B)+,A				;SHIFT QUANTITY TO LOW BYTE
	BIC (B)+,A				;ZAP ALL BUT RELEVANT BITS
	ASH (B)+,A				;MULT. FACTOR: 0 EXCEPT FOR SEC/2
	CMP #3,C				;FIRST TIME THRU LOOP?
	BEQ 1$				
	JSR PC,ZPRDN				;PRINT WITH LEADING 0 IF < 10
	BR 2$
1$:	JSR PC,PRDN				;PRINT WITHOUT LEADING 0 IF < 10	
2$:	MOV (B)+,A				;PICK UP DELIMITER CHARACTER
	MOV A,D					;PUT CHARACTER IN D
	JSR PC,@PCHR				;PRINT CHARACTER
	SOB C,PRDAT3				;DO NEXT SEGMENT
PRDAT4:	RTS PC
