FOO:	7,,(SIXBIT/  DSK/)
FLNM1:	0
FLNM2:	0
BAR:	.BIO,,(SIXBIT/  DSK/)
FLNMA:	0
FLNMB:	0
RETURN:	ASCII/:LOGOUT /
SDSKBK:	0	;LOCATION ON DISK OF HEADER WORD FOR CURRENT BLOCK.
DSKNOW:	0	;CURRENT LOCATION ON DISK.
STADDR:	0	;STARTING ADDR. IN CORE OF PRESENT DISK BLOCK.
STACK:	BLOCK 50
LST:	BLOCK 100	;BLOCKS OF 100 PDP11 WORDS ARE PACKED IN HERE
START:	.OPEN 1,[SIXBIT/  CLO:FOOBAR INPUT /	;INIT. INPUT FROM PDP11
	.VALUE
	.OPEN 2,[SIXBIT/  CLO:FOOBAR OUTPUT /	;INIT OUTPUT TO PDP11
	.VALUE
	.OPEN 3,FOO	;INIT. OUTPUT TO DISK
	.VALUE
	.OPEN 4,BAR	;INIT. READIN FROM DISK.
	.VALUE
	MOVEI 1,STACK-1	;SET UP R1 AS STACK POINTER
WAITDL:	.IOT 1,0	;FIRST CHAR INPUTTED ON PDP11
	ANDI 0,177	;TELETYPE IS EITHER L OR D,FOR LOAD PROGRAM OR
	CAIN 0,104	;DUMP PROGRAM.
	JRST DUMP11
	CAIN 0,114
	JRST LOADMD
	MOVEI 0,77
	.IOT 2,0
	JRST WAITDL
DUMP11:	JSR GTFLNM	;GET & PUT THE FIRST FILENAME IN FLNM1
	MOVEM 0,FLNM1
	JSR GTFLNM	;GET & PUT THE SECOND FILENAME IN FLNM2
	MOVEM 0,FLNM2
	JSR GETNUM	;GET & PUT THE STARTING ADDRESS IN R6
	MOVE 6,0
	JSR GETNUM	;GET & PUT THE ENDING ADDRESS IN R7
	MOVE 7,0
	MOVEI 0,141	;TELL PDP11 TO ENTER DUMP MODE
	.IOT 2,0
	SETZM 0,DSKNOW	;START DISK WRITING AT LOCATION 0.
	SETZM 0,DSKNOW	;HEADER WORD OF 1ST DISK BLOCK IN WORD 0.
	SETOM 0,STADDR	;INIT. START ADDR. AS -1 (IT WIL BE CHANGED).
	SETZ 3
	MOVE 0,6	;SEND THE PDP11 THE STARTING ADDRESS
	PUSHJ 1,SDWDDP
	MOVE 0,7	;SEND THE PDP11 THE ENDING ADDRESS
	PUSHJ 1,SDWDDP
NXTBLK:	.IOT 1,0	;GET ONE CHAR. FROM THE PDP11
	ANDI 0,177
	CAIE 0,3	;3 MEANS THE END OF TRANSMISSIONS
	JRST 0,NEWBLK
	.CLOSE 3
	.CLOSE 4
LOGOUT:	.VALUE RETURN
NEWBLK:	CAIE 0,1	;1 MEANS THE START OF A NEW BLOCK.
	JRST 0,.-5
	HRLI 5,2200	;SET UP R5 AS THE BYTE POINTER THAT WILL PACK
	HRRI 5,LST-1	;2 PDP11 WORDS INTO EACH PDP10 WORD STARTING
	PUSHJ 1,GT11DP	;AT LOCATION LST.GET THE 1ST WORD (-CNT)
	MOVE 4,0	;START OFF R4 AS CHECKSUKM.
	IDPB 0,5	;SAVE -COUNT IN LIST.
	TLZ 3,777777	;CLEAR LEFT HALF OF R3 IF IT ISN'T ALREADY CLEAR.
	PUSHJ 1,GT11DP	;GET THE STARTING ADDR. OF THIS BLOCK.
	IDPB 0,5	;STORE IT IN LST (RIGHT HALF)
	ADD 4,0	;ADD IT TO THE CHECKSUM.
	CAMGE 3,0	;IF START OF NEW BLOCK IS > WHERE WE LEFT OFF,THERE
	PUSHJ 1,DSKBPT	;IS A GROUP OF ZEROS IN BETWEEN.DSKBPT TAKES
	MOVE 3,LST	;CARE OF THIS BY ENDING CURRENT DISK BLOCK
			;AND STARTING ANOTHER.
PACKWD:	PUSHJ 1,GT11DP	;GET ONE DATA WORD FROM THE PDP11
	ADD 4,0		;ADD IT TO CHECKSUM
	IDPB 0,5	;PACK IT AWAY
	AOBJN 3,PACKWD
	PUSHJ 1,GT11DP	;GET THE PDP11'S CHECKSUM
	ANDI 4,177777	;CLEAR TOP HALF OF 10'S CHECKSUM SO WE CAN 
	CAME 0,4	;COMPARE THE TWO CHECKSUMS
	JRST 0,CKSMER
	HLLZ 5,LST
	ASH -1
	HRRI 5,LST
	.IOT 3,5	;AND SEND THE BLOCK TO THE DISK
	HLRZ 5,LST	;AGAIN,MOVE -COUNT INTO R5.
	ASH -1	;DIVIDE COUNT BY 2.
	MOVNS 5,5	;GET +COUNT/2.
	ADDM 5,DSKNOW	;KEEP DSKNOW UP TO DATE (POINTS AT NEXT WORD ON DISK
	JRST 0,NXTBLK
CKSMER:	MOVEI 0,141	;SEND 141 (NOT ACKNOWLEDGE) TO THE PDP11.
	.IOT 2,0
	HRRZ 0,LST	;SEND PDP11 THE STARTING ADDRESS OF THE BLOCK THAT
	PUSHJ 1,SDWDDP	;GOT MUFFED.
	JRST 0,NXTBLK

DSKBPT:	.ACCESS 3,SDSKBK	;MOVE DISK POINTER TO HEADER WORD OF
	MOVE 12,SDSKBK	;CURRENT BLOCK.PUT THIS NUMBER IN R12.
	CAMN 12,DSKNOW	;IF NOTHING WRITTEN ON DISK YET,BR. TO NULBLK.
	JRST NULBLK	;NULBLK JUST MOVES DSKNOW UP 1 & LEAVES ROOM FOR
	SUB 3,STADDR	;GET #OF WORDS IN THIS DISK BLOCK.
	MOVNM 3,12	;PUT -BLOCK LENGTH IN R12.
	MOVSS 12,12	;PUT -COUNT IN LEFT HALF OF R12.
	HRR 12,STADDR	;START. ADDRESS OF BLOCK IN RIGHT HALF OF R12.
	HRROI 13,11	;SET UP R13 AS 1 WORD POINTER IN .IOT INST.
	.IOT 3,13	;SEND HEADER WORD TO THE DISK.
NULBLK:	AOS DSKNOW	;NEXT BLOCK DATA STARTS IN CURR. LOC.+1
	.ACCESS 3,DSKNOW	;MOVE BACK DISK POINTER TO START OF NEW BLOCK.
	MOVEM 0,STADDR	;PUT START ADDR. OF NEW CORE BLOCK IN STADDR.
	POPJ 1,0

LOADMD:	PUSHJ 1,GTFLNM	;GET NAME OF FILE TO BE READ.
	MOVEM 0,FLNMA
	PUSHJ 1,GTFLNM
	MOVEM 0,FLNMB
	MOVEI 0,142
	.IOT 2,0	;TELL PDP11 TO ENTER LOAD MODE.
FIND1:	HRROI 0,1
	.IOT 4,0	;GET 1 WORD FROM DISK &SEE IF IT IS 1(BLOCK START).
	CAIE 2,1
	JRST FIND1	;LOOP UNTIL FIND A ONE.
	HRLI 0,-5	;GET READY TO READ IN NEXT 5 WORDS(BYTES)FROM DISK
	HRRI 0,LST-1	;PUT THEM INTO LST.
	.IOT 4,0	;AND READ THEM IN.
	MOVE 7,LST+2	;PUT HIGH ORDER BYTE OF COUNT IN R7
	ASH 7,10	;SHIFT IT UP.
	ADD 7,LST+1	;ADD IN LOW ORDER BYTE.
	SUBI 7,6	;SUBTRACT 6 FROM BYTE COUNT TO MAKE IT RIGHT.
	JUMPE 7,ALLDON	;IF NO DATA IN BLOCK,WHOLE FILE HAS BEEN READ.
	MOVE 6,LST+4	;PUT HIGH ORDER BYTE OF ST. ADDR. IN R6.
	ASH 6,10	;SHIFT IT UP.
	ADD 6,LST+2	;ADD LOW ORDER BYTE. R6=START ADDRESS.
	SUBM 6,7	;R7=END ADDRESS +1.
NBLK:	MOVE 10,6
	SUBM 7,10
	JUMPLE 10,FIND1	;IF -TEMP COUNT <0,READ NEXT DISK BLOCK.
	CAILE 10,200
	MOVEI 10,200	;IF MORE THAN 200 BYTES IN BLOCK, ONLY SEND 200.
	MOVNS 10,10
	MOVS 5,10	;R5 LEFT HOLDS -TEMP BLOCK COUNT.
	ADDI 5,LST-1
	.IOT 4,5	;READ IN UP TO 200 BYTES FROM DISK.
	MOVE 0,10	;PUT -TEMP COUNT IN R0.
	ASH 0,-1	;DIVIDE BY TWO TO GET -WORD COUNT IN THIS BLOCK.
	MOVE 4,0	;R4 WILL BE THE CHECKSUM.
	PUSHJ 1,SEND11	;SEND -COUNT TO PDP11.
	MOVE 0,6	;MOVE STARTING ADDRESS TO R0.
	ADD 4,0		;ADD IT TO CHECKSUM.
	PUSHJ 1,SEND11	;SEND IT TO PDP11.
	MOVS 5,10	;PUT -BLOCK COUNT IN R5 LEFT.
	ADDI 5,LST
SNXTWD:	MOVE 0,1(5)	;PUT HIGH ORDER BYTE IN R0 FIRST.
	AOBJP 5,SNXTWD	;INC. BYTE POINTER.
	ASH 0,10	;SHIFT IT LEFT.
	ADD 0,-1(5)	;ADD LOW ORDER BYTE.
	ADD 4,0		;ADD WORD TO CHECKSUM.
	PUSHJ 1,SEND11	;SEND THE PDP11 THIS DATA WORD.
LISTEN:	.LISTEN 0,	;IS PDP11 SAYING ANYTHING (ACK OR NAK)?
	JUMPE 0,INCR	;NO. GO ON.
BLKOK:	.IOT 1,0	;GET A CHAR. (ACK. OR NAK) FROM PDP11.
	CAIN 0,140	;140 MEANS CURRENT BLOCK WAS ACCEPTED OK.
	JRST NBLK	;GO ON TO NEXT BLOCK.
	PUSHJ 1,GET11L	;141 WAS SENT.(NAK).GET ADDRESS OF START BLOCK.
	MOVE 6,0	;PUT THE STARTING ADDR. IN R6
	JRST NBLK	;AND RESEND THE BLOCK.
INCR:	AOBJN 5,SNXTWD	;BRANCH BACK IF NOT THRU.
	MOVE 0,4
	ANDI 0,177777	;MASK OFF EVERYTHING PAST BIT 20 IN CHECKSUM.
	PUSHJ 1,SEND11	;AND SEND CHECKSUM TO PDP11.
	JRST BLKOK
ALLDON:	MOVEI 0,2
	.IOT 2,0	;SEND PDP11 2 (2 MEANS END).
	JRST LOGOUT
BOTH1S:	1000001
GET11L:	PUSH 1,2
	PUSH 1,3
GTWD:	PUSHJ 1,GET11D	;GET A WORD OF DATA.
	CAME 2,PAR	;PARITY CHECK.
	JRST BADPAR	;BAD PARITY.
	MOVEI 2,140
	.IOT 2,2	;SEND ACK. TO PDP11.
	POP 1,3
	POP 1,2
	POPJ 1,0
BADPAR:	MOVEI 2,141
	.IOT 2,2	;SEND NAK TO PDP11 & REINPUT WORD.
	JRST GTWD
GT11DP:	PUSH 1,2
	PUSH 1,3
	PUSHJ 1,GET11D
	POP 1,3
	CAME 2,PAR	;PARITY CHECK
	JRST PARERR
	POP 1,2
	POPJ 1,0
PARERR:	POP 1,2
	SUB 1,BOTH1S	;IF THERE WAS A SOBJ INSTRUCTION,I'D USE IT.
	JRST CKSMER
GET11D:	HRLZI 3,220600	;SET UP R3 AS THE BYTE POINTER.
NXTBYT:	.IOT 1,2	;INPUT A CHAR. FROM THE PDP11.
	SUBI 2,40	;SUBTRACT 40 THAT PDP11 ADDED.
	IDPB 2,3	;PACK THE BYTES INTO A WORD IN R0.
	TLNE 3,70000
	JRST 0,NXTBYT	;NO,CONTINUE.
	PUSHJ 1,PARITY	;DETERMINE OUR OWN PARITY.
	MOVE 2,0
	ANDI 0,177777
	ANDI 2,600000
	POPJ 1,0
SDWDDP:	PUSH 1,2
	PUSH 1,3
SDWDA:	PUSHJ 1,SEND11
QUERY:	.IOT 1,2	;WAIT FOR ACK. FROM PDP11.
	ANDI 2,177
	CAIE 2,140
	JRST 0,NAKTST	;NOT AN ACK.,TEST IF IT WAS A NAK.
	POP 1,3	;IT WAS AN ACK.,RETURN
	POP 1,2
	POPJ 1,0
NAKTST:	CAIE 2,141	;IS IT A NAK?
	JRST QUERY
	JRST 0,SDWDA
;
SEND11:	HRLZI 3,220600	;SET UP R3 AS THE I/O POINTER.
	ANDI 0,177777
	PUSHJ 1,PARITY
	XOR 0,PAR	;ADD THE PARITY TO THE WORD TO BE SENT OUT.
SDNXTB:	ILDB 2,3
	.IOT 2,2	;AND SEND THE CHAR. TO THE PDP11.
	TLNE 3,70000	;ALL DONE?
	JRST 0,SDNXTB	;NO.
	POPJ 1,0
ONES:	11111111
PAR:	0
PARITY:	PUSH 1,2
	PUSH 1,3
	PUSH 1,4
	SETZ 3
	HRLZI 4,201000	;SET UP R4 AS PTR TO 8 BIT BYTES.
BYTPAR:	ILDB 2,4	;GET 8 BITS OF DATA INTO R2
	IMULI 2,200401	;DEC'S KLUDGE THAT GETS PARITY OF AN 8 BIT BYTE.
	AND 2,ONES
	IMUL 2,ONES
	ASH 3,1	;R3 TEMP. HOLDS THE PARITY BITS.
	TLNE 2,100
	XORI 3,200000	;SET A PARITY BIT IN R3
	TLNE 4,770000	;DONE WITH BOTH BYTES?
	JRST 0,BYTPAR	;NO.
	MOVEM 3,PAR
	POP 1,4
	POP 1,3
	POP 1,2
	POPJ 1,0
;THESE ARE THE I/O ROUTINES THAT DIGEST EITHER 6 CHARACTER
;OCTAL NUMBERS OR 6 CHARACTER SIXBIT FILENAMES INPUTTED
;FROM THE PDP11'S TELETYPE.
SPSAVE:	0
GETN:	MOVE 1,SPSAVE	;RESTORE STACK POINTER
	JRST @.+1
GETNUM:	0		;THIS GETS A 6 CHAR. NUMBER.
	MOVEM 1,SPSAVE
	JSP 15,GET6+1	;PULL N THE CHARACTERS.
NXTDGT:	AOBJP 1,GETN
	MOVE 2,(1)	;RETREIVE A CHAR. FROM THE STACK.
	CAIL 2,60	;IS IT A VALID NUMBER?
	CAIL 2,70
	JRST 0,NOGOOD	;NO.
	ASH 0,3		;PACK THE CHARS. INTO NUMBER FORM IN R3.
	ANDI 2,7
	XOR 0,2
	JRST 0,NXTDGT
NOGOOD:	MOVEI 0,77	;SEND BACK A QUESTION MARK.
	JRST 0,GET6	;TRY AGAIN.
;
GTFL:	MOVE 1,SPSAVE	;RESTORE STACK POINTER.
	JRST @.+1
GTFLNM:	0
	MOVEM 1,SPSAVE
	JSP 15,GET6+1
NXTCHR:	AOBJP 1,GTFL	;RETURN IF ALL CHARS USED.
	MOVE 2,(1)	;GET A CHAR. THAT WAS PUSHED ONTO THE STACK.
	CAIGE 2,40	;CONTROL CHARS. ARE NO-NOS IN FILENAMES.
	JRST 0,CNTCHR
	XORI 2,40	;CHANGE CHAR. INTO SIXBIT.
	ANDI 2,77
	ASH 0,6		;PACK THE SIXBIT CHAR. INTO R0.
	XOR 0,2
	JRST 0,NXTCHR
CNTCHR:	MOVEI 0,77	;SEND BACK A QUESTION MARK....
	JRST 0,GET6	;AND TRY AGAIN.
SIXL:	6000000
DINGIT:	HRRZI 0,207	;GET READY TO SEND A "DING".
GET6:	.IOT 2,0	;AND SEND IT
	.IOT 1,0	;PULL INN A CHAR.
	ANDI 0,177
	CAIE 0,15	;SPACES,COMMAS,AND CRS. DELIMIT NUMBERS&FILENAMES.
	CAIN 0,54
	JRST 0,COMPIL
	CAIN 0,40
	JRST 0,COMPIL
	CAIN 0,177
	JRST 0,OOPS	;RUBOUT (OY VEY).
	CAML 1,SIXL	;MORE THAN 6 CHARS ALREADY INPUTTED?
	JRST 0,DINGIT	;YES. GUESS WHAT WE HAVE TO DO .
OK:	PUSH 1,0	;PUSH THE CHARACTER ONTO THE STACK.
	JRST 0,GET6
OOPS:	CAIG 1,777777	;"DING" IF TRY TO RUBOUT NON-EXISTANT CHARS.
	JRST 0,DINGIT
	POP 1,0		;IF IT'S A LEGAL RUBOUT,POP ONE CHAR. OFF THE STACK.
	JRST 0,GET6
COMPIL:	.IOT 2,0
	HRR 1,SPSAVE	;SET UP SP TO START OF DATA.
	TLC 1,777777	;GET -NUMBER OF DIGITS IN SP LEFT.
	SETZ 0,0
	JRST (15)

END START
