



Draft-0 Smalltalk: Dreams and Schemes, Chapter I



I

Personal Computing




How do you know when you have what you want?

Of course it is hard to know for certain.  Goals change with time and new
experiences.  But you can try to acquire sufficient leverage to add or modify
what you have as new goals are discovered.

In the educational community, leverage means learning how to find out something
new.  It is no longer possible to acquire all possible factual knowledge; it is
no longer possible to be taught in the context of formal schooling all the facts
needed outside that context.

In the business community, leverage means learning how to research new ideas and
how to predict the outcomes of applying these ideas without having to test all
of them in the real world.

In the social, recreational, or home communities, leverage means learning how to
gather and organize the constantly changing possibilities for using ones' time
and resources.

At home, at work, in formal studies, leverage means the power to act
effectively.  Such power is obtained from the incorporation of a broad range of
information into a particular decision.  One aspect of this is to access
information, to communicate it to oneself and to others, and to apply one idea,
a part of that information, to a variety of contexts.  Such contexts are the
decision making situations with which we deal each day.  Though abstract rather
than real, these contexts serve as learning situations.  The ability to explore
conjectures, to practice both the acquisition and evaluation of information,
potentially increases the leverage to deal with a quickly changing society.

It is the underlying assumption of this book that such accessibility and implied
maleability of information can be obtained through a computer-based system whose
content consists of tools for communication and modelling.  We name a system
that provides this leverage, a personal computer.

For the past several years, the Xerox Learning Research Group has been concerned
with human-to-computer communications, particularly in the context of portable
personal computers.  Our definition of portability is that you should be able to
carry something else too; the vision is that a person could carry the system
around and use it in the grass or at the beach, or other places.  The idea here
is not the aesthetics of being able to use something outside, because of course
we don't always do things outside.  The basic idea is that we want this resource
to be available always so that people can use it as their primary medium for
handling informational needs.

That is our goal.  This book traces the history of our efforts to obtain our
goal.  It is an incomplete history, written now in order to share our
discoveries, both succcesses and misdirections, at a time when others are
choosing to explore similar problems.



What is Personal Computing?

Both the word "person" and the word "computer" in "personal computing" must be
kept in mind at all times.  In particular, all of our designs for a personal
computing system have really started with the idea of a person sitting in front
of a video display screen, wanting to do something with the information
accessible via such a medium.  One of the first questions we asked ourselves is
what is the probability that we can specifically anticipate this unfamiliar
person's need for handling information?

We decided that we could not anticipate his need at all.

Complicating our inability to predict the precise activities to be carried out
on a personal computer is that we must regard most people as being experts at
what they already choose to do.  Indeed, almost anyone who might use the system
knows his own way of doing whatever it is that he does: a child is an expert at
doing what he does every day, such as drawing or constructing model airplanes,
and children are quite different from one another; teachers engage in work that
consists of transmitting a myriad of skills in as many different ways.  Most
adults are engaged in work that, whether they enjoy it or not, consists of
skills that have been built over thousands of hours.  So it was our judgment
that it would be a hopeless task to try and provide a set of simple tools that
would correctly anticipate people's needs in a way commensurate with their
expertise at carrying out their needs.

The conclusion we came to is that a system should be built that people
themselves can mold into the kinds of tools they require at a given time.  This
of course brings up what we think is 90% of the personal computer problem: It is
a communication problem between a person and a piece of hardware, specifically
the contents of that hardware--the software.

The computer is the greatest information amplifier that has ever been produced.
The experimental system we have presently is by no means the ultimate system,
neither the hardware nor the software.  We hope it is in the right direction.  A
thing that came to us as a big shock a couple of years ago, after we had been
enjoying some success, was to suddenly discover something that is really obvious
when you think about it; there is an enormous difference between programming and
designing.  It is an important distinction.  While programming is easy, just
like brick laying is easy, not everyone can design a house to be made from those
bricks.  Not everyone can design a house and, given a design, not everybody can
build one.  We believe this is one of the essential difficulties in making
personal computing a reality; most of the useful tools that a user wants require
complex designs.  Programming is by no means the most important or the most
useful interchange of having personal computing--there are other ways of using
it.  We feel though that the user should always have the opportunity to program.
Programming is, after all, the ultimate way of controlling a computer.  Even if
it is somebody else's text editor or information retrieval system, if you want
to change a picture in it, there should be a way for the personal computer to
allow you to do it.

Here are five properties of personal computing.  They are in the order of what
we can call distinctiveness.  Unfortunately, the first most distinctive thing
about personal computing is the enormous attention span of each user.  The great
uses of it in the next five to ten years may be only because it has a great
attention span.  It is the equivalent of seventy-six trombones: You don't
absolutely need them to do music, but boy is it fun to see them marching down
the street.

The second is the editing of everything: text, pictures, sound and models.  It
is the one process for which personal computers will find value far beyond paper
media.

Searching and editing are the two activities that users of personal computers
are always doing.  Users search for desired effects, ways to cause them, reasons
why they did not happen, and how to fix them.  This third property of personal
computing, searching, perhaps with the aid of multi-indexed information systems,
provides an elimination of distance by connection.  Looking at the computer as a
space, it is a space that is only topological, not metric.  In other words,
every part of the space is the same distance from every other part.  For
example, we are not constrained to the linear relationship of text on a display
screen.  Rather, we can organize the parts of the text in far more complex ways
than we are used to doing in books.  The tyranny of single-dimensional paper
organization of information is replaced by multi-dimensional relations.

Fourth, modelling and simulation are the primary substance of computers.  They
encompass the ultimate content in using the machine.  Modelling to capture
information, such as has been done for thousands of years in speech, hundreds of
thousands of years in text, for just a few centuries in mathematics and a few
decades on the computer, ever more dynamic and ever richer models than we can
manipulate; this is how we grasp our own universe.  We can't touch our
universe--our brain is the thing that is doing the thinking.  You can not touch
anything with your brain; you have to convert whatever happens to all sorts of
electro impulses.  Always dealing with the media--learning about the media and
learning what reactions happen to a single system within it--is the most
important content related area in computers.

Finally, the most subtle use and most subtle value in interactive computing is
the human implication.  Probably everyone has noticed how much a human can take
in using touch and sight and smell and hearing.  There is an enormous amount of
input bandwidth compared to what we have to communicate out with. This may be
part of human beings' fading to media.  We see all this wonderful new
information flooding in through all of our senses: we can hear a Bach fugue but
can only sing one line; we can see enormous distances, but our ability to paint
what we see is severely limited by our own physical attributes.  This is
probably why human beings invented symbol systems--to grasp far more than they
can communicate through the kinds of sounds they can make.  One of the
interesting things we have noticed is that when a user of one of our
experimental system wants to explain something to someone else, they go to the
machine.  Why go to a machine?  Well, perhaps because there is a model there
that, with a few simple commands or waves of ones' hand, can cause a whole
display to appear or to change, thus invoking bandwidth that is much closer to
what a person can see.  This is the computer acting as an amplifier of the
ability of humans to communicate with each other, a way of matching up the
inadequate output bandwidths that we were born with.

One of the principles we have used as a guide when thinking about personal
computing has to do with musical instruments. Nothing is more portable than a
flute or violin--take them anywhere and play them anywhere.  One thing to notice
about a flute or violin is that there is no lag from input to output.  Imagine
what it would be like to play something serious on the flute if there were a
two- or three-second lag.  This would be equivalent to a musician going to the
concert hall in the afternoon and playing a concert, and then returning in the
evening to hear what it might have sounded like.  Absurd.

And, there is another analogy to musical instruments which is very constructive:
By and large most musical instruments were invented as prosthetics, not to make
music per se, but to make up for perceived deficiencies in the human voice.
Hence they were used in order to make a lot of noise in a Roman theater or in a
cathedral.  Back in those days the musical instruments were worse than the
things they were replacing, except in one trivial thing: they were louder.  Over
a long period of time--one or two hundred years--there was alot of interaction
among composers, players and musical-instrument manufacturers.  Musical
instruments found a value system of their own so that today they are not
prosthetics, but amplifiers.  That is what we see as the destiny of personal
computers: amplifiers, not prosthetics.

The success of a personal computing system, then, lies in its ability to support
the information-related activities of its many possible users.  Such a system
must contain facilities which range from directly usable tools, such as text and
picture editors, to the ability to describe new tools.  And these facilities
must be learnable in various stages by users with a broad range of computing
expertise.

The problems faced by a new user parallel those of a person who has books all
over the house and wishes to have a bookcase.  He may see an ad for one, go to
the store, find a bookcase that is just right, and buy it.  Fortuitous and
satisfying.  Often, though, the bookcase is not quite right.  The buyer may
decide to get it anyway, refinish it, and adjust the shelves to fit.  If this is
not possible, the next level of strategy is to find a kit which has much of the
hard work already done yet still allows the builder some options.  If no kit is
available, many people would quit and go back to orange crates.  Our resolute
subject is brave enough to go to a lumber store to purchase materials and a
manual about sawing, fastening and other properties of wood.  In an extreme case
(for example, when a fancy veneer is desired), new materials must be constructed
and the amateur must subcontract the task to an expert or must become more of an
expert himself.

All of these situations will arise in a personal computing system; it must
contain facilities for meeting each difficulty, ranging from directly usable
parts, to "kits" and instructions, to raw materials and theoretical knowledge.
In order of greatest return for least amount of work, users must learn: to
characterize their current need, to browse for and recognize a facility that
possibly meets that need, to use it, to modify it, to fix it, to combine it with
other facilities into a kit, and to make a facility from scratch.

To summarize, our main goal is to develop and invent general media which can be
shaped by others into facilities useful to them.  We are particularly interested
in three aspects of this new metamedium:

o	First, how media are shaped into tools, such as the ones we describe in
the next section.

o	Second, the nature of descriptions and communication which makes
possible access to existing tools and models as well as the use and formulation
of kits.

o	And, third, we would like to learn how people may be taught
communication skills which enable them to shape their computer medium.

Ways to Use a Personal Computer

One of our initial research goals is to determine a basic set of tools for
editing and searching the information contained in a personal computing system.
The style of editing that is selected directs the design of the user interface
as well as the kinds of activities that the programming environment must
support.

Font Editing

Although our intent is not to duplicate paper, we are finding that it works like
paper.  There is this funny thing that happens when a new medium is invented.
The claim is that you have been given something more, but you wind up getting
something less.  There is something almost obscene about the idea of being able
to edit text on a computer in a way that you can't ever do on paper, and having
it printed out or appearing on a display screen as something that is unreadable
(whose contrast, resolution, or ease of viewing fail to capture that of paper).
There is more to the problem than just the display of text in a high quality
font.  Different fonts create different moods and cast an aura that influences
the subjective style of both writing and reading.  Our interests are to not dull
people's senses by giving them presentations that are distant from what their
own senses can take in.

Below is an example of a page set in a particular font; it is followed by
another example that is the same page set in another font.  The fonts should be
programmable in the personal computing system; the user at any time should be
able to create fonts simply by drawing them.  This is the first time, but not
the last, that we will use the term "programming" in such a general way.  We
prefer to think of any kind of control transaction with a computing system as
identical to a programming transaction.  In fact, we feel that the programming
language design is properly part of the design of the interface between the user
and the system.

------------------------------------------------------------------	---------------------------------------------------------------
Figure 1.1.  Insert a picture of the display screen	Figure 1.2 Insert a
picture of the same
with a page of text in timesroman10.	page of text in helvetica12.
-----------------------------------------------------------------	---------------------------------------------------------------



Here are a number of fonts which are contained in our experimental system.

----------------------------------------------------------------------------------------
Figure 1.3.  About six displays of various interesting fonts: handwriting, ita,
sanskrit, elvish, fingerspelling, smalltalk
---------------------------------------------------------------------------------------

Any character font can be described as a matrix of black and white dots.  Using
a pointing device, the user can draw in a character font of his own choosing.
He can then immediately view font changes within the context of text displayed
on the screen.  With our system's fine grain of display, the rough edges
disappear at normal viewing distance to produce high quality characters.

----------------------------------------------------------------------------------------
Figure 1.4.  Designing the font for the button box simulation: Create the horn;
Show the rest--uparrow, right arrow, penup, pendn, start to remember, stop
remember, do what you remember, forget, and numbers 1 through 10.
---------------------------------------------------------------------------------------

The malleability of this approach is illustrated below: this user has decided to
embellish some favorite nouns with their iconic referent.  A teacher of early
reading might like to help children form correspondences between words and
objects by having the visual representations interchange when pointed to by the
child; an audio output facility could provide the sound of the word as well.

----------------------------------------------------------------------------------------
Figure 1.5.  Telling a story with pictures (from PDM: a flower, a bee, and a
bear.
---------------------------------------------------------------------------------------

Text Editing

Every description or object in a personal computing system--such as the
character fonts described above--must be displayable and editable.  Text, both
sequential and structured, can be manipulated by combining pointing and a simple
"menu" of editing commands, thus allowing deletion, transposition and
structuring.  Although a little unglamorous to discuss, users do find themselves
editing text and pictures for about eighty percent of the time they spend using
a computing system.  The malleability possible through interactive editing is
illustrated by entering a little story about butterflies [or some such thing].

By pointing with the stylus to some position in the text and typing, text is
inserted.  Here we see first a clean page.  We point to the beginning and type
some text, making some typing errors along the way.

----------------------------------------------------------------------------------------
Figure 1.6.  Blank page; cursor and selection symbol; typing with inset view of
keyboard the text about butterflies.
---------------------------------------------------------------------------------------

The stylus can be used to "grab" characters.  It leaves a "trail" to show where
it has been, that is, which characters have been selected (here we are using a
box to indicate the trail).  We grab a part of the text that was incorrectly
typed, selecting it, and then type new characters on the keyboard.  The selected
text is easily replaced.

----------------------------------------------------------------------------------------
Figure 1.7.  Grabbing characters and replacing them, with inset view of the
pointing device.
---------------------------------------------------------------------------------------

Anything can be deleted.  Select the characters and then select the command
'delete' that appears in a list of editing commands, a menu, near the text.

----------------------------------------------------------------------------------------
Figure 1.8.  Grabbing characters and deleting them.
---------------------------------------------------------------------------------------

Deleted text is stored away and can be retrieved to be placed into a new
position on the page.

----------------------------------------------------------------------------------------
Figure 1.9.  Pasting the deleted text elsewhere.
---------------------------------------------------------------------------------------

Similarly, anything can be selected and copied.

----------------------------------------------------------------------------------------
Figure 1.10.  Copying text.
---------------------------------------------------------------------------------------

Copied text can be pasted into new positions.

----------------------------------------------------------------------------------------
Figure 1.11.  And pasting it in several places.
---------------------------------------------------------------------------------------

Text can be entered via the stylus as well.  Individual handprinted character
recognizers like the one we have been experimenting with have been around for a
number of years.  The handprinted word gets changed to the proper font
characters.  It can then be selected and inserted.

----------------------------------------------------------------------------------------
Figure 1.12.  Hand drawn characters for insertion.
---------------------------------------------------------------------------------------

Setting margins, justification of paragraphs, changing facing and fonts, are all
done by selecting the text and choosing the appropriate command displayed in a
menu next to the text area.

Graphics

The only way we felt that we could achieve flexability in the new graphics was
to design a mosiac display.  We felt that the display surface of a personal
computer would be a million-dot mosaic display of some kind.  Instead of
building graphics hardware to manipulate this mosaic display, we would build a
machine so that all of the graphics could be done entirely by software.  [extend
with human factors study, Cornsweet reference]

Here is a tool for drawing around with a thin line of black ink.  The message
here is that you should be free to play around and do the kind of doodling that
you can do on paper as well the very crystalline things normally associated with
computer graphics.

----------------------------------------------------------------------------------------
Figure 1.13.  A tool for drawing around with a thin line of black ink.
---------------------------------------------------------------------------------------

The sequence below shows a sketch being planned, scrubbed out, edited, and then
finished off to the user's pleasure.  The dots on the display are either black
or white, as are the dots in newspaper photos.  The subjective effect of grey
scale is caused by the eye fusing an area containing a mixture of small black
and white dots.

----------------------------------------------------------------------------------------
Figure 1.14.  A sketch of the LRG logo: ACK's little man.
---------------------------------------------------------------------------------------

The next set of pictures shows a palette of paint dots (toned patterns) and some
brushes.  A brush can be grabbed with the pointing device, dipped into a paint
pot, and then the half-tone can be swabbed on as a function of the size, shape
and velocity of the brush.  Brushes can be 0-dimensional (like a pencil point),
1-dimensional (like a hoe or rake), or 2-dimensional.  The set of pictures shows
a rather large rectangular brush after swabbing on some tone.  [or some such
sequence] Then a circular brush is grabbed.  The last pair of pictures shows a
flower-shaped brush used to give the effect of painting wallpaper; anything that
appears anywhere can be used, not just as a picture, but as a brush. [Use one of
flegal's tile designs instead] It can be stored away in a repertoire of brushes
for later use.

----------------------------------------------------------------------------------------
Figure 1.15.  Pictures showing the painting with halftone paint and brushes. Use
one of flegal's tile designs for final sequence.
---------------------------------------------------------------------------------------

Pictures are manipulable objects and may be stored in the same way as character
fonts and texts, and printed on hard copy.

Document Editing

A document is any object in the information system that has structure.  A
chapter of a book, such as the one you are presently reading, is a document;
this entire book is a document; an office memo is a document; a library catalog
entry card is a document; and a description of an algorithm in some programming
language is a document.  Primitively, a paragraph, a picture, a heading, and a
bar chart are each documents.  They can be grouped together to compose a page of
a report; the grouping is a document.

A document editor is a facility for creating, modifying, and composing documents
containing other documents.  Using this chapter as an example, a document
created using an editor may contain an image consisting of a mapping of black
and white dots (a bitmap, or with less jargon, a picture), text images
(paragraphs), and headings.  Each kind of image is idiomatic in the sense that
it is made up of particular parts that are added, deleted or formatted in a
particular fashion (like bits or text characters); each image therefore has its
own idiomatic editor such as those already portrayed for drawing or text
editing.

Below is a page from a document describing a "heading" idiom of a particular
document editor.

----------------------------------------------------------------------------------------
Figure 1.16.  A page from the document editor documentation showing textimage,
bordered textimage, heading, bitimages.
---------------------------------------------------------------------------------------

To edit the parts, simply point: pointing to text invokes a text editor;
pointing to a picture invokes a painting tool; pointing to a heading invokes an
editor that lets the user shift individual characters right, left, up, or down.

----------------------------------------------------------------------------------------
Figure 1.17.  Zoom in on a heading: shift the characters and change the font and
content.
---------------------------------------------------------------------------------------

The font or facing for the entire heading can be changed.  Text is changed
simply by typing on a keyboard as in the text editor previously described.

Controlling the Display of Information

A view is the manner in which a particular document is displayed on the video
screen or on paper or using some other device.  This book can be viewed in a
number of ways: ordered as written and displayed on the screen or on paper,
headings only (the table of contents), index only, a listing of special terms (a
kind of glossary), graphic images only, text images only, and so on.

Viewports are display frames within the larger display screen.  They enable the
user of a personal computing system to organize and edit documents viewed at
several levels of refinement.  Views of the same or different documents can be
displayed simultaneously.  Physically, viewports are rectangular areas of the
screen that provide user access to both a document and its editor.

Here is a view of someone's personal information display.

----------------------------------------------------------------------------------------
Figure 1.18.  Zoom out from the bitimage of the flegal's tile, made from the
user-brush of Figure 1.15, to see it as a frame with several less elaborate
others.  The distance should only hint at content.
---------------------------------------------------------------------------------------

Looking closer we see each of the kinds of images already mentioned.  The user
"enters" a viewport by placing a pointing device in the rectangular area.  The
system recognizes this request by displaying additional information related to
the editing of the viewed document.

----------------------------------------------------------------------------------------
Figure 1.19.  A closer view of Figure 1.18 to see some content.  Put the
pointing device in the viewport containing the fancy frame; the toolbox editor
is displayed.
---------------------------------------------------------------------------------------

Forms for Information Retrieval

So far, the personal computer has been discussed as an easily changeable file
memory for words and pictures.  A user's context can be arranged as a dictionary
of names and their definitions.  The names could label fields of a library
catalog card; the definitions would be the completed fields describing a book
name, author, publication date, and so on.  The names could be the names of
procedures in a programming language and the definitions their associated
algorithms; or the names could be references to pictures with the actual
drawings stored as the definitions.

The dictionary is, of course, a document; it is a way to store and retrieve
related information.  As we saw earlier, each kind of entry in the dictionary
could have its own editor.  And each entry may be related sequentially (as with
ordinary paper usage) or inverted with respect to properties (as in a
cross-indexed file system).  One application of using the inversion method is to
be able to automatically crossfile several thousand multifield records, say of a
library system.  One kind of library record could be one that is dynamically
maintained by the library users; the record for a book or reference material
would be annotated by the current readers, and updated and reread by previous
readers.  The annotation could be text, or a sketch, or a diagram.

----------------------------------------------------------------------------------------
Figure 1.20.  A Findit record view.
---------------------------------------------------------------------------------------

A document could be used as a formatting device for specifying information to be
retrieved.  The next figure shows a document whose view is like that of a
dictionary.  Only the template of the dictionary appears at first.  The user
fills in as much of the document as is known, including either the names of the
entries or the definitions.  The layout of the form can be like a conventional
catalog card, as shown, or be viewed more like a report whose parts' labels are
typically hidden.

----------------------------------------------------------------------------------------
Figure 1.21.  A sequence showing a Findit record being completed and search
requested.
---------------------------------------------------------------------------------------

Animation and Music

Animation, music, and programming can be thought of as different sensory views
of dynamic processes.  The structural similarities among them are apparent in a
personal computing system that provides a common framework for expressing these
ideas.

All of the systems are equally controllable by hand or by programming.  Thus,
drawing and painting can be done using a pointing device or in conjunction with
programs which draw straight lines or curves, fill in areas with tone, show
perspectives of three-dimensional models, and so on.  Any graphic expression can
be animated, either by reflecting a simulation (such as bouncing objects in free
space) or by showing an example (giving an "animator" program a sample trace or
a route to follow).

----------------------------------------------------------------------------------------
Figure 1.22.  An animation sequence.
---------------------------------------------------------------------------------------

Music is controlled in a completely analogous manner.  The personal computer can
act as a "super synthesizer" getting direction either from a keyboard or from a
"score" (a sequence of actions over time).  The keystrokes can be captured,
edited and played back.  Children can both learn to play and compose at the same
time because they do not have to spend several years becoming good enough
technically to play their own compositions.

Timbres are the fonts of musical expression as they contain the quality and mood
which different instruments bring to an orchestration.  They may be captured,
edited and used dynamically.

----------------------------------------------------------------------------------------
Figure 1.23.  Captured score; generation of a timbre.
---------------------------------------------------------------------------------------

Smalltalk Programming

Each of the example tools of the previous sections are taken from experimental
systems written in the Smalltalk programming language.  Smalltalk is a language
whose basis is that of communication itself.  Ideas like numbers, simulations
and drawings are gotten as extensions to the kernal language.  We figured the
safest way of not anticipating what people were going to do was to not try and
guess a fixed set of features for the system.  One of our main points is that
the power of a programming system is determined almost entirely by how well it
does in areas for which it does not have features.  We designed Smalltalk so
that the kernal really doesn't have any features except the ability to create
communicating descriptions.

We have actually designed and implemented several software systems.  Each come
under the generic name Smalltalk.  Each of these implementations will be
explored in this book.  For this chapter, however, Smalltalk's semantics has
been somewhat idealized and simplfied.

The traditional differences between interactive control of computer tools and
the programming of these tools have rarely been resolved in an interactive
system.  Yet, ever since JOSS in the early sixties, the only distinctions needed
between direct and indirect programming have been the amount and the kinds of
delay between specification and effect.  In designing a programming language, we
wish to limit the forms of specification, but not their range; we want to
crystallize a style of programming, not just arrive at a syntax for expressions.
Though we search for ways to make our personal computing system more abstractly
simple, we wish to teach users through examples and incremental changes.  In
this way, the user can gradually notice the uniformity of the system and begin
to rely on guesses derived from concrete experience.

If we think of a computer as an environment in which time, space, and structure
can be fashioned, and a programming language as a vehicle for describing and
building complex dynamic structures, then metaphors drawn from the most complex
systems we know, the biological cell, can be very helpful in guiding the
principles of the language we will use.

A biological cell is a structure with more on the inside than on the outside.
In fact, these organisms expend a considerable percentage of their energy and
activities in just maintaining the distinction between inside and outside.
Where almost all of a complex molecule's structure is exposed to the ravages of
any environment in which it is put, a cell only exposes a small part of its
structure: its cell membrane, a fabric specialized to keep all parts of the
environment, except those beneficial to the cell, away from the more delicate
structures inside.

The cell membrane also keeps the cell in.  Inside is a miniature sea, a
primordial soup which the cell keeps simmering to make more cells.  There are
recognizable parts within a cell.  Some, like granules and a host of organic and
inorganic molecules, appear to have a simple relation to the entirety.  Others,
like the mitochondrial chemical factories and genetic material, are so
intertwined into the life cycle of the organism that it is difficult to
fruitfully discuss their nature in isolation.

When a cell divides to produce a twin, the least important of its constituants,
the majority of its cytoplasm and membrane, is simply increased and shared.  Its
most important parts however, the nucleus and mitochondria, are copied as
exactly as nature will permit.  Thus, part of every kind of cell are closely
similar structures which link their destinies coupled with parts that are those
of individual cells alone.

The potential for differentiation within a fixed heritage is enormous.  Every
body-cell in human beings has the same ancestry, yet has let itself be
differentiated by chemical messengers to form a marvelous variety of specialized
tissues and organs to make up creatures which for the most part are blissfully
unaware of their inner majesty.

Now how does this relate to a programming language?

Stripped of their metaphysics, every Smalltalk language design has been
concerned with how to deal with information organized in the form of parts and
wholes, for example, dictionaries which relate part-names to their active
meanings.  The first step in the development of this model was to give each
dictionary-object a separate inside and outside.  Users of the object can deal
with a never changing virtual organization from the outside.  Programmers of the
object can, from the inside, change methods for carrying out its virtual
meanings at any time, as long as the external behavior stays the same.  The
distinction between inside and outside means that users must communicate with an
object to get it to do anything.  Direct absolute commands no longer are
possible; they are replaced by queries tendered in the form of messages.
Objects from the outside thus act quite like digital computers in a
communications network and are neither data-structures nor procedures.

Since there are many more objects in the universe than are contained in any one
dictionary (save the universal dictionary), every dictionary can be thought of
as a filter (or masking device) that selects some objects from the universe and
rejects most others.  The "insideness" and "outsideness" of a dictionary-object
is itself constructed by filtering: the outside is portrayed by a filter that
suppresses internal organization for a simpler external fiction.  Filtering
provides a mechanism for developing interfaces to the human user of a computing
system and to other objects in the system.  As we introduced earlier, because
every dictionary-object is ultimately dealt with as a picture on the display
screen, it simplifies matters to consider every object as inherently an image
with a variety of default and user-supplied ways to display itself for perusal
and editing.  In the next figure we see a complex object in process being viewed
by three objects: two are display viewports.  Each view of an object is
constructed by specifying a particular filter and method for displaying that
filter.  Edits passed through one view that change the state of the object must
be continuously reflected back through all the other views of the object.

----------------------------------------------------------------------------------------
Figure 1.24.  Multiple views of a musical score presented through different
viewports.
---------------------------------------------------------------------------------------

If entries in the internal representation of an object can refer to each other,
then a perfectly general systems network is possible.  We can think of an entry
as containing references to the name of the entry and its meaning.  The meaning
of an entry is thus an object which can be shared (that is, it can be contained
by other entries in other dictionary objects).  This parts-wholes semantics is
also used by the external representation of an object but, as mentioned, its
details may be completely different from the object's internal strategies.

Filtering is used to provide meta-levels of description structuring, ranging
from low-level parts, wholes and messages; to inheritance of properties of an
object; to meta-building blocks; to kits and applications.  An
identify-preserving filtration was shown in Figure 1.24; the identical musical
score is viewed in different ways on the display screen.  Identity-changing
filtration facilitates a second level of system structuring: ways to describe
the kinds of objects we wish to gather together to carry out our wishes.  A
framework we can employ is to use filtering to create new objects that are
dynamic analogies of objects we already know about.  This analogy filtering
mechanism permits differential programming, that is, programming by saying:
"...I want something just like you, except...".  So the first level of
structuring--communicating-objects, parts-wholes, insides-outsides, and
filtering with editing and searching facilities--provides objects that act as
prototypes from which new objects may inherit analogous characteristics.

More system levels are possible and needed in order to have a system for users
who vary greatly in their computing abilities.  A third level is to impose
sharply orthogonal properties on a small number of basic prototypical objects in
order to provide a rich domain for building simulations.  As an example,
consider the following three orthogonal prototypes.  First, a prototypical
object which represents spatial (or locative) characteristics can be the basis
for a wide variety of further descriptions, such as numbers and other algebraic
systems, composition and setting for illustrations, documents, circuit diagrams,
musical scores, animation scenarios, and programs themselves.  A second
prototype embodies the general notion of travelling in a spatial domain.
Examples are a constrained numeric variable, a cursor in a document, a paint
brush in an illustration, a player in a musical score, a role in an animation, a
process point in a program.  Travellers may employ elaborate strategies in
deciding when to move from one location in a space to another, and what to do
when they arrive.  A prototype which supplies a third dimension to this model is
that of a decoration.  This is an entity which is not strictly necessary for the
trip of a traveller through a space, except in a zero-dimensional form, but,
when present, greatly enhances the journey.  In the following example, the
zero-dimensional form is provided in parentheses.  Examples are: a physical
dimension such as length or weight attached to a changing quantity (a scaler);
different type-fonts in a document (a default font); tone/color and texture in
an illustration; the timbre of an instrument used to play a score (a pure sine
wave); the costume of a role in an animation (a dot); and the particular
pragmatic-primitives employed by a program-interpreter.

Kits are the fourth level of structure we can use.  A kit is a further filtering
on a domain; it greatly focuses the degrees of freedom of the domain towards a
particular goal.  Examples that we have tested in Smalltalk include kits for:
arithmetic, algebra, and geometry; document editing; drawing and painting;
music; animation; and job-shop simulation.  Each of these can be understood as
specializations (filtrations) of the three orthogonal prototypes mentioned
previously.

A fifth level of structuring is that of an application, a system whose use is
tailored to a particular problem.  Applications require the least deep
understanding by a user because most degrees of freedom have been removed; as a
result, they are the most difficult system designs to anticipate correctly.
Examples of applications are a music system for composition and orchestration, a
particular kind of viewport for examining Smalltalk programs (called a browser),
and an information retrieval system for a library.  Ideally, all applications
should be built with a careful regard to each of the four lower levels of
structuring we have discussed.  Like the person with books all over the house
who wished to purchase a bookcase, a user unhappy with features in an
application could very likely fix them at the next (kit) level without having to
descend to more atomic levels to create new material.  For example, a kit such
as the job-shop simulator can be specialized by a user into a specific
application for estimating solutions to a business problem.  Yet the simulation
application can again be addressed by the user at the kit level when changes are
needed (such as to add office workers or office equipment).



-------------------------

This has just been a quick sampler of the kinds of things that can be done using
a personal computing system.  Each of these editing tools, as well as other ways
of providing the same functions, will be explored in some depth as we begin to
look more closely at the Smalltalk programming language and the environment it
creates.



Other Readings

Human Factors

Card and Moran book

Cornsweet

Earlier Interactive Systems

JOSS

Smalltalk Papers

Kay Goldberg and Kay

Ingalls

Windowing as an interface device

Teitelman




Draft-1: Smalltalk: Dreams and Schemes, Chapter II Status: ready to edit, may
need to put introduction of pseudo-variable, self, in this chapter; amusement
park example will probably be replaced



 II

Smalltalk: Object-Oriented Programming





A Model for Smalltalk

The Smalltalk system is intended to serve as a vehicle for active description of
the world around us.  It must provide a simple and expressive framework not only
for the parts which make up that world or any other world which we imagine, but
also for the ways in which those parts interact in the course of life as it is,
or as we may choose to make it.  To this end, we have found the concepts of
object (part), communication and classification to be both simple and powerful.
Together, they comprise the basic framework for description in the Smalltalk
language.

In this chapter, we move from the living cell analogy of Chapter I to several
simpler examples where we can clearly identify the notions of object,
communication, and classification.  Preceding these examples, we look at issues
which dominate in the design of a programming language, and Smalltalk's method
for active description in light of those issues.  Finally, we define
object-oriented programming, and point out specific differences between the
Smalltalk system and the work of others.

There are Only Objects

The basic representation for information is called an object.  The term is
chosen because it is a singular abstract noun connoting nothing but unity.

An object demonstrates certain behavior.  Another way to say this is: an object
is capable of responding to specific requests or messages.  Its behavior is
defined by a set of templates or message patterns for messages which it can
understand.  A message pattern describes several messages that differ only in
their choice of arguments.  Symmetrically, objects can send messages to other
objects, typically in response to a request.

Objects can remember.  Since there are only objects, memory is in terms of
objects.

An object is defined by its state (memory) and its repertoire of behavior.  We
construct these definitions synthetically when specifying simulations of a new
class of objects.  We approach these definitions analytically when examining and
using existing (system-provided) objects.

Balancing the Hemispheres

It must be pointed out before embarking on the importance of the notion of
object, that there are two equally important ways to view the world: the
holistic (right-brain, eastern) view which takes the world as it is--whole,
perfect and out of time; and the analytical (left-brain, western) view which
draws distinctions, makes comparisons and analyzes according to cause-effect
relationships.

The digital electronic medium brings with it a very divisionistic point of view,
with a flute arpeggio or a sketch of a mountain scene being reduced alike to 1's
and 0's.  As Smalltalk has evolved, we have worked with this divisionism in two
main ways.  At the descriptive level, we have attempted to provide a simple and
expressive model for the relationship of parts to wholes so that the process of
building a system can draw on one's intuitive ability to synthesize and analyze.
At the interactive level, where we are providing a human interface to the
system, graphic aids such as menus, display viewports and a pointing device can
carry much of the communication in an intuitive way, leaving the user free to
focus his attention on what he wants to do.  We will return to this important
subject of human interface after a deeper look at the descriptive elements of
the language Smalltalk.

The Principle of Modularity

In our minds, we use many tools to reduce the unfathomable burden of dealing
with a million bits of information.  Chief among these are:

o	Distinction and the identification of objects,

o	Separation of form from function, and

o	Grouping of objects by similarity.

It is not pure coincidence that modularity in Smalltalk springs from three
analogous features of the language:

o	Uniform reference to objects,

o	Sending messages to obtain results, and

o	Organization of objects into classes.

In fact, the basic human ability to suppress detail in order to work effectively
manifests as a principle for programming languages.

No part of a complex system should depend on the internal details of any other
part.

In other words, as much as possible, the description should consist of many
local descriptions, each small and easy to understand.

Distinction and the Identification of Objects

As we have said, all references in the Smalltalk language are to objects, which
may be atomic or may consist of several named parts of its state, which refer in
turn to other objects.  For example, a point in two dimensions could be an
object consisting of two parts named 'x' and 'y'.  Each of these parts refers in
turn to another object which (typically) represents a numeric value.  Note that,
although the only truly atomic datum is the bit, it is often appropriate for
such simple objects as names and numbers to be considered atomic.

The principle of modularity dictates that, in a piece of code which reads the
y-coordinate of a point p, nowhere should there be instructions such as: "load
the second word relative to p," for this depends on how the point is
represented.  In particular, such an instruction would perform improperly if it
encountered a point represented in polar coordinates.  Smalltalk's solution to
this situation is to allow the caller only to refer to the object p, and if a
y-coordinate is desired, p must be asked to furnish it.

Pure object reference establishes protection in the same way, for the only way
to modify an object from the outside is to present it with a request for the
modification.  Whether the request shall be granted or denied is entirely up to
the object in question.

Separation of Form From Function Through Messages

The Smalltalk concept of message captures the notion of intent in programs, and
serves as an interface between message senders and their receivers.  It is this
interface which establishes the principle of modularity in Smalltalk.  Senders
need have no knowledge about the objects to whom they send messages, other than
that they respond appropriately to each message being sent.

Communication is the metaphor for processing in the Smalltalk language.  Objects
are created and manipulated by sending messages.  The same model describes
activities ranging from ordinary arithmetic to communicating processes in
separate machines.  To read a point's y-coordinate, send it the message
readYValue; it will work for cartesian or polar points.  To change an employee's
salary in a database, send the employee object the message changeSalary (you'll
probably have to supply an authorization as well).

The communication metaphor supports the principle of modularity, since any
attempt to examine or alter the state of an object is sent as a message to that
object; the sender need never know about internal representation.  For example,
points represented in polar coordinates r and theta would have a method which
responds to the message, y, by returning r multiplied by the sine of theta.

The communication interface is not provided as a feature in the Smalltalk
language; it is the fundamental metaphor upon which the system is constructed.
When the expression 3+4 is evaluated, the message +4 is sent to 3.  Since all
processing is done through communication interfaces, one can make changes or
additions to very complex systems without getting caught in a maze of
interdependencies.

Grouping of Similar Objects By Class

With data stored in objects, and process represented by the sending of messages,
it is the concept of class which brings the two together in a form consistent
with the principle of modularity.  Objects that respond to the same messages in
the same way, and that share the same state description, can be grouped
together.  We call the description of these objects a class description.

Every object in Smalltalk is created as an instance of some class.  The class
holds the representation of the fields for its instances, the messages to which
they can respond, and methods for computing the appropriate responses.  The only
information to be stored in an instance (besides its class) is the set of values
for its named fields.  (This is the particular implementation of the
object/message concept found in Smalltalk-76; other possible approaches are
examined in subsequent chapters.  One alternative view of the grouping or
classification scheme is that an object is specified in an object description
that serves as a prototype for the object's behavior and parts of state; this
prototype has values determined for its parts of state, not just a reference to
potential parts; it is therefore less abstract than the class description.  The
instance is a copy of the prototype that maintains its connection to any changes
in the prototype's behavior, but controls changes to the values of its own parts
of state.)

For every type of object in the Smalltalk system, there is a class which
describes it: Integer, String, Point, Rectangle; these are some of the classes
which describe the basic data types in a typical Smalltalk system.  In class
Rectangle will be found the names of the parts of state of a rectangle, the
messages which are understood by rectangles, and the methods for responding to
those messages.  The class is the natural unit of modularity; it describes all
the external messages understood by its instances, as well as all the internal
details about methods for computing responses to messages and the representation
of data in the instances.

Fruits of Modularity

Adding a new kind of data to a programming system is soon followed by the desire
to print objects of the new data type.  In many languages, this can be a
difficult task at a time when things should be easy.  One is faced with having
to edit the system 'print' routine which (a) is difficult to understand because
it is full of details about the rest of the system, (b) was written by someone
else and may even be in another language, and (c) will blow the system to bits
if you make a false move.  Fear of this often leads to writing a separate
'print' routine with a different name which then must be remembered, usually
leading to an organizational rat's nest.  In an object-oriented system, on the
other hand, printing is effected by sending a message to the object in question.
Therefore the only place where code is needed is right in the description of the
new kind of data (the new class).  If the new code should fail, there is no
problem; the existing system is unmodified, and can continue to provide support.

Suppose the parts of state of a Rectangle are corner and origin.  The code for
moving a Rectangle would be more efficient if corner were relative to origin; in
this way, the corner would not have to be relocated.  This could be accomplished
by changing the parts of state from origin and corner, to origin and extent.
The revised response to the message moveTo: pt would then eliminate the
re-computation of the location of corner (that is, new corner is equal to old
corner-origin+pt.)  In a conventional organization, once the response is
revised, all the code in the system would have to be recompiled because it used
to count on finding the corner coordinates as the second part.  In fact, most
systems would require rewriting because access to the corner (which used to be a
simple load or store) becomes a computation: compute origin+extent to learn the
corner, or make extent equal to pt-origin in order to place the corner at point
pt.

The class and message discipline ensure that if the original message protocol is
supported, then all code outside the class will continue to work.  Moreover, the
only changes required will all be within the class whose representation is being
changed.

Modularity is not just an issue of "cleanliness."  If N parts depend on the
insides of each other, then some aspect of the system will be proportional to
N2.  Such interdependencies will interfere with the system's ability to handle
complexity.  The phenomenon may manifest itself at any level; difficulty of
design, language overgrown with features, long time required to make a change,
or difficulty of debugging.  Encapsulating representation and message protocol
in the concept of class establishes an organization which minimizes
interdependencies.

Defining an Object

Let's take a closer look at this object-oriented semantics.

Here is an object

<==<chapter2-1.press<









It has three message patterns with their methods (or programs) for responding to
messages that match these patterns

<==<chapter2-2.press<


An object has state, parts that describe its properties.  This state
distinguishes objects that may share the same behavior.  So the object looks
more like

<==<chapter2-3.press<











The behavior of the object is described by message patterns and their
corresponding methods,

<==<chapter2-2.press<


and the parts that specify the state.

<==<chapter2-4.press<

The behavior of an object is described in two segments: each message pattern is
followed by a description of the intended response to that message.  These
responses, or methods for responding to a message, may be described in terms of
the object's state information.  One object in the system communicates with
another object by sending it a message.  The response is typically made up of
messages to itself, to other objects, or back to the original object; it may
also include changes to its state.

We could choose a better syntax for the description of the behavior in order to
emphasize the two parts, the one that defines the language for communication
among the objects (the message patterns) and the implementation of the messages
(the methods).  For reasons that will become obvious later, we have chosen a
dictionary-like format:

<==<chapter2-5.press<







We also add a list of items as the state description, and we add the name or
title of the kind of object.

Let's give this syntax a name: Dictionary, and talk about it as an object.  It
has its own behavior, that of adding new message patterns, deleting messages and
editing methods.  Whenever we create a new object, we provide a new Dictionary
containing the message patterns and their methods.  Thus, an object will look
like

<==<chapter2-6.press<











There are lots of objects in a system.  Each can carry around its own
descriptions.  Or we could choose to implement the system in such a way as to
share information about identical behavior.  Objects that respond to the same
messages in the same way can be grouped together.  The state of an object
distinguishes it from other objects that share the same behavior.  As introduced
earlier, this classification of objects according to like behavior provides a
powerful mechanism for creating a system consisting of thousands of independent
yet inter-related and interacting objects.

Example: Bank Account Objects

To illustrate the idea of sending a message to an object in order to store or
retrieve information, a record-like object for keeping deposits and withdrawals
in a bank account is described using the above syntax.

A description of the Bank Account object that resembles a record might be
something like the following.


title	BankAccount

state	name number balance

messages

name: name number: number	Set the name and number of the account.

balance	Return the current balance.

balance_ amount	Store amount as the current balance.


Suppose we create an object named savings that is a kind of BankAccount.
Conceptually, the instance is created with a state dictionary of names and
values, where each value is initially set to nil; nil is a special object
denoting nothing.  savings' message dictionary is that of its class,
BankAccount.

title	savings

state

name	nil

number	nil

balance	nil

messages

name: name number: number	Set the name and number of the account.

balance	Return the current balance.

balance_ amount	Store amount as the current balance.

Let's send the following sequence of messages to our new bank account object.

savings name: 'S. Booker' number: 1234.

savings balance _ 50.

savings balance _ 100.

savings balance _ 75.

savings balance 75 

We use the symbol  as a prompt symbol to indicate that Smalltalk is ready to
receive the next message.

The state dictionary for webster is now

state

name	'S. Booker'

number	1234

balance	75

This object is not very interesting, indeed, it does nothing more than provide
storage space for three items of information.  Suppose instead that we want to
keep separate record of deposits and withdrawals.  In the description of
BankAccountA, we have four parts of state; the name and number of the owner of
the account, a running total of deposits, and a running total of withdrawal.
Withdrawals can only be made if sufficient funds are in the account.  When an
account is first opened, deposits and withdrawals are initialized to zero each.
We have also added a reporting capability.

title	BankAccountA

state	name number deposits withdrawals

messages

init	Set deposits and withdrawals to 0.

name: name number: number	Set the name and number of the account.

deposit: money	Increase the value of deposits by money.

withdraw: money	Determine if there is sufficient funds (is the difference
between deposits and withdrawals greater than or equal to money?)  If there is,
increase withdrawals by money.

balance	Return the difference between deposits and withdrawals.

report	Print out a bank statement: the name, number, total deposits, total
withdrawals, and balance.

Note, that in the above examples of message patterns, we have introduced some
conventions having to do with the actual syntax of Smalltalk-76 as defined in
Chapter VI.  In particular, message patterns are made up of literal parts
(tokens) and parameter parts.  Tokens cannot have hyphens nor spaces, so we
capitalize embedded English-like words to aid readability (BankAccount).  We
have been capitalizing the first letter in the names of classes of objects
(BankAccount), while using lower-case first letters for the names of instances
(savings).  A unary message is a single token (balance).  If a parameter is
expected, we attach a colon to the token (deposit:).  Multiple parameters are
possible simply by specifying a sequence of tokens with colons and parameter
names (name: x number: y).  We employ this syntax and these conventions now in
order to avoid syntactic confusion later.

We can send an instance of BankAccount, savingsA, the following sequence of
messages.

savingsA init savingsA name: 'S. Booker' number: 1234 savingsA deposit: 500
savingsA withdraw: 100 savingsA balance 400 

savingsA responds to the message balance by printing the value 400.  We might
continue our transactions.

savingsA withdraw: 200 savingsA deposit: 50 savingsA withdraw: 250 savingsA
report

S. Booker	 1234 Total Deposits: 550 Total Withdrawals: 550 Balance: 0



savingsA responds with a report of the total transactions for this account.

Now suppose reporting totals is not satisfactory for the bank customers who are
complaining that they want to see an itemization of each deposit and withdrawal.
We could modify the implementation of the object BankAccountA by defining
deposits and withdrawals to be sequences of numbers; the computation of the
balance and the report is somewhat more complex, but no change in the external
view (the messages) is needed.  We have placed asterisks in the left margin to
indicate where changes in the definition of a response to a message was made.

title	BankAccountA

state	name number deposits withdrawals

messages

*	init	Create deposits and withdrawals as empty sequences.

name: name number: number	Set the name and number of the account.

*	deposit: money	Store the value of money in the sequence deposits.

*	withdraw: money	Determine if there is sufficient funds (is the
difference between the sum of the deposits and withdrawals greater than or equal
to money?).  If there is, store the value of money in the sequence withdrawals.

*	balance	Return the difference between the total of all deposits and the
total of all withdrawals.

*	report	Print out a bank statement: the name, number, each deposit and
the total deposits, each withdrawal and the total withdrawals, and balance.

If we now create savingsA as an instance of this kind of bank account, and
execute the messages presented earlier, then the only difference apparent to the
message sender will be the result of the message report.

savingsA report

S. Booker 1234
Deposits: 500 50				Total Deposits: 550 Withdrawals:
100 200 250	Total Withdrawals: 550 Balance: 0 

Of course, the customers are still complaining: They want to see more
information about each transaction, at least the date.  Again, without changing
the message patterns and thereby not having to change any users of BankAccount
objects, we redefine its implementation.  This time, however, we provide
additional kinds of objects, a Deposit and a Withdrawal; these objects will hold
appropriate information about each transaction such as the date.  We then
require that the bank account maintain a sequence of the Deposits and
Withdrawals.



title	Deposit

state	date amount

messages

	on: date value: amount	Store the record of this deposit.

print	Print the stored information.

	value	Return the amount of this deposit.



title	Withdrawal

state	date amount

messages

	on: date value: amount	Store the record of this withdrawal.

print	Print the stored information, showing a negative amount.

	value	Return the negative of the amount of this deposit.



title	BankAccountB

state	name number transactions

messages

*	init	Create transactions as an empty sequence.

name: name number: number	Set the name and number of the account.

*	deposit: money	Create a Deposit for today with money as the amount.
Store this new Deposit in transactions.

*	withdraw: money	Determine if there is sufficient funds (is the
difference between the sum of the deposits and withdrawals greater than or equal
to money?)  If there is, create a Withdrawal for today with money as the amount.
Store this new Withdrawal in transactions.

*	balance	Return the the total of all transactions.

	report	Print out a bank statement: the name, number, each deposit and
the total deposits, each withdrawal and the total withdrawals, and balance.

Again, no change to the set of message patterns is required.  Printing the
report involves sending each item in transactions the message print; depending
on the kind of transaction (Deposit or Withdrawal), the date and a negative or
positive amount will print.

The actual definition of each variation of BankAccount, as written in
Smalltalk-76, is provided in Appendix 1, along with the code for all other
object descriptions used as examples in this chapter.

Example: A Simple Calculator

The notion of state is familiar to users of calculators.  The ones we will
examine in this example are quite simple, including only arithmetic operations
and the ten digits.  If we had a graphics display of the calculator, it might
look like:

			<==<chapter2-12.press<












The reset option clears all operands and operators; selecting clear once sets
the operand to zero, while two clears in a row act as a reset.

Our purpose in this example is to emphasize the notion of state of an object, so
we will simplify matters by assuming that a "nice" user interface to a graphic
display of the calculator is available for selecting digits, operators (+, -, *,
/, and =), reset, and clear.  For example, an image of one or more calculators
with name and current result also displayed, might be accessed via a touch
sensitive display medium. (See Chapter XIIIff for the introduction of user
interface technqiues.)  The simplification includes omitting the messages needed
to have the calculator actually apply an operator to its operands.

Here is a description of the Calculator object.  Its state consists of the two
operands, op1 and op2, the operator, opr, and a flag to indicate whether or not
the last selection was a digit or not.  There are only four messages as shown
below.  Note that it will be the responsibility of the user interface methods to
translate pointing ones' finger at the display screen into one of the first four
messages, providing the appropriate numeric or message-selector parameter; the
interface will also have to determine when to send the calculator the display message.

title	Calculator

state	op1 op2 opr nflag

messages

reset	Set op1 and op2 to 0; set opr to the addition message (+).

clear	If nflag is true, then set op2 to 0 and nflag to false; otherwise, do
the reset.

digit: d 	If nflag is true, then set op2 to the value of ((op2 * 10) + d);
otherwise set op2 to d and nflag to true.

operator: nopr 	Set nflag to false; set op1 to the result of applying the binary
operator opr to the two operands op1 and op2; and then set opr to the next
operator, nopr.

display 	If nflag is true, then show op2, otherwise show op1.



Clearly other display methods are possible.  The issue of how to apply the
binary operator to the operands is dealt with as a programming style issue in
Chapter VIII.  One possible implementation is shown in Appendix I.

Suppose we create a calculator, calc, and then select the various "buttons", one
at a time, in the order shown in the following table.  The corresponding state
changes are shown in adjacent columns of the table.

Buttons	op1	op2	opr	nflag

reset	0	0	+	false
2	0	2	+	true
3	0	23	+	true
-	23	23	-	false	(The computation was 0+23)
2	23	2	-	true
clear	23	0	-	false
1	23	1	-	true
5	23	15	-	false
*	8	15	*	false	(The computation was 23-15)
+=	120	15	+	false	(The computation was 8*15)
+=	135	15	+	false	(The computation was 120+15)
5	135	5	+	true
clear	135	0	+	false	(The computation was 135+0)
-	135	0	-	false
clear	0	0	+	false

We could now create several calculators for each bank teller and even give one
teller two.


Example: A Business Office

The operation of the bank's business office is a familiar example of the idea of
passing messages from one object to another until the message is received by the
object that actually has the needed information.  Suppose the office manager
sends the message 'who printed our envelopes?' to the executive secretary.  To
respond, the executive secretary sends the receptionist the message 'is the
purchasing clerk in?'; if the response from the receptionist is positive, the
office manager is returned the response of the executive secretary's query to
the purchasing clerk: 'who printed our envelopes?'  But the purchasing clerk
actually passes back the filing clerk's response to the purchasing clerk's
message: 'look up who printed our envelopes'.  In the end, the office manager
appears to receive a response from the executive secretary, but is actually
getting the filing clerk's response.

<==<chapter2-11.press<


Example: Door Objects

To illustrate the idea of defining an object by synthesizing from the
descriptions of a lot of objects of the same kind, let's consider an example
borrowed (albeit loosely) from a paper by J. Shoch ["An Overview of the
Programming Language Smalltalk-72", Convention Informatique, Paris, 1977] in
which he illustrates the task of describing the doors which lead into a house.
This example further illustrates the notion of distributing state information to
objects that semantically describe a single kind of object.

First, what is a door?  We might start by describing everything we know about
doors: they are different sizes and colors; they can be hinged on the left or
the right; they might fold, slide or split in two; some have glass windows, some
are all glass and others are all wood; they are located in many different
entrances of a building and its rooms; and most require a key to open them.  At
any given time, a door might be open or not.  In addition, doors with locks
might share some common state, such as the master key which can open them all.

From this general characterization, we can describe particular doors: the brown
wood door with a glass window that guards the entrance to the apartment house
(frontDoor); the green Dutch door leading to the kitchen at the back of my
apartment (backDoor); and the glass sliding door from the family room to the
patio (patioDoor).  They all lock.  My apartment key (to the backDoor) also
opens the door to the apartment house (frontDoor).  The key to my neighbor's
apartment opens the frontDoor, but none of my apartment doors.

We can communicate commands to a door by sending a message.  We might request:

frontDoor areYouOpen	ask the front door if it is ajar

backDoor close	close the back door

patioDoor seeThrough	does the patio door include a glass window?

frontDoor lock	lock the front door

backDoor unlockWith: schlage	if the back door is locked, unlock it with the
key called schlage

frontDoor recognizes: schlage	is the key called schlage one that unlocks the
front door?

A door object might not actually retain memory of the key (or keys) that can
unlock it.  Indeed, in the physical implementation of this object, a door has a
lock; this lock matches an internal pattern against the pattern of a key in
order to determine if the key fits the lock.  The response to the message close
would be to shut the door; depending on whether the lock was engaged or not, the
door might require a key to re-open it.  To lock a door, you might need a key.
The response to the message lock might be an indication that there is no lock,
or that the existing lock requires a key.  It is possible that a door can answer
the inquiry as to whether or not it recognizes the key (schlage); more likely,
the door does not know, rather its lock does, and the implementation for the
message recognizes would pass on the request to the door's lock part.

From the above discussion, we propose that a more detailed view of the message
dictionary of the object door might be:

areYouOpen	If the state of a special indicator, open, is true, then answer
'yes'; otherwise answer 'no'.

close	Indicate that door is not open by setting open to false.

seeThrough	If material, a list of materials that make up the door, includes
'glass', then answer 'yes'; otherwise answer 'no'.

lock	Set the lock.

unlockWith: aKey	Determine if the door is locked.  If so, determine if
aKey fits the lock and, if so, unlock it.  Otherwise say that the key doesn't
fit.  If the door is not locked, say so.

recognizes: aKey	Does aKey match the door's lock?  If so, answer 'yes';
otherwise, answer 'no'.

The methods imply that the object has, as its fields, at least:

open	An object whose value is either true or false, depending on whether or
not the door is ajar.

material	A list of the names of materials; or a list of references to a
new kind of object that remembers color as well as the type of a material (a
Material object).

myLock	a Lock object or nil (meaning no lock is needed for this particular
door).

Alternatively, the door could have fields:

open	(same as first alternative)

material	(same as first alternative)

myLock	An object whose value is true if the door has a lock, false otherwise.

code	A numeric pattern that must match a corresponding pattern known to the
message sender's own key.

lockState	An object whose value is true if the lock is set, false
otherwise.

The difference in the two alternative field descriptions is that, in the first
case, we distribute the knowledge of the key code and state of the lock to a
separate kind of object, a Lock.  This Lock object must be capable of responding
to appropriate messages such as setLock, isLocked (a query), recognizes: aKey,
and unLock.

In the second alternative, the door itself must provide the space for holding
this information about a lock, even if it does not have one, and the door must
be able to respond to messages about the lock.  (Note, we could eliminate the
field myLock by testing code; if code is nil, then there is no lock on the
door.)

Here is a possible description of the Lock object.

title	Lock

state	code flag

messages

setLock	Set the lock by setting the flag part to true.

isLocked	Is the lock set (object sends itself the message setLock)?  If
so, is the flag true?  If so, answer 'yes'; otherwise answer 'no'.

recognizes: aKey	Is the code for aKey identical to code?

unLock	Reset the lock by setting flag to false.

And here are the two possible descriptions of the Door object: each shows all
the fields, but only the three entries in the message dictionary that differ in
their dependence on knowledge of the lock.

Alternative 1

title	Door

state	open material myLock

messages

lock	If myLock is nil, answer that the door has no lock.  Otherwise, send
myLock the message setlock.

unLockWith: aKey	If myLock is nil, then answer that the door has no lock.
Otherwise, if myLock is already locked (send myLock the message isLocked), then
send the message myLock unLockWith: aKey.  Otherwise, answer that the door is
already unlocked.

recognizes: aKey	If myLock is nil, then answer that the door has no lock.
Otherwise have myLock give its response to the message recognizes: aKey.

Alternative 2

title	Door

state	open material myLock code lockState

messages

lock	If myLock is nil, answer that the door has no lock.  Otherwise, set
lockState to true.

unLockWith: aKey	If myLock is nil, then answer that the door has no lock.
Otherwise, if lockState is true, then see if the code for aKey is identical to
code.  If not, answer that the key does not fit the lock.  If lockState is
false, answer that the door is already unlocked.

recognizes: aKey	If myLock is nil, then answer that the door has no lock.
Otherwise, answer whether or not the code for aKey is identical to code.

In the first alternative, the one for which we show the Smalltalk-76 code in
Appendix 1, the actual work is therefore done by an object that has knowledge
appropriate to its common function.  We have also assumed the added existence of
a Key object that responds to the message code by returning a numeric pattern
that can be equated to the code of the door's lock.

This example has emphasized our ability to introduce two views of any object, an
external one (message sending) and an internal one (the implementation).  From
an external view, we can ask a door for its key (e.g., frontDoor key) and
receive a master key in response.  This says nothing about how the key was
determined (does the door know or does the door ask a lock?), nor whether the
determination was a shared or not shared part of all the doors in the system.
Another way to say this is that from an external view, asking an object "what
are you?" obtains the dictionary of message patterns, and, if available, a
description of the intended responses to the messages.  But from an internal
view, the same question returns the specific values for state information and
the methods for responding to the messages.



Constructing an Object Synthetically

So far we have examined several kinds of objects, a BankAccount, a Calculator, a
Door, a Lock, and a Key.  We have seen that we can create many instances of a
kind of object, each sharing the same behavior and the same parts of state.  Now
let's suppose that we want to simulate a world made up of lots of kinds of
objects and we want to collect these objects in some organized fashion.  From an
external view, such organization is not necessarily meaningful.  From an
internal view, that is, for purposes of actually describing an object's
behavior, it is efficient to impose some classification structure on the
potentially large number of similar objects

To review, each object demonstrates some behavior, such as responding to a
particular message.  And several objects may all demonstrate similar behavior,
so we collect these objects together, leaving separate those objects
demonstrating dissimilar behavior.  As we have seen in the previous examples,
the behavior of an object is the actions the object can take.  Each action is
invoked by sending a message to the object.  So we collect together all those
objects that understand the same messages and respond in the same way to these
messages.

Each of these objects also has parts that distinguish the object from another.
Indeed, the responses to the messages might want to communicate or transform
these parts.  The message responses can only be identical if they reference the
same kind of property, and we can therefore use identical reference names.  Each
object part might have different values.

So the decision to form a collection of objects (a class), given a world to
capture, depends on these objects' demonstrating similar behavior and differing
only with respect to the values of state information.  Drawing the division
between shared information (state, message patterns and methods) and
individually owned information (state, message patterns and methods) is, again,
an implementation decision.

Example: An Amusement Park

To illustrate the idea of defining an object from a large world of objects,
let's look at an amusement park.  Here we will find more than one kind of
object.  Our goal is to discover a classification scheme that minimizes the
number of different kinds of objects, yet provides some flexibility in how they
can be used to represent all the activities in the world we wish to simulate.

What do you think of when considering an amusement park?  There is a
merry-go-round, cotton candy, ferris wheels and roller coasters, buying tickets,
buying souveneirs, a fun house, games, side shows (animals, strange people), a
train ride, ice cream booth, cafeteria, sit-down restaurant, animal rides, lines
of people waiting to get on a ride or to get a ticket, someone selling balloons,
and so on.  On the negative side, there are crying kids, and crying parents,
dizziness, stomach aches, and sunburn.

Focusing our attention on the kinds of places, rather than the people or
animals, we can organize the parts of an amusement park into rides, game booths,
and places to buy things (tickets, food, balloons, tee-shirts).  A coarser
organization might divide the parts into places where you buy things and places
where you do not buy things (not too many places like this!)  An even finer
organization divides the parts into:

rides that change all riders at once: merry-go-round, ferris wheel

rides that continuously exchange n riders (where n < the number of all the
seats): bumper cars, fun house, roller coaster, animals, boats

food vendors: kiosk, cafeteria with and without tables, table service

non-food vendors: tickets, souveneirs

Each has a waiting line of some kind made up of objects waiting for service.  At
some time, a worker who gives service sends the message "next, please" to the
line and the next object waiting is given service.  We notice that some lines
lose more than one object at a time, for example, filling a seat on a
ferris-wheel removes two people at a time from the waiting line.  At various
times, objects arrive and enter the line, or objects get tired of waiting and
leave.  In each case, the object involved sends the appropriate message so that
the line can adjust to the change.

next		tell me the next object in the line

next:	n	tell me the next n objects in the line

enter:	p	object p enters the line

leave:	p	object p leaves the line

The amusement park contains many lines in different locations; some are long and
some are short; most contain people, although some have cars (at the entrance to
the park), and some have animals.

Vendors share the behavior of selling something.  Each gives service to one or
more objects (people, usually), taking a computable amount of time and
collecting a fee.  For some vendors, the service includes providing a second
service which might involve a second waiting line (for example, giving a seat at
a table followed by serving food, or selling a ticket and then giving a ride).

serve:	p	vendor serves object p

collect:	n	collect fee n from object p
from:	p	

Vendors appear to remember a waiting line, how many customers to handle at one
time, what to do for the customer, and a way to compute service time.

We could proceed with this classification effort by looking at the behavior of
rides.  In talking about the behavior of rides, we will find ourselves, again,
itemizing all the parts and uses for the variety of rides in the amusement park.
In the same way, we would examine all the eating places in the park.

We have had to remain somewhat vague about the organization of objects that can
make up an amusement park.  In order to provide a more concise description, it
will be necessary for us to specify the purpose in our modelling the park.  That
purpose would then direct our choice of objects and their classification.

For example, suppose our purpose is to collect information about the amount of
time people spend in waiting lines versus riding on an attraction or eatting
food or purchasing an item.  We could then concentrate on the kinds of waiting
lines and the places where such lines exist in the park.  Indeed, we might
describe a Place object, an area where people arrive, get in line, wait until
they can get service, and then, after getting service, leave.  We could have
this object maintain a tally of the time each person spent waiting and the time
they spent getting service.

What kinds of messages should an object like Place understand?  The following is
a possible state and message dictionary for this new object.

title	Place

state	worker customer waitingLine ncust tallyOfCusts tallyOfTime

messages

enter: cust	customer enters the place.

askForService: cust	customer asks for service in the place.

giveService: cust 	customer gets service from worker in the place;

by: worker	how much time is spent giving service is determined by the
worker.

leave: cust	customer leaves the place.

wait: cust	customer has to wait for service.

nextCust	Check to see if any customers are in the waiting line.

We can imagine that the customer can be told the time at which he enters the
waiting line as part of the response to the message wait: cust and that, upon
receiving service (nextCust), the tallyOfCusts would be incremented by 1 and the
difference between the current time and the time remembered by the customer
added to a tallyOfTime.  The average time spent in the waiting line at this
place is computed from these two remembered tallies.

Suppose now that we examine the amusement park and determine that there are
several kinds of places that demonstrate precisely the behavior of the object
Place that we just defined.  Then we can add them as part of the amusement park
by creating them as instances of Place.  Since we are not concerned with the
product or function of each place, these can be ignored.  Because we want to
capture places like a train ride as well as a kiosk, we will have to be
concerned with how many customers are served at one time: we will use an
additional part of state, ncust, to indicate the number of customers to take out
of the waiting line, information to be used in the response to the message
nextCust and in computing the tallies.  The parameter customer might then be one
customer or a list of ncust customers.

Two Graphic Examples

In the introductory remarks of this chapter, we mentioned two examples of
objects taken from the definitions available in Smalltalk-76, a system
implemented on a hardware configuration that includes a graphical output device.
They are Point and Rectangle.

Example: Point Objects

A Point is simply a pair of numbers designating a location in a two-dimensional
space.  For example, the two numbers could represent the distances from the left
side and the top of a display screen.

The description of its messages is:

x	my distance from the y-axis

y	my distance from x-axis

+ pt	pt is a Point.  What is the Point that is pt (a vector distance) away
from me?

- pt	pt is a Point.  What is the vector distance from me to pt?

 pt	Am I a coordinate above and to the left of Point pt?

Note that the first two messages make it possible for some other object to
request information about the parts of the state of the point.  In this example
we have introduced the syntax that there are special tokens, such as +, -, and
, that do not require colons, although the message requires one parameter.  We
call these tokens infix operators.

Suppose we create a point representing a location 50 units from the left and 100
units from the top of a display screen.  We could also create another point 100
units from the left and 25 units from the top.  Let's call these points ptA and
ptB respectively.

title	ptA

class	Point

state

x	50.

y	100.



title	ptB

class	Point

state

x	100.

y	25.


Notice that we are no longer listing the dictionary of messages and their
responses separately for each point.  Because each object is classified as a
point, each can respond to the messages listed above and we can assume that the
dictionary is shared among the objects in the system that are so classified.  In
order to look up items in its message dictionary, each instance has a reference
to its class.

Suppose we send the + message to ptA:

ptA + ptB

The response is a third point at position 150, 125.  This new object has
different values for the parts of its state, but demonstrates the same behavior
as ptA and ptB.  To compute the parts of the new object, the response to the +
message might be something like:

compute the x by adding ptA x and ptB x

compute the y by adding ptA y and ptB y

Example: Rectangle Objects

A Rectangle object is a graphical object with four edges; it could reside on a
display screen.  One way to completely describe it is that it has an origin, its
upper left-hand vertex, and a corner, its lower right-hand vertex.  The vertices
on a display screen may be represented by points as described in the previous
example.

Suppose we have two rectangles on the display screen, R1 and R2.  Tell R1 to
move its origin to 0, 0 and its corner to 100, 100; tell R2 to move its origin
to 200, 200 and its corner to 300, 300.  Now, if we ask each of R1 and R2 for
its center, we expect to get two different responses (i.e., 50, 50 and 250,
250).  Clearly each rectangle has state, information describing its location on
the display screen.

The state distinguishes the two rectangles.  Note that this does not dictate
anything about what the state is nor how it is stored.  It could be four numbers
(for example, minX, minY, maxX, maxY), two points (origin, corner), an origin
point, a width, and a height, or a program that computes the values.  The choice
really depends on the intended use of the object, that is, what responses are
desired.

We could add a message to the object Point making it possible to create a
Rectangle object from two points

rect: pt	create a Rectangle whose origin is me and whose corner is pt

By choosing to share the description of messages and their methods among all the
objects in the system that demonstrate like behavior, all points (e.g., ptA,
ptB, ptA + ptB, as well as any other new ones we might create) would be able to
respond to this new message.

What is an Object-Oriented Language?

We have now seen several examples of what we mean by an object and the
communication among objects via message sending.  We were once delighted to see
a seminar announced on "Machines for Object-Oriented Languages."  Much of the
content however was actually concerned with the language LISP.  While we will
always have a fond spot in our hearts for the language LISP, we do not consider
it to be an object-oriented language, and we wish to make clear what we mean by
the term, as it is a term which characterizes a very significant difference
between certain high-level languages and others.

We consider that a weak definition of an object-oriented language is that there
is a separation between the form of external access to an object and the
internal ways in which access is implemented.  This criterion of separation is
often referred to as abstract data types.  Some languages which fail to meet the
criterion of weak object-orientedness are: Fortran, Algol, APL and LISP.  Some
languages which do not meet this criterion to a lesser or greater degree are:
SIMULA, records and references in Algol, Pascal, and Mesa.  [Alphard and Clu]

The strong definition of an object-oriented language goes a significant step
farther: not only must a sender of a message to an object be independent of the
internal details of that object, it must be independent even of the class of
that object.

Classes Vs. Types

The reader may wonder why we talk about "class Integer" and "class String" when
discussions of other programming languages usually talk about "type Integer" and
"type String".  The reason is that classes and types are not the same.

A class is a grouping mechanism for objects that specifies their representation
(state) and their behavior (message patterns and message responses).  A type is
a grouping mechanism for values that specifies their permissible uses.  For
example, it may be impermissible in a given language to add a string value to an
integer value.  The reason given would be that they are of incompatible types.

Note that the preceding paragraph used the word "object" to define the term
"class" and the word "value" to define the term "type".  Again, "object" and
"value" are not synonyms.  In most languages, a value is either a number or a
reference to a data structure; in Smalltalk, a value is always a reference to an
object.  In both cases, the role of a value is the same: it may be stored into a
variable, passed as an argument, or returned as a result.  An object, on the
other hand, can serve none of these roles.  It is "out in the environment", and
only references to it can play these roles.

Types go with values, and classes go with objects.  Therefore, types are
attributes of variables, of arguments, and of results in the static program,
while classes are attributes of objects in the dynamic environment.

The language SIMULA has both types and classes.  Even in Smalltalk, the notion
of a type is a useful concept.  Two values can be thought of as the same type if
they reference objects that respond to the same certain set of messages.  It is
not necessary for those objects to belong to the same class for this to be so.
Two separately defined classes may have some of their message protocol in
common, although their methods for responding to those messages may differ.
Types cut across class boundaries, and may involve only some of the messages of
some of the classes.

Smalltalk-76 does not have any explicit specification of types.  Thus, although
Smalltalk-76 is strongly object-oriented, it is weakly typed, because the types
of variables, arguments, and results need not be--and cannot be--declared in a
program.  It would be possible to have a language that was strong on both
counts.  However, the benefits of strong typing are mixed, so we have opted to
avoid it.

Note that we have not mentioned the use of subclassing in Smalltalk; it is not
officially introduced until Chapter IV.  By subclassing, we mean the ability to
create a new class description by inheriting the description of an existing
class.  We say that Smalltalk is weakly typed (rather than untyped), because
there is a way to get some of the benefits of a typed language, namely, with
abstract classes.  An abstract class, like a type, lacks the ability to have
instances (the class description has no distinguishing state).  An abstract
class, like a type, is associated with a message protocol that cuts across many
classes, namely, all the concrete subclasses of the abstract class.  Therefore,
a programming style is possible in which the abstract classes behave like types.

Suppose the abstract class Number were the only class in the system that defined
the message 'min: x', which computes the lesser of two numbers.  Then Number
could be thought of as a type restricting the arguments of 'min:' to be
references to certain objects, namely, instances of subclasses of Number.
However, the check on the argument type would not happen when the method was
compiled, but rather when it was executed, so the typing is quite weak.  Still,
this programming style makes programs easier to understand and hierarchies
easier to extend, so it is encouraged.  It will be explored further in Chapter
IV.

Summary of System Objects Referenced in This Chapter

Sequence

next next_ reset empty

Number

String

Constants

nil true false

Point

Rectangle



Other Readings

Object-Oriented Programming Languages

Clu Alphard Mesa Simula






Draft-0 Smalltalk: Dreams and Schemes, Chapter III May 11, 1979



III

Basics of Smalltalk Implementation




How do we really define a programming language that models the framework
presented in the previous chapter?  There are many ways to implement a language
like Smalltalk.  A wide variety of data structures is available for modeling the
static relationships, and the dynamic behavior could be realized by any of
several different algorithms.  In the next (seven) chapters, we will attempt to
give the reader a sense of what is involved in producing a complete Smalltalk
system.  This discussion will include the language syntax, the way in which
messages are sent, compilation into compact syllables, and the run-time
structures which attend the execution of a typical compiled method.  These next
chapters do not address the higher level of user interface nor the lower level
of storage management.  Those parallel topics, being somewhat independent, are
treated separately in this book.

Smalltalk can be viewed in two parts which we will call the Smalltalk virtual
machine and the Smalltalk system.  The Smalltalk virtual machine provides a
representation for the basic ideas underlying Smalltalk: objects, messages,
classes, programs and program execution.  The Smalltalk system is a set of
specific Smalltalk objects represented in the virtual machine.  The purpose of
Smalltalk is to allow a user to create and use Smalltalk objects and to create
new types of objects.  Many specific sets of objects could be envisioned which
fulfill this purpose, all of which could be represented within the same general
framework of objects, messages and classes.  This chapter is about how this
general framework, the Smalltalk virtual machine, is implemented.  It covers how
a class description is used to generate the actual behavior of objects.

<either replace hardware example below or add here a review of hardware used>

Programs and Programming Languages

Both the Smalltalk virtual machine and the Smalltalk system consist mainly of
programs.  These programs describe the actions of the computer on which the
system runs and are expressed in several different programming languages.  Much
of the system is described in programs written in the Smalltalk language but
several important parts of the implementation must be written in lower-level
languages.  This section describes how the various programs in Smalltalk
actually control the computer.

Interpreters and Compilers

A program is a description of some actions for a computer to perform.  We say
that the computer executes the program when it actually performs the actions the
program describes.  There are two types of things that can happen to a program
in the process of execution which are called interpretation and compilation.
Interpretation is sometimes called direct execution, since the actions described
are actually carried out in the process of interpretation.  Interpretation is
performed by an interpreter which directly controls the computer.  The
interpreter looks at the program and makes the computer perform the described
actions.  Compilation is an indirect process by which a program is translated
from one programming language to another.  The actions described in a program
are not performed during the process of compilation so the translated program
must then be interpreted.

There are two types of interpreter, hardware and software.  A hardware
interpreter is a physical device that is actually part of the computer itself.
A software interpreter is a program being executed (interpreted) by another
interpreter.  There can be several levels of software interpretation but the
lowest level interpreter is always a hardware device.  In the early days of
computers, the hardware devices were interpreters for what are commonly known as
machine languages.  In order to interpret a higher level programming language, a
machine language program was written which used the higher level programs as
data and had the machine perform the described actions.  Basic is an example of
a system which was often implemented by a machine language interpreter for Basic
language programs.  In many systems, the machine language Basic interpreter was
itself interpreted by a hardware interpreter.  More recently another layer of
interpretation has been added to many computer systems.  Hardware devices are
built to interpret languages called microcode.  Software interpreters for
machine language programs are then written in microcode.  In such a machine, a
Basic interpreter would be a third layer of interpretation (two software and one
hardware).

The other possible path for a program on its way to controlling a machine is to
be compiled or translated into another programming language.  Fortran is an
example of a language which is normally executed by compiling programs into
machine language programs.  These machine language programs are then interpreted
either by a machine or by a microcode program running on a machine.  Compilation
is a solution to the conflicting goals of efficiency of execution and ease of
use by the programmer.  Often the form of programs most convenient for humans to
read and write is difficult and slow for an interpreter to follow.  A compiler
is a program that translates a "higher level" human usable language into another
language that can be efficiently interpreted.  Note that a compiler can be
written in the language that it compiles, while an interpreter cannot be written
in the language it interprets.  (This needs elaboration).  There are various
degrees of translation possible, some of which are not ordinarily referred to as
compilation.  Assembling is a translation from assembly language, which is a
sequence of alphabetic and numeric characters, to machine language, which is a
sequence of numbers.

In Smalltalk-76 we find both compilation and interpretation.  A Smalltalk
program is a string of characters, usually written by a human.  This string of
characters is presented as data to a compiler which translates it into a
bytecode program.  The bytecode program then becomes data for the bytecode
interpreter which executes it.  The compiler is a set of bytecode programs and
can, therefore, be changed by recompiling it from Smalltalk programs.  It, of
course, did not originate by compiling itself; that is a trick.  In the Alto
implementation, the bytecode interpreter is a set of microcode and Nova-like
machine language programs.  The microcode programs are interpreted by the Alto
hardware and come in two parts.  One part is solely concerned with bytecode
programs themselves and the other part is an interpreter for the Nova-like
machine language programs in the bytecode interpreter.

Virtual Machines

Most interpreters execute programs that are sequences of instructions.  Each
instruction describes an action to be taken by the interpreter.  The process of
interpretation is simply to take the next instruction in sequence and take the
action it describes.  A particular interpreter differs from others in the type
of actions it can perform and how the actions are described.  The actions
described by instructions and performed by interpreters are changes made to a
set of entities under the interpreter's control.  In the case of a hardware
implemented interpreter, these entities are physical registers.  The
instructions executed by a hardware interpreter describe changes to be made to
these registers.  A software implemented interpreter functions in exactly the
same way except that the entities it manipulates need not be physical devices.
A software interpreter and the set of entities it manipulates is called a
virtual machine.  So we have a machine, physical or virtual, consisting of
entities that retain some state and an interpreter which has the ability to
change the entities' state.  The interpreter determines how to change the
entities by consulting instructions in a program.  The two things to be
described about an interpreter are the nature of the state retaining entities of
its virtual machine and the set of instructions it understands.

The Alto computer provides several examples of interpretation.  The hardware
consists of:

1) Two sets of 32 16 bit registers called the R registers and the S registers.

2) A 16 bit two input arithmetic logic unit and a 16 bit shifter.

3) A large (64-256K) memory of 16 bit words and a 16 bit Memory Address
Register.

4) Three 16 bit registers called T, L and IR.

5) A small (1-2K) memory of 32 bit words used to hold microcode programs.

These are all connected by various busses and control wires to each other and to
the hardware interpreter for microcode instructions.  The interpreter looks at a
32 bit microcode instruction and makes a change to the states of some of the
components.  For instance, an instruction might say that the contents of one of
the S registers should be changed to be the contents of the L register or that
the contents of the L register should be set to be the output of the ALU when
the contents of the T register and one of the R registers are provided as inputs
and it is asked to add.

All Altos have an interpreter for a Nova-like machine language stored in part of
their microcode memory.  The virtual machine for this interpreter is similar to
the Data General Nova.  It has four 16 bit registers, an arithmetic logic unit,
a memory of 64K 16 bit words which contains both data and machine language
programs and a 16 bit program address register which contains the address of the
next instruction to be interpreted.  The interpreter executes 16-bit
instructions that move data around in the registers and memory, perform
arithmetic and logical operations on the data in the registers and modify the
address in the program address register.  A program written in Nova machine
language is actually data for another program written in microcode.  This
interpreter uses four of the Alto's R registers to hold the contents of the four
Nova registers, the IR register to hold the program address and the first 64K of
the Alto's memory to simulate the Nova memory.

The Nova virtual machine is a straight foreward modification of the actual
machine on which its interpreter runs (the Alto).  The Smalltalk virtual machine
is more of a change since it is designed around the concepts of the language
(i.e. objects, classes and messages) instead of the typical vonNeuman concepts
(i.e. n-bit binary numbers and linear memories).  The detailed structure of the
Smalltalk virtual machine will be discussed after the following section which
describes the structure of a Smalltalk system.

Smalltalk Fundamentals

The most basic concept of the Smalltalk system is that every part of it has the
same representation.  This uniform representation is an inherently active entity
called an object.  The two basic features of an object are that it can remember
and that it can communicate with other objects by sending and receiving
messages.  Since messages are the only means of interobject communication, it is
in general impossible for an object to know exactly what another object is
remembering.  The only thing another object can count on is how an object will
respond to messages.  For example, an object representing a geometrical point
needs to remember where it is in order to have a point-like message behavior.
But from the outside it is impossible to tell whether the point is remembering
cartesian coordinates or polar coordinates or some other things that allow it to
answer messages about its location.

Objects and Classes

Much of a Smalltalk system consists of descriptions of how objects behave, which
means how they communicate with messages.  Even though it must be impossible to
tell what an object is actually remembering from outside the object, it is
obviously necessary to know this when creating the description of the object's
behavior.  The only thing possible for an object to remember is other objects
(since there is nothing else in the system).  The objects that an object
remembers are called its parts.  The parts of an object are not directly visible
from outside the object.  For the purpose of referring to objects internally,
each object has a unique object reference which is a 16 bit number.  The
internal representation of an object's memory is the set of object references of
its parts.

The objects in the Smalltalk system are partitioned into groups of similar
objects called classes.  The objects that make up a class are called instances
of the class.  The instances represent different occurences of the same kind of
thing in the system; for instance, integers, geometrical points, rectangles,
windows, documents, etc.  There are several kinds of similarity between the
instances of a class.  One similarity is that all instances of a class have the
same size memory; that is, they have the same number of parts.  The only
difference between two instances of the same class is the specific set of
objects that make up their parts.

The similarities of the instances of a class are described in an object.  Each
of these class describing objects has a title which indicates the function of
the instances it describes.  Class titles are typically capitalized, for
instance: Class Integer, Class Point, Class Rectangle, etc.  Since class
descriptions are objects, they must be instances of a class.  The class of class
describing objects is called Class Class.  We will refer to a collection of
instances as a class, and to the object that describes the instances as their
Class.  One of the functions of a Class is to give the number of parts in each
instance.

Messages and Programs

All objects are potentially active.  An object is actually activated when it
receives a communication from another object in the form of a message.  A
message is a set of objects which is naturally represented as a set of object
references.  What an object does when it receives a message is described in a
program.  The instances of a class share a set of programs that describe their
behavior on receiving messages.  The particular program that is executed is
determined by one of the objects in the message which is called the selector.
One part of a Class is a message dictionary which associates message selectors
with programs.  The other objects in the message are called arguments and are
availabe to the program that is associated with the selector in the Class'
message dictionary.  A program describes a general behavior which depends for
its specifics on the arguments in the message.  In some messages all of the
necessary communication is carried in the selector and so no arguments are
included.  Such messages consist of a single object called a unary selector.

A program is a description of some actions to be taken by the Smalltalk
interpreter.  The description of an individual action is called an instruction.
There are two types of action or instruction, state changes and message
transmissions.  A state change instruction directs the interpreter to replace a
specific object reference by another.  A state change instruction has two parts:

1) Where to find the object reference to change

2) What object reference to put there

A message transmission instruction directs the interpreter to send a message to
an object.  A message transmission will result in a new program being executed
by the interpreter.  A message transmission instruction has three parts:

1) Which object to send the message to (the receiver)

2) Which type of behavior to invoke in the receiver (the selector)

3) Further specifics of the behavior to be invoked (the arguments, which may be
absent for certain messages)

The stages in sending a message are:

1) A message send description is encountered in a program (the sending program).

2) The selector described in the instruction is looked up in the message
dictionary of the Class of the receiver described in the instruction, yeilding a
program (the receiving program).

3) The sending program is suspended and the receiving program is executed.

There are two forms of program in the system, symbolic programs which are
written by people and bytecode programs which are executable by the Smalltalk
interpreter.  The Smalltalk compiler translates symbolic programs into bytecode
programs.  In a symbolic program an instruction can refer to one of the
receiver's parts by using a name.  In a bytecode program an instruction must
refer to a part by its index in the receiver's internal representation.  Thus,
the compiler needs a mapping from name to internal index.  Since the mapping is
the same for all instances of a class, it is represented in the Class object.
If two instances of a class are sent the same message, they will run the same
program.  Where the program refers to one of the parts of an instance, the
actual object used will be different for the two receivers.

Thus far we have encountered three things shared by all instances of a class and
stored in their Class:

1) A title.

2) A message dictionary which maps message selectors to bytecode programs.

3) A set of names which can be used in symbolic programs to refer to the
instances' parts.

Superclasses

The classes of the Smalltalk system are heirarchically structured.  Each class
is a subset of another class which is called its superclass.  The classes that
have any one class as their superclass are referred to as its subclasses.  A
class can have many subclasses but only a single superclass.  The only class
that has no superclass is the class of all objects which is described by Class
Object.  A class defining object, or Class, acts as a filter on the Class of its
superclass.  The Class inherits all of the descriptions in its super-Class but
may add any new ones or change certain of the old ones.

The nature of the filtering provided by a sub-Class is different for the three
things found in a Class:

1) A new title must be provided for the subclass.

2) Programs for selectors not found in the superclass may be added to the
message dictionary or new programs for selectors found in the superclass may
replace the old programs.

3) New part names can be added but old part names remain the same.

Collection Objects

An object is a set of parts that represents something in the Smalltalk system.
Each of the parts has a specific function in the object's behavior. ...

The Smalltalk Virtual Machine

A virtual machine is a set of entities which can assume certain states.  The
program interpreter associated with a particular virtual machine is capable of
accessing and changing the state of these entities.  The Smalltalk virtual
machine consists of an object memory and a context register that contains an
object reference.  The instruction set that the program interpreter executes
includes a variety of ways of changing certain parts of the object memory's
state found relative to the context register's contents and two ways of changing
the context register's contents. (Question: what to say at this point about the
parts of the Nova virtual machine that are used by the primitives?)

The Object Memory

The vast majority of the state found in a Smalltalk virtual machine is in the
object memory.  The function of the object memory is to provide an internal
representation for the objects in the system.  An object is an instance of a
class and a set of specific parts.  Each object has a unique object identifier
which is a 16 bit number.  The object memory is an entity that associates an
object's object reference with:

the object reference of the Class that represents its class and

the object references of its parts.

So, in general, the object memory is a mapping from a 16 bit number to a set of
16 bit numbers.

The program interpreter can directly perform three types of operations on the
object memory:

1) What is the object reference of the Class of object obj.

2) What is the object reference of the ith part of object obj.

3) Make the object reference of the ith part of object obj be the object
reference for object newobj.

The Context Register

In a Smalltalk system there is always an object known as the current Context.
The entity that implements this is the Context register which holds the current
Context's object reference.  The current Context gives the interpreter access to
the executing program, to the variables the program is using in that execution
and to a stack.  The execution of Smalltalk programs is stack oriented in two
ways.  First, when programs call other programs, the calls and returns happen in
a stacklike fashion.  Second, as theb general descriptions in the programs are
translated into the specific objects used in the actions, these objects are kept
on a stack called the execution stack.  The call-return stack is basically a
stack of Contexts, the top of which is pointed to by the Context register.  Each
Context has its own execution stack for use by its program.



Sending a Smalltalk Message

The process of sending a message begins when the interpreter encounters a send
message instruction in a program.  The instruction describes a message which
consists of a receiver, a selector and possibly some arguments.  The first thing
the interpreter does is translate the description of these objects into the
actual objects that make up the message.  Usually, sending a message invokes a
new program which is determined by the receiver's class and the selector.  The
interpreter finds the appropriate program and creates a new Context to represent
its execution.  The program uses the rest of the message in its execution.  The
new Context becomes the current Context and the interpreter begins executing its
program; the message has been sent.  The last action taken by the new program
will be to resume execution of the program in which the send message instruction
was found.

Translating Instruction to Message

A send message instruction is a sequence of two or more sub-instructions, one
for each of the objects that make up the message.  The first sub-instructions
describe any arguments of the message.  These are followed by a sub-instruction
that describes the receiver and one that describes the selector.  The
sub-instructions that describe arguments and receivers are called object
descriptors.  The sub-instruction that describe selectors are called selector
descriptors.  The simplest message is a selector sent to a receiver; it has no
arguments.  The instruction that describes such a message is simply an object
descriptor for the receiver followed by a selector descriptor.

There are several types of object descriptor sub-instruction which will be
discussed in a later section.  The effect of executing any object descriptor is
to push the object described on a stack The stack is part of the executing
program's Context.  The simplest types of object descriptors are single bytes
that tell where the object to be pushed can be found relative to the Context of
the program.  For example, a byte might say "push the second field of the
Context" or "push the third field of the object pointed to by the second field
of the Context".  The selector is always found in a part of the program called
the literal frame.  The selector descriptor is a byte that tells where in the
literal frame the selector is.  When the selector descriptor is encountered it
signals the end of the send message instruction.  The receiver will be the top
object on the stack and the arguments will be immediately below it.  The message
has been assembled.

Translating Message to Program

The assembled message is now sent by performing the action it indicates.
Usually, this action is accomplished by executing a Smalltalk program.  The
exception is for messages that invoke primitive actions which will be discussed
later.  The selector of the message is used to choose a program from a
dictionary found in the Class of the receiver.  All the instances of a
particular class will execute the same program when they receive a message with
a particular selector.  After the interpreter selects the program to execute, it
sets up a new Context.  The Context keeps track of the progress of the program's
execution and it gives the program access to the receiver and arguments of the
message.  After the new Context is initialized, it is installed in the current
Context register.  Since the interpreter always finds its next instruction
relative to the Context pointed to by this register, the new program will now be
executing.

The new Context has references to the following objects:

1) The new program

2) The location of the next instruction to be executed in the program

This is initialized to be the first instruction in the program.

3) The receiver of the message

4) The arguments of the message

5) A set of temporary locations that will be used by the program during its
execution

These are initialized to nil.

6) The stack that the program uses in its execution

The stack is initially empty.

7) The Context that represents the program that invoked the new program.

This is initialized to from the current Context register before the new Context
is stored there.  This part of a Context is called its sender.

Translating Program to Actions

When the new Context is stored in the current Context register, the interpreter
begins executing its program's instructions.  There are four types of
instructions found in programs:

1) Message send instructions

2) Message response instructions

3) State change instructions

4) Branch instructions

A message send instruction results in a transfer of control to another program
as described in this section.  The state change and branch instructions do not
result in a change of the executing program.  These instructions will be
discussed in the next section.  A message response instruction ends a program's
execution by transfering control back to the program that invoked it.  This is
accomplished by storing the sender of the current Context into the current
Context register.  The program interpreter will execute instructions in the
program, advancing the Context's pointer to the next instruction in the program.
Whenever a message send instruction is encountered, the program stops executing
and a new program executes.  That new program will eventually encounter a
message response instruction and the original program will continue.  Finally,
the original program will encounter a message response instruction and it will
stop executing by returning to its sender.  The message response instruction
describes a value to be returned to the sender's program.  This return value is
pushed on the sender's stack.



Smalltalk Programs

The last section described how a Smalltalk program is executed when a message is
sent.  The program describes some actions to be taken in a Smalltalk system.
These actions are actually performed by a part of the virtual machine called the
program interpreter.  This section describes the form of the programs that the
interpreter executes.  A program has two basic sections.  The header contains
some general information used in creating a Context to represent this execution
of the program.  The rest of the program consists of instructions which the
interpreter executes.  These instructions are composed of sub-instructions which
are themselves composed of bytecodes.

Object Descriptors

The most common kind of sub-instruction found in a program's instructions is the
object descriptor.  For instance, the form of a send message instruction for a
message of one argument is

<object descriptor><object descriptor><selector descriptor>

An object descriptor describes an object which we will call its referent.  to be
pushed on the execution stack that is found in the program's Context.  There are
two kinds of object descriptor, both discussed in the last section on sending
Smalltalk messages.  The simplest form of object descriptor is one of the single
bytecodes that describe to the interpreter where to find the object to push on
the stack.  These are called the push bytecodes.  The other form of object
descriptor is a send message instruction.  The send message instruction
qualifies as an object descriptor since the value returned from the program the
message invoked is pushed on the stack.


Draft 0 Smalltalk: Dreams and Schemes Chapter IV June 1, 1979 Status: Needs
examples to be completed, needs better subclassing example before getting into
hierarchical numbers and needs to provide definitions for those data structures
introduced in Chapter III.  Will probably also do something about use of the
word "field".



IV

Class Class, Subclassing, and Determination of Method





We begin with a review of the kernel notions of Smalltalk as introduced in
Chapter II.  We then describe a special object, the object that represents
classes of objects, class Class.  In the Smalltak language, a class can be
declared to be a subclass of another class and thus inherit all the traits of
that superclass.  Every class is ultimately descended from the class Object.
Following an explanation of these two special objects, we explore the problems
of determining the proper response to a message given this hierarchical
organization of objects.

The Class Class

The two fundamental principles of the Smalltalk design are that all of the parts
of a system be represented in the same way and that they all interact or
communicate in the same way.  We have adopted the name object to refer to the
uniform representation for the parts of a system and the name message sending to
refer to their uniform method of interaction.  An object is an independent
activity that maintains its own state and communicates on its own terms with
other objects.  Therefore, it has the properties of a complete computing
machine.  Objects are grouped into classes according to their function; the
objects of a class are called its instances.

Since these classes are fundamental parts of the system and since all parts of
the system are represented uniformly as objects, it is natural that there are
objects that represent the classes.  These objects that represent classes of
objects form a class themselves since they all perform the same function; the
name of the class is naturally Class.  The object that represents this class of
objects (i.e., Class) has the interesting property of being a member of the
class it represents.

Every object knows its class; its class may be thought of as an implicit part of
the object's state.  In Smalltalk-76, it is not possible to change the class
membership of an object.

An Archetypal Class: Dictionary

For the sake of the discussion in this chapter, reference will often be made to
a class we call Dictionary.  A dictionary associates with each of a set of
objects a corresponding value.  It can tell what value is associated with a
given object and can insert, delete, and change associations.

A particular instance of class Dictionary might contain the following five
nonsensical associations:

objects	values

'six'	6
'twelve'	12
'+'	'plus'
'Fastalk'	'slow'
'Smalltalk'	'fast'

Let us examine this instance from the two viewpoints described in Chapter II,
the internal viewpoint of its representation or memory, and the external
viewpoint of its message protocol.  We will then examine methods, the link
between the two.

From the internal viewpoint, an instance of a class is made up of the parts that
specify its state.  One of these parts is a reference to the class.  Other parts
determine properties that distinguish this instance from other members of the
class; these conceptually form a dictionary, the state or property dictionary,
that consists of the names of the parts and their current values.  We call each
item in the property dictionary a field.

<==<chapter4-1.press<








Figure 4-1.	An instance references its class and contains a property
dictionary.

From the internal viewpoint, an instance of class Dictionary is composed of two
fields called objects and values.  Both fields reference lists whose lengths are
the same power of 2.  If each list has a length of, say 8, and the dictionary
has 5 associations, then 3 of the locations in each list will be vacant.  Vacant
locations are represented by a reference to the special constant nil.

From the external viewpoint of another object wanting to access a dictionary,
its fields can be reached only indirectly, by sending messages to the instance.
For example, if dict is our sample dictionary, then one can send a "look-up"
message to the dictionary with the Smalltalk expression

dict lookup: 'twelve'

and the value returned will be 12.

To support the external viewpoint of a class, each class consists of a message
dictionary, a sequence of pairs of message patterns and methods.  Basically,
when a message is passed to an object, Smalltalk selects a method to execute by
looking up the message in the object's message dictionary.  If the object is an
instance of a class, the correct message dictionary is the one found in the
definition of the class.  If the look-up operation is successful, then the value
obtained is a method to be executed.  This execution takes place in the context
of the property dictionary of the object, that is, fields that are mentioned in
the method refer to the values in the property dictionary of that instance.

<==<chapter4-2.press<












Figure 4-2.	The message dictionary is in the class definition.

From the external viewpoint, it is not essential to know that a dictionary is
represented by a pair of lists and that their length is a power of 2.  If class
Dictionary were redefined to use a different representation, and if its methods
were modified appropriately, then all other methods that use dictionaries would
continue to function.

In creating a class, the fields are named; in creating an instance, the property
dictionary is automatically set up, providing an item for each named field.

The Pseudo-Variable self

[might move this to Chapter II, depends on Chapter III's needs]

Some standard pseudo-variables are provided automatically to every method.  They
cannot be assigned values by the method.  The most important one is self, the
instance whose method is being performed.  An object can send itself a message
by addressing it to the pseudo-variable self.

[example]

The Class of Classes

Since a class is the one place where detailed representation of its instances is
known, it is the natural source of new instances.  To create a new rectangle,
send the message new to the class Rectangle; to create a new dictionary, send
the message new to the class Dictionary.  Now a very nice aspect to the class
formalism is that it folds back on itself in a way which allows the higher level
of creation to be described without introducing any new concepts.  Each
class--Door, Point, Rectangle--is itself an instance, having as its local
properties the representation and behavior of its instances.  There is, of
course, a class to which these classes belong--class Class--and in that class is
stored the description of how a class is represented, what messages it
understands (such as new), and how the responses are implemented.

As already stated, a new instance of a class is created by passing its class the
message new.  That is to say, and as we would expect, the class itself is an
object to which we can send messages.  The class responds to the message new by
allocating the property dictionary for the new instance, initializes each value
in the dictionary to a standard constant nil, and returns the object.  Usually
the new object is then passed additional messages to initialize it fully.

The message dictionary for class Class, and therefore messages to which all
class objects can respond, include:

[...choose representative messages--do not be complete here


defining the object

fields: myinstvars declare: v rename: newtitle sharing: table subclassOf:
superclass title: title title: t subclassOf: s fields: f declare: d edit:
selector para: para formerly: oldpara canUnderstand: selector install: name
method: method literals: literals code: code backpointers: backpointers
understands: code

execute: code

identifying the object

Isa: x "is x on my superclass chain?"  print: inst on: strm filout

creating an instance

init init: n new new: length

]

Activations

Each method can declare temporary variables that can be used during the
execution of the method.  These variables are destroyed automatically when the
method execution is terminated.  The syntax for defining methods in Smalltalk-76
is detailed in the next chapter.  Suppose for now that the message dictionary of
the class Dictionary contains the message pattern growby: size and that the
method for growing (increasing) the length of the list objects, an instance
variable of Dictionary, uses a temporary variable copy.

If we send a message such as cust growby: 5, where cust is an instance of
Dictionary, a new object that we call an activation is created.  This new object
contains a dictionary for storing the names and values of the temporary
variables of the method that is currently being executed.  The precise
description of this object is provided in the Chapter V section on program
execution.  For now it is sufficient to know that the Smalltalk-76 system
supports four kinds of object variables in the creation and use of objects:
pool, class, instance, and temporary (or method).  Pool variables are those
shared among classes; class variables are those shared among instances of a
class; instance variables are known only to the individual class member; and
temporary variables provide the extra storage requirements when running a
method.



<==<chapter4-3.press<








Figure 4-3.	This activation for an instance of class Dictionary requires
space for one temporary variable.  The instance holds the dictionary of instance
variables.


Subclasses

When several classes implement the same protocol, i.e., respond to the same
messages, they may or may not employ the same methods to do so.  If it happens
that the same methods are employed, it would be awkward to have to repeat their
definitions in each class.  Therefore, a limited facility for sharing method
definitions among classes is provided.  A class may have subclasses.

Take as an example the class, HashSet.  A hash set is a set of objects that are
usually of the same class.  No object appears more than once in such a set.  A
hash set can tell whether a given object is present and can insert and delete
objects.

Class Dictionary can be implemented as a subclass of class HashSet; a dictionary
associates a value with every object in the hash set.  A hash set has only a
list objects as a field; it has no list values.  And so there is no message like
lookup: name.  However, there is a find: obj message that returns the location
of obj in the list objects.  Therefore, class Dictionary need not define a
method for the find: obj message; it inherits one from HashSet.  It also
inherits the field objects, so the class definition need only mention the field
values.


<==<chapter4-4.press<












Figure 4-4.	Class Dictionary is a subclass of class HashSet.  The property
dictionary of an instance of Dictionary contains fields from both classes; the
instance can respond to messages found in the message dictionary of either
class.

This ability to form a subclass is inherited by each class.  Thus it would be
possible to create Dictionary as a subclass of HashSet, and then to create a new
class, DataDictionary, as a subclass of Dictionary.  Both Dictionary and HashSet
would be superclasses of DataDictionary.  An individual class might have several
subclasses.

In Figure 4-5 we show a class Customer in its class hierarchy with HashSet and
Dictionary.  Note the addition of a "declare" part, a dictionary in which we
store information shared among all members of the class.  Now suppose cust is an
instance of class Customer.  Then cust can understand the message growby: 5
because the message pattern growby: size can be found in the message dictionary
of a superclass of Customer.


<==<chapter4-5.press<


















Figure 4-5.	The class Customer is a subclass of Dictionary.  The property
dictionary of its instance contains five items, one for each field in Customer
and its superclasses.  its methods can also refer to a variable instCount, a
property shared among all customer objects.

Order of Method Determination

When an instance of class Dictionary is created, it references its class as
described earlier.  Its class, in turn, references its superclasses.  The
property dictionary of the new instance consists of all fields from the class
and its superclasses.  The instance can respond to any message found in its
class or one of its superclasses.  In looking up a message, Smalltalk first
checks the message dictionary of the object's class.  If not found in the class,
Smalltalk looks for the message in the superclasses, in hierarchical order.  If
the same message is provided in several message dictionaries, the first one
found determines the method to be executed.

If a method contains a statement in the form of sending a message to the
pseudo-variable self, that variable refers to the currently running instance,
regardless of where in the hierarchy of message dictionaries the method is
actually located.  As an example, take the definitions for HashSet and
Dictionary.  And suppose we send a message of the form lookup: name to a
dictionary; the corresponding method is to find the position in the list objects
of the object whose name is name, and then return the value located in the same
position of the list values.  The first step, then, is for the instance to send
itself a message to find name.

self find: name.

The search for the appropriate method to run begins in the message dictionary of
the class of the instance, in this case, Dictionary.  It is not found.  The
search continues by looking at the first superclass, HashSet.  The search
succeeds and a method is executed.  Suppose further that the method for messages
of the form find: obj contains the statement

self findornil: obj.

Here we assume that the actual work of searching the list is carried out in the
method associated with the message pattern findornil: obj.

What is the order of searching for this message pattern?  The pseudo-variable
self refers to the running instance.  Therefore the search begins with the class
of the instance: the search begins in the message dictionary of Dictionary.  In
this case, we are assuming that no message pattern for findornil: obj is in
Dictionary, so the search continues with the class HashSet, where it will be
found.

We will provide further examples of method determination later.

The Pseudo-variable super

The pseudo-variable super is, like self, provided automatically to every method.
A message sent to super goes to the currently running instance with the caveat
that the message-dictionary lookup starts at the superclass of the class whose
method is being performed, instead of at the class of self.

Suppose it is desired to create DataDictionary, a subclass of class Dictionary;
its purpose is to add the ability to count the number of look-up accesses to the
dictionary.  The new subclass adds the field count and then defines the message
lookup: name as follows.

lookup: name 	count _ count + 1.
	 super lookup: name.

The message pattern of this message is the same as the one we examined for the
class Dictionary.  The method consists of two statements (as written in the
syntax of Smalltalk-76).

	count _ count + 1.

The count of accesses to the dictionary is first incremented by one.

	 super lookup: name.

Control is passed to the superclass in order to perform the actual search of the
name in the dictionary.  The pseudo-variable super refers to the running
instance, but indicates that the search for the message pattern should skip
DataDictionary, the class, and begin with the first superclass, Dictionary.

In sending a dataDictionary the message lookup, Smalltalk will examine the
message dictionary of the class DataDictionary before that of Dictionary; so the
above method would be executed for any instance of DataDictionary.  Instances of
Dictionary continue to respond to the lookup message as before.

<==<chapter4-6.press<

















Figure 4-6.	DataDictionary is a subclass of Dictionary.  It reimplements the
response to the message lookup.  Its instances add an item, count, to the
property dictionary.

The Class Object--Hierarchical Inheritance

A class, then, can be declared to be a subclass of another class and thus
inherit all the traits of that superclass.  The subclass can add traits and
behavior of its own, can override those messages it wishes, and can still invoke
the overridden ones from within its code (using the pseudo-variable super;
recursion is effected by using the pseudo-variable self so that the object can
send itself messages).  This inheritance capability leads to a highly factored
system.

Every class is ultimately descended from the class Object, and inherits from
that superclass such behavior as is common to all objects of the system.  A
default description of how an object would print itself as text is given in
class Object, so that as soon as one creates a new class, its instances will
already be capable of printing themselves in a useful way.  Only occasionally is
it necessary to override this default and provide a refined rule for printing.

The message dictionary for class Object, and therefore messages to which all
instances can respond, include:

The following is part of the message dictionary for class Object.

sameAs: object	are self and object the very same object?
class	to which class do I belong?
is: x	am I a member of the class x?
Is: x	is the class x a superclass or class of me?

copy	return a copy of me

print	print a representation of me on the display screen
printon: strm	print a representation of me on device strm

The Classes Object and Class

Class Class and class Object exist as part of the kernel Smalltalk system.  The
existence of each of them is totally intertwined with the existence of the
other.  Every object is ultimately a subclass of the class Object; every class
is an instance of class Class.  This means that Class is a subclass of Object,
while Object and Class are instances of class Class.  Object is the only class
in the system that has no superclass.

In the following figures, the relationship notation we use consists of two kinds
of arrows.

<==<chapter4-7.press<	[use color red here] This is a creation link; it denotes
that the object nearest the circle end of the arrow is an instance of the object
to which it is linked.

[use color blue here] This is a link for behavior descriptions; it denotes that
the object nearest the circle end of the arrow is a subclass of the object to
which it is linked.

Thus the objects in the kernel Smalltalk system are related in the following
way.

<==<chapter4-8.press<



This figure emphasizes that Class is an instance of itself.  It is the only
object in the system so related.  Notice also that in this and subsequent
figures all objects have either a single creation link or both a creation and a
behavior-description link.

Determination of Method

A message dictionary is the specification of potential behavior that is found in
a class.  It is possible to create instances of a class; in particular,
instances of class Class are themselves classes.  The potential behavior of
these instances is found in the message dictionary of class Class.  In the next
figure, we show a new object named Array.  It is an instance of Class and is
therefore a class; it is a subclass of Object.  This new object is created by
first sending the message new to the class Class.  The new object, an instance
of Class, is then sent the message title: 'Array' subclassOf: Object.  The
message dictionary of Class contains the message patterns new and title: name
subclassOf: superclass.

Class new title: 'Array' subclassOf: Object.

<==<chapter4-9.press<








An instance, here Array, can understand any message found in its class or one of
its superclasses.  In order to understand the determination of the potential
behavior of the instance, we form a composite message dictionary for the
instance in the following way.  (1) All messages and their corresponding methods
found in the message dictionary of the class and all the superclasses belong in
the composite message dictionary.  (2) Any conflicts that occur because two
classes, a subclass and one of its superclasses, have identical message
patterns, is resolved by choosing the method found in the subclass.

The composite message dictionary for an object will be represented in the
figures as a box containing the names of the object's class and all its
superclasses, ordered with the class at the top.  These are the classes from
which the messages and associated methods in the composite message dictionary
are determined.  Note that this means that the box packages classes linked
together by the subclass relationship, starting with the class that is linked to
the object by an instance relation.

As an example, suppose we want to evaluate the expression Array new.

The receiver is Array.  The message is new.  The composite message dictionary
comes from

			<==<chapter4-10.press<


The message is understood; the method is found in the message dictionary of
class Class.

Creating Instances of a Class

Because instances of class Class are themselves classes, it is possible to
create instances of them.  The message new is used for this purpose.  The
potential behavior of each instance is found in its composite message dictionary
as described above.  For example, suppose we have created mat as an instance of
Array.  And then we evaluate the expression mat length, noting that the message
pattern length is located in the message dictionary of Array.

<==<chapter4-11.press<


Suppose we now try to evaluate the expression mat new.  We note that none of the
classes used to form the composite message dictionary for the instance mat
includes new as a message.  So the result of evaluating the expression is the
error message: mat does not understand the message new.

Subclassing the Class Class

Instances of a subclass of class Class are themselves classes.  An example might
be to create the class RecordClass.

Class new title: 'RecordClass' subclassOf: Class

The objects in our system now include

<==<chapter4-12.press<













Notice that RecordClass is both an instance and a subclass of class Class.  The
composite message dictionary for RecordClass contains messages and methods from
Class and Object.  One message pattern is title: name subclassOf: superclass.
Suppose we place the same message pattern, but associated with a different
method, in the message dictionary of RecordClass.  Then create TimeCard as an
instance of RecordClass by evaluating the expression

RecordClass new title: 'TimeCard' subclassOf: Object

<==<chapter4-13.press<











The message RecordClass new creates an instance of RecordClass, itself a class.
The new object, in turn, is sent the message title: 'TimeCard' subclassOf:
Object.  (Note the convention of capitalizing titles assists in recognizing the
object as one able to have instances.)  The composite message dictionary for an
instance of RecordClass comes from

<==<chapter4-14.press<



The method associated with the message pattern title: name subclassOf:
superclass is the one specified in RecordClass, not the one originally specified
in Class.

Collection Classes

Instances of class Class are classes whose instances have the exact same number
of fields.  However, Smalltalk-76 includes a Collection class, a subclass of
class Class; its instances are classes whose instances can have differing
numbers of fields.  Without this capability to create instances with varying
length property dictionaries, it is necessary to implement lists as linked
lists.  Hence for efficiency purposes, a class Collection was added to the
system.  (For more detailed discussion of this implementation consideration, see
Chapters III and V.)

Class new title: 'Collection' subclassOf: Class

<==<chapter4-15.press<









The message dictionary of this new class object, Collection, contains the
message patterns new and new: length.  The method for the first, new, takes
precedence over the method found in the class Class; its purpose is to report an
error because instances of Collection must be created with an argument
specifying the number of fields in the instance.  The second message, new:
length, provides the mechanism for creating an instance of Collection, a class
whose instances can have varying length property dictionaries; the number of
entries in the state dictionary is specified as the parameter length.

We now create an instance of class Collection we call Vector.

Collection new title: 'Vector' subclassOf: Array

In the above, the first part of the expression to be evaluated is Collection
new; the receiver is Collection, the message is new; and the composite message
dictionary comes from

<==<chapter4-10.press<



So Vector is created as a class that is an instance of Collection.  It is itself
a class and, as expected, ultimately a subclass of Object.

<==<chapter4-16.press<













For the sake of clarity, let's review this notion of method determination with
an example using Vector and Array.  We place in the message dictionary of Array
the message new, and define its method to simply print the statement, 'message
new was found in class Array'.  Try to evaluate the expression

a _ Array new.

The receiver is Array; the message is new; and the composite message dictionary
is

<==<chapter4-10.press<


The expression is successfully evaluated; since the message new was found in
Class, the above statement does not print.  Rather, a new instance of Array is
created; it is referred to by the identifier a.  Now evaluate the expression

a new 

<==<chapter4-17.press<












The receiver is a; the message is new; and the composite message dictionary for
an instance of Array comes from

		<==<chapter4-18.press<



The result is that the message new is found in Array and, so, the statement
'message new was found in class Array' prints.

Now try

vec _ Vector new.

The composite message dictionary for Vector comes from


<==<chapter4-19.press<



The method for responding to the message new was determined in the message
dictionary of Collection; the result is the error message specified in the
method.

Try

vec_ Vector new: 5.

Again the method was determined in Collection; the result is a new instance of
class Vector whose state dictionary is five entries long.

Now suppose we create a subclass of Vector that we call VecSC.  Since we want it
to be a class whose instances can have varying length property dictionaries, we
create it as an instance of Collection, not of Class.

Collection new title: 'VecSC' subclassOf: Vector

<==<chapter4-20.press<















The composite message dictionary for sending messages to VecSC comes from

	<==<chapter4-19.press<



So the response from the message new to VecSC is an error message; the response
from new: 4 to VecSC is to create an instance of VecSC.  Suppose the instance is
vs.  Then it can understand the message length.  The message new results in our
message 'message new was found in Array'; a new instance of vs is of course not
created.  The composite message dictionary for vs comes from

	<==<chapter4-21.press<





Summary

Any subclass of class Class has the ability to create instances of itself that
are themselves classes.

An instance of class Class is a class; it can create an instance of itself.
This second instance is not a class and cannot create instances of itself.

When a new class is created, it is given both an instance relationship to a
class and a subclass relationship to a class.  An instance is given only an
instance relationship to a class.

A message goes first to the class of the designated receiver; the class is
determined by an instance relationship.  Then, if not found in the message
dictionary of that class, the message goes to each of the superclasses, in turn,
as determined by subclass relationships.

The subclass relationship is provided mainly for purposes of saving space and
adding flexibility of information sharing.  Conceptually, when a new object is
created, its message dictionary is initially the composite message dictionary
formed by taking the message dictionaries of the object's class and
superclasses, in order.  Then there is no such notion as "overriding a message"
-- the message is in the dictionary and the correct method completely replaces
the one already there.  We would also have to deal with the pseudo-variable
super differently, if at all.  Because of the space saving requirement and
because we want to benefit directly from any changes in the superclass, we
physically do not form the composite message dictionary, not at the time of
creating an object nor at the time a message is sent.  Rather, we trace through
the subclass hierarchy, searching message dictionaries for the individual
classes.

There are No Explicit Type Declarations

It is possible that instances of several classes are able to respond to the same
message.  To the extent that two or more classes share that ability, it is said
that they implement the same (message) protocol.  A given class may have part of
its protocol in common with one class and part in common with another.

To send a certain message to an object, the object must be of the "right type";
that is, the object's class must be able to respond to that message.  Although
the notion of class is formalized in Smalltalk, the notion of type is not.
Types are not declared nor even named.

In Smalltalk, as in LISP and APL, a given variable may reference an object of
any class and of any type.  Therefore, if a programming error causes an
unintended object to be assigned to a variable, the error is not detected when
the program is compiled, nor even when the assignment occurs, but somewhat later
when an uncomprehended message is sent to the object.

The absence of type qualification has its benefits.  It permits the notation to
be more concise, and it enables old programs to operate on instances of new
classes, to the extent that those classes follow old protocols.  Moreover, it
facilitates the availability of a small, reliable, and easily extended resident
compiler, thereby permitting direct execution of expressions both for debugging
methods and for invoking them.

Examples

<some simpler examples to redo the data structures of Chapter III's sysdefs
before striking with hierarchical numbers>.

Example: Hierarchical Numbers

The subclass organization also expands the utility of the type-independent
property of Smalltalk code.  For example, the superclass Number implements the
messages

   min max

In terms of the basic comparisons, < =, and >.  Consequently, after defining
only the basic comparisons, any new subclass of Number can respond to the full
numerical protocol.  Other messages in the superclass Number, such as the infix
 (which creates a Point) and to:by: (which creates an Interval), similarly
allow coordinates of Points, and limits of for-loop ranges to be FloatingPoint,
Fraction, or any other kind of Number.

There are several ways one could structure a hierarchy of Number classes.  One
is:

Number

Complex (a subclass of Number)

Real (a subclass of Complex)

Rational (a subclass of Real)

Integer (a subclass of Rational)

Natural (a subclass of Integer)

Bit (a subclass of Natural)

This structure has pleasant mathematical properties.  The potential instances of
each class are a proper subset of the potential instances of its superclass.
But this structure has two serious difficulties.  Class Complex is most
naturally implemented with two Real fields, rPart and iPart.  However, we do not
wish these fields to be inherited by subclasses such as Real and Integer.
Furthermore, instances of class Real in a computing machine are really just
approximations, and don't deserve to be called "Real".

Both difficulties can be surmounted by considering the classes named above to be
abstract classes.  An abstract class is a class that has no property dictionary
and no instances.  An abstract class provides a conceptual framework and a
message dictionary that its subclasses can all share.

This idea leads to another hierarchy.  In the table below, each abstract class
is so noted, and each concrete class is followed by the names of its fields and
the expected class of the value of each field.  Class Bit is concrete, but needs
no fields because its only requirement is that its two instances (0 and 1) be
distinguishable.  The nesting defines the levels of subclassing as indicated in
the first example.

Number (abstract)

Complex (abstract)

CartesianComplex (rPart [Real], iPart [Real])

Real (abstract)

FloatingReal (mantissa [Integer], exponent [Integer])

Rational (abstract)

RatioRational (numerator [Integer], denominator [Natural])

Integer (abstract)

SignedInteger (sign [Boolean], magnitude [Natural])

Natural (abstract)

BinaryNatural (digits [Bit Array])

Bit

The advantages of this hierarchy are suggested by the following example.  Class
CartesianComplex would have messages rPart and iPart that returned the
appropriate field of the instance.  In class Real, the message rPart would
return a reference to itself and iPart would return 0.  Thus, all classes in the
hierarchy below Complex would automatically respond properly to messages iPart
and rPart.

To handle mixed-class arithmetic, let each class respond to a message level by
returning its level in the hierarchy.  A useful set of levels might be:

7	Number
6	Complex and CartesianComplex
5	Real and FloatingReal
4	Rational and RatioRational
3	Integer and SignedInteger
2	Natural and BinaryNatural
1	Bit

When the level changes, it is because the subclass over-rides the level message
of its superclass.  Thus CartesionComplex inherits its message from its
superclass Complex, whereas Real does not.

Each class must also respond to a message upLevel by returning an equal instance
of a class one step higher in the hierarchy.

To handle unmixed addition, each concrete class would have a method 'plus: x'
that was implementation-dependent and that required x to be of the same class.
To handle mixed addition, class Number would have a message '+ x' that allowed x
to be of any class.  Its method would work as follows:

+ x		compare my level with the level of x

if equal, reply by sending myself the message plus: x

if less, reply by sending myself the message + with the result of sending x the
message uplevel

if greater, reply by sending myself the message upLevel and then adding the
result to 3)

Analogous techniques would be used for other arithmetic operators.  Of course,
various improvements can be made, such as having direct conversion between
levels instead of the one-step-at-a-time approach used above.

Although this approach is elegant, it is in practice inefficient for a number of
reasons.  In particular, arithmetic on relatively small integers is a frequently
performed operation in all computing.  The approach here requires at least the
following messages to be passed around in order to add two small integers:

Number +

Natural level

Natural level

Natural equals: Natural

Natural plus: Natural

Array length

.. and several times each:

Array sub: Natural

Bit sum: Bit withCarry: Bit

Bit carry: Bit withCarry: Bit

Therefore, a practical Smalltalk system should make compromises in the
structuring of the number hierarchy.  Classes Bit and Natural are probably
superfluous on a word-oriented machine.  Class SignedInteger should have a
companion class at the same level called ShortSignedInteger that represents the
most commonly used integers in a single machine word in the representation
expected by the hardware adder.  This leads to a change in the hierarchy:

Rational (abstract)

RatioRational (numerator [Integer], denominator [Integer])

Integer (abstract)

SignedInteger (sign [Boolean], magnitude [Array])

ShortSignedInteger (a single machine word)

ShortSignedInteger should have its own message for '+ x' implemented in the
kernel system as follows:

+ x		is x 's class also ShortSignedInteger?

if so, do the addition in the implementation machine if not, invoke the 'Number
+ x' method

In the most common case of adding two instances of ShortSignedInteger, no method
other than ShortSignedInteger + need be invoked.  The class check can be done by
the kernel directly since it must have access to the class of each object
anyway.


Draft 0 Smalltalk: Dreams and Schemes Chapter VI May 11, 1979



VI

Technical Characteristics of Smalltalk-76





Since the first Smalltalk was outlined in 1972, we have produced four
implementations of significance (over 1000 hours of use each) on several
different hardware systems.  To varying degrees, the language has supported the
object-oriented framework, always making it possible for us to explore the
nature of a useful and usable personal computing environment.  The language
kernel that is defined in this chapter was proposed in 1976 after several years
of design and trial implementation.  We have thus termed the language,
Smalltalk-76.  We have separated the description of this particular language
kernel, as provided in this chapter, from those of earlier and later Smalltalks:
the history of implementations can be found in Chapter X; discussion of user
interface issues is provided in Part 2; all of Part 3 is devoted to the future.

System Layering: A Review

The system can be viewed as consisting of several layers, each built on the
lower layers.  At the bottom is the implementation machine, a set of
interconnected physical devices.  On this is built a kernel system that provides
the essential functions of Smalltalk: the creation and maintenance of objects
and their interaction by exchanging messages.  The kernel of Smalltalk is an
extensible system made up of objects organized into classes.  It includes
objects called classes that create and maintain other objects, objects called
methods that describe the interaction of objects and objects called activations
that perform the interaction described by methods.  A method is a sequence of
message descriptions and/or descriptions of transformations of state
information.  Note that we use the word "method" to avoid connotations
associated with the more traditional "program" or "procedure".  These
objects--classes, methods, and activations--make it possible to bootstrap the
behavior of other objects since these other objects can be created by a class;
they then can have any kind of behavior as the result of an activation
performing a method that describes that behavior.

The next level of the system is a basic system that provides certain
conveniences for interacting with objects and for describing new kinds of
objects.  In specifying the basic system, we choose a syntax for expressions and
for the ways in which methods are built from expressions.  The basic
Smalltalk-76 system includes a compiler and graphical facilities for handling
user interactions.  Additional objects provided in the basic system include
class Dictionary; class Number, with its subclasses Integer and Float; and class
Array, with its subclasses String, UniqueString, and Vector; and, to support
user interaction on a display screen, the classes Point, Rectangle, and
UserView.  A number of classes exist in the basic Smalltalk-76 system in order
to support the compiler; they are presented in the next chapter on compiling
methods (Chapter VII, Encoding).  Descriptions of classes for user interactions
are given in chapters in Part 2.

Program execution was dealt with in Chapters II and IV; we concentrate here on
the kernel and basic Smalltalk-76 systems.  In the next sections, we provide a
definition of the syntax of Smalltalk-76 with simple examples.  More extensive
examples are found in Chapter ViII.

The Kernel System

As described above, the kernel system consists of classes, instances, methods,
and activations.

An Example Method

A class only understands a message that has been included in its message
dictionary, i.e., a message for which a corresponding method has been specified.
For example, class Dictionary employs the following method to respond to lookup
messages.

lookup: name | x

[x _ self find: name  [ values  x]  false]

Smalltalk-76 is easier to discuss if the special characters are pronounced as
follows.

:	(silent)
|	with temporary variables [ begin
]	end
_	gets
	then only
	return value
	subscripted by or sub

A method begins with a message pattern, in this case, lookup: name.  The colon
character (:), which is not pronounced, indicates that an argument follows,
i.e., name.  There is also a temporary variable called x that is not an argument
but is used within the method to assist its execution.

The body of a method is a block of Smalltalk statements that provides a
procedural implementation of the method.  Expressions in Smalltalk are usually
embedded in methods in class definitions.

The body of the method above consists of a single conditional statement.

x _ self find: name  [ values  x]  false

A conditional statement has three parts: a condition followed by a right arrow,
; a true alternative enclosed in square brackets; and a false alternative.  In
the above example, the three parts are:

x _ self find: name

This is the condition part.

In this statement, the message find: name is sent to the dictionary itself
(named using the pseudo-variable self).  We expect this message to return the
location of name within the field objects, i.e., an integer subscript i such
that objects  i = name.  If there is no such i, it returns the special constant
false.

The value returned is assigned by the symbol _ to the temporary variable x.  An
assignment statement has a value, which is the value assigned.

The condition of this conditional statement is considered false if the value of
the assignment was false, and is considered true otherwise.

 values  x

This is the true alternative part.

This statement is executed if and only if the condition is not false.  It sends
the message  x to the field values.  We expect that this message returns the
xth element of values.  The  symbol causes the result to be returned as the
value of the current method.

 false

This is the false alternative part.

This statement is executed if and only if the condition is false.  It returns
false as the value of the current method.

The Pseudo-variable super

The pseudo-variable super is, like self, provided automatically to every method.
A message sent to super goes to the currently running instance with the caveat
that the message-dictionary lookup starts at the superclass of the class whose
method is being performed, instead of at the class of self.

The Basic System

Creating Objects: the Message new

A new instance of a class is created by passing its class the message new.  The
class allocates the property dictionary for the new instance, initializes each
value in the dictionary to a standard constant nil, and returns the object.
Usually the new object is then passed additional messages to initialize it
fully.

A new class is created by creating a new instance of class Class, i.e., by
passing the class Class the message new.  This message is followed by messages
informing the new class of the name of its title, its fields (instance
variables), names of properties shared by all members of the class (class
variables), names of any variables to be shared with other classes (pool
variables), and references to a superclass.

Suppose we create a new class whose name is Customer as a subclass of
Dictionary.  It will add instance variables name, address, telephone as the
identication information for the dictionary; and one class variable, instCount,
which will be the tally of all instances of Customer ever. (Its superclass,
Dictionary, you will recall, has one field, values; its superclass HashSet has
one field, objects.)  In order to create this new class, we send Class a
message.

Class new	title: 'Customer'
	subclassOf: Dictionary
	fields: 'name address telephone'
	declare: 'instCount'

Now a customer may be created by the statement

Customer new

The statement Customer new results in a new instance of the class.  Suppose in
the message dictionary of the class Customer there is a message pattern init.
Then a new instance might be passed an additional message requesting that the
instCount be updated.

Customer new init

In Smalltalk-76, special consideration is given to this need to initialize
instance variables or to modify class variables whenever a new instance is
created.  The following expression is equivalent to the one above

Customer init

Suppose we create two instances of class Customer which we will call A and B.
Each instance contains a property dictionary such that if A changes its address
field, the address field for B does not change.  Both A and B refer to the same
class variable(s) so that if A increases the value of instCount, then B will
also be affected by that change.

Modifying the Message Dictionary of a Class

A class is told to associate a method with a message pattern by sending it the
message understands: code classified: heading.  Various designs for the user
interface to the Smalltalk programming environment have provided different
surface methods for specifying the message dictionary of a class.  In Chapter ()
on user aids, we describe a Browser design which provides a text editor and
templates for creating classes and adding message patterns with their
corresponding methods; in Chapter (), we describe a template language as the
surface syntax.  In each case, however, the class Class must ultimately be sent
the message understands: code classified: heading informing it of the message
pattern and its method.

Activations

Each method can declare temporary variables that can be used during the
execution of the method.  These variables are destroyed automatically when the
method execution is terminated.  The syntax for defining methods in Smalltalk-76
is detailed in a later section.

If we now send a message such as cust growby: 5, a new object that we call an
Activation is created.  This new object contains a dictionary for storing the
names and values of the temporary variables of the method that is currently
being executed.  Smalltalk-76 system supports four kinds of object variables in
the creation and use of objects: class, pool, instance, and temporary (or
method).

Object Life

No facilities are provided in Smalltalk-76 for explicit deallocation.  An object
is destroyed automatically when no reference to it exists.  Thus, the programmer
is generally freed from the concern with deallocation.  However, if an instance
points to itself, or if it is part of a cyclic structure, then Smaltlalk will
never realize that it can be deallocated.  Therefore, if a data structure
includes cycles or back pointers, then when it is no longer needed, the
programmer must explicitly remove the pointers (typically by changing them to
the constant nil).

The Basic System: Syntax

We had several goals in mind when we designed the syntax of Smalltalk-76.  To
begin with, it had to be compilable (the previous Smalltalks were not).  Of
course it had to support the notion of sending messages to objects.  Our
previous experience with Smalltalk and other systems lent the following
additional considerations:

1.	We liked the naturalness of infix expressions like 3+4.

2.	We liked descriptive names for user-defined messages.

3.	We liked the notion of keyword parameters to procedures rather than
depending on the programmer's memorizing orderings for each argument.

4.	We disliked parentheses because assuring proper matching can become
frustrating.

5.	We liked the notion of symmetric read/write messages.

6.	We wanted to allow a series of messages to the same object to be sent
concisely.

7.	We wanted the syntax to include control, and to allow the user to define
his own control messages.

Given these desires, the syntax which resulted is mostly a case of form
following function.  In this section we will first treat the syntax for
expressions, and then describe the way in which methods are built from
expressions.

Identifiers and Constants

In Smalltalk, an identifier can be any sequence of letters and digits which
begins with a letter.  By convention multiple word identifiers use capitals at
the word breaks; variables for class definitions begin with a capital letter.
Here are some examples.

a r2d2 lastPictureShow	Rectangle

Smalltalk-76 recognizes constant numbers, strings, names, and lists (as will be
defined later, these are instances of class Number, String, UniqueString, and
Vector, respectively).

A constant number is written as an unbroken sequence of digits.  If the number
is negative, it is preceded by a "high minus" sign: .  If the first digit is 0,
the rest are in octal radix.

0	6	32767	32766		0377		0177777		0100000	

The constant 0940 is an incorrect number.

A constant floating point number is written as a decimal-radix number constant
immediately followed by a decimal point (a period) and one or more decimal
digits.  After the last digit may be an exponent of the form e followed by a
decimal-radix number constant.

0.0		3.14159		32766.32767e32766

Incorrect floating point numbers include

0.		6.		.31415927e1

A constant string is written as an arbitrary sequence of characters enclosed in
apostrophes.  To include an apostrophe in the string, it is necessary to write
two in a row.

''	'a'	'it costs $4.50'		'They said, ''Yes!'''

It is not correct to write

'''		'They said, 'Yes!''

A constant name is either a sequence of letters, digits, and colons not starting
with a digit, or any other single character except a parenthesis.  It is
preceded by the symbol  unless it is embedded in a constant list.

+				,		Help		printon:

Incorrect constant names include

)		12

The difference between a constant string and a constant name is that no two
instances of a name contain the same characters.  They are similar to atoms in
the language LISP.

A constant list is written as an arbitrary sequence of constants enclosed in
parentheses.  It is preceded by a  unless it is embedded in another constant
list.

()		(0 6 32767)		((14 Help) 'arbitrary text')

Incorrect constant lists include

(14 Help)		(1 2 (3 4]

There are a few predefined standard constants in Smalltalk; they are the only
instances of class Object:

nil	It is the default initial value for an identifier.

false	Anything else is effectively "true".

true	It is useful as a "true".

To send a message, one composes an expression which has a receiver part (itself
an expression) and a message part.

receiver	message

As in other programming languages, an expression can be evaluated according to
certain rules in order to yield a value.  The value of every Smalltalk
expression is an object (or, more precisely, a reference to an object).  The
receiver part is something that evaluates to the object that is to receive the
message.  The message part consists of a message name or selector followed by
zero or more parameters.  The message name can be any constant name.

There are three basic forms of a message: unary, binary, and keyword.  A unary
message contains no parameters, a binary message contains one parameter, and a
keyword message contains one or more parameters.  The valence of a message is
equal to the number of parameters it requires.

Unary Messages

The name of a unary message is called a unary selector; syntactically, it is
simply an identifier.

		x		center		next		show	new

Examples of using these message parts in an expression are

		pt x		rect center		strm next		rect show		Rectangle
new

The convention of a left-to-right parse means that a sequence of simple messages
such as

		angle asFloat asRadians cos

is interpreted as:

		((angle asFloat) asRadians) cos

that is, (1) send the unary message asFloat to the object identified as angle,
obtaining a real number; (2) send asRadians to that number, performing a
degree-to-radian conversion, and, finally, (3) send cos to that result to obtain
the cosine.

Binary or Infix Messages

To allow infix expressions like 3 + 4 and a < b, we define infix messages as
those whose selectors are single non-alphabetic characters such as + - < = >  
 and .  (Note that the last character, , is typically used to denote
subscripting.)  We adopted the convention that the first term of an infix
expression is the receiver; the message consists of the infix operator as a
valence-1 selector, with the second term as its parameter.  Thus a < b means
that a will receive the message < with parameter b.  One can see how to compile
this in a perfectly reasonable way, but there is need of a further convention to
say what 2 * a + 1 means.  Since users would be adding their own infix
operators, precedence would be too confusing here, and we established that the
parse would be left-to-right.  Thus 2 * a + 1 means (2 * a) + 1.

Keyword Messages

In some conventional programming languages, the notion of passing parameters by
keyword allows procedure calls of the form

call draw (thickness=2, angle=45, length=1.414*base)

This saves the programmer from having to know the order in which the procedure
expects the parameters.  It can also provide for defaulting (for instance, in
the example, a fourth parameter, color, might be expected; if omitted, it would
default to some color such as black).  This approach has been used in several
applications systems, and also in the IBM's Job Control Language [reference].
We had been looking for a way to represent messages with multiple parameters,
and we thought that by stringing all the keywords together, the agglutenation
could represent a selector of multiple valence.  For example:

pen thickness: 2 angle: 45 length: 1.414*base

Here pen is the receiver.  It receives the message thickness:angle:length: which
has a valence of 3.  This form provides the readability of keywords, and is also
free of the parentheses and commas used in the conventional form.  Leaving the
matter of defaults aside, this technique has another nice property: the valence
of the selector is manifested by the selector itself.  Thus, when a selector has
been found in a message dictionary, the associated method is guaranteed to be
expecting the right number of arguments.

A keyword, then, is simply an identifier with a trailing colon.  For example

		deleteChars:		to:		by:		from:		paint:

The actual selector in the keyword message is the concatenation of the keywords,
in order.  For example, in the expression

		1 to: 10 by: 2

the selector is to:by:, its valence is 2, and the parameters are 10 and 2.
Here, the message is sent to the number 1, resulting in an ordered collection of
numbers: 1, 3, 5, 7, 9.

There are two aspects to the keyword organization which we have not actually
pursued, although we did plan for them in the design.  The first is the
possibility of sorting the agglutenated parts in the compiler, so that they can
be used in any order by the caller.  One of the reasons is that much of our
access to the system is done by selecting choices in a list of alphabetized
messages, and this gets difficult if the selector parts get reordered.

The other possibility which we have not implemented is that of furnishing
defaults for omitted keywords.  This we plan to handle in one of several ways,
for example, by a procedure which intercepts the case of a message which is not
recognized by the receiver.  Before announcing an error, this procedure would
look in the receiver's message dictionary for any other selectors which included
the parts of the unrecognized selector.  If so, it would prompt the user for a
value to use for each of the missing parameters, and then compile these into a
definition for the short version which then calls the full version.

Precedence

In order to allow complex expressions to be assembled without needing many
parentheses to determine grouping, we assigned a different level of precedence
to each of the three message types.  It seemed natural for unary messages to be
sent first, then infix, and finally keyword messages.  This meant that
arithmetic expressions could be embedded in keyword messages without needing
parentheses; also, simple expressions such as source next, center x, vec length
could appear in arithmetic expressions without needing parentheses.  Within a
given level of precedence, evaluation runs from left to right.

Keyword messages can not be written consecutively, or else they would
concatenate into a selector with a longer name.  Thus,

		(a min: b) max: c

and

		a min: (b max: c)

are quite different from

		a min: b max: c

The first two expressions would invoke the selectors min: and max:, while the
latter would invoke the single selector min:max:.

From the discussion above, the reader should be able to parse the following
expression which returns true only if the rectangle r1 is equal to the rectangle
r2.

		r1 origin = r2 origin and: r1 corner = r2 corner

This is interpreted by first sending origin to r1 obtaining a number n1, then
sending origin to r2 to obtain a second number n2, and then sending = to n1 with
n2 as its parameter.  The result will be true or false depending on whether the
two origins are equal.  The same parse takes place on the right with the
corners, and we are left with

<term> and: <term>

which produces the final result to be returned.  The introduction of precedence
between the various message categories has been a success in reducing the need
for parentheses to a reasonable level.

Cascading Messages

Another extension to the message syntax allows for sending a series of messages
to the same receiver as in

		receiver message1; message2; message3.

For example

figure erase; moveto: dest; show.

(artist pen) go: 100; turn: 90; go: 30.

Here the semicolon separates what are referred to as cascaded messages to the
receiver.  The messages are sent in sequence from left to right.  In the first
example, the receiver is figure; it receives three messages, in order: first,
erase; second, moveto: dest; and third, show.  The receiver in the second
example is the result of sending the message pen to artist.  Note that the
parentheses are recommended in order to unambiguously define the receiver of the
cascaded messages.  The value of a series of messages is the response from its
last message; however, a cascaded messge is not an expression, it is a
statement, so, to use the value, you must put it in brackets.

Read/Write Symmetry

As in most programming languages, there are two forms of variable access for
reading and writing.  One uses the identifier to read, and the identifier
followed by a left arrow to write

extent					extent _ 10

The identifier (extent) takes on the value of the expression (10).  Thus we have
a simple assignment statement.  Its value is the value of the assigned
expression.

There are cases where message access comes in read/write pairs, such as:

object	read	write

ith part of a	ai	ai _ 12
next item in strm	strm next	strm next _ char
fifth field of x	x field: 5	x field: 5 _ strm next

In order to support this symmetry in a uniform way, the syntax allows any
message to be extended by a single terminal store-part consisting of a left
arrow and an accompanying parameter.  The left arrow has a right precedence
lower than any selector, so that any expression may follow it.  The extension
results in a totally new message which has a left arrow as its last character
and has a valence greater by 1.  The examples above illustrate extension applied
to each of the basic message categories.  In particular, the new selectors
formed are _, next_, and field:_, respectively.  In the third example, we see
that the expression strm next provides the object that is written into the fifth
field of x.

The formation of a selector using the left arrow notation results in a message;
of course, the message only has meaning if it is found in the message dictionary
of the receiver.  For example, it is possible to have an expression such as

1+3 _ 5

The object 1 is sent the message +_ which has a valence of 2; the two parameters
are 3 and 5.  Unless the message dictionary for an integer includes the selector
+_, this message has no meaning.

Order of Evaluation

Besides the left-to-right rule for the order in which expressions of equal
precedence are evaluated, there is an additional degree of freedom in the order
in which the parameters of a multivalent message are evaluated.  This order is
undefined in the Smalltalk-76 syntax, and users are cautioned against ever
writing code which depends on it (i.e., which has side effects).  The order is
of significance to compilers and interpreters, and we wanted to reserve this
degree of flexibility for future implementors.

Examples

<time for some examples that help the reader figure out precedence, message
syntax, order of evaluation--they should be real--they should be runnable on the
current system--but use message protocols ala chapter 3 until we define syntax
for them in this chapter--will the Customer and BankAccount work?>

Statements, Blocks, and Control

Evaluation in Smalltalk is sequenced by use of statements and blocks.  Any
expression can serve as a statement.  A block is a sequence of statements
separated by periods and enclosed in a pair of square brackets.  As an example,
take

[v _ dict lookup: 'twelve'. w _ dict lookup: 'six'. v+w]

in which v gets 12, w gets 6, and the value of the block is the value of v+w, or
18.

If a block ends with a period (i.e., a terminating expression is omitted), nil
becomes its value.  In these cases, the block is executed for effect rather than
value.  If a return statement ( expression) is executed in the block, then the
block terminates and its value is that of the terminating expression.

Conditionals

The value of a statement may be treated as a true-or-false condition to choose
between two alternative paths of execution.  Such a conditional statement is of
the form

		expression  block.

For example,

		x < y  [x] .	

and

		rect has: pt  [rect growby: 20] .

If the value of the expression is not false then the block is executed and its
value becomes the value of the enclosing block, whose execution thereby
terminates.  Otherwise, the block is skipped.

The equivalent of the Algol

	if ca then sa else if cb then sb;

is obtained by

	[ca  [sa] cb  [sb]] .

Note that, in the above example, if both ca and cb are false, then the value of
the block is nil.  Syntactically, the first alternative of a conditional is a
bracketed block, and the second alternative is everything following that up to
the end of the block in which the conditional appears.  It follows that a
conditional must always be the last statement in a block, and the value of the
executed alternative becomes the value of that block.  An example is

z _ [x<y  [x] y]

which first determines if x is less than y and if so, assigns the value x to z;
otherwise, the value y is stored in z.

The equivalent of the Algol

	v _ if ca then sa else if cb then sb else sc;

is obtained by

	v _ [ca  [sa] cb  [sb] sc] .

In the above example, if both ca and cb are false, then the value of the block,
and thereby of v, is sc.

One of the major uses for blocks in Smalltalk-76 is as a context for a special
conditional construct.  An example is

min _ [x < y  [x] y] .

If the value preceding  is true, then control enters the following block, and
when it ends that block, it exits from the original block as well, thus allowing
construction of simple case-statement forms. The use of cascading messages makes
the following statement form possible.

var  1  [pen paint: green]; = 2  [pen paint: blue]; = 3  [pen up];  4 
[pen erase].

This is equivalent to the statement

[var  1  [pen paint: green] var = 2  [pen paint: blue]
 var = 3  [pen up] var  4  [pen erase]].

Remote Parameters

In order to use message sending to accomplish control, it is necessary to
provide for parameters to be passed unevaluated, so that the receiver has
control of this evaluation.  This function is provided by keyword parts which
end with an open colon () rather than a closed colon (:).  In this case, the
parameter transmitted is a code object, and the receiver can send the message
value to that object in order to cause its evaluation.  The code may never be
evaluated, or it may be evaluated many times; it is up to the receiver.

For example, the expression

user displayOffWhile [fileSource _ strm].

tells the Smalltalk user interface to make the display screen black during the
time needed to evaluate the expression in brackets.  The expression is a request
to a file to store a stream of characters.  The method employed to respond to
displayOffWhile first blackens the screen, then sends the message value to the
expression, and then restores the screen information.

Another example is

user time [dict lookup: 'twelve']

which tells the Smalltalk user interface to return the time that it takes to
evaluate the expression in brackets.  The method for time expr is of the form

t _ currentTime.  expr value.  currentTime - t.

The first statement assigns to the variable t the current value of the time.
The second statement evaluates the expression in question.  And the third
statement returns the difference between the new time and the old.  For
illustration purposes, we have assumed here that there is such a pool variable,
currentTime, that is being updated by another process.

If a simple variable is passed unevaluated, the object transmitted is a remote
reference to that variable and, in addition to being read with value, it may be
stored into with the message value_, allowing the implementation of loops with
induction variables.  For example,

heights _ students transform each to each height

Here the message transformto is being sent to the array students with two
unevaluated parameters, each and each height.  What the array will do is make an
empty copy of itself and then fill that copy by successively binding each to
each element of the original and put into the corresponding element of the copy
the value of each height.  While this may seem like an elaborate system
function, the entire definition in Smalltalk-76 is much smaller than this
paragraph.  We will see the definition at the end of this section.

Control Messages

When we designed the syntax, it seemed that there were certain control functions
(the for-loop, for instance) which could certainly be expressed nicely as
keyword messages, but for whom there seemed to be no appropriate receiver.  We
decided to allow the receiver to be elided with the convention that the message
was essentially being sent to the interpreter itself [actually the current
context, q.v. below].  In Smalltalk-76, three control messages have been
implemented in this way: for, until and while statements.  We have abused this
realm a little, as one would expect  (return a value) to be an infix operator
in this way; and yet  is defined as having a uniquely low precedence so that it
will pick up everything to its right.

The reader will probably enjoy finding more uniform ways to do this.  We have
had occasion to review these decisions, but have sat with our ad-hoc solutions
because they have served so well, and because of a few other petty details.  One
of these is the ad-hoc choice of several control messages which the compiler
converts into in-line tests and jumps, and other optimizations which are, in
fact, essential to adequate performance.  The most important consideration,
which we have followed, is to limit these special cases to lie within a
framework which is totally consistent with things the user can do.  You can, in
fact, define your own version of a for-loop in Smalltalk, and it will run in a
manner identical to that which is defined in the system.

The For Statement

The for statement repeats a block of statements once for each of an ordered set
of values.  During each repetition, the next value from that set is bound to an
iteration variable.  The iteration variable is specified after the keyword for.
Note again that naming a variable after an open colon not only defers
evaluation, it also permits the control method to assign to the variable.

There are four forms of the for statment.  They obtain the set of values for the
iteration variable in different ways.  One form assigns to the iteration
variable the successive integers between 1 and a stop-value.

	for i to: 10 do [i print].

will print the numbers 1 through 10, in order.  Notice that the actual message
is forto:do, with valence 3.  Upon sending this message, evaluation of the
first and third parameters is deferred, while the second parameter is
immediately evaluated.

Variations of this form allow a different initial value and a step value.

for i from: 2 to: 10 do [...]  for i from: 2 to: 10 by: 2 do [...]

The other form assigns to the iteration variable the successive elements of an
object that responds to the message asStream in order to obtain an object that
responds to the mesage next.  As we will discuss more precisely later, several
predefined classes in Smalltalk-76 are able to do so, such as Stream, File,
HashSet, and Array.

	for variable from: term do [statements].

Examples are

	for color from: rainbowVector do [screen flash: color].

and

	for prime from: (2 3 5 7 11) do [x\prime=0  [prime]]

in which each of the first five prime numbers are tested as divisors of x (the \
message means "modulo"), and the first divisor which works (if any) is returned
from the surrounding method without further testing.

The Until Statement

The until statement repeats a block of statements until a condition is true.
The test of the condition is made before ech performance of the block.

	until term do block.

Of course, if the block executes a return statement, it terminates not only
itself, but the entire method.

The While Statement

The while statement repeats a block statement until a condition is flase.  The
test is made before each performance of the block.

	while term do block.

Examples

<present the transform of an array example here note: for, until, while could
serve as examples by showing how the reader can program them himself>

Classes, Methods, and Subclasses

A Special Class: Object

In the Smalltalk-76 basic system, the class Object is implemented as the
superclass of all classes.  It is an abstract class in that it has no state; its
main function is to provide a foundation message protocol for its subclasses.
As such, it provides a default set of capabilities for all objects in the basic
system.

The message protocol of class Object includes the ability to respond to queries
about what kind of class an object is or belongs to, to requests to convert an
object to a Vector or a Stream (two classes provided in the basic Smalltalk-76
system), to attempts to inspect the state of an object or to print an object on
the current output device or on a disk file.  The protocol of the class Object
also provides default methods for responding to requests of the compiler and of
the process scheduler.  The following is part of the message dictionary for
class Object.

sameAs: object	are self and object the very same object?
class	to which class do I belong?
is: x	am I a member of the class x?
Is: x	is the class x a superclass or class of me?

copy	return a copy of me

print	print a representation of me on the display screen
printon: strm	print a representation of me on device strm

Defining a Class

As outlined in the section entitled Capabilities of the Class Class, the full
representation of a class includes a prelude which gives the name of the class
and the format of its instances, followed by a number of textual method
descriptions.  Access to the prelude and selection of a given method to work on
are the subject of the chapter on user aids -- one seldom composes a full class
description as linear text.  The reader interested in the full textual
representation of a class may refer to any of the class descriptions printed in
the appendices.

An example of the syntax of a class definition is

Class new	title: 'BankAccount'
	subclassOf: Customer
	fields: 'acctNumber authorization transactions'
	declare: 'transactionMenu'

in which BankAccount is the name of the class, Record is its superclass,
acctNumber, authorization, and transactions are instance variables, and
transactionMenu is a class variable.  Note that single quotes are placed around
each argument except the superclass.  The messages must be in the order shown,
but the subclassof: and declare: messages are optional.  The default superclass
is Object.

Once a class has been defined, it may be redefined only with caution.  If its
fields (counting those of its superclass) have changed, then, in this system,
all old instances become obsolete, i.e., they will fail to respond to messages.
Furthermore, all the methods defined for the class may bcome undefined until
they are each updated and recompiled.  When class redefinition is attempted, the
current user interface warns the user of any such impending trauma and gives the
user a chance to withdraw the redefinition.

If a class is to share variables with other classes (pool variables), an
additional clause, preceded by a semi-colon, is added to the class definition
for each such variable.  The message pattern to be used is sharing: var.

To initialize class or pool variables, the class should include a message
pattern classInit.  This message is sent directly to the class, although in
reality it is treated specially -- an instance of the class is created and is
then sent the message classInit.  Because any instance of the class has access
to the class or pool variables, it can be used to initialize the variables.
That is, BankAccount classInit is identical to BankAccount new classInit.
Earlier we saw that the message init is treated as a special way to create an
new instance, making it possible to initialize instance variables or to update
class and pool variables.

Defining a Method

The framework which takes us from the level of expressions to the definition of
complete messages is

message pattern with parameter names | temporary variable names
	[code for implementing the response]

The brackets delimit a block, and within the block are statements which are
expressions terminated by periods.  An  within this block indicates the return
of a value and termination of the current method at that point.

Defining a Method makes or updates an entry in the message dictionary of the
class, associating the procedure with the selector derived from the message
pattern.  A message pattern looks exactly like the message except that, instead
of arguments, there are the names of variables (parameters) to which arguments
will be assigned when a message is actually received.

If a particular argument variable is neither a class variable nor an instance
variable of the recipient, then it is automatically declared to be a temporary
(method) variable.  Additional method variables may be declared using the |
construct.

Classes in the Basic System

The description of the objects in the system and the creation of new objects is
accomplished by the Classes in the system.  The Classes rely on certain other
objects to accomplish this task.  All of these objects are part of the kernel
system since they are necessary for the functioning of the system.  This section
lists the Classes of objects that make up the part of the kernel that supports
Class Class.  The discription of each Class includes an italicized statement of
its purpose followed by a description of its function followed by a description
of the messages that are relevant to its behavior in the kernel.  The two
interesting relationships between Classes are class and subclass.  These
relationships are indicated in the following diagram, with class indicated in
red and subclass indicated in blue.  Class Array is included in this diagram but
not in the following descriptions because it participates in the subclass
heirarchy but not in the kernel behavior of its two subclasses.

Object

Class

CollectionClass

Array

Vector

String

HashSet

Dictionary



Object

A primitive form for everything

Object is the ultimate superclass of all objects.  It has no superclass.  It
defines messages understood by all objects.

 otherObject			is otherObject the same as the receiver

class						return the Class object that
describes the receiver (note: that this is the deepest subclass for the
receiver)

hash						return an Integer (this can be
any number, but it must always be the same number for a particular object) (this
message is used in the associative behavior of Dictionaries)

Vector

A primitive form of collection and a primitive form of association

A Vector has a set number of slots for objects.  Each of the slots is numbered
and the objects in the collection are placed in specific slots.

length						how many objects are there room
to collect

 index _ value			include value in the collection associated with
index (which must be an Integer between 1 and the length of the receiver)

 index					return the object in the collection last
associated with index

String

A primitive form of collection and association optimized for collecting Integers
between 0 and 255

A String behaves like a Vector except that the objects collected must be numbers
between 0 and 255.  Strings are used to represent descriptions of behavior
called methods.  The methods consist of instructions (primitive messages) for
the interpretive machine.  The instructions are represented as numbers between 0
and 255.  Strings are also used for optimized collection of text.  The text is
represented as a collection of indices into a character set.

length						how many objects are there room
to collect

 index _ value			include value (which must be an Integer between
0 and 255) in the collection associated with index (which must be an Integer
between 1 and the length of the receiver)

 index					return the object in the collection last
associated with index

HashSet

A non-duplicating, unbounded form of collection and a primitive form of inverted
association

A HashSet does not have a fixed number of slots for the objects it collects, it
will accomodate as many objects as are inserted.  If an object that is already
in the collection is inserted, it will only appear once.  Between insertions and
deletions, the HashSet will associate each element of its contents with a unique
Integer.  These numbers may change when an object is inserted or deleted.

insert: value				include value in the collection but
don't duplicate it if it's there already

delete: value				remove value from the collection (it
should have been previously inserted)

contents					return a Vector containing the
objects in the collection

find: value				return a unique Integer associated with
value

Dictionary

An unbounded form of collection of general associations

A Dictionary is a subclass of HashSet that will collect an arbitrary number of
associations of pairs of objects.

 key _ value			include value in the collection associated with
key (which may be any object)

 key						return the object in the
collection last associated with key

Class

A general form of object description

A Class describes a set of objects called its instances.

new						return a new instance of the
receiver

methodFor: selector		return the method (a String) that describes an
instance's behavior when it receives a message whose selector is selector

CollectionClass

A form of description for optimized collection objects (Vector and String)

A CollectionClass describes a set of instances that can be of different sizes.

new: length				return a new instance of the receiver
with length instance parts

methodFor: selector		return the method (a String) that describes an
instance's behavior when it receives a message whose selector is selector

The Implementation of the Basic Classes

This section describes how the classes listed in the last section are
implemented.  This includes a description of the parts of the objects and the
methods for responding to the messages.  Many of the methods are what we call
primitive methods.  These are programs for the implementation machine as opposed
to regular Smalltalk methods.  They can directly interact with the virtual
memory of the machine.  Some of the methods refer to pointers to objects.  A
pointer to an object is a unique number that the virtual memory uses to refer to
an object.  For instance, the virtual memory represents the parts of objects by
associating the pointers to the parts with the pointers to the object.

Object

A primitive form for everything

Most objects in the system are not direct instances of Object but rather
instances of some subclass of Object.  The three instances of Object itself are
true, false and nil.  The objects called true and false are used to represent
logical values and nil represents the default value for a part of an object.
Object does not contribute any instance parts so these three objects have no
parts at all.  As a consequence, true, false and nil are identical except that
they are separate.  The only way to distinguish them is with the  message.  Any
messages that they respond differently to (like print) must ultimately send  to
them.

 otherObject			if the pointer of the argument and the pointer
of the receiver are the same, returns the object true; otherwise returns false

class						returns a pointer to the Class
of which the receiver is an instance.  This is known to the virtual memory

hash						returns an Integer object whose
value is the pointer to the receiver

Vector

A primitive form of collection and a primitive form of association

Vector and String differ from the other Classes in the system in that their
instances do not all have the same number of parts.  The parts of the instances
represent the objects in the collection and different collections have different
sizes.  This is a storage and access efficiency consideration since collections
could be represented as linked lists in the manner of Lisp cons cells.  Because
a Vector has a fixed number of parts, this number must be specified when a new
instance is made.  This is reflected in the fact that Vector and String are
instances of CollectionClass instead of Class.  Instead of the new message for
instantiation, CollectionClass uses a message called new: that takes an argument
of the size of instance desired.

length						returns the number of parts in
the receiver which is known to the virtual memory

 index _ value			requests the virtual memory to replace the
pointer representing the indexth part of the receiver with the pointer to the
object supplied as an argument.  Returns the argument

 index					returns the pointer of the indexth part
of the receiver

String

A primitive form of collection and association optimized for collecting Integers
between 0 and 255

A String is a further optimized form of Vector.  Since only Integers can be
instance parts, the virtual memory stores the values of the parts instead of
pointers to the parts.  This is space efficient since pointers are longer than
the eight bits necessary to store a value between 0 and 255.

length						returns the number of parts in
the receiver which is known to the virtual memory

 index _ value			requests the virtual memory to replace the value
of the indexth part of the receiver with the value of the Integer supplied as an
argument.  Returns the argument

 index					return an Integer whose value is the
indexth part of the receiver

HashSet

A non-duplicating, unbounded form of collection and a primitive form of inverted
association

A HashSet has one instance part named objects. objects is a Vector in which the
HashSet stores the objects it collects.  The HashSet determines where to store
objects in objects with a hashing scheme to make duplication of objects
efficient to detect.

insert: value				if the argument is not in objects,
include it

delete: value				remove the argument from objects

contents					return a copy of objects with
any nils removed

find: value				return the index of the argument in
objects

Dictionary

An unbounded form of collection of general associations

A Dictionary is a subclass of HashSet which adds another instance part named
values, so Dictionaries have two parts named objects and values.  values is a
Vector of the same length as objects.  When two objects are associated, the key
is inserted in objects using the HashSet insert: method described above.  The
value to be associated with the key is then stored in values in the part with
the same index.

 key _ value			include value in the collection associated with
key (which may be any object)

 key						return the object in the
collection last associated with key

Class

A general form of object description

A Class describes a set of objects called its instances.

new						return a new instance of the
receiver

methodFor: selector		return the method (a String) that describes an
instance's behavior when it receives a message whose selector is selector




<caution--this is simply an appending of two of Dave's papers as my beginning to
make a chapter on implementation>



VI

The Implementation of Smalltalk-76





Basic Data Structure

A basic principle of the Smalltalk system is the uniform representation of the
parts of the system.  We use the name object to refer to this representation.
This chapter describes the nature of objects in the Smalltalk system.
Everything in the system is represented as an object.  Some examples of objects
are:

9a document

9an editor for the document

9a window that displays the document on the screen and allows the user to
interact with the document's editor

9the rectangle that describes the position of the window on the screen

9the number that represents the width of the rectangle

Smalltalk has facilities for the creation of objects and the description of
their behavior.  It also provides for the performance of described object
behaviors.  These facilities, since they are part of Smalltalk, are represented
as objects.  They are called the kernal objects since they are the basis for the
whole system, including themselves.  This chapter will describe the object
representation and the kernal objects that provide facilities for object
creation and object behavior description.  The next chapter will describe the
kernal objects that provide facilities for performing the behavior of objects.
As examples in this chapter we will use two classes of objects that represent
simple graphical entities, Point and Rectangle.  Points are used to represent
locations or two dimensional distances on the display screen and Rectangles to
represent rectangular areas whose sides are parallel to the edges of the screen.

The nature of Smalltalk objects is related to the nature of the virtual memory
that stores their representation and the virtual processor that carries out
their behavior.  These are discussed in detail in Chapters 12 and 9
respectively.  This chapter will treat both aspects of the virtual
implementation machine as black boxes and only discuss the functions they
perform.

The Nature of Objects

This section describes the nature of objects from two perspectives: external and
internal to the object.  Externally, objects interact with other objects in the
system.  Internally, the nature of the interaction must be described in terms of
the structure of the object (which is hidden to the outside).  Both perspectives
have a lot to do with the fundamental behavior of objects which is sending and
receiving messages.  Messages will be discussed in detail in the next chapter.
For now it is enough to say that a message is an object that evokes a certain
behavior from the object it is sent to.  The message has a selector that is a
word or symbol that tells what kind of behavior is desired.  A Point might
respond to messages with the selector "x" by returning its distance from the
left edge of the screen.  The behavior evoked by some messages is relative to
other objects.  These objects are part of the message and called arguments.  A
Point might respond to messages with the selector "-" by returning the
two-dimensional distance from another Point (which will be a Point).  The other
Point must be specified as an argument in the message. Some of the other
messages that a Point must respond to are:

9how far are you from the top of the screen

9are you above and to the left of another Point (an argument)

9add yourself to another Point (an argument)

9make a Rectangle whose origin is you and whose opposing corner is another Point
(an argument)

A Rectangle might respond to messages like the following:

9what is the Point at your upper left corner (or lower left or upper right or
lower right)

9what is the Point at your center

9how wide are you

9move your upper left corner to another Point (an argument)

9is a Point (an argument) inside you

The selectors for these messages to Rectangles might be upperLeftCorner
(lowerLeftCorner,upperRightCorner or lowerRightCorner), center, width, moveTo
and doYouInclude. The messages with selectors moveTo and doYouInclude must
include another object as an argument (a Point in both cases).

The external perspective on an object is its behavior.  This is the perspective
of the other objects in the system except for the objects that are actually
implementing the behavior.  To the rest of the system an object is simply an
entity that can be sent certain messages and will respond in some appropriate
way.  There are two kinds of things an object can do in response to a message,
it can communicate and transform.  An objects communicates by sending messages
to objects and by returning a result to the object that sent it a message.  It
transforms by changing its state.  The state of an object is what distinguishes
it from other instances of the same class.  The state is also that part of an
object that can change.  For instance, a Rectangle that had been sent a message
to move its center would afterwards respond differently to the message asking
where its center was.  An objects behavior on receiving a message may consist of
sending an arbitrary number of messages (including none) and transforming an
arbitrary amount (including none) but it must include the return of a result.
The internal structure of an object is inconsequential from the external
perspective, anything that responds to the messages correctly will look the
same.

The internal perspective on an object is the description of its behavior.  This
is the perspective of the person that wrote the description, the part of the
system that implements the behavior by following the description and any person
who reads the description.  The description is represented as a Class.  As the
name implies, a Class describes a whole class or "kind" of object.  The objects
described by a Class are called its instances.  A Class describes its instances
in terms of a collection of parts and a set of methods for responding to
messages.  The actual objects that make up the parts of an object differ from
one instance of a Class to the next.  The set of methods for responding to
messages is shared by all instances.  This sharing is accomplished by
automatically making the Class of an object one of its parts.  The Class part of
an object is consulted every time it responds to a message.  The external
perspective on an object's state was that it could change its response to one
message as a result of receiving another message.  From the internal
perspective, the object's state is which other objects make up its parts.  The
transformation part of an object's behavior is changing which object is a
particular part.

From both perspectives, the necessity to refer to objects has arisen.
Externally, one must refer to selectors and arguments to specify a message and
also refer to the object that is to receive the message.  Internally, the object
must refer to its parts.  Because of the uniform object representation all
references in the system are to objects.  Each object is associated with a
unique reference called its pointer.  An object is represented internally by the
pointers to the objects which are its parts.  A graphical representation of an
object might be a box containing arrows pointing at other boxes:


















-Class Class

The Parts of an Object

The parts of an object are other objects and are only visible from the internal
perspective.  The only global restriction on the parts of an object is that one
is a Class object.  Other than that, the restrictions on the parts of an object
are purely a matter of the object's behavior (i.e. known only to its Class).  A
Rectangle, for instance, must have parts that allow it to represent a
rectangular area.  What the parts are only matters in how the behavior of the
Rectangle is described.  A Rectangle should be able to respond to the messages
mentioned in the introduction to this chapter.  One way to implement Rectangles
would be to give them four parts that represented the minimum and maximum values
of x and y for Points that fall within the Rectangle.  The desired behaviors
could certainly be described in terms of those parts.  Another way to implement
Rectangles would be to give them two parts that represented opposing corners of
the rectangle.  The identical behaviors could be described in terms of these
parts (i.e. the identical responses to the messages could be made).  Since it is
only through the behavior of an object that it interacts with the other objects
in the system (i.e. through messages), these two implementations with different
numbers of parts would be indistinguishable.  It would only be the description
of the behavior associated with the messages that would be different.

The Description of an Object

The description of an object is contained in its Class.  The Class represents
the internal or implementation perspective on its instances.  From this
perspective, an object is a collection of parts that knows what to do when
messages with certain selectors are received.  A Class describes the parts of
its instances with a list of names for them.  The list of names indicates how
many parts will be required in each instance and it gives a convenient way to
refer to the individual parts in descriptions of the behavior of the instance.
For example, the first implementation of Rectangle mentioned previously might
call its parts minX, maxX, minY and maxY.  The second implementation mentioned
might call its parts origin and corner.

A Class describes the behavior of its instances when they receive messages with
a message dictionary.  The message dictionary is an instance of class Dictionary
that associates message selectors with methods for responding to messages.  The
method associated with a certain selector describes what an instance will do
when it receives a message with that selector.  As mentioned earlier, this
includes sending messages, changing instance parts and responding to the message
that invoked the behavior.  The method is a sequence of descriptions of messages
to be sent and parts to be changed.  The response to the invoking message may be
explicitly described, but since it is mandatory, if an explicit description is
not included, an implicit return of the object itself is assumed.

Optimized Data Structures

Certain Classes of objects in the system are used at such high bandwidth that
their internal representation has been optimized to conserve either the time it
takes to interact with them, the space it takes to store their representation or
both.  These Classes must describe their instances in a different way from the
standard Class description outlined above.

Numbers

Integer is a Class whose instances represent whole numbers between -32768 and
+32767.  The external perspective on Integers is that they respond to messages
with selectors like +,-,/ and *.  This behavior could be implemented several
ways by a standard Class of objects with parts and methods.  These standard ways
of implementing Integers would be too slow for something that happens as often
as Integer arithmetic.  Instead, we have a different internal perspective on
Integers that supports the same external perspective.  An Integer is not made up
of other objects as its parts.  Instead, it has a part that is a binary
representation of its numerical value.  The methods for responding to the
arithmetic messages to Integers are different than normal methods and will be
discussed in the next chapter.

Vectors

Vector is a Class whose instances represent collections or lists of objects.  A
Vector has room to collect a certain number of objects and associates each
object in the collection with an Integer between one and the number of objects
there is room for.  The external perspective on Vectors is that they respond to
messages that associate Integers with objects and messages that return the
objects last associated with particular Integers.  Sending a Vector the message
" 1 _ alpha" would invoke a behavior which would replace its first part with
the object named alpha.  Note that this message is named _ and was sent with
arguments 1 and alpha.  The complementary message is named  and takes a single
argument.  Sending the previously mentioned Vector the message " 1" would
invoke a behavior which would return the first part, the object named alpha in
this case.  Vectors also respond to a message named length by returning the
number of objects there is room for.  As with Integers, this behavior could be
implemented several ways by a standard Class of objects with parts and methods
but such an implementation would be slow and large.  An instance of Vector has
ordinary parts that are other objects.

Dictionaries

Dictionary is a Class whose instances provide a more flexible form of
association than Vectors.  A Dictionary can use any object as a key and the
range of keys need not be specified in advance.  Dictionaries are usually used
to associate names with objects.  We will give a possible implementation for
Class Dictionary as an example.  The actual implementation uses the subclassing
feature of Smalltalk which we will describe in detail later.  A Dictionary has
two parts named names and values.  Both instance parts are Vectors of the same
length.  Dictionary uses the same messages as Vector to make and retrieve
associations (_ and ).  When a Dictionary is sent the message " joe _ beta"
it searches its names Vector for the name joe.  (Note that the  symbol is used
to mean that the name joe is used as an argument and not the object named joe).
If the Dictionary finds joe in the names Vector, it stores the object named
beta as the part with the same index in the values Vector.  When a Dictionary is
sent the message " joe" it searches its names Vector for the name joe.  If
the Dictionary finds joe in the names Vector, it returns the part with the same
index in the values Vector.

Dictionaries are used by the message sending/receiving mechanism in the kernal.
The messages understood by a class of objects are stored in a Dictionary that is
part of the Class that represents the class.  Associated with the names of the
messages are descriptions of the behavior that is appropriate when the messge is
received.  The compiler uses a Dictionary that associates the names of the parts
of fixed length objects with a part index.

-uses of Dictionaries in kernal

direct: messages and methods indirect: names and parts

Strings

String is a Class whose instances represent collections of integers between 0
and 255.  Functionally, the only difference between a String and a Vector is
this restriction on the objects that can be stored.  The restriction allows an
optimized storage structure for Strings which is described in Chapter 12.
Strings are used in various applications where efficiency is required.  For
instance, character strings are stored as a String of indices into a set of
characters which takes less room than a Vector of Character objects.

Methods

Another use of Strings is to store the descriptions of behavior in the system.
There are two basic forms of behavior description, user descriptions and machine
descriptions.  The kernal system is designed to execute machine descriptions and
the basic system provides a translator from user to machine descriptions.  User
descriptions are character strings that contain Smalltalk syntax (names of
objects and messages; and punctuation marks).  Machine descriptions contain
instructions for the virtual interpretation machine.  These instructions are
primitive messages sent to the current MethodFollower.  The behavior of an
object takes two forms, alteration of instance state and sending messages.  A
method is a sequence of message descriptions and state alteration descriptions.

Classes

Class is a Class whose instances represent classes of objects.  A Class
describes the form of its instances, i.e. whether they are all the same length
and if so how many parts they have and what the names of the parts are.  A Class
also describes the behavior of its instances.  The description of behavior is a
Dictionary that associates the names of the messages the instances will respond
to with the Methods that describe specific behavior.

Class Heirarchy

Smalltalk provides a mechanism to make a new Class by augmenting an existing
Class.  The new class is called a subclass of the existing class which is called
the superclass.  A subclass inherits the instance parts and message-method pairs
of the superclass.  It can add instance parts and message-method pairs.  The
added methods may be for new messages or they may redefine the behavior
associated with an existing message in the superclass.  The subclassing
mechanism is implemented by having one of the parts of a Class be its
superclass.  All Classes are subclasses of Class Object at some level.  Class
Object defines no instance parts and only those messages that all objects in the
system are capable of responding to.  Class Object has no superclass.  When the
system wants to find the description of the behavior an object will have when it
receives a message, it looks in the method dictionary of the Class of the
object.  If a method is found for the message name that is used.  If the message
name is not in the Dictionary, the message Dictionary of the superclass is
searched.  This process is repeated up the chain of superclasses until the
message is found or class Object is encountered which terminates the chain.

The Kernel System for Describing and Creating Objects

The description of the objects in the system and the creation of new objects is
accomplished by the Classes in the system.  The Classes rely on certain other
objects to accomplish this task.  All of these objects are part of the kernel
system since they are necessary for the functioning of the system.  This section
lists the Classes of objects that make up the part of the kernel that supports
Class Class.  The discription of each Class includes an italicized statement of
its purpose followed by a description of its function followed by a description
of the messages that are relevant to its behavior in the kernel.  The two
interesting relationships between Classes are class and subclass.  These
relationships are indicated in the following diagram, with class indicated in
red and subclass indicated in blue.  Class Array is included in this diagram but
not in the following descriptions because it participates in the subclass
heirarchy but not in the kernel behavior of its two subclasses.

Object

Class

CollectionClass

Array

Vector

String

HashSet

Dictionary



Object

A primitive form for everything

Object is the ultimate superclass of all objects.  It has no superclass.  It
defines messages understood by all objects.

 otherObject			is otherObject the same as the receiver

class						return the Class object that
describes the receiver (note: that this is the deepest subclass for the
receiver)

hash						return an Integer (this can be
any number, but it must always be the same number for a particular object) (this
message is used in the associative behavior of Dictionaries)

Vector

A primitive form of collection and a primitive form of association

A Vector has a set number of slots for objects.  Each of the slots is numbered
and the objects in the collection are placed in specific slots.

length						how many objects are there room
to collect

 index _ value			include value in the collection associated with
index (which must be an Integer between 1 and the length of the receiver)

 index					return the object in the collection last
associated with index

String

A primitive form of collection and association optimized for collecting Integers
between 0 and 255

A String behaves like a Vector except that the objects collected must be numbers
between 0 and 255.  Strings are used to represent descriptions of behavior
called methods.  The methods consist of instructions (primitive messages) for
the interpretive machine.  The instructions are represented as numbers between 0
and 255.  Strings are also used for optimized collection of text.  The text is
represented as a collection of indices into a character set.

length						how many objects are there room
to collect

 index _ value			include value (which must be an Integer between
0 and 255) in the collection associated with index (which must be an Integer
between 1 and the length of the receiver)

 index					return the object in the collection last
associated with index

HashSet

A non-duplicating, unbounded form of collection and a primitive form of inverted
association

A HashSet does not have a fixed number of slots for the objects it collects, it
will accomodate as many objects as are inserted.  If an object that is already
in the collection is inserted, it will only appear once.  Between insertions and
deletions, the HashSet will associate each element of its contents with a unique
Integer.  These numbers may change when an object is inserted or deleted.

insert: value				include value in the collection but
don't duplicate it if it's there already

delete: value				remove value from the collection (it
should have been previously inserted)

contents					return a Vector containing the
objects in the collection

find: value				return a unique Integer associated with
value

Dictionary

An unbounded form of collection of general associations

A Dictionary is a subclass of HashSet that will collect an arbitrary number of
associations of pairs of objects.

 key _ value			include value in the collection associated with
key (which may be any object)

 key						return the object in the
collection last associated with key

Class

A general form of object description

A Class describes a set of objects called its instances.

new						return a new instance of the
receiver

methodFor: selector		return the method (a String) that describes an
instance's behavior when it receives a message whose selector is selector

CollectionClass

A form of description for optimized collection objects (Vector and String)

A CollectionClass describes a set of instances that can be of different sizes.

new: length				return a new instance of the receiver
with length instance parts

methodFor: selector		return the method (a String) that describes an
instance's behavior when it receives a message whose selector is selector

The Implementation of the Kernel Classes

This section describes how the Classes listed in the last section are
implemented.  This includes a description of the parts of the objects and the
methods for responding to the kernel messages.  Many of the methods are what we
call primitive methods.  These are programs for the implementation machine as
opposed to regular Smalltalk methods.  They can directly interact with the
virtual memory of the machine.  Some of the methods refer to pointers to
objects.  A pointer to an object is a unique number that the virtual memory uses
to refer to an object.  For instance, the virtual memory represents the parts of
objects by associating the pointers to the parts with the pointers to the
object.

Object

A primitive form for everything

Most objects in the system are not direct instances of Object but rather
instances of some subclass of Object.  The three instances of Object itself are
true, false and nil.  The objects called true and false are used to represent
logical values and nil represents the default value for a part of an object.
Object does not contribute any instance parts so these three objects have no
parts at all.  As a consequence, true, false and nil are identical except that
they are separate.  The only way to distinguish them is with the  message.  Any
messages that they respond differently to (like print) must ultimately send  to
them.

 otherObject			if the pointer of the argument and the pointer
of the receiver are the same, returns the object true; otherwise returns false

class						returns a pointer to the Class
of which the receiver is an instance.  This is known to the virtual memory

hash						returns an Integer object whose
value is the pointer to the receiver

Vector

A primitive form of collection and a primitive form of association

Vector and String differ from the other Classes in the system in that their
instances do not all have the same number of parts.  The parts of the instances
represent the objects in the collection and different collections have different
sizes.  This is a storage and access efficiency consideration since collections
could be represented as linked lists in the manner of Lisp cons cells.  Because
a Vector has a fixed number of parts, this number must be specified when a new
instance is made.  This is reflected in the fact that Vector and String are
instances of CollectionClass instead of Class.  Instead of the new message for
instantiation, CollectionClass uses a message called new: that takes an argument
of the size of instance desired.

length						returns the number of parts in
the receiver which is known to the virtual memory

 index _ value			requests the virtual memory to replace the
pointer representing the indexth part of the receiver with the pointer to the
object supplied as an argument.  Returns the argument

 index					returns the pointer of the indexth part
of the receiver

String

A primitive form of collection and association optimized for collecting Integers
between 0 and 255

A String is a further optimized form of Vector.  Since only Integers can be
instance parts, the virtual memory stores the values of the parts instead of
pointers to the parts.  This is space efficient since pointers are longer than
the eight bits necessary to store a value between 0 and 255.

length						returns the number of parts in
the receiver which is known to the virtual memory

 index _ value			requests the virtual memory to replace the value
of the indexth part of the receiver with the value of the Integer supplied as an
argument.  Returns the argument

 index					return an Integer whose value is the
indexth part of the receiver

HashSet

A non-duplicating, unbounded form of collection and a primitive form of inverted
association

A HashSet has one instance part named objects. objects is a Vector in which the
HashSet stores the objects it collects.  The HashSet determines where to store
objects in objects with a hashing scheme to make duplication of objects
efficient to detect.

insert: value				if the argument is not in objects,
include it

delete: value				remove the argument from objects

contents					return a copy of objects with
any nils removed

find: value				return the index of the argument in
objects

Dictionary

An unbounded form of collection of general associations

A Dictionary is a subclass of HashSet which adds another instance part named
values, so Dictionaries have two parts named objects and values.  values is a
Vector of the same length as objects.  When two objects are associated, the key
is inserted in objects using the HashSet insert: method described above.  The
value to be associated with the key is then stored in values in the part with
the same index.

 key _ value			include value in the collection associated with
key (which may be any object)

 key						return the object in the
collection last associated with key

Class

A general form of object description

A Class describes a set of objects called its instances.

new						return a new instance of the
receiver

methodFor: selector		return the method (a String) that describes an
instance's behavior when it receives a message whose selector is selector


<Caution, I have only just begun the editing of this>



VIII

Compilation of Smalltalk-76





The Purpose of Compilation

The compiler takes a single method expressed in the Smalltalk source language
and translates it to the byte-coded object language.  If it detects errors
during translation, it notifies the user by inserting an error message into the
source text at the point of the error.  If no errors are detected, the method is
installed in the specified message dictionary and immediately becomes part of
the environment.

The Structure of the Compiler

The compiler has three major phases of operation: initialization, translation,
and installation.  Initialization builds a symbol table with the names of fields
of the class and other standard names, such as self.  It also initializes and
links up the various routines needed during translation.  Translation scans the
source text and generates object code.  Installation converts certain special
methods (such as those with no code body) to a special form, installs the object
code in the message dictionary, and updates the class organizer.

The translation phase is performed by five cooperating modules: the scanner, the
parser, the tree builder, the optimizer, and the emitter.  The scanner scans the
source text and tokenizes it.  The parser matches the token stream against the
productions of the grammar by recursive descent.  The tree builder constructs a
parse tree with one node per production matched.  The optimizer walks the tree
finding opportunities for optimization.  The emitter walks the tree emitting
optimized object code.

The translator operates in three passes.  In pass one, the scanner, the parser,
and the tree builder march together through the input stream; the scanner and
parser are coroutines and the builder is a set of subroutines of the parser.  In
pass two, the optimizer walks the parse tree.  In pass three, the emitter walks
the parse tree and appends byte codes to the output stream.  Of the three
passes, only the first is through the source text, and only the third is through
the object code.  All three passes span the parse tree, the first one building
it, the second one seeking optimizations, and the third one emitting optimized
code.

The time taken by a typical compilation is divided as follows:



Initialization	17%

Translation	61%

Installation	22%

Translation time is typically divided as follows:



Scanner	42%

Parser	42%

Tree Builder	 6%

Optimizer	 5%

Emitter	 5%

These times were determined using the Smalltalk "spy" facility [see chapter Y].
Note that a large portion of the time is taken in scanning and parsing.  If the
method were stored and edited in parsed form, as in the program template
notation (chapter T), these modules could be eliminated and the compiler would
become about twice as fast.  Of course, the speed advantage and the clarity of
program template notation must be weighed against the conciseness and the
free-form editability of linear text notation.



The Scanner

The scanner is a typical table-driven one.  Each time it is asked for a token,
it scans over one identifier, number, or special character and tells its
coroutine (the parser) what it found by sending a message such as integer: chars
where chars is a string of the characters forming a token that is an Integer
literal (see Figure S/P).  The scanner used by the compiler is general enough
that it is used as a front end to other programs such as a code compressor.

The Parser

The parser is a typical recursive descent type.  When it finds a complete
syntactic construct it tells its helper (the tree-builder) what it found and the
helper returns an object that shall represent that construct in enclosing
constructs. (see Figure P/B) For example, during the parse of x _ y + z, the
parser executes the following statements:

...

var _ helper variable: 'x'

...

rcvr _ helper variable: 'y'.

...

arg _ helper variable: 'z'.

...

expr _ helper rcvr: rcvr op: '+' args: arg.

...

stmt _ helper assign: var expr: expr

...

The parser is general enough to be used as a front end in other applications
than compilation.  All one must do is provide a helper other than the tree
builder.  This technique is used in a program that parses a method and displays
it as a two-dimensional program template.

The Tree Builder

Each call on the tree builder returns a node of the parse tree.  The node
belongs to a class associated with the syntactic construct reported by the
parser, e.g., ParsedAssignment in the last example above, ParsedMessage in the
next-to-last.  The fields of the node include the arguments of the call (e.g.,
var and expr in a ParsedAssignment).

The Optimizer

The optimizer makes a top-down scan through the tree.  The scan is performed by
passing a message to the root node, which passes messages to each of its
descendants, and so forth.  In response to the message it receives, each node
returns the number of bytes of object code that it will emit.  Of course, the
node is able to find out from all its descendants how much code they will emit
before it must compute its own amount.  Thus, in a single pass through the tree,
the size of the object code can be determined (see Figure OP).

During the tree walk, any node may attempt an optimization.  For example, a node
of class ParsedConditional representing ifExpr[thenExpr]elseExpr can tell
ifExpr to generate jumps for and/or expressions instead of generating
true/false results.  It can determine the relative destinations of the jumps
before activating ifExpr by first measuring thenExpr and elseExpr.

Thus, each node must be ready to measure itself and emit code differently when
it is in normal use or when it is the condition of a conditional.  Another
distinction is made as well: whether the value of the expression the node
represents is to be used in further computation (wanted for value) or discarded
(wanted for effect).  Each node should respond to three different measuring
messages:

sizeForValue

returns the amount of code the node would emit to evaluate its subtree and to
return the result.

sizeForEffect: nextPush

returns the amount of code the node would emit to evaluate its subtree and to
discard the result.  The argument nextPush (if not false) is a variable that the
parent node knows will be pushed onto the stack immediately after this node
completes its evaluation (the statements in a block are asked their size from
right to left).  If the last code emitted by this node would be store&pop var
and the next code would be var, then this node emits only store without a pop
and the next node emits var, which has the same overall effect but is less
expensive.

sizeForTruth: trueSkip falsity: falseSkip

returns the amount of code the node would emit to evaluate its subtree and to
jump falseSkip when the value is false, trueSkip otherwise.

For some classes of node, some of these messages are defined in terms of each
other or are defined in superclasses.

Each node remembers certain information it computed during the optimizer pass so
that it can generate the correct code during the emitter pass.

Because Smalltalk is a structured language without a goto statement, each node
is able to measure its descendants in an order that assures that the jumps are
measured after the code they jump over.

The Emitter

At the end of the optimizer pass, the compiler knows how much code will be
generated by the method, and it allocates exactly the needed amount of space.

The emitter then makes a top-down scan through the tree by passing messages to
the nodes.  One argument of each message is a stream onto which the node must
emit the amount of code it promised in the optimizer pass.  Another argument to
each message is an object that keeps track of the current and maximum depth of
the stack that will be needed during evaluation; the node must inform that
object of all pushes and pops (see Figure EM).

Each node should respond to three different measuring messages:

emitForValue: code on: stack

appends bytes to code (informing stack of pushes and pops) to evaluate its
subtree and to return the result.

emitForEffect: code on: stack

appends bytes to code (informing stack of pushes and pops) to evaluate its
subtree and to discard the result.

emitForTruth: trueSkip falsity: falseSkip into: code on: stack

appends bytes to code (informing stack of pushes and pops) to evaluate its
subtree and to jump falseSkip when the value is false, trueSkip otherwise.

As above, some of these messages are defined in terms of each other or are
defined in superclasses.

Quality of Code

The compiler has no peephole optimizer and no postscans over the object code,
yet it optimizes boolean expressions perfectly and optimizes out pop-push pairs.
It is cheaper to walk a parse tree an extra time than to recopy object code
squeezing out unneeded bytes.

The implementation of parse tree nodes as objects means that they can retain
state between passes, and that they can receive and pass different messages to
evaluate their subtrees for different purposes.




<Caution, I have only just begun the editing of this>



XV

User Aids

Aids to Program Development and Debugging

[note to editor: we have to agree upon which way stacks grow, up or down, I
learned up in school, e.g., "top of stack", as in a stack of dishes]

[note to editor: I assume the following concepts are already understood by the
reader: filtering template, window, scheduled, window title, window menu,
"close" command, "frame" command, pane, scroll, edit, pane menu, paste,
deleting, compile, doit, overtype, select, selection, highlight, "interrupt"
command (ctrl c), compiler, assignment statement, temporary variables,
arguments, method, PC, call history, context names, deallocate, reference,
context, call stack, class Integer, class Point, applicative programming style,
dialog window, Smalltalk user interface, current version's sluggish execution
speed, class Player, instancewide, classwide, job shop simulation, stations,
workers, jobs, endless loop, commentary, animation, .]

[note to editor: The World Book article assumes that each player can have a
separate script without being in a separate class.  This hasn't been done in
regular Smalltalk, but it is a good idea.  Maybe we should implement it and then
use the feature here.  Or I could assume that players with different scripts are
in different subclasses.  What I am doing for now is forcing the same script on
the whole class.]

[note to editor: It should be already clear to the reader that many aspects of
our system have known room for improvement, but our staff has insufficient time
to accomplish everything our hearts desire, so we settle for less, but not for
too little.]

Tools for Programmers

Since the advent of interactive computing, programmers have been among its prime
beneficiaries.  Facilities devised to allow the users of computers direct access
to their data were seized upon by programmers to directly access their programs.
The ability interactively to edit, compile, test, and debug programs is now
considered by many programmers to be essential to their productivity and
satisfaction during at least certain stages of the software development process.

Indeed, many programming languages that have grown up in the era of interactive
computing have been set into interactive programming systems.  For example,
BASIC, LISP, and APL systems almost always provide an interactive environment
integrating editing, execution, and debugging.  There are many variations in the
way these facilities are presented; for example, some systems execute compiled
code while others interpret source programs or some intermediate-level language.
But the basic idea is the same.

Smalltalk is a highly interactive system emphasizing two-dimensional display of
information.  It is natural to expect its program development aids to be
organized the same way.  There are many ways to present these facilities, and in
fact, several have actually been tried.  In this section, we will discuss the
aids that are most commonly used in our current Smalltalk system (schemes), and
then talk about aids we wished we had (dreams).  [It should be noted that the
current Smalltalk debugger was itself a dream in many people's minds a few years
ago.]

Programming is to a certain extent a craft.  It is not difficult to create an
analogy between programming and carpentry.  In both crafts, any structure can be
banged together, but some structures hold up better than others.  The ideal
craftsman with perfect materials and tools should be able to build a perfect
structure methodically and elegantly.  In reality, imperfection is the rule, so
parts that don't quite fit have to be adapted, shims have to be inserted here
and there, sections have to be undone and reworked, and so forth.

A craftsman places great value on having the right tools.  A carpenter building
a shelf for his garage may be more than delighted to use simple hand tools.  To
build a house for a contractor, he more than likely will insist upon power saws
and nailing guns.  Similarly, a professional programmer writing a cosine routine
for a microprocesor may joyously code it in assembly language and debug it with
a hexadecimal debugger.  To build a sophisticated multi-user operating system he
will probably insist upon a systems programming language and a symbolic
debugger.

The Smalltalk system provides a set of tools for the programmer that match the
capabilities of the language and the purposes for which it is intended.  The
language is appropriate for the construction of large systems with hundreds of
modules (classes), thousands of data units (objects), and thousands of
procedures (methods).  Such a large system can not be grasped by a single person
in a single moment.  It is necessary to structure the system in an orderly
fashion and to filter the information presented to the programmer so he can
focus on portions of interest.

Debugging Tools

The debugging facilities provided to a programmer affect his style of debugging.
Similarly, the programmer who understands the debugging facilities thoroughly
can more effectively use them.  It is impossible to please everyone's taste and
habits with a single facility, but it is reasonable to provide a set of
facilities that are very general and easy to learn.

One of the principal tactics employed by a programmer during debugging is the
examination of state at a known point of program execution.  Traditionally, the
state has been displayed as a "dump" of areas of memory or as the contents of
individually requested cells.  In interpretive systems like BASIC, LISP, or APL,
the programmer simply types a normal program statement for immediate execution
that has the effect of printing values of interest onto the terminal.  This
technique is also available in Smalltalk.  However, it is needed less often than
in other systems, as will be shown.

Notification Windows

The Smalltalk debugger displays state of interest to the programmer through a
filtering template called a "Notification window".  A notification window
appears on the display in either of the following circumstances: (1) An error,
warning, or breakpoint message is sent to the user by some system or application
method; (2) the user issues an "interrupt" command.  In either case, the
debugger gets control and severs its call stack just after the context that was
running at the point of interruption.  A new notification window is created,
displayed, and scheduled, in which is a reference is held to the severed stack.
Through interactions with the notification window, the programmer can examine
the state that is "frozen" in that stack.

Because the stack held by the notification window has been severed from the main
stack, the programmer can continue to run the Smalltalk user interface after the
notification window appears, unless, of course, the error was caused by a
low-level bug that also disables the user interface.  Usually, the programmer
will proceed to investigate the bug by interacting with the notification window.
However, such a strategy is not mandatory.  One may instead work in other
windows on tasks related or unrelated to the cause of notification.  If another
error occurs, another notification window will appear.  There may be many such
windows and they can be ignored by the programmer or dealt with in any order.
Furthermore, if an error occurs during interaction with a notification window,
another notification window is created to hold the stack of that error.

(Note.  There is an endless loop danger if the methods that create and schedule
a notification window themselves have bugs.  This can happen if someone
erroneously changes a low-level method that is used by the notification
facility.  The effect would be that the first time a notification window began
to be created, an "endless" series of incomplete notification windows would be
created instead.  To prevent this from happening, a crude protection facility is
employed.  A global flag is set during the installation of a new notification
window, and any error message during the time that flag is set is sent to the
dialog window, whereupon the user -- presumably an expert -- is forced to
interact with a crude dialog-style debugger just strong enough to find and
correct the low-level error and get the full user interface going again.)

There is some danger in ignoring a notification, in that the held stack may
reference objects whose internal state could change during ensuing activities.
In practice, we have found such occurrences to be rare, and when they do happen,
usually obvious to the programmer.  This good fortune is due largely to the
strong tendency of Smalltalk programs to localize variable information in
instances and especially in methods, and for global information to be
effectively constant.  Furthermore, applicative programming style tends to
create new instances of fast-changing objects (such as instances of class
Integer or Point) rather than altering old instances.  Therefore, little
information shared by many stacks is variable.

When the notification window first appears, it has one pane, a "stack pane", as
in Figure 1.  This pane shows the name of the top context in the stack, i.e.,
the class and method that were running at the time of the error, breakpoint, or
interruption.  The title of the window is the error message itself, hopefully a
helpful sentence.

The programmer now has several choices: (1) ignore the error for now; (2) invoke
"close" in the window menu, which erases the window and deallocates the held
stack -- this tactic may be appropriate if the source of the problem is already
apparent, or if the message was a warning the programmer decides to heed; (3)
invoke "proceed" in the stack pane menu, which closes the window, but resumes
the held stack instead of deallocating it -- this is appropriate to proceed from
a breakpoint or if the message was a warning the programmer decides to ignore;
(4) invoke "stack" in the stack pane menu, which fills the pane with a
scrollable list of stack context names, to reveal the call history; (5) invoke
the "frame" command, which allows the window to be moved and resized, but which
also changes it from a one-paned to a six-paned window to gain access to a
richer variety of state information.

Are all these options really necessary?  In a system with higher execution speed
than our current one, it would not be necessary to provide the "stack" command,
because it would take insignificantly longer to display the "whole" stack in the
first place.  Furthermore, it would be possible to create all six panes from the
start.  The latter possibility is not necessarily desirable.  The one-paned
version takes less space on the screen than the six-paned version and thus
interferes less with other windows.  In those cases that the programmer wishes
to explore the error further, a larger window will be needed that is likely to
interfere with other windows, so he should have control over where it appears.

Now let us describe the six-paned version of the notification window.  The
choice of panes is not sacred.  The panes are arranged in three rows of two (see
Figure 2).  All of them can scroll.

The upper left pane is the previously decribed stack pane.  The upper right pane
is the "code pane".  The user can select any context in the stack pane by
pointing at it, and the code pane will display the full method running in that
context in source code form.  (Dream: we would like to indicate graphically the
point within the method where execution was interrupted, but this would take too
much time and/or space [why] in the current system.  By looking at the next
level up in the stack the user can tell what message was passed, and usually it
is obvious what statement did it.)

The middle left pane is the "context variable pane".  It displays the names of
all the arguments and temporary variables at the selected stack context, if any.
The middle right pane is the "context value pane".  The user can select any
variable name in the context variable pane and the value of that variable will
print in the value pane.  (Printing is accomplished by passing a message to the
value of the variable, and in a buggy program this can lead to another error
message.  The programmer may investigate the new error, defer it, or close the
window and work more on the original error.)

The lower left pane is the "instance variable pane".  It displays the names of
all the fields of the object executing the selected stack context, if any.  The
middle right pane is the "instance value pane".  The user can select any
variable name in the instance variable pane in an analogous fashion to the
middle row of panes.

In any of the panes in the second column, the user may type, edit, and execute
code (doit).  Code is executed in the selected context; therefore, local
variables may appear in the code.  In particular, any variable can be changed by
typing an assignment statement and doing a doit.  Also, any expression or
statement in the method can be executed on demand, in context, by selecting it
and doing a doit.  If the selected expression has a value of interest, the user
can paste it into one of the same panes, usually a value pane.  The power of
these techniques is often underestimated by beginners.

If the programmer decides to change a method in the code pane, he can edit it
and compile it.  The debugger assumes that all contexts above the edited method
are to be deallocated, and the stack is truncated until that context is on top.
The PC is set back to the beginning of the recompiled method so that "proceed"
will in fact restart the method; arbitrary edits can render other paths of
action senseless (in fact, if the arguments of the method are changed,
restarting usually becomes meaningless and will probably lead to another error).

Inspection Windows

There is one further feature in the debugger, the ability to trace through data
structures.  The message "inspect" can be sent to any object, and that object
will let the user draw out a two-paned window with an "instance variable pane"
and an "instance value pane".  The variable pane displays the names of the
fields of the inspected object, and selected fields display their values in the
value pane.  This "inspection" window is like the bottom row of a notification
window.

One way to make an inspection window to inspect x is to type "x inspect" and
then do a doit.  Of course, x may be any expression (often parenthesized because
of the precedence of inspect).  An easier way, when appropriate, is to select a
variable name in any value pane of a notification window or of an inspection
window, and to invoke "inspect" in its variable pane menu.  By a succession of
cascaded "inspects", a data structure can be traced.  [This, too, is a feature
underutilized by beginners.]  (Sometimes many inspection windows get created and
it would be nice to be able to manage them well -- closing batches of them for
example.)

Breakpoints

There is one important feature almost completely lacking from the present
debugger: the ability to set and clear breakpoints.  We would like to allow the
programmer to point at any reasonable spot in the code pane and set a breakpoint
there.  Then there would be a pane listing all breakpoints, and a menu for
clearing them.  Instead, the crude facility we offer is that the programmer can
edit and compile the method to insert an explicit breakpoint statement (user
notify: 'any text') that when executed will create a notification window with
the desired text as the title.  To clear the breakpoint, it is then necessary to
re-edit and recompile the method.  There are no present aids to keeping track of
all set breakpoints.

Compilation Errors

One class of errors does not use the notification machinery at all.  When the
compiler detects a syntax error or certain other errors, it terminates
compilation, inserts an error message into the displayed version of the method,
and highlights the error message to dramatize it.  The programmer normally reads
the message and then deletes it; since the error message is highlighted, it is
in fact the selection, so deleting takes a single keystroke.  (In the case of a
missing something, it is often possible to simply overtype the error message
with the something.)  Then the correction is made and compilation restarted at
programmer command from the beginning of the method.

Debugging

Given all this machinery, how may a programmer actually solve and correct a bug?
Let us follow through some examples.

Assume the following interface to class Player (see Chapter N):



Instancewide.

location	The current position of the player.

angle	The current direction of the player.

size	The current size of the player.

costume	A picture of the player.

Classwide.

erase	Make the player's image disappear.

display	Make the player's image appear.

turn: angle	Turn the player and its image by angle degrees.

go: dist	Move the player and its image by dist units.

polygon: sides	Inscribe a polygon with sides sides 10 units long.

script	A script for the player to perform.

run	Perform the script.

stop	Stop performing the script.

Correct methods to make the player follow a pentagonal path are:



script [self polygon: 5]

polygon: sides | i

[for i to: sides do

[self go: 10. self turn: 360/sides]]

Let us introduce various trivial bugs into polygon and see how a programmer
might find and fix them.

Error 1. Syntax Error: missing right bracket.



polygon: sides | i

[for i to: sides do

[self go: 10. self turn: 360/sides]

When compilation is attempted, the missing right bracket will be detected and
reported by inserting an error message into the text, thus:



polygon: sides | i

[for i to: sides do

[self go: 10. self turn: 360/sides]PERIOD OR RIGHT BRACKET EXPECTED

The programmer can simply overtype the message with a right bracket and reinvoke
compilation.

Error 2. Semantic error: message not understood.



polygon: sides | i

[for i to: sides do

[self go: 10. self turj: 360/sides]]

When "run" is invoked, the message turj: 72 will be sent to the player.  The
message will not be found in the message dictionary of its class or of any
superclass, so the notification window of Figure 3 will appear.  The title is
"Player does not understand 'turj:'".  The stack pane displays the name of the
context that invoked the error, Player turj:.

There are four possible causes of the "does not understand" error message: (1)
the right message was sent to the wrong recipient; (2) the wrong message was
sent to the right recipient; (3) the wrong message was sent to the wrong
recipient; (4) the right message was sent to the right recipient, but the method
was not defined by the recipient's class nor by any of its superclasses.

In the present example, it is likely to be obvious to the programmer that the
problem is a misspelling of the message name, i.e., case (2).  Two alternative
courses of action would be:

(A) Close the notification window.  Locate the definition of polygon in the
Browser.  Select the letter "j" in turj: and overtype it with an "n".  Invoke
"compile".  Invoke "run" to restart the simulation.

(B) Invoke "frame" to grow the notification window to six panes.  Invoke "stack"
to see the call history.  To see who called Player turj:, read the name of the
second context on the stack: Player polygon:.  Select that context.  Watch the
definition of polygon: sides appear in the code pane.  Select the letter "j" in
turj: and overtype it with an "n".  Invoke "compile".  Watch the top context
disappear from the stack as Player polygon: advances to the top.  Invoke
"proceed" to re-execute the method and continue the simulation.

In this example, the first method seems more efficient.  In more complex
examples, it is possible that the simulation was running for minutes or hours
before the error was encountered.  Method (B) allows it to resume from where it
left off without repeating the portion that was error-free.

Suppose it were not obvious to the programmer that a misspelling was the
problem.  Circumstances likely to obscure the cause include: someone else was
the author of the erroneous code; the message name was a sensible word (next
misspelled as nest); the message name was the name of a message understood by
other classes (block misspelled as black).  A course of action would be:

(C) Invoke "frame" and then "stack" and select Player polygon: in the stack
pane.  Read the definition of polygon: sides in the code pane and locate the
call on Player turj:.  Consider the possible causes: (1) self the wrong
recipient; (2) turj: misspelled; (3) both wrong; (4) definition of turj: omitted
from self's class, Player.  Checking the cross-reference of messages would
reveal that no class defines turj:, so the most likely causes are (2) turj:
misspelled and (4) an omitted definition.  Reasoning about the algorithm and
scanning of the methods defined in class Player expose the problem as (2) a
misspelling of turn:.  Correct the spelling, compile, and proceed.

Error 3. Algorithmic error: line instead of polygon.



polygon: sides | i

[for i to: sides do

[self go: 10. self turn: sides/360]]

Since the fraction is inverted, sides/360 will be 5/360 which will be 0.  Once
"run" is invoked, the message turn: 0 will be sent to the player after each side
is drawn.  Thus, the player will travel in a straight line instead of along a
pentagonal path.  A programmer may consider the following possibilities: (1) go:
is going too far, either because it has been invoked incorrectly or has been
defined incorrectly; (2) turn: isn't turning far enough, or is turning 360
degrees, due to either incorrect invocation or definition; (3) the script hasn't
been compiled, or the wrong player has been told to run, or some other "didn't
plug in the power cord" type of error has occurred.

This example is simple enough that the programmer is likely to solve it in short
order.  However, human beings often fail to see the obvious.  Let us assume that
the person is very methodical, or that he trusts his own code too much and
suspects that the fault lies elsewhere.  An approach to tracking down this bug
is:

Stop the simulation.  Set breakpoints at the beginning of Player go: and Player
turn:.  Rerun the simulation.

The breakpoint in go: will be encountered first.  A notification window will
appear whose stack pane names the context Player go:.  By reframing the window
to six panes and selecting that context, the code pane and the variable panes
will be filled.  In the code pane, it can be seen that the argument of go: is
dist.  By selecting dist in the context variable pane, its value, 10, will
appear in the context value pane.  Since this is correct, invoke "proceed".  The
notification window will disappear, the simulation will proceed for a moment,
and the player will correctly travel 10 units.

Next the breakpoint in turn: will be encountered.  A notification window will
appear whose stack pane names the context Player turn:.  After reframing the
window and selecting that context, it can be seen that the argument of turn: is
angle.  By selecting angle in the context variable pane, its value, 0, will
appear in the context value pane.  Since this is incorrect, the bug has been
localized.

Invoke "stack" to see the call history.  Select the second context on the stack,
Player polygon:.  Find the call on turn:, select its argument, sides/360, and
"doit".  Paste the result in a value pane and see that it is 0.  Now the bug has
been traced closer to its source.

Through the context panes, determine the value of sides; it is 5, which is
correct.  Given that sides is right, but sides/360 is wrong, the bug must be in
that division.

After reasoning to the correct expression, 360/sides, note that sides/360 is
still selected in the code pane, so simply overtype it by the correct
expression.  To verify its correctness, "doit" and "paste" its value into a
value pane.  The result, 72, seems more reasonable than 0, or may even be
realized by the programmer to be correct.  Further verification can be obtained
by selecting self turn: sides/360 and invoking "doit" a number of times.  A
complete revolution of the player's image is accomplished by five "doits", which
is the desired effect.  Edit out the breakpoint and "proceed".

When the breakpoint in go: is reencountered, edit it out and "proceed" again.
The player will follow a pentagonal path as intended.

Manual Interruption

An "interrupt" command is always available to stop all simulations from running
and to create a notification window with the name of the interrupted context in
the stack pane.  If a simulation seems to be in an improper endless loop, the
"interrupt" command enables the programmer to halt it and examine the stack to
determine what method is looping.

Another use of the "interrupt" command is to learn about how a simulation
written by someone else works.  Start running their simulation, and at a point
that you would like to understand "how it is done", invoke the "interrupt"
command.  By looking at the methods on the stack and reading their commentary,
and by inspecting the values of the variables at each level, a lot of
information about the workings of the simulation can be gleaned.

Other tools for understanding the dynamics of a simulation have been tried
experimentally in various versions of Smalltalk.  There is an animated
illustrator that works like the job shop simulations (see chapter S).  The
stations of the job shop are objects and the jobs are messages.  The program
simulates the Smalltalk interpreter itself, and animates illustrates the passing
of messages between objects by animation. [Peter write this section]

Still other tools have been proposed but not yet implemented. [Examples --
Adele?]

Program Creation Tools

In any large system, printed program specifications, readable program listings,
and cross-reference listings are of great help to programmers.  The Smalltalk
system attempts to provide many such services on-line.  The principle services
are The Browser, The Listing Generator, Masterscope, The Cross-Reference
Generator, and Findit.  Findit is an information retrieval system described in
chapter F.  The other services will be described briefly here.

The Browser is a filtering template used to view the classes and methods of the
Smalltalk system.  It is a five-paned window as shown in Figure B.  The panes
are named system pane, class pane, organization pane, selector pane, and code
pane.

In the most common situation, the class pane lists the names of some of the
classes in the system.  One of those class names has been selected by the user
and is highlighted.  The selector pane lists the names of some of the messages
understood by the selected class.  One of those message names has been selected
by the user and is highlighted.  The code pane displays the method used by the
selected class to respond to the selected message.

The system pane and the organization pane provide additional levels of
filtering.  Rather than have the class pane list all the classes in the system
(there are over 100 in the current basic system), the classes are grouped into
ten to twenty categories, such as 'Graphical Objects', 'Numbers', 'Windows',
'Documents', and 'Events'.  The system pane lists the names of the categories.
When the user has selected one of the categories, the class pane displays the
names of the classes in that category.

Similarly, the messages of a given class are grouped into one or more
categories, such as 'Initialization', 'Aspects', 'Showing', 'Editing', and
'Private'.  The organization pane lists the names of the categories for the
selected class.  When the user has selected one of the categories, the selector
pane displays the names of the messages in that category.

Each pane has a menu that operates on the selected item in that pane.  For
example, the class pane menu includes a "print" command.  When it is invoked,
the selected class generates a printed listing of its definition and methods.
The system pane menu also has a "print" command that generates a printed listing
of all the classes in the selected category.

The Browser thus has several uses related to reading the system.  The user can
browse through the system on-line by selecting filters in a four-level
hierarchy.  The user can obtain off-line listings by menu invocations at certain
levels of filtering.

The Browser can be used not only to read the system but also to change it and to
add to it.  For any message displayed in the code pane, the user can edit the
pattern and/or the method.  Invoking "compile" in the code pane menu will check
the syntax, and if correct, will install the method under the specified pattern
in the specified class.  The pattern may represent a new method for the class,
or an old one that is being revised.  There is also provision for changing the
organization of classes in the system or of messages in any class, and for
defining new classes; these facilities will be described shortly.

While the Browser provides filtering views of the definers of system facilities,
the Masterscope facility (named after an Interlisp facility that inspired it)
provides filtering views of the clients of those facilities.  For example, the
Browser can answer the question, "How does class Rectangle respond to the
message has: point?" while Masterscope can answer the question "What methods
send the message has: point?".  In other words, Masterscope is an interactive
cross-reference facility.  Currently, Masterscope inquiries are conducted as a
dialog rather than through a pane-and-menu facility.

Just as one can browse on-line or obtain listings off-line, one can obtain
cross-references either on-line or off-line.  The system has a message that
prints a complete cross-reference of every message, what classes define it and
what methods invoke it.

Filtering templates based on the Browser have been constructed to view other
hierarchical information structures [ref. Simulation Kit, ThingLab Browser].
The concept can be extended to any multi-level information structure stored as a
directed graph.  If the structure can be searched to a large number of levels, a
class of paned windows would have to be defined that could vary its number of
panes, or separate windows could be used, as in the inspection facility.

Program Modification

Defining new methods.  Incremental coding.  Spawn.  Alternatives.

Defining new classes.

Reorganizing.

Changing class definitions.  Current restrictions.  Solutions.

Approaches to program development.





