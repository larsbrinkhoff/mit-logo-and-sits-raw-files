.STITL TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI

;TO DO:
;FIX INTERRUPT MACROS
;HARDWARE INITIALIZATION
;MODEM AND ERROR CODE
;SYSTEM CODE
;MULTIPLE DM
;PGEN1
;DING

	VERN==VERN+%FNAM2

NMODEM==1
.STITL TELETYPE MACROS

.MACR TBK
	.BLKW	NLTY
.ENDM
.STITL TELETYPE DISPATCH TABLES--DATA SPACE

;ALL FOLLOWING CODE CAN BE IN DATA SPACE ONLY!!!!!!!!!!

;DISPATCH TABLE FOR CHARS WITH SPECIAL EFFECT ON TYI INT LEVEL
;(FSF ON IN DTBL) RTSPC IS ADDR OF RTS PC
TIICTB:	RTSPC	;^C
	RTSPC	;^D
	TICG	;^G BREAK TO LEVEL 0
	RTSPC	;^M
	RTSPC	;^N
	TICQ	;^Q QUOTE NEXT CHAR
	RTSPC	;^R
	RTSPC	;^S
	RTSPC	;^W
	RTSPC	;^X
	RTSPC	;^Y
ATICZ:	TICZ	;^Z BREAK TO LEVEL N
;ATICZ:	TIIBPT
	RTSPC	;RUBOUT
	RTSPC	;[
	RTSPC	;]
	TICB	;^B - CHANGE TO %

;DISPATCH TABLE FOR SPECIAL INPUT CHARS WITH EFFECT ON TYPEOUT LEVEL
TOICTB:	TOICC	;^C COPY NXT CHAR FROM EDIT TO TYI BUFFER
	TOICD	;^D DELETE NEXT CHAR FROM EDIT BUFFER
	SKIPR	;^G
	TOICM	;^M POSSIBLE END OF LINE
	TOICN	;^N COPY NEXT WD FROM EDIT TO TYI BUFFER
	TOICQ	;^Q JUST ECHO
	TOICR	;^R COPY REST OF EDIT BUFFER TO TYI BUF
	TOICS	;^S SKIP NXT WD IN ED. BUF.
	TOICW	;^W RUB OUT UP TO PREVIOUS WD SEPERATOR
	TOICX	;^X CLARIFY INPUT
	TOICY	;^Y RECOVER PREVIOUS LINE
	SKIPR	;^Z
	TOIRB	;RUBOUT
	TOIOB	;[ INCREMENT LIST COUNT
	TOICB	;] DECREMENT LIST COUNT
	SKIPR	;^B

;DISPATCH TABLE FOR CHARS SPECIAL ON OUTPUT
;(HAVE FOF ON IN DTBL(CHARACTER)
TOOCTB:	TOOCA	;^A PRINTS AS C.R.
	TOOCH	;^H BACKSPACE, DECREMENTS CHARNO
	TOTYOC	;^G PRINTS AS SELF
	TOOCM	;^M PRINTS AS CR, LF
	TOOCI	;^I (TAB) SPACES TO NEXT TAB STOP
	TOTYOC	;^J (LINEFEED) PRINTS AS SELF
	TOTYOC	;^K (VERTICAL TAB) PRINTS AS SELF
	TOTYOC	;^L (FORMFEED) PRINTS AS SELF
.STITL TELETYPE VARIABLES

NLTY==NTTY+<5*NTBOX>	;TBOX +4 DEVICES
NMXTY==NTBOX
NPORTS==NLTY+<20*NDM>-NDMTY	;DON'T DUPLICATE DM11 TTYS

;STANDARD DEVICE REGISTER BITS
%ER==1_15	;ERROR
%RDY==1_7	;READY
%INT==1_6	;INTERRUPT ENABLE
%CRDT==1_2	;CARRIER DETECT
%ENB==1		;ENABLE
%DTRDY==1	;DATA TERMINAL READY

TBKCH:	7	;^G BREAK TO LEVEL 0
TBKCHL:	32	;^Z BREAK TO LEVEL N
LINEL:	60.	;LINE LENGTH

OMXRES=.-NFTBOX
	OMXNUL==OMXRES+1	;RH--RESET CHAR, LH--NULL CHAR
	.BYTE 21,0	;TBOX (DC0)
	.BYTE 0,40	;TURT 1
	.BYTE 0,40	;TU 2
	0	;MBX
	.BYTE 0,21	;DUMMY

TUDN:	ZEPT NTUR,NFTUR+<2*.RPCNT>

;USE TELETYPE TABLE--LOGICAL TTY FOR EACH USER
UTYTB:	ZEPT NTY,NFTY
	ZEPT MNUSRS-1,NFDMTY+<2*.RPCNT>

TYRS:	;RECEIVE VECTORS FOR EACH TTY
	TKS	;CONSOLE TTY
	DC1RS	;DC1
.IIF Z DHON,	ZEPT 20,DM0CSR	;DM11 TTYS
.IIF NZ DHON,	ZEPT 20,DH0SCR
 	DC0RS	;DC0
	ZEPT 4*NMXTY,-1	;PSEUDO TTYS

TYPTYP:		;PHYSCIAL TTY TYPE
	TPMODM==100000	;MODEM
	TPMPX==40000	;MULTIPLEXOR
	TPPTY==20000	;PSEUDO TTY OR MULTIPLEXEE
	TPDM==10000	;DM11 TTY
		;RH=CPS/10.
	3		;CONSOLE TTY
	3		;DC1, MODEM
	ZEPT 20,TPDM!3	;DM11S
	TPMPX!12	;DC0, THORTON BOX
	TPPTY!3		;TURTLE 1
	TPPTY!3		;TURTLE 2
	TPPTY!3		;MUSIC BOX
	TPPTY!3		;DUMMY

TILTTY:		;RH--LOGICAL TTY # OF EACH PHYSICAL TTY
		;-1 IF ILLOGICAL
		;LH--MPXR #, -1 IF NOT MPXED
	ZEPT NTTY,<
	.BYTE 2*.RPCNT,-1		;CONS, DCS, KLS AND DM11 TTYS
	>
	ZEPT 20-NDMTY,-1	;REST OF DMS
	ZEPT NTBOX,<		;THORTON BOXES
	.BYTE NFTBOX+<2*.RPCNT>,-1
	>
	ZEPT 4*NTBOX,<			;LOGICAL DEVICES
	.BYTE NFTUR+<2*.RPCNT>,NFTBOX+<2*<.RPCNT_-2>>
	>

TYCKBP:	ZEPT NLTY,TYCKBK+<.RPCNT*10>	;PNTRS TO CLOCK BLOCK
TYCKBK:	ZEPT NLTY,<
	.BLKW 3	;CLOCK BLOCK	(3 WDS FOR EACH MODEM)
	2*.RPCNT	;TTY INDEX (FOR CLOCK LEVEL STUFF)
>
TTYU:	TURUSE==.+NFTUR
	ZEPT NLTY,-1	;USER FOR EACH TTY
TIPTTY:	TBK	;FROM TILTTY
MXNUM==TIPTTY+1	;MXPR NUM LH, -1 IF NOT MPXED
TTYTP:	TBK	;TTY TYPE
TTYST:	ZEPT NLTY,TIMAGE!TIMAGI	;TTY STATUS
	TICLKQ==100000	;ENTRY ON CLKQ
	TILIPM==40000	;LINE INPUT MODE
	TICVM==20000	;CONVERT CASE MODE
	TIECM==10000	;ECHO MODE (INPUT)
	TIEDM==4000	;EDIT MODE
	TIRBM==2000	;RUBOUT MODE
	TIMAGE==1000	;IMAGE MODE (OUTPUT)
	TIMAGI==400	;INPUT IMAGE MODE
	TOTRAN==200	;CURRENTLY TRANSMITTING
	TIQF==100	;QUOTE NEXT CHAR
	TIBR==40	;BREAK TYPED BUT NOT PROCESSED BY USER
	TIRST==20	;RESET INPUT ON INTERRUPT LEVEL

TIRCV:	ZEPT NLTY,TYRCV	;ADDRESS TO JSR TO WITH RECEIVED CHARACTER
TBICH:	.BLKW NTBOX		;THORTON BOX IDENTIFYING CHARACTER
.EVEN
TBCHN:	.BLKW NTBOX	;# OF CHARS EXPECTED FROM THIS THORTON BOX

	TIQSZ==300
	;INPUT Q POINTERS
TIQ:	.BLKB TIQSZ*NLTY	;QUEUE
TIQN:	TBK	;# OF CHARS IN INPUT Q
TIQMX:	ZEPT NLTY,TIQSZ	;MAX # OF CHARS ALLOWED IN INPUT Q
TIQT:	ZEPT NLTY,TIQ+<TIQSZ*.RPCNT>	;PNTR TO TOP OF QUEUE
TIQL:	ZEPT NLTY,TIQ+TIQSZ+<TIQSZ*.RPCNT>	;PNTR TO 1 BYTE PAST END OF QUEUE
TIQI:	ZEPT NLTY,TIQ+<TIQSZ*.RPCNT>	;PNTR TO WHERE NEXT CHAR GOES IN
TIQO:	ZEPT NLTY,TIQ+<TIQSZ*.RPCNT>	;PNTR TO WHERE NEXT CHAR COMES OUT
TIBC:	TBK	;# OF UNMATCHED ['S IN TYI BUFFER
TIQTO:	ZEPT NLTY,TIQ+<TIQSZ*.RPCNT>	;PNTR TO WHERE TYO IS PROCESSING
TIQTON:	TBK	;# OF CHARS FOR TYO TO PROCESS
MXNCH==TIQN	;DOUBLES AS IMX DEVICE Q
IMXQT==TIQT
IMXQL==TIQL

	TEQSZ==TIQSZ
	;EDIT Q PNTRS
TEQ:	.BLKB TEQSZ*NTTY
TIEQN:	TBK	;# OF CHARS IN EDIT Q
TIEQMX:	ZEPT NLTY,TEQSZ	;MAX # OF CHARS ALLOWED IN EDIT Q
TIEQT:	ZEPT NLTY+1,TEQ+<TEQSZ*.RPCNT>	;PNTR TO TOP OF QUEUE
TIEQL==TIEQT+2	;PNTR TO 1 BYTE PAST END OF QUEUE
TIEQI:	ZEPT NLTY,TEQ+<TEQSZ*.RPCNT>	;PNTR TO WHERE NEXT CHAR GOES IN
TIEQO:	ZEPT NLTY,TEQ+<TEQSZ*.RPCNT>	;PNTR TO WHERE NEXT CHAR COMES OUT
TIEBC:	TBK	;# OF UNMATCHED ['S FROM EDIT BUFFER

TOTSR:	TBK	;ADDR OF TRANSMIT STATUS REGISTER
TOGOC:	ZEPT NLTY,TYGOC	;ADDR OF ROUTINE TO GET OUTPUT CHARS(MXGOC OR TYGOC)
	TOQSZ==40
	;OUTPUT QUEUE POINTERS
TOQ:	.BLKB TOQSZ*NLTY
TOQN:	TBK	;# OF CHARS IN Q
TOTN==TOQN
TOQMX:	ZEPT NLTY,TOQSZ	;MAX # OF CHARS ALLOWED IN Q
TOQT:	ZEPT NLTY,TOQ+<TOQSZ*.RPCNT>	;PNTR TO TOP OF QUEUE
TOQL:	ZEPT NLTY,TOQ+TOQSZ+<TOQSZ*.RPCNT>	;PNTR TO 1 BYTE PAST END OF QUEUE
TOQI:	ZEPT NLTY,TOQ+<TOQSZ*.RPCNT>	;PNTR TO WHERE NEXT CHAR GOES IN
TOQO:	ZEPT NLTY,TOQ+<TOQSZ*.RPCNT>	;PNTR TO WHERE NEXT CHAR COMES OUT

CHARNO:	TBK	;# OF CHARS FROM LEFT SIDE OF PAGE
TOPAD:	TBK	;# OF CHARS TO PAD

TOIPC:	TBK	;SAVED PC (FOR ECHO)
TOISVA:	TBK	;SAVED A

TOPC:	TBK	;SAVED PC (FOR OUTPUT)
TOSVC:	TBK	;SAVED C
TOSVD:	TBK	;SAVED D

DMMAX==3	;MAXIMUM # CHARS TO SEND TO EACH DM11 TELETYPE
DMBIT==.-NFDMTY
	ZEPT 20,1_.RPCNT
DMBUF==.-NFDMTY
	ZEPT 20,DMOBUF+<DMMAX*.RPCNT>	;PNTR TO DMOBUF
DHNUMBR==.-NFDMTY
	ZEPT 20,.RPCNT

DMOBUF:	.BLKB DMMAX*16.*NDM	;WHERE DM11 SENDS CHARS FROM
TTP:	0

MXICH==.-MXICMN	;DEVICE FOR EACH IDENTIFIER CHAR
	.BYTE 24,26,30,32
TIANTM:	500.	;TIME TO WAIT FOR CARRIER BEFORE HANGING UP
;TIHGTM:	250.	;TIME TO HANG UP FOR
	.IFNZ SEG
PURE==<.!17777>+1
.IIF LE PURE-20000,PURE=40000
PUREAR=KDAR+<PURE/10000>
PUREDR=KDDR+<PURE/10000>
	.IFNZ NEWDIS
	DISPAR=PUREAR+6
	DISPDR=PUREDR+6
	.ENDC
	.ENDC
	.STITL TELETYPE CODE USER LEVEL
;CTYI--OUTPUTS (TO LOGO USER) CHAR FROM USERS TTY
CTYI:	MOV	USER,U
	MOV	UTTY(U),E
	BR	UGTYI2

;UGTYI-- TYI N OUTPUTS A CHAR FROM TTY N
UGTYI:	JSR	PC,OPEN
	MOV	USER,U
	CMP	UTTY(U),E
	BNE	UGTYI1	;BR IF NOT USER'S CONSOLE
UGTYI2:	BIS	#TIMAGI,TTYST(E)	;IMAGE INPUT AND OUTPUT
	BIC	#TILIPM,TTYST(E)	;CHAR INPUT MODE
UGTYI1:	JSR	PC,GTYI	;GET CHAR IN D
	MOV	D,B
	JMP	R1NARG

;CTYO--PRINTS CHAR ON USERS TTY
CTYO:	JSR	PC,G1NARG
	MOV	B,D	;CHAR
	JSR	PC,TTYO	;SEND TO USER'S TTY
	RTS	PC

;UGTYO-- TYO N M SENDS CHAR M TO TTY N
UGTYO:	JSR	PC,G1NARG
	MOV	B,D	;CHAR
	JSR	PC,OPEN	;MAKE SURE TTY OK
	JSR	PC,GTYO	;SEND IT
	RTS	PC

;UTYCK RETURNS IF VALID TTY, LOOSE OTHERWISE
UTYCK:	CMP	E,#2*NLTY
	BGE	UTYCL	;TOO HIGH TTY #
	BIT	#100001,E
	BNE	UTYCL	;BR IF TTY NEG OR ODD
	TST	TTYU(E)
	BLT	UTYCK1	;NOT IN USE
	CMP	TTYU(E),USER
	BNE	UTYCL1	;BR IF IN USE BY SOMEONE ELSE
UTYCK1:	RTS	PC

UTYCL:	ERROR+TDE	;NOT A VALID TTY #
UTYCL1:	ERROR+DIU	;DEVICE IN USE

MYSPEE:	MOV USER,U
	MOV UTTY(U),E
MYSPE1:	JSR PC,G1NARG
	BIT #TPDM,TYPTYP(E)
	BEQ UTYCL
	CMP #16,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASH #6,B
	MOV B,C
	ASH #4,B
	BIS B,C
	BIS #3,C
	SPL 7
	BIC #17,DH0SCR
	BIS DHNUMB(E),DH0SCR
	MOV C,DH0LPR
	SPL 0
	RTS PC
HISSPE:	JSR PC,CKSST
	JSR PC,G1NARG
	CMP #NLTY,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASL B
	MOV B,E
	BR MYSPE1

;OPEN--ASSIGNS TTY TO USER IF VALID TTY #
OPEN:	JSR	PC,G1NARG
	ASL B
	MOV	B,E
	JSR	PC,UTYCK	;RETURN IF VALID TTY
	MOV	USER,TTYU(E)	;ASSIGN TTY TO CURRENT USER
	RTS	PC


;CLOSE--CLOSES TTY IF USER HAS IT OPEN
CLOSE:	JSR	PC,OPEN
CLOSE1:	MOV	USER,U
	CMP	E,UTTY(U)
	BEQ	.+10	;BR IF USER'S CONSOLE
	MOV	#-1,TTYU(E)
	RTS	PC

;SLAM--CLOSES ALL USER TTYS BUT CONSOLE
SLAM:	MOV	#NLTY,A
	CLR	E
SLAM1:	CMP	TTYU(E),USER
	BNE	.+6	;BR IF USER DOESN'T OWN THIS TTY
	JSR	PC,CLOSE1
	TST	(E)+
	SOB	A,SLAM1
	RTS	PC


;TURN CASE CONVERSION ON AND OFF
CASESW:	JSR	PC,G1NARG
	TST	B
	BEQ	CASES1	;BR IF ARG=0
	JSR	PC,TICASE	;CONVERT LOWER TO UPPER CASE ON INPUT
	RTS	PC
CASES1:	JSR	PC,TINCAS	;DON'T CONVERT CASE
	RTS	PC

;TURN ECHOING ON AND OFF
ECHOSW:	JSR	PC,G1NARG
	TST	B
	BEQ	ECHOS1	;BR IF ARG=0
	JSR	PC,TIECH	;ECHO
	RTS	PC
ECHOS1:	JSR	PC,TINECH	;TURN ECHO OFF
	RTS	PC


			;I SPACE USER MODE
;GET A CHAR IN D FOR USER'S TTY
TTYI:	JSR	A,TYEUSV	;GET USER & TTY
	JSR	PC,TYIGC	;GET A CHARACTER
	TST	TIQN(E)
	BGT	.+10
	MOV	TIQT(E),TIQO(E)	;FOR POSSIBLE CHAR AT A TIME INPUT
	JSR	A,TYEURS	;RESTORE E&U
	RTS	PC

;GET A CHAR FOR TNM IN E
GTYI:	JSR	A,TYUSV	;GET USER IN U
	JSR	PC,TYIGC	;GET A CHAR
	JSR	A,TYURS	;RESTORE U
	RTS	PC

;GET A CHAR FOR TTY, DO RIGHT THING IF NONE AVAILABLE
TYIGC1:	BIT	#TILIPM,TTYST(E)
	BEQ	TYIGC2	;BR IF IN CHAR INPUT MODE
	MOV	TBKCHL,D	;RETURN BREAK CHARACTER
	RTS	PC
TYIGC2:	MOV	#FRTYIC,FLSRES(U)
	JSR	PC,FLUSH	;FLUSH USER WITH FLUSH REASON CHAR TYI WAIT
	TST	BRAKE(U)
	BNE	TYIGC3	;BR IF USER TRYING TO BREAK
	TST	TIQN(E)
	BLE	TYIGC2
	JSR	PC,RUNME	;FLUSH REASON CLEARED BY INTERRUPT CODE?
TYIGC:	JSR	PC,TIOQ	;TRY TO GET CHAR FROM INPUT Q
	BR	TYIGC1	;BR IF NONE AVAILBLE
	RTS	PC

TYIGC3:	JSR	PC,RUNME
	RTS	PC


;SLINE
;START LINE INPUT
SLINE:	JSR	A,TYEUSV
	BIC	#TIMAGI!TIMAGE!TIRBM!TIQF,TTYST(E)	;CLR MISC FLAGS
	BIS	#TILIPM!TIRST,TTYST(E)	;LINE INPUT MODE, INPUT RESET
	JSR	A,TYEURS
	RTS	PC
			;I SPACE USER MODE

;PUT CHAR IN D INTO USER'S TTY'S OUTPUT BUFFER
TTYO:	JSR	A,TYEUSV	;GET USER & TTY
	JSR	PC,GTYO	;SEND CHAR
	JSR	A,TYEURS
	RTS	PC

;PUT CHAR IN D INTO TTY IN E'S BUFFER
GTYO: TBTYO:	JSR	A,TYUSV	;GET USER IN U
	TST	TOPC(E)
	BEQ	GTYO3	;BR IF OUTPUT BUFFER NOT FULL
GTYO2:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH	;KEEP FLUSHING TILL ROOM IN OUTPUT Q
	TST	BRAKE(U)	;USER TRYING TO BREAK?
	BNE	GTYO5
	TST	TOPC(E)
	BNE	GTYO2
	JSR	PC,RUNME
GTYO3:	PUSH	C
	JSR	PC,TOTYO	;PUT CHARACTER IN Q
	POP	C
	JSR	PC,TOCINT	;CAUSE OUTPUT INTERRUPT IF NONE PENDING
GTYO4:	JSR	A,TYURS	;RESTORE U
	RTS	PC

GTYO5:	JSR	PC,RUNME
	BR	GTYO4

;SEND CHAR TO MULTIPLEXEE AND WAIT UNTILL IT SENDS CHAR BACK
;RETURN THAT CHAR IN D
MXWT: TBTW:	PUSH	A
	SPUSH	D
	SPUSH	U
	MOV	TIQMX(E),A
	MOV	USER,U
MXWT1:	TST	BRAKE(U)
	BNE	MXWT5
	JSR	PC,TIOQ	;EMPTY TURTLE'S INPUT Q (CLOBBERS D)
	BR	MXWT2	;Q EMPTY
	SOB	A,MXWT1
	ERROR+HARD	;JUST GOT 200 CHARS OUT OF Q!! RUNNING OPEN?
MXWT2:	MOV	E,D
	MOVB	MXNUM(D),E	;GET MULTIPLEXOR NUMBER
	JSR	PC,MXQLAD	;ADD THIS TTY TO END OF MULTIPLEXOR'S QUEUE
	BR	MXWT6	;Q FULL
		;MAKE SURE HE CAN'T BREAK FROM TYO NOW THAT MPXR EXPECTS CHAR
	MOV	D,E
	TST	TOPC(E)
	BEQ	MXWT4
MXWT3:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH
	TST	TOPC(E)
	BNE	MXWT3	;OUTPUT Q STILL FULL
	JSR	PC,RUNME
MXWT4:	POP	U
	SPOP	D
	SPOP	A
	JSR	PC,GTYO	;SEND CHAR
	JSR	PC,GTYI	;GET CHAR BACK
MXWT5:	RTS	PC

MXWT6:	ERROR+TGDZ
			;I SPACE USER MODE

;START SENDING CHARACTERS TO EDIT BUFFER
EDITA:	JSR	A,TYEUSV
	JSR	PC,TYERT	;RESET EDIT BUFFER
	BR	ETYO1

;END SENDING CHARS TO EDIT BUFFER
EDITE:	JSR	A,TYEUSV
	BIS	#TIEDM,TTYST(E)
	BR	ETYO1

;PUT CHARACTER IN EDIT BUFFER
ETYO:	JSR	A,TYEUSV
	CMP	TIEQN(E),TIEQMX(E)
	BGE	ETYO1
	MOVB	D,@TIEQI(E)
	INC	TIEQI(E)
	INC	TIEQN(E)
ETYO1:	JSR	A,TYEURS
	RTS	PC
			;I SPACE USER MODE

;TURN ON ECHO MODE
TIECH:	JSR	A,TYEUSV
	BIS	#TIECM,TTYST(E)
TIECH1:	JSR	A,TYEURS
	RTS	PC
;TURN OFF ECHO MODE
TINECH:	JSR	A,TYEUSV
	BIC	#TIECM,TTYST(E)
	BR	TIECH1

;TURN ON CASE SWITCH
TICASE:	JSR	A,TYEUSV
	BIS	#TICVM,TTYST(E)
	BR	TIECH1
;TURN OFF CASE SWITCH
TINCAS:	JSR	A,TYEUSV
	BIC	#TICVM,TTYST(E)
	BR	TIECH1


;BREAK HAS BEEN PROCESSED ON USER LEVEL,
;OK TO ACCEPT CHARS AGAIN
BRAKR:	JSR	A,TYEUSV
	JSR	PC,TTYRT
;	BIS	#TIRST,TTYST(E)	;TELL INT ROUTINES TO RESET BUFFERS
;	JSR	PC,TOCINT	;CAUSE INTERRUPT
	BIC	#TIBR,TTYST(E)
	BR	TIECH1

;INTIALIZE USER CONSOLE
UCINIT:	SPUSH	A
	MOV	TYCKBP(E),A
	JSR	PC,CLKQDL	;DELETE ANY CLOCK QUEUE ENTRY
	BIC	#TICLKQ!TIMAGE!TIMAGI,TTYST(E)	;PUT INTO ASCII MODE
	BIS	#TILIPM!TIECM!TICVM,TTYST(E)	;LINE INPUT, CONVERT CASE, ECHO
	SPOP	A
	RTS	PC
			;I SPACE USER MODE
;SAVE U, GET USER INTO U, CALL WITH JSR A
TYUSV:	PUSH	U
	MOV	USER,U
	JMP	(A)
;RESTORE U
TYURS:	TST	(P)+	;THIS POPS A SAVED WITH JSR A CALL
	POP	U
	RTS	A	;RESTORING A SAVED BY CALL TO TYUSV

;GET USER IN U, HIS TTY IN E, SAVE BOTH
TYEUSV:	PUSH	U
	SPUSH	E
	MOV	USER,U
	MOV	UTTY(U),E
	JMP	(A)
;RESTORE
TYEURS:	TST	(P)+
	POP	E
	SPOP	U
	RTS	A
.STITL TELETYPE INPUT INTERRUPT ROUTINES

;BREAK VECTORS POINT TO THESE RECEIVE INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TKBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENRBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,RK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENRBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,RK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;	.ENDC
;>>
;.ENDM

DC0RK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENRBK
DC1RK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENRBK

.IFNZ	NTY+NKLTY+NDCTY+NDPTY
;GENRBK--
;GENERAL RECEIVE BREAK FOR TTYS, TBOXS, ETC.
;CALLED WITH	SPUSH A
;		MOV #TTY INDEX,A
;		JMP GENBRK

GENRBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;TTY
	MOV	TYRS(A),U	;RG ADR
	MOV	(U),D	;RG CONTENTS
	BIT	#%ER,D
	BNE	TGENER	;BR IF ERROR BIT ON
	TST	E
	BMI	GENRB1	;BR IF NOT LOGICAL TTY
	MOV	2(U),D	;CHARACTER
	BIC	#177600,D	;ONLY 7 BITS
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS PHYSICAL DEV.
GENRB1:	JSR	U,ACRES
	SPOP	A
	RTT

TGENER:	JSR	PC,GENER
	BR	GENRB1

;A PNTS TO BLK
;D REG CONTENTS
;U BUF ADDR
GENER:
.IFG	NMODEM
	TST	E
	BMI	GENER5
	BIT	#TPMODM,TTYTP(E)
	BNE	GENER2	;BR IF MODEM
GENER5:
.ENDC
	JSR	PC,DEVER	;PRINT ERROR MESSAGE
	BR	GENER4
.IFG	NMODEM
GENER2:	MOV	TYCKBP(E),A
	BIT	#TICLKQ,TTYST(E)
	BEQ	GENER1
	JSR	PC,CLKQDL	;DELETE ANY PRESENT CLKQ ENTRY
	BIC	#TICLKQ,TTYST(E)
GENER1:	BIS	#%DTRDY,(U)
	BIT	#%CRDT,D
	BNE	GENER4
	JSR	PC,TISANS	;TRY TO HANG UP
.ENDC
GENER4:	CMP	(U)+,(U)
	RTS	PC

;;!!! CHANGE SYS CONSOLE PRINOUT HACK
DEVER:	JSR	A,SPRINT
	BPRTXT	^\DEV ERR \
	JSR	PC,PGEN1
	SPREND
	RTS	PC

PGEN1:	MOV	U,A
	JSR	PC,PRON		;REGISTER ADDR
	PRTXT	^\/  \
	MOV	D,A
	JSR	PC,PRON		;REG CONTENTS
	PRCR
	RTS	PC

.IFG NMODEM
;TISHNG:	;ASSERT DATA TERM RDY IN TIHGTM TICKS
;	MOV	#TIHGTM,(A)
;	MOV	#TIUNHG,4(A)
;	BR	TICKLA

TISANS:	MOV	#TIANTM,(A)	;IF NO CARRIER IN TIANTM TICKS, HANG UP
	MOV	#TIANS,4(A)

TICLKA:	JSR	PC,CLKQAD
	BIS	#TICLKQ,TTYST(E)
	RTS	PC

TIANS:	JSR	B,TICKS
	BIT	#%CRDT,@U
	BNE	TIANS1
	BIC	#%DTRDY,@U
;	JSR	PC,TISHNG
TIANS1:	SPOP	U
	SPOP	E
	SPOP	B
	RTS	PC


;---FOLLOWING RUN AT CLOCK BREAK LEVEL---

TICKS:	SPUSH	E	;TICLKQ START
	SPUSH	U
	MOV	6(A),E		;TTY
	BIT	#TICLKQ,TTYST(E)
	BEQ	TICKS1
	BIC	#TICLKQ,TTYST(E)
	JMP	(B)

TICKS1:	BPT	;HOW DID THIS GET ON CLOCK Q?
	BR	TIANS1

;TIUNHG:	JSR	B,TICKS
;	BIS	#%DTRDY,@U	;TURN DATA TERM RDY ON
;	BR	TIANS1

;	TIANTM AND ;TIHGTM HAVE BEEN MOVED
;	TO THE START OF TYI WITH THE BUFFERS

.ENDC
.ENDC
.IFZ DHON
.IFG NDMTY
DM0RK:	BIC	#200,DM0CSR	;CLEAR DONE BIT
	JSR U,ACSAV	;SAVE ACS
	MOV #DMTT+200,B	;BOTTOM OF TUMBLE TABLE
	MOV #TTP,C	;TUMBLE TABLE POINTER
	;BR DMRK

;DM11 RECEIVE INTERRUPT
DMRK:	BR	DMRK3

DMRK1:	BIC	#120200,@(C)	;CLR CHAR RCVD, PARITY, AND UNUSED BITS
	BIT	#40000,@(C)
	BNE	DMRK2	;BR IF NO STOP RECEIVED
	MOV	(C),E
	MOVB	1(E),E	;GET LINE #
	ADD	#NFDMTY,E	;GET PHYSICAL TTY NUMBER
	MOVB	TILTTY(E),E	;GET LOGICAL NUMBER
	BMI	DMRK2	;BR IF ILLOGICAL
	MOVB	@(C),D	;CHARACTER
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS TTY
DMRK2:	ADD	#2,(C)	;INCREMENT POINTER
	CMP	@C,B
	BLO	DMRK3	;BR IF NOT PAST END OF TABLE
	MOV	B,@C	;RESET POINTER
	SUB	#200,@C
DMRK3:	TST	@(C)
	BMI	DMRK1	;BR IF MORE CHARACTERS
	JSR	U,ACRES	;RESTORE AC'S
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0RK:	JSR U,ACSAV
DM0RK2:	MOV DH0NRC,C	;GET THE CHARACTER
	BGE DM0RK3	;NO CHARACTER
	BIC #110200,C	;CLEAR SILLY BITS
	BIT #60000,C	;IS IT A BREAK?
	BEQ DM0RK1	;NOPE
	BIC #60377,C	;CLEAR CHARACTER AND BREAK BITS
	ADD #7,C	;BREAK
DM0RK1:	MOV C,E		;COPY IT
	SWAB E		;GET LINE NUMBER
	BIC #177760,E	;FLUSH CRAP
	ASL E
	MOVB TILTTY+NFDMTY(E),E	;GET LOGICAL NUMBER
	BMI DM0RK2	;ILLOGICAL
	MOV C,D		;COPY AGAIN
	BIC #177600,D	;JUST THE CHARACTER
	BIT #TIRST,TTYST(E)	;RESET INPUT?
	BEQ .+6
	JSR PC,TYIRT1	;GO RESET IT
	JSR PC,@TIRCV(E)	;GOBBLE CHARACTER INTO BUFFER
	BR DM0RK2		;ANY MORE?
DM0RK3:	JSR U,ACRES
	RTT
.ENDC
.ENDC

;MULTIPLEXOR RECIEVE INTERRUPT
MXRCV:	SPUSH	E
	CMP	D,#'_
	BGT	MXRCV3	;BR IF LOWER CASE
	JSR	PC,MXGTY	;GET INDEX OF LOG DEV THIS CHAR BELONGS TO
	BR	MXRCV1	;FAIL, THIS CHAR DOESN'T BELONG TO ANYONE
	JSR	PC,TIINQ	;PUT CHAR IN THAT GUY'S BUFFER
	BR	.+2	;FAIL
MXRCV1:	SPOP	E
MXRCV2:	RTS	PC


MXICMN==140
MXICMX==141
MXRCV3:	;CHAR IS LOWER CASE, IDENTIFIES WHERE NEXT CHAR COMES FROM
	CMP	D,#MXICMN	;SMALLEST LEGAL IDENTIFIER
	BLT	MXRCV4
	CMP	D,#MXICMX	;LARGEST LEGAL IDENTIFIER
	BGT	MXRCV4
	MOVB	MXICH(D),E	;GET INDEX OF DEVICE
	JSR	PC,MXQTAD	;ADD TO TOP OF QUEUE
	BR	MXRCV1	;Q FILLED
	BR	MXRCV1

MXRCV4:	BR	MXRCV1	;L.C. CHAR TOO BIG OR SMALL

MXGTY:	;GETS TTY # OF NEXT LOG. DEV. IN MX Q, UPDATES Q,
	;FAILS IF NOTHING IN QUEUE
	TST	MXNCH(E)
	BLE	MXRCV2	;Q EMPTY, FAIL
	SPUSH	D
	MOV	IMXQT(E),D	;SHUFFLE Q CONTENTS UP ONE BYTE
	MOVB	(D)+,-(P)	;PUSH INDEX OF FIRST DEV ON Q
MXGTY1:	MOVB	(D)+,-2(D)	;MOVE REST OF Q UP ONE BYTE
	CMP	D,IMXQL(E)
	BLO	MXGTY1
	DEC	MXNCH(E)
	MOVB	(P)+,E		;POP DESIRED INDEX
	SPOP	D
	SKPRET


;ADD CHAR IN D TO TOP OF MX INPUT Q
MXQTAD:	CMP	TIQN(E),TIQMX(E)
	BGE	MXQTA2
	SPUSH	A
	MOV	MXNCH(E),A
	ADD	IMXQT(E),A	;POINT AT BOTTOM OF Q
MXQTA1:	MOVB	(A)+,(A)	;MOVE ENTIRE Q DOWN ONE
	SUB	#2,A
	CMP	A,IMXQT(E)
	BHIS	MXQTA1
	INC	MXNCH(E)
	MOVB	D,IMXQT(E)
	SPOP	A
	SKPRET	;RETURN TO SUCCESS
MXQTA2:	RTS	PC	;Q FULL

;ADD CHAR IN D TO BOTTOM OF MX Q
MXQLAD:	CMP	TIQN(E),TIQMX(E)
	BGE	MXQTA2
	SPUSH	A
	MOV	IMXQT(E),A
	ADD	MXNCH(E),A
	MOVB	D,(A)
	INC	MXNCH(E)
	SPOP	A
	SKPRET
.STITL TYPEIN--INTERRUPT LEVEL
;TELETYPE RECIEVE
;PROCESS CHAR IN D FOR TTY IN E
;CAN CLOBBER A,U
TYRCV:	MOV	TTYU(E),U
	BIT	#TILIPM,TTYST(E)
	BEQ	TYRCV1	;BR IF NOT IN LINE INPUT MODE
	BIT	#TIMAGI,TTYST(E)
	BNE	TYRCV1	;BR IF IN INPUT IMAGE MODE
	CMP	D,TBKCH
	BEQ	TYRCV5	;BR IF BREAK CHAR
	CMP	D,TBKCHL
	BEQ	TYRCV6	;BR IF BREAK CH FOR LEVEL N
	CMP	#FRLINW,FLSRES(U)	;WAITING FOR LINE?
	BNE	TYRCV4	;BR IF NO
	BIT	#TIQF,TTYST(E)
	BNE	TYRCQ	;BR IF QUOTE NEXT CHAR FLAG ON
TYRCV3:	BITB	#FSF,DTBL(D)	;DOES CHAR HAVE SEPCIAL EFFECT ON INT LEVEL?
	BEQ	TYRCV1	;NO
	MOVB	DTBL2(D),A	;GET INDEX TO DISPATCH TABLE
	JSR	PC,@TIICTB(A)	;DISPATCH
TYRCV1:	JSR	PC,TYINQ	;PUT IN INPUT Q
	BR	TYRCV2	;FAIL
	JSR	PC,TOCINT	;ROUTINE TO CAUSE OUTPUT INTERRUPT
TYRCV4:	RTS	PC

TYRCV2:	JSR	PC,TIDING	;ECHO A ^G
RTSPC:	RTS	PC	;DUMMY ROUTINE TO JSR TO

;BREAK CHARS, CANNOT BE QUOTED
TYRCV5:	MOV	#7,D	;CHANGE CHAR TO ^G
	BR	TYRCV3
TYRCV6:	MOV	#32,D	;CHANGE TO ^Z
	BR	TYRCV3

;QUOTE NEXT CHAR FLAG ON
;TRY TO QUOTE CHAR IN D
TYRCQ:	BIC	#TIQF,TTYST(E)	;CLR FLAG
	CMP	D,TBKCH
	BEQ	TYRCV5	;DON'T QUOTE BREAK CHAR
	CMP	D,TBKCHL	;DON'T QUOTE BRK TO LEVEL N CHAR
	BEQ	TYRCV6
	BIS	#200,D	;QUOTE CHAR BY SETTING PARITY BIT
	BR	TYRCV1

;FIX THIS
TIDING:	RTS	PC

;PUT CHAR IN D INTO CONSOLE IN E'S INPUT BUFFER
TYINQ:	BIT	#TICVM,TTYST(E)
	BEQ	TIINQ	;BR IF NOT CONVERTING LOWER TO UPPER CASE
	JSR	PC,TICVLU	;CONVERT
;PUT CHAR IN D INTO TTY IN E'S INPUT BUFFER
TIINQ:	CMP	TIQN(E),TIQMX(E)
	BGE	TIINQ1	;BR IF BUFFER FULL
	CMP	TIQI(E),TIQL(E)
	BLO	.+10
	MOV	TIQT(E),TIQI(E)	;RESET PNTR
	MOVB	D,@TIQI(E)	;PUT CHAR IN
	INC	TIQI(E)	;INC POINTER
	INC	TIQN(E)	;INC COUNTER
	INC	TIQTON(E)	;INC OUTPUT LEVEL COUNTER
	SKPRET

TIINQ1:	RTS	PC

;*****TIOQ RUNS AT USER LEVEL ALSO******
;GET A CHAR FROM INPUT QUEUE
TIOQ:	TST	TIQN(E)
	BLE	TIINQ1	;BR IF NO CHARS IN Q
	MOVB	@TIQO(E),D	;CHAR
	INC	TIQO(E)	;PNTR TO WHERE TO GET CHARS FROM
	CMP	TIQO(E),TIQL(E)
	BLO	.+10	;BR IF PNTR NOT PAST END OF BUFFER
	MOV	TIQT(E),TIQO(E)	;RESET PNTR
	DEC	TIQN(E)	;# OF CHARS IN Q
	SKPRET

;IF CHAR IN D IS LOWER CASE, CONVERT TO UPPER
TICVLU:	TSTB	D
	BMI	TICVL1	;BR IF QUOTED
	CMP	D,#'_
	BLE	TICVL1	;BR IF UPPER CASE
	CMP	D,#177
	BEQ	TICVL1	;DON'T CASE RUBOUT
	SUB	#40,D
TICVL1:	RTS	PC


;QUOTE NEXT CHAR
TICQ:	BIT	#TIQF,TTYST(E)
	BNE	TICQ1	;BR IF ^Q WAS PREVIOUS CHAR
	BIS	#TIQF,TTYST(E)
	RTS	PC
TICQ1:	BIC	#TIQF,TTYST(E)
	RTS	PC

;RESET TTY
TTYRT:TBREST:	JSR	PC,TYORT	;RESET TYO STUFF
	JSR	PC,TYIRT	;RESET TYI STUFF
	RTS	PC

;RESET TYPEOUT PNTRS
TYORT:	CLR	TOQN(E)
	MOV	TOQT(E),TOQI(E)
	MOV	TOQT(E),TOQO(E)
	CLR	TOPC(E)
	CLR	TOIPC(E)
	RTS	PC

;*** TYIRT RUNS AT USER LEVEL ALSO ***
;RESET INPUT PNTRS
TYIRT:	BIC	#TIEDM!TIQF!TIRBM,TTYST(E)	;CLR MISC FLAGS
TYIRT1:	BIC	#TIRST,TTYST(E)	;RESET FLAG
	CLR	TIQTON(E)
	CLR	TIQN(E)
	MOV	TIQT(E),TIQI(E)
	MOV	TIQT(E),TIQO(E)
	MOV	TIQT(E),TIQTO(E)
	CLR	TIBC(E)
	RTS	PC

;RESET EDIT PNTRS
TYERT:	CLR	TIEBC(E)
	CLR	TIEQN(E)
	MOV	TIEQT(E),TIEQI(E)
	MOV	TIEQT(E),TIEQO(E)
	RTS	PC

;BREAK TO LEVEL 0
TICG:	MOV	#1,BRAKE(U)	;SET USER BREAK FLAG
	BR	TIBRK
;BREAK TO LEVEL N
TICZ:	MOV	#-1,BRAKE(U)

;BREAK TO LEVEL 0 OR N
;CALL WITH CONTENTS OF BRAKE IN (P)
TIBRK:	BIS	#TIBR,TTYST(E)
	JSR	PC,TTYRT	;RESET INPUT
	CMP	#FRLINW,FLSRES(U)
	BEQ	TIBRK1	;BR IF FLUSHED WAITING FOR LINE
	BIT	#FRBKBT,FLSRES(U)	;SHOULD I UNHANG HIM ANYHOW?
	BEQ	TIBRK2	;BR IF NO
TIBRK1:	CLR	FLSRES(U)	;UNFLUSH
TIBRK2:	RTS	PC

;INTERRUPT LEVEL BREAKPOINT
;CLOBBER ATICZ/  TIIBPT
TIIBPT:	TST	(P)+
	BPT	
	RTS	PC

;REPLACE ^B WITH %
TICB:	MOV #'%,D
	RTS PC


;*** USER AND INTERRUPT LEVEL ***

;IF NOT TRANSMITTING, CAUSE OUTPUT INTERRUPT
TOCINT:	SPUSH	E
TOCIN4:	BIT	#TPPTY,TTYTP(E)
	BNE	TOCIN3
	BIT	#TOTRAN,TTYST(E)
	BNE	TOCIN2	;BR IF TRANSMITTING
.IFG NDMTY
	BIT	#TPDM,TTYTP(E)
	BEQ	TOCIN1	;BR IF NOT A DM11 TTY
	BIS	#100000,@TOTSR(E)	;SET TRANS INT BIT
	BR	TOCIN2
TOCIN1:
.ENDC
	BIC	#100,@TOTSR(E)	;CLEAR AND SET INTERRUPT ENABLE
	BIS	#100,@TOTSR(E)
TOCIN2:	SPOP	E
	RTS	PC

TOCIN3:	MOVB	MXNUM(E),E
	BR	TOCIN4

.STITL TYPE OUT--INTERRUPT LEVEL

;BREAK VECTORS POINT TO THESE TRANSMIT INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TPBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENTBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,TK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENTBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,TK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;		JMP GENTBK
;	.ENDC
;>>
;.ENDM

DC0TK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENTBK
DC1TK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENTBK

.IFZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DM0CSR,U	;STATUS REGISTER
	MOV #NFDMTY,A	;# OF FIRST TTY
	BR DMTK

;DM11 TRANSMIT BREAK
DMTK:	MOV	(U),D	;REGISTER CONTENTS
	BIT	#60000,D
	BEQ	.+6	;BR IF NO ERRORS
	JSR	PC,DEVER	;PRINT ERRORS ON SYSTEM CONSOLE
	BIC	#160000,(U)	;CLEAR ERROR &TRANS INTERRUPT BITS
	MOV	U,B
	ADD	#2,B	;ADDR OF BUFFER ACTIVE REGISTER
	MOV	A,U	;# OF FIRST TTY
	MOV	#1,A	;BIT FOR LINE BUFFER ACTIVE REGISTER
DMTK2:	BIT	A,(B)
	BNE	DMTK3	;BR IF THIS LINE TRANSMITTING
	MOVB	TILTTY(U),E	;LOGICAL TTY #
	BMI	DMTK3	;BR IF ILLOGICAL
	SPUSH	A
	JSR	PC,TYXMT	;TRANSMIT
	SPOP	A
DMTK3:	TST	(U)+	;INC TTY
	ASL	A	;SHIFT BAR BIT
	BNE	DMTK2	;BR IF MORE TTYS TO CHECK
	JSR	U,ACRES
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DH0SCR,U
	MOV #NFDMTY,A
	MOV (U),D	;GET STATUS OF DH11
	BIT #42000,D	;ANYTHING BAD?
	BEQ .+6		;NOPE
	JSR PC,DEVER	;TELL THE WORLD
	INCB 1(U)	;RESET NXM
	BIC #100000,(U)	;RESET DONE
	MOV U,B
	ADD #12,B	;GET BAR ADDRESS
	MOV A,U
	MOV #1,A
DMTK2:	BIT A,(B)	;THAT LINE TRANSMITING?
	BNE DMTK3	;YES
	MOVB TILTTY(U),E	;GET LOGICAL NUMBER
	BMI DMTK3	;ILLOGICAL
	SPUSH A
	JSR PC,TYXMT	;SEND ANYTHING YOU GOT
	SPOP A
DMTK3:	TST (U)+	;NEXT LINE
	ASL A		;NEXT BAR BIT
	BNE DMTK2	;OUT OF LINES?
	JSR U,ACRES
	RTT
.ENDC
.ENDC

;GENERAL TRANSMIT BREAK
GENTBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;GET LOGICAL TTY #
	BMI	GENTB2	;BR IF ILLOGICAL
	MOV	TOTSR(E),B
	MOV	@B,D	;STATUS REG CONTENTS
	BIT	#%RDY,D
	BEQ	GENTB2	;BR IF NOT RDY, SPURIOUS INTERRUPT
GENTB1:	JSR	PC,TYXMT	;TRANSMIT INT ROUTINE
GENTB2:	JSR	U,ACRES
	SPOP	A
	RTT

;GET NEXT MULTIPLEXOR OUTPUT CHARACTER
;SKIP ONE WORD IF SUCESSFULL
MXGOC:	TST	TOQN(E)
	BLE	MXGOC4	;BR IF NO CHARS TO SEND
	CMP	TOQO(E),TOQL(E)
	BLO	.+10	;BR IF OUTPUT PNTR NOT PAST END OF QUEUE
	MOV	TOQT(E),TOQO(E)	;RESET POINTER
	SPUSH	E
	MOVB	@TOQO(E),E	;GET NEXT TTY TO SEND STUFF FOR
	JSR	PC,TOSOP	;START OUTPUT
	BR	.+2	;OUTPUT Q FULL
	JSR	PC,@TOGOC(E)	;GET OUTPUT CHAR
	BR	MXGOC3	;NO CHARS
	SPOP	E
	DEC	TOQN(E)	;DECREMENT MPXRS CHAR COUNT
	BR	.+4
MXGOC1:	SPOP	E
	INC	TOQO(E)	;INC MULTIPLEXOR'S POINTER
MXGOC5:	ADD	#2,@P	;SKIP RETURN
MXGOC2:	RTS	PC

;MULTIPLEXOR HAS CHARS TO SEND, BUT CURRENT MULTIPLEXEE DOESN'T
MXGOC3:	MOVB	OMXNUL(E),D	;RETURN NULL CHAR FOR MULTIPLEXEE
	BR	MXGOC1


;NO CHARACTERS FOR MULTIPLEXOR
MXGOC4:	CMP	TOQO(E),TOQT(E)
	BEQ	MXGOC2	;BR IF NEXT DEVICE IN QUEUE IS FIRST DEVICE
	MOV	TOQT(E),TOQO(E)	;RESET QUEUE
	MOVB	OMXRES(E),D	;SEND MULTIPLEXOR RESET CHARACTER
	BR	MXGOC5

;GET NEXT TTY OUTPUT CHARACTER
;SKIP ONE WD IF SUCCESSFUL
TYGOC:	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC1	;BR IF IN IMAGE MODE (DON'T PAD)
	TSTB	TOPAD(E)
	BGT	TYGOC4	;BR IF SOME PADDING LEFT
TYGOC1:	JSR	PC,TOOQ	;GET CHAR FROM OUTPUT BUFFER
	BR	TYGOC3	;BR IF BUFFER EMPTY
	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC2	;BR IF IN IMAGE MODE
	CMP	D,#15
	BNE	TYGOC2
	MOVB	TTYTP(E),TOPAD(E)	;IF CR, SET UP PADDING
TYGOC2:	ADD	#2,@P	;SKIP RETURN
TYGOC3:	RTS	PC
;SEND PADDING CHAR INSTEAD OF NEXT CHAR FROM QUEUE
TYGOC4:	CLR	D
	DECB	TOPAD(E)	;DEC # OF PADS
	BR	TYGOC2


;REMOVE CHAR FROM CIRCULAR OUTPUT QUEUE AND RETURN IT IN D
;SKIP ONE WORD IF SUCCESSFUL
TOOQ:	TST	TOQN(E)
	BLE	TOOQ2	;BR IF NOTHING IN Q
	CMP	TOQO(E),TOQL(E)	;IS PNTR TO NEXT CHAR PAST END OF Q
	BLO	TOOQ1	;BR IF NO
	MOV	TOQT(E),TOQO(E)	;RESET PNTR
TOOQ1:	MOVB	@TOQO(E),D	;GET CHAR
	INC	TOQO(E)	;INC PNTR
	DEC	TOQN(E)	;DEC CHARACTER COUNT
	ADD	#2,@P	;SKIP RETURN
TOOQ2:	RTS	PC

;TTY TRANSMIT INTERRUPT
;FIRST SEND CHARS IN OUTPUT Q
;THEN PROCESS CHARS IN INPUT Q
;CAN CLOBBER A&C
TYXMT:	BIC	#TOTRAN,TTYST(E)	;CLEAR XMT INT PENDING BIT
	BIT	#TIBR,TTYST(E)
	BNE	TYXMT4	;BR IF BREAKING
	JSR	PC,TOSOP	;START OUTPUT
	BR	TYXMT3	;OUTPUT BUFFER FILLED AGAIN
TYXMT1:	JSR	PC,TOPIC	;PROCESS CHARS FROM INPUT BUFFER
TYXMT3:		;ACTUALLY SEND CHARACTERS!!!
.IFG	NDMTY
	BIT	#TPDM,TTYTP(E)
	BNE	TYXMT5	;BR IF DM11 TTY
.ENDC
	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHAR
	BR	TYXMT4	;NONE
	MOV	D,2(B)	;PUT CHAR IN DEVICES OUTPUT BUFFER
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
TYXMT4:	RTS PC

;START OUTPUT
;SKIP RETURN IF OUTPUT BUFFER NOT FULL
TOSOP:	CMP	TOQN(E),TOQMX(E)
	BGE	TOSOP2	;BR IF Q FULL
	TST	TOPC(E)	;DID WE EXIT FROM MIDDLE OF PROCESSING CHAR TO OUTPUT Q
	BEQ	TOSOP1	;BR IF NO
	MOV	TOSVC(E),C	;RESTORE MISC AC'S
	MOV	TOSVD(E),D
	SPUSH	TOPC(E)	;LOCATION TO JSR TO
	CLR	TOPC(E)
	JSR	PC,@(P)+	;CALL AS COROUTINE
	BR	TOSOP2	;OUTPUT Q FILLED AGAIN
TOSOP1:	ADD	#2,@P	;SKIP RETURN
TOSOP2:	RTS	PC


.IFG NDMTY
TYXMT5:	JSR	PC,DMSND	;TRANSMIT CHARS TO DM TTY
	RTS	PC

;TRANSMIT CHARS TO DM11 TTY
DMSND:	JSR	F,ACSAV
	CLR	A	;-WD CNT
	MOVB	TILTTY(E),U	;PHYSICAL TTY #
	MOV	DMBUF(U),B	;WHERE CHARS ACTUALLY SENT FROM
.IFZ DHON
	MOV	B,DMCA(U)
.IFF
	BIC #17,DH0SCR
	BIS DHNUMB(U),DH0SCR	;SET LINE NUMBER
	MOV B,DH0CAR	;SET THE ADDRESS
.ENDC
	MOV	#DMMAX,C	;MAX NUM OF CHARS TO SEND
DMSND1:	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHARACTER
	BR	DMSND2	;RETURN HERE IF NO CHARS
	MOVB	D,(B)+	;PUT CHAR IN BUFFER
	DEC	A	;-WD CNT
	DEC	C	;MAX NUM OF CHARS TO SEND
	BGT	DMSND1
DMSND2:	TST	A
	BGE	DMSND3	;BR IF NOTHING TO SEND
.IFZ DHON
	MOV	A,DMWC(U)
	BIS	DMBIT(U),DM0BAR	;TRANSMIT
.IFF
	MOV A,DH0BCR	;SET BYTE COUNT
	BIS DMBIT(U),DH0BAR	;START LINE UP
.ENDC
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
DMSND3:	JSR	F,ACRES
	RTS	PC
.ENDC

;PROCESS CHARS IN INPUT BUFFER
TOPIC1:	INC	TIQTO(E)	;INC CHAR PNTR
	DEC	TIQTON(E)	;DEC CHAR COUNT
	JSR	PC,TOIEC	;ECHO CHAR
TOPIC:	CMP	TIQTO(E),TIQL(E)
	BLO	.+10
	MOV	TIQT(E),TIQTO(E)
	TST	TOPC(E)
	BNE	TOPIC2	;IF OUTPUT BUFFER FULL, GO AWAY
	TST	TIQTON(E)
	BLE	TOPIC2	;NO CHARS LEFT
	MOVB	@TIQTO(E),D	;GET NXT CHAR
	BIT	#TIMAGI,TTYST(E)
	BNE	TOPIC1	;BR IF IN IMAGE INPUT MODE
	BIT	#200,D
	BNE	TOPIC1	;BR IF THIS CHAR IS QUOTED
	BITB	#FSF,DTBL(D)
	BEQ	TOPIC1	;BR IF NOT SPECIAL INPUT CHAR
	MOVB	DTBL2(D),A
	JSR	PC,@TOICTB(A)	;DISPATCH TO SPECIAL CHAR ROUTINE
	BR	TOPIC	;SEE IF MORE CHARS TO PROCESS
	BR	TOPIC1	;NOT REALLY SPECIAL

SKIPR:	ADD	#2,@P
TOPIC2:	RTS	PC

;^M POSSIBLE END OF LINE
TOICM:	BIT	#TILIPM,TTYST(E)
	BEQ	TOICM3	;BR IF NOT IN LINE INPUT MODE
	TST	TIBC(E)
	BGT	TOICM3	;BR IF INSIDE BRACKETS
	INC	TIQTO(E)
	DEC	TIQTON(E)
	JSR	PC,TOIEC	;ECHO CHAR
	SPUSH	A
	SPUSH	B
	SPUSH	C
	MOV	TIQT(E),A
	MOV	TIEQT(E),B
	MOV	B,TIEQO(E)
	MOV	TIQN(E),C
	MOV	C,TIEQN(E)	;# OF EDIT CHARS
	MOVB	(A)+,(B)+	;BLT TYPEIN BUFFER TO EDIT BUFFER
	SOB	C,.-2
	MOV	B,TIEQI(E)	;B PNTS PAST END OF STUFF IN EDIT BUF
	SPOP	C
	SPOP	B
	SPOP	A
	JSR	PC,TYIRT	;RESET INPUT BUFFER
	MOV	TIEQN(E),TIQN(E)	;FOR USER LEV TYI
	SPUSH	U
	MOV	TTYU(E),U
	CLR	FLSRES(U)	;RUN THE GUY
	SPOP	U
	RTS	PC
TOICM3:	JMP	SKIPR	;NOT REALLY SPECIAL

;^Y EDIT PREVIOUS LINE
TOICY:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^Y?
	JSR	PC,TOIECS	;IF NO, JMP HERE, ECHO ^Y
	MOV	#15,D
	JSR	PC,TOIECS	;ECHO CR
	MOV	#'_,D
	JSR	PC,TOIEC	;ECHO _
	JSR	PC,TOIQU	;BLT INPUT Q UP (OVERWIRTE ^Y)
	BIS	#TIEDM,TTYST(E)	;PUT TTY IN EDIT MODE
	RTS	PC

;^X CLARIFY INPUT
;TYPE CR, REST OF EDIT BUFFER, CR, INPUT BUFFER
TOICX:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^X?
	MOV	#15,D	;NO
	BIT	#TIEDM,TTYST(E)
	BEQ	TOICX2	;BR IF NOT EDITING
	TST	TIEQN(E)
	BLE	TOICX2	;BR IF NOTHING IN EDIT BUFFER
	MOV	TIEQO(E),A
TOICX1:	JSR	PC,TOIECS	;ECHO CHAR IN D (SKIPS LEVEL IF Q FULL)
	MOVB	(A)+,D	;GET NEXT EDIT CHAR
	CMP	A,TIEQI(E)
	BLO	TOICX1	;BR IF STILL CHARS TO PRINT
	BHI	TOICX5	;BR IF JUST PRINTED LAST CHAR
	CMP	D,#15
	BNE	TOICX1	;LAST CHAR NOT CR, PRINT IT, THEN PRINT CR.
TOICX5:	MOV	#15,D
TOICX2:	TST	TIQN(E)
	BLE	TOICX4
	MOV	TIQT(E),A
TOICX3:	JSR	PC,TOIECS
	MOVB	(A)+,D
	CMP	A,TIQTO(E)
	BLOS	TOICX3	;BR IF MORE INPUT CHARS TO PRINT
TOICX4:	JSR	PC,TOIQU	;BLT INPUT Q UP 1 BYTE (OVERWRITE ^X)
	RTS	PC


;ECHO CHAR FROM SPECIAL INPUT CHAR SUBR
TOIECS:	SPUSH	A
	JSR	PC,TOIEC	;ECHO
TOIES1:	SPOP	A
	TST	TOPC(E)
	BEQ	TOIECR
	MOV	(P)+,TOIPC(E)	;WHERE TO RETURN TO
	MOV	A,TOISVA(E)	;SAVE AC A
TOIECR:	RTS	PC

;ECHO RUBBED OUT CHAR
TOIRCS:	SPUSH	A
	JSR	PC,TOPRB
	BR	TOIES1

;ENTER SUBR THAT TOIECS EXITED
TOIENT:	TST	TOIPC(E)
	BEQ	TOIEN1
	MOV	TOIPC(E),@P	;RETURN HERE INSTEAD OF CALLING ROUTINE
	CLR	TOIPC(E)
	MOV	TOISVA(E),A
TOIEN1:	RTS	PC

;^C COPIES NEXT CHAR FROM EDIT QUEUE TO TYI QUEUE
TOICC:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;TRY TO GET EDIT CHAR
	BR	TOICC1	;FAIL
	MOVB	D,@TIQTO(E)	;PUT WHERE ^C WAS
	RTS	PC
TOICC1:	JSR	PC,TOIQU	;BLT REST OF Q UP ONE BYTE (OVERWRITE ^C)
	RTS	PC

;^N COPIES NEXT WORD FROM EDIT TO TYI Q
TOICN:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICN3	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET EDIT CHARACTER
	BR	TOICN3	;FAIL
	JSR	PC,TOISWS	;SKIP IF WORD SEPERATOR
	BR	TOICN2
TOICN1:	MOVB	D,@TIQTO(E)	;PUT CHAR WHERE ^N WAS
	RTS	PC
TOICN2:	JSR	PC,TOIQD	;BLT Q DOWN ONE BYTE TO MAKE ROOM FOR CHAR
	BR	TOICN1
TOICN3:	JSR	PC,TOIQU	;BLT Q UP ONE BYTE (OVERWRITE ^N)
	RTS	PC

;^R COPY REST OF EDIT BUFFER TO INPUT BUFFER
TOICR:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICR2	;BR IF NOT IN EDIT MODE
TOICR1:	JSR	PC,TOGED	;GET NEXT EDIT CHAR
	BR	TOICR2	;FAIL
	JSR	PC,TOIQD	;BLT INPUT Q DOWN 1 BYTE
	MOVB	D,@TIQTO(E)	;PUT EDIT CHAR IN INPUT Q
	RTS	PC
TOICR2:	JSR	PC,TOIQU	;BLT INPUT Q UP 1
	RTS	PC



;SKIP IF CHAR IN D IS WD SEPERATOR
TOISWS:	TSTB	D
	BMI	TOISW1	;BR IF QUOTED (HIGH BIT ON)
	BITB	#WSF,DTBL(D)
	BEQ	TOISW1	;BR IF NOT SEPERATOR
	SKPRET
TOISW1:	RTS	PC

;^D DELETES NEXT CHAR FROM EDIT QUEUE
TOICD:	JSR	PC,TOIQU	;BLT INPUT Q UP ONE BYTE (OVERWRITE ^D)
	BIT	#TIEDM,TTYST(E)
	BEQ	TOICD1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET NXT EDIT CHAR
	BR	TOICD1	;FAIL
	JSR	PC,TOPRB	;ECHO RUBBED OUT CHAR
TOICD1:	RTS	PC


;^S SKIPS NXT WD IN EDIT QUEUE
TOICS:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICS1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET NXT EDIT CHAR
	BR	TOICS1	;FAIL
	JSR	PC,TOPRB
	JSR	PC,TOISWS	;SKIP IF WD SEPERATOR
	BR	TOICS2
TOICS1:	JSR	PC,TOIQU	;BLT INPUT CHARS UP 1 BYTE (OVERWRITE ^S)
TOICS2:	RTS	PC


;^Q HAD EFFECT ON INPUT, DELETE FROM Q & ECHO
TOICQ:	JSR	PC,TOIQU	;BLT Q OVER ^Q
	JSR	PC,TOIECS	;ECHO ^Q
	RTS	PC
	
;RUBOUT RUBS OUT PREVIOUSLY PROCESSED CHAR
TOIRB:	JSR	PC,TOIQU	;BLT INPUT Q UP 1 BYTE (OVERWRITE RBO)
	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BR	TOIRB1	;FAIL
	JSR	PC,TOPRB	;PRINT RUBBED OUT CHAR
	JSR	PC,TOIBCK	;CHECK FOR RUBBED OUT [ OR ]
	JSR	PC,TOIOWP	;OVERWRITE RUBBED OUT CHAR
	RTS	PC

TOICW2:	JSR	PC,TOIQU	;OVERWRITE ^ CHAR
TOIRB1:	BIC	#TIRBM,TTYST(E)	;CLEAR RUB OUT MODE FLAG
	MOV	#15,D	;ECHO A C.R.
	JSR	PC,TOIEC
	RTS	PC

;^W RUBS OUT PREVIOUS WD
TOICW:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^W?
	JSR	PC,TOIQP	;NO, GET PREVIOUS CHAR
	BR	TOICW2	;FAIL
TOICW1:	JSR	PC,TOIBCK	;CHECK FOR BRACKET
	JSR	PC,TOIRCS	;PRINT CHAR
	JSR	PC,TOIOWP	;BLT OVER CHAR
	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BR	TOICW2
	JSR	PC,TOISWS	;SKIP IF WD SEPERATOR
	BR	TOICW1
	JSR	PC,TOIQU	;BLT OVER ^W
	RTS	PC

;[ INCS BRACKET COUNT
TOIOB:	INC TIBC(E)
	BGE	TOIOB1
	BPT	;-BRACKETS
TOIOB1:	JMP	SKIPR


;] DECS BRACKET COUNT IF THERE ARE ANY
TOICB:	TST	TIBC(E)
	BLE	TOICB1	;NO BRACKETS, IGNORE
	DEC	TIBC(E)	;DEC COUNT
	BR	TOIOB1
TOICB1:	JSR	PC,TOIQU	;OVERWRITE ]
	RTS	PC

;GET PREVIOUS CHARACTER IN INPUT BUFFER AND SKIP
TOIQP:	SPUSH	A
	MOV	TIQTO(E),A	;GET POINTER TO CURRENT CHARACTER
	TSTB	-(A)	;DECREMENT
	CMP	A,TIQT(E)
	BLO	TOIQP1	;BR IF NO PREVIOUS CHARACTER
	MOVB	(A),D
	SPOP	A
	SKPRET
TOIQP1:	SPOP	A
	RTS	PC

;CHECK FOR RUBBED OUT [ & ]
TOIBCK:	CMP	D,#'[
	BNE	.+6
	DEC	TIBC(E)	;IF CHAR WAS [, DECREMENT BRACKET COUNT
	CMP	D,#']
	BNE	.+6
	INC	TIBC(E)	;IF RUBBED OUT A ], INC BRACKET COUNT
	RTS	PC

;OVERWRITE PREVIOUS CHARACTER
TOIOWP:	DEC	TIQTO(E)	;BY INCLUDING IT IN UNPROCESSED CHARS
	INC	TIQTON(E)
;FALLS THROUGH

;BLT ALL UNPROCESSED CHARS BUT FIRST UP ONE BYTE
TOIQU:	JSR	D,TOIBLT
	MOV	C,D	;D PNTS TO LAST CHAR INPUT+1
	MOV	B,C	;B PNTS TO 1ST UNPROCESSED CHAR
	TSTB	(B)+
	BR	TOIQU2
TOIQU1:	MOVB	(B)+,(C)+
TOIQU2:	CMP	B,D
	BLO	TOIQU1
	DEC	TIQN(E)	;TOTAL # OF CHARS
	DEC	TIQTON(E)	;# OF UNPROC. CHARS
	DEC	TIQI(E)	;LAST CHAR
	BR	TOIBLE	;END BLT

;BLT ALL UNPROCESSED CHARS (INCLUDING FIRST) DOWN ONE BYTE
TOIQD:	JSR	D,TOIBLT;SET UP BLT
	MOV	B,D	;D PNTS AT FIRST CHAR TO BE BLTED
	MOV	C,B	;B PNTS AT 1+LAST CHAR TO BE BLTED
	TSTB	(C)+
	BR	TOIQD2
TOIQD1:	MOVB	-(B),-(C)
TOIQD2:	CMP	B,D
	BHIS	TOIQD1
	INC	TIQN(E)	;TOTAL # OF CHARS
	INC	TIQTON(E)	;# OF UNPROCESSED CHARS
	INC	TIQI(E)	;LAST CHAR +1
;END BLT
TOIBLE:	SPOP	C
	SPOP	B
	SPOP	D
	RTS	PC

;START BLT OF UNPROCESSED INPUT CHARS
;CALL WITH JSR D
TOIBLT:	SPUSH	B
	SPUSH	C
	MOV	TIQTO(E),B	;PNTR TO 1ST UNPROCESSED CHAR
	MOV	TIQI(E),C	;PNTR PAST LAST UNPRO. CHAR
	JMP	(D)

;GET NEXT CHAR FROM EDIT BUFFER INTO D AND SKIP IF SUCCESSFUL
TOGED:	TST	TIEQN(E)
	BLE	TOGED2	;BR IF NOTHING LEFT IN EDIT BUFFER
	DEC	TIEQN(E)	;DEC CHAR COUNT
	MOVB	@TIEQO(E),D	;GET NEXT CHAR
	INC	TIEQO(E)
	CMP	D,#'[
	BNE	.+6
	INC	TIEBC(E)	;CHAR WAS [
	CMP	D,#']
	BNE	.+6
	DEC	TIEBC(E)	;CHAR WAS ]
	CMP	D,#15
	BNE	TOGED1	;NOT A CR
	TST	TIEBC(E)	;CR, TEST FOR END OF EDIT LINE
	BGT	TOGED1
	CLR	TIEQN(E)	;EOL, CLR THIS TO BE XTRA CAREFUL
TOGED2:	RTS	PC

TOGED1:	SKPRET

;PRINT RUBBED OUT CHAR IN D ON E'S TTY
TOPRB:	BIT	#TIECM,TTYST(E)
	BEQ	TOPRB1	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BNE	TOIEC2	;ALREADY IN RUBOUT MODE
	BIS	#TIRBM,TTYST(E)
	BR	TOIEC1	;TYPE OPENING \

TOPRB1:	RTS	PC

;ECHO CHARACTER IN D ON E'S TTY
TOIEC:	BIT	#TIECM,TTYST(E)
	BEQ	TOPRB1	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BEQ	TOIEC2	;ALREADY NOT IN RUBOUT MODE
	BIC	#TIRBM,TTYST(E)
	;PRINT CLOSING \
;PRINT \:
TOIEC1:	MOV	D,C	;SAVE CHAR
	MOV	#'\,D
	JSR	PC,TOCINQ	;PUT \ INTO OUTPUT Q
	JSR	PC,TOEXT	;FILLED UP Q
	MOV	C,D	;RESTORE CHAR
TOIEC2:		;PRINT CHAR IN D

;FALLS THROUGH!!!
;FALLS IN!!!

;PROCESS CHAR IN D INTO TTY IN E'S OUTPUT BUFFER
;IF BUFFER FILLS SAVE ACS C,D,PC AND EXIT
TOTYO:	BIT	#TIMAGE,TTYST(E)
	BEQ	TOTYO1	;BR IF NOT IN IMAGE MODE
TOTYOC:	JSR	PC,TOINQ	;PUT CHAR IN OUTPUT BUFFER
	JSR	PC,TOEXT
	RTS	PC

TOTYO1:	MOV	D,C
	BIC	#177600,C
	BITB	#FOF,DTBL(C)
	BNE	TOTYO3	;BR IF SPECIAL ON OUTPUT
	CMP	D,#40
	BLT	TOTYO4	;BR IF CONTROL CHAR
	JSR	PC,TOCINQ
	JSR	PC,TOEXT
TOTYO2:	JSR	PC,TOCLTO	;CHECK FOR LINE TOO LONG
	RTS	PC
;SPECIAL ON OUTPUT
TOTYO3:	MOVB	DTBL2(C),C
	JSR	PC,@TOOCTB(C)
	RTS	PC
;CONTROL CHAR
TOTYO4:	TSTB	D	;QUOTED (PARITY BIT ON?)
	BMI	TOTYOC	;BR IF YES
	MOV	#'^,D
	JSR	PC,TOCINQ	;PRINT ^
	JSR	PC,TOEXT
	MOV	C,D
	ADD	#100,D
	JSR	PC,TOCINQ	;PRINT CHAR +100
	JSR	PC,TOEXT
	MOV	C,D
	BR	TOTYO2

;OUTPUT BUFFER FULL, SAVE STATE OF WORLD AND RETURN ONE LEVEL UP
TOEXT:	MOV	C,TOSVC(E)
	MOV	D,TOSVD(E)
	MOV	(P)+,TOPC(E)
	RTS	PC

;^A PRINTS AS CR
TOOCA:	CLR	CHARNO(E)
	MOV	#15,D
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	MOV	#1,D
	RTS	PC

;^H BACKSPACE DECREMENTS CHARNO IF NOT AT BEGINNING OF LINE
TOOCH:	TST	CHARNO(E)
	BLE	TOOCH1
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	DEC CHARNO(E)
TOOCH1:	RTS	PC

;CHECK IF LINE TOO LONG, IF SO PRINT CRLF
TOCLTO:	CMP	CHARNO(E),LINEL
	BLT	TOOCM1	;BR IF NOT TOO LONG
;^M PRINTS AS CR LF
TOOCM:	MOV	D,C	;SAVE D
	CLR	CHARNO(E)	;CLR CHAR COUNT
	MOV	#15,D
	JSR	PC,TOINQ	;PRINT CR
	JSR	PC,TOEXT
	MOV	#12,D
	JSR	PC,TOINQ	;PRINT LINEFEED
	JSR	PC,TOEXT
	MOV	C,D
TOOCM1:	RTS	PC

;^I PRINTS SPACES TILL NEXT TAB STOP
TOOCI:	MOV	D,C
	MOV	#40,D
TOOCI1:	JSR	PC,TOCINQ
	JSR	PC,TOEXT
	BIT	#7,CHARNO(E)
	BNE	TOOCI1
	MOV	C,D
	RTS	PC

;*** INTERRUPT AND USER LEVEL ***

;PUT CHAR IN D INTO TTY IN E'S CIRCULAR OUTPUT QUEUE
;SKIP TWO WORDS IF SUCESSFULL
TOCINQ:	INC	CHARNO(E)
TOINQ:	CMP	TOQN(E),TOQMX(E)
	BGE	TOINQ2	;BR IF BUFFER FULL
	CMP	TOQI(E),TOQL(E)
	BLO	TOINQ1
	MOV	TOQT(E),TOQI(E)	;RESET PNTR IF PAST BOTTOM
TOINQ1:	MOVB	D,@TOQI(E)	;PUT CHAR IN BUFFER
	INC	TOQI(E)
	INC	TOQN(E)	;INC # OF CHARS IN OUTPUT BUFFER
	SPUSH	E
	MOVB	MXNUM(E),E	;GET THIS TTY'S MULTIPLEXOR
	BMI	TOINQ4	;BR IF NOT PSEUDO OR MULTIPLEXED TTY
	INC	TOQN(E)	;INC MULTIPLEXOR'S CHARACTER COUNT
TOINQ4:	SPOP	E
	CMP	TOQN(E),TOQMX(E)
	BGE	TOINQ3	;BR IF Q FILLED NOW
	ADD	#4,@P	;SKIP RETURN TO SUCESS
TOINQ3:	RTS	PC

TOINQ2:	BPT	;TRIED TO PUT CHAR IN OUTPUT Q WHEN ALREADY FULL
	RTS	PC	;RETURN TO FAILURE
.STITL TELETYPE INITIALIZATION CODE

;INITIALIZATION CODE

TINIT:
;DECIDE WHICH PORTS TO USE & SET UP LOGICAL VARIABLES
	MOV	#NPORTS,A
	CLR	B	;INDEX TO PHYS TABLES
TINIT1:	MOVB	TILTTY(B),C	;LOGICAL INDEX
	BMI	TINIT2	;NOT LOGICAL
	MOVB	B,TIPTTY(C)	;PHYS TTY #
	MOVB	TILTTY+1(B),TIPTTY+1(C)	;MPXR #
	MOV	TYPTYP(B),TTYTP(C)
	MOV	TYRS(B),TOTSR(C)	;RCV RG ADDR
	BIT	#TPDM,TTYTP(C)
	BNE	.+10	;BR IF DM11
	ADD	#4,TOTSR(C)	;TRANS RG ADDR
	BIT	#TPMPX,TTYTP(C)
	BEQ	TINIT2	;BR IF NOT MPXR
	MOV	#MXRCV,TIRCV(C)	;RCV DISPATCH ADDR
	MOV	#MXGOC,TOGOC(C)	;TRANS DISPATCH ADDR
	SPUSH	A
	SPUSH	B
	MOV	#4,A	;# OF MPXED DEVICES
	MOV	TOQT(C),D
	MOV	D,TOQL(C)
	ADD	A,TOQL(C)
TINIT4:	TST	(B)+
	MOVB	TILTTY(B),(D)+	;PUT #'S OF MULTIPLEXEES IN OUTPUT Q
	SOB	A,TINIT4
	SPOP	B
	SPOP	A
TINIT2:	TST	(B)+
	SOB	A,TINIT1

;DECIDE WHICH ARE USER TTYS
	MOV	NUSERS,A
	MOV	#UTYTB,B
	CLR	E
	CLR	U
TINIT3:	MOV	(B)+,E	;INDEX OF NEXT USER TTY
	TST	TTYU(E)
	BMI	.+4
	BPT	;ALREADY BELONGS TO A USER
	MOV	U,TTYU(E)
	MOV	E,UTTY(U)
	JSR	PC,TTYRT	;RESET (INITITALIZE) BUFFERS
	JSR	PC,UCINIT	;INITIALIZE CONSOLE VARIABLES
	ADD	#LUBLK,U
	SOB	A,TINIT3
	MOV	#SYSIDX,TTYU+NFTBOX	;MAKE SYS TBOX USER
	MOV	#TTYI,ITYI	;SET UP NEW USER TYI &TYO ADDRS
	MOV	#TTYO,ITYO
	JSR	PC,TINITH	;INIT HARDWARE
	JMP	NEXTUS

;DON'T FORGET TBOXES
;HARDWARE INITIALIZATION
TINITH:	
.IFNZ NTY
	MOV	#100,TKS	;CONSOLE TTY
	MOV	#100,TPS
.ENDC
	MOV	#111,DC0RS
	MOV	#113,DC0TS
	MOV	OMXRES+DC0TBN,DC0TB	;SLIGHT KLUGE, RESET TBOX
	MOV	#101,DC1RS
	MOV	#501,DC1TS	;FOR VOICE BOX(RJL)
.IFZ DHON
	MOV	#DMCA+NFDMTY,DM0TBR
	MOV	#DMTT,TTP
	MOV	#10101,DM0CSR
.IFF
	MOV #20,A	;SET ALL LINES TO 300 BAUD
	CLR DH0SCR	;START AT ZERO
TINITX:	MOV #16703,DH0LPR
	INC DH0SCR
	SOB A,TINITX
	CLR DH0SSR	;INTERUPT ON > 0 CHARS
	MOV #30100,DH0SCR
.ENDC
	RTS	PC

;CROCKS

DMSQ:TI2Q:	RTS	PC

DC0SND:TB0SND:
	BPT
	RTS	PC
