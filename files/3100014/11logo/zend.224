	.STITL	DISC BLOCKS, NODE SPACE AND TEST LINES
	FOO==%FNAM2
	VERN==VERN+%FNAM2
	.IFNZ NEWDIS
	.=<.!77>+1
DISBTB==<._-6>&1777
DISTPB==<._-6>&1777+1000	;TOP DISPLAY BLOCK
DISREL:	REPT1 8.,DSTOP
DISPDL:	.BLKW 8.
	.=<.!77>+1
DISBFS==<._-6>&1777	;BEGINNING OF FIRST DISPLAY SLOT
	.ENDC
	.IFNZ NEWERS
ERRSRT:	NERRS
ERLNTH==.-ERRSRT
	.ENDC

	.MACR NODE A,B
	.XLIST
$.==$$+1
	A
	B
$$==$$+1
	.LIST
.ENDM

VERNF==VERN

.=<.!77>+1
SLOT1:
	.IF2
	PAD ^\ SLOT1 AT\,\.
	.ENDC
MSLTLN==NODESP-UVBLK+<4*4096.>	;ALL YOU COULD POSSIBLY WANT
	.IFNZ SEG
.OFFSE PURE-.
	.ENDC
	.STITL USER VARIABLES

UVBLK=.
S:	IS
UPDLP:	IP	;USER PDL POINTER(ONLY WHEN USER NOT RUNNING)
SPOPL:	IS
SSWPAD:	IS-PDSWOP
PPOPL:	IP
PSWPAD:	IP-PDSWOP
	.IFNZ OFILES
DBUFAD:	DBUF
DDIRAD:	DDIR	;THE DISK DIRECTORY
DDIRPT:	0
	.ENDC
DBUFPT:	0	;POINTER INTO THE DISK BUFFER
ERRPNT:	0
BASEUS:	0	;BASE OF USER SLOT(MUST BE LAST RELOCATED)
PRBAO:	0	; = 0,374,770, ... N*PDSWOP
SPRBAO:	0	;WHERE N = # P OR S PDL BLOCKS SWAPPED OUT
NSYBUG:	20.	;NUMBER OF SYSTEM BUGS BEFORE RELOAD
NNGC:	0	;NUMBER OF NODES GARBAGE COLLECTED
NNIFSL:	0	;NO. NODES IN FREE STORAGE LIST
DSKNCH:	0	;NUMBER OF CHARS LEFT IN DISK BUFFER
DSKNSC:	0	;NUMBER OF SECTORS IN THIS FILE
DSKADR:	0	;CURRENT SECTOR FOR THIS FILE
	.IFNZ NFILES
REDFLG:	0
WRTFLG:	0
FILFLG:	0
DEFDIR:	46
WRTDIR:	0
LBLKAD:	0
DESMOD:	0
DBGOT:	0
DEOFBL:	-1
ENTBEG:	0
FNBLK:	.BLKW 5
CURDIR:	46
DESSAV:	.BYTE 'N,'E,'W,'S+200
	.BLKW 30.
NAME==DESSAV+2
DBCNT:	0
DESPNT:	0
DESEPT:	0
	.ENDC
SSAVEA:	0	;PLACE S PDL SAVED WHEN MARKING SWAPED OUT PDL
	.IFNZ OFILES
DDIRLS:	MOV0D
	MOV1D
	-1
DSKDAD:	0
DIRNAM:	0
	0
FNAME:	0
	0
	.ENDC
FREE:	SOFN	;START OF FREE NODES
GCP1:	0
GCP2:	0
GCPREV:	0
	ERCLR1==.	;ON ERROR, START ZEROING HERE
TOPS:	0	;GC MARK FROM HERE IF NON 0
TOPS1:	0	;   "
TOPS2:	0	; "	(SIGH)
JPLN:	0	;PROCEDURE LINE # BEFORE LAST "GO"
	;THE FOLLOWING ARE PUSHED BY PEVAL
CPP:	0	;CURRENT PROCEDURE UOE POINTER
CPSN:	0	;C.P. SWAP NO.
CPLN:	0	;CURRENT PROCEDURE LINE NO.
CLP:	0	;CURRENT LINE POINTER - GOOD IF CPSN'S AGREE
CLGN:	0	;CURRENT LINE GENERATION NO.
CTN:	0	;CURRENT TOKEN NO.
CTP:	0	;CURRENT TOKEN POINTER
IFLEV:	0	;IF LEVEL
NOPAR:	0	;NUMBER OF PARENS SEEN BY STNE
CPDLP:	0	;CURRENT PDL PTR AFTER LAST PEVAL PUSH
CSPDLP:	0	;CURRENT S PDL PTR AFTER LAST PEVAL PUSH
	;END OF PEVAL PUSHES EXCEPT
	;CO, CO+2, FLAGS + ERPROC ARE ALSO PUSHED
FUNLEV:	0	;FUNCTION LEVEL

	;THE FOLLOWING ARE PUSHED (SOMETIMES) BY EVAL
CO:	0	;CURRENT OPERATOR
	0
NOR:	0	;NO. OF OPERANDS STILL NEEDED BEFORE CO CAN BE EXECUTED
	;END OF EVAL PUSHES
COF:	0	;CURRENT OPERATOR FLAGS
LO:	0	;LAST OPERATOR
	0
CT:	0	;CURRENT TOKEN
	0	; "
RDFLAG:	0	;FOR READ
LISTBD:	0	;LIST BUILD DEPTH
PSTOPR:	0	;RETURN ADDR FOR PSTOP
TEMP:	0
TMPBLK:	.BLKW 7
TFLAGS:	0	;TEMP FLAGS (ALL TFN'S SHOULD EVENTALLY POINT HERE)
NCHR:	0	;FOR BLST
ABASE:	0	;(ABASE)+10. IS WHAT ARITHMETIC BASE WE ARE IN
		;(FOR CONVERT TO & FROM STRING ROUTINES)
	ERCLR2==.	; ON ERROR STOP CLEARING HERE
FLAGS:	0	;FLAG WORD
ERPROC:	0	;UOE PTR TO PROC TO CALL IF THERE IS AN ERROR
ILINEL:	0	;INPUT LINE PTR GC MARK FROM HERE)
NPROCL:	0	;NAME OF PROC BEING EXECUTED WHEN ERROR OCCURED
NLINEL:	0	;# OF PROC LINE BEING EXECUTED " " "
NTOKEL:	0	;# OF TOKEN BEING EXECUTED " " "
ERRORN:	0	;ERROR NUMBER
BRAKEL:	0	;VALUE OF BRAKE(U)
TOPRNM:	0	;PTR TO UOE OF PROC. BEING "TO"'ED
FNLLP:	0	;FIRST NODE OF LIST OF LINE POINTERS (FOR "TO")
FLAGS2:	0	;EVAL FLAGS - NOT PUSHED BY PEVAL
PRMTCH:	'?	;PROMPT CHAR
GNCN:	0	;"GET NEXT CHAR" NODE AND USED BY GNOLE
	0
NBKTS:	0	;FOR RDSTR
LASTER:	0	;ADDRESS OF LAST ERROR
LASTPR:	0	;LAST PROC DEFINED
GCHR:	TYI	;SOURCE OF CHARS
PCHR:	TYO	;PLACE WHERE OUTPUT CHARS GO (TYO, BLST, ...)
RNSEED:	27.	;FOR RANDOM
ALEVN:	0	;NON-ZERO MEANS ALLOW N LEVEL BREAK STUFF
WVALUE:	0	;USED BY EXAMINE, DEPOSIT, VALUE
DBITTB:	.=.+40
DBITBE=.-2
;TURTLE VARIABLES
TURDN:	0	;USER'S TURTLE DEVICE NUMBER
TURF:	0	;FUDGE FACTOR FOR TURTLE LEFT AMD RIGHT

;MUSIC VARIABLES
MVOC:	.WORD	0,0,0,0	;POINTERS TO VOICE LISTS--ONE FOR EACH VOICE


DFLAGS:	.WORD 0

	FOR NPLOT
;PLOTTER VARIABLES
;THESE MUST BE IN ORDER
PCURX:	.WORD 0,0	;CURRENT PLOTTER X POS
PCURY:	.WORD 0,0	;PLOTTER CURRENT Y
PCURA:	0		;CURRENT ANGLE PLOTTER
	.ENDC
	ENDC NPLOT

	FOR NDISP
;VARIABLES AND CONSTANTS FOR DISPLAY SYSTEM

;THESE MUST BE IN THIS ORDER
DORBEG==.	;MARKS BEGINNING OF THESE VARIABLES
CURX:	.WORD 0,0	;CURX = CURRENT X POSITION
;			THE FIREST WORD IS THE INTEGER PART
;			THE SECOND WORD IS THE FRACTION PART
CURY:	.WORD 0,0	;CURY = CURRENT Y POSITION
CURA:	0	;CURA = THE CURRENT ANGLE
OLDX:	0	;CONTAINS CURX AT THE TIME OF LAST NEW SNAP
OLDY:	0	;CONTAINS CURY AT THE TIME OF LAST NEW SNAP
NADXY:	0	;NUMBER OF EXTRA ADDXY'S WE CAN TRY TO COLLAPSE
ODIREC:	0	;IF NOT EQUAL TO DIREC BREAK INCREMENTS TO NEW OWRD

DOREND==.	;MARKS END OF THESE VARIABLES
;END OF ORDER

STB:	0	;STATIC AREA BOTTOM
STT:	0	;STATIC AREA TOP.POINTS TO TOP OF STATIC DISPLAY AREA
DYB:	0	;DYNAMIC BOTTOM.  POINTS TO BOT OF DY AREA
DYR:	0	;ROVING POINTER USED BY DISPLAY STORAGE ALLOCATIN ROUTINES
DYT:	0	;POINTER TO DYNAMIC AREA TOP
TUB:	0	;POINTER TO TURTLE AREA BOTTOM
SNLIST:	0	;POINTER TO SNAP LIST
SNABOT:	0	;BOTTOM OF CURRENT SNAP
SINA:	0	;CONTAINS SIN OF THE CURENT ANGLE
COSA:	0	;CONTAINS COS OF THE CURENT ANGLE
DIREC:	0	;CONTAINS DIRECTION CODE FRO CURRENT ANGLE
DFBCNT:	0	;KEEPS TRACK OF # OF FREE BITS IN DISPLAY LIST
PUSHJT:	0	;DISPLAY PUSHJ TO TURTLE
.IFZ	NEWDISP
DISNUM:	0
.ENDC
.IFNZ	NEWDISP
DRELOC:	0	;RELOCATION.  ADD THIS TO VIRTUAL ADDRESS TO GET DISPLAY ADDRESS
.ENDC
	.ENDC
	ENDC NDISP


ERRBUF:	.=.+MAXELN
LUVBLK==.-UVBLK
	.=.+20	;EXTRA P PDL SLOP
PDLLIM==.
	.=.+PPDLL
	IP=.
PPUSHL==IP-<PPDLL-PDSLOP>
PDLINK:	.=.+4	;LINK TO PREVIOUS DISK BLOCK
	.=.+SPDLL
	IS=.
SPUSHL==IS-<SPDLL-PDSLOP>
SDLINK:	.=.+4
HCC==67.	;HASH CODE CONSTANT - A PRIME
UHCT:	.=UHCT+<2*HCC>
	-1
GCBITS:DBUF:	.=.+DBUFL
	.IIF NZ OFILES,DDIR:	.=.+DDBUFL
	.=DBUF+2000
	0
	0

.IF2
	PAD ^\ START OF NODESP\,\.
.ENDC

NODESP:	0	;NODE 0
N==NODESP
	0
	$$==1
TRUE=LSTR+$$
	NODE SSTR+$.,"TR
	NODE SSTR,"UE
FALSE=LSTR+$$
	NODE SSTR+$.,"FA
	NODE SSTR+$.,"LS
	NODE SSTR,'E
SECRET=LSTR+$$
	NODE SSTR+$.,"SE
	NODE SSTR+$.,"CR
	NODE SSTR,"ET
$TOTO=LSTR+$$
	NODE SSTR,"TO

	LUNN=$$-1
	NNN=$$	;NEXT NODE NO.
SOFN=NNN	;START OF FREE NODES
ASOFN=.
CLSLTL=<.-UVBLK>/2
	.IFNZ SEG
	.OFFSE 0
	.ENDC
.STITL	INITIALIZE THE WORLD!
CORCHK:	ADD #2,(P)
	RTI
SORTER:	MOV SPDLP,P	;FOR STIMULATOR HACKING
	JSR PC,SORT	;JUST DO THE SORT
	HALT
START:	RESET
	MOV SPDLP,P	;SET UP SYSTEM PDL
.IFZ DHON
.IFG NDM
	MOV #DMTT,DM0TBR
.ENDC
.ENDC
	JSR PC,SORT	;SORT SYSTEM OBLIST
	CLR TIME
	MOV #CORCHK,BEBRV
	.IFNZ NDISP
	MOV #DISREL,NGREL	;SET DISPLAY RELOCATION
	BR .+2
	.ENDC
	MOV #MOVON,A
	TST RKCS
	MOV A,(A)
	MOV #100,LKS
	BR LINEKR
	CLR PCSTBF	
	MOV #115,PCS
LINEKR:
	.IFZ SEG
	MOV #LOGEND,B	;LAST LOCATION WITH CRAP IN IT
	ADD #200,B
	TST (B)	;IS IT REALLY THERE?
	BR .-6	;LOOP ENDED BY MEM TRAP
	BIC #377,B
	SUB #1000+SLOT1,B	;FUDGE AREA (NOW RADIA CAN FIT DDT THERE!)
	.IFF
	JSR PC,SEGSET
	SPL 7
MEMCHK:	INC KDAR+2
	TST 20000
	BR MEMCHK
	DEC KDAR+2
	MOV #1600,F
	.IFNZ NEWDIS
	CLR C
	MOV #DISBFS,A
	MOV #1560-DISBFS,B
	MOV NDISPS,D
	BEQ SLTAL2
DISAL:	MOV DLENGT(C),E
	CMP E,B
	BGT DISAL1
	MOV A,DISAR(C)
	ADD E,A
	SUB E,B
	BR DISAL2
DISAL1:	MOV F,DISAR(C)
	ADD E,F
DISAL2:	DEC E
	SWAB E
	BIS #6,E
	MOV E,DISDR(C)
	TST (C)+
	SOB D,DISAL
	CMP #DISTPB,F
	BGE .+4
	BPT
	.ENDC
SLTAL2:	MOV KDAR+2,B
	SUB F,B
	BGT .+4
	BPT
	MOV #200,KDAR+2
	MOV #<<SLOT1_-6>&1777>,PUREAR
	SPL 0
	.ENDC
	MOV #BEBRK,BEBRV
	CLR A
.IFNZ A1120
	MOV #MQ,C
	MOV B,(C)	;MOVE B TO MQ
	CLR -(C)	;CLEAR HIGH ORDER(AC)
	MOV NSLOTS,-(C)	;DIVIDE
	MOV MQ,A	;GET RESULT
.IFF
	DIV NSLOTS,A
.ENDC
	.IFZ SEG
	CMP A,#MSLTLN
	BLO .+6
	MOV #MSLTLN,A
	BIC #37,A
	MOV #SLOT1,B	;BEGINING OF SLOT-2 (FOR DISK)
	.IFF
	CMP A,#<MSLTLN/100>+2
	BLO .+6
	MOV #<MSLTLN/100>+2,A
	MOV F,B
	.ENDC
	CLR C
	MOV NSLOTS,D
SLTAL1:
	.IFZ SEG
	MOV B,SLOTCA(C)	;ADDRESS OF THIS SLOT
	ADD A,B	;NEXT ONE
	.IFF
	MOV B,SLOTAR(C)
	MOV B,F
	CLR E
	ASHC #6,E
	MOV E,SLOTHA(C)
	MOV F,SLOTCA(C)
	ADD A,B
	.ENDC
	TST (C)+
	DEC D
	BGT SLTAL1	;DO THIS NSLOTS TIMES
	.IFNZ SEG
	MOV #SLOTDR,B
	MOV A,C
	MOV #3,D
SLTDRS:	MOV #77406,(B)
	CMP #200,C
	BLE SLTDR1
	TST C
	BGT SLTDR2
	CLR (B)
	BR SLTDR1
SLTDR2:	DEC C
	MOVB C,1(B)
SLTDR1:	SUB #200,C
	TST (B)+
	SOB D,SLTDRS
	ASH #6,A
	.ENDC
	MOV A,USLENT
	ASR A
	MOV A,B		;SAVE A POSITIVE WORD COUNT
	NEG B
	MOV B,USWCNT
	ASL A	;DIVIDE BY 200
	SWAB A
	INC A	;ADD 1 TO BE SURE
	MOVB A,USNSEC	;NUMBER OF SECTORS USED BY A SLOT
	TST DEBSW
	BNE NOTIME
GETTIM:	CPRTXT ^\DATE AND TIME YY/MM/DD HH:MM:SS :\
	MOV #RYEAR+1,C
GETNM1:	CLR B
	CLR F
GETNUM:	JSR PC,TYI
	CMP #177,D
	BEQ GETTIM
	CMP #15,D
	BEQ NOTIM1
	SUB #60,D
	BLT GOTNUM
	CMP #10.,D
	BLE GOTNUM
	INC F
	MUL #10.,B
	ADD D,B
	BR GETNUM
GOTNUM:	CMP #RSEC,C
	BEQ NOTIME
	TST F
	BEQ GETNM1
	CMP #RDAY,C
	BHIS .+4
	DEC B	;YMD ARE ALL INCREMENTED BEFORE TYPEOUT
	MOVB B,-(C)
	BR GETNM1
NOTIM1:	TST F
	BEQ .+4
	MOVB B,-(C)
NOTIME:	.IFNZ OFILES
	TST MOVON
	BNE .+6
	JMP M1AIN
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-200,(A)+
	MOV #FHDDIR,(A)+
	MOV #20000,(A)+
	MOV #-1,(A)+
	TST (A)+
	MOV #DREADC,(A)
	JSR PC,DPROVK
	TSTB (A)
	BNE .-2
	MOV #MOV1DR,B
	MOV #FHDDIR,A
	CLR D
	JSR F,FSEARC
	BR M1INIT
	BR M1INIT
	BR M1AIN
M1INIT:	PRTXT ^/INIT THE REMOVEABLE PLATTER?/
	JSR PC,TYI
	MOV D,E
	PRCR
	CMP #'Y,E
	BNE M1AIN
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-200,(A)+
	MOV #MOV1DR,(A)+
	MOV #20000,(A)+
	MOV #-1,(A)+
	TST (A)+
	MOV #DWRTEC,(A)
	JSR PC,DPROVK
	TST (A)
	BNE .-2
M1AIN:
	.ENDC
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-200,(A)+
	MOV #FHDDIR,(A)+
	CLR (A)+
	CLR (A)+
	TST (A)+
	MOV #DREADC,(A)
	JSR PC,DPROVK
	TSTB (A)
	BNE .-2
	CLR (A)
	SPUSH A
	MOV #FHIDIR,B	;SEE IF IT IS INITIALIZED
	MOV #FHDDIR,A
	CLR D
	JSR F,FSEARC
	BR DINIT	;NOT INIT
	BR DINIT	;NOT INIT
	CMP #FHDDIR,A
	BEQ DAINIT	;DISK ALREADY INIT
DINIT:	PRTXT ^\OK TO INIT DISK?\
	JSR PC,TYI
	CMP #'Y,D
	BNE DAINIT
	MOV #200,A
	MOV #FHIDIR,B
	MOV #FHDDIR,C
	MOV (B)+,(C)+
	DEC A
	BGT .-4
	MOV #DWRTEC,@(P)	;WRITE OUT THE INITIALIZED DIRECTORY
	JSR PC,DPROVK
	TST @(P)
	BNE .-4
DAINIT:	JSR PC,.CRLF
	TST (P)+
	MOV #FHCLUS,B	;FIND CLEAR USER PLACE
	JSR F,FHSERC
	HALT	;DISK STILL NOT PROPERLY INIT??????
	SPUSH F
	SPUSH #DCLRUS
	JSR PC,LSH7
.IFNZ NEWERS
	MOV #FHERR,B
	JSR F,FHSERC
	HALT
	SPUSH F
	SPUSH #ERBASE
	JSR PC,LSH7
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-ERLNTH/2,(A)+
	MOV #ERRSRT,(A)+
	MOV ERBASE,(A)+
	MOV ERBASE+2,(A)+
	TST (A)+
	MOV #DWRTEC,(A)
	JSR PC,DPROVK
	TST (A)
	BNE .-2
.ENDC
	MOV #FHSYS,B	;FIND THE SYSTEM AREA
	JSR F,FHSERC
	HALT ;????????
	SPUSH D	;SAVE ADDRESS OF START
	SPUSH F
	SPUSH #DSKRND
	JSR PC,LSH7
	MOV 10(A),D	;LENGTH OF SYSTEM AREA
	BIC #170000,D	;GET RID OF TYPE
.IFNZ A1120
	MOV D,MQ	;DIVIDE SPACE EQUALLY AMONG USERS
	MOV NUSERS,DIVIDE
	MOV MQ,A
.IFF
	CLR C
	DIV NUSERS,C
	MOV C,A
.ENDC
	MOV A,B
	SUB #2,A	;KLUDGE, THIS IS SIZE OF TYI+EDIT BUFS+SIZE OF SAVE SPACE
	SUB USNSEC,A	;NUMBER OF SECTORS NEEDED FOR SWAPPING
	MOV A,E	;REMAINING IS FOR DISK BLOCKS
	CMP #400,A	;BUT NOT MORE THAN 1000
	BGT .+6
	MOV #377,A	;MAXIMUM
	MOV A,B
	ASR B
	ASR B
	ASR B
	ASR B	;NUMBER OF BLOCKS/20 NOW IN B
	MOV #DBITTB,C	;SET UP TO INIT DISK BIT TABLE
DALOC5:	DEC B	;20 BLOCKS (=1 WORD IN TABLE)AT A TIME
	BLT DALOC4	;ALL DONE 
	CLR (C)+
	BR DALOC5
DALOC4:	CLR (C)	;ONLY SOME BITS ON IN THIS WORD
	COM (C)
	MOV #1,D
	BIC #177760,A	;# OF WORDS MOD 20
DALOC6:	DEC A
	BLT DALOC7
	BIC D,(C)
	ASL D
	BR DALOC6
DALOC7:	TST (C)+
	CMP C,#DBITBE
	BGT DALOC8
	MOV #-1,(C)
	BR DALOC7
DALOC8:	BIS #100000,DBITBE	;IMPOSSIBLE TO GO OFF TOP
	CLR U
	MOV NUSERS,C
	CMP #1,C
	BNE .+10
	MOV #1,NEXTU7
	SPOP A	;STARTING ADDRESS OF SYS STORAGE

.MACR IADDR AD	;MACRO TO INTIALIZE USER VARIABLES
	MOV A,D
	SPUSH F
	SPUSH AD
	JSR PC, LSH7
	ADD #LUBLK,AD
.ENDM

UVINIT:	CLR FLSADR(U)
	MOV #-1,SLOTAS(U)
	MOV #-1,DISAS(U)
	MOV #FRNEWU,FLSRES(U)	;THIS IS A NEW USER
	IADDR IUSWPD
	ADD USNSEC,A	;FIRST ADDRESS IS SWAPPING AREA
	IADDR IUDBSV	;PLACE TO SAVE DISK BUFFERS WHEN GC'ING
	ADD #2,A	;KLUDGE
	MOV A,@IUDSK
	ADD #LUBLK,IUDSK
	ADD E,A
	ADD #LUBLK,U
	DEC C
	BGT UVINIT
	MOV #MNUSRS,A
	SUB NUSERS,A	;GET NUMBER OF INACTIVE SLOTS
UVINT1:	DEC A	;ANY INACTIVE SLOTS TO FLUSH?
	BLT UVINT2	;NO
	MOV #-1,FLSADR(U)
	ADD #LUBLK,U
	BR UVINT1
UVINT2:	MOV #-1,SLOTAS(U)
	MOV #SYSJOB,FLSADR(U)	;INIT SYS JOB
	CLR UTTY(U)	;PUT IT ON TTY ZERO
	JMP INIT1
;JSR F,FHSERC FIND FILE ON FIXED HEAD DISK
;SKIP 0 BYTES IF NOT THERE
;SKIP 2 BYTES IF FOUND
FHSERC:	MOV #FHDDIR,A	;ADDRESS OF FIXED HEAD DISK DIRECTORY
	CLR D	;START SECTOR ADDRESS AT ZERO
	TST -(F)	;ADJUST TO SKIP PROPERLY
	JMP FSEARC

CHI:	0		;USED IN STYI

MOVON:	0

IUSWPD:	USWPAD
IUDBSV:	UDBFSV
IUDSK:	UDSKAD

SORT:	MOV #SOBLST+2,A	;POINTER TO START AT
	MOV #SOBLSU,B	;PLACE TO FINISH
	MOV PC,F	;SET "SOMETHING MOVED" FLAG
SORTUG:	TST F	;DID SOMETHING GET MOVED LAST PASS?
	BEQ SORTDN	;NO, WE ARE DONE
	CLR F	;NOTHING SO FAR THIS PASS
	MOV A,C	;POINTER INTO TABLE
SORTU:	MOV (C)+,D	;START OF SORT UP
	MOV (C),E	;THINGS TO SORT
	ADD #4+SOBLST,D	;GET TO STRING
	ADD #4+SOBLST,E	;FOR BOTH
SORTU3:	CMPB (D),(E)	;COMPARE THE WORDS
	BLT SORTU2	;IN ORDER, GO TO NEXT PAIR
	BEQ SORTU1	;SAME, CHECK NEXT WORD
	INC F	;HAVE TO SWITHC THEM
	MOV -(C),D
	MOV 2(C),(C)+
	MOV D,(C)
SORTU2:	CMP C,B	;ARE WE AT END?
	BNE SORTU	;NO, CONTINUE
	TST -(B)	;YES, NEXT TIME NOT SO FAR
	BR SORTDG	;GO TO DOWNWARD SORT
SORTU1:	TSTB (D)+
	BNE .+6	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
	TSTB (E)+
	BNE .+6
	MOV #ZERO,E
	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTU3	;OK, CONTINUE
	BPT	;BARF, THEY'RE EQUAL????
	BR SORTU3

SORTDG:	TST F	;DID WE MOVE ANY ON THE UP PASS?
	BEQ SORTDN	;NO,DONE
	CLR F	;CLEAR FLAG
	MOV B,C	;SET POINTER
SORTD:	MOV (C),D
	MOV -(C),E
	ADD #4+SOBLST,D
	ADD #4+SOBLST,E
SORTD3:	CMPB (D),(E)
	BGT SORTD2
	BEQ SORTD1
	INC F
	MOV (C)+,D
	MOV (C),-(C)
	MOV D,2(C)
SORTD2:	CMP C,A
	BNE SORTD
	TST (A)+
	BR SORTUG
SORTD1:	TSTB (D)+
	BNE .+6	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
	TSTB (E)+
	BNE .+6
	MOV #ZERO,E
	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTD3
	BPT
	BR SORTD3

SORTDN:	RTS PC
ZERO:	0


	.IFNZ SIMP
FHIDIR:	.WORD "FI,"XD,"DS,"K0,100020	;DISK LABEL
			;(CHANGE THE LABEL WHEN YOU CHANGE
			; THE INITIAL DIRECTORY!!!!!!!)
FHRUG:	.WORD "SY,'S,"RU,'G,101540	;RUG FILE, 1/2 DISK (SIGH!)
FHCLUS:	.WORD "SY,'S,"CL,"US,100100	;CLEAR USER
FHERR:	.WORD "SY,'S,"ER,"RS,100040
FHSYS:	.WORD "SY,'S,"US,"TO,102000	;USER SPACE
	.WORD 0,0,0,0,77	;SPACE LEFT ON DISK
.=FHIDIR+372
	-10	;END MARKER ON DIRECTORY
	.ENDC
	.IFNZ AI
FHIDIR:	.WORD "FI,"XD,"DS,"K0,100020	;DISK LABEL
			;(CHANGE THE LABEL WHEN YOU CHANGE
			; THE INITIAL DIRECTORY!!!!!!!)
FHRUG:	.WORD "SY,'S,"RU,'G,102110	;RUG FILE, 1/2 DISK (SIGH!)
FHCLUS:	.WORD "SY,'S,"CL,"US,100100	;CLEAR USER
FHERR:	.WORD "SY,'S,"ER,"RS,100040
FHSYS:	.WORD "SY,'S,"US,"TO,105500	;USER SPACE
	.WORD 0,0,0,0,00	;SPACE LEFT ON DISK
.=FHIDIR+372
	-10	;END MARKER ON DIRECTORY
	.ENDC
	.IFNZ GUY
FHIDIR:	.WORD "FI,"XD,"DS,"K0,100020	;DISK LABEL
			;(CHANGE THE LABEL WHEN YOU CHANGE
			; THE INITIAL DIRECTORY!!!!!!!)
FHRUG:	.WORD "SY,'S,"RU,'G,102110	;RUG FILE, 1/2 DISK (SIGH!)
FHCLUS:	.WORD "SY,'S,"CL,"US,100100	;CLEAR USER
FHERR:	.WORD "SY,'S,"ER,"RS,100040
FHSYS:	.WORD "SY,'S,"US,"TO,103000	;USER SPACE
	.WORD 0,0,0,0,12500	;SPACE LEFT ON DISK
.=FHIDIR+372
	-10	;END MARKER ON DIRECTORY
	.ENDC
MOV1DR:	.WORD "MO,"V1,"DI,"SK,100100
	.WORD "RU,'G,"FI,"LE,103100
	.WORD 0,0,0,0,6000
	.=MOV1DR+372
	-40
FHDDIR:	.=.+400

	ALLTXT <>		;ZEND TEXT CONSTANTS

LOGEND=.
	.END START
