.TITLE LSI-11 END OF DH/DD/SMS RT11 DRIVER
A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
P=%6
SP=%6
PC=%7


SMSCSR=177200		;THE CSR FOR THE SMS TO PDP11 INTERFACE
SMSDBF=SMSCSR+2	;THE DATA BUFFER BYTE
SMSCMD=SMSDBF+2	;THE COMMAND BUFFER BYTE
SMSLGT=SMSCMD+2	;LIGHT REGISTER
SMSBRV=270		;TRAP VECTOR ADDRESS
SMSTV=SMSBRV
CLKBRV=100	;CLOCK TRAP ADDRESS
SMSPRM=173000	;PROM ADDRESS
SMSPRE=173376	;LAST PROM ADDRESS (CONFIGURATION WORD)
 SMS60H=1	;IF THIS BIT IS ONE, MACHINE IS 60HZ, ELSE 50HZ
SMSRST=0	;RESET COMMAND, SECOND BYTE IGNORED
 SMSINI=200	;INIT COMMAND
 SMS512=2	;512 BYTE BLOCKS
 SMSDBL=4	;DOUBLE DENSITY
SMSSEK=1	;SEEK, OR WITH DISK DRIVE_3, SECOND BYTE TRACK ADDRESS
SMSRED=2	;READ, OR WITH DISK DRIVE_3 AND:
 SMSDTB=100	 ;DISK TO BUFFER BIT
 SMSBTH=200	 ;BUFFER TO HOST BIT
		  ;SECOND BYTE ON READ IS SECTOR
SMSRID=3	;READ NEXT SECTOR ID, OR WITH DISK DRIVE_3, SECOND BYTE IGNORED
SMSWRT=4	;WRITE, OR WITH DISK DRIVE_3 AND:
 SMSBTD=100	 ;BUFFER TO DISK
 SMSHTB=200	 ;HOST TO BUFFER
		  ;SECOND BYTE ON WRITE IS SECTOR
SMSWRD=5	;WRITE WITH DELETED DATA MARK, OTHERWISE SAME AS WRITE
SMSFMT=6	;FORMAT THE TRACK THE HEADS ARE OVER
		 ;OR WITH DISK DRIVE_3, SECOND BYTE IS TRACK ADDRESS TO WRITE ON DISK
SMSSTS=7	;READ STATUS, OR WITH DISK DRIVE_3, SECOND BYTE IGNORED

;STATUS BITS IN CSR
SMSERR=100000	;ERROR IN OPERATION
SMSRSB=40000	;RESET BIT
SMSPWR=4000	;POWER ON DISK DRIVES
SMSCLE=2000	;CLOCK INTERUPT ENABLE
SMSST1=1000	;STAT ID BIT 1
SMSST0=400	;STAT ID BIT 0
SMSDNE=200	;DONE
SMSINT=100	;INT ENABLE
SMSBSY=40	;BUSY
SMSCMW=20	;WAITING FOR A COMMAND BYTE
SMSDDR=10	;DATA DIRECTION
SMSFDO=4	;FDC ON
SMSXFW=1	;WAITING FOR XFR

;STATUS BITS IN STATUS BYTE
;COMMAND STATUS
SMSITA=2	;INVALID TRACK ADDRESS
SMSISA=4	;INVALID SECTOR ADDRESS
SMSIBS=10	;INVALID BUFFER SPEC
;DISK DRIVE STATUS
SMSDNR=1	;DRIVE NOT READY
SMSDUS=2	;DRIVE UNSAFE
SMSDWP=4	;DRIVE WRITE PROTECTED
SMSNAM=10	;NO ADDRESS MARKS FOUND
SMSSIP=40	;SEEK IN PROGRESS
;OPERATION STATUS
SMSRWA=1	;READ/WRITE ABORTED
SMSHPE=2	;HEAD POSITIONING ERROR
SMSDAM=4	;DATA ADDRESS MARK MISSING
SMSDOV=10	;DATA OVERRUN
SMSSUR=20	;SECTOR UNRECOVERABLE
SMSCRC=40	;CRC ERROR
SMSRWC=100	;READ/WRITE COMPLETE
SMSDDR=200	;DELETED DATA READ

TKS=176500
TKB=TKS+2
TPS=TKB+2
TPB=TPS+2
ACK=105
NAK=403
.=1000
PDL:

.MACRO DCMD A
	JSR PC,WAITR
	MOV A,-(P)
	BIS UNIT,(P)
	MOV (P)+,SMSCMD
.ENDM

.MACRO CMD2 A
	JSR PC,WAITR
	MOV A,SMSCMD
.ENDM


START:	BIS #SMSPWR!SMSRSB,SMSCSR	;TURN ON THE DISK
.IF DF LSIDBL
1$:	BIT #SMSFDO,SMSCSR
	BNE 1$
	DCMD #SMSINI
	CMD2 #SMS512!SMSDBL
.ENDC
	MOV #-1,UNIT
RSTART:	MOV #PDL,P
	CLR SMSLGT
2$:	MOV #CMDBUF,D	;PUT BLOCK INTO CMD BUF
	JSR PC,GETBLK
1$:	MOV #1,SMSLGT
	TST CCOUNT	;READ OR WRITE?
	BGT FLREAD	;READ FROM DISK
	BLT FLWRTE	;WRITE TO DISK
	HALT

FLWRTE:	INC WRTCNT	;ONE MORE WRITE REQUESTED
	NEG CCOUNT
	JSR PC,ACKO
	JSR PC,WRITE	;ACTUALLY DO THE WRITE
	BEQ LOSE		;DIDN'T WORK
	JSR PC,ACKO
	JMP RSTART
LOSE:	INC LOSCNT
	JSR PC,NAKO
	JMP RSTART	;GET NEXT COMMAND

FLREAD:	INC REDCNT	;ONE MORE READ REQUESTED
	JSR PC,ACKO	;ACK THE COMMAND
	JSR PC,READ	;READ THE BLOCK
	BEQ LOSE	
	JSR PC,ACKO
1$:	INC SNDCNT
	JSR PC,SENDB	;SEND THE BLOCK
	JSR PC,GWRD
	CMP #ACK,B
	BNE 1$
	JMP RSTART






GETBLK:	JSR PC,TYI	;GET A CHAR
	CMPB #'Q,A	;IS IT Q?
	BNE GETBLK	;NO, IGNORE
	MOV D,E		;COPY BLOCK POINTER
	JSR PC,GWRD	;GET COUNT
	MOV B,(E)+	;SAVE IN BUFFER
	MOV B,F		;THIS IS OUR COPY
	INC F		;FOR CHECKSUM
	CLR C		;CHECKSUM
WLOOP:	JSR PC,GWRD
	MOV B,(E)+
	ADD B,C
	SOB F,WLOOP	;GET ALL THE WORDS
	INC RCVCNT	;RECIEVED MAYBE GOOD BLOCK
	TST C		;CHECK SUM RIGHT?
	BEQ 1$		;YUP
	INC BADCNT
	JSR PC,NAKO	;SEND NAK
	BR GETBLK
1$:	CMP #RECEND,RECPNT
	BLOS 2$
	MOV A,-(P)
	MOV B,-(P)
	MOV RECPNT,A
	MOV #CMDBUF,B
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV A,RECPNT
	MOV (P)+,B
	MOV (P)+,A	
2$:	RTS PC

GWRD:	JSR PC,TYI
	MOV A,B
	JSR PC,TYI
	SWAB A
	BIC #377,A
	BIC #177400,B
	BIS A,B
	RTS PC

SENDB:	MOV #1,B
	JSR PC,SWRD
	MOV #CCOUNT,E
	CLR C		;FOR CHECKSUM
	MOV (E)+,B	;COUNT NOT IN CHECKSUM
	MOV B,D		;OUR COPY
	JSR PC,SWRD	;SEND COUNT
SLOOP:	MOV (E)+,B
	ADD B,C
	JSR PC,SWRD
	SOB D,SLOOP
	NEG C
	MOV C,B
	JSR PC,SWRD
	RTS PC

SWRD:	MOV B,A
	JSR PC,TYO
	SWAB A
	JMP TYO



TYI:	TSTB TKS
	BPL TYI
	MOVB TKB,A
	RTS PC

ACKO:	MOV #ACK,B
	BR SWRD

NAKO:	MOV #NAK,B
	BR SWRD

TYO:	TSTB TPS
	BPL TYO
	MOV A,TPB
	RTS PC

READ:	MOV #READS,IOROT
	BR DISK

WRITE:	MOV #WRITES,IOROT

DISK:	MOV #10.,RETRYC	;NUMBER OF TIMES TO TRY
	MOVB CUNIT+1,A
	BIC #177770,A
	ASH #3,A
	CMP A,UNIT	;SAME AS LAST UNIT?
	BEQ 1$		;YUP
	CLR F
	MOV A,UNIT	;NO
	JSR PC,SEEK	;CALIBRATE THE DRIVE
1$:	MOV A,UNIT
RETRY:	DEC RETRYC
	BGE 1$
	SEZ
	RTS PC
1$:	MOV #BUFFER,A	;PLACE TO XFER TO/FROM
	MOV CCOUNT,B	;NUMBER OF WORDS TO XFER
	MOV CBLOCK,C	;BLOCK NUMBER
.IF NDF LSIDBL
	ASL C		;CONVERT TO
	ASL C		;STARTING SECTOR #
9$:	MOV C,D		;COPY
	MOV C,E		;TWICE
	CLR F		;TRACK
;BELOW IS COPY OF DEC CODE. UGH!
	BR 3$
2$:	SUB #23.,D
3$:	INC F		;TRAKC ADDRESS
	SUB #26.,E	;FOR THE DIVIDE
	BPL 2$
	CMP #-14.,E	;SET C IF SECTOR MAPS TO 1-13
	ROL D		;PERFORM INTERLEAVE
4$:	SUB #26.,D	;GET INTO -1, -26. RANGE
	BPL 4$		;THIS IS A DIVIDE TO GET A REMANDER
	ADD #27.,D	;NOW IN 1-26 RANGE
.IFF
9$:	MOV C,D		;COPY
	MOV C,F		;TWICE
	ASR F
	ASR F
	ASR F
	ASR F
	INC F		
	BIC #177760,D
	MOVB DBLSTB(D),D
.ENDC
	JSR PC,@IOROT	;DO THE READ OR WRITE
	BEQ RETRY	;LOST ON THIS SECTOR, RETRY WHOLE THING
	INC C		;NEXT SECTOR
	TST B		;WORD COUNT DONE?
	BGT 9$		;NOPE
	CLZ
	RTS PC

DBLSTB:	.BYTE 1,5,9.,13.,2,6,10.,14.,3,7,11.,15.,4,8.,12.,16.


;F HAS TRACK ADDRESS, D HAS SECTOR, A HAS WORD POINTER, B HAS WORD COUNT, C SHOULD BE PRESERVED
READS:	JSR PC,SEEK
	BEQ READSE		;ERROR
	DCMD #SMSRED!SMSDTB	;READ INTO BUFFER
	CMD2 D
	JSR PC,GETST
	BEQ READSE
	DCMD #SMSRED!SMSBTH
	CMD2 A
	JSR PC,WAITD
.IF NDF LSIDBL
	MOV #64.,E
.IFF
	MOV #256.,E
.ENDC
1$:	MOVB SMSDBF,(A)+
	MOVB SMSDBF,(A)+
	DEC B
	SOB E,1$
	JSR PC,GETST
	BEQ READSE
	CLZ
	RTS PC

READSE:	MOV F,-(P)
	CLR F
	JSR PC,SEEK
	MOV (P)+,F
	SEZ
	RTS PC

SEEK:	DCMD #SMSSEK
	CMD2 F
	JMP GETST		;GET THE STATUS

;F HAS TRACK ADDRESS, D HAS SECTOR, A HAS WORD POINTER, B HAS WORD COUNT, C SHOULD BE PRESERVED
WRITES:	JSR PC,SEEK
	BEQ WRITEE
	DCMD #SMSWRT!SMSHTB
	CMD2 A
	JSR PC,WAITD
.IF NDF LSIDBL
	MOV #64.,E
.IFF
	MOV #256.,E
.ENDC
1$:	MOVB (A)+,SMSDBF
	MOVB (A)+,SMSDBF
	DEC B
	SOB E,1$
	JSR PC,GETST
	BEQ WRITEE
	DCMD #SMSWRT!SMSBTD
	CMD2 D
	JSR PC,GETST
	BEQ WRITEE
	CLZ
	RTS PC

WRITEE:	JMP READSE


WAITR:	BIT #SMSCMW,SMSCSR
	BEQ WAITR
	RTS PC

WAITD:	BIT #SMSXFW,SMSCSR
	BEQ WAITD
	RTS PC


GETST:	JSR PC,WAITD
	MOV SMSCSR,LSTCSR
	BPL 1$
	MOV SMSDBF,LSTDAT
	MOV LSTCSR,ERRCSR
	MOV LSTDAT,ERRDAT
	SEZ
	RTS PC

1$:	MOV SMSDBF,LSTDAT
	CLZ
	RTS PC

LSTCSR:	0
LSTDAT:	0
ERRCSR:	0
ERRDAT:	0

IOROT:	0
RETRYC:	0


PAT:PATCH:	.BLKW 100


LOSCNT:	0	;COUNT OF BAD DISK OPERATIONS
BADCNT:	0	;COUNT OF BAD BLOCKS RECIEVIED
SNDCNT:	0	;COUNT OF BLOCKS SENT
RCVCNT:	0	;COUNT OF BLOCKS RECIEVED
REDCNT:	0	;COUNT OF REQUESTED READS
WRTCNT:	0	;COUNT OF REQUESTED WRITES

UNIT:	0	;UNIT NUMBER TO USE

RECPNT:	RECBUF
RECBUF:	.BLKW 4000.
RECEND:	.BLKW 10	;TO ALLOW OVERFLOW

CMDBUF:		;BUFFER FOR COMMAND FROM THE 11/45
CWRDCN:	0	;LENGTH OF COMMAND
CBLOCK:	0	;BLOCK
CUNIT:	0	;UNIT NUMBER
IGNORE:	0	;THIS WORD IGNORED
CCOUNT:	0	;WORD COUNT FOR TRANSFER 
BUFFER:	1	;CHECKSUM WORD ON READ COMMAND, BUFFER START ON WRITE

		;THE LEFT OVER CORE IS THE BUFFER
.END START
