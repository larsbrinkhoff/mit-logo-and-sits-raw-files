	.TITLE SYMBOL HACK VERSION # 023
	.SBTTL CONSTANTS
	.NLIST TTM		;NOT TERMINAL MODE

	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7

	A=R1
	B=R2
	C=R3
	D=R4
	E=R5

	OUTCHN=0		;OUTPUT CHANNEL
	ERRWD=52		;RT11 ERROR CODE LOCATION

	PDS=40			;PUSH DOWN STACK SIZE

	.MCALL .REGDEF,..V2..,.READW,.WRITW,.CSIGEN,.PRINT,.CLOSE,.EXIT,.WAIT,.SETTOP
	..V2..
	.REGDEF

	.SBTTL STARTUP AND TERMINATION



START:	MOV #PDLTOP,SP
	MOV SP,A		;SAVE STACK SINCE .CSIGEN CAN SCREW IT.
	.CSIGEN PRGTOP,#DEFEXT,#0  ;READ STRING FROM TTY, OPEN CHANNELS 0 AND 3, 4, ...
	MOV A,SP
	MOV R0,SYMS		;SYMBOLS START AFTER HANDLERS
	.SETTOP #-2		;GET ALL MEMORY
	MOV R0,SYME
	CLR INBLK		;INITIALIZE INPUT AND OUTPUT ROUTINES.
	MOV #3,INCHAN
	CLR OUTBLK
	JSR PC,WRINI
	CLR INCNT
	CLR SECCNT		;SECTION COUNT
	MOV #MAP,MAPPT		;POINTER INTO THE MAP
	MOV #MAP,NULCPT		;POINTER TO NULL CSECTS
	.WAIT INCHAN		;IS THERE A MAP FILE?
	BCC 1$
	JSR PC,NOMAP		;SET UP NULL MAP
	BR EOF			;AND DO A REAL FILE
1$:	JMP DOMAP		;PROCESS THE MAP FILE

EOF:	MOV #PDLTOP,SP
	.CLOSE INCHAN		;CLOSE THE PROCESSED FILE
	INC INCHAN		;NEXT FILE
EOFX:	.WAIT INCHAN		;SEE IF OPEN
	BCS OUTSY		;DONE, FINISH THE OUTPUT
	CLR INCNT		;NO CHARS IN BUFFER
	CLR INBLK		;BLOCK ZERO
	MOV SYMS,SYMPT		;INIT SYMBOL TABLE
	JMP DOSYMS		;DO ANOTHER FILE

DEFEXT:	.RAD50 /LST/		;DEFAULT INPUT FILE EXTENSION.
	.RAD50 /SYM/		;DEFAULT OUTPUT FILE EXTENSION.
	0
	0

;COME HERE AFTER DETECTING END OF FILE.
OUTSY:	CMP OUTPTR,#OUTBUF	;IF THERE IS ANYTHING IN THE BUFFER,
	BEQ 1$
	JSR PC,WRBUF		;WRITE OUT THE LAST BLOCK.
1$:	.CLOSE #OUTCHN
	.EXIT

DEVHND:	.BLKW 10000		;FOR DEVICE HANDLERS IN CASE SOMEDAY THERE
				;MIGHT BE SOME THT AREN'T RESIDENT.

PAT:
PATCH:
	.REPT 100
	0
	.ENDR
	.SBTTL MAIN LOOP
;COME HERE IF THE FIRST LINE DOESN'T SAY "LINK" ON IT
NOTMAP:	JSR PC,NOMAP	;SET UP DUMMY MAP
	JMP EOFX	;RUN THAT FILE BY AGAIN

NOMAP:	MOV #MAP,A
	CLR (A)+	;A NULL CSECT
	CLR (A)+
	MOV #1000,(A)+	;STARTING AT 1000
	CLR (A)+
	MOV A,MAPPT
	RTS PC

;PROCESS THE MAP FILE
DOMAP:		;FIRST SEE IF THIS IS REALLY A LINK MAP OR A SYMBOL TABLE
.IRPC CH,<LINK>
	JSR PC,RDCH
	CMP A,#15
	BEQ NOTMAP
	CMP A,#''CH
	BNE DOMAP
.ENDR
FNDABS:
.IRPC CH,<. ABS.>	;IS THIS THE ABS SECTION?
	JSR PC,RDCH
	CMP A,#''CH
	BNE FNDABS
.ENDR
DOSEC:	JSR PC,IGNLIN	;SKIP THE ABSOLUTE SECTION INFO
	JSR PC,RDCH	;GET A CHARACTER
	CMP #11,A	;IS IT A TAB?
	BNE GOTSEC	;EITHER A NAMED SECTION OR THE END
	JSR PC,RDCH	;ANOTHER
	CMP #11,A	;ANOTHER TAB?
	BNE GOTBLK	;A BLANK CSECT
	BR DOSEC	;GET A NEW LINE

GOTSEC:	CMP #12,A	;IS IT A SECOND LF?
	BNE 1$		;NOPE
	JMP EOF		;END OF THE FILE
1$:	INC INCNT	;UNREAD THE CHARACTER
	DEC CHPT
	JSR PC,RDSQOZ
	MOV C,-(SP)	;SAVE THE FIRST 3 CHARS
	JSR PC,RDSQOZ	;NEXT 3
	MOV C,-(SP)
	JSR PC,RDCH	;SKIP THE TAB
GOTSE1:	JSR PC,RDOCT	;READ THE START ADDRESS OF THIS AREA
	MOV MAPPT,A
	MOV (SP)+,2(A)	;SECOND PART OF THE NAME
	MOV (SP)+,(A)	;FIRST PART
	MOV C,4(A)	;THE VALUE
	MOV SECCNT,6(A)	;THE SECTION NUMBER
	INC SECCNT
	ADD #10,MAPPT
	CMP #MAPE,MAPPT
	BLOS 1$
	JMP DOSEC	;GO TO THE NEXT SECTION
1$:	.PRINT #MAPOVF
	.EXIT
MAPOVF:	.ASCIZ /MAP OVERFLOW/
	.EVEN

GOTBLK:	CLR -(SP)	;NAME IS BLANK
	CLR -(SP)
	INC INCNT	;UNREAD THE CHARACTER
	DEC CHPT
	BR GOTSE1	;ENTER THE SECTION



;HERE ON DETERMINING THAT THIS PAGE IS NOT SYMBOL TABLE.
NXTPAG:	JSR PC,IGNPAG		;SKIP TO END OF IT

;PROCESS NEXT PAGE
DOSYMS:	JSR PC,IGNLIN		;SKIP THE LINE CONTAINING THE TITLE.
.IRPC CH,<SYMBOL TABLE>	;IS THIS PAGE A SYMBOL TABLE PAGE?
	JSR PC,RDCH
	CMP A,#''CH
	BNE NXTPAG
.ENDR
	JSR PC,IGNLIN		;YES.  SKIP REST OF SUBTITLE LINE.

;PROCESS NEXT SYMBOL.
DOSYM:	JSR PC,IGSPCR		;SKIP SPACES OR CRLF.
	CMP A,#14		;REACHED END OF PAGE => MUS SKIP TITLE.
	BEQ DOSYMS
	JSR PC,RDSQOZ		;READ 1ST 3 CHARS OF SYMBOL NAME.
	CMP C,ENDTST		;IF "SYMBOL NAME" STARTS WITH ". A",
	BNE DOSYM1		;THIS LINE IS REALLY ABOUT ASECT
	JMP GETSEC		;GET THE CSECT'S

ENDTST:	.RAD50 /. A/		;START OF . ABS.

DOSYM1:	MOV C,-(SP)
	JSR PC,RDSQOZ		;READ LAST 3 CHARS.
	MOV C,-(SP)
	CLR C			;COMPUTE THE FLAG WORD.
	JSR PC,RDCH		;THE CHAR AFTER THE SYMBOL IS "=" OR SPACE.
	CMP A,#'=
	BNE 1$
	BIS #1,C		;"=" MEANS DEFINED BY "=", SO HALF KILL.
1$:	JSR PC,RDCH		;THE NEXT CHAR IS EITHER "%" OR SPACE.
	CMP A,#'%
	BNE 2$
	BIS #2,C		;"%" MEANS THIS IS A REGISTER SYMBOL.
	BIC #1,C		;DON'T HALF KILL REGISTERS
2$:	MOV C,-(SP)
	JSR PC,RDOCT		;READ TH SYMBOL VALUE.
	CMP A,#'*		;WAS THERE REALLY A VALUE, OR WAS IT STARS?
	BEQ UNDEF		;SIX STARS AS VALUE MEANS UNDEFINED SYM.
				;IN THAT CASE, DON'T OUTPUT THE DEFINITION.
	CMP #160000,C		;KLUDGE, DON'T HALF-KILL DEVICE REGISTERS
	BHIS 9$
	BIC #1,(SP)
9$:	MOV C,-(SP)		;ELSE OUTPUT ALL 4 WORDS IN ORDER WE GOT THEM.
3$:	JSR PC,RDCH		;GET THE NEXT CHAR
	CMP #11,A		;TAB MEANS DONE
	BEQ 4$
	CMP #15,A
	BNE 6$			;SO DOES CR
	INC INCNT
	DEC CHPT		;BACK UP OVER THE CR
	BR 4$
6$:	CMP #'R,A		;RELOCATABLE?
	BNE 8$
	BIS #4,2(SP)		;SET THE BIT
8$:	CMP #'G,A		;GLOBAL?
	BEQ 3$			;I DON'T CARE
	CMP #'0,A		;ZERO?
	BEQ 5$
	CMP #'1,A		;1?
	BNE 3$
5$:	INC INCNT		;BACK UP
	DEC CHPT
	JSR PC,RDBOCT		;READ THE CSECT NUMBER
	MOVB C,3(SP)		;PUT IT INTO THE FLAG WORD
4$:	MOV SYMPT,C
	MOV 6(SP),(C)+
	MOV 4(SP),(C)+
	MOV 2(SP),(C)+
	MOV (SP)+,(C)+
	MOV C,SYMPT
	CMP C,SYME
	BLO UNDEF1
	.PRINT #SYMOVF
	.EXIT

UNDEF1:	ADD #6,SP		;WHETHER WE WROTE OR NOT, POP WHAT WE PUSHED.
	JMP DOSYM		;PROCESS ANOTHER SYMBOL.
UNDEF:	JSR PC,RDCH
	CMP #11,A
	BEQ UNDEF1
	CMP #15,A
	BNE UNDEF
	INC INCNT
	DEC CHPT
	BR UNDEF1
SYMOVF:	.ASCIZ /SYMBOL TABLE OVERFLOW/
	.EVEN

;COEM HERE TO GET THE CSECT NUMBERS AND THEREBY BE ABLE TO RESOLVE AND OUTPUT THE SYMBOL TABLE
GETSEC:	JSR PC,IGNLIN		;IGNORE THE . ABS. LINE
4$:	JSR PC,RDCH		;GET THE TAB BEFORE THE BLANK .CSECT
	CMP #11,A		;TAB?
	BEQ 1$			;YUP
	CMP #40,A		;SPACE?
	BEQ 4$
	.PRINT #3$
	.EXIT
3$:	.ASCIZ /NO NULL CSECT IN .LST FILE/
	.EVEN
1$:	JSR PC,RDOCT		;READ THE LENGTH OF THE BLANK CSECT
	TST C			;IF IT IS ZERO, THIS CSECT WILL NOT APPEAR IN THE MAP
	BEQ GETNCS
				;BUT FIX UP THE BLANK CSECT
	MOV NULCPT,A		;POINTER PAST LAST FOUND NULL CSECT
2$:	TST (A)			;NULL NAME?
	BEQ GOTNUL			;YUP, GOT ONE
	ADD #10,A
	CMP A,MAPPT
	BLO 2$
	.PRINT #NONUL
	.EXIT
NONUL:	.ASCIZ /MISSING NULL .CSECTS IN MAP/
	.EVEN

GOTNUL:	MOV 4(A),B		;THE OFFSET
	ADD #10,A		;PAST THIS ONE
	MOV A,NULCPT		;TO NEXT POSSIBLE NULL CSECT
	CLR C			;THE CSECT NUMBER (REALLY ONE, BUT MACRO DOESN'T PUT IT IN)
	JSR PC,RESOLV		;RESOLVE THOSE GUYS
GETNCS:	JSR PC,IGNLIN
	JSR PC,RDSQOZ		;GET THE SQUOZE
	MOV C,-(SP)
	JSR PC,RDSQOZ
	MOV C,-(SP)
	JSR PC,RDCH		;GET CHARACTER AFTER IT
	CMP #11,A		;SHOULD BE A TAB
	BNE OUTSYM		;DONE, OUTPUT SYMBOLS
1$:	JSR PC,RDCH		;READ PAST LENGTH OF CSECT
	CMP #40,A
	BNE 1$
	JSR PC,IGSPCR		;IGNORE SPACE
	JSR PC,RDBOCT		;READ A BYTE
	MOV #MAP,A		;POINTER TO THE MAP
2$:	CMP 2(SP),(A)
	BNE 3$
	CMP (SP),2(A)
	BEQ GOTNAM
3$:	ADD #10,A
	CMP A,MAPPT
	BLO 2$
	.PRINT #CANFND
	.EXIT
CANFND:	.ASCIZ /CAN'T FIND ONE OF THE NAMED CSECTS IN THE MAP/

GOTNAM:	CMP (SP)+,(SP)+		;FLUSH THE STACK
	MOV 4(A),B		;THE OFFSET
	JSR PC,RESOLV		;RESOLVE THE SYMBOLS IN THIS CSECT
	BR GETNCS

OUTSYM:	MOV SYMS,A
1$:	CMP A,SYMPT
	BNE 2$
	JMP EOF
2$:	BIT #4,4(A)
	BNE 3$
	MOV (A),C
	JSR PC,WRITE
	MOV 2(A),C
	JSR PC,WRITE
	MOVB 4(A),C
	JSR PC,WRITE
	MOV 6(A),C
	JSR PC,WRITE
3$:	ADD #10,A
	BR 1$

RESOLV:	MOV SYMS,A
1$:	CMP A,SYMPT
	BNE 2$
	RTS PC
2$:	CMPB C,5(A)	;RIGHT CSECT?
	BNE 3$		;NOPE
	BIT #4,4(A)	;RELOC?
	BEQ 3$		;NOPE
	BIC #4,4(A)
	ADD B,6(A)
3$:	ADD #10,A
	BR 1$

	.SBTTL READ NUMBER OR RADIX 50

;READ 6-DIGIT OCTAL NUMBER INTO C
;WE DO NOT CHECK THAT THE "DIGITS" ARE DIGITS.
;A SYMBOL TABLE PRINTOUT CAN ACTUALLY CONTAIN SIX ASTERISKS
;INSTEAD OF SIX DIGITS.  SINCE THE LAST "DIGIT" IS LEFT IN A, TH CALLER CAN CHECK.
RDOCT:	MOV #6,D
RDOCT2:	CLR C
RDOCT1:	JSR PC,RDCH
	ASL C
	ASL C
	ASL C
	ADD A,C
	SUB #'0,C
	DEC D
	BGT RDOCT1
	RTS PC

RDBOCT:	MOV #3,D
	BR RDOCT2

;READ 3 CHARS OF RADIX-50 INTO C
RDSQOZ:	MOV #3,D
	CLR C
RDSQO1:	MUL #50,C
	JSR PC,RDCH		;READ NEXT CHAR INTO A
RDSQO2:	JSR PC,SQCNV		;CONVERT TO SQUOZE IN A
	ADD A,C
	DEC D
	BGT RDSQO1		;DO IT 3 TIMES
	RTS PC

;CONVERT UPPER-CASE ASCII CHAR IN A TO RADIX 50 CHAR IN A
SQCNV:	CMP A,#40		;NOTE THERE ARE TRAILING SPACES!
	BEQ SQCNVS
	CMP A,#'.
	BEQ SQCNV.
	CMP A,#'$
	BEQ SQCNV$
	CMP A,#'0
	BLT SQCNVE
	CMP A,#'9
	BLE SQCNVD
	CMP A,#'A
	BLT SQCNVE
	CMP A,#'Z
	BLE SQCNVL
SQCNVE:	.PRINT #SQCNVM		;NON-RADIX-50 CHAR SEEN => ERROR MESSAGE
	.EXIT

SQCNVM:	.ASCIZ /ILLEGAL CHARACTER IN SYMBOL NAME?/
	.EVEN

SQCNV.:	MOV #34,A		;"." IS 34.
	RTS PC

SQCNV$:	MOV #33,A		;"$" IS 33 IN RADIX 50.
	RTS PC

SQCNVD:	SUB #'0-36,A		;HANDLE ALL DIGITS.  "0" IS 36, "1" IS 37, ETC
	RTS PC

SQCNVL:	SUB #'A-1,A		;HANDLE ALL LETTERS.  "A" IS 1, ETC.
	RTS PC

SQCNVS:	CLR A			;SPACE IN RADIX 50 IS ZERO.
	RTS PC
	.SBTTL SKIP LINE OR PAGE

;SKIP TO END OF LINE
IGNLIN:	JSR PC,RDCH
	CMP A,#12
	BNE IGNLIN
	RTS PC

;SKIP TO END OF PAGE
IGNPAG:	JSR PC,RDCH
	CMP A,#14
	BNE IGNPAG
	RTS PC

;SKIP SPACES, CRS AND LFS.
;WHEN WE COME TO SOME OTHER CHARACTER, WE UN-READ IT.
IGSPCR:	JSR PC,RDCH
	CMP A,#11
	BEQ IGSPCR
	CMP A,#40
	BEQ IGSPCR
	CMP A,#12
	BEQ IGSPCR
	CMP A,#15
	BEQ IGSPCR
	INC INCNT		;UN-READ THE NON-DELIMITER CHARACTER WE JUST FOUND.
	DEC CHPT
	RTS PC
	.SBTTL READ A CHARACTER

;READ NEXT INPUT CHARACTER INTO A
RDCH:	DEC INCNT
	BLT RDBUF
	MOVB @CHPT,A
	INC CHPT
	RTS PC

;RELOAD INPUT BUFFER FROM NEXT BLOCK OF FILE
RDBUF:	.READW #RDAREA,INCHAN,#INBUF,#400,INBLK
	BCS RDERR
	INC INBLK
	MOV #1000,INCNT
	MOV #INBUF,CHPT		;START READING FROM BEGINING
	BR RDCH

RDERR:	TSTB ERRWD		;INPUT ERROR => IS IT EOF ?
	BNE 1$
	JMP EOF			;YES => GO FINISH WRITING AND CLOSE
1$:	.PRINT #RDERMS		;ANY OTHER INPUT ERROR CAUSSES ERROR MESSAGE
	.EXIT
RDERMS:	.ASCIZ /READ ERROR ?/
	.EVEN

INCHAN:	0			;CURRENT INPUT CHANNEL
INBUF:	.BLKW 400		;BUFFER FOR READING LISTING
INCNT:	0			;BYTES YET AVAILABLE IN BUFFER
CHPT:	0			;POINTER INTO BUFFER
INBLK:	0			;NEXT BLOCK NUMBER IN FILE TO READ
RDAREA:	.BLKW 5			;ARG BLOCK FOR .READW

	.SBTTL WRITE ONE WORD

;WRITE THE WORD IN C TO OUTPUT FILE.
WRITE:	MOV C,@OUTPTR
	ADD #2,OUTPTR
	CMP OUTPTR,#OUTBFE	;IF THE BUFFER IS FULL, WRITE IT OUT.
	BEQ WRBUF
	RTS PC

;WRITE OUT THE OUTPUT BUFFER
WRBUF:	.WRITW #WRAREA,#OUTCHN,#OUTBUF,#400,OUTBLK
	BCS WRERR
	INC OUTBLK		;WROTE ONE BLOCK, SO ADVANCE POINTER IN FILE.

;INITIALIZE TH OUTPUT BUFFER
WRINI:	MOV A,-(SP)		;CLEAR IT OUT, IN CASE THIS IS THE LAST
	MOV #OUTBUF,A		;BLOCK AND WE DON'T FILL IT UP.
1$:	CLR (A)+
	CMP A,#OUTBFE
	BNE 1$
	MOV (SP)+,A
	MOV #OUTBUF,OUTPTR	;START STORING AT BEGINNING OF BUFFER.
	RTS PC

;HERE ON ERROR IN OUTPUT.
WRERR:	.PRINT #WRERMS
	.EXIT

WRERMS:	.ASCIZ /OUTPUT ERROR?/
	.EVEN

OUTBUF:	.BLKW 400		;OUTPUT BUFFER
OUTBFE:	0			;END OF OUTPUT BUFFER.
OUTPTR:	0			;POINTER FOR STORING INTO BUFFER.
OUTBLK:	0			;BLOCK NUMBER IN OUTPUT FILE.
WRAREA:	.BLKW 5			;ARG BLOCK FOR .WRITW SYSTEM CALL.

PDL:	.BLKW PDS		;STACK.
PDLTOP:	0
MAPPT:	0
SECCNT:	0
NULCPT:	0			;POINTER PAST LAST NULL CSECT
MAP:	.BLKW 100.*4		;GOOD FOR UP TO 100. SECTIONS
MAPE:
SYMPT:	0
BOTTOM:	.LIMIT			;THE BOTTOM AND TOP ADDRESSES
PRGTOP=.-2			;THE TOP ADDRESS
SYMS:	0			;WHERE THE SYMBOLS START
SYME:	0			;THE TOP ADDRESS GETS FILED IN HERE
.END START
