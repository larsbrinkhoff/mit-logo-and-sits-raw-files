.TITLE RUNOFF	C00-09
	.CSECT
.GLOBL RUNOFF
; THIS PROGRAM WAS TAKEN DIRECTLY FROM THE PDP-10 VERSION
; AUTHORED BY BOB CLEMENTS. BY AND LARGE, THE PDP-10 OP CODES
; WERE TRANSLATED INTO THEIR PDP-11 EQUIVALENT. THIS WILL
; MAKE IT EASY TO INCORPORATE NEW CHANGES AS THEY OCCUR.
;
; THE MAIN CHANGES WERE IN THE COMMAND STRING INTERPRETER
; PORTION AND WITH THE HANDLING OF I/O. GENERALLY, THE I/O
; SIMULATES HOW IT WORKS ON THE PDP-10.
;
;SET THE FOLLOWING SWITCH NON-ZERO TO ALLOW HYPHENATION INTERFACE
.IIF	NDF,HYP		HYP = 1
;
;SET THE FOLLOWING SWITCH NON-ZERO TO USE DOUBLE-BUFFERED OUTPUT
.IIF	NDF,DBLBUF	DBLBUF = 1

	.REPT 0

	---  CORE LAYOUT  ---
-----------
  STACK
-----------

  RUNOFF
  PROGRAM
  ITSELF
----------
  HYPHENATION
  ROUTINE

----------
  DEVICE HANDLERS
----------

  INDEX LIST
----------
  FOOTNOTES

----------

FOREGROUND, IF ANY
----------

RT-11

----------




	.ENDR

.SBTTL DEFINITIONS


	.MCALL ..V2.., .CSIGEN,.SETTOP,.CLOSE,.TTYIN,.PRINT,.TTYOUT
	.MCALL .READW, .WRITW, .WRITE, .WAIT, .QSET,.SRESET,.REGDEF
	.MCALL	.RCTRLO,.DATE
	..V2..
	.REGDEF


; SIMULATED ACCUMULATOR DEFINITIONS

F.1:	.WORD 0
B:	.WORD 0
D:	.WORD 0
X:	.WORD 0
C2:	.WORD 0
S1:	.WORD 0
S2:	.WORD 0
N1:	.WORD 0

;FLAGS IN LH OF F

JUSTF=1
PJUSTF=2
FILLF=4
FFDSW=10
FOOTFG=20		;ON IF PROCESSING FROM FOOTNOTE STRING
IDXCF=40		;USED TO KEEP CASES REMEMBERED IN INDEX
GCINF=100		;ON IF CHARS IN GCINP TO READ
PAUSF=200
TJUSTF=400
ULBSF=1000		;ON IF UNDERLINING WITH BACKSPACE (ASCII)
ULMSW=2000		;ON IF UNDERLINE SHIFT-LOCKED ON
NUMBF=4000
SIGNF=10000
ULMODE=20000
ULSUPF=40000		;ON IF USER HAS SUPPRESSED UNDERLINING DUE TO
			;SOME LOSING KIND OF PRINTER
EXSP3=100000		; * * MUST BE BIT 15
;IMPURE STORAGE

IDXRF:	.BYTE	0	;INDEXING REPEATED ITEM FLAG
FSUBPG:	.BYTE	0	;SUBPAGE MODE
ULNEXT:	.BYTE	0	;UNDERLINES ON NEXT LINE
ULCHAR:	.BYTE	0	;CHARACTER TO USE (DEFAULT C.LPUS)
	.EVEN

RMARG:	.WORD 0
PRMRG:	.WORD 0
CENTC:	.WORD 0
LMARG:	.WORD 0
CAS:	.WORD 0
PAGENO:	.WORD 0
PARIND:	.WORD 0
NSPNG:	.WORD 0
LINEC:	.WORD 0
SUBPGE:	.WORD 0
YEAR:	.WORD	0	;YEAR - 1900.
MONPTR:	.WORD	0	;POINTER TO TABLE OF MONTH NAMES
DAY:	.WORD	0	;DAY OF MONTH


TABTL=	32.*2
TABTAB:	.WORD 0
	.BLKB	TABTL
NTABS:	.WORD 0

NLPG:	.WORD 0
PNLPG:	.WORD 0

; GLOBAL VARIABLES


FOOTBF:	.WORD 0
FOOTC:	.WORD 0
FOOTP1:	.WORD 0
FOOTP2:	.WORD 0
FOOTP3:	.WORD 0
FOOTP4:	.WORD 0

FOOTWB:	.WORD 0
	.BLKB	300.
FTBUFE:
FOOTS1:	.WORD 0
FOOTS2:	.WORD 0

ICBUF:	.WORD 0
	.BLKB	50.
ICBFE:
XFIRST:	.WORD 0
XTOP:	.WORD 0
XBOT:	.WORD 0
OIXC:	.WORD 0
OIXL:	.WORD 0

EMTBLK:	.BLKW	6		;BLOCK TO BUILD EMT CALLS IN
INDCT:	.WORD	0
IBFPTR:	.WORD	0		;INPUT BUFFER POINTER
IBFCTR:	.WORD	0		;INPUT BUFFER COUNTER
OBFPTR:	.WORD	0		;OUTPUT BUFFER POINTER
OBFCTR:	.WORD	0		;OUTPUT BUFFER COUNTER
ICHAN:	.BYTE	0		;THE INPUT CHANNEL #
OCHAN:	.BYTE	0		;THE OUTPUT CHANNEL #

	IBFSIZ=	512.		;SIZE OF INPUT BUFFER
	OBFSIZ=	512.		;SIZE OF OUTPUT BUFFER


; GENERAL


.IF	NE,DBLBUF
IOQUE:	.BLKW	7*2	;2 ELEMENTS FOR QUEUE, 7 WORDS EACH
	.ENDC

T1:	.WORD 0
T2:	.WORD 0
T5:	.WORD 0
T6:	.WORD 0

LCH:	.WORD 0
PSTRP:	.WORD 0,0
N.CNT:	.WORD 0
JOBREL:	.WORD 0		;HIGHEST FREE LOCATION
JOBFF:	.WORD 0		;LOWEST FREE LOCATION
LOWPAG:	.WORD 0			;LOWEST PAGE TO PRINT
HGHPAG:	.WORD 0			;HIGHEST PAGE TO PRINT
; THESE VALUES SET AT INITIALIZATION TIME OR WITH THE /LIMIT:LOW:HIGH
; SWITCH IN THE COMMAND

HWPLN:	.WORD	66.	;HARDWARE PAGE LENGTH
; INITIALIZED TO 66., OR SET WITH /FORM!LENGTH SWITCH

INEOFP:	.WORD EOFDAT-1

.IF	NE,HYP
	.GLOBL MQ,MUL	
;RESERVE TEMPORARY STORAGE FOR FPP MULTIPLY/DIVIDE
MQ:	.WORD 0		;SOURCE
MUL:	.WORD 0		;DESTINATION
	.ENDC

LIMIT:	.LIMIT		;ADDRESS OF LINKED PROGRAM
DEFEXT:	.RAD50 /RNO/
	.RAD50 /DOC/
	.WORD	0,0
OUTBLK:	0		;BLOCK #'S
INBLK:	0
.IIF	NE,HYP	HYPH:	0	;HYPHENATE SWITCH

IN.BUF:	.BLKB	IBFSIZ		;THE INPUT BUFFER
OU.BF1:	.BLKB	OBFSIZ		;THE FIRST OUTPUT BUFFER


.IF	NE,DBLBUF
OU.BF2:	.BLKB	OBFSIZ		;THE SECOND OUTPUT BUFFER
OB:	.WORD	OU.BF1
	.WORD	OU.BF2
OBFSWT:	.WORD	0		;THE OUTPUT BUFFER SWITCHER SWITCH
.ENDC


; LINE TEMPS
LINBK:	.WORD 0
SPCNT:	.WORD 0
LSTSP:	.WORD 0
LINNSC:	.WORD 0

LNIN1:	.WORD 0
LNIN2:	.WORD 0
LOUT1:	.WORD 0
LOUT2:	.WORD 0

LINBF:	.WORD 0
	.BLKB	132.		;*****
LINBFE:
GCINP:	.WORD 0
GCIN2:	.WORD 0
GCSCH:	.WORD 0

CMSTP:	.WORD 0
CMST2:	.WORD 0

CMBF:	.WORD 0
	.BLKB	80.		;****

TTLP1:	.WORD 0
TTLP2:	.WORD 0
TTLBUF:	.WORD 0
	.BLKB	50.		;****
TTLBFE:
STTLP1:	.WORD 0
STTLP2:	.WORD 0
STTLBF:	.WORD 0
	.BLKB	50.		;****
STLBFE:

EXSP1:	.WORD 0
EXSP2:	.WORD 0
ULMCH:	.WORD 0

NSPCH:	.WORD 0
LSTNSP:	.WORD 0
ULPOS:	.WORD 0
CPOS:	.WORD 0
ULPT1:	.WORD 0
ULPBF:	.WORD 0
	.BLKB	250.		;****
;END OF VARIABLES
;PARAMETERS

SHUP='^			;UPPER CASE INDICATOR
SHDN='\			;LOWER CASE INDICATOR
CWARN='_		;QUOTE NEXT CHARACTER
ULCHI='&		;UNDERLINE COMMAND IN INPUT DATA
ULCHS=32		;UNDERLINE CHARACTER IN INTERNAL STORAGE
			; MUST BE .LT. C.QTS
QTSP='#			;QUOTED (NONEXPANDABLE) SPACE IN INPUT FILE

IRMRG=60.		;INITIAL RIGHT MARGIN
ILMRG=0			;INITIAL LEFT MARGIN
INLPG=60.		;INITIAL LENGTH OF PAGE

;CHARACTERS FOR CREF

C.CR=15
C.LF=12
C.SPC=40
C.FF=14
C.TAB=11
C.CMA=',
C.BS=10			;BACKSPACE CHARACTER
C.NXS=177		;NON-EXPANDABLE SPACE (INTERNAL)
C.QTS=37		;QUOTED SPACE. MUST BE C.SPC-1 FOR COMPARES
C.PD='.			;PERIOD. FOR SPECIAL SPACING AFTER PERIOD
C.EOF='Z-100		;END OF FILE
C.EFNT='!		;END OF FOOTNOTE
C.LPUS=	'_		;LINE-PRINTER UNDERSCORE IN OUTPUT FILE
C.MINS=	'-		;MINUS SIGN FOR NEXT-LINE UNDERSCORE
C.SEMI=73		;SEMICOLON

.SBTTL INPUT SECTION

;INPUT LINE

LINNS:	JSR R5, WLNIN1		;WRITE CHAR IN LINE BUFFER
	MOV	R1, LCH		;STORE AS LAST CHARACTER
	INC LINNSC		;COUNT NON-SPACING CHARACTERS
LIN1:	JSR R5, GCIN		;READ CHARACTER WITH PRE-TRANSLATE
	CMP	R1, #C.TAB		;TAB?
	BNE	2$		;NOT A TAB
	JMP	LTAB		;TABS ARE TABS
2$:	CMP	R1, #C.CR		;CRR RET?
	BNE 3$
	JMP LCR			;YES. GO LOOK FOR LF
3$:	CMP	R1, #C.QTS		;SOME OTHER CONTROL CHARACTER?
	BLT LINNS		;YES. TREAT AS NON-SPACING
	CMP	R1, #C.NXS		;NON EXPANDABLE SPACE?
	BEQ 4$
	CMP	R1, #C.SPC		;OR REGULAR SPACE?
	BNE	LIN3
4$:	JMP	LSPAC		;GO HANDLE SPACING
LIN3:	JSR R5, WLNIN1		;WRITE CHAR IN INPUT BUFFER
	MOV	R1, LCH		;SAVE AS LAST CHARACTER
	DEC LINBK		;TIME TO BREAK LINE YET?
	BGE LIN1		;NO. LOOP FOR MORE
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	5$		;NO
	BIT	#JUSTF, F.1	;ANY JUSTIFICATION?
	BEQ	5$		;NO,  SO CAN'T HYPHENATE
	JSR	PC, FINLN	;GO FINISH HYPHENATED LINE
	.ENDC
5$:	JSR R5, OUTLJ		;YES. OUTPUT LINE, JUSTIFIED IF FLAGS
				; SAY SO,  AND SET FOR NEXT LINE
	BR	LIN1		;PROCESS NEXT LINE.
.IF	NE,HYP
;DO THE TERMINATION FOR HYPHENATING
;
FINLN:	MOV	#LNIN1, R4
	MOV	2(R4), R4
	MOV	R4, TEMP		;REMEMBER END OF LINE
FIN10:	JSR	R5, GCIN		;GET A CHARACTER
	CMP	R1, #'A		;IT MUST
	BLT	FINEX		;BE
	CMP	R1, #'Z		;ONLY
	BLE	FIN01		;ALPHABETIC
	CMP	R1, #'A+40
	BLT	FINEX
	CMP	R1, #'Z+40
	BGT	FINEX
FIN01:	JSR	R5, WLNIN1	;PUT CHARACTER IN BUFFER
	MOV	R1, LCH
	BR	FIN10
FINEX:	MOV	R0,-(SP)	;SAVE ALL USED REGISTERS
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	#LNIN1,R0	;STORE
	MOV	2(R0),R0	;A ZERO
	INC	R0		;TEMPORARILY AT THE
	CLRB	@R0		;END OF THE BUFFER
	MOV	LSTSP,R0	;GET ADDRESS
	CMPB	(R0)+,(R0)+	;OF LAST WORD
	.GLOBL	HYPHEN,HYPEDF
	CLR	HYPEDF
	JSR	PC,HYPHEN	;TRY TO HYPHENATE THE WORD
	MOV	LSTSP,R1	;ADDRESS OF LAST SPACE
	MOV	TEMP,R0		;ADDRESS OF REAL END OF LINE
FIN02:	TSTB	-(R0)		;IS THIS A PLACE TO INSERT A HYPHEN?
	BMI	FIN03		;YES
	CMP	R0,R1		;NO, SHOULD I LOOK FARTHER?
	BHI	FIN02		;YES
	CLR	R1		;CLEAR MASK
	BR	FIN05
FIN04A:	BISB	R1,@LSTSP	;RESET THE DESIRED ONE ONLY
FIN04:	MOV	(SP)+,R3	;NO, RESTORE AND RETURN
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	JSR	R5,WLNIN1	;SAVE LEFT OVER CHAR.
	RTS	PC
FIN03:	DEC	R0
	MOV	R0,LSTSP	;SET POINTER TO FAKE SPACE
	INC	SPCNT		;COUNT THE FAKE SPACE
	MOV	R1,R0		;GET START OF WORD
	MOV	#200,R1		;SET BIT MASK
FIN05:	TSTB	(R0)+
	BEQ	FIN04A
	BPL	FIN05
	BICB	#200,-1(R0)	;WIPE OUT ALL OTHER HYPHENATIONS
	BR	FIN05
TEMP:	0
	.ENDC
;SUBROUTINE TO INITIALIZE COUNTS AND POINTERS FOR A NEW LINE

LINSET:	MOV RMARG,R2		;COMPUTE REAL WIDTH OF LINE
	SUB LMARG,R2		;AS DIFFERENCE OF MARGINS
	SUB INDCT,R2		;MINUS INDENTING
	MOV R2, LINBK		;STORE IN LINE-BREAK COUNT
	MOV #-1,SPCNT		;INITIAL COUNTS OF SPACING
	CLR NSPCH		; AND NON-SPACING CHARS
	CLR CPOS		;CARRIAGE POSITION IS FAR LEFT
	CLR LINNSC		;NO NON-SPACING CHARACTERS
	MOV #ULPBF,ULPOS	;UNDERLINE POSITION BUFFER AT START
	MOV LNIN1,LNIN2		;CLEAR LINE INPUT BUFFER BY MOVING 
				; END POINTER BACK TO START
	MOV LNIN1,LSTSP		;SET LAST SPACING CHARACTER BACK HERE
	DEC LSTSP		;MINUS ONE, SO OFF START OF BUFFER
	RTS R5			;RETURN FROM LINSET

;SPECIAL CHARACTERS DURING LINE INPUT

LTAB:	MOV LNIN2,R2		;DETERMINE PRESENT POSITION
	SUB LNIN1,R2
	SUB LINNSC,R2
	ADD LMARG,R2
	ADD INDCT,R2
	JSR R5,TAB		;FIND WHERE NEXT TAB STOP IS
	CMP R2, LINBK		;WOULD THAT MANY EQUAL OR EXCEED LINE SIZE?
	BGE LSPAC		;YES. TREAT AS SPACE, NOT TAB
	MOV R2, X			;NO. NEGATE NUMBER OF SPACES
	NEG X
	ADD X,LINBK		;AND DECREMENT LINBK COUNT BY THAT AMOUNT
	MOV #C.QTS, R1		;PUT N QUOTED SPACES IN BUFFER
..008:	JSR R5,WLNIN1		; ..
	INC X			; ..
	BLT	..008
..011:	JMP	LIN1
;HERE ON SPACE IN INPUT FILE, OR ON NON-EXPANDABLE SPACE. ALSO HERE ON
;TAB WHICH COULDN'T BE SATISFIED SO IS MADE A SPACE
;NOT HERE ON QUOTED SPACES.

LSPAC:	BIT #FILLF,F.1		;FILLING INPUT BEYOND BREAKS?
	BEQ LSPC1		;NO. SIMPLER PROCESSING
	MOV LNIN2,R2		;FILTER OUT LEADING SPACES
	DEC R2			;GET START OF BUFFER MINUS ONE
	CMP R2, LSTSP		;IS THAT WHERE LAST SPACE IS?
	BLOS	..011		;YES. JUST IGNORE THIS SPACE
	MOV LCH,R1		;GET PREVIOUS CHARACTER. WHAT WAS IT?
	CMP R1, #C.SPC		;A SPACE?
	BEQ ..011
	CMP R1, #C.NXS		;OR NON-EXPANDABLE SPACE?
	BEQ	..011		;YES. FILTER MULTIPLE SPACES
	CMP R1, #C.PD		;PERIOD FOLLOWED BY SPACE?
	BNE LSPC1
	TST LINBK		;YES. ANY MORE ROOM LEFT?
	BLOS LSPC1		;NO. JUST STORE THE SPACE
	MOV LNIN2,LSTSP		;YES. FORCE DOUBLE SPACE ON OUTPUT FILE
				;SAVE POINTER AT LAST (THIS) SPACE.
	MOV LINNSC,LSTNSP	;POSITION OF LAST NON-SPACING CHARACTER
				;SAVE AS LST ...
	INC SPCNT		;COUNT SPACING CHARACTER
	MOV #C.SPC,R1		;WRITE THIS SPACE INTO BUFFER
	JSR R5,WLNIN1		; ..
	DEC LINBK		;AND COUNT FOLLOWING CHARACTER
	MOV #C.NXS,R1		;NON-EXPANDABLE SPACE
	BR	..013		; TO BUFFER. THUS 2 IF ANY AT ALL AFTER PD

LSPC1:	MOV LNIN2,LSTSP		;HERE TO STORE AND COUNT A SPACE
				;SAVE POSITION OF THIS SPACE
	MOV LINNSC,LSTNSP	;AND NON-SPACING CHAR POSN
				; ..
	INC SPCNT		;COUNT THIS SPACE
	MOV #C.SPC,R1		;SPACE CHARACTER (EXPANDABLE)
..013:	JMP LIN3		; ..
;HERE ON CARRIAGE RETURN ON INPUT FILE. ASSUMES LF FOLLOWS

ENDBCM:	JSR	R5, LINSET	;SET FOR NEW LINE (BREAK COMMAND)
LCR:	JSR R5,GCIN		;GET FILE CHARACTER
	CMPB	R1,#C.LF		;IS IT LINEFEED?
	BEQ	LGO		;YES
	CMPB	R1,#C.SEMI	;IS IT SEMICOLON?
	BNE LCR			;SHOULD HAVE BEEN. THROW THIS AWAY.

;ENTER HERE AFTER INITIALIZATION.

LGO:	JSR R5,CCIN		;READ INITIAL CHARACTER ON LINE
	CMP	R1,#C.EOF		;END OF FILE?
	BNE ..016
	JMP ENDFIL		;YES. GO WRAP UP.

..016:	CMP	R1,#C.CR		;ANOTHER BLANK LINE?
	BEQ LCR			;YES. GO DISCARD
	CMP	R1,#C.EFNT		;END OF FOOTNOTE?
	BNE ..018
	BIT	#FOOTFG, F.1	;ARE WE IN THE MIDDLE OF A FOOTNOTE?
	BEQ	COMENT		;IT'S A COMMENT
	JMP FOOTND		;YES. GO FINISH FOOTNOTE PROCESSING

..018:	CMP	R1,#C.FF		;FORMFEED ON INPUT?
	BEQ LGO			;YES. IGNORE IT.
	CMP	R1,#C.PD		;PERIOD AS FIRST CHAR?
	BEQ CMN			;YES. GO READ COMMAND LINE
	MOV	R1,GCSCH		;NONE OF ABOVE SPECIAL CASES. SAVE.
	BIT #FILLF,F.1		;FILLING FROM INPUT FILE?
	BNE LSPAC		;YES. TREAT AS IF A SPACE WERE INPUT
	JSR R5,OUTLIN		;NO. OUTPUT THIS LINE
	JMP	LIN1		;AND START ANOTHER.

COMENT:	JSR	R5,CCIN		;FLUSH REST OF INPUT LINE
	CMPB	R1,#C.CR
	BNE	COMENT		; UNTIL A CR COMES ALONG
	BR	LCR
.SBTTL COMMAND SCANNER
;READ AND DISPATCH ON COMMAND
CMN:	MOV #CMBF, R4		;INITIALIZE POINTER TO HOLD USER COMMAND
	JSR R5,CSP		; ..
	MOV R2,CMSTP		; ..
	MOV R2,CMST2		; ..
	MOV	SP,PEEK.F	; FOR PEEKING
	JSR R5,CMCIN		;READ FIRST CHARACTER AFTER DOT
	CMPB R1,#C.CR		;BLANK COMMAND?
	BNE	1$		; NO
2$:	JMP	BREAK		; YES- BREAK THEN

1$:	CMPB	R1,#C.SEMI	; SEMI-COLON?
	BEQ	2$		; YES- SAME AS <CR> HERE
	MOV #<ECTAB-CMTAB>/4,N.CNT	;GET LENGTH OF COMMAND TABLE
				;ACCOUNT FOR 4 BYTES PER ENTRY
	MOV #CMSTP, R4		;STORE FIRST CHARACTER OF COMMAND
	CLR R3
	JSR R5,WCI		; ..
CM2:	MOV CMTAB+2(R3),S2		;PREPARE TO READ DEFINED COMMAND
	MOV CMSTP,R2		;PREPARE POINTER TO READ USER'S COMMAND
	MOV CMST2,B		; ..
	MOV R2,T1		; ..
	MOV B,T2		;FROM TEMPORARY POINTER
CM6:	MOVB @S2,X		;GET CHARACTER OF DEFINED COMMAND
	BEQ CM7
	INC S2
				;MATCHED TO END IF NULL
CM4:	MOV #T1, R4		;GET USER'S COMMAND CHARACTER
	JSR R5,GCI		; ..
	  BR	CM5		;NEED MORE FROM FILE
	CMPB R1,X		;MATCH?
	BEQ CM6			;YES. GO READ SOME MORE
CM8:	CMP (R3)+,(R3)+			;NO. TRY NEXT COMMAND.
	DEC N.CNT
	BGT CM2
	BR	ILCM1		;NO MORE TO TRY. ERROR.

CM5:	MOV	SP,(PC)+	; FLAG PEEK
PEEK.F:	.WORD	0		; NON-ZERO FOR PEEK AT CHAR
	JSR R5,CMCIN		;READ USER'S COMMAND FROM FILE
	CMPB	R1,#C.CR	;END OF LINE?
	BEQ CM8			;YES. NO SUCH COMMAND
	CMPB	R1,#C.SEMI	; OR A SEMI?
	BEQ	CM8		; YES
	MOV #CMSTP, R4		;NO. STORE CHARACTER IN BUFFER
	JSR R5,WCI		; ..
	MOV CMST2,T2		;AND UPDATE TEMPORARY POINTER
				; ..
	BR CM4			;GO CHECK NEW CHARACTER

CM7:	JMP @CMTAB(R3)		;HERE ON MATCH. GET COMMAND ADDRESS
				;AND DISPATCH TO COMMAND CODE
;SUBROUTINES FOR COMMAND SCANNER

CMCIN:	JSR R5,CCIN		;READ FROM INPUT FILE
	CMP	R1,#172		;CHECK FOR LOWER CASE LETTERS
	BGT ..025
	CMP	R1,#140
	BMI	..025		;NO. RETURN CHARACTER
	BIC #40,R1		;YES. MAKE UPPER CASE FOR COMMAND ROUTINE
..025:	RTS R5			; AND RETURN UC EQUIVALENT

;ILLEGAL COMMAND ROUTINE

ILCM2:	MOV #CMSTP,R4		;ADD BAD CHARACTER TO BUFFER
	JSR R5,WCI		; ..
ILCM1:	JSR R5,CCIN		;NOW ADD REST OF LINE
	CMP	R1,#C.CR		;END OF LINE YET?
	BNE ILCM2		;NO. LOOP.
ILCM:	.PRINT	#ILCMM		;TYPEOUT ILLEGAL COMAND MESSAGE
ILCM3:	MOV #CMSTP,R4		;READ OUT COMMAND BUFFER
	JSR R5,GCI		; TO TELETYPE
	  BR ILCM5		;END OF LINE
	MOV	R1, R0		;TYPE CHARACTER
	.TTYOUT
	BR ILCM3		;LOOP FOR WHOLE LINE

ILCM5:	JSR R5,ONPAG		;TELL HIM WHAT PAGE ITS ON
	JMP LCR			;GO DISCARD THE REST OF COMMAND LINE

ONPAG:	.PRINT	#ILCMM2
	MOV PAGENO, R3
	JSR R5,DECTYO		;OUTPUT PAGE NUMBER
	.PRINT	#CRLFM
	RTS R5

;GENERALIZED COMMAND GENERATOR MACRO
;
	.MACRO	CM	NAME,COMMD
	.CSECT	STRING
	$$$ = .
	.ASCIZ	/NAME/
	.CSECT
	.WORD	COMMD,$$$
	.ENDM
;
;	COMMAND DISPATCH TABLE IS FORMATED AS FOLLOWS:
;
;	WORD 1	ADDRESS OF ROUTINE TO HANDLE THE COMMAND
;	WORD 2	ADDRESS OF ASCIZ OF THE COMMAND
;
;	NOTE THAT THE COMMAND SCANNER REQUIRES THAT ANY COMMAND
;	WHICH IS A SUBSTRING OF ANOTHER COMMAND MUST FOLLOW IT
;	IN THE LOOKUP TABLE.
;
CMTAB:
CM	<;>,LCR
CM	<X>,INDEX
CM	<FG>,FIGUR
CM	<FN>,FOOTN
CM	<LC>,LWCAS
CM	<LM>,SETLM
CM	<ND>,NDATE
CM	<NF>,FILOF
CM	<NJ>,JUSOF
CM	<NM>,NUMON
CM	<PG>,CPAGE
CM	<PS>,SETPG
CM	<PX>,PINDX
CM	<RM>,SETRM
CM	<ST>,SETSTL
CM	<TP>,TSTPG
CM	<TS>,SETTAB
CM	<UC>,UPCAS
CM	<NNM>,NUMOF
CM	<DATE>,SDATE
CM	<D>,SDATE
CM	<FILL>,FILLN
CM	<PAGE>,CPAGE
CM	<SKIP>,SKIPL
CM	<BLANK>,LINSKP
CM	<BREAK>,BREAK
CM	<BR>,BREAK
CM	<B>,LINSKP
CM	<NODATE>,NDATE
CM	<INDEX>,INDEX
CM	<TITLE>,SETTL
CM	<CENTER>,CENTER
CM	<C>,CENTER
CM	<FIGURE>,FIGUR
CM	<INDENT>,INDENT
CM	<I>,INDENT
CM	<NOFILL>,FILOF
CM	<NUMBER>,NUMON
CM	<JUSTIFY>,JUSTN
CM	<J>,JUSTN
CM	<SPACING>,SSP
CM	<SP>,SSP
CM	<SUBPAGE>,SPAGE
CM	<FOOTNOTE>,FOOTN
CM	<F>,FILLN
CM	<NONUMBER>,NUMOF
CM	<SUBTITLE>,SETSTL
CM	<S>,SKIPL
CM	<NOJUSTIFY>,JUSOF
CM	<PARAGRAPH>,PARAG
CM	<TAB STOPS>,SETTAB
CM	<TEST PAGE>,TSTPG
CM	<T>,SETTL
CM	<LOWER CASE>,LWCAS
CM	<PAPER SIZE>,SETPG
CM	<UPPER CASE>,UPCAS
CM	<END SUBPAGE>,CPAGE
CM	<LEFT MARGIN>,SETLM
CM	<PRINT INDEX>,PINDX
CM	<P>,PARAG
CM	<RIGHT MARGIN>,SETRM
ECTAB:
;READ SIGNED DECIMAL NUMBER FOR COMMAND DECODER
;NON-SKIP RETURN IF NONE FOUND
RCNO:	CLR R3			;CLEAR ANSWER AC
RCX:	BIC #SIGNF,F.1		;AND SIGN FLAG
RCN1:	JSR R5,CCIN		;READ CHARACTER FROM COMMAND LINE
	CMP	R1,#C.CR		;LEADING CARRIAGE RETURN?
	BEQ RCN5		;YES. NON-SKIP RETURN
	CMPB	R1,#C.SEMI	; OR A SEMI?
	BEQ	RCN5		; SEMI AS GOOD AS CR HERE
1$:
	CMP	R1,#C.CMA		;COMMA SEPARATING ARGS?
	BEQ RCN1		;YES DISCARD
	CMP	R1,#C.SPC		;SPACES AND TABS?
	BEQ RCN1
	CMP	R1,#C.TAB		; ..
	BEQ RCN1			;YES.  SKIP THEM
	CMP	R1,#'-		; ..
	BNE RCN2		;NO
	BIS #SIGNF,F.1		;SET SIGN NEGATIVE
	BR	RCN1

RCN3:	JSR R5,CCIN		;READ ANOTHER CHARACTER
RCN2:	CMP	R1,#'9		;THIS CHAR A DIGIT?
	BGT RCN4
	CMP	R1,#'0		; ..
	BLT RCN4		;NO.  STOP HERE.
	BIC	#^C<17>, R1
	MOV	R3,	-(SP)
	ASL	R3		;MULTIPLY BY 10.
	ASL	R3
	ADD	(SP)+,	R3
	ASL	R3
	ADD	R1,	R3
	BR	RCN3		;AND LOOP FOR MORE.

RCN4:	BIT #SIGNF,F.1		;IF SIGN NEGATIVE?
	BEQ ..035
	NEG	R3		;NEGATE NUMBER
..035:	CMP	(R5)+, (R5)+	;NUMBER FOUND.  SKIP RETURN
RCN5:	MOV	R1,GCSCH		;STORE BREAK CHARACTER
	RTS R5			;AND RETURN FROM RCNO
.SBTTL OUTPUT SECTION
;LINE OUTPUT ROUTINE. THREE ENTRY POINTS

OUTNJ:	MOV LNIN2, R2		;HERE TO OUTPUT CURRENT LINE, NOT JUSTIFIED
	JSR R5,OUTNJ2		;CLEAR TJUSTF, CALL BODY OF ROUTINE
	BIC #EXSP3,F.1		;CLEAR LEFT/RIGHT SPACING FLAG
..041:	RTS R5			;AND RETURN.

OUTLJ:	MOV LSTSP, R2		;END OF LINE IS LAST SPACE, IF ANY
	CMP R2,LNIN1		;..
	BHI ..036
OUTLIN:	MOV LNIN2, R2		;ELSE END OF INPUT LINE
..036:	BIS #TJUSTF,F.1		;COPY JUSTF TO TJUSTF
	BIT #JUSTF,F.1
	BNE ..037
OUTNJ2:	BIC #TJUSTF,F.1		; ..
..037:	MOV R2,LOUT2		;SAVE END OF LINE TO CONSIDER
	MOV LNIN1,B		;AND BEGINNING.
	MOV B,LOUT1		; ..
	CMP R2,LOUT1		;LINE EMPTY?
	BLOS	..041		;YES. NO OUTPUT
..038:	BIT #TJUSTF,F.1		;JUSTIFYING THIS LINE?
	BNE ..039
	JMP OUTNJ1		;NO
..039:	TST SPCNT		;YES, ANY SPACES IN LINE?
	BLE JUSERR		;NO. CAN'T JUSTIFY IT THEN.
	MOV RMARG, R2		;YES. COMPUTE WHERE TO EXPAND THEM
	SUB LMARG, R2		;SIZE OF LINE
	SUB INDCT, R2		; ..
	ADD LOUT1, R2		;SUBTRACT SIZE OF DATA
	SUB LOUT2, R2		;..
	ADD LSTNSP, R2		;COMPENSATE FOR NON-SPACING CHARACTERS
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	..040		;NO
	BITB	#200,@LSTSP	;DO WE ACCOUNT FOR A HYPHEN?
	BEQ	..040		;NO
	DEC	R2		;YES, DECREMENT COUNT
..040:
	.ENDC
	MOV	R2,	B
	CLR	R2
10$:	SUB	SPCNT,	B
	BMI	20$
	INC	R2
	BR	10$
20$:	ADD	SPCNT,	B
	MOV R2,EXSP1		;MULTIPLIER FOR ALL SPACES
	TST	F.1		;EXTRAS TO LEFT OR RIGHT?
	BMI	OUTJC1		;LEFT. STORE NUMBER OF EXTRA SPACES
	NEG B			;RIGHT. GET SPACES BEFORE EXTRAS
	ADD SPCNT,B		;..
OUTJC1:	MOV B,EXSP2		;STORE FOR LATER
OUTNJ1:	MOV INDCT, R2		;GET INDENTING IN CASE OF PARAGRAPH
	CLR INDCT		;(ONCE ONLY)
	ADD LMARG, R2		;PLUS LEFT MARGIN
	JSR R5,NSPAC		;OUTPUT THAT MANY SPACES
OUTL1:	JSR R5,GLOUT		;READ A CHARACTER FROM OUTPUT BUFFER
	  BR	OUTLE		;END OF OUTPUT BUFFER
	CMP	R1,#C.SPC		;REAL SPACE?
	BEQ OUTSP		;YES. GO SEND N OF THEM
	CMP	R1,#C.NXS		;NON-EXPANDABLE SPACE?
	BNE ..043
	MOV #C.SPC,R1		;YES. MAKE IT ONE SPACE
..043:
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	..044		;NO
	MOV	R1, -(SP)
..044:
	.ENDC
	JSR R5,CCOUT		;OUTPUT THE CHARACTER
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	OUTL1		;NO
	MOV	(SP)+,R1
	TSTB	R1		;SHOULD A HYPHEN BE TYPED?
	BPL	OUTL1		;NO
	MOV	#'-,R1
	JSR	R5,CCOUT	;OUTPUT IT
	.ENDC
	BR OUTL1		;LOOP BACK FOR MORE.

JUSERR:				;OUTPUT ERROR MESSAGE ON TTY
	.PRINT	#JUSRM1
	MOV LOUT1, R2		;COPY POINTER TO LINE
	MOV LOUT2,B		; ..
	MOV R2,T1		; ..
	MOV B,T2		; ..
JUSER1:	MOV #T1,R4		;GET CHAR FROM LINE
	JSR R5,GCI		; ..
	  BR JUSER3		;END OF LINE
	MOV	R1,	R0
	.TTYOUT
	BR JUSER1		;LOOP FOR WHOLE LINE

JUSER3:				;TYPE OUT CR-LF
	.PRINT	#CRLFM
	JSR R5,ONPAG		;TELL HIM WHERE HE LOST
	BIC #TJUSTF,F.1		;SAY NOT JUSTIFYING
	BR	OUTNJ1		;AND OUTPUT LINE WITHOUT JUSTIFYING
;HERE TO OUTPUT AN EXPANDABLE SPACE.
OUTSP:	MOV #C.SPC,R1		;OUTPUT A TRUE SPACE
	JSR R5,CCOUT		; ..
	BIT #TJUSTF,F.1		;ARE WE JUSTIFYING?
	BEQ OUTL1		;NO, JUST LOOP
	MOV EXSP1,R2		;YES. HOW MANY MULTIPLE SPACES?
	BLE ..045
	JSR R5,NSPAC		;IF ANY, SEND THEM.
..045:	DEC EXSP2		;TO EXTRA BLANKS YET?
	BGE OUTS1		;NO.
	TST	F.1		;YES. SPACES LEFT OR RIGHT?
	BGE	OUTS2		;RIGHT. OUTPUT A SPACE
	BR OUTL1		;LEFT. NO MORE EXTRAS, JUST LOOP

OUTS1:	TST	F.1		;LEFT OF BREAK. WANT LEFT SPACES?
	BGE	OUTL1		;NO. HOLD FOR LATER
OUTS2:	MOV #C.SPC,R1		;YES. OUTPUT A SPACE
	JSR R5,CCOUT		; ..
	BR	OUTL1		;AND LOOP FOR REST OF LINE
;END OF LINE, AND FOOTNOTE PROCESSING

OUTLE:	ADD	#EXSP3, F.1	; * * EXSP3 MUST BE BIT 15 * *
	MOV LNIN1,R2		;CLEAR INPUT LINE BUFFER
	MOV R2, R0		;BY BACKING UP POINTER
	MOV LNIN2,R2
	MOV R0,LNIN2
	CMP R2, LOUT2		;ANY LEFT TO OUTPUT?
	BLOS OUTLE4		;NO.
	MOV R2, GCIN2		;YES. SAVE POINTER
	MOV LOUT2,GCINP		; ..
				;FOR GET-CHARACTER ROUTINE
	BIS #GCINF,F.1		;NEED TO INPUT FROM BUFFER FIRST

OUTLE4:	MOV NSPNG,R2		;OUTPUT CRLFS FOR THIS LINE
	JSR R5,SKIPN		; ..
	TST FOOTC		;ANY FOOTNOTE LINE COMMANDS DECLARED?
	BEQ OUTFT1
	BIT #FOOTFG,F.1		;YES. DOING THEM ALREADY?
	BNE	OUTFT1
				;SET UP FOR NEW LINE, RETURN FROM OUTLIN
..051:	MOV NLPG,R2		;SEE IF ROOM FOR FOOTNOTES
	SUB FOOTC,R2		; ..
	CMP R2, LINEC		; ..
	BLO OUTFT1
	MOV R2, NLPG		;REDUCE EFFECTIVE PAGE SIZE
	MOV FOOTP2,FOOTP4	;ADD LATEST FOOTNOTES TO POINTER
				; ..
	CLR FOOTC		;CLEAR COUNT OF SAVED FOOTNOTE LINES
	SUB NSPNG,R2		;MINUS NORMAL SPACING
	CMP R2, LINEC		;GREATER THAN LINE COUNT?
	BHI OUTFT1
	JSR R5,BPAGE		;YES. BREAK PAGE HERE.
OUTFT1:	JMP	LINSET		; AND RETURN
;SUBROUTINE TO SKIP N LINES ON OUTPUT FILE

SKIPN:	BIT #ULMODE,F.1		;NEED TO CONSIDER SAVED UNDERLINES?
	BEQ	CCOUT3		;YES. GO DO SO.
CCOUT5:	ADD	R2,LINEC		;COUNT LINES
	CLR NSPCH		;CLEAR PER-LINE COUNTS
	CLR CPOS		; ..
CCOUL1:	MOV #CRLFM,S1		;END-OF-LINE MESSAGE
	JSR R5,FMSG		;OUTPUT CRLF TO LINE
CCOUL2:	DEC	R2		;OUTPUT AS MANY AS REQUESTED
	BGT CCOUL1
	MOV LINEC,R2		;CHECK FOR END OF PAGE
	ADD NSPNG,R2		;POSITION OF NEXT LINE IF ALLOWED
	CMP	R2,NLPG		;UP TO A FULL PAGE?
	BLE ..055
	JSR R5,BPAGE		;YES. HANDLE HEADING
..055:	RTS R5			;RETURN FROM SKIPN

;ROUTINE TO OUTPUT N SPACES TO OUTPUT FILE, N .GE. 0, N IN A.

NSPAC:	TST	R2			;RETURN IF NONE TO OUTPUT
	BLE	2$
	ADD	R2,CPOS		;UPDATE CARRIAGE POSITION
1$:	MOV #C.SPC, R1		;GET A SPACE
	JSR R5,FOUT		;OUTPUT TO FILE
	DEC	R2		;LOOP FOR N SPACES
	BGT 1$
2$:	RTS R5			;AND RETURN.

;ROUTINES TO OUTPUT A STRING TO THE OUTPUT FILE

PSTRPA:	MOV (R4),R2		;GET POINTER FROM PA
	MOV 2(R4),B		;..
	MOV	R2,PSTRP		;STORE IN TEMP
	MOV B,PSTRP+2		;..

PSTRL:	MOV #PSTRP,R4		;GET A CHARACTER FROM THE TEMP POINTER
	JSR R5,GCI		;..
	  RTS R5		;NONE LEFT
	JSR R5,CCOUT		;OUTPUT CHAR TO FILE
	BR PSTRL		;LOOP FOR WHOLE STRING

..057:	JSR R5,CCOUT		;OUTPUT TO FILE
				;OUTPUT ASCIZ FROM S1
PSTRAZ:	MOVB @S1, R1		;GET A CHARACTER
	INC S1			;IF END, QUIT
	TST	R1
	BNE	..057
	RTS	R5
.SBTTL CHARACTER PROCESSORS
;SUBROUTINE TO OUTPUT CHARACTER TO FILE, AFTER SOME TESTS

CCOUT:	CMP	R1,#ULCHS		;UNDERLINE CHARACTER?
	BNE CCOUT1		;NO.
	BIT #ULMODE,F.1		;YES.  BY LINE?
	BEQ CCOUT2		;YES.
	MOVB ULCHAR,R1		;CONVERT TO OUTPUT UNDERLINE
	BIT #ULBSF,F.1		;NO.  BY BACKSPACING?
	BEQ CCOUT1		;NO, ASSUME NON-SPACING
	JSR R5,FOUT		;YES, SEND UNDERLINE
	MOV #C.BS,R1		;AND FOLLOW WITH BACKSPACE
CCOUT1:	CMP	R1,#C.QTS		;QUOTED SPACE?
	BNE ..061
	MOV #C.SPC,R1		;YES, MAKE REAL SPACE
..061:	JSR R5,FOUT		;SEND TO OUTPUT FILE
	INC CPOS		;COUNT POSITION OF CARRIAGE
	RTS R5			;AND RETURN.

CCOUT2:	MOV CPOS,B		;YES.  STORE POSITION IN BUFFER FOR LATER
	MOVB B,@ULPOS		;INTO UNDERLINE BUFFER
	INC ULPOS		;STEP BUFFER POINTER.  (SHOULD CHECK IT)
	RTS R5			;RETURN WITHOUT TYPING THE UNDERLINE.

;CONTINUATION OF OUTPUT N LINES

CCOUT3:	MOV #ULPBF,B		;START CONSIDERING UNDERLINE BUFFER
	CMP B,ULPOS		;ANY UNDERLINES IN THE BUFFER?
	BEQ	CCOUT5		;NO.  GO SEND LINE
	MOV	R2,-(SP)		;SAVE NUMBER OF LINES TO BE OUTPUT
	BIT #ULSUPF,F.1		;UNDERLINES SUPPRESSED?
	BNE CCOUT4		;YES.  SKIP OUTPUT SECTION
	MOV B,ULPT1		;STORE START OFF BUFER
	TSTB	ULNEXT		;UNDERLINING ON NEXT LINE?
	BEQ	1$		; NO
	MOV	#CRLFM, S1	;USE THIS IF YOU FAKE UNDERSCORE WITH A 176
	JSR	R5, FMSG
	BR	2$
1$:	MOV	#C.CR, R1
	JSR	R5,	FOUT	;USE REAL UNDERSCORE (_)
2$:	CLR CPOS		;START AT BEGINNING OF LINE
CCOUT6:	MOVB @ULPT1, R2		;GET POSITION WHERE UNDERLINE GOES
	SUB CPOS, R2		;HOW FAR TO IT?
	JSR R5,NSPAC		;SPACE TO THE UNDERLINE
	MOVB ULCHAR,R1		;GET LINE-PRINTER UNDERSCORE CHARACTER
	JSR R5,FOUT		;SEND TO FILE
	INC CPOS		;COUNT POSITION
	INC ULPT1		;COUNT UNDERLINE BUFFER POINTER
	MOV ULPT1, R2
	CMP	R2,ULPOS		;UP THRU LAST UNDERLINE?
	BNE CCOUT6		;NO.  GO OUTPUT ANOTHER ONE
	TSTB	ULNEXT
	BEQ	CCOUT4
	INC	LINEC		;WE'VE PUT OUT AN EXTRA LINE
CCOUT4:	MOV #ULPBF,ULPOS	;YES.  RESET TO START OF BUFFER
	MOV (SP)+, R2		;RESTORE NUMBER OF LINES
	JMP CCOUT5		;AND GO OUTPUT THEM
;GET INPUT CHARACTER FROM SOURCE FILE

GCIN:	BIT #GCINF,F.1		;STILL READING FROM BUFFER?
	BNE GCIN1		;YES.  GO RE-READ CHARACTER
GCIN3:	TST GCSCH		;NO.  SAVED A CHARACTER?
	BGE GCIN5		;YES.  GO GET IT.
	TST ULMCH		;SAVING CHARACTER DUE TO UNDERLINE?
	BGE	ULMC1		;YES.  GO GET IT.
GCIN5:	JSR R5,CCIN		;NO.  GET CHARACTER FROM FILE.
	CMP	R1,#CWARN		;QUOTING A CHARACTER?
	BEQ CWR1			;YES.  GO GET REAL CHARACTER
	CMP	R1,#SHUP		;UPSHIFT CHARACTER?
	BEQ SHUP1		;YES.  SEE IF SHIFT-LOCK
	CMP	R1,#SHDN		;DOWNSHIFT CHARACTER?
	BEQ SHDN1		;YES.  SEE IF SHIFT-UNLOCK
	CMP	R1,#ULCHI		;UNDERLINE REQUEST?
	BEQ ULCH			;YES.  GO PROCESS
	CMP	R1,#QTSP		;QUOTED SPACE?
	BEQ QTSP1		;YES.
	CMP	R1,#'Z		;UPPER CASE LETTER?
	BGT ..075
	CMP	R1,#'A		;..
	BLT ..075		;NO.
	ADD CAS, R1		;YES.  ADD ON CURRENT CASE
GCINR:
..075:	BIT #ULMSW,F.1		;UNDERLINE SHIFT-LOCK ON?
	BNE ULMC2		;YES.  GO HANDLE
	RTS R5			;NO.  HAVE CHARACTER NOW.

;SPECIAL CASES OF INPUT CHARACTER

QTSP1:	MOV #C.QTS, R1		;QUOTED SPACE (NO UNDERLINING)
	RTS R5			;RETURN WITHOUT UNDERLINE

GCIN1:	JSR R5,GGCINP		;GET CHARFROM INPUT BUFFER
	  BR ..077
	RTS R5			;RETURN IT.
..077:	BIC #GCINF,F.1
	BR	GCIN3		;GO READ FROM FILE, ETC.

CWR1:	JSR R5,CCIN		;READ CHARACTER.  NO TRANSLATION
	BR GCINR		;AND RETURN IT.  MAYBE UNDERLINED
;MORE SPECIAL CASES OF GET-CHARACTER ROUTINE

SHUP1:	JSR R5,CCIN		;READ A CHARACTER
	CMP	R1,#ULCHI		;UNDERLINE?  LOCK ON UNDERLINE?
	BEQ ULMON		;YES.
	CMP	R1,#SHUP		;DOUBLE UPSHIFT?
	BNE GCINR		;NO.  GO RETURN WITH TRUE CASE.
	CLR CAS			;DOUBLE UPSHIFT.  CLEAR CASE OFFSET
	BR GCIN3		;AND GO READ ANOTHER CHARACTER.

SHDN1:	JSR R5,CCIN		;GET ANOTHER CHARACTER
	CMP	R1,#ULCHI		;UNLOCK UNDERLINE?
	BEQ ULMOF		;YES.  GO DO SO.
	CMP	R1,#SHDN		;SECOND DOWNSHIFT?
	BEQ SHDN2		;YES.
	CMP	R1,#'^		;IN RANGE FOR LOWERING?
	BGT GCINR
	CMP	R1,#'@		;..
	BLT GCINR
				;NO.
	ADD #40, R1		;YES.  MAKE IT LOWER CASE
	BR GCINR		;RETURN THIS, UNDERLINED IF NEEDED.

SHDN2:	MOV #40, R2		;SET CASE OFFSET TO LC FOR LETTERS
	MOV R2,CAS		;..
	BR	GCIN3		;AND GO READ ANOTHER CHARACTER

ULMC2:				;HERE WHEN RETURNING A CHAR, BUT UNDERLINE LOCKED ON.
	CMP	R1,#C.QTS		;QUOTED SPACE?
	BEQ ..085
	CMP	R1,#C.SPC		;PRINTING CHARACTER?
	BLE	..085		;NON-PRINTING OR QUOTED SPACE, DON'T UNDERLINE
	MOV	R1,ULMCH		;THIS MAY BE UNDERLINED.  SAVE IT FOR LATER
ULCH:	INC NSPCH		;COUNT NON-SPACING INPUT
	MOV #ULCHS, R1		;CONVERT TO STORAGE UNDERLINE
	RTS R5			;AND RETURN

ULMC1:	MOV ULMCH, R1		;RESTORE SAVED CHARACTER
	MOV #-1,ULMCH		;NEGATIVE TO INDICATE NOT THERE.
..085:	RTS R5			;RETURN WITH THIS SAVED CHARACTER

ULMON:	BIS #ULMSW,F.1		;UNDERLINE LOCKED ON
	BR	GCIN3

ULMOF:	BIC #ULMSW,F.1		;UNDERLINE LOCKED OFF
	BR	GCIN3		;GO READ ANOTHER CHARACTER
;ROUTINE TO READ INPUT FROM FILE OR FOOTNOTE AS APPROPRIATE

CCIN:	MOV GCSCH, R1		;ANY CHARACTER SAVED FROM EARLIER PASS?
	BGE GCIN4		;YES.  GO RETURN IT.
	BIT #FOOTFG,F.1		;CHARACTERS COMING FROM FOOTNOTE?
	BNE FOOTCH		;YES.  GO GET ONE
	JSR R5,FIN		;NO.  READ FROM FILE
	RTS R5			;AND RETURN THAT.

GCIN4:	MOV #-1,GCSCH		;NO MORE SAVED CHARACTERS.
	RTS R5			;RETURN LAST SAVED ONE.

FOOTCH:	MOV #FOOTP3, R4		;GET CHARACTER FROM FOOTNOTE STRING
	JSR R5,GCI		;GET THE CHARACTER
	  BR FOOTHL			;NONE THERE.  I HAVE BLOWN IT GOOD
 	RTS R5			;RETURN THE CHARACTER

FOOTHL:	.PRINT	#HALTM		;GIVE THE HALT MESSAGE
	JMP RUNOFF		;RESTART RUNOFF
.SBTTL COMMANDS

INDENT:	JSR R5,OUTNJ		;OUTPUT REST OF CURRENT LINE
	JSR R5,RCNO		;READ SIGNED DECIMAL NUMBER
PARAG1:	  MOV PARIND, R3		;NONE.  USE CURRENT VALUE
	CMP	R3,RMARG		;LEGITIMATE VALUE?
	BLE ..090
	JMP ILCM		;NO.  COMPLAIN
..090:	MOV	R3,INDCT		;YES.  STORE ARGUMENT
	BR	XEBCM		;END OF BREAK COMMAND

BREAK:	JSR R5,OUTNJ		;THE SIMPLE BREAK COMMAND.
	BR	XEBCM		;RETURN AS ALL BREAK COMMANDS DO

UPCAS:	CLR	CAS		;SET CASE OFFSET TO ZERO
	BR	..092

LWCAS:	MOV #40, CAS		;SET FOR LOWER CASE OFFSET
	BR	..092		;END OF COMMAND (NOT BREAK)

NUMON:	JSR R5,RCNO		;NUMBER PAGES.  ANY PARTICULAR NUMBER?
	  MOV PAGENO, R3		;NO.  LEAVE SAME AS BEFORE
	MOV	R3,PAGENO		;STORE PAGE NUMBER
	BIS #NUMBF,F.1		;TURN ON FLAG TO CAUSE NUMBERING
	BR ..092

NUMOF:	BIC #NUMBF,F.1		;TURN OFF NUMBERING.
..092:	JMP	LCR		;END OF NON-BREAK COMMAND

;	DATE AND NODATE COMMANDS
SDATE:	.DATE		;GET MONITOR DATE
	BEQ NDATE	; NONE EXISTS
	MOV	R0,-(SP)	;SAVE DATE WORD
	BIC 	#^C37,R0	;YEAR - 1972
	ADD	#72.,R0		;YEAR - 1900
	MOV	R0,YEAR
	MOV	@SP,R0		;GET DATE WORD AGAIN
	ASL	R0
	ASL	R0
	ASL	R0
	SWAB	R0
	BIC	#^C37,R0	;DAY OF MONTH
	MOV	R0,DAY
	MOV	(SP)+,R0	;HERE'S THAT WORD AGAIN
	SWAB	R0
	BIC	#^C74,R0	;MONTH*4
	ADD	#MONTBL-4,R0
	MOV	R0,MONPTR	;POINT TO NAME OF MONTH
	BR	..092
NDATE:	CLR	YEAR		;0 YEAR MEANS DON'T PRINT DATE
	BR	..092
;PAGE COMMAND

CPAGE:	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
	CLRB	FSUBPG		;ZERO SUBPAGE FLAG
	MOV #C.SPC,SUBPGE	;CONVERTS TO ASCII 'A-1
				;SAVE HERE FOR LATER USE
DPAGE:	JSR R5,BPAGE		;BREAK PAGE, HEADING
	BR	XEBCM		;END OF BREAK-CLASS COMMAND
SPAGE:	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
	JSR R5,TPAGE		;BREAK PAGE, HEADING, ETC.
XEBCM:	JMP ENDBCM		;END OF BREAK CLASS MESSAGE

;TITLE COMMAND

SETTL:	MOV #TTLBUF, R4		;COMPUTE POINTER TO TITLE BUFFER
	JSR R5,CSP		; ..
	MOV R2,TTLP1		;STORE.
	MOV B,TTLP2		;..
	JSR R5,GCIN		;READ CHARACTER AFTER COMMAND
	CMP	R1,#C.SPC		;SPACE?  SKIP JUST ONE.
	BNE ..093
SETTL1:	JSR R5,GCIN		;READ A CHARACTER
..093:	CMP	R1,#C.CR		;END OF COMMAND LINE?
	BEQ	..092		;YES.  QUIT
	MOV #TTLP1, R4		;NO.  PUT CHAR IN STRING BUFFER
	JSR R5,WCI		;..
	CMP	TTLP2,#TTLBFE	;AT END OF BUFFER?
	BLO	SETTL1		; NOT YET
	.PRINT	#TTL		;TITLE
	.PRINT	#TOOBIG		;TOO LONG
	JMP	ILCM5		;ILLEGAL COMMAND
;SET RIGHT MARGIN COMMAND

SETRM:	JSR R5,OUTNJ		;BREAK-CLASS COMMAND
	JSR R5,RCNO		;GET ARGUMENT
	  MOV PRMRG, R3		;IF NONE, INITIALIZE
	CMP	R3,LMARG		;MUST ALSO BE RIGHT OF LEFT MARGIN
	BLE	..094
	MOV	R3,RMARG		;STORE RIGHT MARGIN
	BR	XEBCM		;END OF COMMAND

;SET LEFT MARGIN COMMAND

SETLM:	JSR R5,OUTNJ		;BREAK COMMAND
	JSR R5,RCNO		;GET ARGUMENT
	  MOV #ILMRG, R3		;IF NONE, INITIALIZE
	CMP	R3,RMARG		;AND LESS THAN RIGHT MARGIN?
	BGE	..094
	MOV	R3,LMARG		;OK SAVE AS LEFT MARGIN
	BR	XEBCM		;AND END BREAK-CLASS COMMAND

;PAGE SIZE COMMAND

SETPG:	JSR R5,RCNO		;GET ARGUMENT
..094:	  JMP	ILCM		;MUST BE ONE
	CMP	R3,#12		;LONG ENOUGH TO BE REASONABLE FOR HEADING
	BLE	..094
	MOV	R3, NLPG		;SAVE AS LENGTH OF THIS PAGE
	MOV	R3,PNLPG		;AND PERMANENT PAGE LENGTH
	JSR R5,RCNO		;SEE IF SECOND ARGUMENT
	  MOV PRMRG, R3		;NO
	CMP	R3,LMARG
	BLE	..094
	MOV	R3,PRMRG		;STORE PAGE WIDTH
	MOV	R3,RMARG
	JMP	LCR		;END OF COMMAND
;PARAGRAPH COMMAND

PARAG:	JSR R5,OUTNJ		;FINISH CURRENT LINE
	JSR R5,RCNO		;OPTIONAL IDENTING ARGUMENT
	  MOV PARIND, R3		;NO.  USE OLD VALUE
	MOV	R3,PARIND		;STORE PARA INDENT VALUE
	MOV LINEC, R2		;GET LINE COUNT USED ON THIS PAGE
	CMP	R2,#5		;BEYOND HEADING YET?
	BLE	..097
	MOV NSPNG, R2		;GET NORMAL LINE-SPACING
	INC R2			;COMPUTE SIZE OF PARAGRAPH BREAK
	ASR R2			;..
	MOV LINEC, R3
	ADD	R2, R3			;CHECK FOR END OF PAGE
	ADD NSPNG, R3		;HERE + PARAG. BREAK + 1 MORE
	CMP	R3, NLPG		;PAGE TOO FULL FOR THE BREAK NEEDED?
	BGE	PARAG2
	JSR R5,SKIPN		;NO.  GO SKIP N LINES (N IN A)
..097:	JMP PARAG1		;CHECK ARGUMENT AND RETURN

PARAG2:	JSR R5,BPAGE		;BREAK PAGE.  ADD HEADING
	BR	..097		;AND RETURN
;TEST PAGE COMMAND

TSTPG:	JSR R5,OUTNJ		;BREAK LINE FIRST
	JSR R5,RCNO		;GET ARGUMENT OF TEST
	  JMP ILCM		;MUST BE ONE
	ADD LINEC, R3		;ADD ON CURRENT LINE POSITION
	CMP	R3,NLPG		;COMPARE TO LENGTH W/O FOOTNOTES
	BLE ..101
	JSR R5,BPAGE		;TEST SHOWS NEAR END. BREAK PAGE.
..101:	JMP ENDBCM		;RETURN FROM TSTPG

;SPACING COMMAND

SSP:	JSR R5,OUTNJ		;BREAK LINE FIRST
	JSR R5,RCNO		;GET ARGUMENT OF SPACING COMMAND
	  JMP ILCM		;MUST BE ONE
	CMP	R3,#5		;MUST BE IN RANGE 1 TO 5
	BGT ..094
	TST	R3			;..
	BLE	..094
	MOV	R3,NSPNG		;OK.  STORE AS NORMAL SPACING
	BR	..101		;END OF SPACING COMMAND

;SUBTITLE COMMAND

SETSTL:	MOV #STTLBF, R4		;COMPUTE POINTER TO
	JSR R5,CSP		;SUBTITLE BUFFER
	MOV	R2,STTLP1		;STORE EMPTY POINTER
	MOV B,STTLP2		;..
	JSR R5,GCIN		;GET CHARACTER FROM INPUT LINE
	CMP	R1,#C.SPC		;SKIP ONE LEADING SPACE
	BNE ..104
SETST1:	JSR R5,GCIN		;GET CHARACTER FROM INPUT LINE
..104:	CMP	R1,#C.CR		;END OF LINE ON INPUT?
	BEQ	..101		;YES.  END OF SUBTITLE COMMAND
	MOV #STTLP1, R4		;NO.  WRITE INTO BUFFER
	JSR R5,WCI		;..
	CMP	STTLP2,#STLBFE	;END OF BUFFER?
	BLO	SETST1
	.PRINT	#STTL
	.PRINT	#TOOBIG
	JMP	ILCM5		;ERROR EXIT
;LINE SKIPPING COMMANDS

SKIPL:	MOV NSPNG,S2		;SKIP COMMAND.  N CURRENT LINES
	BR ..106
LINSKP:	MOV #1,S2		;BLANK COMMAND.  N REAL LINES
..106:	MOV S2,-(SP)		;SAVE S2 FOR SAFETY
	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
	MOV (SP)+,S2		;RESTORE S2
	MOV LINEC, R2		;CHECK CURRENT POSITION
	CMP	R2,#5		;AT TOP OF PAGE?
	BLE	..101		;YES.  IGNORE BLANK COMMAND.
	JSR R5,RCNO		;GET OPTIONAL ARGUMENT
	  MOV #1, R3		;IF NONE, ASSUME 1
	CLR	R2
10$:	ADD	S2,	R2
	DEC	R3
	BNE	10$
	MOV	R2,	R3
	ADD LINEC, R3		;ADD CURRENT LINE
	ADD NSPNG, R3		;PLUS SPACING TO NEXT LINE
	CMP	R3,NLPG		;ROOM FOR ANOTHER?
	BLT ..108
	JMP DPAGE		;NO. MAKE A NEW PAGE
..108:	JSR R5,SKIPN		;YES.  SPACE OUT C(A) LINES
	BR	..101		;END OF COMMAND


FIGUR:	JSR R5,OUTNJ		;BREAK COMMAND
	JSR R5,RCNO		;GET ARGUMENT
	  MOV #1, R3		;IF NONE, ASSUME ONE LINE
	CMP	R3,NLPG		;CHECK FOR RATIONAL ARGUMENT
	BGT ..109
	TST	R3			;..
	BLE	..109		;BAD.  ERROR.
	MOV	R3,-(SP)		;SAVE DESIRED SPACE
	ADD LINEC, R3		;SEE IF NEED NEW PAGE FOR FIGURE
	CMP	R3,NLPG		;WOULD THIS OVERFLOW PAGE
	BLT ..111
	JSR R5,BPAGE		;YES.  BREAK PAGE
..111:	MOV (SP)+, R2		;GET BACK DESIRED SIZE
	JSR R5,SKIPN		;SPACE THAT OUT
	BR	..101		;END OF BREAK COMMAND

..109:	JMP	ILCM
JUSTN:	JSR R5,OUTNJ		;BREAK COMMAND
	BIS #JUSTF+PJUSTF,F.1	;TURN ON JUSTIFYING
	BR	..112		;AND RETURN FROM COMMAND

JUSOF:	JSR R5,OUTNJ		;BREAK CURRENT LINE
	BIC #PJUSTF+JUSTF,F.1	;TURN OFF JUSTIFY BITS
	BR	..112		;AND FINISH COMMAND

FILLN:	JSR R5,OUTNJ		;BREAK COMMAND
	BIS #FILLF+JUSTF,F.1	;TURN ON FILLING, COPY PJUSTF TO JUSTF
	BIT #PJUSTF,F.1		;COPY PERMANENT FLAG
	BNE ..112
	BIC #JUSTF,F.1		;TO CURRENT ONE.
..112:	JMP ENDBCM		;AND OF COMMAND

FILOF:	JSR R5,OUTNJ		;BREAK CURRENT LINE
	BIC #FILLF+JUSTF,F.1	;TURN OFF FILLING AND JUSTIFYING
	BR	..112		;END OF COMMAND

SETTAB:	CLR NTABS		;CLEAR NUMBER OF TABS
SETT1:	JSR R5,RCNO		;GET ANOTHER STOP IF ANY
	  JMP	LCR		;NO, RETURN
	ADD #2,NTABS		;GET POINTER
	MOV NTABS,X
	MOV X,R0
	MOV	R3, TABTAB-2(R0)	;STORE THIS TABSTOP
	CMP R0, #TABTL		;CHECK TABLE SIZE
	BLO SETT1		;OK.
	BR	..109		;TOO MANY TABS

;ROUTINE TO FIND NEXT TABSTOP FOR OUTLIN ROUTINE.  CALL
;WITH CURRENT POSITION IN A.

TAB:	CLR X			;START AT FIRST TABSTOP
	BR TAB1			;PRE-ENDCHECK, IN CASE NONE.

TAB2:	MOV X,R0
	MOV TABTAB-2(R0), R4	;GET CURRENT TAB STOP
	CMP	R2, R4			;THIS STOP BEYOND CURRENT POS?
	BLO TAB3		;YES.  GET DIFFERENCE
TAB1:	CMP X,NTABS		;LOOKED AT ALL TAB STOPS?
	BHIS ..115
	ADD #2,X			;NO.  LOOK AT ANOTHER
	BR TAB2

..115:	MOV RMARG, R4		;YES.  ASSUME A TABSTOP AT RIGHT END
TAB3:	SUB	R2, R4			;GET DISTANCE TO TABSTOP
	MOV	R4, R2			;ANSWER IN A
	RTS R5			;RETURN
;ROUTINE TO SPACE TO TOP OF FORM

FORM:	MOV LINEC, R3		;GET CURRENT LINE POSITION
	BLE	..119		;ALREADY AT TOP.  RETURN.
	BIT	#PAUSF, F.1	;SHOULD WE PAUSE?
	BEQ	10$		;NOPE
	CMP	PAGENO,LOWPAG	;PRINTING THIS PAGE?
	BLO	10$		; NO, PRESS ON REGARDLESS
	BIS	#10000, @#44	;SET SPECIAL MODE
	JSR	R5,	OUTPUT	;DUMP PARTIAL BUFFER
	.WAIT	OCHAN
	.TTYIN			;WAIT FOR ANY CHAR BEFORE PROCEDING
	CMPB	R0,#15		;DID HE HIT <CR>
	BNE	1$		; NOPE
	.TTYIN			;FLUSH THE <LF> WHICH RT-11 SENDS US
1$:	BIC	#10000, @#44	;UN-SET SPECIAL MODE
	BR	BPG3		;ASSUME GUY HAS POSITIONED PAPER PROPERLY

10$:	BIT #FFDSW,F.1		;SPACING WITH FF OR LFS
	BEQ BPG2		;LINEFEEDS
	MOV #C.FF,R1		;OUTPUT FORMFEED TO FILE
	JSR R5,FOUT		;..
	BR BPG3			;ADJUST COUNTS
BPG2:	MOV	R3,	N1
	CLR	R3
10$:	SUB	HWPLN, N1	;COMPARE WITH HARDWARE PAGE LENGTH
	BMI	1$
	INC	R3
	BR	10$
1$:	MOV	#CRLFM,S1	;PUT OUT CRLF'S
	JSR	R5,FMSG		; TO FILE
	INC N1			;..
	BLT 1$
BPG3:	CLR LINEC		;CURRENT LINE NOW ZERO
	TSTB	FSUBPG		;DON'T INCREMENT PAGE, IF SUBPAGE
	BNE	..119
	INC PAGENO		;COUNT PAGE NUMBER
..119:	RTS R5			;RETURN FROM FORM ROUTINE
;ROUTINE TO BREAK PAGE AND OUTPUT HEADING


TPAGE:	INCB	FSUBPG		;SET SUBPAGE FLAG
	INC SUBPGE		;INCREMENT SUBPAGE
BPAGE:	MOV LINEC, R2		;CURRENT LINE POSITION
	CMP	R2,#5		;IN HEADING AREA?
	BLE	..119		;YES - DON'T DO IT AGAIN
	MOV FOOTP3, R2		;SEE IF ANY DATA IN FOOTNOTE BUFFER
	CMP	R2,FOOTP4		;..
	BEQ ..121
	JMP FOOTGO		;YES.  GO PROCESS THAT FIRST
..121:
FOOTX:	JSR R5,FORM		;OUTPUT FORMFEED OF LINEFEEDS
	MOV #1, R2		;SKIP A LINE
	JSR R5,SKIPN		;..
	MOV #TTLP1, R4		;OUTPUT TITLE TO FILE
	JSR R5,PSTRPA		;PRINT STRING FROM PA
	BIT #NUMBF,F.1		;WANT PAGE NUMBER?
	BEQ BPGN		;NO.
	MOV RMARG, R2		;FIND POSITION WHERE THIS LEFT US
	ADD ULPOS, R2		;..
	SUB #ULPBF, R2		;ADD IN ANY UNDERLINES
	SUB TTLP2, R2		;AND TITLE CHARACTERS
	ADD TTLP1, R2		;..
	TSTB	FSUBPG		;SUBPAGE?
	BEQ 10$
	DEC	R2			;MAKE ROOM FOR LETTER
10$:	SUB #10, R2		;MINUS 8 FOR "PAGE NNN"
	BMI	BPGN		;NO ROOM FOR PAGE NUMBER
	JSR R5,NSPAC		;SPACE OVER TO THERE
	MOV #PGTXT, S1		;PAGE MESSAGE
	JSR R5,FMSG		;OUTPUT TO FILE
	MOV PAGENO, R3		;OUTPUT PAGE NUMBER
	JSR R5,PPGNO		;3 DIGIT DECIMAL PRINT
	TSTB	FSUBPG		;IS THIS A SUBPAGE?
	BEQ BPGN
	MOV SUBPGE,R1		;RETRIEVE THE LETTER
	ADD #' ,R1		;MAKE AN ASCII LETTER
	JSR R5,FOUT		;GET IT INTO OUTPUT BUFFER
BPGN:	MOV #1, R2		;OUTPUT THE LINE WITH TITLE
	JSR R5,SKIPN		;..
	MOV #STTLP1, R4		;OUTPUT THE SUBTITLE, IF ANY
	JSR R5,PSTRPA		;..
	TST	YEAR		; ANY DATE TO PUT OUT?
	BEQ	1$		;  NO
	BIT	#NUMBF,F.1	;ARE WE NUMBERING PAGES?
	BEQ	1$		; NO, DON'T PRINT DATE
	MOV	RMARG,R2	;OK, HOW FAR TO RIGHT MARGIN?
	ADD	ULPOS,R2
	SUB	#ULPBF,R2	;SUBTRACT UNDERLINES
	ADD	STTLP1,R2
	SUB	STTLP2,R2	;SUBTRACT SUBTITLE CHAR'S
	SUB	#10.,R2		;MAKE ROOM FOR #DD#MMM#YY
	BMI	1$		; NO ROOM!
	JSR	R5,NSPAC	; GO THERE
	MOV	DAY,R3
	JSR	R5,PPGNO	;#DD OR ##D
	MOV	#1,R2
	JSR	R5,NSPAC	;ONE MORE #
	MOV	MONPTR,S1
	JSR	R5,FMSG		;MONTH NAME GOES TO FILE
	MOV	YEAR,R3
	JSR	R5,PPGNO	;#YY UNTIL 1999
1$:	MOV #3, R2		;AND OUTPUT THIS LINE.
	JMP SKIPN		;INCLUDING SUBTITLE, AND RETURN FROM BPAGE
;SUBROUTINE FOR PAGE NUMBER OUTPUT

PPGNO:	MOV #C.SPC,R1		;LEADING SPACES IF NEEDED
	CMP	R3,#99.		;3 DIGITS?
	BGT ..124
	JSR R5,FOUT		;NO.  SPACE.
..124:	CMP	R3,#9.		;2 DIGITS?
	BGT ..125
	JSR R5,FOUT		;NO.  SPACE AGAIN.
..125:
DECPRT:	MOV	R3,	-(SP)
	CLR	R3
1$:	INC	R3
	SUB	#10.,	(SP)
	BGE	1$
	ADD	#60+10., (SP)
	DEC	R3
	BEQ	2$
	JSR	R5,	DECPRT
2$:	MOV	(SP)+,	R1
	JMP	FOUT
;CENTER COMMAND

CENTER:	JSR R5,RCNO		;SEE IF ANY ARGUMENT
	  MOV PRMRG, R3		;NO.  DEFAULT IS RIGHT SIDE OF PAPER
	MOV	R3,CENTC		;STORE
	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
..127:	JSR R5,GCIN		;DISCARD REST OF THIS COMMAND
	CMPB	R1,#C.LF		; ..
	BEQ	1$		; YES
	CMPB	R1,#C.SEMI	; OR A SEMICOLON?
	BNE ..127		; ..
1$:	MOV LNIN1, R2		;CLEAR INPUT BUFFER
	MOV	R2,LNIN2		; ..
CENT1:	JSR R5,GCIN		;READ LINE TO BE CENTERED
	CMP	R1,#C.CR		;THROUGH CR
	BEQ CENT2		; CR. DONE.
	JSR R5,WLNIN1		;PUT IN LINE INPUT BUFFER
	BR CENT1		;LOOP FOR MORE

CENT2:	MOV CENTC, R2		;COMPUTE SPACING BEFORE LINE
	ADD LNIN1, R2		;AS HALF RIGHT MARGIN
	SUB LNIN2, R2		;MINUS HALF OF LINE SIZE
	ADD NSPCH, R2		; INCLUDING UNDERLINES, ETC.
	ASR	R2		;TAKE HALF
	JSR R5,NSPAC		;OUTPUT SPACES
	MOV #LNIN1, R4		;THEN OUTPUT LINE BUFFER TO FILE
	JSR R5,PSTRPA		; ..
	MOV NSPNG, R2		;THEN SPACE TO NEXT LINE
	JSR R5,SKIPN		; ..
	JMP ENDBCM		;AND RETURN AFTER COMMAND
.SBTTL INDEX OPERATIONS
;ROUTINE TO ADD ITEM TO INDEX DATA AT TOP OF CORE

INDEX:	MOV #ICBUF,R0
1$:	CLR (R0)+		;FIRST, PUT ITEM IN COMPARISON BUFFER
	CMP R0,#ICBFE
	BLO 1$
				;CLEAR COMPARISON BUFFER
	MOV #ICBUF-1,S1
	CLRB	IDXRF		;CLEAR REPEATED ITEM FLAG
2$:	JSR R5,GCIN		;GET CHARACTER OF INDEX DATA
	CMP	R1,#C.SPC		;SKIP LEADING SPACES OR TABS
	BEQ 2$
	CMP	R1,#C.TAB		; ..
	BEQ 2$
INDX1:	CMP	R1,#C.CR		;COPY THROUGH END OF LINE
	BEQ INDX2		;END.
	INC	S1
	MOVB	R1,@S1		;STORE CHARACTER OF INDEX DATA
	JSR R5,GCIN		;GET NEXT CHARACTER
	CMP	S1,#ICBFE-1	;NEED ONE NULL FOR ASCIZ STRING!
	BLO INDX1		;LOOP IF ROOM
	.PRINT	#INDX		;INDEX ENTRY
	.PRINT	#TOOBIG
	JMP	ILCM5		;ERROR EXIT
INDX2:	MOV #2,R0		;FORM THE ASCIZ OF THE INDEX
	BIT #1,S1		;CHECK FOR BOUNDARY ALIGNMENT
	BEQ .+4
	INC R0
	ADD R0,S1
	SUB #ICBUF,S1		; ..
	MOV XFIRST, R2		;GET ADDRESS OF FIRST ITEM SO FAR
	BEQ INDXV		;IF NONE, LIST IS EMPTY. START IT.
INDXL2:	BIC #IDXCF,F.1		;CLEAR CASE-DIFFERENCE CATCHER
	MOV 4(R2), B		;ADDRESS OF ASCIZ OF OLD ITEM
				;POINTER TO IT.
	MOV #ICBUF, R4		;POINTER TO NEW ITEM
INDXL1:	MOVB @B,R1		;GET CHAR OF OLD
	INC B
	MOVB @R4, C2		;AND ONE OF NEW
	INC	R4
	CMP	R1,C2		;SAME BEFORE CASE MERGE?
	BEQ 3$
	BIS #IDXCF,F.1		;NO. REMEMBER THAT.
3$:	CMP	R1,#141		;CONVERT LC TO UC
	BLT 4$
	BIC #40,R1		; ..
4$:	CMP C2,#141		; ..
	BLT 5$
	BIC #40,C2		; ..
5$:	CMP	R1,C2		;SAME?
	BNE 6$
	TST	R1		;YES. LOOP UNLESS END OF STRINGS
	BNE INDXL1
6$:	CMP	R1,C2		;WHICH IS FIRST?
	BGT INDX3		;NEW ONE IS FIRST, AND DIFFERENT
	CMP	R1,C2		;ARE THEY IDENTICAL?
	BNE IDX4A		;YES. NO NEED FOR NEW COPY. ADJUST POINTERS
	BIT #IDXCF,F.1		;SEEM THE SAME. WERE CASES DIFFERENT?
	BNE INDX3		;YES. ASSUME THESE ARE DIFFERENT
	BISB	#1,IDXRF		;FLAG REPEATED ITEM
IDX4A:	MOV (R2), B		;NO. OLD ONE IS FIRST. LOOK FURTHER
	BEQ INDX5		;END OF LIST. NEW IS LAST
	MOV B, R2			;MOVE LINK TO A
	BR INDXL2		;LOOK FURTHER
;HEADER LAYOUT FOR INDEX ENTRY IS
;
;	.WORD FORWARD LINK
;	.WORD BACKWARD LINK
;	.WORD POINTER TO ASCII TEXT
;	.WORD PAGE NUMBER

INDX3:	TSTB	IDXRF		;AFTER REPEATED ITEM?
	BNE IDX4B		;YES. GO PUT IN REPEAT.
	JSR R5,INDXAD		;ADD ITEM WITH PAGE NO TO STORAGE (UNLINKED?
	MOV 2(R2),B		;WHO PRECEDED OLD?
	BNE ..512		;ANYONE?
	MOV	R4,XFIRST		;NO. NEW IS FIRST OF ALL.
..512:	MOV	R4,2(R2)		;NEW IS PREDECESSOR OF OLD
	MOV	R2,(R4)		;OLD IS SUCCESSOR OF NEW, NO PREDECESSOR
	TST B			;IF ANYONE PRECEDED OLD,
	BEQ ..513
	MOV	R4,@B		;MAKE NEW ONE BE HIS SUCCESSOR
..513:	MOV B,2(R4)		;AND OLD'S PRED IS NOW NEW'S PRED
	BR	.QECM		;RETURN FROM INDEX COMMAND

IDX4B:	MOV 2(R2), R2		;AT END OF REPEAT. GET LAST ONE.
IDX4C:	JSR R5,INDXAP		;ADD POINTERS ONLY (WITH PAGE. NO LINK)
	MOV 4(R2),B		;NEW POINTS TO SAME TEXT AS OLD
	MOV B,4(R4)		; ..
	MOV (R2),B		;GET PREVIOUS SUCCESSOR OF OLD
	MOV	R4,(R2)		;MAKE NEW SUCCEED OLD
	TST B			;IF THERE WAS AN OLD NEXT,
	BEQ ..515
	MOV B,R0		;NEW IS NOW PRED OF OLD NEXT.
	MOV	R4,2(R0)
..515:	MOV B,(R4)		;OLD SUCCESSOR IS SUCCESSOR OF NEW
	MOV	R2,2(R4)		;OLD IS PREDECESSOR OF NEW
	BR	.QECM		;END OF INDEX COMMMAND

INDX5:	TSTB	IDXRF		;AFTER REPEATS?
	BNE IDX4C		;YES. GO ADD AT END.
	JSR R5,INDXAD		;CREATE TEXT AND POINTER BLOCK WITH PAGENO
	MOV	R4,(R2)		;MAKE NEW FOLLOW OLD
	MOV	R2,2(R4)		;AND OLD PRECEDE NEW.
	CLR (R4)
.QECM:	JMP	LCR		;RETURN FROM INDEX COMMAND
INDXV:	JSR R5,INDXAD		;CREATE TEXT AND POINTER BLOCK, PAGE NO
	MOV	R4,XFIRST		;THIS IS FIRST ITEM (AND ONLY)
	CLR (R4)		;NO LINKS AT ALL
	CLR 2(R4)
	BR	.QECM

INDXAP:	MOV XTOP, R4		;GET CURRENT TOP OF INDEX
	ADD #10, R4		;NEED TEN WORDS FOR LINKS
	CMP	R4,FOOTBF		;SPACE BEFORE FOOTNOTES?
	BLO ..517
	JSR R5,EXPAND		;NEED MORE CORE
..517:	MOV XTOP, R4		;NEW VALUE OF XTOP, IF GREW
	MOV	R4,XTOP		;NEW TOP
	ADD #8.,XTOP		;NOW UP FOUR WORDS
INDXAX:	MOV PAGENO,6(R4)	;GET PAGE NUMBER
				;INTO NEW ITEM
	RTS R5			;AND RETURN.

INDXAD:	MOV XTOP, R4		;GET TOP OF INDEX STORAGE
	ADD S1, R4		;NEED 4 WORDS PLUS TEXT
	ADD #8., R4
	CMP	R4,FOOTBF		;LESS THAN BASE OF FOOTNOTES?
	BLO ..518
	JSR R5,EXPAND		;NO. TRY TO EXPAND
..518:	MOV XTOP, R4		;GET TOP OF INDEX
	MOV	R4,-(SP)		;SAVE BASE OF NEW ITEM
	MOV	R4,XTOP		;COMPUTE NEW TOP OF INDEX
	ADD S1,XTOP
	ADD #8.,XTOP
	MOV #ICBUF,FROM		;TRANSFER TEXT INTO BUFFER
	ADD #8., R4		;INTO TEXT AREA
	MOV	R4,TO		;FORM ADDRESS OF TEXT
	MOV	R4,-4(R4)
	MOV XTOP,ENDADR		;FORM LAST ADDRESS OF BLT
..519:	MOV @FROM,@TO		;TRANSFER INDEX ITEM
	ADD #2,FROM
	ADD #2,TO
	CMP TO,ENDADR
	BLO ..519
	MOV (SP)+, R4		;RESTORE BASE OF INDEX.
	CLR (R4)		;NO POINTERS YET.
	CLR 2(R4)
	BR INDXAX		;PUT PAGE NUMBER IN ITEM AND RETURN

FROM:	.WORD 0
TO:	.WORD 0
ENDADR:	.WORD 0
;PRINT INDEX ONTO FILE

PINDX:	JSR R5,OUTNJ		;BREAK COMMAND.  OUTPUT LINE.
	MOV XFIRST, R2		;GET FIRST ITEM IN INDEX
	BEQ PINDXX		;QUIT IF NONE.
	MOV	R2,OIXC		;SAVE CURRENT POINTER
	CLR OIXL		;CLEAR CURRENT LETTER
PINDL1:	MOV OIXC,B		;GET POINTER TO TEXT OF THIS ITEM
	MOV B,R0		; ..
	MOV 4(R0),B
				;ASCIZ POINTER
	MOVB @B,R1		;GET FIRST LETTER
	INC B
	CMP	R1,#141		;LOWER CASE?
	BLT ..520
	BIC #40,R1		;YES.  MAKE UPPER.
..520:	CMP	R1,OIXL		;SAME AS INITIAL LETTER OF PREVIOUS ONE?
	BEQ PINDX1		;YES.  SKIP THIS
	MOV #1, R2		;NO.  OUTPUT AN EXTRA LINE
	MOV	R1,OIXL		;SAVE THIS CHARACTER
	JSR R5,SKIPN
PINDX1:	MOV LMARG, R2		;SPACE IN TO LEFT MARGIN
	JSR R5,NSPAC		; ..
	MOV OIXC, R2		;GET POINTER TO ASCII
	MOV 4(R2), S1		;..
	JSR R5,PSTRAZ		;OUTPUT STRING OF ASCIZ
	MOV RMARG, R2		;NOW GO TO MIDDLE OF LINE
	SUB LMARG, R2		;IF NOT THERE YET
	ASR	R2			; ..
	SUB CPOS, R2		;MINUS CURRENT POSITION
	BLE PIND2		;THERE ALREADY
	MOV #C.SPC,R1		;GET A SPACE
	BIT #1, R2		;MAKE DOTS LINE UP
	BEQ ..522
	JSR R5,FOUT		;OUTPUT A SPACE
..522:	ASR	R2			;OUTPUT ALTERNATE DOTS AND SPACES
..524:	MOV #..523,S1		; ..
	JSR R5,FMSG		; ..
	DEC	R2			;OUTPUT TILL MIDDLE OF LINE
	BGT ..524
PIND2:	MOV #C.SPC,R1		;OUTPUT ONE SPACE
	JSR R5,FOUT		; ..
	MOV OIXC,B		;GET PAGE NUMBER OF THIS ENTRY
	MOV B,R0		; ..
	MOV 6(R0), R3
	JSR R5,DECPRT		;OUTPUT PAGE NUMBER
PINDX2: MOV @B, R4		;GET SUCCESSOR OF THIS ENTRY
	MOV	R4,OIXC		;STORE CURRENT ENTRY FOR NEXT PASS
	BEQ PINDXX		;END OF LIST?  JUMP IF SO.
	MOV B,R0		;TEXT OF CURRENT ITEM
	MOV 4(R0), R2
	MOV 4(R4), D		;TEXT OF NEXT ITEM
	CMP D, R2			;SAME AS CURRENT?
	BNE PINDX3
				;NO.  ON TO NEXT.
	MOV 6(R4), R3		;SAVE.  GET PAGE NUMBERS OF BOTH
	MOV B,R0		; ..
	MOV 6(R0),N1
	CMP N1, R3		;PAGES SAME TOO?
	BNE PINDX4
				;NO.  OUTPUT NEW PAGE NUMBER
	MOV	R4,B			;YES.  DON'T REPEAT PAGE NUMBER
	BR PINDX2		; ..

PINDX3:	MOV NSPNG, R2		;OUTPUT SPACING FOR END OF LINE
	JSR R5,SKIPN		; ..
	BR PINDL1		;GO ON TO NEXT ITEM IN LIST

PINDXX:	MOV NSPNG, R2		;BLANK LINE AT END
	JSR R5,SKIPN		; ..
	MOV XBOT,XTOP
	CLR XFIRST
	JMP ENDBCM		;RETURN FROM PINDX COMMAND

PINDX4:	MOV #',,R1		;PUT COMMA BETWEEN PAGE NUMBERS
	JSR R5,FOUT
	BR	PIND2
.SBTTL FOOTNOTE OPERATIONS

;FOOTNOTE N COMMAND

FOOTN:	JSR R5,RCNO		;HOW MANY LINES TO RESERVE?
	  JMP ILCM		;MUST HAVE SPEC
	CLR	-(SP)
10$:	ADD	NSPNG, (SP)
	DEC	R3
	BNE	10$
	MOV	(SP)+,	R3
	ADD	R3,FOOTC		;ADD TO RESERVED FOOTNOTE LINES
..145:	JSR R5,CCIN		;SKIP REST OF COMMAND LINE
	CMP	R1,#C.LF		; ..
	BNE ..145
	BR FOOTN3		;YES. END OF LINE.

FOOTN2:	JSR R5,CCIN		;READ A CHARACTER
FOOTN1:	JSR R5,WCIFTN		;WRITE CHARACTER IN BUFFER
	CMP	R1,#C.LF		;END OF LINE?
	BNE FOOTN2
FOOTN3:	JSR R5,CCIN		;YES. SEE WHAT CHAR AFTER LF IS
	CMP	R1,#C.EOF		;END OF FILE?
	BNE ..148
	MOV #C.EFNT,R1		;YES. FAKE END OF FOOTNOTE CHAR.
..148:	CMP	R1,#C.EFNT		;END FLAG (EXCL)?
	BNE FOOTN1		;NO. STORE ANOTHER LINE
	JSR R5,WCIFTN		;YES. STORE THIS CHARACTER
	JMP	LCR		;AND RETURN TO COMMAND ROUTINE

;START PROCESSING THE FOOTNOTE BUFFER. CALLED FROM BPAGE
;WHEN FOOTP3 POINTER IS NOT EMPTY

FOOTGO:	MOV #100., R2		;SET HUGE PAGE SIZE TO PREVENT EXTRA FORMS
	MOV NLPG,R0		;AND GET CURRENT LENGTH
	MOV	R2,NLPG
	MOV R0, R2
	SUB LINEC, R2		;DISTANCE TO END
	BLOS ..150		;IF SOME LEFT TO GO,
	JSR R5,SKIPN		; SKIP TO END OF PAGE BEFORE FOOTNOTES
..150:	MOV RMARG,-(SP)		;SAVE THESE ITEMS OVER FOOTNOTE PROCESSING
	MOV LMARG,-(SP)
	MOV PARIND,-(SP)	;SAVE PARA INDENTING
	MOV NSPNG,-(SP)
	MOV GCSCH,-(SP)
	MOV INDCT,-(SP)		;OCCASSIONALLY WE NEED TO SAVE THIS
	CLR INDCT		;CLEAR IT FOR RANDOM FAILURES
	BIS #FOOTFG,F.1		;FLAG IN FOOTNOTE PROCESSING
	MOV #-1,GCSCH		;CLOBBER ANY SAVED CHARACTERS
	MOV #FOOTWB, R4		;PREPARE END-OF-LINE-HOLDING-BUFFER
	JSR R5,CSP		; ..
	MOV	R2,FOOTS1		; ..
	MOV B,FOOTS2		; BUFFER IS EMPTY
	BIC #GCINF,F.1		;NO SAVED INFO. WAS THERE ANY?
	BEQ FOOTS3		;NO. LEAVE.
FOOTSB:	JSR R5,GGCINP		;GET A CHARACTER FROM SAVED BUFFER
	  BR FOOTS3		;NO MORE
	MOV #FOOTS1, R4		;SAVE BUFFER
	JSR R5,WCI
	CMP	FOOTS2,#FTBUFE
	BLO	FOOTSB		;LOOP UNTIL SAVED BUFFER ALL MOVED
	.PRINT	#INLINE		;SAVED INPUT LINE TOO LONG
	.PRINT	#TOOBIG
	JSR	R5,ONPAG
	BR	FOOTN5		;FORGET IT

FOOTS3:	JSR R5,LINSET		;INITIALIZE LINE FOR START OF FOOTNOTE
	JMP LGO			;AND GO PROCESS SAVED FOOTNOTE COMMANDS

;HERE WHEN LINE ROUTINE DISCOVERS INITIAL EXCLAMATION

FOOTND:	JSR R5,OUTNJ		;YES. FINISH UP LINE
	MOV FOOTP3, R2		;ANY MORE FOOTNOTES COMING?
	CMP	R2,FOOTP4		; ..
	BEQ ..152
	JMP LGO			;YES. GO READ SOME MORE
..152:	CMP	R2,FOOTP2		;ANY UNPROCESSED FOOTNOTES TO ADD?
	BHIS FOOTN6		;NO.
	MOV	R2,T5		;YES.  ADD THEM TO LIST.
	MOV FOOTP2,B		;SAVE POINTER TO REMAINING COMMANDS
	MOV B,T6		; ..
	MOV FOOTP1, R2
	MOV	R2,FOOTP2
	MOV	R2,FOOTP3
	MOV	R2,FOOTP4
FOOTN4:	MOV #T5, R4		;COPY T5 STRING TO FOOTP1
	JSR R5,GCI		;GET A CHARACTER
	  BR FOOTN5		;NO MORE.
	JSR R5,WCIFTN		;WRITE IN FOOTNOTE POINTER 1
	BR FOOTN4		;LOOP TILL DONE
FOOTN6:	MOV FOOTP1, R2		;CLEAR FOOTNOTE BUFFERS
	MOV	R2,FOOTP2		; ..
	MOV	R2,FOOTP3		; ..
	MOV	R2,FOOTP4		; ..
FOOTN5:	BIC #EXSP3+FOOTFG,F.1	;INITIALIZE LEFT/RIGHT FLAG
				; AND MARK NOT IN FOOTNOTE MODE NOW
	MOV (SP)+,INDCT		;RESTORE SAVED PARAMTERS
	MOV (SP)+,GCSCH
	MOV (SP)+,NSPNG
	MOV (SP)+,PARIND
	MOV (SP)+,LMARG
	MOV (SP)+,RMARG
	MOV PNLPG,NLPG		;RESET LENGTH OF PAGE
				; ..
	MOV FOOTS1, R2		;WAS PARTIAL LINE SAVED?
	CMP	R2,FOOTS2		; ..
	BEQ FOOTS4		;NO.
	MOV FOOTS2,B		;YES. PUT POINTER IN GCINP
	MOV	R2,GCINP		; ..
	MOV B,GCINP+2		; ..
	BIS #GCINF,F.1		;AND FLAG TO LOOK AT THAT BUFFER
FOOTS4:	JMP FOOTX		;RETURN TO LINE PROCESSOR

WCIFTN:	MOV FOOTP2, R2		;WRITE IN FOOTNOTE BUFFER, CHECKING SIZE
	MOV JOBREL,B		; ..
	CMP	R2,B			; ..
	BLO WCIFT1		;OK. NO PROBLEM.
	JMP EXPERR		;CAN'T HAVE IT. GIVE UP.
WCIFT1:	MOV #FOOTP1, R4		;NOW WRITE CHARACTER
	BR WCI			; ..
.SBTTL HANDY-DANDY SUBROUTINES

;ROUTINE TO COMPUTE EMPTY STRING POINTER

CSP:	MOV	R4, R2
	DEC	R2
	MOV	R2,B
	RTS R5

;ROUTINES TO GET CHARACTER AND INCREMENT STRING POINTER

GGCINP:	MOV #GCINP, R4
	BR GCI
GLOUT:	MOV #LOUT1, R4		;PARTICULAR ARGUMENT
GCI:	MOV (R4), R2		;GET FIRST POINTER
	CMP	R2,2(R4)		;ANYTHING IN STRING
	BHIS	CPOPJ		;NO.  NON-SKIP RETURN.
	INC (R4)		;YES.  COUNT AND GET FIRST POINTER
	MOV (R4), R2
	MOVB (R2), R1
	TST	(R5)+		;FORCE SKIP RETURN
CPOPJ:	RTS R5

;ROUTINES TO WRITE CHARACTER AND INCREMENT POINTERS

WCI:	INC 2(R4)
	MOVB	R1,@2(R4)	;STORE IT
	RTS R5

WLNIN1:	MOV	#LNIN1,R4
	JSR	R5,WCI		;WRITE CHAR IN LINE BUFFER
	CMP	2(R4),#LINBFE
	BLO	1$		;OK, BUFFER NOT FULL
	.PRINT	#INLINE
	.PRINT	#TOOBIG
	JSR	R5,ONPAG
1$:	RTS	R5		;PRESS ONWARD

;I/O SUBRS

FMSGL:	INC S1
FMSG:	MOVB @S1, R1
	BEQ	CPOPJ		;RETURN ON NULL
	JSR R5,FOUT		;OUTPUT CHARACTER
	BR FMSGL		;LOOP

FOUT:	CMP	PAGENO,LOWPAG	;IN BOUNDS?
	BLO	11$		; TOO LOW, IGNORE IT
	CMP	PAGENO,HGHPAG
	BHI	12$		;  TOO HIGH, QUIT
	TST	OBFCTR		;SEE IF SPACE IN OUTPUT BUFR
	BNE	10$		;IF YES, JUST PLUNK IN THE CHAR
	JSR	R5,	OUTPUT	;IF NOT, WRITE THE BUFFER
10$:	DEC	OBFCTR
	MOVB	R1,	@OBFPTR
	INC	OBFPTR		;BUMP THE BUF PTR
11$:	RTS R5			;AND RETURN
12$:	MOV	#-1,HGHPAG	;SET HIGH PAGE BACK TO INFINITY
	JMP	ENDFI2

FIN:	DEC IBFCTR		;ANYTHING IN BUFFER?
	BGT FINOK		;YES.
				;NO. GET BUFFER FULL.

INPUT:	.READW	#EMTBLK, ICHAN, #IN.BUF, #IBFSIZ/2, INBLK

	BCC	10$
	CMPB	#1,	@#52
	BLO	5$		;CHAN NOT OPEN, TRY NEXT FILE
	BEQ	7$
5$:	CLR	INBLK		;EOF SEEN (OR NOT OPEN)
	INC	ICHAN		;TRY NEXT CHAN IN LINE
	CMPB	#10,	ICHAN	;INPUT CHANNELS GO FROM 3-10
	BHIS	INPUT		;STILL A CHANCE
	BR	FINEOF		;DONE 'EM ALL
7$:	JMP	RDERR3

10$:	INC	INBLK
	MOV	#IBFSIZ, IBFCTR
	MOV	#IN.BUF-1, IBFPTR
FINOK:	INC	IBFPTR		;POINT TO CHARACTER
	MOVB	@IBFPTR, R1	;NO.  GET CHAR.
	BEQ	FIN		;IGNORE NULLS
	TST	PEEK.F		; PEEKING?
	BEQ	2$		; NO
	CLR	PEEK.F		; CLEAR IT RIGHT OFF
	CMPB	R1,#15		; A <CR>?
	BEQ	1$		; YES
	CMPB	R1,#C.SEMI	; OR A SEMI-COLON
	BNE	2$		; NO
1$:	DEC	IBFPTR		; RESET PTR
	INC	IBFCTR		; AND THIS ONE
2$:	CMP	R1,#177		;AND RUBOUTS
	BEQ FIN			;GET ANOTHER
	RTS R5			;RETURN CHARACTER

FINEF1:	MOV EOFPTR,R1		;INITIAL EOF POINTER
	MOV	R1,INEOFP
	DEC INEOFP
FINEOF:	INC INEOFP		;GET LITERAL CHARACTER
	MOVB @INEOFP, R1
	BEQ FINEF1		;IF NONE, RESTART LITERAL
	RTS R5			;NO.  RETURN CHARACTER

EOFPTR:	.WORD EOFDAT-1
EOFDAT:	.BYTE C.CR,C.LF,C.EOF,0
	.EVEN
;THIS ROUTINE OUTPUTS THE CURRENT LINE BUFFER

OUTPUT:	TST	OBFCTR
	BEQ	10$
5$:	CLRB	@OBFPTR		;CLEAR PARTIAL BUFFER TO NULLS
	INC	OBFPTR
	DEC	OBFCTR
	BNE	5$

.IF	EQ,DBLBUF
10$:	.WRITW	#EMTBLK, OCHAN, #OU.BF1, #OBFSIZ/2, OUTBLK
	BCS	20$
15$:	INC	OUTBLK
	MOV	#OBFSIZ, OBFCTR
	MOV	#OU.BF1, OBFPTR
	RTS	R5
.IFF
10$:	.WAIT	OCHAN
	BCS	17$
12$:	MOV	R1,	-(SP)
	MOV	OBFSWT,	R1
	.WRITE	#EMTBLK, OCHAN, OB(R1), #OBFSIZ/2, OUTBLK
	BCS	20$
15$:	ADD	#2,	R1
	BIC	#^C<2>,	R1
	MOV	OB(R1),	OBFPTR
	MOV	R1,	OBFSWT
	MOV	(SP)+,	R1
	MOV	#OBFSIZ,	OBFCTR
	INC	OUTBLK
	RTS	R5
17$:	TSTB	@#52
	BEQ	12$			;IF CHAN NOT OPEN, IGNORE
	BR	WRERR3			;HARDWARE ERROR!
.ENDC

20$:	CMPB	#1,	@#52
	BLO	15$
	BEQ	WRERR3
	.PRINT	#..209
	BR	RUNOFF
;READ WORD OF SIXBIT INTO A FROM TYI

SIXBRL:	JSR R5,TYI		;GET A CHARACTER
	CMP	R1,#'Z		;LETTER?
	BGT ..171
	CMP	R1,#'A		; ..
	BGE SIXBR1		;YES
..171:	CMP	R1,#'9		;DIGIT?
	BGT ..168
	CMP	R1,#'0		; ..
	BLT	..168
SIXBR1:	SUB #40,R1		;MAKE SIXBIT
	TST B			;ROOM IN ANSWER?
	BEQ SIXBRL
	MOVB	R1, R2		;FIX UP LATER
	BR SIXBRL		;LOOP

;READ CHARACTER FROM TTY.  CONVERT ALTMODES, LC, DISCARD CR AND NULL

TYI:	.TTYIN
	MOV	R0,	R1
	CMP	R1,#172		;LOWER CASE?
	BGT ..164
	CMP	R1,#141		; ..
	BLT ..164		;NO
	BIC #40,R1		;YES, MAKE UPPER
..164:	CMP	R1,#15		;CARRIAGE RETURN?
	BEQ TYI
	TST	R1		;OR NULL?
	BEQ TYI			;YES.  DISCARD.
	CMP	R1,#176		;ALTMODE?
	BEQ ..167
	CMP	R1,#175		; ..
	BNE ..168
..167:	MOV #33,R1		;YES.  MAKE ESCAPE.
..168:	RTS R5			;RETURN CHARACTER


YESNO:	.TTYIN
	CMP R0, #'Y		;IS FIRST CHAR A Y?
	BEQ ..175
	ADD #6,R5		;NO.  SKIP.
..175:	JSR	PC,	TTSKIP
	RTS R5			;YES.  DON'T SKIP.

WRERR3:	.PRINT	#..176
	BR	RUNOFF		;RESTART

RDERR3:	.PRINT	#..177
	BR	RUNOFF		;RESTART
EXPERR:
EXPAND:	.PRINT	#..193
	JMP ENDFIL

DECTYO:	MOV	R3,	-(SP)
	CLR	R3
1$:	INC	R3
	SUB	#10., (SP)
	BGE	1$
	ADD	#60+10., (SP)
	DEC	R3
	BEQ	2$
	JSR	R5,	DECTYO
2$:	.TTYOUT	(SP)+
	RTS	R5

TTSKIP:	.TTYIN
	CMP	R0,	#12		;SKIP TO LINEFEED
	BNE	TTSKIP
	RTS	PC
.SBTTL INITIALIZATION

RESTRT:	BR	RUNOFF	;MONITOR RESTARTS HERE
	.GLOBL	START
START:	.PRINT	#VERMES		;SIGN ON
	BIS	#20000,@#44	;SET RE-ENTER BIT IN JSW
RUNOFF:	.RCTRLO		;TURN ON TERMINAL PRINTING
	MOVB	#3,	ICHAN	;INITIAL INPUT CHANNEL
	CLRB	OCHAN		;INITIAL OUTPUT CHANNEL
	MOV #-1,GCSCH		;NO SAVED CHARACTER
	MOV #-1,ULMCH		; ..
	MOV #INLPG, R2		;INITIAL LENGTH OF PAGE
	MOV	R2,PNLPG
	MOV	R2,NLPG
	MOV #IRMRG, R2		;INITIAL RIGHT MARGIN
	MOV	R2,PRMRG
	MOV	R2,RMARG
	MOV #ILMRG,LMARG	;INITIAL LEFT MARGIN
	MOV #40,CAS		;INITIAL CASE SETTING IS LOWER
	MOV #1,PAGENO		;INITIAL PAGE NUMBER
	MOV #1,NSPNG		;INITIAL SPACING
	MOV #5,PARIND		;INITIAL PARAGRAPH INDENTING
	CLR TTLP1		;NO TITLE TO START WITH
	CLR TTLP2
	CLR STTLP1		;CLEAR SUBTITLE TOO
	CLR STTLP2		; ..
	CLR	YEAR		;NO DATE SET YET
	CLR LINEC		;START AT TOP OF PAGE
	CLR INDCT		;AND LEFT OF PAPER
	CLR NTABS		;NO TABS YET
	CLR FOOTC		;NO FOOTNOTE LINES HELD YET
	CLR XFIRST		;NOTHING IN THE INDEX
.IIF	NE,HYP	CLR HYPH	;NO HYPHENATION ASSUMED
	MOV #LINBF, R4		;INITIALIZE LINE INPUT POINTER
	JSR R5,CSP
	MOV	R2,LNIN1		;STORE.
	MOV R2,	LNIN2		; ..
	CLR IBFCTR		;SET CHARACTER COUNTS
.IIF	NE,DBLBUF	CLR	OBFSWT	;SET TO FIRST OUTPUT BUFFER
	MOV #OBFSIZ,	OBFCTR	;SET CHARACTER COUNTS
	MOV #IN.BUF-1,	IBFPTR	;INITIALIZE POINTERS
	MOV #OU.BF1,	OBFPTR	;INITIALIZE POINTERS
SETUP0:	MOV	#JUSTF+PJUSTF+FILLF+FFDSW+NUMBF,F.1	;INITIAL FLAGS
	CLR	LOWPAG		;SET PAGE LIMITS TO 0
	MOV	#-1,HGHPAG	; AND INFINITY
	MOV	#66.,HWPLN	;DEFAULT VALUE FOR HARDWARE PAGE LENGTH
	MOVB	#C.LPUS,ULCHAR	;SET DEFAULT UNDERLINE CHAR.
	CLRB	ULNEXT		; AND CLEAR U:S FLAG
	MOV	@#42, SP	;RESTORE STACK
	.SRESET			;UNLOAD ODD HANDLERS, ETC
.IIF	NE,DBLBUF	.QSET	#IOQUE, #2	;ADD 2 ELEMENTS TO IO QUEUE
	.CSIGEN	LIMIT+2,#DEFEXT,#0	;CALL CSI
	BCC	CC		;CSI OK
	MOVB	@#52,R1		;ILLEGAL CSI, TELL USER WHY
	BEQ	ICERR1		;ILLEGAL COMMAND
	CMPB	R1,#1
	BEQ	RDERR2		;ILLEGAL DEVICE
	CMPB	R1,#3
	BEQ	WRERR2		;DEVICE FULL
	CMPB	R1,#4
	BNE	ICERR1		;ILLEGAL ERROR
	BR	WRERR1		;NO INPUT FILE
CC:	MOV	R0,JOBFF	;SAVE START OF FREE AREA
	CLR	INBLK		;INITIALIZE INPUT/OUTPUT BLOCK NBRS
	CLR	OUTBLK
	MOV	(SP)+,R1	;GET SWITCH COUNT GIVEN BY CSI
EE:	BEQ	RNGO		;NO SWITCHES GIVEN
	MOV	(SP)+,R3	;GET SWITCH
.IF	NE,HYP
	CMPB	R3,	#'H	;HYPHENATE?
	BEQ	10$		;SET HYPHENATE
	.ENDC
	CMPB	R3,	#'F
	BEQ	30$		;SIMULATE FORMFEED
	CMPB	R3,	#'P
	BEQ	40$		;PAUSE BETWEEN PAGES
	CMPB	R3,	#'U
	BEQ	50$		;FIGURE OUT UNDERSCORE
	CMPB	R3,	#'L
	BEQ	60$		;PAGE LIMIT OPTION
	CMPB	R3,	#'?
	BEQ	70$		;IF HELP NEEDED
	BR	ICERR1		;BAD SWITCH = ILLEGAL COMMAND
2$:	TST	R3		;SEE IF SWITCH HAD A VALUE
	BGE	5$		;IF NOT
	TST	(SP)+		;IF SO, IGNORE IT
5$:	DEC	R1		;COUNT SWITCHES
	BR	EE		;CONTINUE

.IF	NE,HYP
10$:	MOV	SP,	HYPH		;SET HYPHENATE
	BR	2$
	.ENDC
30$:	BIC	#FFDSW, F.1		;SIMULATE FF
	TST	R3		;SEE IF VALUE FOR FORM LENGTH
	BPL	5$		; NO,USE DEFAULT OF 66.
	MOV	(SP)+,R3	;GET VALUE
	CMP	R3,#15.		;SHOULD HAVE AT LEAST 15. LINES/PAGE
	BLO	ICERR1		; TOO SHORT, TOO BAD
	MOV	R3,HWPLN	;  SET HARDWARE PAGE LENGTH VALUE
	BR	5$		;GO LOOK FOR ANOTHER SWITCH
40$:	BIS	#PAUSF, F.1		;PAUSE BETWEEN PAGES
	BR	2$
50$:	TST	R3			;SEE IF UNDERSCORE HAD OPTION
	BGE	5$			;IF NO
	MOV	(SP)+,	R3		;IF YES, GET IT
	CMP	R3,	(PC)+
	.RAD50	/B/
	BNE	52$
	BIS	#ULBSF+ULMODE, F.1
	BR	5$
52$:	CMP	R3,	(PC)+
	.RAD50	/C/
	BNE	54$
	BIS	#ULMODE, F.1
	BR	5$
54$:	CMP	R3,	(PC)+
	.RAD50	/N/
	BNE	55$
	BIS	#ULSUPF, F.1
	BR	5$
55$:	CMP	R3,(PC)+
	.RAD50	/S/
	BNE	ICERR1		;ILLEGAL OPTION
	MOVB	#C.MINS,ULCHAR	; UNDERLINE WITH -
	INCB	ULNEXT		;  ON NEXT LINE
	BR	5$
60$:	TST	R3		;SEE IF LIMIT OPTION HAS VALUE
	BPL	ICERR1		; NO, ILLEGAL COMMAND
	TST	HGHPAG		;-1 INITIALLY
	BPL	61$		; IT'S BEEN SET
	MOV	(SP),HGHPAG	;OK, HERE IS HIGH VALUE
61$:	MOV	(SP)+,LOWPAG	; LOW OR ONLY VALUE
	BR	5$
70$:	.PRINT	#HELPTX
JMPSET:	JMP	SETUP0		;RESTART AFTER CALL FOR HELP
;ERRORS DURING SPECIFICATIONS

ICERR1:	.PRINT	#..207
	BR	JMPSET

RDERR2:	.PRINT	#..208
	BR	JMPSET

WRERR1:	.PRINT	#..210
	BR	JMPSET
WRERR2:	.PRINT	#..209
	BR	JMPSET

;HERE WHEN OPTIONS ALL SPECIFIED

RNGO:	.SETTOP	#-2		;ASK FOR ALL CORE
	MOV	R0,JOBREL	; TAKE WHAT WE CAN GET
	MOV JOBFF, R4		;GET FREE AREA
	MOV	R4,XTOP		;INITIAL INDEX POINTERS
	MOV	R4,XBOT		; ..
	MOV JOBFF, R2
	MOV JOBREL, R4		;GIVE HALF OF CORE TO FOOTNOTES
	ADD	R2,R4		; MIDDLE = TOP + BOTTOM
	ROR	R4		;  /2
	MOV	R4,FOOTBF		;SAVE FOR COMPARISON LATER
	JSR R5,CSP		; ..
	MOV	R2,FOOTP1		;STORE
	MOV B,FOOTP2
	MOV	R2,FOOTP3		;IN BOTH POINTERS
	MOV B,FOOTP4
	BIT #FFDSW,F.1		;FORMFEED OR LF'S?
	BEQ RNG1			;LINEFEEDS, REQUEST POSITIONING
	MOV #C.FF,R1		;OUTPUT FORMFEED
	JSR R5,FOUT
RNG2:	JSR R5,LINSET		;SET UP FOR LINE
	MOV #5, R2		;NO TITLE YET, SO SKIP HEADING AREA
	JSR R5,SKIPN		; ..
	JMP LGO			;AND INTO MAIN LOOP, LINE INPUT

RNG1:	.PRINT	#RNGM1		;ASK FOR POSITIONING
	JSR	PC,	TTSKIP	;SKIP TO LINEFEED
	BR RNG2			;AND GO.

ENDFIL:	JSR R5,OUTNJ		;FINISH LAST LINE
	JSR R5,FORM		;TO TOP OF FORM
ENDFI2:	CMP OBFCTR, #OBFSIZ	;CHECK FOR PARTIAL LINE
	BEQ 10$
	JSR R5,OUTPUT		;FLUSH IT

10$:	.WAIT	OCHAN
	.CLOSE	OCHAN
	.CLOSE	ICHAN
	JMP RUNOFF		;IN CASE OF CONTINUE
	.CSECT	STRING		;PUT IN WITH COMMAND STRINGS
	.NLIST	BEX
VERMES:	.ASCIZ /RT-11 RUNOFF C00-09/
..193:	.ASCIZ <15><12>/?NOT ENOUGH CORE/
..523:	.ASCIZ / ./
CRLFM:	.BYTE 15,12,0
ILCMM:	.ASCIZ /?ILLEGAL COMMAND: /
TTL:	.ASCII	/?TITLE/<200>
STTL:	.ASCII	/?SUBTITLE/<200>
INDX:	.ASCII	/?INDEX ENTRY/<200>
INLINE:	.ASCII	/?INPUT LINE/<200>
TOOBIG:	.ASCII	/ TOO LONG /<200>
ILCMM2:	.ASCII /ON OUTPUT PAGE  /<200>
JUSRM1:	.ASCIZ /?CAN'T JUSTIFY LINE:  /
PGTXT:	.BYTE	120,141,147,145,40,0	;^PAGE
..176:	.ASCIZ <15><12>/?ERROR ON OUTPUT FILE./
..177:	.ASCIZ <15><12>/?ERROR ON INPUT DEVICE/
..207:	.ASCIZ /?ILLEGAL COMMAND/
..208:	.ASCIZ /?ILLEGAL DEVICE/
..209:	.ASCIZ /?DEVICE FULL/
..210:	.ASCIZ	/?FILE NOT FOUND/
HALTM:	.ASCIZ <15><12>/FATAL ERROR IN RUNOFF, ABORTING/
RNGM1:	.ASCII /POSITION PAPER, TYPE RETURN./<200>

HELPTX:	.ASCII	<15><12>!GENERAL COMMAND FORMAT IS:!<15><12>
	.ASCII	!DEV:OUTFIL=DEV:INFIL1,DEV:INFIL2.../S1/S2...!<15><12>
	.ASCII	!INPUT DEFAULT EXTENSION IS .RNO!<15><12>
	.ASCII	!OUTPUT DEFAULT EXTENSION IS .DOC!<15><12>
	.ASCII	!LEGAL SWITCHES ARE:!<15><12>
	.ASCII	%/F!N	- SIMULATE FORMFEEDS WITH LINEFEEDS%<15><12>
	.ASCII	!	  TO MAKE PAGE 'N' LINES LONG (DEFAULT 66)!<15><12>
.IF	NE,HYP
	.ASCII	!/H	- HYPHENATE WORDS AS NECESSARY TO JUSTIFY LINES!<15><12>
	.ASCII	!	 (N.B. HYPHENATION MAY NOT BE CORRECT)!<15><12>
	.ENDC
	.ASCII	%/L!N	- LIMIT - PRINT PAGE N ONLY%<15><12>
	.ASCII	%/L!M!N	- LIMITS - PRINT FROM PAGE M TO N%<15><12>
	.ASCII	!/P	- PAUSE BETWEEN PAGES (TYPE ANY CHAR TO CONTINUE)!<15><12>
	.ASCII	!/U	- UNDERSCORE BY OVERPRINTING LINE (DEFAULT)!<15><12>
	.ASCII	!/U:B	- BACKSPACING UNDERSCORE!<15><12>
	.ASCII	!/U:C	- NON-SPACING UNDERSCORE!<15><12>
	.ASCII	!/U:S	- NEXT LINE UNDERSCORE WITH -!<15><12>
	.ASCII	!/U:N	- SUPPRESS UNDERSCORES!<15><12>
	.ASCIZ	!/?	- PRINT THIS TEXT!<15><12>

MONTBL:	.ASCIZ	/J/<'A!40><'N!40>
	.ASCIZ	/F/<'E!40><'B!40>
	.ASCIZ	/M/<'A!40><'R!40>
	.ASCIZ	/A/<'P!40><'R!40>
	.ASCIZ	/M/<'A!40><'Y!40>
	.ASCIZ	/J/<'U!40><'N!40>
	.ASCIZ	/J/<'U!40><'L!40>
	.ASCIZ	/A/<'U!40><'G!40>
	.ASCIZ	/S/<'E!40><'P!40>
	.ASCIZ	/O/<'C!40><'T!40>
	.ASCIZ	/N/<'O!40><'V!40>
	.ASCIZ	/D/<'E!40><'C!40>

	.EVEN
	.LIST BEX

	.CSECT
RUNEND:	.END	START
                                                                                                                                                                                                                                                                                                                                                                                                    