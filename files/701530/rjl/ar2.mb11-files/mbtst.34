.TITLE MEMORY BREAK REGISTER TESTER
R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
SP=%6
PC=%7

PS=177776

TKS=177560
TKB=177562
TPS=177564
TPB=177566

MBCSR=0		;CONTROL AND STATUS
MBXHGH=2	;HIGH BITS OF X REGISTER
MBXLOW=4	;LOW BITS OF X REGISTER
MBYHGH=6	;HIGH BITS OF Y REGISTER
MBYLOW=10	;LOW BITS OF Y REGISTER
MBHHGH=12	;HIGH BITS OF HISTORY REGISTER
MBHLOW=14	;LOW BITS OF HISTORY REGISTER
MBHCNT=16	;HISTORY MEMORY COUNTER

;BITS IN MBCSR
INTE=100
AFRZ=200
XAYRT=400	;X<A<Y READ TRAP
XAYWT=1000	;X<A<Y WRITE TRAP
NOINIT=2000	;IGNORE INIT
INTEAO=4000	;INTERRUPT ON ALMOST OVERFLOW

;BITS IN MBXHGH AND MBYHGH
REDTRP=4	;READ TRAP BIT
WRTTRP=10	;WRITE TRAP BIT

;BITS IN MBHHGH
WRTBIT=4	;WRITE BIT IN HISTORY MEMORY HIGH BITS

;TRAP VECTORS
HLT=3		; "HALT" IS A BREAKPOINT
.=0
	HLT
	HLT
BEBRV:	.+2
	HLT
ILLBRV:	.+2
	HLT
BPTBRV:	.+2
	HLT
IOTBRV:	.+2
	HLT

.=200
	JMP FINDEM

;RANDOM STORAGE
.=600
PDL:
.=1000
	JMP FINDEM	;GO FIND ANY MB11S AND TEST THEM
	JMP TESTEM	;GO TEST ANY WE'RE SET UP FOR

REGTAB:	REGTB		;TABLE OF REGISTER ADDRESSES
REGTB:	.BLKW 20
VECTAB:	VECTB		;TABLE OF VECTOR ADDRESES
VECTB:	.BLKW 20
NMB11S:	1		;NUMBER OF MB11S WE'VE FOUND

IBITS:	3417		;CONTROL REGISTER
	17		;X HIGH
	177776		;X LOW
	17		;Y HIGH
	177776		;Y LOW
	77		;HISTORY MEMORY COUNTER

FINDEM:	RESET
	MOV #PDL,SP
	CLR NMB11S
	MOV #REGTB,REGTAB
	MOV #VECTB,VECTAB
	MOV #IOTBRV+4,R0
	MOV #100-5,R1	;NUMBER OF TRAP VECTORS TO INIT
	MOV #IOTBRV+6,R2
TRPINT:	MOV R2,(R0)+	;PUT .+2 INTO PC WORD OF TRAP
	MOV #4,(R0)+	;PUT IOT INSTRUCTION IN PS PART
	CMP (R2)+,(R2)+	;ADD 4 TO R2
	DEC R1		;COUNT DOWN
	BNE TRPINT
	MOV #NONEX,BEBRV
	CLR BEBRV+2
	MOV #160000,R0	;FIRST I/O LOCATION
MBFIND:	CLR @REGTAB
	CLR @VECTAB
	MOV R0,R1	;THE PLACE TO LOOK
	MOV #10,R2	;NUMBER OF REGISTERS TO LOOK FOR
FINDLP:	TST (R1)+	;NON-EX WILL TRAP OUT HERE
	DEC R2
	BNE FINDLP
	MOV R0,R1	;LETS TAKE ANOTHER LOOK AT THAT
	ADD #12,R1
	MOV #5,R2
FINCLP:	CLR -(R1)	;CLEAR A REGISTER
	TST (R1)	;DID IT CLEAR?
	BNE NOTHER	;NOPE, CAN'T BE AN MB11
	DEC R2
	BNE FINCLP
	MOV #REDTRP,MBXHGH(R0)	;SET TO COMPARE ON READ ON X (=0)
	TST 0		;SHOULD CAUSE THE COMPARE
	CMP #AFRZ,MBCSR(R0)	;DID IT?
	BNE NOTHER	;NO, CAN'T BE ONE
	MOV #INTCHK,IOTBRV
	MOV BPTBRV,-(SP)
	MOV BPTBRV+2,-(SP)
	MOV #BPTBRV+2,BPTBRV
	MOV #4,BPTBRV+2
	CLR PS			;MAKE SURE WE CAN INTERUPT
	BIS #INTE,MBCSR(R0)	;THIS SHOULD CAUSE INTERRUPT
INTHER:	240		;GIVE IT A CHANCE
	240
TOHER:	MOV (SP)+,BPTBRV+2	;IT DIDN'T!
	MOV (SP)+,BPTBRV
NOTHER:	ADD #20,R0	;THIS ISN'T ONE, GO TO NEXT PLACE
	BNE MBFIND	;UNLESS PAST ALL I/O REGSITERS
	JMP TESTEM	;GO CHECK ALL THE ONES WE FOUND

NONEX:	CMP (SP)+,(SP)+	;GOT A BUS ERROR LOOKING FOR MB11
	BR NOTHER	;SO NONE HERE!

INTCHK:	MOV (SP)+,R4	;SAVE THE PLACE WE TRAPPED TO
	TST (SP)+	;FLUSH PS WE TRAPED WITH
	SUB #4,R4	;GET REAL VECTOR ADDRESS
	MOV (SP),2(SP)	;FLUSH THE PS WITH THE PC
	TST (SP)+
	CMP #INTHER,(SP)	;SEE IF INT CAME FROM THE RIGHT PLACE
	BHI BADINT	;BEFORE INTHER IS A BAD PLACE
	CMP #TOHER,(SP)	;SO IS AFTER TOHER
	BLO BADINT
	MOV R0,@REGTAB	;THIS IS AN MB11, SAVE IT'S REGISTER ADDRESS
	MOV R4,@VECTAB	;AND VECTOR ADDRESS
	ADD #2,REGTAB
	ADD #2,VECTAB
	INC NMB11S
	TST (SP)+	;FLUSH THAT PS
	BR TOHER	;RESTORE BPT VECTOR AND TRY NEXT ONE

BADINT:	JSR R5,TYPE
	.ASCIZ /BAD INTERUPT FROM /
	.EVEN
	JSR PC,OTYPE	;ADDRESS TRAPED FROM IS ON TOP OF STACK	
	JSR R5,TYPE
	.ASCIZ / THROUGH VECTOR /
	.EVEN
	MOV R4,-(SP)	;SAVE BAD VECTOR
	JSR PC,OTYPE
	JSR PC,CRLF
	HLT
	RTS PC		;ATTEMPT TO 




;TEST ALL THAT WE KNOW ABOUT
TESTEM:	RESET
	MOV #PDL,SP
	MOV #REGTB,REGTAB	;RESET TABLE POINTERS
	MOV #VECTB,VECTAB
TESTLP:	MOV @REGTAB,R0		;REGISTER ADDRESS STAYS IN R0
	BEQ TESTEM
	JSR R5,TYPE
	.ASCIZ /TESTING MB11 @ /
	.EVEN
	MOV R0,-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / VECTOR /
	.EVEN
	MOV @VECTAB,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	JSR PC,VECCLR	;MAKE VECTOR GO AWAY

;TEST CLEARING AND SETTING OF BITS IN THE CONTROL REGISTER
CNTTST:	MOV R0,R1	;COPY POINTER TO MB11
	ADD #12,R1
	MOV #5,R2	;5 REGISTERS TO CLEAR
CNTTS1:	CLR -(R1)	;TRY TO CLEAR IT
	TST (R1)	;CLEAR?
	BEQ CNTTS2	;YUP
	JSR R5,TYPE
	.ASCIZ /CAN'T CLEAR /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,SPACE
	MOV (R1),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
CNTTS2:	DEC R2
	BNE CNTTS1

;TEST SETTING OF INDEPENDENT BITS
	MOV #IBITS,R2
	MOV R0,R1
	MOV #5,R3
SLOOP:	JSR PC,SETLOP	;GO TEST IT
	CMP (R2)+,(R1)+	;NEXT BITS AND REGISTER
	DEC R3
	BNE SLOOP	;TRY THAT ONE
	MOV R0,R1
	ADD #MBHCNT,R1	;POINT TO HISTORY COUNTER
	MOV #1,MBCSR(R0)	;FREEZE WHILE DOING THIS ONE
	CLR (R1)	;AND CLEAR IT FIRST
	JSR PC,SETLOP	;TRY IT OUT
	CLR (R1)	;CLEAR IT TO MAKE SURE WE DON'T CAUSE INTERUPT
	MOV #INTEAO,R4
	MOV R0,R1	;TRY TO SET ALMOST OVERFLOW IN ENABLE IN CSR	
	JSR PC,SETLO1
	CLR (R0)	;MAKE SURE NO ADDRESS COMPARE SET
	MOV #INTE,R4
	JSR PC,SETLO1	;TEST INTERUPT ENABLE
	CLR (R1)
	MOV #5517,(R0)	;SET ALL BUT NOINIT
	RESET		;AND INIT
	TST (R0)	;SHOULD BE CLEAR
	BEQ TSTNI1	;IS
	JSR R5,TYPE
	.ASCIZ /INIT DIDN'T CLEAR CSR /
	.EVEN
	MOV (R0),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTNI1:	MOV #7517,(R0)	;SET ALL WITH NO INIT
	RESET		;SHOULDN'T DO ANYTHING
	CMP #7517,(R0)	;CHECK
	BEQ TSTNI2	;RIGHT
	JSR R5,TYPE
	.ASCIZ /INIT CLEARED BITS WITH NOINIT SET /
	.EVEN
	MOV (R0),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTNI2:	CLR (R0)
	JMP TSTHMC	;GO TEST THE HISTORY MEMORY COUNTER

SETLOP:	MOV #1,R4
	MOV (R2),(R1)	;TRY TO SET ALL THE BITS
	CMP (R2),(R1)	;ALL SET?
	BEQ SETLO4	;YUP
	JSR R5,TYPE
	.ASCIZ /BITS /
	.EVEN
	MOV (R2),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / DON'T SET IN /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,SPACE
	MOV (R1),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
SETLO4:	CLR (R1)
	JSR PC,SETLO1
SETLO2:	ROL R4		;NEXT BIT
	BNE SETLO1
	RTS PC

SETLO1:	BIT R4,(R2)	;IS THIS AN INDEPENDENTLY SETABLE BIT?
	BEQ SETLO5	;NO, IGNORE
	BIS R4,(R1)	;TRY TO SET IT
	BIT R4,(R1)	;SET?
	BNE SETLO3	;YUP
	JSR R5,TYPE
	.ASCIZ /CAN'T SET /
	.EVEN
	JSR PC,BITTYP
SETLO3:	BIC R4,(R1)	;TRY TO CLEAR IT
	BIT R4,(R1)	;CLEAR?
	BEQ SETLO5	;WIN
	JSR R5,TYPE
	.ASCIZ /CAN'T CLEAR /
	.EVEN
	JSR PC,BITTYP
SETLO5:	RTS PC


BITTYP:	MOV R4,-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / IN /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	RTS PC

TSTHMC:	CLR (R0)	;CLEAR THE CSR
	MOV R0,R1	;COPY ADDRESS
	ADD #MBHCNT,R1	;MAKE A POINTER TO THE HISTORY COUNTER
	MOV #6,R2	;SIX REFERENCES PER LOOP
	MOV #24,R3	;24 LOOPS=170 REFERENCS
	MOV #2,R4	;STARTS AT 2
	CLR (R1)	;CLEAR COUNTER
TSTHC1:	CMP R4,(R1)	;IS IT RIGHT?
	BEQ TSTHC2	;YUP
	JSR R5,TYPE
	.ASCIZ /HISTORY COUNTER LOST AT /
	.EVEN
	MOV R4,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	BR TSTHC3	;GIVE UP ON THIS TEST
TSTHC2:	ADD R2,R4
	DEC R3
	BNE TSTHC1

;TEST THE FREEZE BITS IN TH ECSR
TSTHC3:	MOV #4,R2	;THERE ARE 4 OF THEM
	MOV #1,R3
TSTHCF:	MOV R3,(R0)	;SET A FREEZE BIT
	CMP (R1),0(R1)	;IS IT FROZEN?
	BEQ TSTHF1	;YUP
	JSR R5,TYPE	
	.ASCIZ /DIDN'T FREEZE WITH BIT /
	.EVEN
	MOV R3,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTHF1:	ROL R3		;NEXT BIT
	DEC R2
	BNE TSTHCF
	CLR (R0)

;TEST FREEZING ON ADDRESS COMPARE
	MOV #REDTRP,MBXHGH(R0)	;SET COMPARE ON READ
	CLR MBXLOW(R0)		;OF LOCATION 0
	TST 0			;ACTIVATE COMPARE
	CLR MBXHGH(R0)
	BIT #AFRZ,(R0)		;DID THE COMPARE HAPPEN
	BNE TSTHF2		;YUP
	JSR R5,TYPE
	.ASCIZ /0 COMPARE DIDN'T SET AFRZ/
	.EVEN
	JSR PC,CRLF
TSTHF2:	CMP (R1),0(R1)		;IS IT FROZEN?
	BEQ TSTHF3		;YUP
	JSR R5,TYPE
	.ASCIZ /0 COMPARE DIDN'T FREEZE/
	.EVEN
	JSR PC,CRLF

TSTHF3:	BIT #100,(R1)	;DID OVERFLOW STAY SET?
	BNE TSTHF4	;YUP
	JSR R5,TYPE
	.ASCIZ /HISTORY COUNT OVERFLOW DIDN'T STAY SET/
	.EVEN
	JSR PC,CRLF

;TEST THAT OVERFLOW BEING SET AND INTERUPT ON ALMOST OVERFLOW CAUSE FREEZE
TSTHF4:	MOV #340,PS	;DON'T ALLOW INTERUPTS
	MOV #INTEAO,(R0)	;SET INTERUPT ON ALMOST OVERFLOW
	CMP (R1),0(R1)	;FROZEN?
	BEQ TSTHF5	;YUP
	JSR R5,TYPE
	.ASCIZ /INT ON ALMOST OVERFLOW AND OVERFLOW DIDN'T FREEZE/
	.EVEN
	JSR PC,CRLF
TSTHF5:	CLR (R0)
	CLR PS		;ENABLE INTERUPTS

;TEST THAT INTERUPT ON ALMOST OVERFLOW INTERUPTS
	MOV #1,(R0)	;FREEZE
	CLR (R1)	;START HISTORY COUNTER AT 0
	MOV #34,R2
	MOV @VECTAB,R3
	MOV #TSTHOI,(R3)	;SET UP INTERUPT VECTOR
	MOV #INTEAO,(R0)	;SET INTERRUPT ON ALMOST OVERFLOW
	DEC R2
	BNE .-2		;THIS LOOP WILL DO 70 MEMORY REFERENCES
	CLR (R0)	;INTERRUPT SHOULD PREVENT US GETTING HERE
	JSR R5,TYPE
	.ASCIZ /INTERRUPT ON ALMOST OVERFLOW DIDN'T/
	.EVEN
	JSR PC,CRLF
	BR TSTHO1
TSTHOI:	CMP (SP)+,(SP)+	;FLUSH INTERUPT STACK WORDS
TSTHO1:	JSR PC,VECCLR	;RESET VECTOR

;TEST THE HISTORY MEMORY
	MOV #RTIAD,BEBRV	;MAKE NXM A NOP
	MOV R0,R1		;COPY DEVICE POINTER
	CLR (R0)
	ADD #MBHCNT,R1
	MOV #77,R3		;WE WILL TEST EVERY ADDRESS FROM 0 TO 157776
TSTHM1:	CLR R5
	MOV #70000,R2		;FOR EVERY HISTORY MEMORY LOCATION
	INC (R0)		;START WITH HISTORY FROZEN
TSTHM2:	MOV R3,R4		;MEMORY LOCATION TO TEST
	SUB #1,R4		;GO BACK ONE
	MOV R4,(R1)		;SET COUNTER THERE
	CLR (R0)		;ENABLE HISTORY
	TST (R5)		;TEST THE MAGIC LOCATION TO PUT IT INTO HISTORY
				;THE FETCH OF THE TEST PUTS COUNTER AT RIGHT PLACE
	INC (R0)		;FREEZE
	MOV R3,(R1)		;SET COUNTER BACK
	TST MBHHGH(R0)		;SHOULD BE NO HIGH BITS
	BEQ TSTHM3		;YUP
	JSR R5,TYPE
	.ASCIZ /HIGH BITS SET IN HISTORY MEMORY /
	.EVEN
	JSR PC,HISTYP		;TYPE WHAT'S WRONG
TSTHM3:	CMP R5,MBHLOW(R0)	;ARE LOW BITS RIGHT?
	BEQ TSTHM4		;YUP
	JSR R5,TYPE
	.ASCIZ /LOW BITS IN HISTORY MEMORY ARE WRONG /
	.EVEN
	JSR PC,HISTYP
TSTHM4:	ADD #2,R5	;GO TO NEXT ADDRESS
	DEC R2		;TILL WE RUN OUT
	BNE TSTHM2
	DEC R3		;GO TO NEXT HISTORY LOCATION
	BGE TSTHM1	;TILL WE RUN OUT OF THOSE TOO
	MOV #BEBRV+2,BEBRV
	
;NEXT TEST HIGH BITS OF HISTORY MEM AND WRITE BITS
	MOV R0,R0TAB1
	MOV R0,R0TAB2
	MOV R0,R0TAB3
	MOV #3,HPHASE	;PHASE COUNTER
TSTHH1:	MOV #1,(R0)	;FREEZE
	MOV #16.,R4	;ITERATION COUNT
	MOV HPHASE,(R1)	;STARTING LOC
	CLR R1
	CLR (R0)	;UNFREEZE
TSTHH2:	MOV R1,(R0)	;SET WRITE AND HIGH BITS IN HISTORY MEMORY
TSTHH3:	DEC R4		;ITERATION COUNT
TSTHH4:	BNE TSTHH2
TSTHH5:	INC (R0)	;FREEZE HISTORY
	MOV R0,R1
	ADD #MBHCNT,R1
	MOV HPHASE,R4
	ADD #103,R4
	CMP R4,(R1)	;THIS IS WHERE I THINK THE HISTORY POINTER SHOULD BE
	BEQ TSTHH6
	JSR R5,TYPE
	.ASCIZ /BAD HISTORY POINTER AFTER TEST /
	.EVEN
	MOV (R1),-(SP)
	JSR PC,OTYPE
	JSR R5,TYPE
	.ASCIZ / SHOULD BE /
	.EVEN
	MOV R4,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTHH6:	MOV HPHASE,(R1)	;START CYCLE AGAIN
	MOV #HISTB1,R5	;FIRST CYCLE SHOULD BE SPECIAL
	MOV #16.,R4	;16 CYCLES
	MOV #4,R2
	BR TSTHH8

TSTHH7:	MOV #HISTAB,R5
	MOV #4,R2
TSTHH8:	MOV (R1),R3	;SAVE FOR ERROR TYPE OUT
	CMP (R5)+,MBHHGH(R0)	;HIGH PART RIGHT?
	BEQ TSTH.1		;YUP
	JSR R5,TYPE
	.ASCIZ /HIGH PART WRONG /
	.EVEN
	JSR PC,HISTYP
TSTH.1:	CMP (R5)+,MBHLOW(R0)	;LOW PART RIGHT?
	BEQ TSTH.2
	JSR R5,TYPE
	.ASCIZ /LOW PART WRONG /
	.EVEN
	JSR PC,HISTYP
TSTH.2:	INC (R1)
	DEC R2
	BNE TSTHH8
	DEC R4
	BNE TSTHH7
	DEC HPHASE
	BGE TSTHH1

	JMP TSTXY

RTIAD:	RTI

HISTYP:	MOV R3,-(SP)
	JSR PC,OTYPE
	JSR PC,SPACE
	MOV MBHHGH(R0),-(SP)
	JSR PC,OTYPE
	JSR PC,SPACE
	MOV MBHLOW(R0),-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	RTS PC

HISTAB:	.WORD	0 , TSTHH2 , 7
R0TAB1:	.WORD	0 , 0 , TSTHH3 , 0 , TSTHH4
HISTB1:	.WORD	0 , TSTHH5 , 3
R0TAB2:	.WORD	0 , 7
R0TAB3:	.WORD	0 , 0 , TSTHH4
HPHASE:	.WORD	0

TSTCMR:	MOV #70000,R2
	CLR R3		;ADDRESS TO USE
HERE1:	MOV #REDTRP,(R1)	;ENABLE READ COMPARES
TSTCM1:	MOV R3,2(R1)	;SET THE COMPARE ADDRESS
	CLR (R0)
	BIT #AFRZ,(R0)	;COMPARE SET?
	BEQ TSTCM2	;NOT YET	
	CMP #HERE1,R3	;COMPARE SET BY CODE MAYBE?
	BHI TSTCM3	;NOPE NOT YET
	CMP #THERE1,R3	;MAYBE?
	BHI TSTCM2	;PROBABLY SO
TSTCM3:	JSR R5,TYPE
	.ASCIZ /COMPARE SET WHEN IT SHOULDN'T BE /
	.EVEN
	JSR PC,CMTYP
TSTCM2:	TST (R3)	;SHOULD SET COMPARE
	BIT #AFRZ,(R0)	;SET?
	BNE TSTCM4
	JSR PC,TYPE
	.ASCIZ /COMPARE NOT SET WHEN IT SHOULD BE /
	.EVEN
	JSR PC,CMTYP
TSTCM4:	ADD #2,R3
	DEC R2
	BNE TSTCM1
THERE1:
;TEST WRITE COMPARE
	MOV 0,R5
	CLR (R1)
	CLR 2(R1)
	CLR (R0)
	MOV #WRTTRP,(R1)
	TST 0		;THIS SHOULDN'T SET WRITE
	BIT #AFRZ,(R0)
	BEQ TSTWR1
	JSR R5,TYPE
	.ASCIZ /WRITE COMPARE SET WHEN IT SHOULDN'T /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTWR1:	MOV R5,0	;WRITE LOCATION 0	
	BIT #AFRZ,(R0)
	BNE TSTWR2
	JSR R5,TYPE
	.ASCIZ /WRITE COMAPRE DIDN'T SET WHEN IT SHOULD /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTWR2:	MOV #3+REDTRP,(R1)	;SET TO READ TRAP ON HIGH BITS
	CLR 2(R1)
	CLR (R0)
	TST 0
	BIT #AFRZ,(R0)
	BEQ TSTHG1
	JSR R5,TYPE
	.ASCIZ /READ COMPARE SET WITH HIGH BITS SET /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTHG1:	MOV #160000,2(R1)
	TST 160000	;SHOULD SET COMPARE	
	BIT #AFRZ,(R0)
	BNE TSTHG2
	JSR R5,TYPE
	.ASCIZ /READ COMPARE DIDN'T SET WITH HIGH BITS SET /
	.EVEN
	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
TSTHG2:	RTS PC

CMTYP:	MOV R1,-(SP)
	JSR PC,OTYPE
	JSR PC,SPACE
	MOV R3,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
	RTS PC


;TEST THE X AND Y COMPARE REGISTERS
TSTXY:	MOV #RTIAD,BEBRV
	MOV R0,R1
	ADD #MBXHGH,R1	;POINT TO THE HIGH REGISTER
	JSR PC,TSTCMR	;TEST A COMPARE REGISTER
	MOV R0,R1
	ADD #MBYHGH,R1	;TEST THE Y REGISTER
	JSR PC,TSTCMR

;TEST THE X<A<Y
	MOV #70000-2,R1	;TEST WITH 0<A<160000
	MOV #2,R2	;R2 IS A
	CLR MBXHGH(R0)
	CLR MBXLOW(R0)
	CLR MBYHGH(R0)
HERE:	MOV #4,MBYLOW(R0)
XAYLOP:	MOV #400,(R0)	;SET THE X<A<Y READ BIT
	TST -2(R2)	;X=A
	TST 2(R2)	;Y=A
	BIT #AFRZ,(R0)	;SHOULDN'T HAVE SET
	BEQ XAYLO1
	CMP R2,#HERE	;UNLESS IN THE CODE RANGE
	BLO XAYLO2	;ITS LOWER	
	CMP R2,#THERE
	BLO XAYLO1	;IT IS IN CODE RANGE, IGNORE SETTING
THERE:
XAYLO2:	JSR R5,TYPE
	.ASCIZ /X<A<Y COMPARE SET WHEN IT SHOULDN'T /
	.EVEN
	MOV R2,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
XAYLO1:	TST (R2)	;NOW IT SHOULD SET
	BIT #AFRZ,(R0)
	BNE XAYLO3
	JSR R5,TYPE
	.ASCIZ /X<A<Y COMPARE DIDN'T SET WHEN IT SHOULD HAVE /
	.EVEN
	MOV R2,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
XAYLO3:	ADD #2,R2
	ADD #2,MBXLOW(R0)
	ADD #2,MBYLOW(R0)
	DEC R1	
	BNE XAYLOP

;TEST WITH VARIOUS COMBINATIONS
	MOV #XAYTTB,R5	;POINTER TO TEST TABLE
XAYTL:	MOV R0,R1
	ADD #MBXHGH,R1	;POINT TO X HIGH PART
	MOV #4,R2
XAYTL1:	MOV (R5)+,(R1)+
	DEC R2
	BNE XAYTL1
	MOV #XAYRT,(R0)
	TST @(R5)+
	JSR PC,XAYTYP
	MOV #XAYWT,(R0)
	MOV R0,@(R5)+	;DO A WRITE
	JSR PC,XAYTYP
	CMP R5,#XAYTTE	;AT END OF TABLE?
	BNE XAYTL

	JMP TSTDNE

XAYTYP:	CMP (R5)+,(R0)
	BEQ XAYTY1
	JSR R5,TYPE
	.ASCIZ /BAD X<A<Y TEST /
	.EVEN
	MOV R5,-(SP)
	JSR PC,OTYPE
	JSR PC,CRLF
XAYTY1:	RTS PC

XAYTTB:	;X HIGH	X LOW	Y HIGH	Y LOW	TST AD	RESULT		WRT AD	RESULT
.WORD	3 ,	160000,	3 ,	160004,	160002,	XAYRT!AFRZ,	160002,	XAYWT!AFRZ
.WORD	2 ,	160000, 3 ,	160002,	160000, XAYRT!AFRZ,	160002,	XAYWT!0
.WORD	1 ,	160000, 3 ,	160002,	160000, XAYRT!AFRZ,	160002,	XAYWT!0
.WORD	0 ,	160000,	3 ,	160002, 160002,	XAYRT!0,	160000,	XAYWT!AFRZ
.WORD	0 ,	PDL ,	2 ,	160002,	2 ,	XAYRT!AFRZ,	160002,	XAYWT!0
.WORD	0 ,	PDL ,	1 ,	0 ,	2 ,	XAYRT!AFRZ,	160000,	XAYWT!0
XAYTTE:




TSTDNE:	JSR PC,VECCLR
	ADD #2,REGTAB
	ADD #2,VECTAB
	JMP TESTLP

VECCLR:	MOV R1,-(SP)
	MOV R2,-(SP)
	MOV @VECTAB,R1		;GET VECTOR ADDRESS OF THIS ONE
	MOV R1,R2
	TST (R2)+
	MOV R2,(R1)+
	MOV #4,(R1)		;CATCH INTERUPTS WE DON'T EXPECT
	MOV (SP)+,R2
	MOV (SP)+,R1
	RTS PC


TYPE:	MOV R4,-(SP)	;SAVE R4
TYPE1:	MOVB (R5)+,R4	;GET A CHAR
	BEQ TYPE2	;ZERO IS END
	JSR PC,TYO	;TYPE IT
	BR TYPE1
TYPE2:	MOV (SP)+,R4
	INC R5
	BIC #1,R5	;MAKE IT EVEN
	RTS R5

CRLF:	MOV R4,-(SP)	;SAVE R4
	MOV #15,R4	;CR
	JSR PC,TYO
	MOV #12,R4	;LF
	JSR PC,TYO
	CLR R4		;NULL
	JSR PC,TYO
	JSR PC,TYO
CRLF1:	JSR PC,TYO
	MOV (SP)+,R4
	RTS PC

SPACE:	MOV R4,-(SP)
	MOV #40,R4
	BR CRLF1

OTYPE:	MOV R4,-(SP)	;SAVE R4
	MOV R3,-(SP)	;AND R3
	MOV R2,-(SP)	;AND R2
	MOV 10(SP),R3	;GET NUMBER TO TYPE OUT
	MOV #6,R2
	ROL R3
	ROL R3
	MOV R3,R4
	ROR R3
	BIC #177776,R4
	BR OTYPE2

OTYPE1:	ROL R3		;ROTATE 4 BITS
	ROL R3
	ROL R3
	ROL R3
	MOV R3,R4	;COPY THING TO TYPE OUT
	ROR R3		;RECOVER BIT FROM CARRY
	BIC #177770,R4	;FLUSH EXTRA BITS
OTYPE2:	ADD #60,R4	;MAKE IT ASCII
	JSR PC,TYO
	DEC R2
	BNE OTYPE1
	MOV (SP)+,R2	;RESTORE R2
	MOV (SP)+,R3	;AND R3
	MOV 2(SP),R4	;GET RETURN ADDRESS
	MOV (SP),4(SP)	;MOVE SAVED VALUE OF R4 OVER NUMBER TO TYPE OUT
	CMP (SP)+,(SP)+	;FLUSH ONE COPY OF R4 AND RETURN ADDRESS
	RTS R4

TYO:	TSTB TPS
	BPL TYO
	MOVB R4,TPB
	RTS PC


.END FINDEM
