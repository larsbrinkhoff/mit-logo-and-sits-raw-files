	TITLE FILE TRANSFER FROM 10 TO 11
A=1
B=2
C=3
D=4
E=5
F=6
TT=14
T=15
11PTR=16
P=17

DBUFL=2000		;LENGTH OF 10 DISK BUFFER
11BUFP==1000		;11 BYTE ADDRESS FOR THE BUFPTR
11FLGW==1004		;BYTE ADDRESS FOR THE FLAG WORD

PDL:	BLOCK 50
FILBLK::
DEVNAM:	SIXBIT /DSK/
FN1:	SIXBIT /@/
FN2:	SIXBIT />/
SNAME:	SIXBIT /11LOGO/
WRTFLG:	0
DBUFP:	0
DBFEND:	0
EOFFLG:	0
BYTCNT:	0

GO:	.VALUE [ASCIZ /:PROCED
/]
START:	MOVE P,[-50,,PDL]
	PUSHJ P,MAP11
FND11:	MOVE A,[105_20.]
	CAME A,FLAGW		;WAIT FOR HIM TO WAVE THE FLAG
	 .HANG
	SETZM FLAGW		;SLAP IT DOWN
	MOVEI B,1
	.SLEEP B,
	CAME A,FLAGW		;DID HE COME BACK?
	 JRST FND11		;NOPE
	MOVE A,[106_20.]	;WAVE AT HIM
	MOVEM A,FLAGW
	MOVEI B,1
	.SLEEP B,
	SKIPE FLAGW		;HE SHOULD SLAP US DOWN NOW
	 JRST FND11
GETFIL:	PUSHJ P,GETBUF
	MOVE D,(A)		;FLAG FOR READ OR WRITE
	MOVEM D,WRTFLG
	MOVE D,A
	ADD D,[441000,,1]
	MOVEI B,FILBLK
	PUSHJ P,RFN"RFN

	MOVE A,[10700,,DBUF-1]
	MOVEM A,DBUFP
	MOVEM A,DBFEND
	SETZM EOFFLG
	MOVEI A,6		;READ
	SKIPE WRTFLG
	MOVEI A,1		;WRITE (UNIT)
	MOVE B,[-1,,777700]
	SETZM FLAGW
	.CALL [ SETZ
		SIXBIT /OPEN/
		4000,,A
		1000,,1
		DEVNAM
		FN1
		FN2
		SETZ SNAME ]
	 JRST OPNFAI
	MOVEM B,FLAGW		;SET THE FLAG WORD IF THE OPEN SUCCEEDED
	SETZM BUFPTR
	SKIPE WRTFLG		;READ OR WRITE?
	 JRST WRTFIL		;WRITE

;this is the loop to send a file to the pdp11
FNDBUF:	PUSHJ P,GETBUF
	MOVE B,(A)		;RECOVER THE COUNT
	LSH B,-26		;PUT IT IN IT'S PLACE
	SETZM BUFPTR		;TELL THE 11 WE HAVE THE BUFFER
	PUSHJ P,FILBUF
	 JRST FNDBUF
	JRST START

;THIS IS THE LOOP TO GET A FILE FROM THE PDP11
WRTFIL:	PUSHJ P,IBUF		;INIT THE OUTPUT TO DISK BUFFER
WRTLOP:	PUSHJ P,GETBUF		;GET A BUFFER TO FILL
	PUSHJ P,OUTBUF		;FILL IT AND GIVE IT TO THE 11
	 JRST WRTLOP		;JUMP BACK IF THAT WASN'T THE LAST BUFFER LOAD
	PUSHJ P,FINFIL
	.CLOSE 1,
	JRST START

OPNFAI:	SETZM BUFPTR
	JRST START

GETBUF:	SKIPN BUFPTR
	 .HANG
	MOVE A,BUFPTR
	LSH A,-6
	ANDI A,177777
	ADDI A,11STRT*2000
	POPJ P,

;MAPS IN ENTIRE 11 AT 11STRT
MAP11:	MOVE A,[602000,,1777]
	MOVEI B,11STRT
	MOVEI C,100
MAPLOP:	.CALL [ SETZ
		SIXBIT /T11MP/
		B
		SETZ A ]
	 .LOSE 1000
	ADD A,[4,,0]
	AOS B
	SOJN C,MAPLOP
	POPJ P,

;THIS IS CALLED WITH COUNT OF PDP10 WORDS IN B, POINTER TO BUFFER IN A
FILBUF:	MOVEI C,1(A)		;COPY POINTER
	SETZM BYTCNT		;VALID BYTES
TRANLP:	SETZ E,
CHRLOP:	PUSHJ P,GCHR		;GET A CHAR
	DPB F,[241000,,E]
	PUSHJ P,GCHR
	DPB F,[341000,,E]
	PUSHJ P,GCHR
	DPB F,[41000,,E]
	PUSHJ P,GCHR
	DPB F,[141000,,E]
	MOVEM E,(C)
	AOS C
	SKIPE EOFFLG
	 JRST [	MOVE C,BYTCNT
		LSH C,4
		MOVEM C,(A)
		AOS (P)
		POPJ P, ]
	SOJN B,TRANLP		;TRAN ANOTHER 4 CHARACTERS
	SUB B,(A)		;GET THE NEGATIVE OF THE COUNT
	MOVEM B,(A)
	POPJ P,

;GETS CHARACTER POINTED TO BY DBUFP
;IF DBUFP = DBFEND, READ IN ANOTHER BUFFER
; IF NOTHING IS READ, SET EOFFLG, AND RETURN A SPACE
;IF EOFFLG IS SET RETURN A SPACE
GCHR:	SKIPE EOFFLG
	 JRST FNDEOF
	MOVE T,DBUFP
	CAMN T,DBFEND
	 JRST NEWBUF
	ILDB F,DBUFP
	AOS BYTCNT
	POPJ P,
NEWBUF:	MOVE T,[-DBUFL,,DBUF]
	.IOT 1,T
	CAMN T,[-DBUFL,,DBUF]
	 JRST FNDEOF
	SOS T
	HRLI T,10700
	MOVEM T,DBFEND
	MOVE T,[10700,,DBUF-1]
	MOVEM T,DBUFP
	JRST GCHR
FNDEOF:	SETOM EOFFLG
	MOVEI F," 
	POPJ P,

OUTBUF:	MOVE B,(A)	;GET THE BYTE COUNT
	LSH B,-24	;PUT IT IN IT'S PLACE
	JUMPE B,OUTEOF	;END OF FILE
	MOVEI C,1(A)	;POINTER TO THE DATA
OUTLOP:	MOVE E,(C)
	SOJL B,OUTEND
	LDB F,[241000,,E]
	PUSHJ P,PCHR
	SOJL B,OUTEND
	LDB F,[341000,,E]
	PUSHJ P,PCHR
	SOJL B,OUTEND
	LDB F,[41000,,E]
	PUSHJ P,PCHR
	SOJL B,OUTEND
	LDB F,[141000,,E]
	PUSHJ P,PCHR
	AOJA C,OUTLOP

OUTEND:	SETZM BUFPTR
	SETZM (A)	;TELL THE 11 WE HAVE GOBBLED THE BUFFER CONTENTS
	POPJ P,

OUTEOF:	SETZM BUFPTR
	SETZM (A)
	AOS (P)
	POPJ P,

;PUT A CHARACTER INTO THE FILE BUFFER
;IF THE BUFFER IS FULL, OUTPUT IT TO THE FILE
PCHR:	IDPB F,DBUFP
	SOSE BYTCNT
	 POPJ P,
	MOVEI T,DBUFL*5
	MOVE TT,[10700,,DBUF-1]
	.CALL [SETZ
		SIXBIT /SIOT/
		1000,,1
		TT
		SETZ T]
	 .LOSE 1000
IBUF:	MOVE T,[10700,,DBUF-1]
	MOVEM T,DBUFP
	MOVEI T,DBUFL*5
	MOVEM T,BYTCNT
	POPJ P,

FINFIL:	MOVE T,BYTCNT
	SUBI T,DBUFL*5
	MOVNS T
	MOVE TT,[10700,,DBUF-1]
	.CALL [SETZ
	SIXBIT /SIOT/
	1000,,1
	TT
	SETZ T]
	.LOSE 1000
	POPJ P,

$$rfn==1
.INSRT SYSENG;RFN >
RSIXTP:PSIXTP:	POPJ P,
;BUFPTR MUST BE DIVISIBLE BY 4
;BUFPTR 0=>NO BUFFERS READY FOR 10
;	NON-ZERO=>BUFFER POINTER IN BUFPTR+2 AND BUFPTR
;	(TEN CLEARS IT WHEN IT HAS READ POINTER OUT OF BUFPTR+2)
;A BUFFER IS A BLOCK OF STORAGE THE FIRST WORD STARTS AS THE LENGTH
;SECOND WORD IS UNUSED
;WHEN THE TEN HAS FILLED IT, IT NEGATES THE LENGTH, UNLESS EOF, WHEN IT CLEARS IT
; ON EOF, THE SECOND WORD HAS THE VALID BYTE COUNT
; LENGTH MUST BE DIVIDIBLE BY 4 AND BUFFER MUST BE ON A 4 WORD BOUNDARY

DBUF:	BLOCK DBUFL
11STRT=<.+1777>/2000
BUFPTR==<11STRT*2000>+<11BUFP/4>
FLAGW==<11STRT*2000>+<11FLGW/4>
END GO
