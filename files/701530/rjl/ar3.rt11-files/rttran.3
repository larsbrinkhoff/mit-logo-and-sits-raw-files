.TITLE RT11 MEMORY FILE TRANSFER

A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
P=%6
PC=%7

.MCALL .EXIT,.CSIGEN,.SETTOP,.CLOSE,.WRITW,..V2..,.PRINT,.TTYIN,.READW
..V2..

LENBUF=10	;BUFFER LENGTH IN 256. WORDS
SYSERR=52
.ASECT
.=1000
BUFPTR:	.WORD 0,0
FLAGW:	.WORD 0,0
LINE:	.BLKW 50
	.BLKW 200
PDL:	
PAT:	.BLKW 100
AREA:	.BLKW 100
DEFEXT:	.RAD50 /MAC/
	.RAD50 /MAC/
	.RAD50 /MAC/
	.RAD50 /MAC/
HNDARE:	.BLKW 1000	;HANDLER AREA
FILE11:	0		;TEMP POINTER TO THE FILE FOR THE 11 TO HACK
FILE10:	0
BP1:	0
	BP2
BP2:	0
	BP1
FRSFLG:	0
BLKNUM:	0
ASCFLG:	0

START:	MOV #PDL,P
	CLR BUFPTR
	CLR BUFPTR+2
	CLR FRSFLG
	CLR BLKNUM
	MOV #BUF1,B	;START OF THE FIRST BUFFER
	ADD #3,B
	BIC #3,B	;ROUND UP TO A MULTIPLE OF 4 BYTES
	MOV B,A
	ADD #10+<2*LENBUF*1000>,A	;END OF THE BUFFERS
	.SETTOP		;TELL THE SYSTEM
	MOV B,BP1	;FIRST BUFFER
	ADD #4+<LENBUF*1000>,B	;BEG OF SECOND BUFFER
	MOV B,BP2	;SECOND BUFFER
TENP:	MOV #105,FLAGW	;TELL THE TEN WE ARE ALIVE
	CLR A		;ABOUT 65 MILLISECONDS
	MOV #100.,B	;ABOUT 6.5 SECONDS
1$:	TST FLAGW	;IS THE TEN ALIVE?
	BEQ 2$
	SOB A,1$
	SOB B,1$
3$:	.PRINT #NOTEN
	CLR A
	.EXIT
2$:	MOV #105,FLAGW	;WAVE AT THE TEN
4$:	CMP #106,FLAGW	;DOES HE WAVE BACK?
	BEQ 5$
	SOB A,4$
	SOB B,4$
	BR 3$
5$:	CLR FLAGW	;READY TO GO
GETL:	.PRINT #READY
	MOV #LINE,B
LINLOP:	.TTYIN
	CMPB #15,A
	BEQ 1$
	MOVB A,(B)+
	BR LINLOP
1$:	.TTYIN		;FLUSH THE LF
	CLRB (B)+	;TERMINATE THE STRING
	MOV #LINE,B	;NOW DO A SCAN
	JSR PC,TENSCN	;LOOK FOR A TEN INDICATION
	BNE 2$		;FOUND A TEN INDICATION
	MOV B,FILE10
	JSR PC,TENSCN
	BNE 3$		;FOUND A TEN INDICATION
4$:	.PRINT #WHCWAY
	JMP GETL	;TRY AGAIN

2$:	MOV B,FILE11	;SAVE POINTER
	MOV #LINE,FILE10
	DEC FILE11	;THIS TIME YOU'VE GONE TOO FAR
	JSR PC,TENSCN	;ANY MORE TEN INDICATION?
	BNE 4$
	JMP X11T10

3$:	MOV #LINE,FILE11
	JMP X10T11

TENSCN:	CLR D		;THE FOUND A ; OR 10: FLAG
2$:	MOVB (B)+,A
	CMPB #'=,A
	BEQ 1$
	CMPB #'<,A
	BEQ 1$
	TST A
	BEQ 1$
	CMPB #';,A
	BNE 3$
	INC D
3$:	CMPB #'1,A
	BNE 2$		;NONE OF THE ABOVE
	CMPB #'0,(B)	; "10" ?
	BNE 2$
	CMPB #':,1(B)	; "10:" ?
	BNE 2$
	MOVB #40,-1(B)
	MOVB #40,(B)+
	MOVB #40,(B)
	INC D
	BR 2$

1$:	TST D
	RTS PC


X10T11:	MOV FILE10,A
	MOV A,C
	MOV BP1,B
	ADD #4,B	;GO PAST THE FLAG WORD
1$:	MOVB (A)+,(B)+
	BNE 1$
	CLRB (C)	;FOR THE CSIGEN
	JSR PC,OPNFIL
	CLR F		;THE FLAG TO SAY READ FROM THE TEN
	JSR PC,TENNAM	;GIVE THE FILE NAME TO THE TEN
TRAN1:	MOV #BP1,F	;POINTER TO THE FIRST BUFFER LINK
BUFLOP:	TST BUFPTR+2	;IS THE TEN ALIVE?
	BNE BUFLOP
	MOV (F)+,C	;GET A BUFFER POINTER
	MOV #LENBUF*1000,(C)	;SET IN THE LENGTH
	CLR 2(C)	;CLEAR FOR THE TEN
	MOV C,BUFPTR+2	;GIVE THE BUFFER TO THE TEN
	MOV (F),F	;RING AROUND THE BUFFERS
	TST FRSFLG	;FIRST TIME AROUND?
	BNE BUFLP2	;NO
	MOV #1,FRSFLG	;SET FLAG FOR THE NEXT TIME
	BR BUFLOP	;AND DO THE SECOND BUFFER

BUFLP2:	MOV (F),C	;GET A POINTER TO THE  BUFFER
BUFLP1:	TST (C)		;IS THE TEN DONE YET?
	BEQ BUFEOF	;END OF FILE
	BPL BUFLP1	;NOT READY YET
	MOV (C),D	;GET THE BYTE COUNT
	NEG D		;POSITIVE
	CMP (C)+,(C)+	;GET TO THE DATA
	JSR PC,REVBYT	;SWAP THE BYTES
	.WRITW #AREA,#0,C,#LENBUF*400,BLKNUM
	BCC BUFLP3
WRTLOS:	.PRINT #LOSE
	CLR A
	.EXIT
BUFLP3:	ADD #LENBUF,BLKNUM
	BR BUFLOP

LOSE:	.ASCIZ /LOST WRITING OUT A BLOCK!/
	.EVEN

BUFEOF:	TST (C)+	;SKIP PART OF THE HEADER
	MOV (C)+,B	;GET THE BYTE COUNT
	MOV B,D		;COPY COUNT
	INC B		;ROUND UP
	ASR B		;WORD COUNT
	.WRITW #AREA,#0,C,B,BLKNUM	;WRITE LAST BLOCK
	BCS WRTLOS
	.CLOSE #0
	CLR A
	.EXIT

X11T10:	MOV #LINE,B
	MOV BP1,A
	ADD #4,A
1$:	MOVB (B)+,(A)+
	CMPB #'=,(B)
	BEQ 2$
	CMPB #'<,(B)
	BNE 1$
2$:	CLRB (A)
	JSR PC,OPNFIL	;TRY TO OPEN THE LOCAL FILE
	MOV #1,F
	JSR PC,TENNAM	;GIVE THE FILE NAME TO THE PDP10
TRAN2:	MOV #BP1,F	;POINTER TO THE FIRST BUFFER LINK
	MOV #-1,FRSFLG
SNDLOP:	TST BUFPTR+2	;IS THE TEN ALIVE?
	BNE SNDLOP
	MOV (F)+,C	;GET A BUFFER POINTER
	TST FRSFLG	;FIRST TIME FOR THIS BUFFER?
	BLE 4$
3$:	TST (C)
	BNE 3$		;WAIT FOR THE TEN TO BE DONE WITH THE BUFFER
4$:	INC FRSFLG
	MOV C,E		;COPY
	CMP (E)+,(E)+	;DATA GOES HERE
	.READW #AREA,#3,E,#LENBUF*256.,BLKNUM
	BCC 1$
	TSTB SYSERR
	BNE RLOSE	;READ LOST SOMEHOW
	CLR A		;ZERO BYTES (RT11 BYTES TOO!!)
1$:	ASL A		;BYTES
	MOV A,(C)	;FOR THE TEN
	CLR 2(C)	;CLEAR FOR THE TEN
	MOV C,BUFPTR+2	;GIVE THE BUFFER TO THE TEN
	MOV (F),F	;RING AROUND THE BUFFERS
	ADD #LENBUF,BLKNUM
	TST A		;LAST ONE ZERO BYTES?
	BEQ REDDNE	;DONE
	BR SNDLOP	;AND DO THE SECOND BUFFER


REDDNE:	TST BUFPTR+2
	BNE REDDNE	;TEN GOT THE EOF BUFFER
	CLR A
	SOB A,.
	.EXIT

RLOSE:	.PRINT #REDLOS
	CLR A
	.EXIT


OPNFIL:	MOV P,F
	.CSIGEN #HNDARE,#DEFEXT,FILE11
	BCC 3$
	.PRINT #CSIERR
	MOVB SYSERR,A
	ASL A
	ADD #ERRTAB,A
	MOV (A),A
	.PRINT
	JMP START
3$:	MOV (P)+,ASCFLG	;ANY SWITHC => BINARY
	MOV F,P
	RTS PC

TENNAM:	MOV BP1,A
	MOV F,(A)
	MOV F,2(A)
	MOV A,C
	CMP (C)+,(C)+
	MOV #200.,D
	JSR PC,REVALW	;REVERSE THE BYTES
	MOV A,BUFPTR+2	;SEND TO THE TEN
2$:	TST BUFPTR+2
	BNE 2$		;WAIT FOR IT TO GOBBLE IT
	TST FLAGW	;OK TO GO?
	BNE 3$
	.PRINT #FNF
	JMP START
3$:	RTS PC

REVBYT:	TST ASCFLG
	BEQ REVRTS		;DON'T HACK THEN
REVALW:	MOV C,E		;GET THE BUFFER POINTER
	INC D
	ASR D		;GET A WORD COUNT
	BEQ 1$
2$:	SWAB (E)+
	SOB D,2$
1$:
REVRTS:	RTS PC

ERRTAB:	ILLCMD
	NODEV
	ILLCMD
	DIRFUL
	FNF11
ILLCMD:	.ASCIZ /ILLEGAL COMMAND/
NODEV:	.ASCIZ /DEVICE NOT FOUND/
DIRFUL:	.ASCIZ /NO ROOM IN DIRECTORY/
FNF11:	.ASCIZ /PDP11 FILE NOT FOUND/
NOTEN:	.ASCIZ /CAN'T GET THE PDP10/
READY:	.ASCIZ /RTTRAN.69/
WHCWAY:	.ASCIZ /WHICH WAY? USE ; OR 10: TO INDICATE THE TEN FILE./
FNF:	.ASCIZ /THE TEN DOESN'T LIKE THAT FILE NAME/
CSIERR:	.ASCIZ /GOT AN ERROR IN THE CSI/
REDLOS:	.ASCIZ /ERROR ON THE BUFFER READ/
.EVEN
BUF1:	0
.END START
