	.TITLE	PIP   V06.00
	.SBTTL ;RT-11 PIP  (PERIPHERAL INTERCHANGE PROGRAM)
	.IDENT	/V06.00/
	.NLIST	TTM
	.LIST	CND
	.ENABL	LC

; DEC-11-ORTSB-A
; RT-11 PIP  (PERIPHERAL INTERCHANGE PROGRAM)
;
;
; COPYRIGHT (C) 1977
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS  FURNISHED  UNDER A LICENSE  FOR  USE
; ONLY ON  A  SINGLE COMPUTER SYSTEM AND  MAY  BE COPIED
; ONLY WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.
; THIS  SOFTWARE,  OR  ANY OTHER COPIES THEREOF, MAY NOT
; BE PROVIDED OR OTHERWISE  MADE AVAILABLE  TO ANY OTHER
; PERSON  EXCEPT FOR  USE ON  SUCH SYSTEM AND TO ONE WHO
; AGREES TO THESE LICENSE  TERMS. TITLE TO AND OWNERSHIP
; OF THE SOFTWARE  SHALL AT ALL TIMES REMAIN IN DEC.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE
; WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED AS A
; COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR
; RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH
; IS NOT SUPPLIED BY DEC.
;
;
;
;
;
;
;
;
	.SBTTL ;***** GENERAL COMMENTS *****


	.IF NE 0
 1) Patch space can be generated by changing the value of FREE.
	This is the high limit of the program +2.
	There is also a psect PATCH$ for patching the object
	program.
 2) $DEBUG should have a value of 1 if debugging with DDT.
	This makes many of the routine names and data words
	global.
 3) Psect COMPLT must not be swapped over by the USR.  It
	contains routines called by same.
 4) WHERE$ and $$MSG must be set to 0.  They are used in the
	error message macro (ERROR).  Also, the names of all
	error messages must be unique to 5 characters.
 5) Psect PIP must be the last psect in the program.
 6) Anything marked:
		'*****CRITICAL ORDERING*****'
	means just that.  Don't change the order of that code
	before understanding what it does!!!!
 7) PIP attempts to keep the date currently on a file
	across copies and renames.  It does this with
	GETDAT and FIXDAT (see comments there), a 13.
	word queue, DATTBL, for the COPY routine, DATLST,
	the pointer to DATTBL, and HJDATE.
 8) PIP uses bit 12 of the status word of directory entries
	to flag files to be included in an operation.  This
	bit is currently unused.  If it ever becomes defined
	by the monitor, the symbol GOOD must be redefined to
	another bit.
	NOTE:
	PIP only sets this bit in its INTERNAL copy of the
	directory.
 9) The macro ERROR will not work in overlays.  Be warned!
10) The macro SWITCH generates the switches and words needed
	to process the switches.  It must not have more than
	16. switches which are invalid with other options
	(at least if they are be checked as they presently
	are).  The symbol .$M must be set to 1.

11) The USR MUST NOT swap over the data buffers (following the
	code).  This area may be used in .ENTER and .DELETE
	requests.
	.ENDC
	.SBTTL ;MACRO Definitions

	.MCALL	..V2..,	.ENTER,	.PURGE,	.SPFUN,	.SETTOP,.RELEAS
	.MCALL	.CLOSE,	.CSISPC,.DELETE,.DSTATU,.FETCH,	.TTYIN
	.MCALL	.LOOKUP,.PRINT,	.RCTRLO,.RENAME,.REOPEN,.SAVEST
	.MCALL	.READW,	.WAIT,	.DATE,  .WRITW,	.EXIT,	.TTYOUT
	.MCALL	.CSTAT,	.GTJB,	.SERR,	.HERR,	.TRPSET,.GTIM

	..V2..

.MACRO ERROR	TEXT,LEVEL,FILE
.IF NDF	$'TEXT
	$'TEXT	= $$MSG
.ENDC
.IF EQ	$'TEXT - $$MSG
	.PSECT	ER$TBL,D
	.WORD	TEXT
	.PSECT	PIP
	$$MSG	= $$MSG + 1
.ENDC
.IF NB	FILE
    .IF DIF	<FILE>,<R5>
	.IF NDF	.$'FILE
	    .$'FILE	= WHERE$
	.ENDC
	.IF EQ	.$'FILE - WHERE$
	    .PSECT	FILTBL,D
	    .WORD	FILE
	    .PSECT	PIP
	    WHERE$	= WHERE$ + 1
	.ENDC
	.T$	= .$'FILE
    .ENDC
.IFF
    .T$	= 0
.ENDC
	JSR	R5,ERRMSS
.IF EQ	LEVEL - 1
	.BYTE	<.T$*4+LEVEL+200>
.IFF
	.BYTE	<.T$*4+LEVEL>
.ENDC
.IF B	FILE
	.BYTE	<$'TEXT*2>
.IFF
    .IF DIF	<FILE>,<R5>
	.BYTE	<$'TEXT*2+200>
    .IFF
	.BYTE	<$'TEXT*2+201>
    .ENDC
.ENDC
.ENDM	ERROR
.MACRO	DSTATU	AREA,NAME
.IIF NB	<NAME>	MOV	NAME,R0
	JSR	PC,$STAT
.ENDM

.MACRO	SWITCH	CHAR,ADR,MODE,VALUE,MASK
	.BYTE	''CHAR,MODE
.IF B	VALUE
	.WORD	0
.IFF
.IIF NE	$DEBUG	.GLOBL	VALUE
VALUE:	.WORD	0
.ENDC
.IF EQ	MODE
.IIF NE	$DEBUG	.GLOBL ADR
	.WORD	ADR-COPY
.IFF
.IIF NE	$DEBUG	.GLOBL	ADR
ADR:	.WORD	0
.ENDC
.IF B 	MASK
	.WORD	0
	.WORD	0
.IFF
	.IIF EQ	<.$M>	.ERROR 	;SWITCH GENERATION ERROR (OVER- OR UNDERFLOW)
	ASSIGN	\''CHAR
	.$N = 0
	.IRPC	.$O,MASK
		ADMASK	\''.$O
	.ENDM
	.WORD	.$N
	.WORD	.$M
	.$M = .$M + .$M
.ENDC
.ENDM	SWITCH

.MACRO	DEVICE	DEV1,DEV2
	MOV	DEV1,-(SP)
	MOV	DEV2,-(SP)
	JSR	PC,DEVCHK
.ENDM	DEVICE

.MACRO	MOVR5R0
	JSR	PC,M4R5R0
.ENDM	MOVR5R0

.MACRO	ASSIGN	X
	...'X = .$M
.ENDM	ASSIGN

.MACRO	ADMASK	X
.IF DF	...'X
	.$N = .$N + ...'X
.ENDC
.ENDM	ADMASK
	.SBTTL ;Symbol definitions

STRTAD	= 40			;USER PROGRAM START ADDRESS
JSW	= 44			;JOB STATUS WORD
SYSPTR	= 54			;POINTER TO RT-11 RESIDENT
	;*Error bytes and flags
EMTERR	= 52			;RT-11 EMT ERROR RETURN BYTE
ERRBYT	= 53			;CUSP ERROR RETURN BYTE
SEVERE	= 10			;SEVERE ERROR
ERROR	= 4			;ERROR
WARN	= 2			;WARNING
	;*Offsets to vital RMON words
USRBSO	= 266			;USR BASE OFFSET
SYSUNT	= 275			;OFFSET TO SYSTEM DEVICE UNIT #
	;*ASCII and RAD50 constants
RUBOUT	= 377			;RUBOUT
ASTRSK	= 52			;ASTERISK
R50STAR	= 132500		;* IN RADIX 50 (FROM CSI)
LFNULL	= 5000			;ASCII <LF><NULL>
HDR1	= 42110			;ASCII H,D
EOF1	= 47505			;ASCII E,O
	;*Directory status word bit definitions
GOOD	= 10000			;FLAG FOR FILES TO PUT IN EXPANDED LIST
DIREOB	= 4000			;DIRECTORY BIT SAYING END OF BLOCK
DIRPRM	= 2000			;BIT SAYING PERMANENT FILE
DIREMP	= 1000			;BIT SAYING EMPTY ENTRY
DIRTMP	= 400			;BIT SAYING TEMP ENTRY
DIRBLK	= 6			;STARTING BLOCK OF DIRECTORIES
DIRESZ	= 16			;SIZE OF 1 DIRECTORY ENTRY (+ XTRABY)
	;*Other random bits
CSWEOF	= 20000			;EOF BIT IN CSW
FILSTR	= 100000		;File structured device from .DSTATUS
NRTDIR	= 10000			;Non-RT-11 directory structured .DSTATUS
	;*Device identification codes returned by .DSTATUS
LPIDEN	= 3			;LINE PRINTER
TTIDEN	= 4			;CONSOLE PRINTER
TMIDEN	= 11			;TM11/TU10/TSO3
CTIDEN	= 13			;TA11/TU60
TJIDEN	= 20			;TJU16
	;*Symbols used by ERROR macro
$$MSG	= 0			;USED FOR ERROR MESSAGE MACRO.  BOTH
WHERE$	= 0			;OF THESE MUST BE ZERO!!!
	;*Set up default values
.IIF NDF	$DEBUG		$DEBUG	= 1
.IF NE	$DEBUG
.GLOBL	DEVINF,	SSB,	MCEOF,	ACT,	BEGIN
.GLOBL	START,	SWTCHS,	EXPAND,	DELETE,	RENAME,	COPY
.GLOBL	MTCA,	DFNBUF,	CORCHK,	OEXPND,	ENTER,	LOOKUP
.GLOBL	READ,	READC,	WRITE,	WRITEC,	FILBUF,	SYSCHK
.GLOBL	GETDIR,	DIRBUF,	RDDIR,	MCDIR,	OPNDIR,	BUFSIZ
.GLOBL	R50OUT,	YESCHK,	FILDES,	READB,	CONV,	ASCFIL
.GLOBL	TEST,	NOFILL,	CLOOP,	FNAML,	FNOUT,	LOGCHK
.GLOBL	CHARS,	LOGCHK,	FETCH,	NXTDIR,	HEDLOG,	CHKDEV
.GLOBL	DFNBUF,	CORBL,	RDIR1,	WLDCHK,	MCDIRR,	CRLF
.GLOBL	AREA,	OLNAME,	NEWNAM,	FILCON,	CLSALL,	EXPND2
.GLOBL	EXPND3,	FIXDAT,	GETDAT,	HJDATE,	INBLK
.GLOBL	INBUF,	INBUFE,	INFILS,	LPCHK,	PRE,	MATCH1
.GLOBL	MAGTAP,	NXTCPY,	ONE$,	OUBLK,	OUBUF,	OUBUFE
.GLOBL	OUCHAN,	R4SAV,	R50WD,	SAVER5,	SKIP,	CHKIN
.GLOBL	SOPTR,	SPFUN,	SPFUN1,	SPFUN2,	TODAY,	WRDCNT
.GLOBL	ZER$,	ENDSEG,	DUNMCD,	REWDIR,	READMT,	CTDIR
.GLOBL	CTDIR1,	ASCR50,	ERMTCA,	ERRMSS,	QUECHK,	NOR
.GLOBL	$ERTAB,	FILTAB,	FILCHK,	FILTST,	GETLFT,	EXPFIL
.GLOBL	DEVCHK,	RENAM1,	WILDMT,	INSTAT,	MATCH,	OUTER
.GLOBL	DATLST,	DATTBL,	DEVNAM,	EBOMB,	EBOMB1,	IMCOPY
.GLOBL	IMLOOP,	RENAM2,	RENAM3
.ENDC
	.SBTTL ;Psect set up and definition

	.PSECT	IMPURE,D	;IMPURE DATA PSECT
	.PSECT	ER$TBL,D	;TABLE OF STARTING ADDRESSES OF
$ERTAB:				;THE ERROR MESSAGES
	.PSECT	FILTBL,D	;TABLE OF ADDRESSES OF RAD50 FILENAME
FILTAB:				;AREAS FOR ERROR MESSAGES
	.PSECT	ASCDAT,D	;BYTE ALIGNED DATA AREA
	.PSECT	CLEAR,D		;ADDRESSES OF THINGS TO BE CLEARED ON
				;START UP
	.PSECT	PATCH$		;Patch psect
	.PSECT	COMPLT		;ROUTINES CALLED BY THE USR
	.PSECT	PIP		;MAIN CODE SECTION
				;THIS MUST REMAIN AS THE LAST PSECT!!!
	.SBTTL ;Command Dispatcher


;THIS IS THE START UP CODE AND COMMAND DISPATCHER FOR PIP.
;IT SETS UP AND CLEARS FLAG WORDS, PRINTS THE REBOOT MESSAGE
;GETS THE COMMAND LINE, AND CHECKS FOR SOME INVALID COMMANDS.

	.ASECT
.=46
	.WORD	START		;SET UP THE USR SWAP LOCATION

	.PSECT	PIP
BEGIN:	MOV	#VERSON,@#STRTAD  ;SET UP THE REENTRY POINT
	BIS	#20000,@#JSW	;SET THE REENTRY BIT IN THE JSW
	MOV	SP,(PC)+	;SAVE THE START OF THE STACK
SAVSP:	.WORD	0
	BR	ESTRT		;SKIP OVER WARNING MESSAGE TESTS
				;-ALSO REENTRY POINT
	.SBTTL ;VERSION
VERSON:	.PRINT	#VMESAG		;TELL HIM OUR VERSION NUMBER
	.PSECT	ASCDAT,D
	.NLIST	BEX
VMESAG:	.ASCII	\PIP V06.00A\
QUICR:	.BYTE	0		;THIS BYTE IS USED FOR FAST <CRLF>'S
	.LIST	BEX
	.PSECT	PIP

START:	TST	REBMES		;SHOULD WE TYPE REBOOT MESSAGE?
	BNE	ESTRT		;NO
	ERROR	RBMSG,0		;PRINT REBOOT MESSAGE
ESTRT:	.DATE			;GET TODAY'S DATE
	MOV	R0,(PC)+	;AND REMEMBER IT IN TODAY
TODAY:	.WORD	0
	MOV	SAVSP,SP	;SET STACK POINTER
	.TRPSET	#AREA,#SISERR	;On traps to 4 and 10, issue "SYSTEM ERROR"
	.GTIM	#AREA,#NEWNAM	;Get the time to force date roll over
	.RCTRLO			;RESET CTRL/O SWITCH
	.SETTOP	FREE		;RESET HIGH ADDRESS
	MOV	R0,USRBAS	;USRBAS IS THE HI LIMIT

;RELEASE ALL HANDLERS, AND PURGE ALL CHANNELS

	.CLOSE	#0		;IN CASE OF MAGTAPES!!!
	MOV	#FILDES,R1	;POINT TO THE CSI FILE SPEC AREA
1$:	TST	@R1		;ANYTHING THERE?
	BEQ	2$		;NOPE
	.RELEAS	R1		;RELEASE THE HANDLER
2$:	ADD	#12,R1		;POINT TO NEXT FILE SPEC
	CMP	R1,#FILDES+36	;INTO THE INPUT SPECS YET?
	BLOS	1$		;NO
	TST	-(R1)		;YES.  INPUT SPECS 1 WORD SHORTER
	CMP	R1,#FILDES+116	;DONE?
	BLO	1$		;NOPE.  DO ANOTHER
	MOV	#17,R1		;POINT TO HI CHANNEL NUMBER
3$:	.PURGE	R1		;AND PURGE THE CHANNEL
	DEC	R1		;GO TO NEXT ONE
	BGE	3$		;NOT DONE YET.


;***** CRITICAL ORDERING *****
;SINCE PIP HAS NO DEFAULT EXTENSIONS,
;CLEAR AND USE 'NEWNAM' FOR THIS PURPOSE
	MOV	#NEWNAM,R0	;POINT TO RENAME AREA
4$:	CLR	(R0)+		;CLEAR IT
	CMP	R0,#NEWNAM+10	;DONE?
	BLO	4$		;LOOP IF NOT
5$:	.CSISPC	#FILDES,#NEWNAM,#0  ;GET CSI COMMAND STRING FROM TTY
;***** END CRITICAL ORDERING *****

	BCS	5$		;TRY AGAIN ON ERROR
	MOV	@#SYSPTR,R0	;GET POINTER TO RMON
	MOV	USRBSO(R0),R0	;GET BASE OF USR
	TST	-(R0)		;SET R0 TO BOTTOM OF USR
	CMP	R0,FREE		;ARE WE ALREADY ABOVE THE USR?
	BHI	6$		;NO.  DO THIS SETTOP
	MOV	#-2,R0		;YES.  TAKE ALL OF MEMORY
6$:	.SETTOP			;TELL MONITR HOW MUCH CORE WE NEED
	MOV	R0,(PC)+	;AND SAVE WHAT WAS GIVEN
USRBAS:	.WORD	0
	MOV	#CLRLST,R0	;POINT TO LIST OF STUFF TO CLEAR
1$:	CLR	@(R0)+		;CLEAR A WORD
	TST	@R0		;END OF LIST?
	BNE	1$		;NO, DO MORE
	MOV	SP,(PC)+	;SET SYSMES TO NON-ZERO
SYSMES:	.WORD	1î
	MOV	SP,(PC)+	;SET REBMES TO NON-ZERO
REBMES:	.WORD	1
	.ENABL	LSB
	CLR	R3		;CLEAR SWITCH HANDLER ADDRESS
	CLR	R4		;CLEAR THE MASK WORD
	MOV	(SP)+,R1	;NUMBER OF SWITCHES
	BNE	2$		;BRANCH IF SWITCH GIVEN
	MOV	#FILDES,R0	;POINT TO FILE DESCRIPTOR
1$:	TST	@R0		;FILE GIVEN? (CHECKING THE DEVICE WORD)
	BNE	2$		;YES. CONTINUE
	ADD	#12,R0		;NONE THERE. INC POINTER
	CMP	R0,#FILDES+36	;ARE WE IN INPUT LIST?
	BLO	1$		;NO. INCREMENT WAS CORRECT
	TST	-(R0)		;YES. INPUT SPECS ONE WORD SHORTER
	CMP	R0,#FILDES+116	;ARE WE DONE?
	BLO	1$		;NO.  CONTINUE
	BR	VERSON		;MUST HAVE BEEN A <CRLF>.  GIVE VERSION
2$:	DEC	R1		;ANY MORE SWITCHES ??
	BLT	FILCHK		;GO FIX SPECIAL DEVICE FILENAMES(IF ANY)
3$:	MOV	(SP)+,R2	;GET SWITCH
	BMI	4$		;VALUE WAS SPECIFIED
	CLR	-(SP)		;USE ZERO FOR SWITCH VALUE
4$:	MOV	#SWTCHS-10,R5	;POINTER TO SWITCH LIST
5$:	CMP	(R5)+,(R5)+	;BUMP SWITCH LIST POINTER
	CMP	(R5)+,(R5)+	;AND AGAIN
	MOV	(R5)+,R0	;GET SWITCH MODE AND CHARACTER
	BEQ	9$		;END OF SWITCH LIST...BAD SWITCH
	CMPB	R2,R0		;IS THIS THE NAMED SWITCH ??
	BNE	5$		;NO, KEEP LOOKING
	CMPB	R2,#'M		;IS IT THE MAGTAPE SWITCH?
	BEQ	MAGTAP		;YES.  SPECIAL CASE SINCE IT CAN
				; HAVE 2 VALUES
6$:	MOV	(SP)+,(R5)+	;STORE SWITCH VALUE
	TST	R0		;WHAT TYPE OF SWITCH
	BMI	7$		;ITS A MODE SWITCH
	MOV	(R5)+,R3	;NO, SAVE THE ADDRESS OF ROUTINE
	BR	8$		;LOOK FOR NEXT SWITCH
7$:	MOV	SP,(R5)+	;SET THE SWITCH NON-ZERO
8$:	BIT	(R5)+,R4	;TEST THE FLAG BITS FOR AN ILLEGAL COMBO
	BNE	ILLOPT		;BRANCH IF ILLEGAL COMBINATION
	BIS	@R5,R4		;ELSE, SAVE THE SWITCH BIT
	BR	2$		;LOOK FOR NEXT SWITCH
MAGTAP:	BIC	#100000,R2	;CLR THE VALUE BIT
	SWAB	R2		;NEED TO KNOW WHICH FILE /M WAS ON
	CMPB	R2,#2		;INPUT FILE?
	BGT	6$		;YES.  AS YOU WERE
	MOV	#FILONO,R5	;NO.  CHANGE SWITCH LIST POINTER
	BR	6$		;AND CONTINUE
9$:	CMPB	R2,#'L		;IF IT'S AN 'L', TELL TO USE DIR
	BNE	ILLOP1		;IT'S NOT...
	ERROR	TURBON,2
	.EXIT			;AND QUIT ON HIM
ILLOP1:	ERROR	ILOPT,1
ILLOPT:	ERROR	ILOPC,1
	.DSABL	LSB
	.SBTTL ;CLRLST- List of things to be cleared on start-up
	.PSECT	CLEAR,D

;THIS WAS PUT IN ANOTHER PSECT JUST TO GET IT OUT OF THE WAY

CLRLST:
	OUCHAN	;OUTPUT CHANNEL NUMBER
	LOGGED	;LOGGING DONE FLAG
	TACNOC	;CONCAT FLAG FOR COPY ROUTINE
	FLEFND	;FLAGS FOR INPUT EXPANDER
	WILDMT	;FLAGS FOR MT AND CT COPIES
	ONETIM	;FLAG FOR SERIAL NON-FILE STRUCTURED OUTPUT DEVICES
	ERRFLG	;ERROR FLAG FOR INPUT, DEVICE FULL, OUTPUT ERRORS
	ASCFIL	;START OF STORAGE FOR ASCII OF INPUT FILENAMES
;	FLECNT	;Input file count
	ASCII	;(/A)
	FBIN	;(/B)
	CURRNT	;(/C)
	IGNORE	;(/G)
	DISMNT	;(/I:DIS)
	COPYNO	;(/K)
	FILINO	;(/M INPUT)
	FILONO	;(/M OUTPUT)
	NOREP	;(/N)
	OUTDEL	;(/O)
	EXCLUD	;(/P)
	QUERY	;(/Q)
	SNGBLK	;(/S)
	NEWDAT	;(/T)
	CONCAT	;(/U)
	LOGGIN	;(/W)
	SYSBAD	;(/Y)
	0	;END OF LIST
	.SBTTL ;Switch Table
	.PSECT	IMPURE,D

;EVEN THO THIS IS IN THE IMPURE PSECT, THERE ARE THINGS
;HERE THAT MUST NOT BE CHANGED!!!

MODE	= 200
ACTION	= 0
.$M	= 1

;ARGUMENT	USE
;--------	---
;    1		OPTION NAME TO CSI
;    2		FLAG WORD FOR SWITCH
;    3		0 SAYS IT'S AN ACTION ROUTINE,
;		200 SAYS IT MODIFIES AN ACTION
;    4		WHERE THE VALUE IS STORED, IF NEEDED
;    5		OPTION ILLEGAL IF GIVEN WITH THESE OPTIONS

SWTCHS:
	SWITCH	A ASCII  MODE,,		<B>
	SWITCH	B FBIN	 MODE,,		<AK>
	SWITCH	C CURRNT MODE
	SWITCH	D DELETE ACTION,,	<R>
	SWITCH	G IGNORE MODE
	SWITCH	I DUMMY4 MODE	DISMNT
	SWITCH	K DUMMY0 MODE	COPYNO	<BNORU>
	SWITCH	M DUMMY1 MODE   FILINO
	SWITCH	N NOREP  MODE,,		<KO>
	SWITCH	O OUTDEL MODE,,		<KN>
	SWITCH	P EXCLUD MODE
	SWITCH	Q QUERY  MODE
	SWITCH	R RENAME ACTION,,	<DKU>
	SWITCH	S SNGBLK MODE
	SWITCH	T NEWDAT MODE
	SWITCH	U CONCAT MODE,,		<KR>
	SWITCH	W LOGGIN MODE
	SWITCH	X DUMMY2 MODE
	SWITCH	Y SYSBAD MODE
	0			;THEORETICAL END OF TABLE
	SWITCH	M DUMMY3 MODE	FILONO
	.SBTTL ;FILCHK
	.PSECT	PIP

;THIS PROCEDURE CHECKS FOR INPUT FROM TT:, PR:, PC:, AND OTHER
;SERIAL, NON-BLOCKED DEVICES.  UPON FINDING ONE, IT CLEARS THE
;FILENAME GIVEN (SINCE THIS WOULD CAUSE ERRORS LATER ON AND IS
;NOT NEEDED), AND SETS THE SINGLE BLOCK TRANSFER FLAG.  IT ALSO
;CHECKS FOR THESE DEVICES AS OUTPUT, AND SETS A 'ONE-AT-A-TIME'
;TRANSFER FLAG, IF FOUND.

	.ENABL	LSB
FILCHK:	MOV	#FILDES+36,R1	;POINT TO INPUT FILE LIST
1$:	ASR	WILDMT		;Shift the MT, CT flag
	TST	@R1		;ANYTHING THERE?
	BEQ	2$		;NO
	DSTATUS	#DEVINF,R1	;WHAT KIND OF DEVICE
	BIT	#<FILSTR+NRTDIR>,DEVINF  ;FILE STRUCTURED
				;OR NON-RT DIRECTORY STRUCTURED
	BEQ	6$		;NO
	JSR	PC,MTCA1	;Is it an MT or CT?
	BNE	2$		;No.  Continue
	BISB	#40,WILDMT	;Else set the flag
2$:	ADD	#10,R1		;POINT TO NEXT FILE SPEC
3$:	CMP	R1,#FILDES+116	;DONE?
	BLO	1$		;NO
	DSTATUS	#DEVINF,#FILDES	;SEE IF THE OUTPUT DEVICE IS
	BIT	#<FILSTR+NRTDIR>,DEVINF  ;LP, TT, PP, ETC.
	BNE	4$		;IT'S NOT
	MOV	SP,(PC)+	;SET THE FLAG FOR LATER USE
ONETIM:	.WORD	0
	BR	5$
4$:	TST	COPYNO		;If not LP, TT, PC, then /K is illegal
	BNE	ILLOP1		;So give an error message
5$:	BR	FILTST		;YES.  GO CHECK OUTPUT FILENAMES
6$:	TST	(R1)+		;GET PAST DEVICE WORD
	CLR	(R1)+		;CLEAR THE FILENAME
	CLR	(R1)+		;
	CLR	(R1)+		;AND THE EXTENSION
	INC	SNGBLK		;AND DO SINGLE BLOCK TRANSFERS
	BR	3$		;AND CONTINUE
	.DSABL	LSB


	.SBTTL ;$STAT-	 Do a .DSTATUS....

$STAT:	CMP	DISMNT,#^RDIS	;Dismounted system device?
	BEQ	2$		;That's what he said
1$:	.DSTATU	#DEVINF		;Do the .DSTATUS
	RTS	PC		;Return to caller
2$:	MOV	R0,-(SP)	;Save the device word
	.SERR			;Trap system errors
	MOV	(SP)+,R0	;Restore the device word
	JSR	PC,1$		;Go do the .DSTATUS
	.HERR			;Let the system catch them now
	CLC			;Ignore any errors
	RTS	PC		;And return to caller	
	.SBTTL ;FILTST

;THIS PROCEDURE MAKES SURE THAT THE OUTPUT FILE SPEC MATCHES THE
;INPUT SPECS IN REGARD TO WILD-CARDS.

	.ENABL	LSB
1$:	TST	CONCAT		;IS IT A CONCAT COPY?
	BNE	FETCH		;YES.  IGNORE WILD CARD ERROR
2$:	ERROR	ILOUTW,1,FILDES
FILTST:	MOV	#FILDES+2,R5	;POINT TO OUTPUT FILENAME
	TST	@R5		;ANY OUTPUT FILE?
	BEQ	FETCH		;NO OUTPUT FILE, NO NEED TO TEST
	MOV	#TEST,CHARS	;STORAGE FOR ASCII FILENAME
	JSR	PC,FNAML	;CONVERT OUTPUT NAME TO ASCII
	JSR	PC,WLDCHK	;CHECK FOR WILD CARDS
	MOV	R0,R1		;SAVE RETURNED VALUE
	BMI	2$		;CONTAINED A '%' OR EMBEDDED '*'
	MOV	#FILDES+40,R5	;POINT TO 1ST INPUT FILENAME
3$:	TST	@R5		;NO FILE HERE?
	BEQ	9$		;NO.  SKIP IT
	MOV	R5,-(SP)
	JSR	PC,FNAML	;CONVERT IT TO ASCII
	JSR	PC,WLDCHK	;CHECK FOR WILD CARDS
	BEQ	5$		;NO WILDCARDS.
	BPL	4$		;NO EMBEDDED WILDCARDS
	NEG	R0		;ELSE, GET RID OF FLAG
4$:	ASRB	WILDMT		;Shift the MT, CT flag
	BCC	6$		;Branch if this device not MT, CT
	INCB	WLDTNG		;Else set the wildcard flag
	BR	6$
5$:	ASRB	WILDMT		;SHIFT THE FLAG WORD
6$:	CMP	R1,R0		;IS THERE A WILD CARD IN OUTPUT
				;FOR EACH IN INPUT?
	BLT	1$		;NO.  ERROR
	DEC	R1		;IS IT A A.*=*.B CONSTRUCT
	BNE	7$		;CAN'T BE
	CMP	R2,#2		;POSSIBLY.  CHECK R2
	BEQ	1$		;YES.  ERROR
7$:	INC	R1		;RESTORE TO PREVIOUS VALUE
8$:	MOV	(SP)+,R5
9$:	ADD	#10,R5		;POINT TO NEXT INPUT FILE
	CMP	R5,#FILDES+116	;ARE WE DONE?
	BLO	3$		;NO.  CONTINUE

	.DSABL	LSB
	.PSECT	IMPURE,D
WILDMT:	.BYTE	0
WLDTNG:	.BYTE	0
	.PSECT	PIP
	.SBTTL ;Handler fetch

;THIS PROCEDURE FETCHES THE HANDLERS, CHECKS FOR MULTIPLE OUTPUT
;FILES, CHECKS FOR CERTAIN ILLEGAL COMMANDS, AND IN THE CASE OF
;SINGLE BLOCK TRANSFERS (BECAUSE OF /G, /S OR /U), DEFINES
;THE I/O BUFFERS.  THIS LAST IS NEEDED FOR /U (CONCATENATE COPY)
;SINCE THE BUFFER MUST ALWAYS BE RESIDENT.
	.ENABL	LSB

FETCH:	MOV	FILDES+12,-(SP)	;MORE THAN ONE OUTPUT SPEC?
	BIS	FILDES+24,(SP)+	;TEST THE 3RD OUTPUT SPEC
	BEQ	2$		;WASN'T THERE.  DO THE FETCHES
	ERROR	ERTMOF,1	;ELSE TOO MANY OUTPUT FILES
1$:	ERROR	ILDEV,1
ILCMND:	ERROR	ILLCMD,1
2$:	MOV	#FILDES,R2	;POINTER TO CSI OUTPUT
	MOV	FREE,R4		;ADDRESS OF FREE CORE
3$:	TST	@R2		;IS DEVICE NAME NULL?
	BEQ	6$		;YES, DON'T FETCH A HANDLER
	DSTATUS	#DEVINF,R2	;SEE IF THE HANDLER IS LOADED,
				; AND GET SIZE, IF NOT
	BCS	1$		;Illegal device.
	TST	DEVINF+4	;LOADED?
	BNE	5$		;YES.  NO NEED TO FETCH
	MOV	USRBAS,-(SP)	;SEE IF ENUF ROOM
	MOV	R4,-(SP)	;PRESENT HI LIMIT
	ADD	DEVINF+2,@SP	;ADD IN HANDLER SIZE
	SUB	(SP)+,(SP)+	;DOES IT FIT?
	BCC	4$		;YES
	JSR	PC,CHKCOR	;SEE IF WE CAN GET MORE
4$:	.FETCH	R4,R2		;LOAD HANDLER IN FREE CORE
	BCS	1$		;ILLEGAL DEVICE (PROBABLY)
	MOV	R0,R4		;SAVE UPDATED FREE CORE ADDRESS
5$:	CMPB	DEVINF,#CTIDEN	;WE WORKING WITH A CASSETTE?
	BNE	6$		;NO
	BIS	FILINO,FILONO	;ELSE, MAKE SURE THAT THE /M VALUE
	BIS	FILONO,FILINO	;GETS USED NO MATTER WHERE IT WAS
				; ON COMMAND LINE
6$:	ADD	#12,R2		;BUMP LIST POINTER
	CMP	R2,#FILDES+36	;ARE WE IN THE INPUT LIST ??
	BLOS	3$		;NO, INCREMENT WAS CORRECT
	TST	-(R2)		;INPUT LIST ELEMENTS ARE 1 WORD SHORTER
	CMP	R2,#FILDES+116	;DONE WITH LIST ??
	BHIS	7$		;YES.  END THE LOOP
	JSR	PC,MTCA1	;ARE ILLEGAL
	BNE	3$		;NOT MT: OR CA:
	MOV	NOREP,-(SP)	;PUSH NOREPLACE FLAG
	BIS	OUTDEL,(SP)+	;BIS THE OUTPUT PREDELETE FLAG
	BNE	ILCMND		;ILLEGAL
	BR	3$		;AND CONTINUE
7$:	MOV	R4,INFILS	;SAVE START OF EXPANDED INPUT LIST
	MOV	R4,R2		;AND PUT IT INTO R2
	MOV	SNGBLK,-(SP)
	BIS	CONCAT,@SP	;IF A CONCAT OR AN IGNORE MODE COPY,
	BIS	IGNORE,@SP	; THEN DO A SINGLE BLOCK COPY
	MOV	(SP)+,SNGBLK	;SINGLE BLOCK XFER MODE?
	BEQ	EXPAND		;NO
	MOV	USRBAS,-(SP)	;SAVE THE BASE ADDRESS OF THE USR
	MOV	R2,USRBAS	;SET UP FOR DFNBUF
	ADD	#1000,USRBAS	;AT LEAST 1 BLOCK OF BUFFER SPACE
	MOV	ASCII,-(SP)	;IF NOT ASCII
	BIS	FBIN,(SP)+	;NOR BINARY
	BEQ	8$		;ONLY 1 BUFFER
	ADD	#1000,USRBAS	;ELSE WE NEED 2
8$:	CMP	USRBAS,@SP	;ENUF CORE?
	BLO	9$		;YES
	JMP	COROVR		;NOPE
9$:	JSR	PC,DFNBUF	;GO DEFINE THE BUFFER SPACE
	MOV	USRBAS,R2	;THIS WILL BE THE START OF FREE CORE
	TST	(R2)+		;MAKE SURE IT'S PAST THE BUFFERS
	MOV	R2,INFILS	;SAVE THE START OF FREE CORE
	MOV	(SP)+,USRBAS	;RESTORE THE REAL USR BASE
	.DSABL	LSB
	.SBTTL ;Input expansion

;THE FOLLOWING CODE EXPANDS THE INPUT LIST GIVEN BY CSI INTO
;A LIST STARTING AT @INFILS.  THIS IS DONE IN THE FOLLOWING MANNER
;
;	1) EXPAND THE GIVEN FILE SPEC INTO THE ASCII EQUIVALENT
;		(EXPFIL)
;	2) READ A DIRECTORY SEGMENT INTO MEMORY
;	3) IF A FILE IN THE DIRECTORY MATCHES, MARK IT AS 'GOOD'
;		(SEE CODE.  THIS IS MODIFIED BY /P)
;	4) GO THRU THE DIRECTORY AND MOVE ENTRIES MARKED GOOD INTO
;		THE EXPANDED INPUT LIST (GETLFT)
;	5) DO THE REQUIRED OPERATION ON THIS SET OF FILES
;	6) HAS THE WHOLE DIRECTORY BEEN SCANNED?
;	7) IF NOT, GO TO 2)
;	8) ARE THERE ANY UNEXPANDED FILES LEFT (MULTIPLE DEVICES)?
;	9) IF SO, GO TO 1)
;	10) RETURN TO COMMAND LEVEL (JMP START)
;

EXPAND:	ADD	#COPY,R3	;MAKE IT THE CORRECT OPERATION
	MOV	R3,(PC)+	;SAVE IT
ACT:	.WORD	0
	CLR	R4		;CLEAR THE CURRENT DEVICE
	MOV	R2,(PC)+	;SAVE START OF DIRECTORY BUFFER
DIRBUF:	.WORD	0
	ADD	#60,DIRBUF	;MAY NEED 6 ENTRIES MORE
	BISB	#77,FLEFND	;SAY NO FILE FOUND
	BISB	#77,FILDON	;SAY NO FILES DONE
1$:	CLR	R0		;NO DIRECTORY SEGMENTS IN YET
	MOV	R0,(PC)+	;SAVE IT
NXTDIR:	.WORD	0
EXPND2:	MOV	INFILS,R2	;POINT TO START OF EXPANDED FILE LIST
	.ENABL	LSB
	JSR	PC,EXPFIL	;EXPAND INPUT FILES TO ASCII
				;AND READ IN A DIRECTORY BLOCK
				;IF NECCESSARY
	MOV	DIRBUF,R5	;POINT TO DIRECTORY BUFFER
	ADD	#12,R5		;GET PAST HEADER WORDS
1$:	MOV	#ASCFIL,R1	;POINT TO THE ASCII FILE NAMES
	TST	@R1		;ANYONE THERE?
	BNE	2$		;YES.  GO GET THE GOOD ONES
	TST	@INFILS		;ANYTHING IN THAT LIST?
	BNE	12$		;YES.  GO DO THEM
	BR	EXPND3		;ELSE, WE'RE DONE
2$:	BIT	#DIREOB,@R5	;END OF DIRECTORY SEGMENT?
	BNE	12$		;YES
	BIT	#DIRPRM,@R5	;FILE THERE?
	BEQ	11$		;NO
3$:	MOV	R1,-(SP)	;SAVE R1
	MOV	R2,-(SP)	;AND R2
	MOV	R5,-(SP)	;AND R5
	MOV	#TEST,R2	;ASCII FILE NAME (DIRECTORY) GOES HERE
	MOV	R2,(PC)+	;SAVE ADDRESS FOR FILE NAME CONVERTER
CHARS:	.WORD	0
	TST	(R5)+		;POINT TO THE FILENAME
	JSR	PC,FNAML	;AND CONVERT IT TO ASCII
	JSR	PC,MATCH	;CHECK THE FILENAMES FOR A MATCH
	TST	R0		;WELL, DO THEY?
	BEQ	4$		;NO
	ADD	#7,R1		;POINT TO THE EXTENSIONS
	ADD	#7,R2		;
	JSR	PC,MATCH	;AND CHECK THEM FOR A MATCH
4$:	MOV	(SP)+,R5	;RESTORE R5
	MOV	(SP)+,R2	;AND R2
	MOV	(SP)+,R1	;AND R1
	TST	EXCLUD		;EXCLUDE SWITCH GIVEN?
	BNE	6$		;YES.
	TST	R0		;DID THEY MATCH?
	BEQ	10$		;NO
	TST	CURRNT		;WANT ONLY TODAY'S FILES?
	BEQ	5$		;NO
	CMP	14(R5),TODAY	;WAS IT CREATED TODAY?
	BNE	7$		;NO
5$:	BIS	#GOOD,@R5	;MARK THE ENTRY FOR LATER
	BICB	13(R1),FLEFND	;SAY WE FOUND THE FILE
	BR	10$		;AND CONTINUE TO NEXT FILE
6$:	TST	R0		;DID IT MATCH?
	BEQ	8$		;NO.
7$:	BIS	#DIREMP,@R5	;EMPTY FILE FOR OUR PURPOSES
	BR	11$		;AND CONTINUE
8$:	TST	CURRNT		;WANT ONLY THE CURRNT DATE?
	BEQ	9$		;NO
	CMP	14(R5),TODAY	;IS THE FILE THE CURRNT DATE?
	BNE	7$		;NO.  WE DON'T WANT IT
9$:	BIS	#GOOD,@R5	;MARK IT AS POSSIBLY GOOD
10$:	ADD	#14,R1		;POINT TO NEXT PATTERN STRING
	TST	@R1		;ANYTHING THERE
	BNE	3$		;YES.  CONTINUE
11$:	ADD	#DIRESZ,R5	;POINT TO NEXT FILE IN DIRECTORY
	ADD	XTRABY,R5	;DON'T FORGET EXTRA WORDS
	BR	1$
12$:	JSR	PC,GETLFT	;NOW COLLECT ALL GOOD FILES
	TST	@(PC)+		;ANY THERE?
	.DSABL	LSB
INFILS:	.WORD	0
	BEQ	EXPND2		;NO
	MOV	INFILS,R5	;POINT R5 AT THE EXPANDED INPUT LIST
	MOV	R4,-(SP)	;SAVE THE CURRNT DEVICE
	MOV	#FILDES,R4	;POINT AT THE OUTPUT FILENAME
	JSR	PC,@ACT		;GO DO THE OPERATION FOR THESE FILES
	MOV	(SP)+,R4	;RESTORE THE CURRNT DEVICE
	TST	ERRFLG		;ANY ERRORS REPORTED?
	BEQ	1$		;NOPE.  CONTINUE
	CMP	ACT,#COPY	;Did we come from the copy routine?
	BEQ	JMPRTS		;Yes.  Stop now
	TST	FILDES		;Could be COPY/DELETE
	BNE	JMPRTS		;It was.  Quit while ahead
1$:	MOV	SP,LOGGED	;DON'T PRINT HEADERS AGAIN
	BR	EXPND2		;ELSE, CONTINUE PROCCESSING
	.ENABL	LSB		;***NEEDED BECAUSE ERROR CHANGES PSECTS
EXPND3:	TST	CONCAT		;WAS THIS A CONCATENATE COPY
	BEQ	2$		;NO
	.WAIT	#15		;IS THE CHANNEL OPEN
	BCS	2$		;NO
	MOV	ASCII,-(SP)	;IF ASCII
	BIS	FBIN,(SP)+	; OR FORMATTED BINARY
	BEQ	1$		;  WE'LL FILL THE BUFFER WITH NULLS
	MOV	SOPTR,R2	;RESTORE POINTER TO THE OUTPUT BUFFER
	MOV	#15,OUCHAN	;TELL WRITE ROUTINE WHICH CHANNEL
	JSR	PC,FILBUF	;ZERO FILL THE BUFFER
1$:	.CLOSE	#15		;AND CLOSE THE FILE
2$:	TST	EXCLUD		;WAS EXCLUDE SET?
	BNE	JMPRTS		;THEN DON'T CHECK FOR FILE NOT FOUND
	MOV	#FILDES+36,R5	;POINT TO CSI INPUT FILE DESCRIPTORS
	MOV	#1,R1		;FLAG CHECKER FOR FILES NOT FOUND
3$:	BITB	R1,FLEFND	;DID WE FIND THIS FILE?
	BEQ	4$		;YES
	TST	@R5		;WAS THERE ONE THERE?
	BEQ	4$		;NO
	ERROR	FILFND,2,R5	;ISSUE 'FILE NOT FOUND' MESSAGE
4$:	ASLB	R1		;SET FOR NEXT FILE
	ADD	#10,R5		;POINT TO NEXT INPUT FILE
	CMP	R5,#FILDES+116	;DONE?
	BLO	3$		;NOT YET
JMPRTS:	JMP	START		;RETURN TO COMMAND DISPATCHER
	.DSABL	LSB
	.SBTTL ;GETLFT- Get files left by the input expand

;This routine picks out the files marked 'GOOD' by EXPAND and places
;them in the expanded input list.  R2 enters pointing to the expanded
;list area (INFILS), and exits pointing to the 1st free location following
;the list.  It also makes sure that .SYS files are not operated upon
;unless a /Y was given (via SYSCHK), and .BAD files are not included (they
;must be included by EXPFIL).  The reboot message flag is cleared
;if the operation is a copy, since SYSCHK is called by the ENTER
;routine to check output filenames.

	.ENABL	LSB
GETLFT:	MOV	DIRBUF,R5	;POINT TO DIRECTORY BUFFER
	ADD	#12,R5		;SKIP HEADER WORDS
1$:	BIT	#DIREOB,@R5	;END OF DIRECTORY SEG?
	BNE	5$		;YES
	BIT	#<DIRTMP+DIREMP>,@R5  ;IS IT AN EMPTY
	BNE	4$		;YES
	BIT	#GOOD,@R5	;IS IT ONE WE WANT?
	BEQ	4$		;NO
	MOV	R4,@R5		;MOVE DEVICE NAME INTO THE AREA
	MOV	R5,R0		;SET UP FOR SYSCHK
	JSR	PC,SYSCHK	;SEE IF .SYS FILE
	BEQ	4$		;IT WAS
	CMP	ACT,#COPY	;IS THIS FOR A COPY?
	BNE	2$		;NO
	MOV	SP,REBMES	;DON'T NEED THE REBOOT MESSAGE YET
2$:	CMP	6(R5),(PC)+	;IS IT A .BAD FILE?
	.RAD50	\BAD\		;
	BEQ	4$		;YES
3$:	MOV	(R5)+,(R2)+	;MOVE DEV. NAME INTO EXPANDED INPUT LIST
	MOV	(R5)+,(R2)+	;AND THE FILE NAME
	MOV	(R5)+,(R2)+	;
	MOV	(R5)+,(R2)+	;AND THE EXTENSION
	SUB	#10,R5		;BACKUP
4$:	ADD	#DIRESZ,R5	;POINT TO NEXT FILE NAME
	ADD	XTRABY,R5	;DON'T FORGET EXTRA WORDS
	BR	1$		;AND CHECK IT
5$:	CLR	(R2)+		;MARK THE END OF THE LIST
	RTS	PC		;AND RETURN
	.DSABL	LSB
	.SBTTL ;EXPFIL- Expand input file names to ASCII

;This code does a lot of the work for the input expand routine.
;It sets up the ASCII filenames and filetypes for the MATCH routine.
;It also decides whether or not to place the file spec into the expanded
;input list without going thru the expansion routine.  This is based as
;follows:
;	 1) All input specs containing wildcards must be expanded
;	 2) If 1 is false, the following reasons will place the
;		spec automatically in the expanded list:
;		a) a CONCATENATE copy is being done
;		b) the input device is a magtape or cassette,
;		   and there are no wild cards for that device-
;		   type
;		c) the input device is TT:, PC:, CR:, etc.
;		d) the output device is LP:, PC:, TT:, etc.
;		e) the input filetype is .BAD
;		NOTE: if this happens, then the file is marked as 'FOUND'
;			This will cause files to be QUERIED for, and 
;			then a 'File not found DEV:FILENAME' message
;			to be given if the file does not exist, and
;			/Q is set.
;	 3) All other file specs must be expanded.
;
;Only file specs of files residing on the same device will be expanded
;to ASCII on any one pass thru EXPFIL.  Only one directory segment will
;be scanned at a time.  The whole directory for a device will be
;scanned before going on the next device (if there).

EXPFIL:	MOV	R2,-(SP)	;SAVE POINTER TO EXPANDED INPUT LIST
	MOV	#ASCFIL,R2	;POINT TO AREA FOR ASCII FILENAMES
	TST	NXTDIR		;HAVE WE GOT A DIRECTORY YET
	BNE	14$		;YES
1$:	CLR	R4		;CLEAR THE CURRENT DEVICE INDICATOR
	TST	@R2		;ANYTHING ALREADY EXPANDED?
	BEQ	2$		;NO
	BICB	13(R2),FILDON	;SAY THIS FILE DONE
	CLR	@R2		;CLEAR THE WORD
	ADD	#14,R2		;POINT TO NEXT ONE
	BR	1$		;SEE IF ANY MORE
2$:	MOV	DIRBUF,R5	;POINT TO THE DIRECTORY BUFFER
	MOV	#DIREOB,12(R5)	;AND SAY IT'S THE END OF THE SEGMENT
	MOV	#1,R1		;FLAG CHECKER
	MOV	#ASCFIL,R2	;POINT TO STORAGE AGAIN
	MOV	#FILDES+36,R0	;POINT TO INPUT FILE SPECS
3$:	BITB	R1,FILDON	;DONE THIS ONE YET?
	BEQ	12$		;YES.  DON'T DO IT AGAIN
	TST	@R0		;ANYTHING THERE?
	BEQ	12$		;NOPE.  CONTINUE
	MOV	R0,-(SP)	;SAVE R0
	MOV	R0,R5		;POINT TO FILE NAME
	TST	R4		;GOT A DEVICE DIRECTORY YET?
	BEQ	4$		;NO
	DEVICE	@R5,R4		;IS THE INPUT DEVICE THE SAME
	BNE	11$		;NO
4$:	MOV	(R5)+,R4	;USE THIS AS THE DEVICE
	MOV	R2,CHARS	;ASCII FILENAME GOES HERE
	JSR	PC,FNAML	;CONVERT THE INPUT FILENAME TO ASCII
	JSR	PC,WLDCHK	;ANY WILD CARDS IN THE FILENAME?
	BNE	10$		;YES
	JSR	PC,MTCA		;GO SEE IF MT OR CA
	BNE	5$		;NOPE
	TSTB	WLDTNG		;WAS THERE A WILDCARD ON A MAGTAPE?
	BEQ	6$		;NOPE
	BR	10$		;ELSE LEAVE IT IN THE MATCH LIST
5$:	TST	CONCAT		;AND A CONCATENATE COPY?
	BNE	7$		;YES.  NO NEED TO CHECK DIRECTORY
	MOV	@SP,R0		;GET POINTER TO DEVICE NAME
	TST	2(R0)		;FILENAME THERE?
	BEQ	7$		;NO.  MUST BE TT:, PC:, ETC.
;	JSR	PC,SYSCHK	;It a .SYS file, and if so, is there a /Y?
;	BEQ	8$		;.SYS with no /Y
	TST	ONETIM		;IF OUTPUT DEVICE IS THE TT, LP, PC
	BNE	6$		; THEN JUST PUT IT IN THE LIST
	MOV	@SP,R5		;POINT TO FILENAME
	CMP	6(R5),(PC)+	;IS IT A BAD FILE?
	.RAD50	\BAD\		;
	BNE	10$		;NO
6$:	CLR	@R2		;CLEAR THE ASCII FILENAME
7$:	MOV	2(SP),R0	;POINT TO EXPANDED INPUT LIST
	MOV	@SP,R5		;POINT TO INPUT FILENAME
	MOVR5R0			;AND MOV (R5)+,(R0)+ 4 TIMES
	MOV	R0,2(SP)	;INCREMENT THE EXPANDED LIST POINTER
8$:	CMP	R2,#ASCFIL	;IS THERE ANYTHING IN THE ASCII LIST?
	BNE	9$		;YEP.  LEAVE IT THERE
	CLR	R4		;ELSE, NO DIRECTORY TO GET, YET
9$:	BICB	R1,FLEFND	;SAY IT'S FOUND
	BICB	R1,FILDON	;AND DONE
	BR	11$		;
10$:	ADD	#13,R2		;POINT TO END OF NAME
	MOVB	R1,(R2)+	;STORE FLAG VALUE
11$:	MOV	(SP)+,R0	;RESTORE R0
12$:	ADD	#10,R0		;POINT TO NEXT FILE NAME
	ASLB	R1		;ROTATE FLAG WORD
	CMP	R0,#FILDES+116	;DONE?
	BLO	3$		;NO
	CLR	@R2		;MARK END OF LIST
	TST	R4		;HAVE WE GOT ANYTHING?
	BNE	13$		;YES 
	CLR	R0		;ELSE, SAY NO DIRECTORY IN
	BR	15$		;AND QUIT
13$:	MOV	#DEVNAM,R5	;POINT TO NFS LOOKUP DEVICE BLOCK
	MOV	R4,@R5		;MOVE IN THE DEVICE NAME
	JSR	PC,GETDIR	;AND GO GET THE FIRST DIRECTORY SEGMENT
	BR	15$		;AND RETURN
14$:	MOV	NXTDIR,R0	;GET THE DIRECTORY SEGMENT NUMBER
	JSR	PC,RDDIR	;AND GO GET THAT DIRECTORY SEGMENT
15$:	MOV	R0,NXTDIR	;SAVE THE NEXT DIRECTORY SEGMENT NUMBER
	MOV	(SP)+,R2	;RESTORE R2
	RTS	PC		;AND RETURN
	.SBTTL ;DELETE

	.ENABL	LSB
DELETE:	MOV	QUERY,-(SP)	;SAVE THE QUERY SWITCH
	MOV	LOGGIN,-(SP)	;AND THE LOGGING SWITCH
	TST	@R4		;ANY OUTPUT FILES SPECIFIED?
	BEQ	1$		;NO
	MOV	R4,-(SP)	;YES. DO A COPY FIRST
	MOV	R5,-(SP)	;SAVE THE REG.S FOR THE RETURN
	MOV	#CPHD4,LOGHED	;Print the copied/deleted message
	JSR	PC,HEDLOG	;
	INC	(PC)+		;And mark it logged
LOGGED:	.WORD	0
	MOV	#COPY,ACT	;LOGCHK HAS TO KNOW WHERE CALLED FROM
	JSR	PC,COPY		;CALL THE COPY ROUTINE
	CLR	QUERY		;CLEAR THE QUERY OPTION
	CLR	LOGGIN		;AND THE LOGGING OPTION
	MOV	#DELETE,ACT	;RESTORE THE ROUTINE POINTER
	MOV	(SP)+,R5	;RESTORE THE REGISTERS
	MOV	(SP)+,R4	;
1$:	MOV	#CPHD1,LOGHED	;POINT TO THE HEADER FOR LOGGING
	JSR	PC,HEDLOG	;AND LOG IT IF NECCESSARY
2$:	TST	@R5		;ANY FILES LEFT TO DELETE ??
	BNE	3$		;YES.  CONTINUE
	MOV	(SP)+,LOGGIN	;AND RESTORE THE LOGGING OPTION
	MOV	(SP)+,QUERY	;AND RESTORE THE QUERY VALUE
	RTS	PC		;DO NEXT PIP COMMAND
3$:	TST	2(R5)		;NULL FILE NAMES NOT ALLOWED
	BEQ	4$		;ERROR
	MOV	R5,R0		;SET UP FOR MTCA
	JSR	PC,MTCA
	BNE	5$		;NEITHER
	CMPB	DEVINF,#CTIDEN	;IS IT A CASSETTE?
	BEQ	5$		;YES
4$:	ERROR	ILLDEL,1,R5	;CAN'T DELETE FROM MAGTAPES
5$:	JSR	PC,QUECHK	;DO QUERY
	BEQ	7$		;DON'T DO THE DELETE
	.DELETE	#AREA,#0,R5,FILINO  ;DELETE VERSION 2
	BCC	6$		;NO ERRORS.  CONTINUE
	ERROR	FILFND,2,R5
	BR	7$		;DON'T DO LOGGING ON ERRORS
6$:	JSR	PC,LOGCHK	;DO LOGGING
7$:	ADD	#10,R5		;BUMP INPUT LIST POINTER
	BR	2$		;AND DO THE NEXT ONE
	.DSABL	LSB
	.PSECT	ASCDAT,D
	.NLIST	BEX
CPHD1:	.ASCIZ	\deleted:\
CPHD4:	.ASCIZ	\copied/deleted:\
	.LIST	BEX
	.PSECT	PIP
	.SBTTL ;RENAME

	.ENABL	LSB
RENAME:	TST	FILDES		;Is there an output file?
	BEQ	ILCMD1		;If not, there's an error somewhere
	MOV	#CPHD2,LOGHED	;POINT TO THE HEADER STRING
	JSR	PC,HEDLOG	;PRINT THE HEADING IF NEEDED
1$:	TST	@R5		;ANY MORE FILES TO RENAME ??
	BEQ	STL1V		;NO, RETURN TO PIP
	MOV	R5,R0		;PT R0 TO FILE
	JSR	PC,MTCA		;IF MT OR CT,
	BEQ	ILLREN		;DISALLOW RENAME EVEN THO MONITR WILL
	TST	DEVINF		;IS IT RANDOM ACCESS?
	BPL	ILLREN		;IF NOT, THEN ERROR
	DEVICE	@R4,@R5		;ARE DEVICES THE SAME ???
	BNE	ILLREN		;NO, PROBABLY AN ERROR
	JSR	PC,OEXPND	;EXPAND NEXT OUTPUT FILE NAME
	MOV	#OLNAME,R0	;POINT TO OLD NAME
	MOVR5R0			;MOVE 4 WORDS OF OLD NAME INTO LIST
	MOV	R5,-(SP)	;SAVE THE POINTER TO THE INPUT LIST
	JSR	PC,SYSCHK	;See if output is a .SYS file without /Y
	BEQ	2$		;It was.  Don't do RENAME
	MOV	#OLNAME,R5	;POINT TO THE OLD NAME
	JSR	PC,QUECHK	;DO QUERY,NOREPLACE,OUTPUT-PREDELETE
	BEQ	2$		;DON'T RENAME
	CLR	HJDATE		;CLEAR THE DATE FIXING WORD
	JSR	PC,RENAM2	;GO DO THE RENAME
	JSR	PC,LOGCHK	;DO LOGGING
2$:	MOV	(SP)+,R5	;RESTORE POINTER TO INPUT LIST
	BR	1$		;AND DO MORE FILES
	.DSABL	LSB
ILLREN:	ERROR	ILRENM,1,R5

ILCMD1:	JMP	ILCMND		;Go issue "Illegal command" error

RENAM1:	JSR	PC,LOOKUP	;GO LOOKUP THE FILE AND GET THE DATE
	BEQ	STL1V		;FILE DOESN'T EXIST
	.PURGE	#0		;PURGE THE CHANNEL
				;AND FALL THRU TO DO THE RENAME


RENAM2:	MOV	#FIXDAT,AREA+10	;PUT THE DATE FIXING ROUTINE ADDRESS
				;WHERE THE MONITOR CAN FIND IT
RENAM3:	.RENAME	#AREA,#0,#OLNAME+1  ;AND RENAME THE FILE
	BCC	STL1V		;FILE WAS THERE.  RETURN
	ERROR	FILFND,2,OLNAME	;ELSE, RETURN AN ERROR MESSAGE
STL1V:	RTS	PC		;BACK TO PIP
	.PSECT	ASCDAT,D
	.NLIST	BEX
CPHD2:	.ASCIZ	\renamed:\
	.LIST	BEX
	.PSECT	PIP
	.SBTTL ;COPY


COPY:	TST	FILDES		;Is there an output file
	BEQ	ILCMD1		;If not, it's an error
	MOV	R2,(PC)+	;Save pointer to input statii area
INSTAT:	.WORD	0
	MOV	#CPHD3,LOGHED	;Point to header string for logging
	JSR	PC,HEDLOG	;And print it (maybe)
	MOV	COPYNO,CPYNO	;Save number of copies to do
	MOV	INFILS,SAVER5	;Initial value of R5
	MOV	INSTAT,-(SP)	;Pointer to status block area
	BIS	CONCAT,NEWDAT	;USE TODAY'S DATE FOR CONCAT COPIES
	.ENABL	LSB
ZER$:	TST	ERRFLG		;ANY ERRORS BEEN REPORTED
	BNE	1$		;YES.  JUST RETURN.
	MOV	SAVER5,R5	;Restore pointer to input list
	MOV	INSTAT,R2	;Restore status block pointer
	MOV	R2,@SP		;FIX IT ON THE TOS, ALSO
	MOV	#15,R3		;Set up for 13 LOOKUP's and ENTER's
	MOV	#DATTBL,DATLST	;POINT TO DATE TABLE
	MOV	R3,OUCHAN	;Initialize the output channel
ONE$:	TST	@R5		;Any more files to lookup?
	BNE	3$		;Yes
	CMP	R3,#15		;Have we done any?
	BNE	8$		;Yes
1$:	TST	(SP)+		;No.  clean off the stack
2$:	RTS	PC		;And return
3$:	DEC	R3		;Decrement the counter
	BMI	8$		;Done 13 so quit
	JSR	PC,CORCHK	;Else make sure enuf room for savestatus
	MOV	R5,R0		;Point to device name
	JSR	PC,MTCA		;DON'T LOOKUP IF MT OR CA
	BEQ	7$		;IT'S IS ONE OF ABOVE
	JSR	PC,LOOKUP	;And do it
	BNE	6$		;LOOKUP SUCCEEDED
	MOV	R5,R0		;LOOKUP FAILED.  POINT TO NEXT FILE
	SUB	#10,R0		;MOV THE LIST BACK
	MOV	R0,-(SP)	;SAVE NEW R5
4$:	TST	@R5		;At end of list yet?
	BEQ	5$		;Branch if yes
	MOVR5R0			;Else move the block up
	BR	4$		;AND KEEP GOING 'TIL END OF LIST
5$:	CLR	-10(R5)		;Mark the new end of the list
	MOV	(SP)+,R5	;RESTORE R5
	INC	R3		;RESET OUTPUT CHANNEL NUMBER
	BR	ONE$		;AND CONTINUE
6$:	.SAVEST	#AREA,#0,R2	;Save the status of the input file
	MOV	HJDATE,@DATLST	;SAVE THE DATE WE GOT
	ADD	#2,DATLST	;AND UPDATE THE DATE STACK POINTER
	ADD	#12,R2		;Status blocks are 12 bytes long
	TST	ONETIM		;IS THE OUTPUT DEVICE TT:, LP:, PC:?
	BNE	8$		;YES.  ONE ENTER AT A TIME THEN
	BR	ONE$		;NO.  Do another
7$:	MOV	(R5)+,(R2)+	;MOVE IN DEVICE NAME
	MOV	(R5)+,(R2)+	; AND THE FILENAME
	MOV	(R5)+,(R2)+	;  TWO WORDS WORTH
	MOV	(R5)+,(R2)+	;   AND THE EXTENSION
	MOV	#-1,(R2)+	; AND SAY IT'S MT OR CA
8$:	CLR	(R2)+		;Mark the end of the input statii
	MOV	#DATTBL,DATLST	;POINT TO DATE STACK
	TST	CONCAT		;CONCAT COPY?
	BEQ	10$		;NO
	TST	(PC)+		;HAS OUTPUT FILE ALREADY BEEN ENTERED?
TACNOC:	.WORD	0
	BEQ	9$		;NO
	MOV	SOPTR,R2	;RESET OUTPUT BUFFER POINTER
	JMP	25$		;AND CONTINUE
9$:	CLR	OUBLK		;CLEAR THE OUPUT BLOCK NUMBER
	MOV	OUBUF,R2	;INITIALIZE WRITEC
	MOV	#15,OUCHAN	;SET UP FIRST OUTPUT CHANNEL
	MOV	R4,R0		;POINT THE DEVICE BLOCK (CSI)
	CLR	HJDATE		;DEFAULT TO KEEPING THE DATE
	JSR	PC,SYSCHK	;Check for .SYS file
	BEQ	1$		;It was... w/o a /Y
	JSR	PC,ENTER	;ENTER THE OUPUT FILE
	BEQ	22$		;ENTER FAILED
	MOV	SP,TACNOC	;SAY THAT OUTPUT FILE ENTERED FOR CONCAT
	JMP	25$		;AND DO THE COPY
10$:	MOV	SAVER5,R5	;RESTORE POINTER TO INPUT LIST
11$:	TST	SNGBLK		;If single block transfer mode
	BNE	QUAD$		;Buffers already defined
	JSR	PC,DFNBUF	;Else define the buffers now
QUAD$:	MOV	@SP,R2		;POINT TO INPUT STATUS BLOCKS
12$:	TST	@R5		;Any more files?
	BEQ	25$		;No
	TST	@R2		;WAS IS LOOKUPED?
	BEQ	25$		;NOPE
	JSR	PC,OEXPND	;Expand the output file name
	MOV	#NEWNAM,R0	;Point to the output filename
	JSR	PC,SYSCHK	;See if output is a .SYS file
	BNE	13$		;It's not
	ADD	#2,DATLST	;Update the date list pointer
	BR	16$		; and continue
13$:	DSTATUS	#DEVINF,R5	;IS INPUT FILE-STRUCTURED?
	TST	DEVINF
	BPL	18$		;NOPE.  DON'T CARE THEN
	DEVICE	@R5,NEWNAM	;FIND OUT IF SAME DEVICE
	BNE	18$		;NOPE
	MOV	R5,-(SP)	;SAVE R5
	MOV	#NEWNAM+2,R0	;POINT TO OUTPUT FILE NAME
	TST	(R5)+		;POINT TO INPUT FILE NAME
	CMP	(R5)+,(R0)+	;SEE IF NAME THE SAME
	BNE	17$		;NOPE
	CMP	(R5)+,(R0)+	;BOTH WORDS
	BNE	17$		;NOPE
	CMP	(R5)+,(R0)+	;AND THE EXTENSION
	BNE	17$		;DIFFERENT FILE NAMES. DO NORMAL COPY
	MOV	@SP,R5		;RESTORE R5
	MOV	#OLNAME,R0	;POINT TO RENAME AREA	
	MOVR5R0			;AND MOVE IN 4 WORDS OF NAME
	MOV	#OLNAME,R5	;POINT BACK
	CLR	HJDATE		;CLEAR THE DATE FIX WORD
	JSR	PC,QUECHK	;AND QUERY THE USER
	BEQ	15$		;HE SAID NO.
14$:	JSR	PC,RENAM1	;AND DO A RENAME (TO FIX DATE IF NEEDED)
	MOV	#OLNAME,R5	;POINT TO INPUT FILENAME
	JSR	PC,LOGCHK	;AND GO DO LOGGING
15$:	MOV	(SP)+,R5	;RESTORE R5
16$:	MOV	#-1,@R5		;MARK THE FILE AS DONE
	BR	23$		;AND CONTINUE
17$:	MOV	(SP)+,R5	;RESTORE R5
18$:	MOV	FILDES+10,@R3	;GET SPECIFIED SIZE, IF ANY
	BNE	19$		;NONE GIVEN TO CSI
	MOV	4(R2),@R3	;Output file same size as input file
19$:	MOV	R5,R0		;POINT TO INPUT FILENAME
	JSR	PC,MTCA		;IS IT A MAGTAPE OR CASSETTE?
	BNE	20$		;BRANCH IF NOT
	MOV	FILDES+10,@R3	;SET UP CORRECT SIZE FOR ENTER
20$:	MOV	@DATLST,HJDATE	;SET UP CORRECT DATE
	ADD	#2,DATLST	;FIX DATE STACK POINTER
	JSR	PC,QUECHK	;AND ASK IF WE SHOULD DO IT
	BNE	21$		;SAID IT WAS OK
	MOV	#NEWNAM,R0	;ELSE, WE MUST SPECIAL CASE MT, CT
	JSR	PC,MTCA		;
	BNE	23$		;BRANCH IF NOT.
	ADD	#10,R5		;POINT TO NEXT FILE NAME
	ADD	#12,R2		;AND NEXT INPUT STATUS BLOCK
	MOV	R5,SAVER5	;SAVE THE UPDATED POINTER
	MOV	R2,@SP		;BOTH OF THEM
	BR	12$		;AND CONTINUE
21$:	MOV	#NEWNAM,R0	;POINT TO OUTPUT FILENAME
	JSR	PC,ENTER	;And enter the file
	BNE	23$		;ENTER MADE IT
22$:	CLR	@R2		;ELSE, ASSUME A BAD ERROR
	MOV	#-1,@R5		;MAKE SURE NO LOGGING DONE
	ADD	#10,R5		;BUMP INPUT LIST POINTER
	BR	25$		;AND CONTINUE
23$:	ADD	#10,R5		;Bump input list pointer
	ADD	#12,R2		;And input statii pointer
	TST	ONETIM		;SPECIAL CASE FOR LP:, PC:, OR TT:
	BEQ	24$		;NONE OF ABOVE
	MOV	R5,-(SP)	;SAVE R5
	SUB	#10,R5		;POINT BACK AT LAST ONE
	JSR	PC,LOGCHK	;AND DO THE LOGGING NOW
	MOV	(SP)+,R5	;THEN RESTORE R5
	BR	25$		;AND CONTINUE
24$:	JSR	PC,MTCA1	;SPECIAL CASE FOR MT: OR CT:
	BEQ	25$		;ONLY ONE CHANNEL OPEN AT A TIME
	DEC	OUCHAN		;Decrement the output channel number
	BNE	12$		;And do more if more channels
25$:	MOV	R5,-(SP)	;Temp storage
	.DSABL	LSB
	MOV	SAVER5,R5	;Restore pointer to input list
	MOV	R5,(PC)+	;AND SAVE IT HERE FOR POSTERITY
SAVR5:	.WORD	0
	MOV	(SP)+,SAVER5	;And store this one for next go 'round
	MOV	#15,OUCHAN	;FIRST OUTPUT CHANNEL
CLOOP:	MOV	@SP,R0		;Pointer to status blocks
	TST	@R0		;Is it zero?
	BNE	1$
	JMP	CLSALL		;Yes.  Go close the output files
1$:	CMP	@R5,#-1		;Should we copy this one?
	BEQ	SKIP		;No.
	JSR	PC,OEXPND	;YES.  GO EXPAND THE OUTPUT FILENAME
2$:	MOV	@SP,R0		;POINT TO INPUT STATUS BLOCK
	TST	10(R0)		;WAS IT FOR AN MT OR CT?
	BMI	3$		;BRANCH IF SO
	.REOPEN	#AREA,#0,(SP)	;Reopen the input file
	BR	NXTCPY		;AND DO THE NEXT
3$:	MOV	R5,-(SP)	;SAVE R5 FROM LOOKUP ROUTINE
	MOV	R0,R5		;POINT TO FILENAME TO LOOKUP
	JSR	PC,LOOKUP	;AND DO THE THING
	BNE	5$		;LOOKUP SUCCEEDED
	MOV	#4$,-(SP)	;SET UP FOR CALL TO ERMTCA
	MOV	#RTS8,-(SP)	;FAKE OUT A CALL FROM WRITE
	JMP	ERMTCA		;DO THIS IN CASE OUTPUT IS A MT OR CA
4$:	MOV	(SP)+,R5	;RESTORE R5
	MOV	#-1,@R5		;SAY THE FILE IS NOT DONE
	JMP	ERRCLS		;AND GO CLOSE THE OTHER OUTPUT FILES
5$:	MOV	(SP)+,R5	;RESTORE R5 (POINTS TO FILENAME BLOCKS)
NXTCPY:	TST	CONCAT		;CONCAT COPY?
	.ENABL	LSB
	BEQ	2$		;NO
	JSR	PC,QUECHK	;DO LOGGING, ETC.
	BNE	3$		;GO DO THE COPY
SKIP:	ADD	#10,R5		;Bump input list pointer
	ADD	#12,@SP		; And status block pointer
	TST	CONCAT		;IF IT'S A CONCAT COPY,
	BEQ	1$		;
	.CLOSE	#0		; THEN CLOSE THE INPUT FILE
	BR	CLOOP		;AND CONTINUE
1$:	DEC	OUCHAN		;  And go to next channel
CLOOP1:	BR	CLOOP		;   And continue
2$:	CLR	OUBLK		;Clear the output block number
	MOV	OUBUF,R2	;Initialize WRITEC
3$:	CLR	INBLK		;Clear the input block number
	CLR	INBUFE		;Initialize READC and READB
	TST	FBIN		;Formatted binary copy?
	BNE	BMCOPY		;Yes
	TST	ASCII		;Ascii copy?
	BEQ	IMCOPY		;No.  Do image copy
4$:	JSR	PC,READC	;Read a char
	BEQ	MCEOF		;End of input file
	JSR	PC,WRITEC	;Write a char
	BR	4$		;Do next char
	.DSABL	LSB
BMCOPY:	MOV	R4,(PC)+	;Save R4
R4SAV:	.WORD	0
	MOV	#FIRSTBY,R4	;SET UP FOR READB	
	CLR	(PC)+		;FLAG FOR LIBRARY FILE CHECK
FIRST1:	.WORD	0
1$:	JSR	PC,READB	;Read formatted binary
	BEQ	2$		;End of file
	JSR	PC,WRITEC	;Write a character
	BR	1$		;Again
2$:	MOV	R4SAV,R4	;Restore R4
	BR	MCEOF		;AND DONE
IMLOOP:	JSR	PC,WRITE	;Write the buffer load
	BCC 	IMCOPY		;NO ERROR, CONTINUE
	JMP	OUTER		;Output errors
IMCOPY:
	JSR	PC,READ		;Read a buffer load
	BNE	IMLOOP		;No EOF, don't quit
MCEOF:	TST	CONCAT		;CONCAT COPY?
	BNE	NOFILL		;YES.  DON'T FILL THE BUFFER (MORE TO COME)
	MOV	ASCII,-(SP)	;If not an ascii transfer
	BIS	FBIN,(SP)+	; Nor formatted binary
	BEQ	NOFILL		;  Then do not fill buffer
	JSR	PC,LPCHK	;SEE IF IT'S AN ASCII COPY TO LP:
	JSR	PC,FILBUF	;Fill end of buffer with nulls
	BR	NFIL1
NOFILL:	JSR	PC,LPCHK
NFIL1:	DEC	(PC)+		;Decrement the copy counter
CPYNO:	.WORD	0
	BGT	NXTCPY		;And do another if needed
	.CLOSE	#0		;Close the input file
1$:	ADD	#10,R5		;Bump input list pointer
	ADD	#12,@SP		; And input status block pointer
	TST	CONCAT		;CONCAT COPY?
	BEQ	2$		;NOPE
	MOV	R5,-(SP)	;ELSE SAVE R5
	SUB	#10,R5		;POINT BACK TO FILENAME
	JSR	PC,LOGCHK	;DO LOGGING
	MOV	(SP)+,R5	;AND RESTORE R5
	BR	CLOOP1		;AND CONTINUE THE CONCAT COPY
2$:	MOV	COPYNO,CPYNO	;Reset the number of copies
	.ENABL	LSB
	MOV	#NEWNAM,R0	;POINT TO OUTPUT FILE NAME
	JSR	PC,MTCA		;IF IT'S A MT OR CA
	BNE	1$		; NOT A MT OR CA
	.CLOSE	OUCHAN		; ELSE, CLOSE THE CHANNEL NOW
	MOV	R5,(PC)+	;SAVE THE POINTER
SAVER5:	.WORD	0
	MOV	SAVR5,R5	;POINT TO 1ST ONE COPIED
	JSR	PC,OEXPND	;EXPAND THE OUTPUT FILE NAME FOR LOG
	JSR	PC,LOGCHK	;AND DO THE LOGGING
	MOV	SAVER5,R5	;AND RESTORE POINTER
	JMP	QUAD$		;AND CONTINUE
1$:	CMPB	DEVINF,#TTIDEN	;IS OUTPUT DEVICE THE TT?
	BNE	2$		;NO
	.PRINT	#QUICR		;DO A <CRLF>
2$:	DEC	(PC)+		;Decrement the output channel
OUCHAN:	.WORD	0
	BGT	CLOOP1		;Go try another transfer
CLSALL:	TST	CONCAT		;IS IT A CONCAT COPY?
	BEQ	ERRCLS		;NO. GO CLOSE FILES
	MOV	R2,(PC)+	;SAVE THE OUTPUT BUFFER POINTER
SOPTR:	.WORD	0
	BR	5$		;AND CONTINUE
ERRCLS:	MOV	#16,R2		;START AT THE HIGH CHANNEL NUMBER
	MOV	SAVR5,R5	;POINT TO 1ST FILENAME
	JSR	PC,OEXPND	;EXPAND THE OUTPUT FILENAME
	MOV	#NEWNAM,R0	;POINT TO IT
	JSR	PC,MTCA		;SEE IF IT'S AN MT OR CA
	BEQ	5$		;YEP.  JUS CONTINUE
	MOV	OUCHAN,R1	;POINT TO THE CURRENTLY OPEN CHANNEL
	INC	R1		; +1
3$:	DEC	R2		;NOTHING OPENED ON 16
	CMP	R2,R1		;Are we done closing output channels?
	BLT	5$		;Yes.  Return.
	.CLOSE	R2		;Close the channel
	TST	ONETIM		;IF IT'S THE LP:, PC:, OR TT:
	BNE	4$		;THEN IT'S ALREADY BEEN LOGGED
	JSR	PC,OEXPND	;ELSE EXPAND THE OUTPUT FILENAME
	JSR	PC,LOGCHK	;AND DO THE LOGGING
4$:	ADD	#10,R5		;POINT TO NEXT FILENAME
	BR	3$		;AND CONTINUE
5$:	JMP	ZER$		;Go do another batch of files
	.DSABL	LSB

	.PSECT	ASCDAT,D
	.NLIST	BEX
CPHD3:	.ASCIZ	\copied:\
	.LIST	BEX
	.PSECT	PIP
	.SBTTL ;MTCA
;MTCA TESTS FOR UNIT NAME POINTED TO BY R0 MAGTAPE OR CASSETTE.
;IF SO, Z BIT IS SET.

MTCA:	DSTATUS	#DEVINF		;GET STATUS OF THIS DEVICE
MTCA1:	MOV	#DEVINF,R0	;POINT R0 TO STATUS WORD
	CMPB	@R0,#TMIDEN	;TM11 MAGTAPE ?
	BEQ	1$
	CMPB	@R0,#TJIDEN	;TJU16 MAGTAPE?
	BEQ	1$		;YES
	CMPB	@R0,#CTIDEN	;TA11 CASSETTE?
1$:	RTS	PC


	.SBTTL ;HEDLOG- Print the logging headers

	.ENABL	LSB
HEDLOG:	TST	QUERY		;QUERY MODE?
	BNE	1$		;YES
	TST	LOGGIN		;LOGGING MODE?
	BEQ	2$		;NO
1$:	TST	LOGGED		;HAVE WE ALREADY PRINTED THE HEADER?
	BNE	2$		;YES
	.PRINT	#FILES		;PRINT ' Files '
	MOV	(PC)+,R0
LOGHED:	.WORD	0
	.PRINT			;PRINT THE HEADER
2$:	RTS	PC		;AND RETURN
	.DSABL	LSB
	.PSECT	ASCDAT,D
	.NLIST	BEX
FILES:	.ASCII	\ Files \<200>
	.LIST	BEX
	.PSECT	PIP

M4R5R0:	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	RTS	PC
	.SBTTL ;DFNBUF- Define buffer(s)

;DFNBUF IS ENTERED WITH R2 POINTING TO THE START OF THE
;AVAILABLE BUFFER SPACE. BUFFER ALLOCATION IS DONE
;DEPENDING ON THE AMOUNT OF AVAILABLE CORE AND ON THE
;ASCII SWITCH. INBUF, OUBUF, OUBUFE, AND BUFSIZ ARE SET
;AND CHECKS ARE MADE FOR INSUFFICIENT BUFFER SPACE.
;REGISTER 2 IS LEFT POINTING AT THE START OF THE OUTPUT
;BUFFER.  R0 IS USED AS A TEMPORARY.

DFNBUF:	MOV	USRBAS,R0	;POINTER TO USR DIRECTORY BUFFER
	MOV	R2,(PC)+	;SAVE START OF INPUT BUFFER
INBUF:	.WORD	0
	SUB	R2,R0		;TOTAL SPACE FOR BUFFERS
	BCS	COVR1		;NO ROOM FOR BUFFER(S)
	BIC	#777,R0		;ROUND TO BLOCKS
	BEQ	COVR1		;IF NO MEM SEE IF SOME LEFT SOMEWHERE
	MOV	ASCII,-(SP)	;IF IT IS NEITHER ASCII
	BIS	FBIN,(SP)+	;  NOR FORMATTED BINARY
	BEQ	1$		;    THEN WE NEED BUT ONE BUFFER
	BIC	#1000,R0	;SINCE WERE SPLITTING,NEED EVEN # OF BLOCKS
	ROR	R0		;HALVE THE BUFFER SIZE (/A USES 2)
	ADD	R0,R2		;GET START ADDR OF OUTPUT BUFFER
1$:	MOV	R2,(PC)+	;SAVE START ADDRESS OF OUTPUT BUFFER
OUBUF:	.WORD	0
	MOV	R2,(PC)+	;GET ENDING ADDRESS OF OUTPUT BUFFER
OUBUFE:	.WORD	0
	ADD	R0,OUBUFE
	ROR	R0		;GET SIZE OF BUFFER(S) IN WORDS
	MOV	R0,(PC)+	;SAVE IT
BUFSIZ:	.WORD	0
	BNE	RTSPC		;RETURN OK IF BUFFERS NON-ZERO
COROVR:	ERROR	NOMEM,2		;NO ROOM IN CORE
	JMP	ESTRT		;RESTART
COVR1:	JSR	PC,CHKCOR	;SEE IF MORE AVAILABLE
	BR	DFNBUF		;YES.  TRY AGAIN

	.SBTTL ;CORCHK and CHKCOR

;CORCHK IS ENTERED WITH R2 POINTING TO START OF AVAILABLE
;CORE.  WE CHECK IF THERE IS ENOUGH ROOM FOR A SAVESTATUS
;BLOCK, OR FOR A MT/CT FILENAME, OR FOR THE NEXT FILE
;NAME IN AN INPUT EXPANSION. ALL THREE ARE CHECKED BY
;INSURING THERE IS AT LEAST 12. BYTES OF FREE CORE LEFT.
;CHKCOR does a .SETTOP to get all memory available.
;CALLED FROM INPUT EXPANDER AND FROM COPY ROUTINE. (BC)

CORCHK:	MOV	USRBAS,-(SP)	;USE SAME CHECK THAT DFNBUF USES;###
	MOV	R2,-(SP)	;PUT FREE CORE PTR ON STACK	;###
	ADD	#14,(SP)	;ADD 14 TO FREE CORE PTR-NEED 6 WDS;###
	SUB	(SP)+,(SP)+	;DO THE SUBTRACT 		;###
	BCC	RTSPC		;IF CC-ENUF ROOM-JUST RETN.	;###
CHKCOR:	.SETTOP	#-2		;GRAB ALL MEM AVAILABLE
	CMP	R0,USRBAS	;DID WE GET MORE?
	BLOS	COROVR		;BRANCH IF ALL GONE
	MOV	R0,USRBAS	;ELSE RESET OUR TOP
	BR	RTSPC		;AND RETURN
	.SBTTL ;OEXPND- Expand output file name

;OEXPND EXAMINES THE CURRENT OUTPUT FILE ENTRY FOR A POSSIBLE
;WILD CARD (*) CHARACTER IN EITHER THE FILE NAME OR EXTENSION.
;IF SUCH EXISTS, THE CORRESPONDING PART OF THE CURRENT INPUT
;FILE IS MOVED INTO THE OUTPUT FILE DESCRIPTOR. THE NEW
;OUTPUT FILE DESCRIPTOR IS STORED IN THE FOUR WORD BLOCK
;NEWNAM. THE ROUTINE IS ENTERED WITH R4 POINTING TO THE
;CURRENT OUTPUT FILE AND R5 POINTING TO THE CURRENT INPUT
;FILE.  ONE CALL TO OEXPND PRODUCES ONE OUTPUT FILE. R0 IS USED AS
;A TEMPORARY.  R3 is destroyed.

OEXPND:	MOV	R5,-(SP)	;SAVE R5 FROM WILD CARD CHECK
	MOV	R2,-(SP)	;SAVE R2 FROM R50WD
	MOV	#FILDES,R4	;RESET POINTER TO OUTPUT FILE SPEC
	MOV	#TEST,R2	;POINT TO STORAGE FOR ASCII FILE NAME
	MOV	R4,R5		;POINT TO DBLK
	JSR	PC,FILCON	;CONVERT THE FILE NAME TO ASCII
	MOV	(SP)+,R2	;RESTORE R2
	JSR	PC,WLDCHK	;CHECK FOR WILD CARDS
	BPL	1$		;NO CONTINUE
	JMP	BADOUF		;YES. ISSUE MESSAGE
1$:	MOV	(SP)+,R5	;ELSE RESTORE R5
	MOV	#NEWNAM,R3	;POINTER TO SPACE FOR NEW NAME
	MOV	(R4)+,(R3)+	;COPY DEVICE NAME
	CMP	@R4,#R50STAR	;IS FILE NAME *  ??
	BNE	2$		;NO
	MOV	2(R5),(R3)+	;YES, SUBSTITUTE NAME FROM INPUT LIST
	MOV	4(R5),(R3)+	;(TWO WORDS)
	CMP	(R4)+,(R4)+	;MOVE OUTPUT LIST POINTER TO EXTENSION
	BR	3$		;GO CHECK EXTENSION
2$:	MOV	(R4)+,(R3)+	;COPY NAME FROM OUTPUT LIST
	MOV	(R4)+,(R3)+
3$:	CMP	@R4,#R50STAR	;IS EXT .*  ??
	BNE	4$		;NO
	MOV	6(R5),(R3)+	;YES, USE EXTENSION FROM INPUT LIST
	BR	5$
4$:	MOV	(R4)+,(R3)+	;EXT IS OK, COPY IT
5$:	MOV	#FILDES,R4	;POINT TO OUTPUT FILE SPEC
RTSPC:	RTS	PC		;RETURN OUTPUT FILE NAME IN NEWNAM
	.SBTTL ;ENTER

;ENTER IS USED TO DO AN RT-11 ENTER OF THE FILE WHO'S
;NAME IS POINTED TO BY R0. CHECKS ARE MADE FOR ALL KNOWN
;ILLEGAL CASES (* IN FILE NAME OR EXTENSION OR NULL FILE).
;OUCHAN CONTAINS THE CHANNEL NUMBER TO BE USED FOR THE
;FILE. ATTEMPTS TO ENTER A .SYS FILE WITHOUT A
;/Y WILL CAUSE ENTER TO RETURN WITH Z=1. A SUCCESSFUL
;ENTER RETURNS WITH Z=0  (BEQ FAILS). OUBLK IS CLEARED
;TO INITIALIZE WRITE.

ENTER:	TST	(R0)		;ANY FILE TO ENTER
	.ENABL	LSB
	BEQ	2$		;NO, RETURN WITH Z=1
	MOV	R0,-(SP)	;SAVE R0 FROM WILD CARD CHECK
	MOV	R5,-(SP)	;AND R5
	MOV	#TEST,CHARS	;MOVE ADDR OF STORAGE TO POINTER
	MOV	R0,R5		;POINT TO DBLK
	TST	(R5)+		;POINT TO FILE NAME
	JSR	PC,FNAML	;CONVERT TO ASCII
	JSR	PC,WLDCHK	;CHECK FOR WILD CARDS
	BNE	BADOUF		;YES.  BAD FILE NAME
	MOV	2(SP),R5	;ELSE, GET PTR TO THE OUTPUT FILE NAME
	MOV	#NEWNAM,R0	;STORE IT IN NEWNAM
	CMP	R5,R0		;ARE THEY THE SAME LOCATION?
	BEQ	1$		;YES.  DON'T COPY THEM
	MOVR5R0			;STORE DEVICE:FILENAME.FILETYPE
	MOV	FILDES+10,@R0	;AND FIX THE LENGTH
1$:	MOV	(SP)+,R5	;RESTORE REGISTERS
	MOV	(SP)+,R0	;AND CONTINUE
	TST	2(R0)		;NULL NAME?
	BNE	2$		;NO-OK
	DSTATUS	#DEVINF		;GET DEVICE STATUS
	TST	DEVINF		;FILE STRUCTURED?
	BMI	BADOUF		;YES-DISALLOW THE ENTER
2$:	CLR	OUBLK		;SET OUTPUT FILE BLOCK NUMBER TO 0
	MOV	#AREA,R0	;POINT TO EMT AREA BLOCK
	MOV	#1000,@R0	;SET UP CODE
	BISB	OUCHAN,@R0	;SET UP CHANNEL NUMBER
	MOV	#NEWNAM,2(R0)	;POINT TO DBLK
	CLR	6(R0)
	MOV	NEWNAM+10,4(R0)  ;SET UP LENGTH,SEQNUM	
	MOV	#NEWNAM,R0	;POINT TO DEVICE NAME FOR MTCA
	JSR	PC,MTCA		;CHECK FOR MT OR CA
	BEQ	7$		;BRANCH IF SO
3$:	MOV	#AREA,R0	;RESTORE R0
	CLR	10(R0)		;CLEAR OUT THE DATE FIXER WORD TO THE MONITOR
	TST	DEVINF		;IS IT DECTAPE OR DISK?
	BPL	4$		;NO.  DON'T PLAY WITH DATE
	MOV	#FIXDAT,10(R0)	;ROUTINE FOR MONITOR TO CALL
	INC	2(R0)		;SET FLAG TO MONITOR
4$:	EMT	375		;AND DO THE ENTER
	BCS	8$		;ENTER BAD-REPORT ERROR
5$:	TST	FILONO		;IF + ONLY DO ONCE
	BLE	6$		;NOT IT
	CMPB	DEVINF,#CTIDEN	;IF CT, THEN DON'T FOOL WITH /M VALUE
	BEQ	6$
	MOV	#-1,FILONO	;DON'T GOT THERE AGAIN
6$:	JMP	CLZRTS		;ENTER OK,RETURN AFTER CLZ
7$:	MOV	FILONO,AREA+6
	CLR	AREA+4		;DO A ZERO LENGTH ENTER
	BR	3$
8$:	CMPB	DEVINF,#TMIDEN	;IS THE DEVICE A TM11?
	BEQ	10$		;YES
	CMPB	DEVINF,#TJIDEN	;A TJU16?
	BEQ	10$		;YES
	ERROR	DEVFUL,2,NEWNAM  ;NO. NORMAL ERROR
9$:	JMP	SEZRTS		;SET Z-BIT SAYING FAILED
BADOUF:	ERROR	FILOUT,1
10$:	CLR	R0
	MOVB	@#EMTERR,R0	;GET THE ERROR BYTE
	ASL	R0		;MAKE IT A WORD OFFSET
	MOV	ERR$4(R0),PC	;AND JUMP TO ERROR HANDLER
MTER0:	ERROR	SYSERR,2
	BISB	#SEVERE,@#ERRBYT  ;SEVERE ERROR!!!!
	.EXIT
MTER1:	ERROR	DEVFUL,1,NEWNAM	;DEVICE FULL ERROR
MTER2:	ERROR	DEVUSE,1	;DEVICE IN USE ERROR
MTER3:	ERROR	NOTDUN,0,NEWNAM  ;FILE WAS FOUND
	BR	9$		;CONTINUE
MTER4:	ERROR	FSNNF,1		;FILE SEQUENCE NUMBER NOT FOUND
MTER5:	ERROR	ILVALU,1	;ILLEGAL VALUE ON /M
	.DSABL	LSB
	.PSECT	IMPURE,D
ERR$4:	MTER0
	MTER1
	MTER2
	MTER3
	MTER4
	MTER5
	.PSECT	PIP
	.SBTTL ;LOOKUP

;LOOKUP DOES AN RT-11 LOOKUP OF THE FILE WHO'S NAME IS
;POINTED TO BY R5. THIS REGISTER IS THEN INCREMENTED PAST
;THE FILE DESCRIPTOR. LOOKUP INITIALIZES READ AND READC BY
;CLEARING INBLK AND INBUFE.

LOOKUP:	CLR	(PC)+		;INITIALIZE INPUT FILE BLOCK NUMBER
INBLK:	.WORD	0
	CLR	(PC)+		;INITIALIZE READC ROUTINE
INBUFE:	.WORD	0
	DSTATUS	#DEVINF,R5	;WHAT KIND OF DEVICE
	TST	DEVINF
	BMI	2$		;RT-11 DIRECTORY STRUCTURED
	.WAIT	#0		;IS THE CHANNEL OPEN?
	BCS	1$		;NO.  GO OPEN IT
	JSR	R5,SPFUN4	;IT'S AN OPEN MAGTAPE CHANNEL
	.BYTE	377,-2		;SPACE FORWARD TO TAPE MARK
	BR	5$		;AND SKIP THE LOOKUP
1$:	CLR	AREA+10		;MAKE SURE DATE FIX DOESN'T HAPPEN
	BR	3$		;AND DO THE LOOKUP
2$:	MOV	#GETDAT,AREA+10	;ROUTINE TO GET DATE WHEN MONITOR CALLS
	INC	R5		;SET BIT TO TELL MONITOR
3$:	.LOOKUP #AREA,#0,R5,FILINO  ;LOOKUP ON CHANNEL 0
	ROR	-(SP)		;Save the carry bit
	TST	DEVINF		;Is it a non-random device?
	BPL	4$		;Yes.  No date fix done
	DEC	R5		;Else fix R5
4$:	TST	(SP)+		;Did we get any errors?
	BPL	5$		;Nope.  Continue
	.CLOSE	OUCHAN		;Close the output 'cause MT and CT happen 1st
	ERROR	FILFND,2,R5	;Issue 'File not found' error
	ADD	#10,R5		;Bump the input list pointer
	JMP	SEZRTS		;Set Z bit to return failure
5$:	ADD	#10,R5		;Bump the input list pointer
	TST	FILINO		;Was it a positive number?
	BLE	6$		;No.  Carry on
	CLR	FILINO		;Else, cause rewind hereafter
6$:	JMP	CLZRTS		;And return with Z bit cleared
	.SBTTL ;GETDAT and FIXDAT
	.PSECT	COMPLT

;These two procedures are used to preserve a file's date across copies and
;renames.  They are called by the USR and must not be swapped over (this is
;the reason they are in another psect).  On entry, R1 points to the date word
;for in a file's directory entry.  All registers MUST be preserved.  The stack
;should not be modified.  GETDAT saves the date of a file temporarily in
;HJDATE.  FIXDAT sets the date word to the old value, or the current system
;date, depending on the following:
;	 1) If the /T switch is given, use the current date
;	 2) If the old date is 0 (no date), use the current date
;	 3) If the current date is 0, use the old date
;	 4) In all other cases, use the old date
;These routines are invoked by placing their address in the 5th word of the
;.area block for .ENTER, .LOOKUP, and .RENAME requests, and setting the 
;.name block odd, i.e.
;	MOV	#FIXDAT,AREA+10
;	.ENTER	#AREA,#0,#FILNAM+1
;These routines may NEVER be called unless the device is an RT-11 directory
;structured device (no magtapes or cassettes).


GETDAT:	MOV	@R1,(PC)+	;GET THE DATE OF THE FILE
HJDATE:	.WORD	0
	RTS	PC		;AND RETURN TO MONITOR

FIXDAT:	TST	NEWDAT		;DOES HE WANT TODAY'S DATE ON FILE?
	BEQ	3$		;NO
	TST	TODAY		;SYSTEM DATE THERE?
	BEQ	3$		;NO
1$:	MOV	TODAY,@R1	;YES.  PUT IT ON THE FILE
2$:	RTS	PC		;AND RETURN TO MONITOR
3$:	TST	HJDATE		;WAS THERE A DATE ON THE INPUT FILE?
	BEQ	4$		;NO
	MOV	HJDATE,@R1	;YES PRESERVE THE DATE
	BR	2$		;AND RETURN
4$:	TST	@R1		;IS THERE A DATE?
	BEQ	1$		;NO.  USE TODAY'S
	BR	2$		;YES. RETURN
	.PSECT	PIP
	.SBTTL ;DEVCHK

;DEVCHK is entered with 2 device names in RAD50 on the stack.  It
;attempts to determine whether or not the devices are the same
;by doing a non-file structured lookup on the device and 
;checking the channel status information to get the device
;index and unit number.  If the device is an MT or CT, then
;no lookup is done (to prevent rewinds), and the logical
;device name is used as the info word.  If the 2 devices are
;the same, DEVCHK returns with Z=1.


DEVCHK:	MOV	(SP)+,(PC)+	;Save the return address
DRETN:	.WORD	0
	MOV	(SP)+,DEVNAM	;Move 1st device name to a useful place
	JSR	PC,CHKDEV	;Go get info on this device
	MOV	R0,(PC)+	;Save the info
TSTIT:	.WORD	0		;
	MOV	(SP)+,DEVNAM	;Get the 2nd device name
	JSR	PC,CHKDEV	;And get its info
	SUB	R0,TSTIT	;Find out if the same
	JMP	@DRETN		;And return

	.ENABL	LSB
CHKDEV:	CLR	DEVNAM+2	;Set up for non-file structured lookup
	MOV	#DEVNAM,R0	;Point to device name
	JSR	PC,MTCA		;See if a magtape or cassette
	BEQ	1$		;If so, don't do lookup
	.LOOKUP	#AREA,#16,#DEVNAM  ;Else, lookup on channel 16
	MOV	#16,R0		;Need to get channel status info
	MOV	R0,-(SP)	;Save for *10.
	ASL	R0		;*2
	ASL	R0		;*4
	ADD	(SP)+,R0	;*5
	ASL	R0		;*10.
	CMP	(R0)+,(R0)+	;Skip 2 words
	ADD	@#SYSPTR,R0	;Point to CSW for the channel
	MOV	R1,-(SP)	;Save R1
	MOV	@R0,R1		;Get device index
	BIC	#^C<76>,R1
	SWAB	R1		;Save it
	BISB	11(R0),R1	;Get the unit number
	.PURGE	#16		;Purge the channel
	MOV	R1,R0		;Save the device index, unit # for ret.
	MOV	(SP)+,R1	;Restore R1
	RTS	PC		;And return
1$:	MOV	DEVNAM,R0	;Return with device name if MT or CT
	RTS	PC
	.DSABL	LSB
	.SBTTL ;READ

;READ IS USED TO READ BUFSIZ NUMBER OF WORDS FROM THE INPUT
;FILE CURRENTLY OPEN ON CHANNEL 0. INBLK IS THE RELATIVE 
;BLOCK NUMBER, AND INBUF IS THE BUFFER ADDRESS. IF THE READ
;IS COMPLETELY SUCCESSFUL, READ RETURNS WITH Z=0 (BEQ FAILS)
;AND THE ACTUAL NUMBER OF WORDS READ IN R0. THIS MAY BE LESS
;THAN BUFSIZ IF THE READ OVERLAPPED THE END OF FILE. IF THE
;READ IS UNSUCCESSFUL (EOF ENCOUNTERRED) Z=1 UPON RETURN
;SIGNALING THAT NOTHING WAS READ. READ WILL IGNORE HARD
;INPUT ERRORS IF THE /G SWITCH WAS SPECIFIED. READ WILL
;INCREMENT THE INPUT FILE BLOCK NUMBER (INBLK) BY THE
;NUMBER OF BLOCKS TRANSFERRED. READN WILL READ THE NUMBER
;OF WORDS IN R0.
;BEFORE BEGINNING THE READ OPERATION,A SPECIAL CASE CHECK IS
;MADE TO SEE IF THE INPUT DEVICE IS CASSETTE OR MAGTAPE.
;IF IT IS,THE BUFFER SIZE IS REDUCED TO 256 WORDS,TO PREVENT
;FILE ELONGATION BY EXTRA NULLS DURING THE TRANSFER. A FURTHER SPECIAL
;CASE CHECK IS MADE FOR CASSETTE,AND IF CASSETTE IS THE INPUT
;DEVICE,THE 256 WORD BUFFER IS "READ" BY FOUR SMALLER READS TO
;THE CASSETTE OF ONE RECORD EACH (64 WORDS). THIS IS NECESSARY TO
;PROPERLY DETECT END-OF FILE,WHICH MAY COME AFTER AN ODD NUMBER
;OF RECORDS ON CASSETTE.
;If an error occurs on the read and the number of blocks actually read
;is 0, the block count is incremented by 1 to prevent that block from
;being read again on /G copies.

READ:	MOV	2(SP),R0	;GET PTR TO CORE BLOCK
RCOM:	TST	10(R0)		;AND TEST 5TH WORD FOR < 0
	BPL	CORBL		;IF NOT, DO BUFFERS SIZE XFERS
	MOV	#256.,BUFSIZ	;ELSE (MT OR CA) DO SMALLER XFERS
	MOV	OUBUF,OUBUFE
	ADD	#1000,OUBUFE	;RESET OUTPUT BUFFER LIMITS
CORBL:	MOV	BUFSIZ,RWCNT	;ELSE, READ A BUFFER LOAD
	.READW	#AREA,#0,INBUF,RWCNT,INBLK
	ROR	-(SP)		;SAVE CARRY BIT FOR ERROR CHECK
	SWAB	R0		;NUMBER OF BLOCKS ACTUALLY READ
	BNE	1$		;ENUF WORDS TO MAKE A BLOCK
	INC	INBLK		;ELSE, SAY THERE WAS (PROBABLY A READ ERROR)
1$:	ADD	R0,INBLK	;INCREMENT RELATIVE BLOCK NUMBER
	SWAB	R0		;RESTORE IT TO A WORD COUNT
	TST	(SP)+		;DID READ GIVE ERROR ?
	BMI	RDERR		;YES, CHECK ON IT
CLZRTS:	CLZ			;CLEAR EOF INDICATOR
RTS7:	RTS	PC
SEZRTS:	SEZ			;BIT ON MEANS EOF FOR CT OR MT
	RTS	PC
RDERR:	TSTB	@#EMTERR	;WHAT KIND OF ERROR ??
	BEQ	RTS7		;RETURN WITH COND CODES =0
	TST	IGNORE		;SHOULD WE IGNORE IT (/G)
	BEQ	EBOMB		;NO, BOMB ON ERROR
	MOV	R0,-(SP)	;SAVE ACTUAL COUNT
	ERROR	INERR,0,R5	;PRINT, BUT CONTINUE
	MOV	(SP)+,R0	;RESTORE COUNT
	BR	CLZRTS		;SO RETURN
EBOMB:	ERROR	INERR,2,R5	;PRINT AN ERROR
	JMP	EBOMB1
	.SBTTL ;READC

;READC IS USED TO READ CHARACTERS FROM THE CURRENT INPUT FILE
;(OPEN ON CHANNEL 0). R1 IS USED AS THE BUFFER POINTER
;AND THE CHARACTERS ARE RETURNED ONE AT A TIME IN R0 AS SEVEN
;BIT ASCII. READC USES READ TO DO THE ACTUAL READING.
;IF THE EOF IS ENCOUNTERRED, READC RETURNS WITH
;Z=1  (BNE FAILS).

READC:	CMP	R1,INBUFE	;IS BUFFER EMPTY ??
	BLO	1$		;NO, DON'T READ
	MOV	2(SP),R0
	JSR	PC,RCOM		;EMPTY BUFFER, READ SOME
	BEQ	2$		;END OF FILE
	MOV	INBUF,R1	;RESET BUFFER POINTER
	ASL	R0		;GET ACTUAL NUMBER OF BYTES READ
	ADD	R1,R0		;NOW GET ADDR OF END OF BUFFER
	MOV	R0,INBUFE	;SAVE THIS
1$:	MOVB	(R1)+,R0	;GET A CHARACTER FROM THE FILE
	BIC	#177600,R0	;MAKE IT SEVEN BIT
	BEQ	READC		;IGNORE NULLS
	CMP	R0,#177		;IS IT A RUBOUT ??
	BEQ	READC		;YES, IGNORE IT
	CMP	R0,#32		;IS IT CTRL/Z? (NE RETURNS CHAR,EQ RETURNS EOF)
2$:	RTS	PC		;RETURN CHARACTER
	.SBTTL ;READB-	Formatted binary read

;READB IS USED TO READ FORMATTED BINARY FILES
;IT WILL DISCARD ANY DATA BEFORE THE BYTE 001
;MARKING THE FIRST BLOCK
;USED REGISTERS 0,1, AND 4
;PLEASE NOTE, REGISTER 4 MUST BE INITALLY SET TO FIRSTBY
	.ENABL	LSB

READB:	CMP	R1,INBUFE	;END OF BUFFER?
	BLO	1$		;NO
	MOV	2(SP),R0	;GET PTR TO CORE BLOCK
	JSR	PC,RCOM		;READ SOME MORE DATA
	BEQ	3$		;END OF FILE
	MOV	INBUF,R1
	ASL	R0		;MAKE WORD COUNT , BYTE COUNT
	ADD	R1,R0		;THIS IS END OF INPUT BUFFER
	MOV	R0,INBUFE	;
	TST	FIRST1		;IS THIS THE FIRST PASS THRU?
	BNE	1$		;NO.  CONTINUE
	CMP	4(R1),#7	;IS 3RD WORD A '7'
	BEQ	5$		;YES.  IT'S A LIBRARIAN OUTPUT FILE
1$:	MOV	@R4,PC		;THIS IS A JMP IN DISGUISE
BYTE1:	DECB	(R1)+		;IS THIS BYTE AN 001 ?
	BNE	READB		;WELL, NOT A BLOCK
	INCB	-(R1)		;FIX REG 1 AND THE BYTE
	CLR	(PC)+		;CLEAR THE CHECKSUM
CKSUM:	.WORD	0
	CLR	(PC)+		;CLEAR THE BYTE COUNTER
BYSIZ:	.WORD	0
	BR	OUTCHA		;ADVANCE THREAD AND OUTPUT BYTE
BSIZE:	MOVB	@R1,BYTMP	;STORE FIRST BYTE OF BYTE SIZE
	BR	OUTCHA		;OUTPUT THIS CHARACTER
BSIZE2:	MOVB	@R1,BYTMP+1	;STORE SECOND BYT OF BYTE SIZE
	ADD	BYTMP,BYSIZ	;COMPUTE BYTE SIZE
	INC	BYSIZ		;ADJUST FOR CHECKSUM BYTE
				;FALL THRU TO FINISH THE BLOCK
OUTCHA:	TST	(R4)+		;ADVANCE THE THREAD
OUTCH:	MOVB	(R1)+,R0	;FOR WRITEC
	ADD	R0,CKSUM
	DEC	BYSIZ		;DECREMENT BYTE COUNTER
	BNE	3$		;AND EXIT
	TSTB	CKSUM		;IS CHECKSUM EQUAL TO ZERO
	BNE	4$		;NO, ERROR
2$:	MOV	#FIRSTBY,R4	;RESET FOR A NEW BLOCK
				;  (ALSO SET NON-ZERO RETURN CODE)
	INC	FIRST1
3$:	RTS	PC		;RETURN WITH CHARACTER IN R0
4$:	TST	IGNORE		;IGNORE READ ERRORS
	BNE	6$		;YES, CONTINUE
	JSR	PC,ERMTCA
	ERROR	CHKSUM,1,R5
5$:	ERROR	ERRLIB,2,R5	;GIVE THE ERROR
	JSR	PC,ERMTCA
	TST	(SP)+		;CLEAR THE RETURN ADDRESS
	JMP	ERRCLS
6$:	ERROR	CHKSUM,0,R5
	BR	2$
	.DSABL	LSB

FIRSTBY:.WORD	BYTE1		;FIND A BYTE CONTAINING 001
	.WORD	OUTCHA		;OUTPUT THE NULL AFTER THE 001
	.WORD	BSIZE		;SAVE & OUTPUT THE FIRST
	.WORD	BSIZE2		;  AND 2ND COUNT BYTES
	.WORD	OUTCH		;THEN OUTPUT WITHOUT UPDATING THREAD
	.SBTTL ;ERMTCA- Take care of errors on reads and writes
	.SBTTL ;	 from and to magtapes and cassettes

;THIS CODE MUST BE PHYSICALLY BETWEEN THE READ AND THE
;WRITE CODE.  THIS IS BECAUSE OF THE ERROR CHECKING THAT
;MUST BE DONE ON MAGATAPE WRITES.

ERMTCA:	MOV	#NEWNAM,R0	;OUTPUT DEVICE AN MT OR CA?
	JSR	PC,MTCA
	BNE	1$		;BRANCH IF NOT
	.CLOSE	OUCHAN		;ELSE CLOSE THE OUTPUT CHANNEL
	CMP	PC,@SP		;CALLED FROM WRITE CODE?
	BHI	1$		;NO
	CMPB	DEVINF,#CTIDEN	;IS IT A MAGTAPE?
	BEQ	1$		;NO
	.CLOSE	#0		;CLOSE THE INPUT CHANNEL
	MOV	R5,-(SP)	;SAVE R5
	MOV	#DEVNAM,R5	;POINT TO SOMEPLACE FOR A NFS LOOKUP
	MOV	NEWNAM,@R5	;GET THE DEVICE
	JSR	PC,MTNFS	;DO A NON-FILESTRUCTURED LOOKUP ON THE MAGTAPE
	MOV	(SP)+,R5	;AND RESTORE R5
	JSR	PC,BSTM		;BACK SPACE TO TAPE-MARK
	JSR	PC,BSTM		; AGAIN
	JSR	PC,BSTM		;  AND AGAIN
	JSR	PC,BSTM		;   AND AGAIN.
	JSR	R5,SPFUN
	.BYTE	377,-1		;WRITE A TAPE-MARK
	JSR	R5,SPFUN
	.BYTE	377,-1		;WRITE A TAPE-MARK
	JSR	R5,SPFUN
	.BYTE	377,-1		;WRITE A TAPE-MARK
1$:	RTS	PC


BSTM:	JSR	R5,SPFUN4	;DO A BS TO TAPMARK
	.BYTE	377,-3
	BIT	#1,TEST		;WAS A TAPE-MARK FOUND?
	BEQ	BSTM		;NO
RTS8:	RTS	PC		;ELSE RETURN
	.SBTTL ;LPCHK-	 Force the last line of output from 
	.SBTTL ;	 LP05 buffer

	.ENABL	LSB
LPCHK:	DSTATUS	#DEVINF,#FILDES	;FIND OUT WHAT KIND OF DEVICE
	CMPB	DEVINF,#LPIDEN	;IS IT THE LINE PRINTER?
	BNE	1$		;NO RETURN
	TST	ASCII		;ASCII COPY?
	BEQ	2$		;NO IMAGE MODE (I HOPE)
	JSR	PC,CRLF		;PUT IN THE <CRLF>
1$:	RTS	PC		;RETURN TO COPY ROUTINE
2$:	MOV	#LFNULL,@OUBUF	;PUT A <LF><NULL> INTO THE BUFFER
	MOV	#1,R0		;PRINT 1 WORD
				;FALL THRU TO WRITE
	.DSABL	LSB


	.SBTTL ;WRITE

;WRITE IS USED TO WRITE SOME NUMBER OF WORDS ONTO THE CHANNEL
;OUCHAN FROM THE BUFFER OUBUF TO THE RELATIVE BLOCK
;NUMBER OUBLK.  THE WORD COUNT IS SPECIFIED BY R0.

WRITE:	MOV	R0,(PC)+	;PUT WORD COUNT ON STACK
WRDCNT:	.WORD	0
	.WRITW	#AREA,OUCHAN,OUBUF,WRDCNT,OUBLK
	BCS	OUTER		;BRANCH ON ERROR
	MOV	WRDCNT,R0	;GET WORD COUNT
	SWAB	R0		;MAKE IT A BLOCK COUNT
	ADD	R0,(PC)+	;AND ADD TO OUTPUT BLOCK COUNT
OUBLK:	.WORD	0
	.ENABL	LSB
	RTS	PC		;AND RETURN
	.DSABL	LSB

	.ENABL	LSB
OUTER:	TSTB	@#EMTERR	;WHAT KIND OF ERROR
	BEQ	1$		;EOF ON WRITE
	ERROR	OUTERR,2,NEWNAM	;ELSE HARD ERROR
	BR	2$
1$:	ERROR	OUTFUL,2,NEWNAM
2$:
EBOMB1:	JSR	PC,ERMTCA	;IN CASE OF MT OR CT
	MOV	ASCII,-(SP)	;If ASCII or BINARY xfer, then
	BIS	FBIN,(SP)+	; there's an extra word on the stack
	BEQ	3$
	TST	(SP)+		;so clean it off
3$:	TST	(SP)+		;CLEAN OFF THE RETURN ADDRESS
	JMP	ERRCLS		;CLOSE OUT THE OPEN CHANNELS
	.DSABL	LSB
	.SBTTL ;CRLF

;CRLF WILL OUTPUT A CARRIAGE RETURN LINE FEED VIA WRITEC.

CRLF:	MOV	#15,R0		;OUTPUT A CARRIAGE RETURN
	JSR	PC,WRITEC
	MOV	#12,R0		;THEN A LINE FEED
				;AND FALL THRU TO WRITEC


	.SBTTL ;WRITEC

;WRITEC IS USED TO WRITE CHARACTERS TO THE CURRENT OUTPUT FILE
;OPEN ON CHANNEL OUCHAN. R2 IS USED AS THE OUTPUT BUFFER
;POINTER, AND WRITE IS USED TO DO THE ACTUAL IO TRANSFER.

	.ENABL	LSB
WRITEC:	CMP	R2,OUBUFE	;IS BUFFER FULL ??
	BLO	1$		;NO, DON'T WRITE IT
	MOV	R0,SAVR0	;SAVE CHARACTER TO BE WRITTEN
	MOV	BUFSIZ,R0	;PUT WORD COUNT INTO R0
	JSR	PC,WRITE	;WRITE ONE BUFFER LOAD
	MOV	(PC)+,R0	;RESTORE CHARACTER
SAVR0:	.WORD	0
	MOV	OUBUF,R2	;SETUP BUFFER POINTER
1$:	MOVB	R0,(R2)+	;STUFF CHARACTER INTO BUFFER
	RTS	PC
	.DSABL	LSB
	.SBTTL ;FILBUF

;FILBUF FILLS THE CURRENT BLOCK OF THE OUTPUT BUFFER WITH
;NULLS AND THEN WRITES OUT THE LAST BUFFER LOAD. THIS
;MAY BE SHORTER THAN BUFSIZ.

	.ENABL	LSB
1$:	CLRB	(R2)+		;PUT IN ANOTHER NULL
FILBUF:	MOV	R2,R0		;GET CURRENT BUFFER POINTER
	SUB	OUBUF,R0	;GET CURRENT BUFFER SIZE
	BIT	#777,R0		;IS SIZE A MULTIPLE OF 1000 BYTES ?
	BNE	1$		;NO, MORE NULLS
	ASR	R0		;MAKE THIS A WORD COUNT
	JMP	WRITE		;WRITE OUT LAST PIECE OF FILE
	.DSABL	LSB
	.SBTTL ;SYSCHK

;SYSCHK  USED TO PROTECT .SYS FILES FROM INADVERTENT
;DELETION, RENAMING, OR MODIFICATION.  THE ROUTINE IS ENTERRED
;WITH R0 POINTING TO THE FILE DESCRIPTOR TO BE CHECKED.
;IF THE FILE HAS AN EXTENSION OF .SYS AND THE /Y SWITCH
;HAS NOT BEEN SET, SYSCHK WILL RETURN WITH Z=1 (BEQ
;SUCCEEDS). OTHERWISE THE RETURN IS WITH Z=0 (BEQ FAILS).

	.ENABL	LSB
SYSCHK:	CMP	6(R0),(PC)+	;IS IT A .SYS FILE ??
	.RAD50	\SYS\
	BNE	3$		;NO, JUST RETURN
	TST	SYSBAD		;WAS THERE A /Y ??
	BEQ	4$		;INFORM USER
	MOV	R0,-(SP)	;SAVE R0
	JSR	PC,MTCA		;SEE IF MT OR CA,AND GET DEV. STATUS INFO
	BEQ	1$		;IT IS.  CAN'T BE SYS DEVICE
	MOV	#DEVINF+4,R0	;POINT TO DEVINF+4 (USED AS SCRATCH TOO)
	CMP	@R0,@#SYSPTR	;IS THIS IS A SYS DEVICE
	BLO	1$		;NO
	CLR	-(R0)		;SET UP FOR NON-FILE-STRUCTURED
	MOV	@(SP),-(R0)	;PUT IN THE DEVICE NAME
	.LOOKUP	#AREA,#17,#DEVINF  ;OPEN THE DEVICE NON-STRUCTURED
	.SAVEST	#AREA,#17,#SSB	;AND GET INFORMATION THEREON
	MOV	@#SYSPTR,R0	;BASE OF RES INTO R0
	CMPB	SYSUNT(R0),SSB+11 ;IS IT SYSTEM DEVICE?
	BNE	1$		;NOT SYS DEVICE (AT LAST)
	CLR	REBMES		;SET SWITCH SO REBOOT PRINTED WHEN DONE
1$:	MOV	(SP)+,R0
2$:	TST	SYSBAD		;WAS THERE A /Y  ??
3$:	RTS	PC
4$:	TST	SYSMES		;HAVE WE BEEN HERE BEFORE??
	BEQ	2$		;YES. RETURN
	ERROR	NOSYS,0		;WARN THE USER ABOUT NO SYS,BAD
	CLR	SYSMES		;AND REMEMBER WE'VE BEEN HERE
	BR	2$
	.DSABL	LSB
	.SBTTL ;GETDIR and RDDIR

;GETDIR IS USED TO OPEN A DIRECTORY AND TO READ ITS FIRST
;BLOCK INTO THE DIRECTORY BUFFER. R5 SHOULD POINT TO THE
;DEVICE NAME IN RAD50 FOLLOWED BY A ZERO WORD. THE DEVICE
;IS THEN OPENNED ON CHANNEL 0 AS A NON FILE STRUCTURED
;DEVICE, ALLOWING READING OF ABSOLUTE BLOCKS.
;THE REMAINING FUNCTIONS OF GETDIR ARE
;THE SAME AS THOSE OF RDDIR.
;RDDIR IS USED TO READ SUCCESSIVE DIRECTORY BLOCKS.
;UPON EXIT R5 POINTS TO THE FIRST ENTRY OF THE CURRENT
;DIRECTORY BLOCK, R0 CONTAINS THE ABSOLUTE BLOCK NUMBER OF
;THE NEXT DIRECTORY BLOCK (0 MEANS THIS IS THE LAST), AND
;XTRABY CONTAINS THE NUMBER OF EXTRA BYTES IN EACH
;DIRECTORY ENTRY.

GETDIR:	.ENABL	LSB
	MOV	R5,R0		;POINT TO DEVICE NAME
	JSR	PC,MTCA		;AND IF MT OR CA
	BEQ	MCDIR		;GO DO SPECIAL DIRECTORY PROCESS
	JSR	PC,OPNDIR	;ELSE, OPEN THE DIRECTORY
	.REOPEN	#AREA,#0,#DSSB	;ON CHANNEL 0
	MOV	#1,RDIR1	;READ FIRST DIRECTORY BLOCK
	BR	1$		;SKIP THE REOPEN
RDDIR:	MOV	#DEVNAM,R5	;Point to nfs lookup area
	MOV	R4,@R5		;Move in device name
	MOV	R0,(PC)+	;Save the directory block number
RDIR1:	.WORD	0
	MOV	R5,R0		;Point to name for MTCA
	JSR	PC,MTCA		;If it's an MT or CT
	BEQ	MCDIRR		;GO DO MT OR CT DIRECTORY
	.REOPEN	#AREA,#0,#DSSB	;REOPEN THE DIRECTORY
1$:	MOV	DIRBUF,R5	;POINTER TO INPUT BUFFER
	ASL	RDIR1		;MAKE IT AN ABSOLUTE BLOCK NUMBER
	ADD	#DIRBLK-2,RDIR1	;
2$:	MOV	R5,-(SP)	;Put the pointer on the stack
	ADD	#1024.,@SP	;We need 2 blocks of space
	SUB	USRBAS,(SP)+	;Do we have it?
	BCS	3$		;Branch if yes.
	JSR	PC,CHKCOR	; else try to get more
	BR	2$		;  and check again
3$:	.READW	#AREA,#0,R5,#512.,RDIR1	;READ 2 BLOCKS INTO USRBUF
	BCS	BADDIR		;ERROR READING DIRECTORY
	CMP	4(R5),#37	;THIS ISNT A SURE TEST
	BHI	ILGER
	.SAVEST	#AREA,#0,#DSSB	;SAVE THE STATUS OF THE DIRECTORY
	TST	(R5)+		;SKIP NBLOCKS
	MOV	(R5)+,R0	;POINTER TO NEXT DIR BLOCK
	TST	(R5)+		;SKIP HIGHEST SEGMENT NUMBER
	MOV	(R5)+,(PC)+	;GET EXTRA WORD COUNT
XTRABY:	.WORD	0
	TST	(R5)+		;SKIP FILE BEGINNING BLOCK
	RTS	PC
	.DSABL	LSB
BADDIR:	ERROR	ERRDDR,1
ILGER:	ERROR	ILLDIR,1
	.SBTTL ;MCDIR
;MCDIR READS AN MT OR CT DIRECTORY.
;WHEN ENTERED THROUGH MCDIR IT REWINDS THE VOLUME READS ITS 1ST LABEL
;AND RETURNS AN ENTRY IN USRBUF SIMILAR TO THOSE IN THE DIRECTORY OF A FILE
;STRUCTURED DEVICE.  ON SUBSEQUENT CALLS TO MCDIRR IT READS AND RETURNS THE NEXT LABEL
;IT ENCOUNTERS.  WHEN IT REACHES LEOT OR PEOT IT RETURNS AN END-OF-
;DIRECTORY ENTRY.


MCDIR:	.ENABL	LSB
	CMPB	DEVINF,#CTIDEN	;Input device a cassette?
	BNE	1$		;Branch if no
	CLR	2(R5)		; else 
	.LOOKUP	#AREA,#0,R5	; LOOKUP THE CASSETTE NFS
	JMP	CTDIR		; and GO DO A CASSETTE DIRECTORY SEARCH
1$:	MOV	R1,-(SP)	;Save R1 and R4
	MOV	R4,-(SP)	;
	TST	FILINO		;What kind of /M value did he give
	BGT	10$		;Positive.  Go let handler position us
2$:	JSR	PC,MTNFS	;NON-FILE STRUCTURED LOOKUP TO MT
	BCS	BADDIR		;Lookup failed
	TST	FILINO		;/M:0?
	BEQ	3$		;YES
	JMP	FNDPOS		;NO.  NEGATIVE.  GO FIND POSITION
3$:	JSR	R5,SPFUN	;REWIND BEFORE DIRECTORY
	.BYTE	377,-5
4$:	JSR	PC,SKPVL1	;SKIP VOL1 IF MT
	BR	7$		;AND GO DO THE DIRECTORY
MCDIRR:	MOV	R1,-(SP)	;Preserve R1 and R4
	MOV	R4,-(SP)	;
	.WAIT	#0		;See if channel already open
	BCC	5$		;Branch if it was
	JSR	PC,MTNFS	;Else open it NFS
	BCS	BADDIR		;Failed for some reason
	BR	6$		; else skip the forward space
5$:	JSR	R5,SPFUN4	;SPACE TO EOF1 LABEL
	.BYTE	377,-2		;(FORWSP CODE)
	BCC	6$		;No error
	JSR	PC,CHKTM	;See if 'TM ENCOUNTERED' error
6$:	JSR	R5,SPFUN4	;Get past the next TM
	.BYTE	377,-2		;(FORWSP CODE)
	BCC	7$		;No error
	JSR	PC,CHKTM	;Check the error
7$:	JSR	PC,READMT	;READ A BLOCK (should be HDR1)
	BCC	8$		;NO ERROR
	JSR	PC,CHKIN	; else see what kind
8$:	CMP	@R5,#EOF1	;Is this an EOF label?
	BEQ	6$		;Branch on yes.  Try again
	CMP	@R5,#HDR1	;Is it an HDR label
	BNE	REWDIR		;Branch if not.  It's an error
	JSR	PC,ASCR50	; else convert the filename to ASCII
	BIT	#DIREMP,DIRBUF+12  ;Was it a deleted file (Pre V3)
	BNE	5$		;Branch if yes.  Try the next one
ENDSEG:	MOV	DIRBUF,R5	;Point to the input buffer
	MOV	#DIREOB,30(R5)	;Say the second file is end-of-block
	MOV	SP,R0		;Say there's a next block
	BR	9$		;
DUNMCD:	CLR	R0		;Say there's no next block
9$:	CLR	XTRABY		;No extra bytes
	MOV	(SP)+,R4	;Restore R4 and R1
	MOV	(SP)+,R1	;
	RTS	PC		;And return to caller
10$:	CLR	2(R5)		;Do a NFS Lookup to position the
	JSR	PC,LOOKUP	; tape for us
	BNE	11$		;Branch if no error
	.CLOSE	#0		; else close the channel
	BR	CHKIN1		;and assume that we're done
11$:	.CLOSE	#0		;Close the channel
	SUB	#10,R5		;Restore R5 to old value
	JSR	PC,MTNFS	;Do a NFS Lookup
	BCC	12$		;Branch if no error
	JMP	BADDIR		; else issue error message
12$:	MOV	#4,CNT1		;Close left us after the file
13$:	JSR	R5,SPFUN4	;so backspace 4 times
	.BYTE	377,-3		;
	BCC	15$		;
	CMP	TEST,#4		; or until BOT
14$:	BEQ	4$		;
15$:	DEC	(PC)+		;
CNT1:	.WORD	0
	BNE	13$		;
	JSR	R5,SPFUN1	; and then forward space over TM
	.BYTE	377,-2
	BR	7$		; and go read the label

;FNDPOS is used to locate our position on the magtape.  This is done by
;back spacing until an EOF label or BOT is encountered.  When this has
;been done, we continue at the appropriate place in the main routine.

FNDPOS:	JSR	R5,SPFUN4	;BS TM
	.BYTE	377,-3
	BCC	16$
	CMP	TEST,#4		;BOT?
	BEQ	14$		;Branch if yes.
16$:	JSR	R5,SPFUN4	;FS TM
	.BYTE	377,-2
	JSR	PC,READMT
	BCC	17$		;No error
	JSR	PC,CHKIN	;Else go find out what kind.
17$:	CMP	@R5,#EOF1	;FOUND EOF1 LABEL?
	BEQ	6$		;YES.  CONTINUE
	JSR	R5,SPFUN4	;ELSE, BS TM
	.BYTE	377,-3
	BR	FNDPOS		;ELSE CONTINUE
	.DSABL	LSB

MTNFS:	CLR	2(R5)		;NON-FILE LOOKUP TO OPEN CHANNEL
	.LOOKUP	#AREA,#0,R5,#-1
	RTS	PC
	.ENABL	LSB
CHKIN:	TSTB	@#EMTERR	;WHAT KIND OF ERROR
	BNE	1$		;EOT AND/OR LEOT
	TST	(SP)+
CHKIN1:	MOV	DIRBUF,R5
	MOV	#DIREOB,12(R5)
	BR	DUNMCD
1$:	CMP	TEST,#6		;SHORT BLOCK READ? (RSTS TAPES)
	BEQ	RTS3
REWDIR:	JSR	R5,SPFUN	;ON ERROR, REWIND TO GET KNOWN POSITION
	.BYTE	377,-5		;(REWIND CODE)
	JSR	PC,SKPVL1	;IF MT,FSPACE OVER VOL1
	JMP	BADDIR		;AND TAKE ERROR EXIT
	.DSABL	LSB


READMT:	MOV	DIRBUF,R5	;POINT R5 TO INPUT BUFFER FOR READS
	MOV	R5,R4		;USE 1ND HALF OF BUFFER FOR DIRECTORY
	ADD	#32,R5
	ADD	#12,R4		;DIRECTORY'S HAVE 5 WORDS AT TOP
	MOV	R5,-(SP)
	ADD	#512.,@SP
	SUB	USRBAS,(SP)+
	BCS	1$
	JSR	PC,CHKCOR
1$:	.SPFUN	#AREA,#0,#-10,R5,#256.,#TEST  ;READ NEXT BLOCK (HDR1)
RTS3:	RTS	PC

;CTDIR CONVERT THE LABELS ON A CASSETTE TO DIRECTORY FORMAT

CTDIR:	MOV	R1,-(SP)
	MOV	R4,-(SP)
	MOV	DIRBUF,R4
	MOV	R4,R5
	ADD	#44,R4
CTDIR1:	ADD	#6,R4
	MOV	DIRBUF,R5
	.READW	#AREA,#0,R5,#20,#0  ;READ THE FIRST LABEL INTO BUFFER
	BCS	3$		;ASSUME EOT ON ERROR
	TSTB	(R5)		;IF NULL NAME,
	BEQ	3$		;SENTINAL FILE, DONE
	TSTB	14(R5)		;IS SEQUENCE NUMBER 0?
	BEQ	1$		;YES-CONTINUE
	SUB	#6,R4
	BR	2$
1$:	MOV	R2,-(SP)
	MOV	R4,R2
	JSR	PC,CORCHK
	MOV	(SP)+,R2
	JSR	PC,ASCR50	;ELSE, GET NAME INTO DIRECTORY
2$:	JSR	R5,SPFUN	;SPACE TO NEXT FILE
	.BYTE	377,-3		;(NEXTFILE CODE)
	BCC	CTDIR1		;TRY NEXT FILE
	ADD	#6,R4
3$:	MOV	#DIREOB,@R4
	JSR	R5,SPFUN
	.BYTE	377,-5
	.CLOSE	#0
	ADD	#40,DIRBUF
	JMP	DUNMCD
;SPFUN EXECUTES THE SPECIAL FUNCTION WHOSE CODE FOLLOWS THE SUBROUTINE
;CALL.  IT DOES SO BY SETTING UP THE LIST AND EXECUTING EMT 375.
;SPFUN SETS THE WCOUNT TO 0,SPFUN1 SETS IT TO -1

SPFUN4:	MOV	#-1,-(SP)
	BR	SPFUN2
SPFUN1:	MOV	#1,-(SP)	;WC TO 1
	BR	SPFUN2
SPFUN:	CLR	-(SP)		;WC TO 0
SPFUN2:	MOV	#AREA,R0	;PT R0 TO LIST
	MOV	#32*400+0,(R0)+	;LOAD SPECIAL FUNC. CODE, CHANNEL 17
	MOV	#TEST,(R0)+	;SET UP ERROR BLOCK
	CLR	(R0)+		;CLEAR THIS ONE
	MOV	(SP)+,(R0)+	;SET UP WC
	MOV	(R5)+,(R0)+	;GET CODE INTO 5TH WORD
	MOV	#AREA,R0	;RESTORE POINTER TO AREA
	EMT	375		;THEN DO IT
	RTS	R5		;AND GO BACK

;ASCR50 DETERMINES THE TYPE OF ENTRY, NULL OR GOOD, BY THE FIRST LETTER
;OF THE FILE NAME POINTED TO BY R5 AND INSERTS THIS INFORMATION AS THE
;STATUS OF THIS DIRECTORY ENTRY IN THE SLOT POINTED TO BY R4
;THEN IT CONVERTS THE ASCII STRING POINTED TO BY R5 TO 3 RAD50 WORDS
;IN THE SPACE POINTED TO BY R4.
;### ASCR50 WILL IGNORE A '.' (DOT) IN COLUMN 7 OF THE ASCII FILENAME
;AND EXTENSION STRING, SINCE THE MT HANDLER PUTS ONE THERE FOR EASE
;OF TRANSFERABILITY TO RSX  ASCR50 WILL ALSO MAKE FILENAMES
;LIKE  'ABC.DAT' ON MAGTAPE (OR CASSETTE) LOOK LIKE PROPER RT 
;FILENAMES ON THE DIR LISTING.		B.C.
;###
ASCR50:	MOV	#DIREMP,R0	;SET EMPTY IF NON-NULL NAME
	CMPB	@R5,#RUBOUT	;DELETED FILES START WITH RUBOUT
	BEQ	NULNAM
	CMPB	@R5,#ASTRSK	;DELETED FILES ALSO START WITH *
	BEQ	NULNAM
	ASL	R0		;TYPE 4 FOR GOOD NAME
NULNAM:	MOV	R0,(R4)+	;INSERT TYPE AS STATUS OF THIS ENTRY
	MOV	#9.,CTR		;COUNT 9 CHARACTERS
	CMPB	DEVINF,#CTIDEN
	BEQ	NXTCAR
	CMP	(R5)+,(R5)+
NXTCAR:	MOVB	(R5)+,R0	;GET CHAR INTO R0
	CMPB	#'.,R0		;IS CHAR A DOT?			;###
	BNE	R50PAK		;IF NE-NO			;###
	CMP	CTR,#3		;IS THIS CHAR POS 7?		;###
	BLO	R50PAK		;IF PAST 7, TREAT DOT AS DOT	;###
	BEQ	NXTCAR		;IF AT POS. 7 JUST IGNORE DOT	;###
	MOV	#40,R0		;IF BEFORE 7, MAKE DOT A SPACE	;###
	DEC	R5		;AND ADJ PTR TO PAD FILNAM W/SPACES ;###
R50PAK:	DEC	(PC)+		;COUNT DOWN FROM 3
R50CTR:	.WORD	0
	BGT	1$		;SPACE LEFT, SO GO *50
	CLR	(R4)+		;CLEAR THE NEXT WORD
	MOV	#3,R50CTR	;RESET COUNT
1$:	SUB	#72,R0		;CHECK FOR DIGIT
	ADD	#12,R0
	BCC	2$		;NO, GO TRY FOR LETTER
	ADD	#36,R0		;SCALE DIGIT
	BR	4$
2$:	SUB	#20,R0		;REDUCE TO LETTER RANGE
	BLE	3$		;DELIMITER!
	CMP	R0,#32		;A TO Z?
	BLE	4$		;GOT IT
	SUB	#40,R0		;MAY AS WELL TRY LOWER CASE
	BGT	2$
3$:	CLR	R0		;(DELIMITER)-CALL IT A SPACE	;###
4$:	ASL	-(R4)		;*50+CHAR
	ASL	@R4
	ASL	@R4
	ADD	@R4,R0
	ASL	@R4
	ASL	@R4
	ADD	R0,(R4)+	;KEEP POINTING PAST IT
	DEC	(PC)+		;COUNT THIS CHARACTER
CTR:	.WORD	0
	BGT	NXTCAR		;IF MORE LEFT, GET NEXT CHAR
	RTS	PC

;IF DEVICE LAST DSTATUSED INTO DEVINF IS MT, ISSUES A
;SPFUN CALL TO SPACE FORWARD 1 BLOCK

SKPVL1:	CMPB	DEVINF,#CTIDEN	;CASSETTE?
	BEQ	4$		;YES-DONE
1$:	JSR	R5,SPFUN1	;YES-SPACE OVER VOL1 LABEL
	.BYTE	377,-2		;SPACE 1 BLOCK
	MOV	R5,-(SP)	;SAVE R5
	MOV	R0,-(SP)	;AND R0
	MOV	R4,-(SP)
	JSR	PC,READMT
	BCC	2$		;NO ERROR
	JSR	PC,CHKIN
2$:	CMP	@R5,#240	;WAS IT BOOT BLOCK?
	BEQ	3$		;MUST BE BOOT BLOCK:POSITION AFTER IT
	JSR	R5,SPFUN1	;NO-BACKUP AND POSITION BEFORE IT
	.BYTE	377,-3		;BACKSPACE ONE BLOCK
3$:	MOV	(SP)+,R4
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R5	;RESTORE R5
4$:	RTS	PC		;RETURN


CHKTM:	TSTB	@#EMTERR
	BNE	1$
	DEC	TEST
	BNE	1$
	RTS	PC
1$:	JMP	REWDIR

	.SBTTL ;OPNDIR

;OPNDIR WILL OPEN THE DEVICE SPECIFIED BY THE STRING
;POINTED TO BY R5 ON CHANNEL 16.
;It will then do a .SAVESTATUS on the channel.

OPNDIR:	CLR	2(R5)		;DO A NON-FILE-STRUCTURED LOOKUP
	.LOOKUP	#AREA,#16,R5	;LOOKUP THE FILE (OPEN NON-STRUCT)
	BCS	BADJMP		;ERROR LOOKING UP DIRECTORY
	DSTATUS	#DEVINF,R5	;FIND OUT WHAT KIND OF DEVICE
	TST	DEVINF		;WELL, IS IT FILE STRUCTURED?
	BPL	BADJMP		;NOT A DIRECTORY DEVICE
	.SAVEST	#AREA,#16,#DSSB	;SAVE THE STATUS OF THE DEVICE
	RTS	PC
BADJMP:	JMP	BADDIR		;ERROR VECTOR
	.SBTTL ;CONV

;CONV WILL CONVERT THE NUMBER IN R0 TO A DIGIT STRING
;USING RADIX. THE RESULTING STRING OF DIGITS (LESS
;LEADING ZEROES WILL BE POINTED TO BY R1, WITH A NEGATIVE
;BYTE TO INDICATE THE END OF STRING. R3 MAY BE SET TO THE
;DESIRED FIELD WIDTH, IN WHICH CASE CONV WILL INSERT
;SUFFICIENT BLANKS TO RIGHT JUSTIFY THE DIGITS 
;IN THAT FIELD.  R4 IS USED AS A TEMPORARY.

	.ENABL	LSB
CONV:	MOV	#DIGITS,R1	;POINTER TO DIGITS OUTPUT AREA
	MOV	R4,-(SP)	;PRESERVE R4
1$:	CLR	R4		;CLEAR REMAINDER WORD
	MOV	#17,-(SP)	;SET BIT COUNT
2$:	ASL	R0		;SHIFT DIVIDEND-QUOTIENT REG
	ROL	R4		;SHIFT REMAINDER REG
	CMP	R4,(PC)+	;BIG ENOUGH TO SUBTRACT ??
RADIX:	.WORD	0
	BLO	3$		;NO
	SUB	RADIX,R4	;SUBTRACT DIVISOR
	INC	R0		;SET CORRESPONDING BIT IN QUOTIENT
3$:	DEC	(SP)		;ANY MORE BITS ??
	BPL	2$		;YES
	MOVB	R4,-(R1)	;SAVE REMAINDER AS RIGHTMOST DIGIT
	ADD	(SP)+,R3	;DECREMENT DIGIT COUNT
	TST	R0		;ANYTHING LEFT ??
	BNE	1$		;YES, KEEP DIVIDING
4$:	DEC	R3		;ENOUGH CHARACTERS ??
	BMI	5$		;YES, RETURN
	CLRB	-(R1)		;NO. PUT IN LEAD ZERO
	BR	4$
5$:	MOV	(SP)+,R4	;RESTORE R4
	RTS	PC
	.DSABL	LSB
	.NLIST	BEX
	.BYTE	0,0,0,0,0,0,0
DIGITS:	.BYTE	377
	.LIST	BEX
	.SBTTL ;FILCON

;FILCON takes as input a pointer to a device/filename block in R5, and 
;a pointer to the storage location of the ASCII in R2.  R2 is left pointing
;at the start of the ASCII filename.  Blanks are NOT removed.  A ':' is stored
;after the device name.  R5 is left pointing past the device/filename block.

FILCON:	JSR	PC,R50WD	;CONVERT THE DEVICE NAME
	MOVB	#':,(R2)+	;MOVE IN THE COLON
	MOV	R2,CHARS	;POINT TO STORAGE FOR NAME
				;Fall thru to convert the filename

	.SBTTL ;FNAML

;FILCON converts the filename pointed to by R5 into ASCII, and stores it at
;the location pointed to by CHARS.  Blanks are inserted before and after the
;extension (required by MATCH).  R5 is updated past the filename.

FNAML:	MOV	R2,-(SP)	;SAVE R2
	MOV	CHARS,R2	;STORAGE FOR ASCII CHARACTERS
	JSR	PC,R50WD	;FIRST 3 CHARS
	JSR	PC,R50WD	;NEXT 3
	MOVB	#40,(R2)+	;STORE A BLANK
	JSR	PC,R50WD	;GET THE EXTENSION
	MOVB	#40,(R2)+	;AND A BLANK AT THE END
	MOV	(SP)+,R2	;RESTORE R2
	RTS	PC

	.SBTTL ;R50OUT

;R50OUT WILL CONVERT A RAD50 FILE NAME TO ASCII AND STORE IT IN
;CHARS.  SPACES ARE STORED FOR 0 AND 33.  34 CONVERTS TO '.'.
;35 CONVERTS TO '/'.  R50OUT uses CONV.

R50WD:	MOV	(R5)+,R0	;GET THE RAD50 WORD
R50OUT:	MOV	R3,-(SP)	;PRESERVES R3, R1
	MOV	R1,-(SP)
	MOV	#3,R3		;OUTPUT THREE CHARS ALWAYS
	MOV	#50,RADIX	;SET RADIX TO 50
	JSR	PC,CONV		;CONVERT FROM RAD 50
1$:	MOVB	(R1)+,R0	;GET NEXT CHARACTER
	BMI	5$		;MINUS IS INDICATOR CHARACTER
	BEQ	2$		;ZERO IS A BLANK
	CMP	R0,#32		;IS IT A LETTER  (1-32)  ??
	BLE	3$		;YES
	SUB	#36,R0		;IS IT A DIGIT  (36-47)  ??
	CMP	#-3,R0		;% OR * (34,35) OR DIGIT (36-47)??
	BLT	4$		;YES
2$:	MOV	#-40,R0		;PRINT A SPACE FOR 0,33
3$:	ADD	#20,R0		;CONVERT FROM (1-32) TO (101-132)
4$:	ADD	#60,R0		;CONVERT FROM (34-47) TO (56-71)
	MOVB	R0,(R2)+	;STORE THE CHAR
	BR	1$
5$:	MOV	(SP)+,R1
	MOV	(SP)+,R3
	RTS	PC
	.SBTTL ;FNOUT
FNOUT:	MOV	R2,-(SP)	;SAVE R2
	MOV	R1,-(SP)	;AND R1
	MOV	CHARS,R0	;POINT TO FILE NAME STRING
	MOV	R0,R2		;GET END POINT OF STRING
	ADD	#16,R2		;
	MOV	R0,R1		;POINTER FOR BLANK REMOVAL
	MOVB	#'.,12(R0)	;PUT IN THE DOT
1$:	CMPB	@R0,#40		;IS IT A BLANK?
	BEQ	3$		;YES
	MOVB	(R0)+,(R1)+	;NO.  MOVE IT IN
2$:	CMP	R0,R2		;ARE WE DONE?
	BHIS	4$		;BRANCH IF SO
	BR	1$		;ELSE CONTINUE
3$:	INC	R0		;SKIP THE BLANK
	BR	2$		;AND CONTINUE
4$:	CMPB	-1(R1),#'.
	BNE	5$
	CMPB	-2(R1),#':
	BNE	5$
	DEC	R1
	BR	6$
5$:	CMP	R1,R2		;HAVE TO BLANK FILL?
	BHIS	6$		;DONE
	MOVB	#40,(R1)+	;MOV IN BLANK
	BR	5$		;AND CONTINUE
6$:	MOVB	#200,@R1	;NO <CRLF> AFTER PRINTING THE NAME
	MOV	(SP)+,R1	;RESTORE REGISTERS
	MOV	(SP)+,R2	;
	.PRINT 	CHARS		;AND PRINT THE FILE NAME
	RTS	PC
	.SBTTL ;YESCHK

;YESCHK GETS A FULL LINE FROM THE TTY
;IT RETURNS CC EQUAL IF THE FIRST CHAR WAS "Y"
;OTHERWISE CC NONEQUAL

YESCHK:	.PRINT	#QMARK		;Print a question mark
	.TTYIN			;READ CHARACTER FROM TT:
	MOV	R0,-(SP)	;SAVE THE RESPONSE CHARACTER
1$:	.TTYIN			;GET NEXT TT: CHARACTER
	CMP	R0,#12		;IS IT A LINE FEED ??
	BNE	1$		;NO, KEEP SKIPPING
	CMP	(SP)+,#'Y	;WAS RESPONSE "Y......"  ??
	RTS	PC
	.SBTTL ;MATCH

;ON ENTRY R1 POINTS TO THE TEST STRING AND R2 POINTS TO THE
;FILE STRING (MATCH STRING).  R0 EXITS NON-ZERO ON A MATCH.

MATCH:	MOV	R4,-(SP)	;SAVE REGISTERS USED
	MOV	R3,-(SP)	;
	MOV	R1,-(SP)	;
	MOV	R2,-(SP)	;
	JSR	PC,MATCH1	;AND DO THE MATCH
	MOV	(SP)+,R2	;RESTORE THE REGISTERS
	MOV	(SP)+,R1	;
	MOV	(SP)+,R3	;
	MOV	(SP)+,R4	;
	RTS	PC		;AND RETURN TO CALLER
MATCH1:	CLR	R0		;ASSUME FAILURE
	MOV	#40,R4		;USED OFTEN, WASTE A REGISTER
1$:	MOVB	(R1)+,R3	;GET PATTERN CHARACTER AND BUMP POINTER
	CMPB	R3,#'/		;ARB MATCH (* WAS CONVERTED TO /)
	BNE	2$		;NO MATCH
	CMPB	@R1,R4		;END OF STRING?
	BEQ	5$		;YES.  ARB MATCH
2$:	CMPB	R4,@R2		;CHECK FOR END OF STRING
	BEQ	3$		;BRANCH IF YES
	CMPB	R4,R3		;AT PATTERN END
	BEQ	6$		;BRANCH AT PATTERN END
	CMPB	R3,#'/		;ARB MATCH?
	BEQ	5$		;BRANCH IF YES
	CMPB	(R2)+,R3	;ARE CHARS IDENTICAL?
	BEQ	1$		;BRANCH IF YES TO CONTINUE COMPARE
	CMPB	R3,#'.		;WILD CHAR POSITION? (% -> .)
	BEQ	1$		;BRANCH IF YES TO CONTINUE COMPARE
	BR	6$		;NONE OF ABOVE. RETURN WITH FAILURE
3$:	CMP	R4,R3		;AT END OF STRING, AT END OF PATTERN?
	BNE	6$		;BRANCH IF NO. RETURN WITH FAILURE
4$:	INC	R0		;SUCCESS!!!!!!!
	BR	6$		;RETURN A LEVEL
5$:	MOV	R1,-(SP)	;RECURSIVE ARB MATCHER, SAVE STATE
	MOV	R2,-(SP)
	JSR	PC,1$		;CALL SELF
	MOV	(SP)+,R2	;RESTORE STATE
	MOV	(SP)+,R1	;
	TST	R0		;SUCCESS???
	BNE	6$		;BRANCH ON SUCCESS TO PERCOLATE UP
	CMPB	R4,(R2)+	;AT END OF STRING? MAKE * COVER 1 MORE
	BNE	5$		;BRANCH IF NO. TRY AGAIN
6$:	RTS	PC		;RETURN TO PREVIOUS LEVEL
	.SBTTL ;WLDCHK

;THIS PROCEDURE CHECKS AN ASCII FILE NAME FOR WILD CARDS.
;THE FILE NAME MUST LOOK LIKE
;	FFFFFFBXXXB
;WHERE  'F' IS THE FILENAME, 'X' IS THE EXTENSION, AND 'B' IS A 
;BLANK.  R3 RETURNS AS 1 IF THERE IS A WILDCARD IN THE NAME, 2 IF
;IN THE EXTENSION, AND 3 IF IN BOTH.  R3 IS NEGATIVE IF THERE IS AN
;EMBEDDED * OR ANY % IN THE FILENAME OR EXTENSION.  THE FILENAME IS 
;POINTED TO BY CHARS


WLDCHK:	MOV	R3,-(SP)	;PRESERVE R0
	MOV	R1,-(SP)	; AND R1
	CLR	R1		;CLEAR THE EMBEDDED FLAG
	CLR	-(SP)		;CLEAR THE COUNTER
	MOV	#6,R0		;CHECK THE 1ST 6 CHARS
	MOV	CHARS,R3	;POINT TO THE THING
1$:	CMPB	@R3,#'.		;IS IT A '%'?
	BEQ	5$		;YES
	CMPB	(R3)+,#'/	;NO.  IS IT A '*'?
	BEQ	4$		;YES
	DEC	R0		;DECREMENT THE CHAR COUNT
	BNE	1$		;NOT DONE.  CHECK ANOTHER CHAR
	SUB	CHARS,R3	;WHERE ARE WE?
	CMP	R3,#12		;FINISHED CHECKING THE EXTENSION?
	BLT	7$		;NO.  MORE WORK TO DO
2$:	TST	R1		;EMBEDDED WILD CARD OR '%'
	BEQ	3$		;NO
	NEG	@SP		;YES.  NEGATE THE COUNTER
3$:	MOV	(SP)+,R0	; AND PUT IT IN R3
	MOV	(SP)+,R1	;RESTORE THE REGISTERS
	MOV	(SP)+,R3
	TST	R0
	RTS	PC		;AND RETURN TO CALLER
4$:	CMPB	@R3,#40		;BLANK FOLLOWING?
	BNE	5$		;NO
	TSTB	-(R3)		;MOVE THE POINTER BACK
	CMP	R3,CHARS	;ARE WE AT THE BEGINNING?
	BEQ	6$		;YES
	CMPB	-1(R3),#40	;NO.  IS THERE A PRECEDING BLANK
	BEQ	6$		;YES
5$:	INC	R1		;NO.  SET EMBEDDED FLAG
6$:	INC	@SP		;INCREMENT COUNTER
	SUB	CHARS,R3	;FIND OUT WHERE WE ARE
7$:	CMP	R3,#6		;IN THE FILENAME?
	BGT	8$		;NO. IN THE EXTENSION
	MOV	CHARS,R3	;YES.  POINT TO THE FILENAME
	ADD	#7,R3		;POINT TO THE EXTENSION
	MOV	#3,R0		;CHECK 3 CHARS THIS TIME
	BR	1$		;GO DO THE CHECKING
8$:	INC	@SP		;INCREMENT THE COUNTER
	BR	2$		;AND CONTINUE
	.SBTTL ;LOGCHK and QUECHK

;LOGCHK and QUECHK do the logging and querying for PIP.  They also
;call on NOR and PRE to take care of the /N (NOREPLACE) and /O (OUTPUT
;PREDELETE) options.  They are entered with the input filename pointed to
;by R5 and the output filename (if any) in NEWNAM.  If for any reason
;the input file is not to be acted upon, @R5 is replaced by -1 and the 
;Z-bit is set.

	.ENABL	LSB
LOGCHK:	TST	LOGGIN		;LOGGING MODE SET?
	BEQ	5$		;NO
	CLR	(PC)+		;SAY NOQUERY
QUERY1:	.WORD	0
	CMP	@R5,#-1		;DID HE SAY NO TO A QUERY?
	BEQ	5$		;YES.  DON'T LOG IT THEN
	BR	LOGGIT
QUECHK:	INC	QUERY1		;
	TST	QUERY		;QUERY MODE?
	BNE	1$		;YES
	CMP	@R5,#-1		;ALREADY CHECKED THIS FILE?
	BEQ	5$		;YES.  DON'T DO IT AGAIN
	JSR	PC,NOR		;CHECK FOR NO REPLACE
	BEQ	5$		;FILE WAS THERE.  NO OPERATION DONE
	BR	PRE		;DO PRE-DELETE IF NEEDED
1$:	JSR	PC,NOR		;CHECK FOR NO REPLACE
	BEQ	5$		;FILE WAS THERE
LOGGIT:	MOV	R5,-(SP)	;SAVE REGISTERS FROM FILE NAME CONVERT
	MOV	R0,-(SP)	;
	MOV	R2,-(SP)	;
	MOV	#TEST,R2	;STORAGE PLACE FOR ASCII FILE NAME
	MOV	R2,CHARS	;
	JSR	PC,FILCON	;CONVERT THE FILE NAME TO ASCII
	MOV	#TEST,CHARS
	JSR	PC,FNOUT	;AND PRINT IT
	CMP	ACT,#DELETE	;IS THIS FOR DELETE?
	BEQ	2$		;YES.  NO OUTPUT SIDE TO PRINT
	.PRINT	#CPTO		;PRINT ' TO '
	MOV	CHARS,R2	;RESTORE POINTER TO ASCII CHARS
	MOV	#NEWNAM,R5	;POINT TO OUTPUT FILE SPEC
	JSR	PC,FILCON	;AND CONVERT IT TO ASCII
	MOV	#TEST,CHARS
	JSR	PC,FNOUT	;AND PRINT IT
2$:	TST	QUERY1		;QUERY MODE?
	BEQ	3$		;NO
	JSR	PC,YESCHK	;ASK THE USER
	BEQ	4$		;HE SAID OK.  SO DOIT
	MOV	(SP)+,R2	;RESTORE REGISTERS
	MOV	(SP)+,R0	;
	MOV	(SP)+,R5	;
	MOV	#-1,@R5		;MARK FILE NOT TO BE DONE
	SEZ			;SET CC'S
	BR	5$		;SKIP PRE-DELETE ON NOREPLACE
3$:	.PRINT	#QUICR		;ELSE, LOGGING MODE. PRINT <CRLF>
4$:	MOV	(SP)+,R2	;RESTORE REGISTERS
	MOV	(SP)+,R0	;
	MOV	(SP)+,R5 
	TST	QUERY1		;
	BEQ	5$
	BR	PRE		;DO PRE-DELETE IF NEEDED
5$:	RTS	PC
	.DSABL	LSB
	.SBTTL ;NOREPLACE and PREDELETE

NOR:	TST	NOREP		;IS IT NORPELACE?
	.ENABL	LSB
	BEQ	2$		;NO
	MOV	R0,-(SP)	;YES.
	.LOOKUP	#AREA,#16,#NEWNAM  ;LOOKUP THE FILE
	BCC	4$		;NO ERROR. THE FILE IS THERE.
	TST	@#EMTERR	;WHAT KIND OF ERROR
	BNE	1$		;FILE NOT FOUND.  RETURN WITH Z=0
SISERR:	ERROR	SYSERR,2	;ELSE ERROR.
	BISB	#SEVERE,@#ERRBYT
	.EXIT			;AND QUIT
1$:	MOV	(SP)+,R0	;RESTORE R0
2$:	CLZ			;RETURN Z=0
3$:	RTS	PC		;AND RETURN
4$:	ERROR	NOTDUN,0,R5
	.PURGE	#16		;PURGE THE CHANNEL
	MOV	#-1,@R5
	MOV	(SP)+,R0	;RESTORE R0
	SEZ			;RETURN WITH Z=1
	BR	3$
	.DSABL	LSB

PRE:	TST	OUTDEL		;OUTPUT PRE-DELETE
	BEQ	2$		;NO
	MOV	R0,-(SP)	;SAVE R0
	.DELETE	#AREA,#16,#NEWNAM  ;DELETE THE OUTPUT FILE
	BCC	1$
	TSTB	@#EMTERR	;IS IT A FILE NOT FOUND?
	BEQ	SISERR		;NO.  SOMETHING BAD
1$:	MOV	(SP)+,R0	;RESTORE R0
2$:	CLZ			;SET CC'S
	RTS	PC

	.PSECT	ASCDAT,D
	.NLIST	BEX
CPTO:	.ASCII	\ to \<200>
QMARK:	.ASCII	\? \<200>
	.LIST	BEX
	.PSECT	PIP
	.SBTTL ;ERRMSS- Error message handler

;THIS PROCEDURE PRINTS ALL ERROR MESSAGES GIVEN BY PIP.
;IT IS CALLED BY THE MACRO 'ERROR'.  IF YOU ARE CRAZY
;ENOUGH TO TRY TO CODE IT YOURSELF, HERE IS THE CALLING
;SEQUENCE:
;	JSR	R5,ERRMSS
;	.WORD	FLAGWORD
;WHERE FLAGWORD IS ENCODED THUSLY:
;	BITS	USE
;	----	---
;	0-1	ERROR LEVEL
;		0 => WARNING
;		1 => FATAL, GO TO RESTART
;		2 => FATAL, RETURN TO CALLER
;	2-6	OFFSET TO ADDRESS OF RAD50 DEVICE/FILENAME
;		BLOCK IN 'FILTAB' (PSECT FILTBL)
;		IF BIT 15=1 AND BIT 8=0
;	 7	INDICATES ERROR LEVEL 1
;	 8	IF =1 THEN THE ADDRESS OF THE RAD50
;		DEVICE/FILENAME BLOCK IS ON THE STACK
;		(IT WAS IN R5)
;	9-14	OFFSET TO ADDRESS OF THE ERROR MESSAGE
;		IN $ERTAB (PSECT ER$TBL)
;	 15	IF =1 THEN A FILENAME IS TO BE PRINTED
;		AFTER THE ERROR MESSAGE
;THE OFFSETS INTO THE TABLES ARE CURRENTLY WORD OFFSETS!
;NOTE:	IF THE MACRO IS INVOKED WITH A REGISTER HOLDING
;	THE POINTER TO THE FILENAME, THAT REGISTER MUST
;	BE R5.

ERRMSS:	.RCTRLO			;RESET CONTROL O
	MOVB	#'F,ERHD2	;ASSUME FATAL ERROR
	INC	ERRFLG
	CLR	(PC)+		;ASSUME A RETURN TO THE CALLER
RESTRT:	.WORD	0
	BIT	#3,@R5		;NON-FATAL ERROR
	BNE	1$		;BRANCH ON NO
	MOVB	#'W,ERHD2	;NO.  MAKE IT A WARNING MESSAGE
	DEC	ERRFLG		;'MAY AULD ACQUAINTANCE BE FORGOT'
	BISB	#WARN,@#ERRBYT	;SET THE RT ERROR BYTE
	BR	3$
1$:	TSTB	@R5		;IF FATAL ERROR WITH NO RETURN
	BPL	2$
	MOV	SP,RESTRT	;SET THE RESTART FLAG
2$:	BISB	#ERROR,@#ERRBYT
3$:	.PRINT	#ERHD1		;PRINT '?PIP-'
	MOV	@R5,R0		;PICK UP THE FLAG WORD
	BIC	#100777,R0	;LEAVE ONLY THE OFFSET TO THE ERROR MESSAGE
	SWAB	R0		;GET THE OFFSET
	MOV	$ERTAB(R0),R0	;AND GET THE ADDRESS OF THE MESSAGE
	.PRINT			;AND PRINT THE ERROR MESSAGE
	MOV	@R5,R0		;GET THE FLAG WORD AGAIN
	BIC	#177603,R0	;GET OFFSET TO THE FILENAME ADDRESS
	ASR	R0		;FIX IT TO A WORD OFFSET
	MOV	R5,-(SP)	;SAVE R5
	TST	@R5		;ANYTHING LEFT TO PRINT?
	BPL	10$		;NO FILENAME TO PRINT
	BIT	#400,@R5	;IS THE FILENAME ADDRESS IN THE TABLE
				;OR ON THE STACK?
	BEQ	4$		;IN THE TABLE IF EQUAL
	MOV	2(SP),R5	;GET THE ADDRESS
	BR	5$		;AND CONTINUE
4$:	MOV	FILTAB(R0),R5	;GET THE ADDRESS FROM THE TABLE
5$:	MOV	R2,-(SP)	;SAVE FROM THE FILE NAME COVERSION
	MOV	#TEST,R2	;POINT TO STORAGE FOR ASCII STRING
	JSR	PC,FILCON
	MOV	#TEST,R2
	MOV	R2,CHARS	;SAVE FOR THE FILE NAME CONVERSION
6$:	CMPB	@R2,#'.		;IS IT A CONVERTED %?
	BNE	7$		;NO
	MOVB	#'%,@R2		;YES.  PUT IT BACK
7$:	CMPB	@R2,#'/		;A CONVERTED *?
	BNE	8$		;NO
	MOVB	#'*,(R2)+	;YES RECONVERT
	BR	9$
8$:	TSTB	(R2)+
9$:	CMP	R2,#TEST+15	;DONE? 
	BLOS	6$		;NO
	JSR	PC,FNOUT
	MOV	(SP)+,R2	;RESTORE R2
10$:	.PRINT	#QUICR		;STICK IN A <CRLF>
	MOV	(SP)+,R5
	TST	(R5)+		;SKIP OVER THE FLAG WORD
	TST	RESTRT		;RETURN TO CALLER?
	BNE	11$		;NO
	RTS	R5		;YES.  RETURN TO CALLER
11$:	JMP	START		;RESTART

	.PSECT	ASCDAT,D
	.NLIST	BEX
ERHD1:	.ASCII	\?PIP-\
ERHD2:	.ASCII	\F-\<200>
	.LIST	BEX
	.PSECT	PIP
	.SBTTL ;Error messages
	.PSECT	ASCDAT,D


	.NLIST	BEX
CHKSUM:	.ASCII	\Check sum error \<200>
DEVFUL:	.ASCII	\Device full \<200>
DEVUSE:	.ASCII	\Device in use \<200>
ERRDDR:	.ASCII	\Error reading directory\<200>
ERRLIB:	.ASCII	\Library file not copied \<200>
ERTMOF:	.ASCII	\Too many output files\<200>
FILFND:	.ASCII	\File not found \<200>
FILOUT:	.ASCII	\Illegal output file \<200>
FSNNF:	.ASCII	\File sequence number not found\<200>
ILDEV:	.ASCII	\Illegal device\<200>
ILLCMD:	.ASCII	\Illegal command\<200>
ILLDEL:	.ASCII	\Illegal delete \<200>
ILLDIR:	.ASCII	\Illegal directory\<200>
ILOPC:	.ASCII	\Illegal option combination\<200>
ILOPT:	.ASCII	\Illegal option\<200>
ILOUTW:	.ASCII	\Illegal use of wildcards \<200>
ILRENM:	.ASCII	\Illegal rename \<200>
ILVALU:	.ASCII	\Illegal option value\<200>
INERR:	.ASCII	\Input error \<200>
NOMEM:	.ASCII	\Insufficient memory\<200>
NOSYS:	.ASCII	\No .SYS action\<200>
NOTDUN:	.ASCII	\Output file found, no operation performed \<200>
OUTERR:	.ASCII	\Output error \<200>
OUTFUL:	.ASCII	\Output file full \<200>
RBMSG:	.ASCII	<7>\Reboot\<7><200>
SYSERR:	.ASCII	<7>\System error\<7><200>
TURBON:	.ASCII	\Use DIR\<200>
	.EVEN
	.LIST	BEX
	.PSECT	PIP
	.SBTTL ;Storage declarations
	.PSECT	IMPURE,D
FLEFND:	.BYTE	0		;"File has been found" flag
FILDON:	.BYTE	0		;"File has been expanded" flag
ERRFLG:	.WORD	0		;Error detected flag
DATLST:	.WORD	0		;Pointer to date que for FIXDAT, GETDAT
BYTMP:	.WORD	0		;Temporary for binary copy
RWCNT:	.WORD	0		;Number of words to read
DEVNAM:	.BLKW	2		;USED FOR NON FILE STRUCTURED OPEN
OLNAME:	.BLKW	4		;OLD NAME SPACE FOR RENAME
NEWNAM:	.BLKW	5		;NEW NAME SPACE FOR RENAME
DEVINF:	.BLKW	5		;DEVICE INFORMATION BLOCK
DSSB:	.BLKW	5		;DIRECTORY SAVE STATUS BLOCK
SSB:	.BLKW	5		;SAVE STATUS BLOCK
AREA:	.BLKW	7		;EMT area block
TEST:	.BLKW	10		;ASCII FILE NAME AREA
DATTBL:	.BLKW	15		;Date que area for FIXDAT, GETDAT
ASCFIL:	.BLKW	46		;ASCII FILE NAME AREA
FILDES:	.BLKW	47		;OUTPUT AREA FOR CSI
	.PSECT	PIP
FREE:	.WORD	.+2		;FREE CORE
				;HANDLERS
				;BUFFER(S) (/S & /U)
				;EXPANDED INPUT LIST & DIRECTORY BUFFER
				;STATUS BLOCKS FOR INPUT LIST & /R)
				;BUFFER(S)
	.END	BEGIN
                                                                                                                                                                                                                       