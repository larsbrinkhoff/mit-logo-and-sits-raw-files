.TITLE DUP V03.01
.IDENT /VO3.01 /
; RT-11 DUP DISK UTILITY PROGRAM
;
; DEC-11-ORTSB-A
;
; COPYRIGHT (C) 1977
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE
; OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE MADE
; AVAILABLE TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO
; ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE TO AND OWNERSHIP OF THE
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DEC.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE 
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DEC.
;
;	J.D.
; THINGS TO DO

.SBTTL	MACRO DEFINITIONS

.MCALL	..V2..,.RELEAS,.LOCK,.UNLOCK,.SCCA,.GTLIN,.GTIM,.ENTER
.MCALL	.CLOSE,.CSISPC,.DELETE,.DSTATU,.FETCH,.HRESET,.PURGE
.MCALL	.LOOKUP,.PRINT,.RCTRLO,.RENAME,.REOPEN,.SAVEST,.MTPS
.MCALL	.SETTOP,.TTYIN
.MCALL	.READW,.WAIT,.DATE,.WRITW,.EXIT,.REGDEF,.QSET
.MCALL	.CSIGEN,.SERR,.TRPSET,...CM1,...CM2,...CM3

..V2..	;USE V2 MACRO FORMAT
.REGDEF	;DEFINE REGISTERS

;

;DIRECTORY DEFINITIONS
DIRTEN  = 400			;FIRST WORD ON A TENTATIVE DIR ENTRY
DIRPER	= 2000			;FIRST WORD ON A PERMANENT DIR ENTRY
DIREMP	= 1000			;FIRST WORD OF AN EMPTY DIRECTORY ENTRY
DIRSIZ	= 16			;SIZE OF DIRECTORY ENTRY WITH NO EXTRA WORDS
DIRSTR	= 6			;DIRECTORY STARTS IN BLOCK 6
MAXDIR	= 37			;MAXIMUM DIRECTORY SIZE IN SEGMENTS
DIRDFT	= 4			;DEFAULT DIR. SIZE IN SEG.
DIREOB	= 4000			;DIRECTORY END OF BLOCK


;MONITOR VALUES
IFACTV = 400			;INDIRECT FILE OPEN BIT
FGACTV	= 200			;BIT 7  OF THE CONFIG WORD WILL BE SET IF F IS ACTIVE


;MONITOR OFFSETS
CONFIG	= 300			;FIXED OFFSET OF THE CONFIGURATION WORD.
BLKEY   = 256			;OFFSET TO BLKEY IN MONITR
				;IS DIR. SEGMENT IN USRBUF.
STATWD	= 366			;DCLS/INDIRECT FILES STATE WORD.
USRRBT  = 1000			;USR RESIDENT BIT IN CONFIG
USRBOF  = 266			;OFFSET INTO RMON FOR NORMAL LOAD
				;ADDRESS OF USR.
SYSUNT	= 275			;OFFSET OF UNIT # OF SYS:
SYSIDX	= 364			;OFFSET OF INDEX INTO TABLES OF SYS:
XM	= 10000			;XM BIT IN CONFIG.



;MONITOR BOOT OFFSETS
BOOTST	= 500			;START OF BOOT AFTER READS.
BOOTIM	= 5000			;ADDRESS TO STORE TIME IN THE BOOT.
BOODAT	= 5004			;ADDRESS TO STORE THE DATE IN THE BOOT.
				;VALUES TO STORE IN THE DX BOOTSTRAP.
DXUNIT	=224			;ADDRESS TO STORE THE UNIT NUMBER IN THE DX SECONDARY BOOT.
DXRDCMD	= 130			;ADDRESS TO STORE READ COMMAND.
DXREADF	= 612			;ADDRESS OF READ ROUTINE.
DXRDX	= 150			;ADDRESS TO STORE JMP TO READF.
DXUN0	= 7			;READ VALUE FOR UNIT 0.
DXUN1	= 27			;READ VALUE FOR UNIT 1.

;MONITOR SOFTWARE COMMUNICATION WORDS
JSW	= 44			;JOB STATUS WORD
GTLIN$	=10			;BIT TO SET FOR GET LINE TO GET INPUT FROM TERMINAL.
STRTAD	= 40			;START ADDRESS LOC.
SYSPTR	= 54			;ADDRESS THAT CONTAINS THE LOW ADDRESS OF THE MONITOR
IOERRB	= 52			;I/O ERROR BYTE.
USERRB	 =53			;ERROR BIT FOR DCLS/INDIRECT FILES.
SEVERR	= 10			;SEVERE ERROR BIT IN USERRB.
TTYCON	= 56			;TERMINAL CR,LF CONTROL
FNF	= 1			;BYTE 52=1 ON FILE NOT FOUND
DIU	= 2			;BYTE 52=2 ON DEVICE IN USE.


;RK06 DISK CONSTANTS
RK6RBS	= 27060.		;RK06 FIRST PHYSICAL REPLACEMENT BLOCK
RK6HRB	= 27103.		;HIGHEST RK06 REPLACEMENT BLOCK
RK6ERT	= 27104.		;FIRST SECTOR ON AN RK06 THAT CONTAINS BAD BLOCK INFORMATION.

;VOLUME ID CONSTANTS
DSKCLU	= 722			;PACK ID ADDRESS FOR DISK CLUSTER SIZE
DSKDIR	= 724			;PACK ID ADDRESS FOR DIRECTORY START ADD.
DSKVER	= 726			;PACK ID ADD. FOR RAD50 VERSION NUMBER.
DSKPIL	= 730			;PACK ID LOCATION OF DISKS,WORDS 354-361.
DSKPOL	= 744			;PACK OWNER NAME LOCATION,WORDS 362-367.
DSKFTL	= 760			;PACK FORMAT TYPE LOCATION,WORDS 370-375.
MTPIL	= 4			;MT VOL ID START AT THE 3RD WORD IN VOL 1
MTPOL	= 50			;MT OWNER STARTS AT WORD 21 OF VOL 1

;MT SPECIAL FUNCTION CODES
CTRWND	= -5			;CT REWIND
MTREAD	= -10			;MT READ
MTWRIT	= -7			;MT WRITE
MTRWND	= -5			;MT REWIND
MTTM	= -1			;MT TAPE MARK

;DISK SPECIAL FUNCTION CODES.
SPRAD  = 377			;READ
SPWRT  = 376			;WRITE
SPREP   = 374			;FORCE TO READ REPLACEMENT BLOCK.

;DEVICE IDENTIFICATION CODES IN $STAT
RKIDEN	= 0			;RK11/RK05,RK03
DTIDEN	= 1			;TC11/TU56
TMIDEN	= 11			;TM11/TU10/TS03
RFIDEN	= 12			;RF11/RS11
CTIDEN	= 13			;TA11/TU60
RJIDEN	= 16			;RJS03/4
TJIDEN	= 20			;TJU16
DPIDEN	= 21			;RP11/RP02,RP03
DXIDEN	= 22			;RX11/RX01
DMIDEN	= 23			;RK06

DSTSEQ	= 100000		;BIT 15 IN DSTATUS TABLE ,WORD 1,=1 FOR DISK.
DSTMT	= 10000			;BIT 12 IN DSTATUS TABLE ,WORD 1,=1 FOR MT,CT.

;CSR'S
TPS	= 177564		;CONSOLE TERMINAL CSR
TKS	= 177560		;

;VECTORS
TRPVEC  = 34			;TRAP VECTOR ADDRESS.

;CONSTANTS
STAR	= 132500		;RAD 50 CODE FOR *.
MDUPSZ	= 48.			;SIZE OF MDUP FILE IN BLOCKS

; CONDITIONAL ASSEMBLY PARAMETER
.IIF NDF M$DUP,M$DUP=0

; DUP DOCUMENTATION
;
; 1.PATCHING- IF IT IS NECESSARY TO PATCH DUP AND ADDITIONAL MEMORY
;		IS NEEDED,STORE THE NEW HIGH ADDRESS OF DUP IN FREEM:
;		THE MEMORY BETWEEN FREE AND THE NEW HIGH ADDRESS
;		CAN THEN BE USED FOR PATCHING.
; USE /W IF YOU HAVE AN 8K SYSTEM AND WISH TO REMOVE THE SYSTEMS
; DEVICE.THIS WILL STOP AND WAIT TO REMOVE OR REPLACE THE SYSTEMS DEVICE.
.IF EQ M$DUP
.ASECT
.=JSW
	.WORD	20000		;SET REENTER BIT
.=46
	.WORD	CREATE		;SWAP THE USR STARTING AT CREATE.

.ENDC
.CSECT DUP
	;ONCE ONLY CODE
BEGIN:	MOV	@#SYSPTR,R2	;SET ADDRESS TO DFLG
	ADD	#BLKEY,R2	;GET ADDRESS OF BLKEY IN MONITOR.
	MOV	R2,BLKEYP	;AND SAVE IN BLKEYP.
	ADD	#<CONFIG-BLKEY>,R2	;GET ADDRESS OF CONFIG WORD.
	MOV	R2,CONFGP	;AND STORE IN POINTER.
	ADD	#<USRBOF-CONFIG>,R2	;GET ADDRESS OF OFFSET IN RMON
					;FOR NORMAL LOAD ADDRESS OF USR.
	MOV	R2,USRBAS		;SAVE IN USRBAS.
	MOV	#INIT,@#STRTAD	;STORE RESTART ADDRESS.
START:
REENTR:	BR	INIT		;REENTER POINT.
INIT:	MOV	#START,SP	;SET THE STACK AT RESTR
.IF EQ M$DUP
	JSR	PC,WWAIT	;WAIT HERE IF /W  ACTIVE
.ENDC
				;THE FOLLOWING SETTOP IS NECESSARY
				;AFTER /S IS EXECUTED.
	MOV	FREEM,R0	;DO A SETTOP TO FREE.
	JSR	PC,SETTOP	;THIS WILL ALLOW THE USR TO COME
				;IN WITHOUT SWAPPING.THE HANDLERS
				;IN MEMORY MAY BE DESTROYED.
	.RCTRLO			;RESET CONTROL 0
	.CLOSE	#0		;CLOSE CHANNELS
	.CLOSE	#1
.IF NE M$DUP
	.PURGE	#0		;PURGE CHANNEL THAT CAN'T BE CLOSED.
	.PURGE	#1
.ENDC
.IF EQ M$DUP
	.RELEAS	#INDEV		;RELEASE HANDLERS.
	.RELEAS	#OUTDEV
	JSR	PC,PERMIC	;PERMIT CONTRIL C'C
;	.SCCA	#AREA,#0	;PERMIT CONTROL C'S.
.ENDC
				;INITIALIZE VARIABLES FOR A NEW COMMAND
START1:	CLR	@BLKEYP		;CLEAR USR DIR. SEGMENT KEY TO
				;FORCE A READ OF THE DIR. FOR /T.
	MOV	#<SEND-SWITS>/3,R0	;MOVE -1 INTO SWITS TABLE
	MOV	#SWITS+2,R1
1$:	MOVB	#-1,(R1)
	ADD	#3,R1
	DEC	R0
	BNE	1$
	MOV	#<ZEND-SWITV>/2,R0	;SET THE SWITCH VALUE TABLE =0.
	MOV	#SWITV,R1
2$:	CLR	(R1)+
	DEC	R0
	BNE	2$

COMLIN:	.CSISPC	#OUTSPC,#DEFEXT,#0
	.ENABL	LSB
	BCS	START		;RESTART ON A COMMAND ERROR
				;GET COMMAND SWITCHES
				;AND STORE THE VALUES IN SWITV
				;SET BYTE 3 OF SWITS TO 0 IF THE SWITCH IS
				;FOUND.  SET IT 1 OR 2 IF 1 OR 2 VALUES ARE
				;ALSO GIVEN.
				;WORD 1 OF SWITV WILL ALWAYS BE THE FIRST
				;VALUE AND WORD 2 THE SECOND VALUE
				;SWITS BYTE 1 IS THE SWITCH LETTER AND
				;BYTE 2 THE NUMBER OF VALID VALUES.
	MOV	(SP)+,R0	;NUMBER OF SWITCHES TO READ IN R0
	BEQ	COMTST		;NO SWITCHES
SWTLP:	DEC	R0		;TEST IF ANY SWITCHES TO PROCESS
	BMI	SWITCT		;DONE, EXECUTE COMMAND
	MOV	#SWITV,R3	;ADDRESS OF SWITCH VALUE TABLE
	MOV	#SWITS,R1	;ADDRESS OF SWITCH ID TABLE
1$:	TSTB	(R1)		;AT THE END OF THE ID TABLE
	BNE	22$
24$:	JMP	ISWMES		;YES, SWITCH NOT FOUND, ERROR
22$:	CMPB	(SP),(R1)+	;COMPARE INPUT SWITCH ASCII AGAINST TABLE.
	BEQ	MATCH		;FOUND MATCH
	MOVB	(R1)+,R2	;WERE SWITCH VALUES ALLOWED FOR THIS SWITCH
	BEQ	7$		;NO
	ASL	R2		;YES, MOVE ADDRESS TO NEXT VALUE ENTRY.
	ADD	R2,R3
7$:	TSTB	(R1)+		;POINT TO NEXT SWITCH ID IN SWITS
	BR	1$
MATCH:	MOVB	(R1)+,R2	;R2 HAS THE NUMBER OF VALUES ALLOWED
	TST	(SP)+		;TEST FOR A SWITCH VALUE
	BMI	4$		;BRANCH ON VALUE
	TSTB	(R1)		;NO VALUE, WAS SWITCH PROCESSED BEFORE?
	BGE	CERJ1		;YES, COMMAND ERROR.
	INCB	(R1)+		;NO, SET SWITCH ACTIVE.
	BR	SWTLP

4$:	TSTB	(R1)		;SWITCH HAS A VALUE.  WAS THE SWITCH SEEN BEFORE?
	BGE	5$		;YES
	INCB	(R1)		;NO, SET BYTE 0 TO INDICATE SWITCH ACTIVE.
5$:	INCB	(R1)		;ADD TO NUMBER OF SWITCH VALUES.
	CMPB	(R1),R2		;TOO MANY VALUES GIVEN?
	BGT	CERJ1
				;NOTICE .CSISP GIVES SWITCHES AND VALUES IN
				;REVERSE ORDER, LAST ONES FIRST.
	CMP	R2,#2		;TEST IF SWITCH ALLOWS 1, 2 OR 3 VALUES
	BLO	10$		;ONE VALUE ALLOWED
	BEQ	11$		;TWO VALUES ALLOWED
	ADD	#2,R3		;THREE VALUES ALLOWED, MOVE
	MOV	(R3)+,(R3)	;CONTENTS OF VALUE 2 INTO VALUE 3
	SUB	#4,R3
11$:	MOV	(R3)+,(R3)	;MOVE CONTENTS OF VALUE 1 INTO VALUE 2.
	SUB	#2,R3		;POINT TO WORD 1 OF VALUE LIST
10$:	MOV	(SP)+,(R3)	;STORE THE VALUE FOR THE SWITCH
	BR	SWTLP		;UPDATE R3 POINTING TO THE SWITV TABLE
CERJ1:	JMP	CERMES

COMTST:	TST	INDEV		;NO SWITCH WAS ON THE COMMANS LINE.
.IF NE M$DUP
	BEQ	PRVER		;PRINT VERSION NUMBER.
	INCB	SK+2
	JMP	LOADH
.ENDC
	BNE	CERJ1		;ERROR IF A FILE SPEC WAS GIVEN.
PRVER:	.PRINT	#MESVER		;PRINT VERSION IN RESPONSE TO <CR>
INIT1:	JMP	INIT
	.DSABL	LSB
.IF EQ M$DUP

; TEST FOR REQUIRED SWITCHES

SWITCT:	TSTB	SN+2		;IF /N.
	BPL	1$
	TSTB	SR+2		;/R
	BMI	6$		;/R NO ON
	TSTB	SB+2		;BOTH /R AND /B IS ILLEGAL.
	BPL	4$		;ERROR.
	BR	1$		;OK
6$:	TSTB	SB+2		;OR /B WAS ISSUED
	BMI	2$
1$:	TSTB	SZ+2		;THEN /Z MUST BE SET.
	BPL	2$
4$:	JMP	ISWMES
2$:	TSTB	SH+2		;IF /H
	BPL	3$
	TSTB	SF+2		;OR /F WAS ISSUED
	BMI	5$
3$:	TSTB	SK+2		;THEN /K MUST BE SET.
	BMI	4$
5$:	TSTB	SX+2		;/X
	BMI	LOADH
	TSTB	SS+2		;THEN /S
	BMI	4$
.IFF
SWITCT:
.ENDC
				;TEST TO ZERO DUMMY OUTPUT FILES.
				;THE USR REQUIRES AN OUTPUT FILE
				;TO BE SPECIFIED,IF AN OUTPUT DEVICE
				;IS SPECIFIED.
LOADH:
.IF EQ M$DUP
	TSTB	SU+2		;TEST FOR /U
	;FOR DCLS, COPY /BOOT GENERATES A FILE.* IF
	;THE .SYS IS NOT SPECIFIED.
	BMI	3$
	CMP	#STAR,INFILE+4	;TEST FOR FILE.*/U
	BNE	1$
	MOV	SYS,INFILE+4	;SET TO FILE.SYS
	BR	1$
3$:	TSTB	SI+2		;TEST FOR /I
	;FOR DCLS, COPY /I GENERATES
	;DEV:*.*/I=DEV:*.*
	BMI	4$		;BR IF NO /I
	CMP	#STAR,INFILE	;TEST FOR *.* ON INPUT.
	BNE	7$
	CMP	#STAR,INFILE+4
	BNE	1$
	CLR	INFILE		;ZERO FILE IF *.*
	BR	1$
7$:	TST	INFILE		;TEST FOR INPUT FILE.
	BEQ	1$		;NONE
	INCB	OUTENT		;SET OUTPUT ENTER FLAG
	BR	2$		;DON'T ZERO OUTPUT FILE.
4$:	TSTB	SK+2		;TEST FOR /K
	BMI	8$		;NO /K
	TST	OUTDEV		;TEST IF OUPPUT DEV SPECIFIED.
	BNE	5$		;YES
	MOV	TTNAME,OUTDEV	;NO,OUTPUT SCAN TO TT:.
	BR	5$
8$:	TSTB	SZ+2		;DON'T LOOK FOR /V IF /Z SET.
	BMI	10$		;/Z NOT SET
	TST	OUTDEV		;/Z CAN COME AS
				;	DEV:/Z  OR  DEV:*/Z=
				;TEST IF ON OUTPUT SIDE.
	BEQ	1$		;NO
	TST	INDEV		;YES,TEST IF INPUT DEVICE SPECIFIED.
	BNE	1$		;OK
	CMP	#STAR,OUTFIL	;TEST FOR AN OUTPUT FILE,NOT *
	BNE	CERJ1		;ERROR IF SO.
	MOV	OUTDEV,INDEV	;OTHERWISE MOVE OUTPUT DEV TO INPUT.
	CLR	OUTDEV		;AND CLEAR OUTPUT DEV.
	BR	1$		;/Z SET DON'T LOOK FOR /V
10$:	TSTB	SV+2		;NO /Z ,TEST FOR /V.
	BMI	6$		;NOT SET.
	TST	SVV		;TEST FOR /V:ONLY CHANGE VOL ID.
	BEQ	9$		;NO
	INCB	SZ+2		;YES,SET /Z
	BR	1$
9$:	TST	OUTDEV		;/V ONLY,TEST FOR OUT DEV.
	BNE	5$
	MOV	TTNAME,OUTDEV	;OUTPUT TO TT:
5$:	CLR	INFILE		;SET NO INPUT  FILE FOR DCLS,
				;SINCE DIR/BAD;DIR/VOL WILL
				;GENERATE INPUT FILES.
6$:	TSTB	SS+2		;TEST FOR /S
	BMI	2$
1$:	CLR	OUTFIL		; /U,/I,/S,/Z CAN HAVE DUMMY OUTPUT
				;/Z FOR MT0:A=MDUP.BOT/Z
.ENDC
				;INPUT ON CHANNEL 0
				;OUTPUT ON CHANNEL 1
2$:	MOV	FREEM,R1	;STORE START OF FREE CORE TO LOAD HANDLERS
				;CHANGE #FREE TO ADD PATCH CODE.
	MOV	#INDEV,R2	;ADDRESS OF INPUT DEVICE.
.IF EQ M$DUP
	TSTB	SC+2		;TEST FOR /C CREATE.
	BMI	LOADHS
	MOV	OUTDEV,INDEV	;/C HAS AN OUTPUT FILE IN THE
				;COMMAND.STORE THE DEVICE NAME
				;IN A INDEV LOCATION TO DO A
				;NONFILE STRUCTURED LOOKUP ON IT.
	MOV	#INDEV,R2	;DO LOOKUP ON OUTPUT DEV. ONLY.
	CLR	OUTDEV		;SET OUTDEV ZERO SO BOTH 
				;CHANNEL 0,1 ARE NON FILE LOOKUPS.
LOADHS:	JSR	PC,DSTATI
;	.DSTATUS #INSTA,R2	;GET STATUS OF DEVICE
	MOV	#INSTA,R0	;R0= ADDRESS OF DSTATUS TABLE FOR FETCH.
	JSR	PC,FETCH
;	.FETCH	R1,R2		;FETCH ITS HANDLER
.ENDC
.IF NE M$DUP
	JSR	PC,DSTATI
;	.DSTATUS #INSTA,R2	;GET DSTATUS ON DEVICE.
	JSR	PC,DEVSZI	;WILL GET AN ERROR,SINCE THERE IS NO
				;SY: DEVICE TO READ HANDLER.
				;GET DEV: SIZE FROM TABLE.
	TSTB	SH+2		;TEST FOR MDUP /H
	BPL	12$		;YES,DON'T CLEAR OUTPUT FILE.
	CLR	OUTFIL		;NO,CLEAR DUMMY OUTPUT FILE.
	BR	1$		;LOOKUP OUTPUT DEVICE.

12$:	.ENTER	#AREA,#1,R2,#MDUPSZ ;ENTER MDUP.BOT FILE.
	BCC	6$
	JMP	DFUMES
.ENDC
1$:	JSR	PC,LOOKU0
;	.LOOKUP	#AREA,#0,R2	;OPEN THE INPUT DEVICE ON CHANNEL 0
	JSR	PC,SAVST0
;	.SAVESTATUS #AREA,#0,#SAVSTI	;SAVESTATUS THE INPUT DEV.
;	BCS	5$		;SAVESTATUS ON MT WILL GIVE AN ERROR
;	.REOPEN #AREA,#0,#SAVSTI
5$:
.IF EQ M$DUP
	TSTB	ST+2		;TEST FOR /T,INPUT FILE.
	BMI	4$		;NO
	MOV	INDEV,DINDEV	;YES,DO NON FILE LOOKUP ON IN DEV.
	MOV	#DINDEV,R2	;DO LOOKUP VIA DUMMY LOC.
	.CLOSE	#0		;CLOSE OPENED FILE
				;WANTED TO DO FILE LOOKUP FOR VERIFICATION.
	JSR	PC,LOOKU0
;	.LOOKUP #AREA,#0,R2	;NOW DO NON FILE LOOKUP.
				;IF NO OUTPUT DEV. LET INPUT BE OUTPUT DEV.
.ENDC
4$:	MOV	#OUTDEV,R2	;ASSUME AN OUTPUT DEV.
	TST	OUTDEV		;TEST FOR AN OUTPUT DEVICE
	BNE	3$		;BRANCH IF ONE
	BIT	#DSTSEQ,INSTA	;TEST FOR SEQUENTIAL DEVICE.
	BEQ	6$		;YES,DON'T DO LOOKUP .
	MOV	INDEV,DINDEV	;NO OUTPUT  DEVICE,MOVE INPUT DEV NAME
	MOV	#DINDEV,R2	;TO DUMMY AREA,AND LOOKUP NON FILE STRU.
3$:
	JSR	PC,DSTATO
;	.DSTATUS #OUTSTA,R2	;DO STATUS ON OUTPUT DEVICE
.IF NE M$DUP
	JSR	PC,DEVSZO	;GET DEVICE SIZE OF OUTPUT DEV.
.ENDC
.IF EQ M$DUP
	MOV	#OUTSTA,R0	;R0= ADDRESS OF DSTATUS TABLE FOR FETCH.
	JSR	PC,FETCH
;	.FETCH	R1,R2		;FETCH ITS HANDLER
	TSTB	OUTENT		;TEST TO DO AN ENTER.
	BEQ	10$		;NO
	MOV	SIV+2,R3	;GET SIZE OF FILE
	SUB	SIV,R3
	INC	R3
	TST	SIV+4		;TEST IF WRITE VALUE IS 0.
	BEQ	7$		;YES
	JMP	CERMES		;NO,ERROR.
7$:	.ENTER	#AREA,#1,R2,R3	;ENTER A FILE THE SIZE OF R3
	BCC	11$		;NO ERROR
	JMP	DFUMES		;DEVICE FULL.
.ENDC
10$:	JSR	PC,LOOKU1
;	.LOOKUP	#AREA,#1,R2	;OPEN DEVICE FOR OUTPUT ON CHANNEL 1
11$:	JSR	PC,SAVST1
;	.SAVESTATUS	#AREA,#1,#SAVSTO	;SAVE STATUS THE OUTPUT DEVICE.
;	BCS	6$
;	.REOPEN	#AREA,#1,#SAVSTO
6$:
.IF EQ M$DUP
	MOV	R1,BUFSTA	;STORE START OF BUFFER SPACE
	ADD	#1024.,R1	;DIROUB=BUFSTR ;512. WORD BUFFER
	MOV	R1,DIRINB	;DIRINB IS A 256. WORD BUFFER.
	ADD	#1024.,R1
.IFF
	MOV	@USRBAS,BUFSTA	;USE THE USR BUFFER IN MDUP FOR DIR. BUFFER
	MOV	@USRBAS,DIRINB	;USE SAME BUFFER FOR DIRINB AND DIROUB.
.ENDC
	MOV	R1,BLKOUB	;BLKOUB IS A 256. WORD BUFFER.
	ADD	#512.,R1
	MOV	R1,BLKINB	;BLKINB IS A 257. WORD BUFFER.
	ADD	#512.,R1
	MOV	R1,BUFEND	;SAVE END OF BUFFERS.

				;COME HERE AFTER SWITCH IS EXECUTED TO
				;SEE IF THERE IS ANOTHER SWITCH TO DO
COMEXE:
.IF EQ M$DUP
	TSTB	SO+2		;WAIT TILL LATER FOR /O.
	BPL	COMCHK
	JSR	PC,WWAIT	;TEST TO WAIT TO REMOVE SY: OR RESTORE SY:
.ENDC
COMCHK:	MOV	#SWITS+2,R0
	MOV	#ROUADD,R1
2$:	TSTB	(R0)+		;SEARCH FOR SWITCHES TO EXECUTE
	BGE	1$
	TSTB	(R0)+		;TEST FOR THE END OF TABLE
	BEQ	INIT2		;RESTART
	TSTB	(R0)+		;POINT TO NEXT SWITCH IN TABLE
	ADD	#2,R1		;SKIP DOWN ADDRESS TABLE.
	BR	2$
1$:	DEC	R0		;FOUND AN ACTIVE SWITCH
	MOV	R0,SWITSS	;SAVE SWITCH ADDRESS
	MOV	(R1),R1		;TEST FOR A NON ACTION SWITCH.
	BEQ	COMRTN		;SKIP IF IT IS
	JMP	(R1)		;OTHERWISE JUMP TO ROUTINE
COMRTN:	MOVB	#-1,@SWITSS	;STORE -1 IN SWITCH
.IF EQ M$DUP
	JSR	PC,PERMIC
;	.SCCA	#AREA,#0	;PERMIT CONTROL C'S.
.ENDC
	CLR	FBRUNF
.IF EQ M$DUP
	JSR	PC,WWAIT	;TEST TO WAIT.
	MOVB	#-1,SW+2	;TURN /W SWITCH OFF.
.ENDC
	BR	COMCHK
INIT2:	JMP	INIT
SWITSS:	0

.IF EQ M$DUP
	;ROUTINE TO DO .SCCA.
	;R5 IS DESTROYED.
INHIBC:	MOV	#SCCAW,R5	;INHIBIT CONTROL C
	BR	SETCC
PERMIC:	CLR	R5
SETCC:	.SCCA	#AREA,R5
	RTS	PC
.ENDC
	.ENABL	LSB
.IF EQ M$DUP
	;ROUTINE TO DO A FETCH
FETCH:	TST	4(R0)		;TEST IF HANDLER IS LOADED.
	BNE	2$		;YES
	MOV	2(R0),R0	;NO,GET SIZE OF HANDLER.
	ADD	R1,R0		;R0= ADDRESS TOP OF HANDLER
	JSR	PC,SETTOP	;SETTOP TO ADDRESS.
2$:	.FETCH	R1,R2		;R1=MEMORY LOCATION,R2=DEV:ADD.
	BCS	1$		;BRANCH ON ERROR.
	MOV	R0,R1		;RETURN FREE MEMORY ADDRESS.
	RTS	PC
.ENDC

	;ROUTINE TO DO DSTATUS
DSTATI:	MOV	#INSTA,-(SP)	;DSTATUS ON INPUT DEV.
	BR	DSTAT
DSTATO:	MOV	#OUTSTA,-(SP)	;DSTATUS ON OUTPUT DEV.
DSTAT:	MOV	R2,R0		;R2=ADD. OF DEV: BLOCK
	EMT	342
.IF EQ M$DUP
	BCS	1$		;ERROR.
.ENDC
	RTS	PC
.IF EQ M$DUP
1$:	JMP	ILDMES
.ENDC
	.DSABL	LSB

	.ENABL	LSB
	;ROUTINE TO DO A LOOKUP.
LOOKU0:	MOV	#400,-(SP)	;SET CHANNEL 0 AND CODE.
	BR	LOOKU
LOOKU1:	MOV	#401,-(SP)	;SET CHANNEL 1 AND CODE.
LOOKU:	MOV	#AREA+4,R0	;R0-> .AREA
	CLR	(R0)		;CLEAR	SPECIAL CODE
	MOV	R2,-(R0)	;STORE DEV: ADDRESS.
	MOV	(SP)+,-(R0)	;STORE CHANNEL,CODE.
	EMT	375
	BCS	2$
1$:	RTS	PC
2$:	CMPB	#FNF,@#IOERRB	;TEST FOR TYPE OF ERROR.
	BNE	3$
	JMP	FNFMES
3$:	JMP	DIUMES
	.DSABL LSB

	;ROUTINE TO SAVESTATU AND REOPEN.
SAVST0:	MOV	#2400,-(SP)	;SAVE CODE FOR CHANNEL 0.
	MOV	#SAVSTI,-(SP)	;AND STATUS ADD.
	BR	SAVSTA
SAVST1:	MOV	#2401,-(SP)
	MOV	#SAVSTO,-(SP)
SAVSTA:	MOV	#AREA+2,R0	;R0-> .AREA
	MOV	(SP)+,(R0)	;STORE STATUS ADDRESS.
	MOV	(SP)+,-(R0)	;STORE,CHANNEL CODE.
	EMT	375
	BCS	1$		;MT GIVES ERRORS
	MOV	#AREA,R0	;POINT AT AREA
	ADD	#400,(R0)	;CHANGE CODE TO REOPEN
	EMT	375
1$:	RTS	PC
.IF EQ M$DUP
.ENABL LSB
; THIS ROUTINE GETS A Y FROM THE TERMINAL AND RETURNS TO THE CALLER.
; IF THE FIRST CHARACTER IS NOT Y IT JUMPS TO INIT

YESCHK:	BIS	#GTLIN$,@#JSW	;SET BIT TO GET INPUT FROM TER.
				;FOR DCLS
	.GTLIN	BLKINB		;GET Y<CR> LINE.
	BIC	#GTLIN$,@#JSW	;CLEAR BIT.
	CMPB	#'Y,@BLKINB	;TEST FOR Y
				;IF YES RETURN.
	BNE	2$		;OTHERWISE GO TO INIT
	RTS	PC
2$:	JMP	INIT
	;WWAIT IS A ROUTINE TO WAIT ON Y
WWAIT:	TSTB	SW+2		;TEST TO WAIT.
	BMI	1$		;NO
	.PRINT	#MESCON		;PRINT MESSAGE.
	JSR	PC,YESCHK	;GET YES.
1$:	RTS	PC
.DSABL LSB
.ENDC


DINDEV:	.WORD	0,0	;DUMMY INDEV LOCATION FOR LOOKUPS.
DEFEXT=DINDEV+2		;DEFAULT EXT
	
OUTSPC:	.BLKW	39.
OUTDEV	= OUTSPC		;OUTPUT DEVICE
OUTFIL	= OUTSPC+2		;OUTPUT FILE
INSTA	= OUTSPC+12		;-20  INPUT DEVICE STATUS
OUTSTA	= OUTSPC+22		;-30  OUTPUT DEVICE STATUS
;OPEN	= OUTSPC+32		;-34  OPEN
INDEV	= OUTSPC+36		;INPUT DEVICE
INFILE	= OUTSPC+40		;-44  INPUT FILE NAME
AREA	= OUTSPC+46		;-60  AREA
SCCAW   = OUTSPC+62		;-62
;OPEN	= OUTSPC+64		;-64
SAVSTI	= OUTSPC+66		;-76
SAVSTO	= OUTSPC+100		;-110
;OPEN	= OUTSPC+112		;-114
.IF NE M$DUP


; MDUP IS USED TO BOOT THE SYSTEM FROM MAGTAPE
; MDUP IS ENTERED WITH THE MAGTAPE INPUT OPENED NON FILE STRUCTURED
; AND THE DISK OUTPUT THE SAME.
; MDUP WILL WRITE MINI SYSTEM TO THE DISK, WRITE THE BOOT
; AND BOOT IT.
; TM,MM HAS THE SAME VECTOR.
; COMMAND IS	DEV:A=XT0:	; IE. RK1:A=MT0:
; USE /T ON /Z FOR RJS04 AND RF'S
; USE /T:N FOR RJSO4 AND RF, WHERE N=2 FOR RJSO4
; AND N= # OF PLATTERS FOR THE RF.

MDUP:	.PURGE	#1		;PURGE THE CHANNEL ON THE DISK.
				;MT IS STILL OPEN NON FILE STRUCTURED.
	MOV	#OUTDEV,R0	;GET THE FIRST TWO CHARACTERS OF THE OUTPUT DEVICE
	JSR	PC,DEVPRT	;AND MAKE IT ASCII.
	MOV	#DEVASC,R0	;TEST IF THE FIRST CHARACTER IS SPACE.
	CMPB	(R0),#40
	BNE	1$
	TSTB	(R0)+		;SKIP PAST IT
1$:	MOVB	(R0)+,MMONAS	;STORE THE FIRST 2 CHARACTERS OF THE DEVICE IN
	MOVB	(R0)+,MMONAS+1	;THE SYSTEM FILE NAME XXMNSJ.SYS TO
				;FORM IE., RKMNSJ.SYS.
	MOV	OUTDEV,R0	;GET THE RAD50 DEVICE NAME
	MOV	#50,R1		;SUBTRACT OFF LAST CHARACTER
	JSR	PC,DIV
	ASL	R0		;MULTIPLY BACK BY 50(OCTAL).
	ASL	R0
	ASL	R0
	MOV	R0,-(SP)
	ASL	R0
	ASL	R0
	ADD	(SP)+,R0
	ADD	#15,R0		;ADD M TO RAD50 WORD TO FORM RAD50
	MOV	R0,MMONAM	;MONITOR NAME.  IE., RKMNSJ.SYS
	MOV	#MFILEN,R2	;POINT R2 AT FILENAME LIST.
	JSR	R5,ZMTWT	;REWIND THE MAGTAPE
	.WORD	MTRWND
MGETNF:	MOV	(R2)+,OUTFIL	;STORE FILE NAME IN DEFVICE BLOCK
	MOV	(R2)+,OUTFIL+2
	MOV	(R2)+,OUTFIL+4
	.ENTER	#AREA,#1,#OUTDEV	;ENTER THE FILE ON THE DISK
	BCC	MSMAG
MDISKE:	JMP	EWUMES
MSMAG:	MOV	BLKOUB,OUTBUF	;SETUP WRITE ROUTINE TO WRITE A BLOCK
	MOV	#256.,OUTSIZ
	CLR	OUTBLK
	MOV	BLKOUB,SPBUF	;BUFFER ADDRESS TO READ MAGTAPE TO.
	BR	MFHDR1		;SEARCH FOR HDR1 AFTER VOL1, BOOT
				;MAGTAPE LOOKS LIKE
				; V0L1 BOOT  HDR1*DATA*EOF1*HDR1*DATA ETC.
MFNF:	MOV	#3,R4		;SKIP TO NEXT HDR1 BY READING THREE
				;TAPE MARKS
1$:	JSR	R5,ZMTWT
	.WORD	MTREAD
	BCC	1$		;TEST FOR TAPE MARK, IT IS RETURNED FROM
				;THE HANDLER AS AN ERROR, 52=0.
	DEC	R4		;READ 3 TAPE MARKS.
	BNE	1$
MFHDR1:	JSR	R5,ZMTWT	;READ HDR1, IF BEGINNING OF TAPE
	.WORD	MTREAD		;WILL READ VOL1 AND BOOT FIRST
	BCS	MEOT		;A TAPE MARK HERE MEANS EOT
	MOV	BLKOUB,R0	;TEST FOR HDR1, FIRST 4 CHARACTERS OF BUFFERS.
	CMP	(R0)+,#"HD
	BNE	MFHDR1
	CMP	(R0)+,#"R1
	BNE	MFHDR1
				;FOUND HDR1
	MOV	R2,R3		;R3 POINTS AT ASCII FILE NAME, FILE--.EXT
	MOV	#10.,R5		;COMPARE THE TEN ASCII CHARACTERS.
1$:	CMPB	(R0)+,(R3)+
	BNE	MFNF		;IF NOT EQUAL SEARCH FOR NEXT FILE
	DEC	R5
	BNE	1$
MMATCH:	JSR	R5,ZMTWT	;FOUND THE FILE, READ THE TAPE MARK.
	.WORD	MTREAD
1$:	JSR	R5,ZMTWT	;READ A DATA BLOCK
	.WORD	MTREAD
	BCS	MCLOSE		;TEST FOR TAPE MARK, END OF DATA
	JSR	PC,WRIT1	;WRITE THE FILE TO THE DISK, ONE BLOCK AT A TIME.
	INC	OUTBLK
	BR	1$
MCLOSE:	.CLOSE	#1		;END OF FILE, CLOSE THE DISK FILE.
	BCS	MDISKE
	JSR	R5,ZMTWT	;READ EOF1 LABEL
	.WORD	MTREAD
	JSR	R5,ZMTWT	;READ TAPE MARK AFTER EOF1
	.WORD	MTREAD
MEOT1:	ADD	#10.,R2		;POINT R2 AT NEXT FILE NAME.
	CMP	R2,#MFILEE	;TEST FOR END OF FILE TRANSFERS.
	BNE	MGETNF
	.CLOSE	#0		;ALL FILES COPIED, CLOSE THE MAGTAPE
	.CLOSE	#1		;AND DISK FILES.
	BCS	MDISKE
				;NOW TO WRITE BOOTSTRAP TO DISK AND BOOT.
	CLR	OUTFIL		;SET OUTPUT FILE NULL TO CAUSE A
	CLR	OUTFIL+2	;NON FILE STRUCTURED LOOKUP.
	MOV	OUTDEV,INDEV	;SET THE DISK DEV: AND FILE NAME OF
	MOV	MMONAM,INFILE	;THE MONITOR IN INPUT DEVICE BLOCK.
	MOV	MMONAM+2,INFILE+2
	MOV	MMONAM+4,INFILE+4
	CLRB	SU+2		;SET /U AND /O FLAGS ON.
	CLRB	SO+2
	MOVB	#-1,SK+2	;CLEAR THE MDUP SWITCH /K.
	JMP	LOADH		;RE INITIALIZE DUP TO DO THE
				;LOOKUPS.

MEOT:	JSR	R5,ZMTWT	;REWIND THE TAPE IF EOT REACHED
	.WORD	MTRWND
	.PURGE	#1		;AND FORGET OUTPUT FILE
	BR	MEOT1		;MOVE ON TO NEXT FILE

	; RAD50 FILENAME AND ASCII FILENAMES.

MFILEN:
MMONAM:	.WORD	0		;XXMNSJ.SYS
	.RAD50	/NSJ/
	.RAD50	/SYS/
MMONAS:	.ASCII	/XXMNSJ.SYS/
	.RAD50	/TT/		;TT.SYS
	.WORD	0
	.RAD50	/SYS/
	.ASCII	/TT    .SYS/
	.RAD50	/LP/		;LP.SYS
	.WORD	0
	.RAD50	/SYS/
	.ASCII	/LP    .SYS/
	.RAD50	/MT/		;MT.SYS
	.WORD	0
	.RAD50	/SYS/
	.ASCII	/MT    .SYS/
	.RAD50	/MM/		;MM.SYS
	.WORD	0
	.RAD50	/SYS/
	.ASCII	/MM    .SYS/
	.RAD50	/PIP/		;PIP.SAV
	.WORD	0
	.RAD50	/SAV/
	.ASCII	/PIP   .SAV/
	.RAD50	/DUP/		;DUP.SAV
	.WORD	0
	.RAD50	/SAV/
	.ASCII	/DUP   .SAV/
	.RAD50	/DIR/		;DIR.SAV
	.WORD	0
	.RAD50	/SAV/
	.ASCII	/DIR   .SAV/

MFILEE:
; THIS ROUTINE IS USED TO GET THE DEVICE SIZE AND STORE
; IT IN THE DSTATUS TABLE.

DEVSZI:	MOV	#INSTA,R0	;GET ADDRESS OF DSTATUS TABLE.
	BR	DEVSZ
DEVSZO:	MOV	#OUTSTA,R0
DEVSZ:	MOV	#DEVSZT,R3	;ADDRESS OF SIZE TABLE.
	CLR	R4
2$:	TST	(R3)		;TEST FOR END OF TABLE.
	BMI	1$		;YES,ERROR.
	CMPB	(R0),(R3)	;TEST FOR DEV. TYPE.
	BEQ	3$		;MATCH.
	CMP	(R3)+,(R3)+	;SKIP TO NEXT DEV. ENTRY.
	BR	2$
1$:	JMP	CERMES
3$:	ADD	2(R3),R4	;STORE DEVICE SIZE IN R4.
	DEC	STV		;TEST FOR RF OR RJ.
	BGT	3$		;YES,ADD EXTRA SIZE.
	MOV	R4,6(R0)	;STORE DEV. SIZE IN TABLE.
	RTS	PC

DEVSZT:	.WORD	0,11300		;RK
	.WORD	21,116100	;DP
	.WORD	16,2000		;DS/RJSO3
	.WORD	23,64664	;DM
	.WORD	12,2000		;RF
	.WORD	22,756		;DX
	.WORD	1,1102		;DT
	.WORD	11,0		;MT
	.WORD	20,0		;MM
	.WORD	-1		;END TABLE
	; .R MDUP
	; *DEV:MDUP.BOT/H
	; MDUP /H WILL WRITE 0-12K TO THE SPECIFIED FILE.
	; BEFORE RUNNING MDUP, BOOT SYSTEM AS AN 12K SYSTEM
	; SET USR NOSWP, AND LOAD ALL HANDLERS. THE HARDWARE MT
	; HANDLER CAN BE USED.

WMDUP:	RESET			;STOP THE CLOCK.
	MOVB	#-1,SW+2	;SET /W SWITCH OFF.
	.SCCA	#AREA,#SCCAW	;INHIBIT CONTROL C IN FILE WRITTEN OUT.
	MOV	#4015,@#TTYCON	;SET TERMINAL FOR ALL SLOW TYPES.
	MOV	#MDUPST+2,@#STRTAD  ;STORE START ADDRESS OF MDUP
				;MSBOOT STARTS AT C(40)+2
	.TRPSET	#AREA,#SYSMES	;TRAP YOUR OWN ERRORS.
	.SERR
	MOV	#401,PATMD1	;PATCH OUT SETTOP.
	CLR	OUTBLK		;WRITE 0-12K TO THE FILE
	CLR	OUTBUF
	MOV	#256.*MDUPSZ,OUTSIZ	;MDUPSZ=BLOCK SIZE OF FILE
	JSR	PC,WRIT1	;WRITE OUT 0-12K.
	.CLOSE	#1		;CLOSE THE FILE FOR LENGTH.
	
	;THE SNAPSHOT OF THE MONITOR JUST TAKEN,HAS THE PC IN THE
	;MONITOR AND QUEUES ASSIGNED AND I/O IN PROGRESS ETC.
	;WE MUST COPY THE MONITOR WHEN IT IS NOT ACTIVE,SINCE WE
	;CAN'T DO SOFT/HARD RESETS,THEY ARE IN THE USR BUFFER.

				;MOVE THE TOP 4K ABOVE THE MONITOR.
				;WE ARE RUNNING IN AN 12K SYSTEM.
	MOV	#256.*MDUPSZ/2,R2  ;R2=NUMBER OF WORDS TO MOVE.
	MOV 	R2,R1
	ASL	R1		;R1=ADDRESS TO MOVE FROM.
	MOV	R1,R0
	ASL	R0		;R0=ADDRESS TO MOVE TO,12K ADDRESS.

	MOV	R2,OUTSIZ	;NUMBER OF WORDS TO WRITE.
	MOV	#MDUPSZ/2,OUTBLK ;THE BLOCK TO START WRITE TO.
	MOV	R0,OUTBUF	;BUFFER TO WRITE FROM.

1$:	MOV	(R1)+,(R0)+	;MOVE TOP 4K TO ABOVE THE MONITOR.
	DEC	R2
	BNE	1$

	.LOOKUP #AREA,#1,#INDEV ;REOPEN THE FILE.
	BCS	2$
	JSR	PC,WRIT1	;WRITE THE COPY OF A NON ACTIVE MON.
	.EXIT			;RETURN TO MONITOR.
2$:	JMP	ERUMES

	;START MDUP HERE WHEN LOADED FROM TAPE.
MDUPST:	NOP
	BIS	#100,@#TKS	;SET TTY INTERRUP ENABLE.
	JMP	INIT		;START MDUP.
.ENDC

; ZERO ROUTINE WILL INITIALIZE ANY FILE STRUCTURED RT-11 DEVICE
;	DEV:/Z
; /Z HAS TWO DIFFERENT VALUES
; /Z:M IS THE EXTRA NUMBER OF WORDS (M) IN THE DIRECTORY
; /Z/N:M IS THE SIZE OF THE DIRECTORY FOR BLOCK REPLACABLE DEVICES
; THE VALUE OF M IS 1<=M<=31.  IF /N:M IS NOT GIVEN THE
; DEVICE WILL BE ZEROED WITH A DEFAULT DIRECTORY GIVEN BY TABLE ZDDT
; (ZERO DIRECTORY DEFAULT TABLE)
; WHEN MT OR CT ARE ZEROED THE TAPE END OF FILE TERMINATOR IS STORED ON THE 
; DEVICE WITH NO FILES.
;FOR MT ONLY,A BOOT BLOCK CAN BE PUT ON  WHEN THE TAPE IS
;INITIALIZED.
;	MTX:A=DEV:MBOOT.BOT/Z
;THE TAPE THEN LOOKS LIKE.
;	VOL1 BOOT HDR1**EOF1***
;THE FILE MBOOT.BOT CONTAINS THE ONE BLOCK BOOT.
;
; WHEN A BLOCK REPLACEABLE DEVICE IS ZEROED, THE DIRECTORY IS SET TO ONE
; EMPTY = THE SIZE OF THE DEVICE FOR FILES.  A DUMMY BOOT IS PUT IN
; BLOCK 0 AND A DUMMY VOLUME ID IS PUT IN BLOCK 1.
; BLOCK 1 CONTAINS:
; WORDS 0-65 RK06 REPLACEMENT BLOCKS
; WORD 351	PACK CLUSTER SIZE.
; WORD 352	DIRECTORY START ADDRESS.
; WORD 353	RAD50 VERSION NUMBER.
; WORD 354-361	PACK ID.
; WORD 362-367	PACK OWNER NAME.
; WORD 370-375	PACK FORMAT TYPE.
;
; FOR AN RK06 A SET OF UP TO 32 REPLACEMENT BLOCKS FOR BAD BLOCKS
; ARE STORED IN BLOCK 1 OF THE DISK.  THE REPLACEMENT BLOCKS COME FROM
; TRACK 0 AND 1 OF CYLINDER 410 (THE LAST CYLINDER).
; ZERO LIST OF ROUTINES CALLED
; DEVPRT
; MAKEMP
; WDIR
; WRITI1
; WRITE1
; YESCHK
;
; LOCAL VARIABLES
; NONE
	.ENABL	LSB
ZERO:	JSR	PC,SETTPS	;SETTOP TO END OF BUFFERS.
.IF EQ M$DUP
	BIT	#DSTMT,OUTSTA	;TEST FOR SPECIAL MT: INITIALIZATION.
	BEQ	2$
	MOV	#-1,SZV		;SET MAGTAPE MBOOT ZERO SWITCH.
	JMP	ZMTBOT		;YES,GO TO MT ZERO.
2$:	JSR	R5,TESTSF	;TEST FOR ERRORS, TEST IS FOREGROUND RUNNING
	.WORD	446		;NO OUTDEVICE=2, NO INFILE=4, INPUT DEVICE MUST BE
				;FILE STRUCTURED=200, AN INPUT DEVICE MUST BE PRESENT=40
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES.
	.WORD	37740
.ENDC
	MOV	#ZDDT,R1	;SEARCH TABLE FOR BLOCK REPLACEABLE DEVICE
	MOV	#<ZDDTE-ZDDT>/2,R2	;AND STORE THE DEFAULT DIRECTORY SIZE IN R0
	MOV	#4,R0		;DEFAULT VALUE IF NOT IN TABLE ZDDT
10$:	CMPB	INSTA,(R1)+
	BEQ	11$
	TSTB	(R1)+
	DEC	R2
	BNE	10$
	BR	19$
11$:	MOVB	(R1)+,R0
19$:	TSTB	SN+2		;TEST IF SEGMENT NUMBER INPUT; /N:N
	BMI	1$		;NO
	MOV	SNV,R0		;YES, DON'T USE THE DEFAULT VALUE.
	BGT	21$
20$:	JMP	CERMES		;TEST IF <=0 OR >MAXDIRECTORY SIZE=37(0)
21$:	CMP	R0,#MAXDIR
	BHI	20$
1$:	MOV	R0,SNV		;SAVE DIRECTORY SIZE
	ASL	R0		;GET FIRST BLOCK FOR FILES.
	ADD	#DIRSTR,R0	;ADD BOOT.
	MOV	R0,ZREPFG
	MOV	SZV,R0		;TEST IF ADDITIONAL DIRECTORY WORDS SPECIFIED
	BMI	20$		;MUST BE 0-500.
	CMP	#500.,R0
	BLO	20$
.IF EQ M$DUP
	TST	SVV		;TEST TO CHANGE VOL BLOCK ONLY.
	BEQ	SLZ		;NO.
	MOV	#SLASHU,R1	;YES,ASK IF SURE.
	BR	SLRUS
SLZ:	MOV	#SLASHZ,R1
SLRUS:	JSR	PC,RUS		;ASK ARE YOU SURE.
.ENDC
.IF EQ M$DUP

	TST	TESTMC		;TEST FOR MT OR CT TO ZERO.
	BEQ	12$		;SET IN TESTS
	JMP	ZMTCA
.ENDC
				;CREATE ZEROED DIRECTORY
12$:	MOV	DIROUB,R5	;ADDRESS OF OUTPUT BUFFER IN R5.
	MOV	R5,R0		;STORE SPACES IN OUTPUT BUF.
	JSR	PC,BLANK2
	MOV	SNV,R3		;R3=# OF SEGMENTS IN THE DIRECTORY
	MOV	R3,(R5)+	;STORE # OF SEGMENTS IN 1ST WORD OF DIRECTORY HEADER
	CLR	(R5)+		;0 WORD 2; MEANS LAST DIRECTORY SEG IN USE.
	MOV	#1,(R5)+	;HIGHEST SEGMENT CURRENTLY OPEN. 1 IS THE FIRST.
	MOV	SZV,R2		;NUMBER OF EXTRA BYTES PER DIR ENTRY
	ASL	R2		;Z:N IS IN WORDS.
	MOV	R2,(R5)+	;R2 HAS EXTRA BYTES
	ADD	#DIRSIZ,R2
	MOV	R2,DIRSZ	;SIZE OF DIRECTORY ENTRY
				;BLOCK NUMBER WHERE FILES BEGIN
	ASL	R3		;MULTIPLY SEGMENTS BY 2 TO GET BLOCKS
	ADD	#DIRSTR,R3	;ADD START OF DIRECTORY.
	MOV	R3,(R5)+	;R3=NUMBER OF BLOCKS IN DIRECTORY + BOOT.
				;GENERATE AN EMPTY FILE
	MOV	INSTA+6,R0	;GET DEVICE SIZE
	SUB	R3,R0		;SUBTRACT USED BLOCKS BY SYSTEM. R0=SIZE OF FILE
	JSR	PC,MAKEMP	;GENERATE EMPTY FILE AND STORE IN BUFFER.
	MOV	#DIREOB,(R5)	;BUFSTR=DIRECTORY SEGMENT NOW LOOKS LIKE
				;W0=4 OR # OF SEG	*W5=1000 EMPTY FILE
				;W1=0			*W6,7,10=RANDOM
				;W2=1			*W11=EMPTY SIZE
				;W3=X WORDS/DIR ENTRY	*W12,13=RANDOM
				;W4=16 IF W0=4 OR START OF FILES	*W14=4000 END OF SEG
	MOV	BLKOUB,R0	;STORE SPACES IN OUTPUT BUF.
	JSR	PC,BLANK1
	.DSABL	LSB
.ENABL LSB
; BEFORE THE DIR SEG IS WRITTEN OUT CHECK FOR /R
; IN ORDER TO USE BAD BLOCK REPLACEMENT.
ZREP:	CLR	@BLKOUB		;ZERO FIRST WORD OF REPLACEMENT BLOCK
				;SO HANDLER WILL KNOW THER ARE NO REPLACEMENT
				;BLOCKS IF NONE ARE SPECIFIED.
	TST	SVV		;TEST TO CHANGE VOL ONLY.
	BNE	12$		;YES,SAVE RK06 REPLACEMENT BLOCKS.
	TSTB	SR+2		;TEST TO DEVELOP A REPLACEMENT TABLE
	BMI	ZOUT		;BRANCH IF NO
				;YES, SCAN THE DISK AND GENERATE A TABLE
				;TO BE PUT IN WORDS 0 - 63. OF BLOCK 1.
	MOV	#ZREPB-1,R5	;GET THE REPLACEMENT BLOCKS FOR THE DEVICE
1$:	TSTB	(R5)+		;SKIP TO WORD BOUNDARY.
	MOV	(R5)+,R3	;AND STORE IN R3
	BNE	2$
	JMP	ISWMES
2$:	MOV	(R5)+,R4	;SET R4 = LAST BAD BLOCK REPLACEMENT
	CMPB	INSTA,(R5)+	;COMPARE DEVICE ID, IF SAME
	BNE	1$		;R3 = 1ST REPLACEMENT BLOCK
				;THE REPLACEMENT TABLE IS IN BLKOUB AND
				;IS STORED IN WORDS 0 - 77 OF BLOCK 1 AS
				;WORD 0 = BAD BLOCK, WORD 1 = REPLACEMENT BLOCK
	TST	SRV		;TEST TO REPLACE REPLACEMENT BLOCK TABLE.
	BEQ	11$		;NO
12$:	MOV	BLKOUB,INBUF	;READ 65. WORDS OF BLOCK 1 FROM DISK.
	MOV	#1,INBLK	;THIS CONTAINS REPLACEMENT BLOCKS.
	MOV	#65.,INSIZ
	JSR	PC,READ0
	BR	ZOUT		;SKIP OVER BUILDING REPLACEMENT TABLE.
11$:	INCB	SL+2		;SET SPECIAL FUNCTION FLAG
	MOV	BLKOUB,R5	;ETC., THE TABLE IS ENDED BY A 0
				;UP TO 32. BAD BLOCK REPLACEMENTS ARE ALLOWED.
	CLR	R0		;SCAN THE DISK FROM BLOCK 0 TO THE
	CLR	R1		;LAST BLOCK WITHOUT THE WRITE OPTION
	MOV	INSTA+6,R2
	DEC	R2
	JSR	PC,BSCAN	;START SCAN FOR BAD BLOCKS
				;BSCAN WILL READ A BLOCK AT A TIME INTO
				;BLKINB+2 AND AN ERROR WORD INTO BLKINB.
	BR	7$		;NO BAD BLOCKS
	BR	8$		;ILLEGAL RETURN
	MOV	#32.,R2		;FOUND A BAD BLOCK
				;SET R2 = 32., TOTAL NUMBER OF BAD BLOCKS
				;ALLOWED
3$:	CMP	R0,#DIRSTR	;TEST IF BAD BLOCK IN BOOT AREA.
	BHIS	10$		;NO
	JMP	ESAMES		;ERROR IF SO.
10$:	CMP	R0,(PC)+	;TEST IF BLOCK IS IN THE DIRECTORY.
ZREPFG:	.WORD	0		;FIRST FREE BLOCK FOR FILES.
	BHIS	13$		;NO
	.PRINT	#MESW		;PRINT WARING MESSAGE.
	.PRINT	#MESBDB
13$:	CMPB	#DMIDEN,INSTA	;TEST FOR RK06
	BNE	9$
	CMPB	#200,@BLKINB	;ALL BAD BLOCKS MUST BE MARKED WITH
	BEQ	9$		;A BSE ERROR.
	JMP	UBBMES		;UNMARKED BAD BLOCK.
9$:	DEC	R2		;TEST IF TOO MANY BAD BLOCKS
	BMI	8$
	MOV	R0,(R5)+	;STORE THE BAD BLOCK IN BLKOUB
4$:	MOV	R3,R1		;SET TO READ THE REPLACEMENT BLOCK INTO BLKIN
	CMP	R3,R4		;TEST IF THE BAD BLOCKS HAVE BEEN EXHAUSTED.
	BLOS	5$		;BRANCH IF NO
8$:	JMP	TMBMES		;TYPE ERROR MESSAGE
5$:	JSR	PC,BSREAD	;READ THE REPLACEMENT BLOCK FROM INPUT DEVICE.
	.WAIT	#0		;WAIT FOR COMPLETION.
	BCC	6$		;TEST FOR ERRORS.
	INC	R3		;IF YES, GET NEXT REPLACEMENT BLOCK.
	BR	4$		;AND TRY IT.
6$:	MOV	R3,(R5)+	;BLOCK OK, STORE IT IN THE REPLACEMENT TABLE.
	INC	R3		;R3= NEXT REPLACEMENT BLOCK.
	JSR	PC,BSCNRE	;SCAN FOR NEXT BAD BLOCK.
	BR	7$		;NO MORE
	BR	8$		;ILLEGAL RETURN
	BR	3$		;BAD BLOCK.
7$:	CLR	(R5)		;STORE A 0 AT THE END OF THE TABLE
	BR	ZOUT
ZREPB:	.WORD	RK6RBS,RK6HRB,DMIDEN	;BLOCKS 27060.-27103. THE FIRST 2 TRACKS
				;OF THE LAST CYLINDER OF AN RK06 ARE BAD BLOCK REPLACEMENT
	.WORD	0
.DSABL LSB
.ENABL LSB
				;WRITE BLOCK 1
ZOUT:	MOV	BLKOUB,R3	;WRITE STANDARD PACK ID, OWNER NAME AND
	MOV	R3,R4
	ADD	#DSKPIL,R4	;DISK TYPE IN BLOCK 1, R0 = START OF ID AREA
	JSR	R5,ZVTST	;CALL ROUTINE TO TEST FOR /V AND ASK INPUT IF GIVEN.
	.WORD	12.		;# OF VOL ID CHARCTERS ALLOWED
	.WORD	12.		;# OF OWNER NAMES ALLOWED
	.WORD	DSKPOL-DSKPIL	;INCREMENT BETWEEN VOL ID AND OWNER NAME.
	BR	15$		;/V WAS SPECIFIED
				;COME HERE IF /V WAS NOT SPECIFIED
16$:	MOV	#"RT,(R4)+	;STORE RT11A AS ID AT DSKPIL
	MOV	#"11,(R4)+
	MOVB	#'A,(R4)
15$:	MOV	BLKOUB,R4	;POINT AT DISK TYPE INFORMATION.
	ADD	#DSKCLU,R4	;
	MOV	#1,(R4)+	;STORE CLUSTER SIZE.
	MOV	#6,(R4)+	;DIRECTORY START  LOCATION.
	MOV	VERR50,(R4)	;RAD50 VERSION NUMBER.
	ADD	#DSKFTL-DSKCLU-4,R4	;POINT R4 AT FORMAT TYPE.
	MOV	#"DE,(R4)+	;STORE FORMAT TYPE "DECRT11A".
	MOV	#"CR,(R4)+
	MOV	#"T1,(R4)+
	MOV	#"1A,(R4)
	MOV	#1,OUTBLK	;WRITE OUT BLOCK 1 OF THE DISK.
	JSR	PC,WRITS1	;IT NOW CONTAINS THE VOL ID DEFAULT
				;AND THE RK06 SPECIFIC STUFF.
	TST	SVV		;TEST TO DO ONLY VOL BLOCK.
	BNE	ZEXIT		;YES,SO EXIT.
	MOV	#ZREPB+4,R0	;TEST TO FORCE READ  BLOCK ONE OF DEVICE BY HANDLER,
1$:	CMPB	INSTA,(R0)+	;IF DISK HAS BLOCK REPLACEMENT.
	BEQ	FRBLK1		;YES,TELL HANDLER TO READ BLOCK 1.
	TSTB	(R0)+		;SKIP TO NEXT ENTRY OF TABLE.
	TST	(R0)+		;TEST FOR END OF TABLE.
	BEQ	ZDIRW		;YES,DON'T CAUSE A READ.
	TST	(R0)+		;SKIP TO NEXT ENTRY.
	BR	1$
FRBLK1:	JSR	R5,ZMTWT	;YES, FORCE HANDLER TO READ REPLACEMENT BLOCKS.
	.WORD	SPREP
				;WRITE DIRECTORY SEGMENT
ZDIRW:	MOV	#1,R0		;WRITE SEG ONE.
	JSR	R5,WDIR
.IF EQ M$DUP
	CLR	OUTBLK		;WRITE DEFAULT BOOTSTRAP ON DEVICE.
	MOV	#BTMSGP,OUTBUF
	JSR	PC,WRIT1
	CMPB	INSTA,#DXIDEN	;TEST FOR DX
	BNE	18$		;DONE, DO NEXT COMMAND.
	MOV	#DXAREA,R0	;WRITE SPECIAL VOL ID FOR STANDARD DX
	EMT	375
	BCS	17$
.ENDC
18$:	TSTB	SB+2		;TEST TO DO /B BAD BLOCK SCAN.
	BPL	19$
ZEXIT:	JMP	COMRTN		;NO RETURN
19$:	JMP	BAD		;YES
17$:	JMP	EWUMES
	.DSABL	LSB

.IF EQ M$DUP
	;SUBROUTINE TO PRINT MESSAGE
	;"ARE YOU SURE?"
RUS:	TSTB	SY+2		;TEST TO SKIP MESSAGE.
	BPL	2$		;YES,/Q SET.
	TSTB	SW+2		;TEST FOR /W
	BPL	2$		;DON'T ASK ON /W
	MOV	#OUTDEV,R0	;TRY OUTPUT DEV. FIIRST.
	TST	OUTDEV		;TEST IF NULL
	BNE	1$		;BRANCH IF NOT,ELSE USE INPUT DEVICE.
	MOV	#INDEV,R0
1$:	JSR	PC,DEVPRT	;PRINT MESSAGE DEV:ARE YOU SURE
	MOV	#DEVASC,R0	;POINT AT ASCII TO PRINT
4$:	CMPB	#40,2(R0)	;TEST IF LAST CHAR A SPACE.
	BNE	3$		;NO
	MOVB	1(R0),2(R0)	;SHIFT CHARS.
	MOVB	(R0),1(R0)
	MOVB	#40,(R0)	;STORE SPACE AT FRONT.
	BR	4$
3$:	.PRINT	#MESCRL		;PRINT <CR LF>.
	.PRINT	#DEVASC		;PRINT DEV
	.PRINT	R1		;PRINT /Z
	.PRINT	#MESARE		;PRINT " ARE YOU SURE?"
	JSR	PC,YESCHK	;WAIT FOR YES.
2$:	RTS	PC
.ENDC

.IF EQ M$DUP
	;TEST FOR SPECIAL MT:ZERO.

ZMTBOT:	JSR	R5,TESTSF	;TEST FOR ERRORS
	.WORD	150		;INPUT DEVICE MUST BE BLOCK REPLACEABLE
				;INPUT FILE MUST BE PRESENT.
1$:	CMPB	#CTIDEN,OUTSTA	;TEST IF CT.
	BNE	2$		;BRANCH IF NOT.
	JMP	ILDMES		;NOT MT.
2$:	MOV	#SLASHZ,R1	;ASK, ARE YOU SURE.
	JSR	PC,RUS
	BR	ZMT		;OUTPUT DEV: IS MT.
; COME HERE TO ZERO MT OR CASSETTE

ZMTCA:	CMPB	#CTIDEN,INSTA	;TEST FOR A CASSETTE
	BNE	ZMT		;BRANCH IF MT
	MOV	#INDEV,R2	;R2=ADDRESS OF INDEV
	.CLOSE	#0
	.DELETE	#AREA,#0,R2	;DELETE TO A CASSETTE WILL ZERO THE TAPE.
				;MUST DO TO A CLOSED CHANNEL.
	BCC	2$		;BRANCH IF NO ERRORS.
	JMP	ERUMES
2$:	JSR	PC,LOOKU0
;	.LOOKUP	#AREA,#0,R2
	JSR	R5,ZMTWT	;REWIND THE CASSETTE AND EXIT
	.WORD	CTRWND
	JMP	COMRTN
	;ZERO A MAGTAPE TO LOOK LIKE
	;	VOL1 HDR1**EOF1***
	;		OR
	;	VOL1 BOOT HDR1**EOF1***
ZMT:	JSR	PC,ZMTZ		;ZERO THE BUFFER BLKOUB WITH SPACES.
	MOV	BLKOUB,R4	;POINT R4 AT BLKOUB
	JSR	R5,ZMTS		;STORE 9 CHAR IN BUFFER
	.WORD	MESZ1,9.
				;THE FIRST CHARACTER IN BUFFER IS REFERRED TO AS 1.
				;VOL1 STARTA AT CAHRACTER 1.
	SUB	#5,R4		;POINT R4 AT DEFAULT RT11A
	JSR	R5,ZVTST	;TEST FOR /V AND GET VOL ID AND OWNER NAME IF SO.
	.WORD	6		;6 CHARACTERS ALLOWED FOR VOL ID
	.WORD	10.		;10. CHAR ALLOWED FOR OWNER NAME
	.WORD	36.		;DIFFERENCE BETWEEN RT11A (CHAR5) AND OWNER NAME
				;(CHAR41.)
				;R4 POINTS AT CHARACTER 41, IF /V WAS SPECIFIED.
	BR	3$		;/V WAS SPECIFIED
	ADD	#33.,R4		;/V NOT SPECIFIED POINTS AT CHAR 38.
	BR	4$
3$:	SUB	#3,R4		;POINT AT 38.
4$:	MOVB	#'D,(R4)+	;STORE D % B
	MOV	#"%B,(R4)	;R4 POINTS AT CHARACTER 39
	MOVB	#61,12.(R4)	;STORE 1 IN CHARACTER 51
	MOVB	#63,41.(R4)	;STORE 3 IN CHARACTER 80
	MOV	BLKOUB,SPBUF	;POINT BUFFER IN SPREAD ROUTINE TO BLKOUB
	JSR	R5,ZMTWT	;REWIND MT
	.WORD	MTRWND
	JSR	R5,ZMTWT	;WRITE VOL1 TO MT
	.WORD	MTWRIT
	CMP	#-1,SZV		;TEST TO WRITE BOOT.
	BNE	5$		;NO
	MOV	BLKOUB,INBUF	;YES,READ BOOT BLOCK FROM FILE
	MOV	#256.,INSIZ	;READ ONE BLOCK
	CLR	INBLK
	JSR	PC,READ0
	JSR	R5,ZMTWT	;WRITE BOOT TO MT.
	.WORD	MTWRIT
5$:	JSR	PC,ZMTZ		;WRITE SPACES TO BLKOUB
	MOV	BLKOUB,R4
	JSR	R5,ZMTS		;STORE HDR1 STUFF IN BUFFER
	.WORD	MESZ2,39.
	JSR	R5,ZMTS
	.WORD	MESZ3,29.
	JSR	R5,ZMTWT	;WRITE HDR1 TO MT.
	.WORD	MTWRIT
	JSR	R5,ZMTWT	;WRITE 2 TAPE MARKS
	.WORD	MTTM
	JSR	R5,ZMTWT
	.WORD	MTTM
	MOV	BLKOUB,R4	;RESET BUFFER ADDRESS.
	JSR	R5,ZMTS		;STORE EOF1 IN BUFFER
	.WORD	MESZ4,4
	JSR	R5,ZMTWT	;WRITE BUFFER TO MT
	.WORD	MTWRIT
	JSR	R5,ZMTWT	;WRITE 3 TAPE MARKS
	.WORD	MTTM
	JSR	R5,ZMTWT
	.WORD	MTTM
	JSR	R5,ZMTWT
	.WORD	MTTM
	JSR	R5,ZMTWT	;REWIND THE TAPE
	.WORD	MTRWND
	JMP	COMRTN		;RETURN

.ENDC

.ENABL	LSB
; ROUTINE TO CALL SPIO WITH THE REQUEST CODE IN R0
; IF AN ERROR OCCURS THE MESSAGE MESEWT IS PRINTED
; R0 IS DESTROYED
ZMTWT:	CLRB	SPRWBF		;ASSUME CHANNEL 0 FOR I/O
	CMP	#-1,SZV		;TEST FOR MT ON OUTPUT;INIT WIT BOOT.
	BNE	3$		;NO
ZMTWTO:	MOVB	#1,SPRWBF	;YES,DO I/O ON CHANNEL 1
3$:	MOV	(R5)+,R0
	JSR	PC,SPIOC1	;CALL ROUTINE VIA ENTRY WHERE I/O
				;CHANNEL IS SET UP ALREADY
	BCS	1$		;TEST FOR ERROR
	RTS	R5
.IF NE M$DUP
1$:	TSTB	@#IOERRB		;TEST FOR TAPE MARK.
	BNE	2$
	SEC
	RTS	R5
2$:	JMP	ERUMES
.IFF
1$:	JMP	EWUMES
.ENDC
.DSABL	LSB

.IF EQ M$DUP
; ROUTINE TO STORE SPACES IN THE BUFFER BLKOUB, JSR PC,ZMTZ
; R0, R1 DESTROYED
ZMTZ:	MOV	#256.,R0
	MOV	BLKOUB,R1
1$:	MOV	#20040,(R1)+
	DEC	R0
	BNE	1$
	RTS	PC
; ROUTINE TO STORE CHARACTERS IN A BUFFER (R4), CALL VIA JSR R5,ZMTS
; FOLLOWED BY ADDRESS OF THE CHARACTERS AND THE NUMBER
; THE CHARACTERS ARE STORED INDIRECT R4 WHICH IS SET BEFORE THE CALL
; R0 AND R1 ARE DESTROYED
; R4 POINTS TO CHAR AFTER LAST CHARACTER STORED
ZMTS:	MOV	(R5)+,R0
	MOV	(R5)+,R1
1$:	MOVB	(R0)+,(R4)+
	DEC	R1
	BNE	1$
	RTS	R5
.ENDC

; ROUTINE TO TEST FOR /V ON /Z AND IF SET TO REQUEST THE VOLUME ID.
; AND OWNER NAME AND TO GET THE INPUT AND STORE IT IN A BUFFER ADDRESS
; GIVEN ON THE CALL	JSR	R5,ZVTST
;			.WORD	# OF CHAR. TO GET FOR VOL ID
;			.WORD	# OF CHAR TO GET FOR OWNER NAME
;			.WORD	ADDRESS INCREMENT TO ADD TO R4
;			EXIT
; ON CALL R4 EQUALS THE ADDRESS TO STORE THE VOL ID
; AND THE ADDRESS INCREMENT GIVES THE VALUE TO BE ADDED TO THE ORIGINAL
; R4 TO GIVE THE ADDRESS TO STORE THE OWNER NAME.
; ON EXIT R4 EQUALS THE ADDRESS TO STORE OWNER NAME.
; IF /V WAS NOT GIVEN EXIT AT THE EXIT+2 LOCATION
ZVTST:	TSTB	SV+2		;TEST OF /V
	BMI	1$		;NOT GIVEN
	MOVB	#-1,SV+2	;SET THE SWITCH -1 SO IT ISN'T USED AGAIN.
	BIS	#GTLIN$,@#JSW	;SET BIT TO CAUSE GET LINE TO GET 
				;INPUT FROM THE TERMINAL.
	.PRINT	#MESVID		;REQUEST "VOL ID?"
	.PRINT	#MESQUE
	MOV	(R5)+,R1	;GET MAX NUMBER OF CHARACTERS TO GET FROM TTY.
	JSR	PC,GETCHR	;GET THE CHARACTERS AND STORE (R4)
				;NOTE R4 IS RESTORED ON EXIT.
	.PRINT	#MESOWN		;REQUEST "OWNER NAME?"
	.PRINT	#MESQUE
	MOV	(R5)+,R1	;GET MAX NUMBER OF CHARACTERS TO GET FROM TTY
	ADD	(R5)+,R4	;GET INCREMENT TO ADD TO R4 AND ADD
	JSR	PC,GETCHR	;GET THE CHARACTERS AND STORE (R4)
	BIC	#GTLIN$,@#JSW	;CLEAR BIT.
	RTS	R5		;EXIT
1$:	ADD	#10,R5		;EXIT AT EXIT+2
	RTS	R5
; GETCHR IS A ROUTINE FOR /Z/V TO GET VOLUME ID AND OWNER NAME
; INPUT AND STORE IT IN DSKPIL AND DSKPOL OF THE BLOCK 1 BUFFER
; CALL GETCHR VIA JSR  PC,GETCHR   WITH THE STORAGE ADDRESS IN R4
; AND R1 = NUMBER OF CHARACTERS TO GET.
; ALL REGISTERS ARE RESTORED ON EXIT.

GETCHR:	JSR	PC,SAVREG
	.GTLIN	BLKINB		;GET A LINE
	MOV	BLKINB,R0	;R0 -> INPUT LINE
1$:	TSTB	(R0)		;TEST FOR END OF LINE.
	BEQ	2$		;EXIT IF SO
	DEC	R1		;TEST IF ALL CHARACTERS WERE INPUT
	BMI	2$		;DON'T STORE IF SO
	MOVB	(R0)+,(R4)+	;OTHERWISE STORE THE INPUT CHAR VIA R4
	BR	1$		;GET NEXT CHARACTER
2$:	JSR	PC,RSTREG
	RTS	PC
;
.IF EQ M$DUP
; MAGTAPE VOL1, HDR1, EOF1 CHARACTERS.
MESZ1:	.ASCII	/VOL1RT11A /
MESZ2:	.ASCII	/HDR1ZEROED.ZZZ       RT11A 000100000001/
MESZ3:	.ASCII	/00 00000 00000 000000DECRT11A/
MESZ4:	.ASCII	/EOF1/
	.EVEN

; ARGUMENT AREA FOR FLOPPY INIT SPFUN REQUEST
DXAREA:	.BYTE	1,32		;CHANNEL 1, SPFUN REQ
	7			;SECTOR 7
	DXBUF			;ADDRESS OF BUFFER TO BE WRITTEN
	0			;TRACK 0
	.BYTE	377,376		;SECTOR WRITE COMMAND, WAIT FOR COMPLETION
	0

; BUFFER USED TO WRITE FLOPPY VOL ID. ONLY FIRST 5 BYTES ARE SIGNIFICANT
DXBUF:	.WORD	0		;SPFUN USES FIRST WORD FOR DD FLAG.
	.ASCII	/RT11A/
.ENDC
				;DEVICE NUMBER, DEFAULT DEVICE DIRECTORY SIZE
ZDDT:	.BYTE	0,20		;RK05
	.BYTE	1,4		;DECTAPE
	.BYTE	12,4		;RF11
	.BYTE	16,4		;RJS03/4
	.BYTE	21,37		;RP02/3
	.BYTE	22,4		;RX01
	.BYTE	23,37		;RK06
ZDDTE:
	.EVEN
.IF EQ M$DUP

;******************************************************************
; DUMMY BOOT WRITTEN INTO BLOCK 0 OF ALL DEVICES PROPERLY ZEROED
	TPB	= 177566
	TPS	= 177564
BTMSGP:	NOP			;ALL BOOTS START WITH NOP CHECK
	MOV	#BTMSG-BTMSGP,R0
1$:	TSTB	@#TPS
	BPL	1$
2$:	MOVB	(R0)+,@#TPB
	BPL	1$
	BR	.

	.ENABL LC
BTMSG:	.BYTE	0,0,15,12,0,0,0,0,0,0,0,0,0,0

	.ASCII	/?BOOT-F-No boot on volume/

	.BYTE	15,12,200
	.EVEN
	.DSABL LC
;*********************************************************************
.ENDC
.IF EQ M$DUP

; CREATE WILL CREATE A NEW FILE FROM THE COMMAND FILE.EXT/C:M:N
; OF THE SIZE N STARTING AT BLOCK M
; BLOCK M MUST BE IN AN EMPTY FILE.  IF M IS NOT THE FIRST BLOCK OF THE
; FILE THE PREVIOUS FILE MUST BE AN EMPTY.  IF THE SIZE OF THE FILE
; EXTENDS PAST THE EMPTY THE FOLLOWING FILE MUST BE AN EMPTY OF A
; SIZE LARGE ENOUGH TO ACCOMODATE THE CREATED FILE.
; IF THE SIZE OF THE FILE TO BE CREATED ENDS WITHIN THE EMPTY THE NEXT FILE MUST BE AN EMPTY
; IF EMPTIES DON'T EXIST ON EITHER SIDE OF THE EMPTY,EMPTIES WILL
; BE TRIED TO BE PUT IN THE DIR. IF THERE IS ROOM.
; THE "NEW FILE" IS THE FILE BEING CREATED
; "EMPTY FILE" IS THE FILE IN WHICH THE NEW FILE STARTS.
; "PREVIOUS EMTPY" IS THE EMPTY FILE BEFORE "EMPTY".
; "NEXT EMPTY" IS THE EMPTY FILE AFTER "EMPTY".


CREATE:	JSR	PC,SETTPS	;SETTOP TO END OF BUFFERS.
	JSR	R5,TESTSY	;TEST FOR COMMAND ERRORS
				;NO INPUT FILE
				;OUTPUT DEVICE MUST BE PRESENT AND BLOCK REPLACEABLE
				;OUTPUT FILE MUST BE PRESENT
	.WORD	224
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES.
	.WORD	175777
	MOV	#OUTDEV,R2	;GET OUTPUT DEV.
	MOV	INDEV,OUTDEV	;PUT FILE DEVICE NAME BACK AND
	.LOOKUP	#AREA,#2,R2	;DO A LOOKUP.
	BCS	2$		;IF FILE NOT FOUND,OK.
	JMP	FEXMES		;ELSE AN ERROR IF THE FILE ALREADY
				;EXISTS.
2$:	.PURGE	#2		;PURGE THE CHANNEL.
	CMPB	#2,SC+1		;TEST FOR TWO VALUES ON THE SWITCH
	BEQ	1$
	MOV	#1,SCV+2	;DEFAULT TO 1.
1$:	JSR	PC,INHIBC
;	.SCCA	#AREA,#SCCAW	;INHIBIT CONTROL C'S.
	MOV	SCV,R1		;R1 CONTAINS THE FIRST BLOCK # OF THE FILE TO BE
	MOV	R1,BLKOFI	;CREATED, SAVE IN BLKOFI
	MOV	SCV,R0		;TEST IF FILE EXCEEDS DEVICE.
	ADD	SCV+2,R0
	CMP	R0,INSTA+6	;COMPARE TO DEVICE SIZE.
	BLOS	CREAT		;NO
	JMP	CERMES		;OTHERWISE AN ERROR.
CREAT:	JSR	PC,CBLKFL	;READ IN SEGMENT THAT CONTAINS THE FILE THAT CONTAINS BLK # IN R1
				;SET PARAMETERS FOR THE EMPTY FILE.
	BR	6$		;NOT EMPTY, "PRINT FILE NOT EMPTY"
				;ON RETURN R1 = RELATIVE BLK # IN FILE.
				;R2 = LAST BLOCK # OF PREVIOUS FILE
				;R3 = 1ST BLOCK # OF NEXT FILE
				;R4 = RELATIVE BLOCK # IN FILE = R1
	TST	R1		;TEST IF FIRST BLOCK OF FILE?
	BEQ	1$		;YES
	MOV	R2,R1		;NO, GET PREVIOUS FILE, R2 IS BLOCK # OF LAST
				; BLOCK OF PREVIOUS FILE.
	JSR	PC,BLKFIL	;READ IN PREVIOUS FILE'S SEGMENT
	CMP	#-1,R0		;TEST IF BLOCK IS OUT OF DIR.
	BEQ	2$		;YES
	CMP	R0,#SEMPTY	;TEST IF EMPTY
	BNE	2$		;NO
	CMP	BLKFSG,SEGMNT	;TEST IF IN DIFFERENT SEG.
	BEQ	8$		;NO
	ADD	R4,@BLKFLG	;YES,ADD EXCESS TO PREVIOUS EMPTY
	JSR	PC,SEGWRT	;WRITE PREVIOUS SEGMENT OUT.
	JSR	PC,CRTST	;READ IN ORIGINAL SEG.
	SUB	R4,@BLKFLG	;SUB. EXCESS FROM ORIGINAL EMPTY.
	MOV	DIRINB,R0	;UPDATE DIR. START BLOCK
	ADD	R4,10(R0)
	BR	7$
2$:	JSR	PC,CRTST	;GET ORIGINAL SEG.
	JSR	PC,SEGSFD	;SLIDE EMPTY DOWN TO CREATE
				;ANOTHER EMPTY ON TOP OF IT.
	BR	8$		;DID IT
6$:	JMP	FNEMES		;CAN'T CREATE ANOTHER EMPTY.
8$:	ADD	R4,@BLKFLG	;ADD EXCESS BLOCKS TO PREVIOUS EMPTY.
	ADD	DIRSZ,BLKFLG	;POINT TO ORIGINAL EMPTY.
	SUB	R4,@BLKFLG	;SUB. EXCESS BLOCKS.
7$:	JSR	PC,SEGWRT	;WRITE THE SEGMENT THAT CONTAINS THE PREVIOUS FILE WHOSE
				;SIZE WAS INCREASED.
1$:	MOV	R3,R1		;R3 = 1ST BLOCK OF FILE AFTER NEW FILE.
	JSR	PC,BLKFIL	;READ SEGMENT OF FILE AFTER NEW FILE.
	MOV	FILSIZ,R3	;SET R3=NUMBER OF BLOCKS LEFT IN
	SUB	R4,R3		;THE ORIGINAL EMPTY;FILSIZ-REL
	CMP	#-1,R0		;TEST IF BLOCK OUT OF DIR.
	BEQ	9$		;YES
	CMP	R0,#SEMPTY	;TEST IF THE NEXT FILE IS EMPTY
	BEQ	31$		;YES
9$:	JSR	PC,CRTST	;READ IN ORIGINAL EMPTY SEG.
	JSR	PC,SEGSRD	;TRY TO CREATE AN EMPTY.
				;AFTER THE FILE OF INTREST.
	BR	30$		;GOT ONE
				;CAN'T CREATE AN EMPTY.

	CMP	R3,SCV+2	;NO, THEN THE NEW FILE END MUST = END OF EMPTY FILE.
	BEQ	34$
5$:	JMP	FNEMES		;IF NOT ERROR.
30$:	ADD	DIRSZ,BLKFLG	;POINT TO THE CREATED EMPTY.
31$:	MOV	@BLKFLG,R2	;SAVE SIZE OF THE NEXT EMPTY.
	ADD	R2,R3		;R3=AVAILABLE SPACE FOR NEW FILE.
				;R3=FILSIZ+NEXT EMPTY-REL
	SUB	SCV+2,R3	;R3=NEW SIZE OF NEXT EMPTY.
	BMI	5$		;IF NEGATIVE;ERROR.
	MOV	R3,@BLKFLG	;SET SIZE OF THE NEXT EMPTY.
	BNE	33$
	JSR	PC,SEGSHF	;IF ZERO SHIFT IT OUT.
33$:	CMP	BLKFSG,SEGMNT	;IS THE NEXT EMPTY IN THE SAME SEGMENT AS THE EMPTY FILE?
	BEQ	4$		;YES
	MOV	DIRINB,R0	;
	SUB	R3,R2		;R2= DELTA BETWEEN OLD AND NEW
				;NEXT EMPTY SIZE.
	ADD	R2,10(R0)	;ADD TO DIR. HEADER,1ST BLOCK
				;OF DIR.SEG.
4$:	JSR	PC,SEGWRT	;WRITE THE SEGMENT OUT.
34$:	JSR	PC,CRTST	;READ IN ORIGINAL SEG.
	MOV	#OUTFIL,R1	;ADDRESS OF FILE NAME
	MOV	BLKFLG,R5	;GET ADDRESS OF FILE ENTRY IN R1
	SUB	#10,R5
	MOV	SCV+2,R0	;SIZE OF FILE.
	JSR	PC,MKFILE	;WRITE PERMANENT FILE INDICATOR IN ENTRY
				;PUT FILE NAME IN DIR ENTRY
	JSR	PC,SEGWRT	;WRITE SEGMENT
	JMP	COMRTN		;DONE


CRTST:	MOV	SCV,R1		;YES,READ IN ORIGINAL BLOCK/FILE.
	JSR	PC,BLKFIL
1$:	RTS	PC
;SEGSFD/SEGSRD WILL ATTEMP TO ENTER AN EMPTY INTO THE DIRECTORY
;IF THERE IS ROOM.
;SEGSFD WILL SLIDE THE FILE AND EVERYTHING UNDER IT DOWN
;SEGSRD WILL SLIDE EVERY THING UNDER THE FILE DOWN
;R0 IS DESTROYED,R1-R5 RESTORED.
;CALL  JSR PC,SEGSFD/SEGSRD
;ASSUMES  BLKFIL WAS CALLED PREVIOUSLY.
;RETURN CALL+2 IF SUCCESSFUL
;       CALL+4 IF CAN'T CREATE EMPTY


SEGSFD:	MOV	BLKFLG,R0	;ADDRESS OF FILE SIZE OF
				;OF ENTRY IN BUFFER
	BR	SEG1
SEGSRD:	MOV	BLKFLG,R0
	ADD	DIRSZ,R0	;ADDRESS OF FILE SIZE OF FILE AFTER
				;FILE OF INTREST,IF THERE IS ONE
SEG1:	MOV	R5,-(SP)	;SAVE R5,R2
	MOV	R2,-(SP)
	SUB	#10,R0		;POINT R0 TO STATUS WORD OF
				;DIR. ENTRY.
	MOV	R0,R5		;SAVE ADDRESS TO PUT EMPTY.
	BR	4$		;TEST FOR END OF DIR. SEGMENT
				;FIRST.FILE OF INTREST MAY HAVE
				;BEEN THE LAST.
1$:	ADD	DIRSZ,R0	;POINT TO NEXT STATUS WORD.
				;DIRSZ SET UP IN BLKFIL.
4$:	CMP	(R0),#DIREOB	;TEST FOR END OF SEGMENT.
	BNE	1$		;NO
	MOV	R0,R2		;END OF SEGMENT,POINT R2 AT ADDRESS.
	ADD	DIRSZ,R0	;TEST IF THERE IS ROOM FOR AN EMPTY.
	CMP	R0,BLKOUB
	BLO	5$		;BRANCH IF OK
	ADD	#2,4(SP)	;EXIT CALL+4
	BR	3$
5$:	TST	(R0)+		;POINT R0,R2 1 WORD PASS  WORDS TO MOVE.
	TST	(R2)+
2$:	MOV	-(R2),-(R0)	;MOVE WORD DOWN A DIR. ENTRY SPACE.
	CMP	R5,R2		;TEST IF ALL ENTRIES MOVED.
	BNE	2$		;NO
	CLR	R0		;YES,MAKE AN EMPTY WHERE R5 IS POINTING.
				;INITIAL SIZE IS ZERO.
	JSR	PC,MAKEMP
3$:	MOV	(SP)+,R2	;RESTORE R2,R5.
	MOV	(SP)+,R5
	RTS	PC		;EXIT

; EXTEND FILENAME.EXT/T:N WILL EXTEND THE FILE SPECIFIED
; INTO THE NEXT FILE WHICH MUST BE EMPTY.
; THE RESULTANT FILE WILL BE N BLOCKS BIGGER.
; N CANNOT BE LARGER THAN THE SIZE OF THE EMPTY.
; IF THE EMPTY IS COMPLETELY USED UP, THE 0 LENGTH FILE LEFT IS
; ELIMINATED FROM THE DIRECTORY.
EXTEND:	JSR	PC,SETTPS	;SETTOP TO END OF BUFFERS.
	JSR	R5,TESTSY	;TEST FOR ERRORS
	.WORD	152
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES
	.WORD	173777
	MOV	SAVSTI+2,R1	;GET STARTING BLOCK # OF FILE, IF 0
	JSR	PC,INHIBC
;	.SCCA	#AREA,#SCCAW	;INHIBIT CONTROL C'S.
	MOV	DIRINB,R5
	ADD	SAVSTI+4,R1	;R1 = FIRST BLOCK OF NEXT FILE BY ADDING THE FILE SIZE.
	JSR	PC,CBLKFL	;READ IN THE SEGMENT CONTAINING THE EMPTY FOLLOWING
	BR	3$		;THE FILE
	MOV	STV,R4		;TEST IF THE EXTENSION IS SMALLER THAN THE EMPTY FILE.
	CMP	R4,FILSIZ
	BHI	3$		;NO ERROR.
	SUB	R4,@BLKFLG	;YES - MAKE THE EMPTY THAT MANY BLOCKS SMALLER.
	BNE	1$
	JSR	PC,SEGSHF	;IF ZERO ELIMINATE THE ZERO LENGTH FILE.
1$:	MOV	R5,R0		;ADDRESS OF FILE SIZE OF THE FIRST ENTRY IN THE SEG.
	ADD	#22,R0
	CMP	BLKFLG,R0	;TEST IF THE EMPTY FILE IS THE FIRST FILE OF
	BNE	2$		;THE SEGMENT
	ADD	R4,10(R5)	;YES, THEN THIS SEGMENT STARTS N BLOCKS LATER.
2$:	JSR	PC,SEGWRT	;WRITE THE SEGMENT OUT.
	MOV	R2,R1		;READ IN THE SEGMENT WITH THE FILE
	JSR	PC,BLKFIL
	ADD	R4,@BLKFLG	;EXTEND THE FILE SIZE BY N.
	JSR	PC,SEGWRT	;WRITE THE SEGMENT OUT.
	JMP	COMRTN
3$:	JMP	FNEMES
BLKLOS:	0			;NUMBER OF BLOCKS LOST TO PREVIOUS EMPTY.
SEGNO:	0			;SEGMENT NUMBER THAT CONTAINS EMPTY.
FILSIZ:	0			;FILE SIZE OF EMPTY
BLKOFI:	0			;BLOCK NUMBER OF BAD BLOCK OR 1ST BLOCK OF NEW FILE.
CBFILN:	0			;ADDRESS OF NEW FILE NAME.

; SCAN IS CALLED IN RESPONSE TO /K
;		DEV:/K[:START:STOP]
; IT WILL SCAN THE DEVICE FOR BAD BLOCK AT A MAXIMUM RATE
; AND TYPE OF THE BAD BLOCK #, ERROR TYPE, FILENAME.
; RELATIVE BLOCK NUMBER IN FILE
; BAD BLOCK # = ABSOLUTE (0,1,2...) LOGICAL BLOCK ON DISK,
;	ON RK06, DX IT IS NOT THE SAME AS PHYSICAL SINCE
;	DISK IS MAPPED BY THE HANDLER.  ON AN RK06 REPLACEABLE BAD BLOCKS ARE NOT REPORTED.
; ERROR TYPE = HARD IF BLOCK IS NOT RECOVERABLE ON /W OR
;	NOT READABLE OTHERWISE.
;	= SOFT IF BLOCK IS READABLE AFTER IT WAS REWRITTEN
; FILENAME IS THE FILE IN WHICH THE BAD BLOCK WAS FOUND, COULD
; BE FILE NAME; EMPTY OR A TENTATIVE FILE.
; RELATIVE BLOCK # IS THE RELATIVE BLOCK IN THE FILE, 0,1,2 ETC
; 0 BEING THE FIRST BLOCK
; IF THE OUTPUT DEVICE IS NOT SPECIFIED TT IS DEFAULT
; /H IS A WRITE AFTER READ OF BAD BLOCK
;
; COMMON VARIABLES

;LOCAL VARIABLES

; ROUTINES CALLED
; BLKFIL
; DEVPRT
; CONVRT
; TESTS
;

SCAN:	JSR	R5,TESTS	;TEST FOR COMMON ERRORS
	.WORD	55
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES
	.WORD	77437
20$:	JSR	PC,SETTPS	;SETTOP TO END OF BUFFERS.
	MOV	#24,OUTSIZ	;OUTPUT 50 BYTES,24 WORDS.
	MOV	#SMESAG,OUTBUF
	CLR	OUTBLK
	JSR	PC,WRIT1
	MOV	BLKOUB,R3
	CLR	R0		;SET R0 = 0 IF NO /H
	TSTB	SH+2		;SET R0 = 1 IF /H GIVEN
	BMI	1$
	INC	R0
1$:	MOV	SKV,R1		;IF NO VALUES ARE INPUT SKV=0 ANYWAY
	MOV	SKV+2,R2	;GET STOP VALUE
				;TEST IF A STOP VALUE WAS INPUT
	BNE	2$		;BRANCH IF YES
	MOV	INSTA+6,R2	;NO, THE DEVICE SIZE -1 IS THE LST BLOCK #.
	DEC	R2
2$:	JSR	PC,BSCAN	;SCAN THE DEVICE
	BR	SCANEX		;DONE, NO ERRORS.
	BR	SOFT	;SOFT ERROR
HARD:	MOV	#SHARD,-(SP)	;HARD ERROR
	BR	SCAN1		
SOFT:	MOV	#SSOFT,-(SP)

				;R3=BLKOUB
SCAN1:	MOV	R3,R5		;R0 IS THE BAD BLOCK NUMBER FROM BSCAN
	JSR	PC,CONVRT	;CALL CONVRT TO OUTPUT (R0) INTO THE OUPUT BUFFER.
	MOV	#10.,R4		;NUMBER OF WORDS TO OUTPUT FOR NUMBER ONLY.
	MOV	#6,R1		;OUTPUT SPACES TO THE BUFFER, UP TO "TYPE".
6$:	MOVB	#40,(R5)+
	DEC	R1
	BNE	6$
	MOV	(SP)+,R1	;OUTPUT "HARD" OR "SOFT"
	MOV	(R1)+,(R5)+
	MOV	(R1)+,(R5)+
	MOV	#20040,(R5)+	;OUTPUT SPACES.
	TSTB	SF+2		;TEST TO LOOK UP FILE.
	BMI	1$		;BRANCH IF NO.
5$:	MOV	R0,R1		;CONVRT RESTORES R0
	JSR	PC,BLKFIL	;FIND THE FILE IN WHICH THE BAD BLOCK RESIDES
	CMP	#-1,R0		;TEST IF OUT OF DIRECTORY.
	BEQ	1$		;R0=-1 IF SO.
	MOV	#3,R2		;R1 IS RETURNED AS THE RELATIVE BLOCK # IN THE FILE
8$:	JSR	PC,DEVPRT	;R0 POINTS TO THE FILENAME OR TYPE
	MOVB	DEVASC,(R5)+	;CONVERT THREE LINES OF RAD50 AND STORE IN
	MOVB	DEVASC+1,(R5)+	;THE OUTPUT BUFFER.
	MOVB	DEVASC+2,(R5)+
	CMP	#2,R2		;OUTPUT A "." BETWEEN THE FILENAME AND EXTENSION
	BNE	7$
	MOVB	#'.,(R5)+

7$:	ADD	#2,R0		;POINT TO NEXT RAD50 LINE
	DEC	R2		;TEST IF THREE LINES OF RAD50 DONE.
	BNE	8$
	MOV	#20040,(R5)+	;PUT OUT 2 SPACES.
	MOV	R1,R0		;OUTPUT RELATIVE BLOCK OF FILE WHICH IS BAD.
	JSR	PC,CONVRT
	MOV	#19.,R4		;OUTPUT 23 WORDS FOR FILE LOOK UP.
1$:	MOV	#5015,(R5)+	;OUTPUT <CRLF>

				;OUTPUT 22 WORDS,44 BYTES,OR 7 WORDS
				;16 BYTES.
				;BLK # = 6 BYTES
				;SPACES = 4 BYTES
				;TYPE + 2 SPACES=  6 BYTES
				;FILENAME = 12 BYTES + 2 SPACES	= 14 BYTES
				;REL BLOCK # = 6 BYRES + 2 SPACES + CRLF= 12 BYTES
				;TOTAL = 44 BYTES.
	INC	OUTBLK		;INCREMENT BLOCK FOR A FILE.
	MOV	R4,OUTSIZ
	MOV	R3,OUTBUF	;R3=BLKOUB ADDRESS.
	JSR	PC,WRIT1
	JSR	PC,BSCNRE	;RECALL BSCAN TO CONTINUE THE SCAN OF THE DISK.
	BR	SCANEX		;NO MORE ERRORS.
	BR	SOFT		;SOFT ERROR
	BR	HARD		;HARD ERROR
SCANEX:	JMP	COMRTN
SHARD:	.ASCII	/HARD/
SSOFT:	.ASCII	/SOFT/

SMESAG:	.ASCII	/BAD BLOCKS  TYPE  FILENAME    REL BLK /
	.BYTE	15,12
	.EVEN


; SQUISH WILL COMPRESS THE INPUT DEVICE ONTO THE OUTPUT DEVICE
; THERE CAN BE TWO DEVICES OR ONE DEVICE, IN WHICH CASE THE DEVICE IS
; COMPRESSED ONTO ITSELF.
; TWO DEVICES
; WHEN THERE ARE 2 DEVICES THE OUTPUT DEVICE MUST BE ZEROED BEFORE IT CAN
; BE COMPRESSED TO.  THE OUTPUT DIRECTORY IS SCANNED FOR BAD BLOCK FILES AND
; THE START AND SIZE OF THE BAD BLOCK FILES ARE STORED IN BADBKT
;
; SINGLE DEVICE
; WHEN THERE IS 1 DEVICE THE DIRECTORY MUST BE RELINKED INTO A SEQUENTIALLY
; LINKED DIRECTORY.  THE BAD BLOCK FILES ARE READ DURING THE COMPRESS
; AND STORED IN BADBKT.
;
; DURING COMPRESSION FILES ARE STORED TOWARD THE FRONT OF THE DEVICE
; STARTING AT THE END OF THE DIRECTORY.  IF THERE ARE .BAD FILES ON THE OUTPUT
; DEVICE, FILES ARE STORED UNTIL THEY CAN'T FIT IN FRONT OF THE BAD FILE.
; ALL SUCCEEDING FILES ARE STORED AFTER THAT BAD FILE UNTIL ANOTHER BAD FILE
; IS ENCOUNTERED.  THE RESULTANT DEVICE WOULD HAVE COMPRESSED FILES, AN
; EMPTY, .BAD FILE, COMPRESSED FILES, EMPTY ETC.
;
; A MAXIMUM OF 128. BAD BLOCKS CAN BE PROCESSED BY THIS ROUTINE.
; 
; VARIABLE PARTICULAR TO SQUISH

SLIST:	0			;A 256. WORD TABLE TO STORE THE PAIR ;SEGMENT NUMBER AND
				;THE SEGMENT SLOT IT IS STORED IN, FOR RELINK,
				; IT STARTS AT BLKINB+256.
SEGTMP	= BLKOUB		;512. WORD BUFFER TO TEMPORARILY STORE A SEGMENT.
				;START AT BLKOUB.

BADBKT	= BLKOUB		;A 256. WORD TABLE TO STORE BAD BLOCK INFORMATION AS
				;BLOCK # OF START OF BAD BLOCK ;FOLLOWED BY FILE SIZE
				; THE TABLE
				;IS ENDED BY -1
; BUFFERS ARE LAYED OUT AS FOLLOWS.
;	;FOR RELINK
	;DIROUB
	;DIRINB
	;SEGTMP	= BLKOUB + BLKINB
	;SLIST	= STARTING AT BLKINB + 512.
;	;FOR COMPRESSING
	;DIROUB
	;DIRINB
	;BADBKT	= BLKOUB
	;DATA BUFFER = BLKINB TO END OF AVAILABLE MEMORY IN STEP OF 256.
INBSIZ:	0			;SIZE OF THE INPUT BUFFER IN BLOCKS.
SEGBST:	0			;CURRENT START BLOCK NUMBER OF THE NEXT
				; FILE IN THE OUTPUT BUFFER
SQUTMP:	0			;TEMPORARY LOCATION.


; SEGMENT HEADER WORDS
; 1ST = # OF SEGMENTS AVAILABLE TO THE DIRECTORY
; 2ND = LINK TO NEXT SEGMENT, 0 MEANS THIS IS THE LAST SEG. 1 IS SEGMENT ONE.
; 3RD = HIGHEST SEGMENT IN USE ; UPDATED IN SEG 1 ONLY
; 4TH = EXTRA BYTES IN DIR. ENTRY
; 5TH = FIRST BLOCK REFERENCED BY THIS SEGMENT, 1ST BLOCK OF 1ST FILE IN SEG.
; 6TH = START OF DIR ENTRIES.

SQUISH:	JSR	PC,SETTPS	;SETTOP TO TOP OF BUFFERS.
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES
	.WORD	117377
	JSR	R5,TESTS	;TEST INPUT / OUTPUT FIRST.
	.WORD	75

	TSTB	SY+2		;TEST FOR /Y
	BPL	4$		;DON'T TEST FOR RT FORMAT.
	MOV	#1,R0		;READ BLOCK 1 OF INPUT DEVICE
	JSR	PC,READB0
	MOV	BLKINB,R0	;LOOK AT FORMAT ID IN BLOCK 1.
	CMP	#"CR,DSKFTL+2(R0)
	BNE	5$		;BAD.
	CMP	#"T1,DSKFTL+4(R0)
	BEQ	4$		;OK.
5$:	.PRINT	#MESW		;PRINT WARNING MESSAGE,NO RT-11 VOL ID.
	.PRINT	#MESNVI
4$:	MOV	#1,R0		;READ THE OUTPUT DIR.
	JSR	R5,GETODR
	DIROUB
	MOV	DIROUB,R4	;GET THE DIR. ENTRY SIZE
				;AND THE NUMBER OF EXTRA BYTES.
	MOV	6(R4),R0
	MOV	R0,DIRXBY
	ADD	#DIRSIZ,R0
	MOV	R0,DIRSZ
	TST	OUTDEV		;TEST FOR ONE OR TWO DEVICE /S
	BEQ	SQUONE		;BRANCH IF ONE DISK /S.
				;TWO DISK /S.
	JSR	R5,TESTSY	;TEST FOR ERRORS,WAIT FOR REPLY.
	.WORD	75
	ADD	#12,R4		;TEST IF OUTPUT DEVICE IS ZEROED.
2$:	CMP	(R4),#DIREMP	;FIRST FILE MUST BE EMPTY,OR .BAD FILE.
	BNE	1$		;IF NOT EMPTY,TEST IF END OF SEGMENT
3$:	ADD	DIRSZ,R4	;TEST NEXT ENTRY.
	BR	2$
1$:	CMP	(R4),#DIREOB	;IF NOT EMPTY,TEST IF END SEG. MARKER.
	BEQ	SQURKE		;BRANCH IF SO.
	CMP	6(R4),BADFIL+4	;OTHERWISE ,TEST IF .BAD FILE.
	BEQ	3$		;IF YES,TEST NEXT ENTRY
	JMP	DNZMES		;IF NON OF THE ABOVE,ERROR.

SQUONE:	JSR	R5,TESTSF	;TEST FOR ERRORS BUT DON'T WAIT FOR ANSWER.
	.WORD	75
	MOV	#SLASHS,R1
	JSR	PC,RUS		;SINGLE DISK /S,ASK "ARE YOU SURE".
	JSR	PC,INHIBC
;	.SCCA	#AREA,#SCCAW	;INHIBIT CONTROL C'S
	MOV	BLKINB,R0	;FOR A SINGLE DEVICE IS THE DIRECTORY MUST
	ADD	#1024.,R0	;BE RELINKED, BUFFERS BLKOUB AND BLKINB
				;ARE USED FOR A 512. WORD TEMPORY SEGMENT BUFFER
				;A LIST OF SEGMENT POINTERS WILL GO IN THE
	JSR	PC,SETTOP	;256. WORD BUFFER FOLLOWING THE TEMP SEG. BUFFER.
				;POINTER TO BY R5
	INCB	IOCON		;SET FLAG TO CONTINUE ON DIR. I/O ERROR.

; RELINK DIRECTORY
; THE ALGORITHRM USED IS AS FOLLOWS
; A) READ THE FIRST SEGMENT, IT IS ALWAYS IN THE 1ST SLOT ON THE DISK
;    SLOTS ARE PHYSICAL AREAS ON THE DISK
;    SEGMENT N IS LINKED TO ANOTHER SEGMENT WHICH COULD BE IN
;    SLOT N+1 OR SOME OTHER SLOT.  THE JOB IS TO GET ALL THE SEGMENTS IN ORDER.
; B) GET SEGMENT IN SLOT N, FIND OUT TO WHICH SEGMENT IT IS LINKED
; C) IF LINKED TO N+1 OK
; D) IF NOT INTERCHANGE THE SEGMENTS SO THAT LINKED SEGMENT IS IN SLOT N+1
;    AND THE SEGMENT TAKEN OUT OF SLOT N+1 IS STORED IN THE SLOT OF THE LINKED SEGMENT
; E) REMEMBER IN SLIST THAT WE MOVED THE SEGMENT OF N+1 TO THE NEW SLOT.
; F) WHEN WE LOOK FOR A LINKED SEGMENT, LOOK IN SLIST FIRST TO SEE IF IT IS THERE.
; G) WHEN A SEGMENT IS USED FROM SLIST, DELETE IT FROM SLIST.
; I) READ SEGMENT IN SLOT N.

SQURLK:	MOV	#1,R2		;R2 IS SEGMENT SLOT N
	MOV	#2,R1		;R1 IS SEGMENT SLOT N + 1
	MOV	BLKINB,R5	;SET R5= THE LIST OF SEGMENT POINTERS.
	ADD	#512.,R5
	MOV	#-1,(R5)	;-1 ON TOP OF LIST ; NO VALUES IN LIST
7$:	MOV	R2,R0		;SET TO READ DIR. N.
	JSR	R5,RDIR		;READ DIRECTORY N INTO BUFFER DIRINB
	MOV	DIRINB,R3
	MOV	2(R3),R4	;SEGMENT SLOT N IS LINKED TO, "LINKED SEG"=R4
	BEQ	SQURKE		;DONE, DIRECTORY IS RELINKED.
	MOV	R5,R0		;TEST IF "LINKED SEG" IS ON THE LIST
				; SET 4$ BELOW FOR LIST STRUCTURE
1$:	TST	(R0)		;TEST FOR END OF LIST
	BMI	3$		;END OF LIST NOT ON LIST ;"NEXT SETMENT SLOT" = "LINKED SEG"
	CMP	(R0)+,R4
	BEQ	2$		;"LINKED SEG" IS ON THE LIST.
	TST	(R0)+		;SKIP TO NEXT ENTRY
	BR	1$
2$:	MOV	(R0),R4		;SEGMENT N IS LINKED TO SEGMENT IN SLOT = R4
	CLR	(R0)		;R4 = "NEXT SEGMENT SLOT" ;REMOVE ENTRY FROM TABLE
	CLR	-(R0)		;ZERO BOTH WORDS OF ENTRY.

3$:	CMP	R4,R1		;R4 = "NEXT SEGMENT SLOT" NUMBER
	BEQ	6$		;DOES R4 = N+1 ;IF YES DON'T NEED TO MOVE SEGMENT
				;IN SLOT N+1
				;"NEXT SEGMENT SLOT" NOT EQUAL TO N+1, MUST MOVE
				;"NEXT SETMENT SLOT" ENTRY INTO N+1 AND THE CONTENT
				;OF N+1 INTO "NEXT SEGMENT SLOT".
	MOV	R1,R0		;MOVE THE SEGMENT IN N+1 INTO A TEMPORARY
	JSR	R5,GETDIR	;BUFFER
	SEGTMP			;THE CONTENT OF THIS LOCATION CONTAINS THE ADDRESS OF
				;THE BUFFER

	MOV	R4,R0		;GET SEGMENT FROM SLOT "NEXT SEGMENT SLOT"
	JSR	R5,GETDIR
	DIROUB
	MOV	R1,R0		;AND STORE IT IN SLOT N+1
	JSR	R5,WDIR
	MOV	R4,R0		;STORE SEGMENT FROM TEMP BUFFER.
	JSR	R5,PUTDIR	;AND STORE IT IN "NEXT SEG SLOT".
	SEGTMP
	MOV	R5,R0		;TEST IF A SEGMENT WAS STORED IN SLOT N+1

4$:	TST	(R0)+		;TEST FOR END LIST
	BMI	5$		;A SEGMENT WAS NOT STORED IN SLOT N+1
	CMP	R1,(R0)+	;DOES N+1 = "SLOT STORED IN"
	BNE	4$		;NO
	MOV	R4,-(R0)	;YES - THE SEGMENT IS NOW STORED IN SLOT "NEXT SEG SLOT"
	BR	6$
5$:	MOV	R1,-(R0)	;PUT "SEG FROM N+1" ;"NEXT SEGMENT SLOT" ON THE
	TST	(R0)+		;LIST
	MOV	R4,(R0)+
	MOV	#-1,(R0)	;END OF LIST
				;LIST FORMAT IS THE PAIR SEGMENT # ;SLOT IT IS STORED IN
				;ENDED BY -1.
6$:	MOV	R1,2(R3)	;STORE LINK TO SEGMENT IN SLOT N+1
	MOV	R2,R0		;WRITE SEGMENT TO SEGMENT SLOT N
	JSR	R5,PUTDIR
	DIRINB
	INC	R1		;SKIP TO NEXT SEGMENT SLOT
	INC	R2
	BR	7$

SQURKE:	MOV	BLKINB,R1	;ADDRESS BASE OF DATA AREA.
	TSTB	SYSFLG		;TEST FOR /S ON SY:
	BNE	1$		;BRANCH IF YES.
2$:	JSR	PC,BUFSZH	;SETTOP TO BOTTOM OF RESIDENT MONITOR.
	BR	SQUBAD
				;SUQISH ON SY:
1$:	MOV	BUFEND,R0	;R0=LAST WORD ON NEEDED BUFFERS.
	CMP	R0,@USRBAS	;TEST IF USR WOULD LOAD BELOW IT.
	BHIS	2$		;IF SO CAN'T MAKE USR RESIDENT.
				;MAKE USR RESIDENT.
	JSR	PC,SETTOP	;SETTOP TO END OF NEEDED BUFFER AREA.
	.LOCK			;LOCK USR IN MEMORY.IF ALREADY IN
				;MEMORY VIA SET USR NOSWAP,ABOVE 
				;LOGIC STILL OK.
	INCB	USRRES		;SET USR RESIDENT FLAG.
	MOV	@USRBAS,R0	;SETTOP TO BELOW USR.
	SUB	#2,R0
	JSR	PC,BUFSZL	;USE ALL MEMORY UP TO USR FOR BUFFERS.

;FIND THE .BAD FILES ON THE OUTPUT DEVICE AND
;WRITE THEM IN THE TABLE BADBKT.

SQUBAD:	MOV	DIRSZ,R4	;SIZE OF A DIR. ENTRY
	SUB	#10,R4		;NUMBER OF WORDS BETWEEN
				;THE FILESIZE AND STATUS OF THE
				;NEXT DIR.ENTRY.
	MOV	BADBKT,R1	;ADDRESS TO STORE BAD BLOCK INFO.
	MOV	#1,R0		;READ FIRST OUTPUT SEGMENT.
3$:	CMP	R0,#37		;TEST FOR A VALID DIR.
	BHI	5$		;CAN'T HAVE MORE THAN 37 SEGS.
	JSR	R5,GETODR	;READ AN OUTPUT DIR. SEG.
	DIROUB
	MOV	DIROUB,R2	;ADDRESS OF BUFFER OF SEGMENT.
	MOV	10(R2),R3	;R3=FIRST BLOCK OF FIRST FILE.
	ADD	#12,R2	;POINT TO STATUS OF FIRST ENTRY.
2$:	ADD	#6,R2		;POINT TO FILE SIZE.
	CMP	R2,DIRINB	;TEST IF ADDRESS IN SEGMENT BUF.
	BLO	4$
5$:	JMP	IDRMES		;NOT A VALID DIRECTORY.
4$:	CMP	BADFIL+4,(R2)+	;TEST IF A .BAD FILE.
	BNE	1$
	MOV	R3,(R1)+	;STORE BLOCK NUMBER AND
	MOV	(R2),(R1)+	;FILESIZE OF .BAD FILE IN TABLE.
1$:	ADD	(R2),R3		;ADD FILE SIZE TO BLOCK COUNTER.
	ADD	R4,R2		;PONIT TO STATUS OF NEXT ENTRY.
	CMP	#DIREOB,(R2)	;TEST IF END OF DIR. SEG.
	BNE	2$		;NO
	MOV	DIROUB,R2	;READ NEXT DIR.SEGMENT.
	MOV	2(R2),R0	;GET SEGMENT NUMBER.
	BNE	3$
	MOV	#-1,(R1)	;LAST SEGMENT ,STORE -1 TO MARK END 
				;OF THE TABLE.

;INITIALIZE TO COMPRESS THE DISK.

SQUCIN:	MOV	#1,R0		;READ INPUT DIR.
	JSR	R5,RDIR
	MOV	#1,R0		;READ OUTPUT DIR.
	JSR	R5,GETODR
	DIROUB
	MOV	BLKINB,OUTBUF	;ADDRESS OF OUTPUT BUFFER
	MOV	BLKINB,INBUF	;AND INPUT BUFFER.
	MOV	DIROUB,R0	;POINT TO THE INPUT AND OUTPUT DIR SEG BUFFERS.
	MOV	DIRINB,R1
	CMP	6(R0),6(R1)	;TEST IF EXTRA BYTES THE SAME.
	BEQ	1$
	JMP	IDRMES		;IF NOT ILLEGAL DEVICE TO OUTPUT TO.
1$:	TST	(R0)+		;SKIP SIZE OF OUTPUT DIR.
	MOV	#1,(R0)+	;INIT LINK WORD TO 1
	MOV	#1,(R0)+	;HIGHEST SEGMENT CURRENTLY OPEN
	TST	(R0)+		;POINT TO FIRST BLOCK WORD.
				;INITIALIZE R1-R5
	MOV	BADBKT,R5	;R5 POINTS TO TOP OF BAD BLOCK LIST
	MOV	R1,R4
	ADD	#12,R4		;INIT R4 = ADDRESS  FIRST INPUT FILE
	MOV	(R0)+,R3	;SET R3=FIRST BLOCK OF OUTPUT FILE.
	MOV	R3,SEGBST	;SET SEGBST=FIRST BLOCK OF OUTPUT FILE.
	MOV	R0,DIROBP	;DIROBP POINTS TO THE FIRST OUTPUT 
				;FILE BLOCK.
	MOV	10(R1),R2	;INIT R2 = FIRST BLOCK OF INPUT FILES
 	MOV	R2,R1		;INIT R1 = FIRST BLOCK OF INPUT FILES
; R5 IS THE POINTER TO THE BAD BLOCK TABLE.
; R4 IS THE POINTER TO THE INPUT SEGMENT
; R3 IS THE BLOCK NUMBER TO WRITE DATA TO ON THE OUTPUT DEVICE
; R2 IS THE BLOCK AFTER THE LAST BLOCK OF DATA TO READ FROM THE INPUT DEVICE
; R1 IS THE FIRST BLOCK OF DATA TO READ FROM THE INPUT DEVICE.
; SEGBST IS THE START BLOCK OF THE NEXT OUTPUT FILE.
SQUIT:	MOV	10(R4),R0	;R0 = FILE SIZE OF FILE ENTRY.
	BIT	#<DIREMP+DIRTEN>,(R4)	;TEST IF ENTRY IS AN EMPTY
					;OR A TENTATIVE FILE.
	BNE	12$		;YES ;FOR AN INPUT EMPTY THE PREVIOUS
				;FILE DATA IS COPIED TO THE OUTPUT DEVICE,
				;THE START OF OUTPUT BLOCK IS INCREMENTED BY
				;(STOP-START) ;THE START BLOCK FOR INPUT
				;DATA IS INCREMENTED BY THE EMPTY FILE
				;SIZE AND THE STOP BLOCK FOR INPUT IS SET
				;EQUAL TO THE START BLOCK VALUE.
	CMP	BADFIL+4,6(R4)	;TEST IF THE FILE IS A .BAD FILE
	BNE	10$

12$:	ADD	DIRSZ,R4	;ADD FILE SIZE TO START BLOCK OF NEXT INPUT FILE
				;POINT TO NEXT ENTRY.
	BR	13$		;WRITE DATA AND UPDATE NEXT START OUTPUT BLOCK,
				;STOP AND START FOR INPUT READ.
				;NEXT OUTPUT BLOCK = CURRENT VAL + (STOP-START)
				;START = STOP + FILE SIZE (.BAD OR EMPTY)
				;STOP = START

10$:	MOV	R0,-(SP)	;A REGULAR FILE, TEST IF IT WILL FIT BEFORE
	ADD	SEGBST,(SP)	;THE NEXT .BAD FILE ON THE OUTPUT DEVICE.
	CMP	(SP)+,(R5)	;START OF NEXT FILE + SIZE <= START OF .BAD FILE?
	BHI	11$		;NO, FILE WILL NOT FIT.
	JSR	PC,DIRFST	;YES, WRITE DIRECTORY ENTRY TO THEOUTPUT BUFFER.
	ADD	R0,R2		;ADD THE FILE SIZE TO STOP
	ADD	DIRSZ,R4	;ADD THE FILE SIZE TO BLOCK NUMBER OF START OF NEXT
				;INPUT FILE ;POINT TO NEXT INPUT ENTRY.
	BR	14$		;
11$:	JSR	PC,WDATA	;FILE WILL NOT FIT, WRITE DATA TO OUTPUT DEVICE
	MOV	(R5)+,R0	;AND .BAD FILE ON OUTPUT DEVICE, STORE IN R0.
	SUB	SEGBST,R0
	BEQ	15$		;DON'T CREATE EMPTY IF 0.
	JSR	PC,DIREST	;STORE THE EMPTY FILE ENTRY
15$:	ADD	R0,R3		;ADD SIZE OF EMPTY TO START OF NEXT OUTPUT OF DATA
	MOV	(R5)+,R0	;GET SIZE OF .BAD FILE
	JSR	PC,DIRBST	;STORE THE .BAD FILE ENTRY IN THE OUTPUT DIRECTORY.
	ADD	R0,R3		;ADD SIZE OF .BAD FILE TO START OF NEXT OUTPUT OF DATA.
	CLR	R0		;ADD THE SIZE OF STOP-START IN THE WRITE DATA TO
	BR	16$		;THE START OF NEXT WRITE DATA
				;NEXT OUTPUT BLOCK =
				; CURRENT VAL+(STOP-START)+.BAD SIZE+EMPTY SIZE
				;START = LAST STOP :R0 = 0 SINCE FILE WILL BE RESELECTED.
				;STOP = NES START = LAST STOP

13$:	JSR	PC,WDATA
16$:	SUB	R1,R3		;ADD (STOP-START) OF INPUT DATA TO START OF NEXT OUTPUT DATA
	ADD	R2,R3
	MOV	R2,R1		;NEW START = LAST STOP+FILE SIZE OF EMPTY OR BAD READ
	ADD	R0,R1
	MOV	R1,R2		;NEW STOP = START
14$:	MOV	R4,SQUTMP	;SAVE R4
	CMP	#DIREOB,(R4)	;TEST IF ANOTHER ENTRY AVAILABLE IN SEQ.

	BNE	SQUIT
	MOV	DIRINB,R4	;WAS THAT THE LAST SEGMENT?, GET THE SEGMENT
	MOV	2(R4),R0	;LINK WORD.
	BEQ	17$		;YES IF ZERO
	JSR	R5,RDIR		;NO, READ IN DIRECTORY VIA LINK WORD
	ADD	#12,R4		;POINT TO FIRST DIRECTORY ENTRY
	BR	SQUIT
17$:	MOV	SQUTMP,R4	;RESTORE R4
	CMP	#-1,(R5)	;NO MORE FILES, WRITE OUT ANY .BAD
	BNE	11$		;FILES LEFT FOR THE OUTPUT DEVICE
SQUDON:	JSR	PC,WDATA
	MOV	OUTSTA+6,R0	;CALCULATE THE SIZE OF THE LAST EMPTY FILE.
	SUB	SEGBST,R0
	JSR	PC,DIREST	;STORE THE EMPTY FILE ON THE OUTPUT DIRECTORY.
	MOV	#DIREOB,@DIROBP	;STORE THE DIR. SEG. END MARKER.
	MOV	DIROUB,R4	;POINT TO THE LAST SEGMENT OF THE DIRECTORY
	MOV	2(R4),R1	;GET THE VALUE OF THE HIGHEST SEGMENT IN USE
	CLR	2(R4)		;SET = 0, END OF DIRECTORY LINK
	MOV	R1,R0		;WRITE OUT THE LAST SEGMENT.
	JSR	R5,WDIR
	MOV	#1,R0		;READ IN OUTPUT SEGMENT 1
	JSR	R5,GETODR
	DIROUB
	MOV	R1,4(R4)	;STORE THE HIGHEST SEGMENT IN USE
	MOV	#1,R0
	JSR	R5,WDIR		;WRITE SEGMENT 1 OUT.
SQUEXT:	TSTB	SYSFLG		;TEST IF SY: WAS SQUISHED.
	BEQ	SQURTN		;NO
	TSTB	USRRES		;TEST IF USR RESIDENT.
	BEQ	1$		;NO,REBOOT.
	TSTB	SX+2		;TEST FOR /X , NO BOOT
	BMI	1$		;IF NOT SET REBOOT .
	.PRINT	#MESW		;IF SET,TYPE MESSAGE,AND STAY IN DUP.
	.PRINT	#REBOOT
	BR	SQURTN
1$:	JMP	BOOTS		;REBOOT SYSTEM
SQURTN:	JMP	COMRTN


; WDATA IS A ROUTINE TO WRITE BLOCKS OF DATA FROM ONE DEVICE TO ANOTHER.
; CALL WDATA VIA	JSR	PC,WDATA	WITH
; R2 = RSTOP = THE BLOCK NUMBER OF THE BLOCK AFTER THE LAST ONE TO READ.
; R1 = RSTART = THE FIRST BLOCK TO READ
; R2-R1 CAN NOT EXCEED 255.
; R3 = WSTART = THE BLOCK ON THE OUTPUT DEVICE TO START THE WRITE TO
; WDATA READS A BUFFER OF DATA INBUF WORD SIZE BIG STARTING AT BLOCK RSTART.
; IT THEN WRITES THE NUMBER OF BLOCKS (STOP-START) READING AS MANY BUFFER LOADS
; AS NECESSARY.AND WRITING AS MANT AS NECESSARY.
; IF THE DATA ON A SINGLE DEVICE TRANSFER IS IN THE SAME PLACE, NO
; TRANSFER IS EXECUTED.
; VALUES NEEDED TO BE INITIALIZED ONCE ARE
;
; ALL REGISTERS ARE RESTORED
WDATA:	TST	OUTDEV		;TEST IF A ONE DEVICE TRANSFER
	BNE	6$		;NO, DO THE WRITE
	CMP	R3,R1		;YES ;IS THE THE DATA GOING TO BE MOVED
	BNE	6$		;YES, DO THE I/O
	RTS	PC		;NO EXIT
6$:	JSR	PC,SAVREG

4$:	CLR	R4		;CLEAR MULTIPLE READ FLAG.
	MOV	R2,R5		;FIND NUMBER OF BLOCKS TO TRANSFER.
	SUB	R1,R5		;R5=RSTOP-RSTART.
	BEQ	5$		;IF 0 NOTHING TO WRITE.
	CMP	R5,INBSIZ	;TEST IF TRANSFER CAN BE DONE IN
	BLO	1$		;ONE READ/WRITE.BRANCH IF YES.
	MOV	INBSIZ,R4	;R4=NUMBER OF BLOCKS TO READ/WRITE
	MOV	R4,R5
1$:	SWAB	R5		;MULTIPLY BY 256..
				;R5=NUMBER OF WORDS TO R/W.
	MOV	R5,INSIZ	;SET NUMBER OF WORDS TO READ.
	MOV	R1,INBLK	;AND BLOCK TO START FROM.
	JSR	PC,READE0	;READ DATA.
	BCC	7$
	JSR	R5,PRINTS	;PRINT ERROR MESSAGE
	MESERU
	CMP	#1,INBSIZ	;TEST IF 1 BLOCK MODE.
	BEQ	9$		;YES,JUST CONTINUE.
10$:	MOV	#1,INBSIZ	;ELSE  SET NUMBER OF BLOCKS TO I/O
				;PER TRANSFER TO 1.
	BR	4$		;REDO I/O
				;CODE FOR /IMAGE, TO CATCH AN
				;ILLEGAL REQUEST FROM A FILE.
7$:	TST	R0		;TEST FOR R0=0;MT RETURN.
	BEQ	9$		;YES
	CMP	R0,R5		;TEST IF ALL DATA WAS READ.
	BEQ	9$		;YES
	.PURGE	#1		;ILLIMINATE THE OUTPUT FILL.
	JMP	CERMES		;NO
9$:	MOV	R3,OUTBLK	;STORE BLOCK TO WRITE TO.
	MOV	R5,OUTSIZ	;NUMBER OF WORDS TO WRITE.
	MOV	R5,R0		;CALCULATE LAST BLOCK TO WRITE THIS TIME.
	SWAB	R0		;R0=BLOCKS TO WRITE.
	ADD	R3,R0		;R0=LAST BLOCK+1  TO WRITE.
	CMP	R0,OUTSTA+6	;TEST IF OFF END OF DEVICE.
	BLOS	8$		;NO
	TST	OUTSTA+6	;TEST IF MAGTAPE,
	BEQ	8$		;CONTINUE IF SO
	JMP	DFUMES		;YES,DEVICE FULL.
8$:	JSR	PC,WRITE1	;WRITE DATA.
	BCC	2$
	JSR	R5,PRINTS	;PRINT ERROR MESSAGE
	MESEWU
	CMP	#1,INBSIZ	;TEST IF IN 1 BLOCK MODE.
	BEQ	2$		;YES,CONTINUE
	BR	10$		;ELSE RETRY IN 1 BLOCK MODE.
2$:	TST	R4		;TEST IF MORE DATA TO READ.
	BNE	3$
5$:	JSR	PC,RSTREG	;NO
	RTS	PC
3$:	ADD	R4,R3		;R3=BLOCK TO WRITE TO NEXT.
	ADD	R4,R1		;R1=BLOCK TO START READ FROM.
	BR	4$		;DO NEXT READ.

; DIRECTORY STORE ROUTINE
; THIS ROUTINE WILL STORE FILE ENTRIES IN A DIRECTORY THAT IS
; SEQUENTIALLY LINKED.  THE ENTRIES ARE STORED SEQUENTIALLY TIL A SEGMENT
; IS FULL ;THE SEGMENT IS LINKED TO THE NEXT SEGMENT IN ORDER AND WRITTTEN OUT
; TO THE DIRECTORY.  THERE ARE THREE ENTRIES
; DIRFST - STORE A FILE ENTRY
; DIREST - STORE AN EMPTY
; DIRBST - STORE A .BAD ENTRY
; FOR EACH ENTRY THE ROUTINE IS CALLED VIA	JSR	PC,ENTRY, WITH
; R0 = THE FILE SIZE ON ENTRY
; R4 = POINTER TO THE INPUT DIRECTORY OF THE CURRENT FILE DIRECTORY
; ALL REGISTERS ARE RESTORED.
	.ENABL	LSB
DIRFST:	CLR	-(SP)		;SET FLAG 0
				;ENTRY TO STORE A FILE.
	BR	1$
DIRBST:	MOV	#1,-(SP)	;SET FLAG 1
				;ENTRY TO STORE A .BAD FILE.
	BR	1$
DIREST:	MOV	#-1,-(SP)	;SET FLAG -1
				;ENTRY TO STORE AN EMPTY.
1$:	JSR	PC,SAVREG
				;R4 = POINTS TO THE CURRENT INPUT FILE
	MOV	DIROBP,R5	;R5 = ADDRESS POINTER TO STORE NEXT FILE IN
				;THE OUTPUT BUFFER.
	MOV	R5,R0		;TEST IF THERE IS ROOM FOR A FILE ENTRY,
	ADD	DIRSZ,R0	;DIROBP+DIRSZ .LT. DIROUB+1024.
				;MUST HAVE 1 WORD FOR THE END OF DIRECTORY ENTRY.
	CMP	R0,DIRINB
	BLO	2$		;SEGMENT HEADER + 2 HAS THE SEGMENT NUMBER IN IT.
	MOV	#DIREOB,(R5)	;WRITE END OF SEGMENT MARKER.
	MOV	DIROUB,R5	;RESET R5 TO TOP OF DIR. SEGMENT
	MOV	2(R5),R0	;WRITE THE DIRECTORY SEGMENT. SET LINK TO NEXT SEGMENT.
	INC	2(R5)		;THIS SEGMENT WILL LINK TO THE NEXT HIGHEST SEGMENT.
				;SINCE THERE IS AT LEAST 1 MORE FILE TO WRITE OUT.
				;THE REST OF THE SEGMENT HEADER IS THE SAME EXCEPT
				;+10 WHICH HAS BEEN SET ALREADY.
	CMP	2(R5),(R5)	;TEST IF DIR. SIZE IS EXCEEDED.
	BLOS	7$
	JMP	DFLMES		;EXIT IF SO.
7$:	JSR	R5,WDIR		;WRITE THE SEGMENT WHOSE NUMBER IS IN R0.
	MOV	SEGBST,10(R5)	;PUT THE BLOCK NUMBER WHERE FILES IN THE NEXT
				;SEGMENT BEGINS
				;SET THE OUTPUT SEGMENT POINTER TO
	ADD	#12,R5		;THE ADDRESS FOR THE FIRST FILE ENTRY
2$:	MOV	12(SP),R0	;ADD THE FILE SIZE TO SEGMENT BLOCK COUNT.
	ADD	R0,SEGBST	;R0 CONTAINS THE FILE SIZE ON ENTRY AND
				;SAVREG SINKS IT ON THE STACK.
	TST	16(SP)		;TEST FOR TYPE OF ENTRY
	BEQ	4$
	BMI	3$
	MOV	#BADFIL,R1	;STORE A .BAD FILE, SIZE IS IN R0
	JSR	PC,MKFILE
	BR	6$
3$:	JSR	PC,MAKEMP	;STORE AN EMPTY, SIZE IS IN R0
	BR	6$
4$:	MOV	DIRSZ,R1	;TRANSFER THE FILE ENTRY FROM THE INPUT SEGMENT.
	ASR	R1		;DIVIDE BY 2 FOR WORDS.
5$:	MOV	(R4)+,(R5)+
	DEC	R1
	BNE	5$
6$:	MOV	R5,DIROBP	;SAVE THE OUPUT POINTER.
	JSR	PC,RSTREG
	TST	(SP)+		;POP OFF FLAG
	RTS	PC
	.DSABL	LSB
;IMAGE WILL DO A BLOCK FOR BLOCK COPY OF A DEVICE
;TO ANOTHER
;OR BLOCKS IN A FILE TO ANOTHER FILE.
;THE NEW FILE STARTS THE WRITE FROM BLOCK 0 ONLY.
;DEVO:=DEVI:[FILENAME]/I[:INDEV START BLK: INDEV STOP BLOCK:OUTDEV START BLOCK

IMAGE:	JSR	R5,TESTSF	;TEST FOR COMMAND ERRORS.
	.WORD	440
	TST	INFILE		;TEST FOR INPUT FILE.
	BEQ	7$		;NONE
	TST	OUTFIL		;TEST FOR OUTPUT FILE
	BEQ	6$		;IF NONE ITS AN ERROR.
	TSTB	SI+2		;TEST FOR /I VALUES
	BPL	7$		;BR IF VALUES INPUT
6$:	JMP	CERMES		;ELSE AN ERROR.
7$:	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES
	.WORD	136777
	CMP	DKNAM,OUTDEV	;TEST FOR A DEFAULT OUTPUT DEV.
	BNE	10$		;NO
	.PRINT	#MESW		;PRINT A WARNING MESSAGE.
	.PRINT #MESDKW
10$:	MOV	#SLASHI,R1	;ASK,"ARE YOU SURE".
	JSR	PC,RUS
	MOV	DIROUB,R1	;USE ALL CORE ABOVE FREE:.
	JSR	PC,BUFSZH	;GET BUFFER SIZE.
	TST	OUTSTA+6	;TEST FOR MT.
	BEQ	9$		;YES
	TST	INSTA+6		;TEST FOR MT
	BNE	5$
9$:	MOV	BLKOUB,R0	;SET BUFFER SIZE TO 1K FOR MT.
	JSR	PC,BUFSZL	;RECALL BUFFER SETUP.
5$:	MOV	DIROUB,INBUF	;INITIALIZE READ AND WRITE ROUTINE.
	MOV	DIROUB,OUTBUF
	CLR	R1		;START READ AT BLOCK 0.
	CLR	R3		;START WRITE AT BLOCK 0.
	TSTB	SI+2		;TEST IF SWITCH VALUES WERE GIVEN.
	BEQ	3$		;NO
	CMPB	#3,SI+1		;MAKE SURE THREE WERE GIVEN.
	BEQ	1$
	JMP	CERMES		;IF NOT PRINT ERROR
1$:	MOV	SIV,R1		;R1 = START OF READ
	MOV	SIV+2,R2	;R2 = END OF READ + 1
	CMP	R1,R2		;TEST FOR ERROR.
	BHI	6$		;START>STOP.
	INC	R2
	MOV	SIV+4,R3	;R3 = START OF WRITE
	BR	2$		;DO READ/WRITE.
3$:	MOV	OUTSTA+6,R4	;R4 = OUT DEVICE SIZE
	MOV	INSTA+6,R2	;R2 = IN DEVICE SIZE
	BEQ	4$		;BRANCH IF INPUT IS MT.
	TST	R4		;TEST IF OUTPUT IS MT.
	BEQ	2$
	CMP	R2,R4		;TEST FOR SMALLEST DEVICE SIZE.
	BLOS	2$		;BRANCH IF INPUT IS.
4$:	MOV	R4,R2		;READ THE NUMBER OF BLOCKS =
				;THE OUTPUT
				;R2 = LAST BLOCK + 1 READ = DEVICE SIZE
2$:	JSR	PC,WDATA	;READ/WRITE DATA
	TST	OUTSTA+6	;TEST FOR MT ON OUTPUT.
	BNE	8$		;NO.
	JSR	R5,ZMTWTO	;YES,WRITE A TAPE MARK.
	.WORD	MTTM
8$:	JMP	COMRTN
 
BUFSZH:	MOV	#-2,R0		;SETTOP FOR ALL AVAILABLE MEMORY.
BUFSZL:	.SETTOP			;ENTRY TO SETTOP FOR LIMITED MEMORY.
	CMP	R0,R1		;TEST IF ANY ROOM.
	BLOS	1$		;BRANCH IF NO.
	SUB	R1,R0		;SUBTRACT START OF BUFFER.
	ADD	#2,R0		;ADD 2 TO GET ALL OF MEMORY.
	ASR	R0		;DIVIDE BYTES TO WORDS.
	BIC	#100377,R0	;CONVERT TO BLOCKS.
				;ZERO BIT 15 IF SET BY ASR.
	SWAB	R0		;R0= NUMBER OF BLOCKS
	MOV	R0,INBSIZ	;STORE IN INBSIZ FOR ROUTINE WDATA.
	BEQ	1$		;ERROR IF ZERO BUFFER SPACE.
	RTS	PC
1$:	JMP	NOCMES
.ENDC
 

; /B WILL SCAN THE DEVICE FOR BAD BLOCKS AND WRITE .BAD FILES
; OVER THE BAD BLOCKS. 
; /B CAN BE EXECUTED ONLY ON A ZEROED DEVICE.  MULTIPLE CONTIGUOUS BAD BLOCKS WILL
; BE INCORPORATED INTO ONE .BAD FILE

; COMMON VARIABLES USED
; DIRXBY
; SEGMNT

; LOCAL SYMBOLS
BFFB:	0			;FIRST FREE BLOCK AVAILABLE FOR FILES
HIGHSG:	0			;HIGHEST SEGMENT IN DIR.
BADFBK:	0			;FIRST BLOCK OF FILES.
BADLAT:	0			;ADDRESS OF LAST BAD BLOCK IN TABLE.


BAD:	MOV	BLKOUB,R5	;TABLE TO STORE BAD BLOCK NUMBERS.
	MOV	#256.,R4	;MAX. NUMBER OF BAD BLOCKS ALLOWED.
	MOV	#1,R0		;SET TO SCAN THE DISK FROM BLOCK 0
				;TO END OF DISK WITH WRITE AFTER 
				;READ OPTION.
	MOV	INSTA+6,R2
	DEC	R2
	CLR	R1
	JSR	PC,BSCAN	;SCAN DISK.
	BR	5$		;NO ERRORS
	BR	2$		;SOFT ERROR
3$:	MOV	R0,(R5)+	;HARD ERROR,STORE IN TABLE.
	BEQ	4$		;ERROR IF BLOCK 0
				;ZERO WILL BE USED IN TABLE LATER
	DEC	R4		;TEST IF TOO MANY BAD BLOCKS.
	BGT	2$		;NO
	JMP	TMBMES		;OTHERWISE PRINT MESSAGE
4$:	JMP	ESAMES
5$:	JMP	BADEX

2$:	JSR	PC,BSCNRE	;RECALL BSCAN AFTER AN ERROR
	BR	BADFB		;ALL ERRORS FOUND.
	BR	2$		;SOFT ERROR
	BR	3$		;HARD ERROR
BADFB:	MOV	#-1,(R5)	;STORE END MARKER IN TABLE
				;START TO BUILD FILES.
	MOV	#1,R0		;READ SEGMENT 1
	MOV	R0,SEGMNT	;INITIALIZE VARIABLE TO 1
				;CURRENT  SEGMENT IN USE.
	JSR	R5,RDIR		;NOW READ IT
	MOV	DIRINB,R5	;GET START OF DIR. BUFFER ADDRESS.
	MOV	(R5),HIGHSG	;HIGHEST SEG. IN DIR.
	MOV	6(R5),DIRSZ	;SET DIRSZ=DIR. ENTRY SIZE.
	ADD	#DIRSIZ,DIRSZ
	MOV	6(R5),DIRXBY	;SET DIRXBY=EXTRA BYTES IN DIR. ENTRY.
	MOV	10(R5),R2	;GET FIRST BLOCK OF FILES.
				;SET R2 =FIRST BLOCK OF SEGMENT
				;FOR EACH DIR. SEGMENT.
	MOV	22(R5),R3	;SET R3=SIZE OF EMPTY IN ZEROED DIR.
				;R3=LAST EMPTY SIZE WHEN DONE.
	MOV	R2,R4		;SET R4=FIRST FILE BLOCK-1
	MOV	R2,BADFBK	;SAVE FIRST BLOCK.
	DEC	R4
				;R4= LAST BAD BLOCK INCOUNTED.
	MOV	R2,BFFB		;SET BFFB=FIRST BLOCK THAT CAN BE
				;BAD ON A DISK
				;SET=FIRST FILE BLOCK,
1$:	ADD	#12,R5		;SET R5=FIRST BLOCK ENTRY IN SEG.
				;R5=ADDRESS TO STORE DIR. ENTRIES.

BAD5:	MOV	BLKOUB,R1	;R1=TABLE OF BAD BLOCKS.
				;SEARCH IT FOR THE SMALLEST ONE LEFT.
2$:	MOV	R1,BADLAT	;SAVE ADDRESS OF SMALLEST BLOCK FOUND.
	MOV	(R1)+,R0	;GET A BLOCK
	BMI	BAD4		;IF -1 TABLE IS EMPTY
	BEQ	2$		;IF 0 GET THE NEXT ENTRY
4$:	TST	(R1)		;OTHERWISE  TEST IF THE NEXT BLOCK IS VALID.
	BMI	6$		;IF -1 ,FOUND A BLOCK
	BNE	3$		;IF POSITIVE,TEST IT AGAINST PREVIOUSLY
				;FOUND BLOCK
5$:	TST	(R1)+		;IF 0 SKIP TO NEXT ENTRY
	BR	4$
3$:	CMP	(R1),R0		;TEST TO SEE IF BLOCK IS SMALLER.
	BLO	2$		;YES,SAVE IT
	BR	5$		;NO GET NEXT BLOCK
6$:	CLR	@BADLAT		;FOUND THE SMALLEST BLOCK
				;ZERO ITS LOCATION SO AS NOT TO BE
				;USED AGAIN.
	CMP	R0,BFFB		;COMPARE THE BAD BLOCK WITH THE FIRST FREE
	BHIS	1$		;BLOCK FOR FILES
	JMP	ESAMES		;PRINT "ERROR IN SYSTEM AREA"
1$:	INC	R4		;ADD 1 TO VALUE OF LAST BAD BLOCK.
	CMP	R0,BADFBK	;TEST IF FIRST BLOCK OF FILE IS BAD.
	BEQ	BAD3		;IF YES MUST CREATE AN FILE FIRST.
	CMP	R0,R4		;TEST IF NES BAD BLOCK IS ONE AFTER LAST BAD BLOCK.
	BNE	BAD1		;NO
	SUB	DIRSZ,R5	;YES, POINT BACK TO LAST .BAD FILE STATUS WORD
	INC	10(R5)		;ADD ONE TO THE FILE SIZE
	ADD	DIRSZ,R5	;POINT TO NEXT DIRECTORY ENTRY
	INC	R2		;ADD 1 TO FIRST BLOCK OF SEG. COUNT.
	DEC	R3		;-1 TO LAST EMPTY COUNT.
	BR	BAD5
BAD1:	JSR	PC,BWRSEG	;TEST TO WRITE SEGMENT OUT.
	MOV	R0,-(SP)	;SAVE BAD BLOCK NUMBER.
	SUB	R4,R0		;R0=EMPTY SIZE=BAD BLOCK-LAST BAD BLOCK-1.
	SUB	R0,R3		;UPDATE LAST EMPTY SIZE.
	ADD	R0,R2		;AND SEG.FIRST BLOCK.
	JSR	PC,MAKEMP	;CREATE AN EMPTY.
	MOV	(SP)+,R4	;STORE LAST BAD BLOCK.
	JSR	PC,BWRSEG	;TEST TO WRITE SEG.
BAD3:	MOV	#1,R0		;CREATE A BAD FILE OF SIZE 1.
	MOV	#BADFIL,R1
	JSR	PC,MKFILE
	DEC	R3		;UPDATE LAST EMPTY SIZE.
	INC	R2		;AND SEG. FIRST BLOCK.
	BR	BAD5		;GET NEXT BLOCK.
BAD4:	JSR	PC,BWRSEG	;TEST TO WRITE THE SEG.
	MOV	R3,R0		;CREATE THE LAST EMPTY.
	JSR	PC,MAKEMP
	MOV	DIRINB,R2	;WRITE THE LAST SEG. OUT.
	CLR	2(R2)		;WITH A 0 LINK.
	MOV	#DIREOB,(R5)	;PUT IN END OF SEG. MARKER.
	MOV	SEGMNT,R0	;SEGMENT TO WRITE.
	JSR	R5,PUTDIR	;AND NOW WRITE IT.
	DIRINB
	MOV	#1,R0		;READ IN FIRST SEGMENT.
	JSR	R5,RDIR
	MOV	SEGMNT,4(R2)	;STORE HIGHEST SEG IN USE.
	MOV	#1,R0		;AND WRITE SEG. 1 BACK.
	JSR	R5,PUTDIR
	DIRINB
BADEX:	JMP	COMRTN
	;BWRSEG WILL TEST IF THE DIR. SEGMENT IS FULL AND
	;WRITE IT OUT IF SO.AFTER THE WRITE IT INITIALIZES
	;FOR THE NEXT SEGMENT.

	.ENABL	LSB
BWRSEG:	JSR	PC,SAVREG
	MOV	R5,R0		;TEST IF DIR. BUFFER CAN TAKE
	ADD	DIRSZ,R0	;ONE MORE ENTRY.
	CMP	R0,BLKOUB	;BLKOUB IS THE BUFFER AFTER DIRINB.
	BLO	1$		;YES
	MOV	DIRINB,R1	;ADDRESS OF BUFFER.
	INC	SEGMNT		;SET SEGMENT TO NEXT SEG. NUMBER.
	MOV	SEGMNT,R0	;GET THE NEW SEGMENT NUMBER.
	MOV	R0,2(R1)	;SET LINK IN DIR SEGMENT TO NEXT SEG.
	MOV	#DIREOB,(R5)	;STORE END OF SEGMENT MARKER.
	CMP	R0,HIGHSG	;TEST IF LAST SEGMENT.
	BLO	3$		;BRANCH IF NO
	JMP	TMBMES		;EXIT IF SO.
3$:	DEC	R0		;SET R0=DIR. SEGMENT TO WRITE.
	JSR	R5,PUTDIR	;WRITE DIR.SEGMENT
	DIRINB
	MOV	R2,10(R1)	;STORE FIRST DIR. SEGMENT BLOCK.
	ADD	#12,R1		;START OF NEW DIR. SEGMENT ENTRY.
	MOV	R1,(SP)		;AND STORE IN R5 ON RETURN.
1$:	JSR	PC,RSTREG	;RESTORE REGISTERS
	RTS	PC
	.DSABL	LSB
.IF EQ M$DUP

; BLKFIL WILL FIND THE FILE IN WHICH A BLOCK RESIDES
; CALL BLKFIL VIA 	JSR	PC,BLKFIL	WITH THE BLOCK #
; IN R1 (=0, 1, 2, 3 ...)
; BLKFIL RETURNS TO CALL+2 WITH THE RELATIVE BLOCK # IN THE FILE
; IN R1 (=0, 1, 2, ...) AND R0 POINTING TO A THREE WORD RAD50
; FILE NAME, EMPTY OR TENTATIVE.  THE FILE NAME IS IN THE DIRECTORY
; IN THE BUFFER, DIRINB.  BLKFSG=SEG# OF FILE.
; IF BLOCK IS OUTSIDE THE DIRECTORY,R0=-1.
; BLKFLG IS THE ADDRESS OF THE FILE SIZE OF THE FILE ENTRY SORT.
; THE DIRECTORY SEGMENTS ARE READ IN DIRINB DESTROYING PREVIOUS INFORMATION.
; ON RETURN THE SEGMENT CONTAINING THE DESIRED FILE ENTRY IS IN DIRINB.
; R2-R5 ARE PRESERVED
BLKFIL:	JSR	PC,SAVREG	;SAVE PC, R0-R5 ON THE STACK
	MOV	#1,R2		;SET R2 TO READ THE FIRST DIRECTORY SEGMENT
	CLR	R5		;R5 WILL CONTAIN THE BLOCK ADDRESS OF THE FIRST BLOCK
5$:	MOV	R2,R0		;IN A FILE
	JSR	R5,RDIR		;READ IN A DIRECTORYSEGMENT INTO DIRINB
	MOV	R2,BLKFSG	;R2 = DIRECTORY SEGMENT TO READ, SAVE IN BLKFSG
	MOV	DIRINB,R4	
	TST	R5		;TEST IF FIRST DIRECTORY SEGMENT
	BNE	1$
	MOV	6(R4),R3	;YES, GET # OF EXTRA DIRECTORY BYTES
	MOV	R3,DIRSZ	;GET TOTAL DIR. SIZE.
	ADD	#DIRSIZ,DIRSZ
	ADD	#6,R3		;R3 = FILE INDEX FROM FILE LENGTH TO NEXT STATUS WORD
				;IN BYTES.
1$:	MOV	10(R4),R5	;R5 = FIRST BLOCK OF FILE BEING EXAMINED.
				;R4 = POINTER TO FILE ENTRY IN SEGMENT
	ADD	#12,R4		;R4 POINTS AT STATUS WORD,
4$:	CMP	(R4),#DIREOB	;TEST IF END OF SEGMENT
	BEQ	2$		;BRANCH IF YES
	ADD	#10,R4		;POINT AT FILE LENGTH, SAVE IT IN BLKFLG
	MOV	R4,BLKFLG
	ADD	(R4),R5		;R5 CONTAINS ABSOLUTE BLOCK # OF NEXT FILE
	CMP	R1,R5		;R1 = ABSOLUTE BLOCK SEARCHED FOR
	BLO	3$		;BLOCK IS IN THIS FILE IF R1<R5
	ADD	R3,R4		;R4 POINTS TO STATUS WORD OF NEXT ENTRY
	CMP	R4,BLKOUB	;TEST IF OUT OF DIR BUFFER.
	BLO	4$		;NO
9$:	JMP	IDRMES		;YES NOT A LEGAL DIR SEGMENT.
2$:	MOV	DIRINB,R2	;READ NXT SEGMENT, GET LINK TO NEXT SEGMENT
	ADD	#2,R2
	MOV	(R2),R2		;GET THE LINK INTO R2.
	BNE	5$		;GET NEXT SEGMENT.
				;BLOCK PAST DIR LAST FILE
				;RETURN R0=-1.
10$:	MOV	#-1,R4		;BLOCK NOT IN  DIR.SET R0=-1 AS FLAG ON EXIT.
	BR	8$		;AND EXIT.
3$:	SUB	(R4),R5		;R5 CONTAINS FIRST BLOCK NUMBER OF FOUND FILE
	SUB	R5,R1		;R1 CONTAINS THE RELATIVE BLOCK NUMBER (0,1, 2...) IN FILE.
	BMI	10$		;BAD BLOCK IN DIRECTORY.
	SUB	#10,R4		;R4 POINTS AT STATUS WORD OF FILE.
	CMP	(R4),#DIREMP	;TEST FOR FILE TYPE
	BEQ	6$		;IF EQUAL = EMPTY FILE (1000)
	CMP	(R4),#DIRTEN	;TEST IF A TENTATIVE FILE
	BNE	11$		;NO
	TSTB	@CONFGP		;TEST IF FJOB LOADED.
	BMI	7$		;YES
	BR	6$		;NO,TREAT TENTATIVES, AS EMPTIES.
11$:	CMP	(R4),#DIRPER	;TEST IF PERMANENT
	BNE	9$		;ERROR IF NONE OF ABOVE.
	ADD	#2,R4		;PERMANENT FILE
	BR	8$		;POINT R4 AT FILE NAME IN DIRINB
6$:	MOV	#SEMPTY,R4
	BR	8$
7$:	MOV	#STENTA,R4
8$:	MOV	R4,12(SP)	;STORE ADDRESS OF RAD50 NAME IN R0 ON THE STACK.
	MOV	R1,10(SP)	;STORE RELATIVE BLOCK NUMBER OF FILE IN R1 ON STACK
	JSR	PC,RSTREG
	RTS	PC
BLKFSG:	0			;SEG NUMBER READ
BLKFLG:	0			;POINTS AT FILE LENGTH
; ROUTINE TO WRITE DIRINB TO THE SEGMENT IN BLKFSG
; USED BY EXTEND, CREATE, BIN
SEGWRT:	MOV	BLKFSG,R0	;GET SEGMENT NUMBER
	JSR	R5,PUTDIR	;CALL WRITE ROUTINE
	DIRINB
	RTS	PC

; THIS ROUTINE WILL SLIDE A DIRECTORY UP ONE SLOT
; IT ASSUMES THAT BLKFIL HAS BEEN CALLED TO READ IN THE SEGMENT
; AND BLKFLG POINTS TO THE FILE SIZE OF THE ENTRY TO BE ELIMINATED
; THE ENTRY IS OF 0 SIZE AND ALL ENTRIES BELOW, INCLUDING THE END OF SEGMENT
; MARKER ARE SLID UP TO ELIMINATE THE ZERO ENTRY.
; ALL REGISTERS ARE RESTORED.

SEGSHF:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	DIRSZ,R0	;R0 = TOTAL SIZE OF A DIRECTORY ENTRY
	MOV	BLKFLG,R1	;CALCULATE ADDRESS OF ENTRY TO BE ELIMINATED
	SUB	#10,R1		;R1 = ADDRESS OF ENTRY TO BE ELIMINATED
	ADD	R1,R0		;R0 = ADDRESS OF NEXT ENTRY
2$:	CMP	(R0),#DIREOB	;TEST FOR END OF SEGMENT MARKER.
	BEQ	1$		;THE END
	MOV	(R0)+,(R1)+	;MOV ENTRY UP
	BR	2$
1$:	MOV	(R0),(R1)	;MOVE END MARKER UP
	MOV	(SP)+,R1	;RETURN
	MOV	(SP)+,R0
	RTS	PC
; CBLKFL IS A ROUTINE CALLED TO INITIALIZE VARIABLES AND TO LOCATE A BLOCK # IN A FILE.
; CALL CBLKFL VIA WITH R1 = THE BLOCK #.
;	JSR	PC,CBLKFL
;	RETURN IF BLOCK # IS NOT IN AN EMPTY
;	RETURN IF BLOCK # IS IN AN EMPTY
;
; CBLKFL WILL CALL BLKFIL TO LOCATE THE BLOCK # IN A FILE THEN
; INITIALIZE VARIABLES.  ON RETURN
;
; BLKFSG = SEG # CONTAINING THE BLOCK.
; BLKFLG = ADDRESS OF SIZE OF THE FILE ENTRY (IN DIRINB)
; BLKLOS = 0
; SEGMNT = BLKFSG
; FILSIZ = SIZE OF THE FILE IN WHICH BLOCK # RESIDES
; R2 = LAST BLOCK # OF PREVIOUS FILE
; R3 = FIRST BLOCK # OF NEXT FILE
; R4 = RELATIVE POSITION OF BLOCK # IN FILE
; R1 = R4
; R0 = ADDRESS OF FILE NAME OR "EMPTY".
;
CBLKFL:	MOV	R1,R2		;SAVE BLOCK NUMBER
	JSR	PC,BLKFIL	;READ IN SEG THAT CONTAINS BLOCK NUMBER.
	CMP	#-1,R0		;TEST IF IN  A VALID DIR FILE.
	BNE	2$		;YES
	JMP	CERMES		;NO,PRINT MESSAGE.
				;R1 = RELATIVE POSITION, 0 = FIRST BLOCK OF FILE
2$:	CLR	BLKLOS		;BLOCKS LOSS TO PREVIOUS EMPTY
	MOV	BLKFSG,SEGMNT	;SAVE SEGMENT NUMBER
	MOV	@BLKFLG,FILSIZ	;SAVE FILE SIZE
	SUB	R1,R2		;R2 = BLOCK # - REL BLK #
	MOV	R2,R3
	DEC	R2		;R2 = BLOCK # - REL BLK # - 1 = LAST BLOCK OF PREVIOUS FILE
	ADD	@BLKFLG,R3	;R3 = BLOCK # - RELBLK # + FILE SIZE =
				; FILE BLOCK OF NEXT FILE
	MOV	R1,R4		;R4 = REL POSITION OF INPUT BLOCK IN FILE
	CMP	R0,#SEMPTY	;TEST IF FOUND FILE IS EMPTY
	BNE	1$		;NO EMPTY, RETURN + 2
	ADD	#2,(SP)		;EMPTY, RETURN + 4
1$:	RTS	PC
.ENDC


; BSCAN WILL SCAN THE DEVICE BETWEEN THE LIMITS R1 TO R2 FOR BAD BLOCKS.
; CALL BSCAN VIA JSR  PC,SCAN WITH THE START ADDRESS IN R1, LAST BLOCK IN R2
; AND R0=0 FOR READ ONLY ;=1 TO TEST WRITE/READ.  R1<=R2, R2<=DEVICE SIZE.
; BSCAN RETURNS WITH THE BAD BLOCK IN R0 AND AT CALL+4 FOR A SOFT ERROR
; CALL+6 HARD ERROR AND AT CALL+2 FOR NO ERRORS.  AFTER THE FIRST ERROR RETURN BSCAN IS
; RECALLED VIA JSR PC,SCNRE TO CONTINUE THE SEARCH FOR BAD BLOCKS.  NOTE
; BSCAN RETURNS AFTER EACH BAD BLOCK FOUND.  NO REIGSTERS NEED BE SET ON ENTRY AT SCNRE
; ALL REGISTERS EXCEPT R0 ARE RESTORED.
; USES BUFFER BLKINB
BSCAN:	JSR	PC,SAVREG	;SAVE REGISTERS 0-5
	CLR	BSRWSF		;CLEARS SPECIAL FUNCTION FLAG.
	TSTB	SL+2		;TEST FOR /L
	BMI	8$		;NO
	MOV	#SPFTBL,R5	;TEST IF OK ON THIS DEVICE
6$:	TSTB	(R5)		;END OF TABLE?
	BPL	7$		;NO
	JMP	ILDMES		;YES - ILLEGAL DEVICE
7$:	CMPB	(R5)+,INSTA	;TEST TABLE AGAINST ID
	BNE	6$		;NOT THE SAME
	INC	BSRWSF		;MATCH, SET SPECIAL FUNCTION FLAG.
8$:	CMP	R2,INSTA+6	;TEST OF R2<DEVICE SIZE
	BHIS	5$		;LAST BLOCK = DEVICE SIZE -1
	CMP	R1,R2		;R1<=R2
	BLOS	4$
5$:	JMP	CERMES
4$:	MOVB	R0,SCANRW	;SAVE SCAN TYPE
	MOV	#SRATET,R4	;GET RATE OF ACCESS FOR DEVICE FROM TABLE
	MOVB	INSTA,R5	;READS ARE DONE BY SKIPPING BLOCKS TO GET
	MOV	#1,R3		;THE MAXIMUM NUMBER OF READS PER
3$:	CMPB	(R4)+,R5	;DISK REVOLUTION
	BEQ	1$
	BMI	2$		;NO MATCH FROM TABLE, DEFAULT TO 1.
	TSTB	(R4)+
	BR	3$
1$:	MOVB	(R4),R3		;R3 = DISK INDEX READ RATE
2$:	MOV	R2,SSTOP	;SAVE THE STOP ADDRESS AND RATE
	MOV	R3,SRATE
				;R1 IS THE START ADDRESS
	MOV	R1,SSTART	;SAVE FOR TEST
				;R4 IS THE FIRST BLOCK ADDRESS FOR A SEQUENCE DOWN
				;THE DISK
	MOV	R1,R4		;R4 IS THE BASE DISK ADDRESS
	MOV	R3,SRAP		;SRAP IS THE NUMBER OF PASSES DOWN THE DISK
	BR	SCANST		;I.E., IF RATE IS 3 THEN THE DISK IS READ 0, 3, 6, 9, ETC.
				;1, 4, 7, 10, ETC. THEN 2, 5, 8, 11 ETC. AND SRAP
				;WOULD =3.
BSCNRE:	JSR	PC,SAVREG	;REENTRY POINT AFTER AN ERROR RETURN
	MOV	SSTART,R1	;RESTORE VALUES SRAP STAYS AS LEFT OFF
	MOV	SSTOP,R2
	MOV	SRATE,R3
	MOV	SBASE,R4
SCANCO:	TST	R1		;IF ZERO ,DONE.
	BEQ	SDONE
SCANST:	JSR	PC,BSREAD	;READ  THE BLOCK.
	MOV	R1,-(SP)	;SAVE THE BLOCK READ ON THE STACK

6$:	ADD	R3,R1		;THROW AWAY THE REQUEST # THAT COMPLETED OK.
	CMP	R1,R2		;CALCULATE THE NEXT BLOCK TO READ ;ADD RATE
	BLOS	SCANS		;TEST IF PAST LAST BLOCK
	INC	R4		;IF YES, GO TO NEXT BASE
	MOV	R4,R1		;START READING NEXT BLOCK SEQUENCE.
	DEC	SRAP		;TEST IF ALL SEQUENCES DONE
	BNE	SCANS		;NO READ DISK
	CLR	SSTART		;FLAG = 0 SO WE DON'T RESTART
	CLR	R1		;SET R1=0 TO SET SSTART 0 BELOW.
SCANS:	MOV	BLKINB,R5	;GET ADDRESS OF SPFUN ERROR CODE.
	.WAIT	#0	;WAIT FOR COMPLETION.
	BCS	SERROR		;BRANCH IF ERROR.
	TSTB	SL+2		;TEST FOR ERROR LEVEL
	BMI	NOERR		;NO SPECIFIED
	TSTB	(R5)		;TEST ERROR CODE FROM HANDLER.
	BEQ	NOERR		;YES
	CMPB	(R5),SLV	;TEST IF RECOVERABLE ERROR SHOULD BE AN ERROR
	BLOS	SERR2		;BRANCH IF YES
NOERR:	TST	(SP)+		;POP OFF VALUE.
	BR	SCANCO		;READ NEXT BLOCK.
SERROR:	TST	SLV		;TEST IF L = -1
	BPL	SERR2		;NO
	CMPB	(R5),#200	;IF YES, RECORD ONLY MARKED BAD SECTORS
	BNE	NOERR		;IF NOT, NO ERROR.
SERR2:	MOV	R1,SSTART	;SAVE THE BLOCK # OF THE SECOND I/O QUEUED UP TO
	MOV	R4,SBASE	;START WITH OR REENTRY. SAVE BASE OF SEQUENCE.
SERR1:	MOV	(SP)+,R1	;BLOCK NUMBER OF ERROR BLOCK
	MOV	R1,12(SP)	;PUT IN R0 ON THE STACK
	TSTB	SCANRW		;TEST TO DO WRITE THEN READ ON ERROR BLOCK
	BEQ	1$		;NO
	MOVB	#11,BSRWAC	;SET TO DO A WRITE.
	JSR	PC,BSWRIT
	.WAIT	#0
	BCS	1$
	JSR	PC,BSREAD
	.WAIT	#0
	BCC	2$
1$:	ADD	#2,16(SP)	;HARD ERROR ON BLOCK
2$:	ADD	#2,16(SP)	;SOFT ERROR, COULD READ AFTER REWRITTEN
SDONE:	JSR	PC,RSTREG	;EXIT JSR  PC,SCAN
				;     DONE
	RTS	PC		;     SOFT ERROR
				;     HARD ERROR

; BSCAN LOCAL SYMBOLS
SRATET:	.BYTE	23,5,22,2,21,3,16,3,12,2,1,4,0,2,-1   ;DEVICE ACCESS RATE TABLE
				;EACH TWO NUMBERS IS DEVICE # FOLLOWED BY THE
				;SEARCH RATE. THE RATE IS THE NUMBER OF BLOCKS
				;TO SKIP BETWEEN EACH READ ACCESS DURING THE SEARCH.

SCANRW:	.BYTE	0		;=0 TO READ ONLY ;=1 TO WRITE READ ON ERROR.
				;SET BY BSCAN
	.EVEN
SSTOP:	0			;LAST BLOCK TO SEARCH TO
SRATE:	0			;# OF BLOCKS TO SKIP BETWEEN EACH READ
SSTART:	0			;THE START BLOCK FOR THIS BAD SEARCH
SBASE:	0			;THE FIRST BLOCK ADDRESS IN A BLOCK READ SEQUENCE
SRAP:	0			;# OF PASSES ACROSS THE ENTIRE DISK THAT WILL BE MADE
SLASTC:	0			;TEMPORARY STORAGE OF THE LAST CHANNEL READ
				;IN THE EXAMPLE OF THE READING SCHEME 0,3,6,9, ETC.,
				;1,4,7,10, ETC., THEN 2,5,8,11, ETC.,
				;SSTART = FIRST BLOCK TO READ ON ENTRY OR REENTRY TO BSCAN
				;SSTOP = LAST BLOCK TO BE TESTED, TO SCAN THE WHOLE DISK
				;SSTART = 0, SSTOP = LAST BLOCK
				;SBASE = 0, THEN 1 THEN 2
				;SRAP = 3 AND DECREMENTED TO 0
				;SRATE = 3
; SCAN LEVEL TABLE - THIS TABLE CONSISTS OF DEVICES THAT
; CAN BE SCANNED VIA SPECIAL FUNCTION CALLS.  THE SPECIAL FUNCTION
; WILL RETURN ERROR INFORMATION ON EACH READ IN THE FIRST WORD OF THE BUFFER

SPFTBL:	.BYTE	DMIDEN		;RK06 RETURNS THE BIT SET FOR
				;100000 ON I/O SUCCESS
				;100010 IF ECC CORRECTED
				;100004 IF GOOD ON CONTROLLER RETRY
				;100002 IF GOOD AFTER OFFSET RETRY
				;100001 IF GOOD AFTER RECALIBRATION
				;100200 IF A MARKED BAD BLOCK
				;1774XX IF UNRECOVERABLE ERROR BUT NOT
				;	MARKED BAD BLOCK.
	.BYTE	-1
	.EVEN
; /L:N IS THE LEVEL OF ERROR TO REPORT
; NO /L OR N=0 - UNRECOVERABLE BAD BLOCKS.
; L:1 ABOVE PLUS RECALIBRATION
; L:2 ABOVE PLUS OFFSET RETRY
; L:4 ABOVE PLUS CONTROLLER RETRY
; L:10 ABOVE PLUS ECC
; L:-1 REPORT ONLY MARKED BAD BLOCKS.
.IF EQ M$DUP

; VOLUME WILL WRITE THE VOLUME ID AND OWNER NAMES FROM A
; BLOCK REPLACEABLE DEVICE AND MT TO THE OUTPUT DEVICE.
; IF AN OUTPUT DEVICE IS NOT SPECIFIED TT: IS DEFAULT.  IF ONE IS
; SPECIFIED AND FILE STRUCTURED A FILENAME MUST BE SPECIFIED.
;	*TT:=DK:/V
;	VOL ID=XXXXXXXXXXXX<CRLF>
;	OWNER NAME=XXXXXXXXXXXX<CRLF>
;
;	DK:/V:1
; WILL CAUSE THE VOL ID TO BE CHANGED IN THE ZERO ROUTINE
; BUT THE DEVICE IS NOT ZEROED.
VOLUME:	JSR	PC,SETTPS	;SETTOP TO END OF BUFFERS.
	JSR	R5,TESTS	;TEST FOR ERRORS, NO INPUT FILE, MUST HAVE
	.WORD	445		;AN INPUT DEV, IT MUST BE FILE STRUCTURED, AND
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES
	.WORD	177757
1$:	TST	INSTA		;TEST FOR BLOCK REPLACEABLE DEVICE
	BMI	2$		;BRANCH IF SO
	CMPB	#TMIDEN,INSTA	;TEST FOR TM OR TJU MAGTAPE
	BEQ	4$
	CMPB	#TJIDEN,INSTA
	BEQ	4$		;NO
	JMP	CERMES		;OTHERWISE AN ERROR.
4$:	MOV	BLKINB,R1	;SET BUFFER TO ACCESS THE MT TAPE
	MOV	R1,SPBUF	;VIA BUFFER BLKINB.  MT 2 WORDS BEFORE FOR
	MOV	#MTRWND,R0	;REWIND THE TAPE
	JSR	PC,SPIO
	BCS	10$
5$:	MOV	#MTREAD,R0		;READ A 256. WORD BLOCK
	JSR	PC,SPIO
	BCC	7$
10$:	JMP	ERUMES
7$:	CMP	#240,(R1)	;TEST IF A BOOT BLOCK, IF SO READ THE NEXT BLOCK.
	BEQ	5$
	CMP	#"VO,(R1)	;TEST IF A VOL1 HEADER, IF NOT AN ERROR
	BEQ	6$
	JMP	DNZMES
6$:	JSR	R5,VOLPR1	;PRINT VOL ID AND OWNER NAMES FROM VOL1
	.WORD	MTPIL,6		;6 CHARACTERS AT MTPIL OF VOL 1
	.WORD	MTPOL,10.	;10. CHARACTERS AT MPTOL OF VOL 1
	MOV	#MTRWND,R0	;REWIND TAPE.
	JSR	PC,SPIO
	BR	8$
				;READ FROM BLOCK #1 OF INPUT DEVICE,
2$:	MOV	#1,R0		;ONE BLOCK INTO BLKINB
	JSR	PC,READB0
	JSR	R5,VOLPR1	;CALL ROUTINE TO RPINT THE VOL ID AND OWNER NAME
	.WORD	DSKPIL,12.	;12. CHARACTERS AT DSKPIL FOR VOL ID
	.WORD	DSKPOL,12.	;12. CHARACTERS AT DSKPOL FOR OWNER NAME
8$:	JMP	COMRTN

; SUBROUTINE TO PRINT VOL ID, OWNER NAME TO OUTPUT
VOLPR1:	MOV	BLKOUB,R0	;OUTPUT BUFFER
	MOV	#MESVID,R1	;STORE "VOL ID="
	JSR	R5,VOLSTR
	.WORD	9.		;= 4.5 BYTES +"=" = 5 WORDS.
				;R4 COUNTS # OF WORDS TO OUTPUT
				;R4 IS IN BYTES THEN CONVERTED TO
				;WORDS TO DO THE WRITE.
	MOVB	#'=,(R0)+	;STORE =.
	MOV	#12.,R4		;R4 = 5+1 FOR CRLF AT END
	MOV	BLKINB,R3	;ADDRESS OF THE INPUT BUFFER.
	MOV	R3,R1
	ADD	(R5)+,R1	;ADD THE OFFSET OF VOL ID IN INPUT BUFFER
	MOV	(R5)+,R2	;GET NUMBER OF CHARACTER WORDS TO PRINT
	ADD	R2,R4		;ADD R4 COUNT
	JSR	R5,VOLST0	;STORE CHARACTERS
	MOV	#MESOWN,R1	;STORE "OWNER NAME="
	JSR	R5,VOLSTR
	.WORD	13.		;=6.5 BYTES +"=" = 7 WORDS.
	MOVB	#'=,(R0)+	;STORE =.
	ADD	#14.,R4		;ADD R4 COUNT
	MOV	R3,R1		;BLKINB ADDRESS
	ADD	(R5)+,R1	;PLUS OFFSET FOR OWNER NAME
	MOV	(R5)+,R2	;NUMBER OF WORDS TO PRINT
	ADD	R2,R4		;ADD R4 COUNT
	JSR	R5,VOLST0	;STORE WORDS IN OUTPUT BUFFER.
	MOV	MESOWN,(R0)	;STORE A CRLF AT END OF PRINTOUT
	MOV	#OUTBLK,R0	;PREPARE TO WRITE THE BUFFER TO THE OUTPUT DEVICE
	CLR	(R0)+		;BLOCK 0
	MOV	BLKOUB,(R0)+	;OUTPUT BUFFER
	ASR	R4		;CHANGE TO WORDS.
	MOV	R4,(R0)		;NUMBER OF WORDS
	JSR	PC,WRIT1	;WRITE IT
	RTS	R5
VOLSTR:	MOV	(R5)+,R2	;MOVE (R5) WORDS FROM (R1)
VOLST0:	MOVB	(R1)+,(R0)+	;TO (R0)
	DEC	R2
	BNE	VOLST0
	RTS	R5
.ENDC

; WBOOT WILL WRITE THE BOOTSTRAP ONTO A BLOCK REPLACEABLE DEVICE
; FROM THE SPECIFIED MONITOR FILE.  OUTDEV:=INDEV:FILE.EXT/U.
;OR  DEV:FILE.EXT/U.
; IF NO OUTPUT DEVICE IS SPECIFIED THE BOOT WILL BE WRITEN ONTO THE INPUT DEVICE.
; WBOOT WILL READ THE FIRST 5 BLOCKS FROM THE SPECIFIED FILE AND WRITE
; BLOCK 0 TO PHYSICAL BLOCK 0 OF THE DISK, AND BLOCK 1-4 TO PHYSICAL 2-5.
WBOOT:
.IF NE M$DUP
	MOV	FREEM,R0	;SETTOP FOR 5 BLOCKS.
	ADD	#1280.*2,R0
PATMD1:	JSR	PC,SETTOP	;WILL BE PATCHED OUT FOR MDUP.BOT.
.IFF
	JSR	PC,SETTPS	;SETTOP TO END OF BUFFERS.
	JSR	R5,TESTS	;TEST FOR ERRORS AND FJOB RUNNING
	.WORD	171		; INPUT AND OUTPUT DEVICES MUST BE BLOCK
.ENDC
				;REPLACEABLE, AN INPUT FILE MUST BE SPECIFIED
.IF EQ M$DUP
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES
	.WORD	147777
.ENDC
	MOV	#INBLK,R1	;POINT TO READ1 EMT AREA
	CLR	(R1)+		;READ STARTING AT RELATIVE BLOCK 0
.IF NE M$DUP
	MOV	FREEM,(R1)+
.IFF
	MOV	DIROUB,(R1)+	;INTO BUFFER DIROUB
.ENDC
	MOV	#1280.,(R1)+	;5 BLOCKS = 5 X 256.= 1280. WORDS
	JSR	PC,READ0
	MOV	#OUTBLK,R1	;POINT TO WRITE1 EMT AREA
	CLR	(R1)+		;WRITE STARTING AT PHYSICAL BLOCK 0
.IF NE M$DUP
	MOV	FREEM,(R1)+
.IFF
	MOV	DIROUB,(R1)+	;FROM BUFFER DIROUB.
.ENDC
	MOV	#256.,(R1)+	;1 BLOCK = 256. WORDS.
	JSR	PC,WRIT1
	MOV	#1024.,-(R1)	;WRITE 4 BLOCKS = 4 X 256. = 1024. WORDS
	ADD	#512.,-(R1)	;FROM BUFFER ADDRESS C(DIROUB)+512. BYTES
	MOV	#2,-(R1)	;STARTING AT PHYSICAL BLOCK 2
	JSR	PC,WRIT1
	JMP	COMRTN		;RETURN

	.SBTTL	BOOT /O
; CAN CALL BOOT AS DEV:/O OR DEV:FILE/O
; DEV:/O READS BLOCK 0 OF THE DEVICE INTO DIROUB,
; MOVES IT TO 0-777 AND STARTS AT 0.
; DEV:FILE/O READS BLOCK 0 -> DIRUUB
;            READS BLOCK 2-5 -> DIROUB+256.
; MOVE IT TO 0-4777 AND JUMPS TO A LOCATION IN THE
; BOOT AFTER WHICH IT THINKS IT ALREADY READ BLOCK 2-5
; DEV:FILE/O MUST AGREE IN DEVICE AND FILE NAME.
; I.E., XXN:XXMNYY.SYS/O
BOOT:
.IF EQ M$DUP
	JSR	PC,SETTPS	;SETTOP TO END OF BUFFERS.
	JSR	R5,TESTSY	;TEST FOR ERRORS.  TEST IF FJOB RUNNING.
	.WORD	71		;NO OUTPUTT FILE, INPUT DEVICE MUST BE
				;BLOCK REPLACEABLE AND AN INPUT DEVICE MUST BE PRESENT
	JSR	R5,SWTST	;TEST FOR ILLEGAL SWITCHES
	.WORD	57777
	TST	INFILE		;TEST FOR A FILE
	BEQ	BOOTS		;NO
	CMP	SYS,INFILE+4	;TEST FOR .SYS TYPE
	BNE	BOOTE		;ERROR
				;TEST IF FILE SPEC AGREES WITH DEVICE.
	MOV	INFILE,R0	;GET RAD50 VALUE OF XXM.
	MOV	#50,R1		;DIVIDE IT BY 50 TO KNOCK OFF M.
	JSR	PC,DIV
	ASL	R0		;MULTIPLY QUOTIENT BY 50
	ASL	R0		;TO GET BACK RAD 50 VALUE OF XX.
	ASL	R0
	MOV	R0,-(SP)
	ASL	R0
	ASL	R0
	ADD	(SP)+,R0
	MOV	R0,DINDEV	;STORE RAD50 DEVICE NAME .
	MOV	#DINDEV,R2	;PUT ADD. IN R2
	JSR	PC,DSTATO	;AND DO A DSTATUS
;	.DSTATUS #OUTSTA,#DINDEV ;GET DSTATUS OF DEV WITH NAME XX
				;FROM FILE NAME.
	CMP	INSTA,OUTSTA	;TEST IF DEVICE   TYPE AND DEVICE
				;TYPE FROM THE FILE NAME ARE THE SAME.
	BEQ	BOOTS		;RKMNYY CAN BE BOOTED ONLY FROM RKN:.
BOOTE:	JMP	CERMES
				;A LOOKUP HAS BEEN DONE ON THE FILE SPECIFIED
				;OR THE DEVICE NON FILE STRUCTURED.
BOOTS:	JSR	PC,WWAIT	;WAIT FOR <CR>
	MOV	#BOOTK,TRPVEC	;GET IN KERNEL MODE FOR XM MON.
	CLR	TRPVEC+2
	TRAP	0
.ENDC
BOOTK:	MOV	DIROUB,R2	;R2 = ADDRESS TO STORE BLOCK
	MOV	#256.,INSIZ	;READ ONE BLOCK
	MOV	R2,INBUF	;IN DIROUB
	CLR	INBLK		;READ BLOCK 0 OF DISK OR FILE.
	JSR	PC,READ0	;READ BLOCK
				;STORE TIME AND DATE AT LOGICAL 5000 FROM 0.
	MOV	R2,R4		;GET ADDRESS TO STORE TIME IN BOOT.
	ADD	#BOOTIM,R4
	.GTIM	#AREA,R4	;STORE TIME.
	.DATE
	MOV	R0,<BOODAT-BOOTIM>(R4) ;STORE DATE.
	CLR	R1		;R1 -> ADDRESS TO STORE BOOT.
	MOV	#2,BOOTJP	;ASSUME TO JUMP TO LOCATION 2, THE START OF THE BOOT.
.IF EQ M$DUP
	TST	INFILE		;TEST FOR A FILE
	BEQ	BOOTMO		;BRANCH IF NO FILE
	CMP	#240,(R2)	;TEST FOR A VALID BOOT FILE.
	BEQ	3$
	.PRINT	#REBOOT
4$:	JMP	CERMES		;PRINT MESSAGE.
3$:	MOV	#1024.,INSIZ	;READ BLOCKS 1-4
	ADD	#512.,INBUF	;INTO DIROUB+512.
	INC	INBLK
	JSR	PC,READ0
				;GET ADDRESS TO JMP TO IN BOOT.
	MOV	BOOTST(R2),BOOTJP	;STORE TO JMP INDIRECT
				;AFTER ALL BLOCKS ARE READ.
.ENDC
BOOTMO:	RESET			;DO A RESET TO STOP ALL I/O.
	CLR	INBUF		;READ ONE WORD TO LOCATION 0
	CLR	INBLK		;TO RESET UNIT # IN CONTROLLER.
	MOV	#1,INSIZ
	JSR	PC,READ0
	MOV	INSTA,R4	;GET DEVICE TYPE.
	MOVB	SAVSTO+11,R0	;AND UNIT NUMBER IN R0
				;FOR DX - CAN ONLY BOOT DX0 AND DX1
	.MTPS	#340		;SET PRIORITY 7 FOR LSI.
	MOV	#<256.*5>+6,R3	;MOVE FILE BLOCKS 0-4 PLUS TIME&DATE TO LOCATION 0.
2$:	MOV	(R2)+,(R1)+	;MOVE THE BOOT TO LOCATION 0 AND UP.
	DEC	R3
	BNE	2$
.IF EQ M$DUP
	CMPB	#DXIDEN,R4	;TEST FOR A DX
	BNE	1$		;NO
	CMP	#2,BOOTJP	;TEST FOR JUMP TO 2.
	BEQ	1$
	MOV	#137,@#DXRDX	;STORE JMP READF  IN READS ROUTINE IN  BOOT,
	MOV	#DXREADF,@#DXRDX+2
	MOV	#DXUN0,@#DXRDCMD ;STORE READ COMMAND FOR UNIT 0.
	MOV	R0,@#DXUNIT	;STORE UNIT NUMBER IN READS ROUTINE.
	BEQ	1$		;BRANCH IF UNIT 0.
	MOV	#DXUN1,@#DXRDCMD ;ELSE STORE READ COMMAND FOR UNIT 1
.ENDC
1$:	MOV	#10000,SP	;SET STACK POINTER.
	CLR	@#0		;SET 0 TO ZERO FOR BOOT.
				;IF LOC 0=0 READ DATE/TIME FROM 5000
				;IF       =240 SET DATE/TIME -0
	JMP	@BOOTJP		;CALL THE BOOT.
BOOTJP:	.WORD	0		;BOOT ENTER ADDRESS.

.IF EQ M$DUP
; TESTS WILL TEST IF AN INPUT OR OUTPUT FILE OR DEVICE WAS
; SPECIFIED AND WHETHER THE DEVICE IS BLOCK REPLACEABLE
; TESTMC IS SET 1 ON MT AND CT AND 0 OTHERWISE
; ENTRY POINT TESTSF WILL CALL FBRUN BEFORE ENTERING TESTS
;R0,R1 ARE DESTROYED,R2-R5 UNCHANGED.
; TESTS IS CALLED VIA
;	JSR	R5,TESTS/TESTSF
;	CODE	WORD
; CODE WORD = SUM OF THE FOLLOWING TESTS
; 1 - NO OUTPUT FILE ALLOWED
; 2 - NO OUTPUT DEVICE ALLOWED
; 4 - NO INPUT FILE ALLOWED
; 10 - INPUT DEVICE MUST BE BLOCK REPLACEABLE
; 20 - OUTPUT DEVICE MUST BE BLOCK REPLACEABLE
; 40 - AN INPUT DEVICE MUST BE PRESENT
; 100 - INPUT FILE MUST BE PRESENT
; 200 - OUTPUT FILE MUST BE PRESENT.
; 400 - INPUT DEVICE MUST BE FILE STRUCTURED
	.ENABL	LSB
TESTSF:	JSR	PC,FBRUN	;CALL FJOB CHECK ROUTINE, DON'T WAIT FOR "YES".
	BR	TESTS
TESTSY:	JSR	PC,FBRUNY	;CHECK FJOB AND WAIT FOR "YES" TO CONTINUE.
TESTS:	MOV	(R5)+,R0	;GET CODE WORD FROM CALL.
	MOV	#TESTS1,R1	;POINT TO FIRST TEST
2$:	ASR	R0		;GET CODE BIT
	BCC	1$		;IF 0, GET NEXT BIT
	JMP	(R1)		;IF SET CALL TEST
1$:	BNE	9$		;IF R0 = 0 DONE
	RTS	R5
9$:	ADD	#TESTS2-TESTS1,R1	;POINT TO NEXT TEST
	BR	2$
TESTS1:	TST	OUTFIL		;R0 = 1 BIT FOR NO OUTFIL
	BEQ	9$
	BR	TESTE1
TESTS2:	TST	OUTDEV		;R0 = 2 BIT FOR NO OUTDEVICE
	BEQ	9$
	BR	TESTE1
3$:	TST	INFILE		;R0 = 4 BIT - NO INFILE
	BEQ	9$
	BR	TESTE1
4$:	TST	INSTA		;R0 = 10 BIT - INPUT DEVICE MUST BE BLOCK REPLACEABLE
	BMI	9$
	BR	TESTE2
5$:	TST	OUTSTA		;R0 = 20 BIT - OUTPUT DEVICE MUST BE
	BMI	9$		;BLOCK REPLACEABLE
	BR	TESTE2
6$:	TST	INDEV		;R0 = 40 BIT - AN INPUT DEVICE MSUT BE PRESENT.
	BNE	9$
	BR	TESTE1
7$:	TST	INFILE		;INPUT FILE MUST BE PRESENT
	BNE	9$		;R0 = 100
	BR	TESTE3
10$:	TST	OUTFIL		;TEST FOR OUTPUT FILE.
	BNE	9$		;R0=200
	BR	TESTE3
8$:	CLR	TESTMC
	TST	INSTA		;R0 = 400 BIT - INPUT DEVICE MUST BE FILE STRUCTURED.
	BMI	9$		;EITHER BLOCK REPLACEABLE
	INC	TESTMC
	BIT	#10000,INSTA	;OR FILE STRUCTURED.
	BNE	9$
	BR	TESTE2		;DEVICE NOT FILE STRUCTURED
TESTE1:	JMP	CERMES		;COMMAND ERROR MESSAGE
TESTE2:	JMP	ILDMES		;DEVICE NOT RANDOM ACCESS
TESTE3:	JMP	FNFMES		;FILE NOT FOUND.
TESTMC:	0			;= 0 IF BLOCK REPLACEABLE, 1 IF MT OR CT.

	.DSABL	LSB

; SWTST TESTS FOR VALID SWITCHES.  IF AN INVALID
; SWITCH IS FOUND AN ERROR
; MESSAGE IS GIVEN.  TO CALL
;	JSR	R5,SWTST
;	.WORD	IVAL
; SET BIT FOR ALL INVALID SWITCHES
; REFER TO  SWITS FOR ALL SWITCH INFORMATION.
;
SWTST:	MOV	(R5)+,R0	;GET INVALID SWITCHES
	MOV	#SWITS+2,R1	;R1 POINTS AS SWITCH TABLE.
1$:	CLC
	ROR	R0		;GET BIT OF INVALID SWITCH
	BCC	3$		;BRANCH IF NOT SET
	TSTB	(R1)		;THIS SWITCH IS NOT ALLOWED
	BMI	3$		;SHOULD BE EQUAL TO -1.
2$:	JMP	ISWMES
3$:	ADD	#3,R1
	TST	R0
	BNE	1$
	RTS	R5
.ENDC
.IF EQ M$DUP


; CONVRT WILL CONVERT A WORD TO AN OCTAL NUMBER
; IN ASCII AND STORE IT INDIRECT R5
; THE NUMBER IS INPUT VIA R0 AND THE ASCII NUMBER
; IS OUTPUT (R5)+ A BYTE AT A TIME.  LEADING ZEROS ARE OUTPUT
; AS SPACES AND THERE AR NO TRAILING SPACES.
; R0-R4 ARE PRESERVED, R5 POINTS TO THE BYTE LOCATION AFTER THE LAST CHARACTER.
; A TOTAL OF 6 CHARACTERS ARE OUTPUT.

CONVRT:	JSR	PC,SAVREG	;SAVE REGISTERS
	CLR	R3		;R3 IS THE NUMBER OUTPUT FLAG.
	MOV	#6,R2		;SET COUNT TO 6 CHARACTERS, BIT 15 AND 5 SETS OF 3 BITS
	CLR	R1		;CLEAR C AND NUMBER REG.
	CLC
	ROL	R0		;GET BIT 15
	ROL	R1
	BR	1$		;OUTPUT A 1 OR NOTHING
3$:	CLR	R1		;CLEAR C AND NUMBER REG.
	CLC
	ROL	R0		;GET NXT 3 HIGHEST BITS
	ROL	R1
	ROL	R0
	ROL	R1
	ROL	R0
	ROL	R1
1$:	BNE	2$		;OUTPUT IF NON ZERO
	TST	R3		;TEST IF ANUMBER OUT YET
	BNE	2$		;YES, OUTPUT A ZERO
	MOV	#40,R1		;NO, OUTPUT A SPACE
	BR	4$
2$:	INC	R3		;SET NUMBER OUT FLAG
	ADD	#60,R1		;CONVERT TO ASCII
4$:	MOVB	R1,(R5)+	;OUTPUT VIA R5
	DEC	R2		;TEST IF DONE
	BNE	3$
	CMP	#40,R1		;WAS ALL OUTPUT SPACES?
	BNE	5$		;NO
	DEC	R5		;YES,MUST BE A ZERO.
	MOVB	#60,(R5)+	;OUTPUT A ZERO.
5$:	MOV	R5,(SP)		;RETURN R5 TO CALLER
	JSR	PC,RSTREG
	RTS	PC
.ENDC

; MKFILE WILL GENERATE A FILE ENTRY IN THE DIRECTORY
; CALL VIA JSR PC,MKFILE WITH R5 POINTING TO THE NEW STATUS
; WORD OF THE DIRECTORY ENTRY, R1 CONTAINING THE ADDRESS OF THE RAD50 FILE NAME,
; R0 CONTAINING THE SIZE OF THE FILE.
; R1 AND R5 POINT TO THE WORD FOLLOWING THE FILE NAME AND DIRECTORY ENTRY DATE
; R0 IS DESTROYED, R2, R3, R4 ARE NOT USED.
MKFILE:	MOV	#DIRPER,(R5)+	;STORE THE DIR ENTRY "PERMANENT" CODE
	MOV	(R1)+,(R5)+	;STORE THE FILE NAME
	MOV	(R1)+,(R5)+
	MOV	(R1)+,(R5)+
	MOV	R0,(R5)+	;STORE THE FILE SIZE
	TST	(R5)+		;SKIP JOB#/CHAN#
	.DATE
	MOV	R0,(R5)+	;STORE THE DATE.
	ADD	DIRXBY,R5	;ADD EXTRA DIR. BYTES.
	RTS	PC

; READ/WRITE ROUTINES - WILL DO READ/WRITE REQUEST.
; AND THE ROUTINE CALLED VIA JSR  PC,READ0/WRITE1.  ON RETURN THE CARRY BIT
; IS SET FOR AN ERROR OF ACCESSING THE END OF FILE.
; READS ARE DONE ON CHANNEL 0.
; WRITES ARE DONE ON CHANNEL 1.
; ON ENTRY BLOCK, BUFFER AND SIZE MUST BE SET.
; R0 = THE NUMBER OF WORDS WRITTEN OR READ.
; R1-R5 ARE UNCHANGED
;
.ENABL	LSB
WRIT1:	MOV	#OUTCHN,R0	;POINT TO TABLE
	EMT	375		;DO I/O
	BCC	2$		;TEST FOR ERROR
	JMP	EWUMES
2$:	RTS	PC

				;ENTRY TO WRITE 1 BLOCK FROM BLKOUB.
WRITS1:	MOV	#256.,OUTSIZ	;SET WORD COUNT TO 256.

	MOV	BLKOUB,OUTBUF	;SET BUFFER TO BLKOUB
	BR	WRIT1

WRITE1:	MOV	#OUTCHN,R0
	EMT	375
	RTS	PC
READB0:	MOV	R0,INBLK	;STANDARD READ INTO BLKINB
	MOV	#256.,INSIZ
	MOV	BLKINB,INBUF
READ0:	MOV	#INCHN,R0	;SAME AS ABOVE.
	EMT	375
	BCC	2$
	JMP	ERUMES
READE0:	MOV	#INCHN,R0
	EMT	375
	RTS	PC
.DSABL	LSB

; OUTCHN, INCHN, OUTTYP, INTTYP ARE CONSTANTS
; BLOCK, BUFFER AND SIZE ARE VARIABLE
OUTCHN:	.BYTE	1		;CHANNEL 1 FOR OUTPUT
	.BYTE	11
OUTBLK:	0			;DISK BLOCK ADDRESS
OUTBUF:	0			;CORE BUFFER ADDRESS
OUTSIZ:	0			;BUFFER SIZE IN WORDS
OUTTYP:	0			;WRITE WAIT
INCHN:	.BYTE	0		;INPUT CHANNEL IS 0
	.BYTE	10
INBLK:	0			;DISK BLOCK TO READ FROM
INBUF:	0			;CORE BUFFER TO READ INTO
INSIZ:	0			;SIZE OF BUFFER IN WORDS
INTYPE:	0			; READ WAIT.

; GETDIR, RDIR, PUTDIR, WDIR
; THESE ROUTINES WILL READ OR WRITE A DIRECTORY SEGMENT.
; GETDIR AND RDIR READS A DIRECTORY SEGMENT ON CHANNEL 0
; GETODR READS A DIRECTORY SEGMENT ON CHANNEL 1.
; JSR  R5,RDIR WITH R0 = SEGMENT NUMBER ;WHERE 1 IS THE FIRST SEGMENT
; RDIR READ INTO DIRINB.
;	JSR	R5,GETDIR
;	ADDRESS OF BUFFER POINTER 
; THE BUFFER POINTER CONTAINS THE ADDRESS OF THE BUFFER
; R0 CONTAINS THE SEGMENT TO READ.
;
; PUTDIR AND WDIR WRITES A DIRECTORY SEGMENT ON CHANNEL 1
; JSR R5,WDIR WITH R0 = SEGMENT NUMBER ; 1 IS THE FIRST SEGMENT
; WDIR WRITES FROM DIROUB.
;	JSR	R5,PUTDIR
;	ADDRESS OF BUFFER POINTER
; THE BUFFER POINTER CONTAINS THE ADDRESS OF THE BUFFER.
; R0 CONTAINS THE SEGMENT TO WRITE
; R0 IS DESTROYED, R1-R5 ARE RESTORED.
	.ENABL	LSB
GETODR:	MOV	#4001,-(SP)	;STORE CHANNEL = 1, I/O = READ
	BR	GETDR1
GETDIR:	MOV	#4000,-(SP)	;STORE CHANNEL = 0, I/O = READ
GETDR1:	MOV	(R5)+,-(SP)	;GET ADDRESS OF LOCATION IN WHICH IS ADDRESS OF BUFFER
	MOV	@(SP)+,GPAREA+4	;STORE BUFFER ADDRESS FOR TRANSFER
	BR	1$
RDIR:	MOV	#4000,-(SP)	;STORE CHANNEL = 0, I/O = READ = 10
	MOV	DIRINB,GPAREA+4	;STORE BUFFER ADDRESS
1$:	MOV	(SP)+,GPAREA	;STORE CHANNEL ; I/O BYTES
	BR	3$
PUTDIR:	MOV	(R5)+,-(SP)	;SAME AS ABOVE
	MOV	@(SP)+,GPAREA+4
	BR	2$
WDIR:	MOV	DIROUB,GPAREA+4
2$:	MOV	#4401,GPAREA	;STORE CHANNEL = 1, I/O = WRITE = 11
3$:	ASL	R0		;CALCULATE BLOCK # FROM SEGMENT #, 2 BLOCKS
	ADD	#DIRSTR-2,R0	;PER SEGMENT, SEGMENT 1 STARTA AT DIRSTR
	MOV	R0,GPAREA+2	;BLOCK, STORE BLOCK #.
	MOV	#GPAREA,R0	;POINT R0 AS I/O AREA
	EMT	375		;I/O REQUEST
	BCS	4$		;BRANCH ON ERROR.
	RTS	R5		;RETURN
4$:	TSTB	IOCON		;TEST TO CONTINUE ON ERROR.
	BNE	6$		;YES IF SET.
	CMPB	#10,GPAREA+1	;TEST IF READ OR WRITE AND GIVE MESSAGE
	BEQ	5$
	JMP	EWDMES
5$:	JMP	ERDMES
6$:
.IF EQ M$DUP
	CMPB	#10,GPAREA+1	;TEST FOR READ OR WRITE.
	BEQ	7$		;READ
	JSR	R5,PRINTS	;WRITE;;PRINT MESSAGE
	MESEWD
	RTS	R5		;RETURN
7$:	JSR	R5,PRINTS	;PRINT MESSAGE
	MESERD
.ENDC
	RTS	R5		;RETURN
	.DSABL	LSB
GPAREA:	0			;BYTE 0 = CHANNEL = 0 FOR READ, = 1 FOR WRITE
				;BYTE 1 = READ = 10, WRITE = 11
	0			;BLOCK ON DISK
	0			;BUFFER ADDRESS
	512.			;WORD COUNT
	0			;READW/WRITW


; BSREAD, BSWRIT, BSRWI WILL DO REAL TIME I/O VIA READ, WRITE
; AND SPECIAL FUNCTION FOR THE RK06
; BSREAD AND BSWRIT ARE CALLED TO DO THE READ AND THE WRITE VIA
;	JSR	PC,BSREAD/BSWRIT    WITH
;		R1 = BLOCK #
; R0 IS DESTROYED AND R1-R5 RESTORED
;
; USES BUFFER BLKINB
BSREAD:	MOVB	#10,BSRWAC	;SET TO DO A READ.
BSWRIT:	MOV	#BSRWA+2,R0
	MOV	R1,(R0)+	;STORE BLOCK ADDRESS
	MOV	BLKINB,(R0)	;STORE BUFFER ADDRESS.
	MOV	#1,R0		;SET R0 1 FOR READ/WRITE I/O FUNCTION
	TST	BSRWSF		;TEST TO DO SPFUN REQUEST
	BEQ	2$		;BRANCH IF NO
	MOV	#-1,R0		;R0= 177777	;377/377
	CMPB	BSRWAC,#10	;TEST IF A READ
	BEQ	3$		;BRANCH IF YES
	MOV	#177377,R0	;SET R0 = 177377 = 376/377.
3$:	MOVB	#32,BSRWAC	;STORE SPFUN CODE
2$:	MOV	R0,BSRWAF	;STORE I/O FUNCTION
	MOV	#BSRWA,R0	;EXECUTE I/O
	EMT	375
	BCC	4$		;NO ERRORS
	JMP	NODMES		;DEVICE NOT PRESENT.
4$:	RTS	PC
BSRWA:	.BYTE	0		;CHANNEL =0.
BSRWAC:	.BYTE	0		;I/O CODE 10 = READ; 11 = WRITE, 32 SPFUN REQUEST
	.WORD	0		;DEVICE BLOCK #
	.WORD	0		;BUFFER
	.WORD	256.		;WORD COUNT
BSRWAF:	.WORD	0		;=1 IF I/O = READ OR WRITE
				;= 177777 = 377/377 FOR READ,
				; 177377 = 376/377 FOR WRITE IF SPFUN
	.WORD	1		;USED FOR SPFUN ONLY, FOR REAL TIME I/O
BSRWSF:	.WORD	0		;=1 FOR SPECIAL FUNCTION, OTHERWISE 0.

; SPREAD AND SPWRIT WILL DO A SPECIAL FUNCTION READ AND WRITE WAIT.
; THE ROUTINE IS CALLED VIA JSR PC,SPREAD OR SPWRIT.  WORDS SPBLK AND SPBUF
; MUST BE SET BEFORE THE CALL.
; R0-R5 ARE UNCHANGED
; READS ARE DONE ON CHANNEL 0
; WRITES ARE DONE ON CHANNEL 1
; SPIO IS AN ADDITIONAL ENTRY POINT SO THAT MAGTAPE I/O REQUESTS CAN BE DONE
; ON THIS ENTRY R0 CONTAINS THE COMMAND CODE TO BE DONE ON CHANNEL 0.
; ENTER SPIO AT SPIOC1 TO DO I/O ON CHANNEL 1 OR 0

	.ENABL	LSB
SPIO:	CLRB	SPRWBF		;SET TO DO I/O ON CHANNEL 0.
SPIOC1:	MOVB	R0,SPRWBF+11	;ENTRY TO SPFUN REQUEST OTHER THAN READ
				;AND WRITES FOR DISKS.
	CLR	SPBLK		;SET BLOCK #=0,NO EXTRA ERROR INFO FROM MT.
	BR	1$
SPREAD:	MOVB	#377,SPRWBF+11	;DO A READ ON CHANNEL 0
	CLRB	SPRWBF
	BR	1$
SPWRIT:	MOVB	#376,SPRWBF+11	;DO A WRITE ON CHANNEL 1
	MOVB	#1,SPRWBF
1$:	MOV	R0,-(SP)		;SAVE R0 AND THEN POINT IT AT THE I/O AREA
	MOV	#SPRWBF,R0
	EMT	375
	MOV	(SP)+,R0	;NOTE MOVE DOESNOT CHANGE THE C BIT
	RTS	PC		;RETURN WITH C BIT FOR CALLER
	.DSABL	LSB
SPRWBF:	.BYTE	0		;CHANNEL, 0 FOR READ, 1 FOR WRITE.
	.BYTE	32
SPBLK:	.WORD	0		;+2 = DEVICE BLOCK
SPBUF:	.WORD	0		;+4 = BUFFER
	.WORD	256.		;+6 = BUFFER SIZE
	.BYTE	377		;+10
	.BYTE	0		;+11 = 377 FOR A READ, 376 FOR A WRITE
	.WORD	0		;WAIT I/O
SETTPS:	MOV	BUFEND,R0	;STANDARD SETTOP.
SETTOP:	MOV	R0,-(SP)	;SAVE LOCATION OF TOP OF PROGRAM
	.SETTOP
				;LOCATION RETURNED IS THAT REQUESTED.
	CMP	R0,(SP)+	;TEST IF WE GOT REQUESTED CORE
	BNE	1$
	RTS	PC		;YES
1$:	JMP	NOCMES		;NO, NOT ENOUGH CORE.

; THIS ROUTINE WILL CONVERT THE RAD50 POINTED TO BY R0.
; INTO THREE BYTES OF ASCII, READY FOR INPUT TO .PRINT
; THE RESULTS ARE STORED IN DEVASC
; LEFT JUSTIFIED,FILLED WITH SPACES.
; THIS ROUTINE IS CALLED VIA JSR PC,DEVPRT
; RETURNS THE ASCII IN DEVASC
; RESTORES ALL REGISTERS
DEVPRT:	JSR	PC,SAVREG	;SAVE REGISTERS 0-5
				;RAD50 VALUE IN R0, NOT = 0
	MOV	#3,R2		;SET COUNT FOR THREE ASCII CHAR
	MOV	#DEVASC+3,R3	;WILL STORE THE ASCII BOTTOM  UP.
	MOV	(R0),R0		;GET RAD50 VALUE TO BE CONVERTED.
	BEQ	5$		;INPUT  A ZERO,ALL SPACES.
2$:	MOV	#50,R1		;DIVIDE RAD50 VALUE BY 50
	JSR	PC,DIV		;TO GET A CHAR AS THE REMAINDER
				;RAD50 = ((C1*50)+C2)*50+C3
				;DK: CONVERTS TO D=C1, K=C2, SPACE=C3
				;RK0: ; R=C1, 0=C3
				;R0 IS THE QUOTIENT, R1 IS THE REMAINDER
	TST	R1		;TEST REMAINDER FOR 0; RAD50 FOR SPACE
	BEQ	5$		;STORE SPACE
4$:	ADD	#100,R1		;CONVERT TO ASCII ;PP5-44 OF RT-11 REF MAN
	CMP	R1,#133		;TEST IF A LETTER
	BLT	3$
	ADD	#-100+11,R1
	CMP	R1,#44		;TEST IF $
	BEQ	3$
	ADD	#-11+22,R1	;CONVERT TO .THRU 9
3$:	MOVB	R1,-(R3)	;STORE IN DEVASC BOTTOM UP.
	DEC	R2		;COUNT NUMBER OF CHAR STORED
	BEQ	1$
	TST	R0		;TEST IF DONE DIVIDING, QUOTIENT = 0
	BNE	2$
5$:	MOV	#40,R1		;PAD WITH SPACES.
	BR	3$
1$:	JSR	PC,RSTREG
	RTS	PC
.IF EQ M$DUP

; FBRUN WILL TEST IF THE FOREGROUND JOB IS RUNNING
; AND PRINT A MESSAGE "BOTH JOBS ACTIVE, CONTINUE? <CRLF>"
; AND RETURN TO THE CALLER
; IF Y IS TYPED AND TERMINATE THE FUNCTION
; OTHERWISE
; IF THE OUTPUT DEVICE IS SY: THE MESSAGE
; MESFAS IS PRINTED AND THE FUNCTION IS NOT EXECUTED.
; ENTER AT FBRUNY TO WAIT FOR "YES" AND FBRUN
; TO JUST TYPE THE MESSAGE.
; R0 AND R1 ARE  DESTROYED
FBRUN:	CLR	FBRUN0
	BR	FBR1
FBRUNY:	MOV	#1,FBRUN0
FBR1:	TST	FBRUNF		;TEST IF MESSAGE PRINTED BEFORE
	BNE	1$		;EXIT IF YES
	MOV	@#SYSPTR,R0
	BIT	#USRRBT,CONFIG(R0)	;TEST IF USR RESIDENT.
	BEQ	2$
	INCB	USRRES		;SET FLAG IF SO.
				;TEST IF OUTDEVICE=SYS:
2$:	CMPB	SAVSTO+11,SYSUNT(R0)	;TEST IF SAME UNIT #.
	BNE	4$
	MOV	SAVSTO,R1	;GET DEVICE INDEX IN R1
	BIC	#177701,R1	;CLEAN OUT ALL BUT BITS 1-5=DEV. INDEX.
	CMP	R1,SYSIDX(R0)	;TEST IF SAME AS IS IN SYSTEM INDEX
	BNE	4$
	TSTB	SS+2		;TEST FOR /S, CANNOT /S IF IN INDIRECT FILE
	BMI	5$
	BIT	#IFACTV,STATWD(R0) ;TEST STATEWORD FOR INDIRECT FILE OPEN.
	BPL	5$
	JMP	IACMES		;ERROR
5$:	INCB	SYSFLG		;SET SY: FLAG
	TSTB	CONFIG(R0)	;TEST IF FJOB ACTIVE,BIT 7.
	BPL	1$		;BRANCH IF NO.
	TSTB	SO+2		;TEST FOR /O
	BPL	3$		;CONTINUE IF YES,ASK QUESTION.
	JMP	FACMES		;IF YES THEN INDEV=SYS, DON'T
				;DO ANTYING TO IT.
4$:	TSTB	CONFIG(R0)	;TEST IF FJOB ACTIVE.
	BPL	1$		;BRANCH IF NO.
3$:	TSTB	SY+2		;TEST IF /Y IS SET.
	BPL	1$		;BR IF SO.
	.PRINT	#MESFAT
	TST	FBRUN0		;TEST TO WAIT FOR "YES".
	BEQ	1$
	.PRINT	#MESCON		;PRINT CONTINUE?.
	JSR	PC,YESCHK	;WAIT FOR YES RETURN.
1$:	RTS	PC
FBRSY:	.RAD50	/SY/
FBRUN0:	0			;SET 1 TO WAIT FOR YES.
				;SET 0 NOT TO.
.ENDC

; MAKEMP WILL CREATE AN EMPTY DIRECTORY ELEMENT
; AND STORE IT INDIRECT R5.  THE EMPTY ELEMENT IS
; WORD 0 = 1000; BYTE 0=0, BYTE 1=2
; WORD 1,2,3=RANDOM DATA
; WORD 4=FILE SIZE IF EMPTY
; WORD 5,6=RANDOM DATA
; CALL MAKEMP VIA JSR PC,MAKEMP WITH
;	R0 = FILE SIZE
;	R5 = LOCATION TO STORE EMPTY
;	DIRSZ = SIZE OF A DIRECTORY ENTRY
; RETURN WITH R0-R4 UNCHANGED.
;	R5 = ADDRESS OF NEXT DIRECTORY ENTRY

MAKEMP:	MOV	#DIREMP,(R5)	;STORE EMPTY INDICATOR (1000) IN 1ST WORD OF ENTRY
	MOV	R0,10(R5)	;STORE EMPTY FILE SIZE
	ADD	DIRSZ,R5	;POINT TO NEXT DIRECTORY ENTRY
	RTS	PC
; ROUTINE TO DIVIDE THE CONTENTS OF R0 BY R1
; AND STORE THE QUOTIENT IN R0 AND THE REMAINDER
; IN R1, CALL VIA JSR PC,DIV

DIV:	MOV	#20,-(SP)	;SET LOOP COUNT
	MOV	R1,-(SP)	;SAVE DIVISOR FOR SUBTRACTS
	CLR	R1		;CLEAR REMAINDER
30$:	ASL	R0		;DOUBLE LEFT SHIFT
	ROL	R1		;
	CMP	R1,(SP)		;SUBTRACT OUT DIVISOR?
	BLO	40$		;IF LO NO
	SUB	(SP),R1		;SUBTRACT OUT DIVISOR
	INC	R0		;ADD IN LOW BIT
40$:	DEC	2(SP)		;DECREMENT REPEAT COUNT
	BGT	30$		;IF GT MORE TO GO
50$:	CMP	(SP)+,(SP)+	;CLEAN STACK
	RTS	PC


;ROUTINE TO STORE SPACES IN A BUFFER
;CALL WITH BUFFER ADDRESS IN R0

	.ENABL	LSB
BLANK1:	MOV	#256.,R1	;ENTER HERE TO STORE 256. WORDS
	BR	1$
BLANK2:	MOV	#512.,R1	;ENTER HERE TO STORE 512. WORDS.
1$:	MOV	#20040,(R0)+
	DEC	R1
	BNE	1$
	RTS	PC
	.DSABL	LSB

; SAVREG, SAVES THE PC FROM THE JSR, PC,SAVREG
; AND R0-R5 ON THE STACK AND RETURNS
; CALL VIA JST PC,SAVREG
SAVREG:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	JMP	@14(SP)

; RSTREG, RESTORES R0-R5 AND THE STACK FOR SAVREG
; CALL VIA JSR PC,RSTREG

RSTREG:	MOV	(SP)+,14(SP)	;SAVE THE RETURN ADDRESS OVER
	MOV	(SP)+,R5	;THE PC LEFT BY SAVREG
	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	PC

.IF EQ M$DUP
EWDMES:	MOV	#MESEWD,-(SP)
	BR	PRINT
CERMES:	MOV	#MESCER,-(SP)
	BR	PRINT
NOCMES:	MOV	#MESNOC,-(SP)
	BR	PRINT
ERDMES:	MOV	#MESERD,-(SP)
	BR	PRINT
ESAMES:	MOV	#MESESA,-(SP)
	BR	PRINT
DNZMES:	MOV	#MESDNZ,-(SP)
	BR	PRINT
DFUMES:	MOV	#MESDFU,-(SP)
	BR	PRINT
ERUMES:	MOV	#MESERU,-(SP)
	BR	PRINT
EWUMES:	MOV	#MESEWU,-(SP)
	BR	PRINT
DFLMES:	MOV	#MESDFL,-(SP)
	BR	PRINT
FACMES:	MOV	#MESFAC,-(SP)
	BR	PRINT
ILDMES:	MOV	#MESILD,-(SP)
	BR	PRINT
NODMES:	MOV	#MESNOD,-(SP)
	BR	PRINT
IDRMES:	MOV	#MESIDR,-(SP)
	BR	PRINT
FNEMES:	MOV	#MESFNE,-(SP)
	BR	PRINT
TMBMES:	MOV	#MESTMB,-(SP)
	BR	PRINT
ISWMES:	MOV	#MESISW,-(SP)
	BR	PRINT
IACMES:	MOV	#MESIAC,-(SP)
	BR	PRINT
UBBMES:	MOV	#MESUBB,-(SP)
	BR	PRINT
FNFMES:	MOV	#MESFNF,-(SP)
	BR	PRINT
DIUMES:	MOV	#MESDIU,-(SP)
	BR	PRINT
FEXMES:	MOV	#MESFEX,-(SP)
.IFF
SYSMES:	MOV	#MESSYS,-(SP)
	BR	PRINT
FNFMES:
DIUMES:
ILDMES:
ISWMES:
NOCMES:
NODMES:
CERMES:	MOV	#MESCER,-(SP)
	BR	PRINT
ERDMES:
ERUMES:	MOV	#MESERU,-(SP)
	BR	PRINT
DFUMES:
ESAMES:
EWDMES:
EWUMES:	MOV	#MESEWU,-(SP)
	BR	PRINT
TMBMES:
UBBMES:	MOV	#MESBBK,-(SP)

.ENDC
PRINT:	.PRINT	#MESF		;PRINT FATAL HEADER
	MOV	(SP)+,R0
	.PRINT			;THEN MESSAGE
	BISB	#SEVERR,@#USERRB	;SET ERROR BIT FOR DCLS EXIT.
	JMP	INIT
.IF EQ M$DUP
PRINTS:	.PRINT	#MESW		;PRINT WARNING HEADER
	MOV	(R5)+,R0
	.PRINT			;PRINT MESSAGE
	RTS	R5
.ENDC

; QUESTIONS

	.ENABL LC
.IF EQ M$DUP

MESARE:	.ASCII	' are you sure?'
	.BYTE	200
SLASHZ:	.ASCII	'/Init'
	.BYTE	200
SLASHI:	.ASCII	'/Copy'
	.BYTE	200
SLASHS:	.ASCII	'/Squeeze'
	.BYTE	200
SLASHU:	.ASCII	'/Vol id change'
	.BYTE	200
MESCON:	.ASCII	'continue?'
	.BYTE 200
MESFAT:	.ASCII	'Foreground job loaded,'
	.BYTE	200
	.EVEN
.ENDC
MESOWN:	.BYTE	15,12
	.ASCII	/ OWNER NAME/
	.BYTE	200
	.EVEN
MESVID:	.BYTE	15,12
	.ASCII	/ VOL ID/
	.BYTE	200
MESQUE:	.ASCII	/? /
	.BYTE	200

; VERSION NUMBER

.IF NE M$DUP
MESVER:	.ASCIZ	'MDUP V03.01  '
.IFF
MESVER:	.ASCIZ	'DUP V03.01  '
.ENDC


.IF EQ M$DUP
;ERROR MESSAGES

MESF:	.ASCII	'?DUP-F-'
	.BYTE	200
MESW:	.ASCII	'?DUP-W-'
	.BYTE	200
.IFF
MESF:	.ASCII	'?MDUP-F-'
	.BYTE	200
MESW:	.ASCII	'?MDUP-W-'
	.BYTE	200
.ENDC
.IF EQ M$DUP
REBOOT:	.BYTE	7	;BELL
	.ASCIZ	'Reboot'
MESEWD:	.ASCIZ	'Error writing directory'
.ENDC
MESBDB:	.ASCIZ	'Bad directory block'
MESCER:	.ASCIZ	'Illegal command'
.IF EQ M$DUP
MESNOC:	.ASCIZ	'Insufficient memory'
MESERD:	.ASCIZ	'Error reading directory'
MESESA:	.ASCIZ	'Error in system area'
MESDNZ:	.ASCIZ	'Directory not zeroed'
MESDFU:	.ASCIZ	'Device full'
.ENDC
MESERU:	.ASCIZ	'Read error'
MESEWU:	.ASCIZ	'Write error'
.IF EQ M$DUP
MESDFL:	.ASCIZ	'Directory full'
MESFAC:	.ASCIZ	/Cannot write SY: while FG loaded/
MESILD:	.ASCIZ	'Illegal device'
MESNOD:	.ASCIZ	'Device not active'
MESIDR:	.ASCIZ	'Illegal directory'
MESFNE:	.ASCIZ	'Illegal contiguous file'
MESTMB:	.ASCIZ	'Too many bad blocks'
MESISW:	.ASCIZ	'Illegal option'
MESIAC:	.ASCIZ	'Cannot /s sy: if indirect file open'
MESUBB:	.ASCIZ	'Unmarked bad block'
MESFNF:	.ASCIZ	'File not found'
MESDIU:	.ASCIZ	'Device in use'
MESNVI:	.ASCIZ	'No RT-11 vol id'
MESFEX:	.ASCIZ	'File exists'
MESDKW:	.ASCIZ	'Output is the default device'
MESCRL:	.BYTE	15,12,200
.IFF
MESBBK:	.ASCIZ	'Bad blocks'
MESSYS:	.ASCIZ	'System error'
.ENDC
	.EVEN
	.DSABL LC

SWITS:				;SWITCH INDICATOR LIST.THE FIRST
				;TWO BYTES NEVER CHANGE
				;THE LAST BYTE IS -1 IF SWITCH
				;IS NOT ACTIVE ; =0 IS ACTIVE
				;=1 IF ACTIVE WITH 1 VALUE
				;AND =2 IF ACTIVE WITH 2 VALUES.
SZ:	.BYTE 'Z,1,-1		;SWITCH #1
SN:	.BYTE 'N,1,-1		;#2
SR:	.BYTE 'R,1,-1		;#4
SB:	.BYTE 'B,0,-1		;#10
SV:	.BYTE 'V,1,-1		;#20
SK:	.BYTE 'K,2,-1		;#40
SH:	.BYTE 'H,0,-1		;#100
SF:	.BYTE 'F,0,-1		;#200
SS:	.BYTE 'S,0,-1		;#400
SI:	.BYTE 'I,3,-1		;1000
SC:	.BYTE 'C,2,-1		;2000
ST:	.BYTE 'T,1,-1		;4000
SU:	.BYTE 'U,0,-1		;#10000
SO:	.BYTE 'O,0,-1		;#20000
SY:	.BYTE 'Y,0,-1		;#40000
SL:	.BYTE 'L,1,-1		;100000
	;END  SWTST TEST SWITCHES
SX:	.BYTE 'X,0,-1
SW:	.BYTE 'W,0,-1
SEND:	.BYTE 0
	.EVEN
SWITV:				;CONTAINS THE VALUE OF THE SWITCH
SZV:	.WORD	0		;INITIALIZE TO 0
SNV:	.WORD	0
SRV:	.WORD	0
SVV:	.WORD	0
SKV:	.WORD	0,0		;SKV ALWAYS FIRST VALUE, SKV+2 SECOND VALUE
SIV:	.WORD	0,0,0
SCV:	.WORD	0,0
STV:	.WORD	0
SLV:	.WORD	0
				;VALUES THAT NEED TO BE 0ED.
FBRUNF:	0
SYSFLG:	.BYTE	0		;SY: FLAG =1 IF /S ON SY:,ELSE 0.
USRRES:	.BYTE	0		;USR RESIDENT FLAG
				;=1 IF RESIDENT,ELSE 0.
IOCON:	.BYTE	0		;SET=1 TO CONTINUE ON DIR. I/O ERR.
OUTENT:	.BYTE	0		;SET=1 FOR AN OUTPUT ENTER.
ZEND:

ROUADD:				;STORE IN HERE A 0 FOR A NON ACTION SWITCH OR
	ZERO			;THE ADDRESS OF THE ROUTINE TO CAL IF AN ACTION SWITCH.
	0
	0
	0
.IF NE M$DUP
	0
	MDUP
	WMDUP

	.WORD	0,0,0,0,0
.IFF
	VOLUME
	SCAN
	0
	0
	SQUISH
	IMAGE
	CREATE
	EXTEND
.ENDC
	WBOOT
	BOOT
	0
	0
	0
	0

; COMMON DATA
BADFIL:	.RAD50	/  FILE/
	.RAD50	/BAD/
SEMPTY:	.RAD50	/EMPTY/
	.WORD	0
STENTA:	.RAD50	/TENTATIVE/
TTNAME:	.RAD50	/TT/
SYS:	.RAD50	/SYS/
VERR50:	.RAD50	/V3A/
DKNAM:	.RAD50	/DK/

; COMMON CONSTANTS
FREEM:	FREE		;START OF FREE MEMORY.
CONFGP:	0			;POINTER TO CONFIG WORD IN RMON.
USRBAS:	0			;POINTER TO OFF 266 IN RMON. NORMAL LOAD
				;ADDRESS OF USR.
BLKEYP:	0			;POINTER TO BLKEY IN RMON.

; COMMON VARIABLES
DIROBP:	0			;POINTER INTO DIRECTORY OUTPUT SEGMENT
DIRSZ:	0			;TOTAL SIZE OF A DIRECTORY ENTRY
DIRXBY:	0			;NUMBER OF EXTRA BYTES IN THE DIRECTORY
DIRIBP:	0			;POINTER INTO THE DIRECTORY INPUT SEGMENT
SEGMNT:	0			;CURRENT SEGMENT # IN USE
DEVASC:	.BYTE	0,0,0,':,200	;ASCII BYTES OF DEVICE NAME TO BE PRINTED BY .PRINT.
	.EVEN

				;***********BUFFER STORAGE MUST BE IN BELOW
				;************ORDER***************
BUFSTA:	0			;START OF FREE SPACE AFTER HANDLERS ARE LOADED.
DIROUB	= BUFSTA		;DIRECTORY OUTPUT BUFFER=BUFSTAR
DIRINB:	0			;DIRECTORY INPUT BUFFER=BUFSTAR+512.
BLKOUB:	0			;BLOCK OUT BUFFER
BLKINB:	0			;BLOCK IN BUFFER ;257. WORDS LONG
BUFEND:	0			;END OF BUFFERS,LAST WORD OF BUFFERS.


FREE:	0
	.END	BEGIN
                                                                                                                                                                                                                          