	TITLE	CREF

;ACCUMULATOR DEFINITIONS
AC0=0
TEMP=1
TEMP1=2
WPL=3	;CONTAINS COUNT OF HOW MANY REFERENCES/LINE IN LISTING
RC=WPL
SX=4
BYTEX=5
BYTEM=6
TX=BYTEM
C=7
CS=10
LINE=11	;HOLDS LINE #
FLAG=12
FREE=13	;POINTS TO HIGH END OF INCREMENT BYTE TABLE
SYMBOL=14	;POINTS TO ENTRY COUNT AT LOW END OF SYMBOL TABLE
TOP=15	;CONTAINS HIGHEST AVAILABLE ADR IN MEMORY
IO=16	;HOLDS FLAGS
PP=17	;PUSH DOWN POINTER

;DEFINITIONS FOR LENGTHS OF LINES AND PAGES
WPLLPT==14.	;IN OUTPUT LPT LISTING, 14 REFERENCES/LINE
WPLTTY==8	;IN OUTPUT TTY LISTING, 8 REFERENCES/LINE
.LPP==53.	;LINES PER PAGE IN LISTING
PDL==30		;PUSH DOWN STACK LENGTH
LSTBSZ==100	;LST BUFFER SIZE.
INBSZ==100	;INPUT BUFFER SIZE.
TTIBSZ==20	;COMMAND BUFFER SIZE.

ORM= IORM
SAVE=PUSH PP,
REST=POP PP,
CALL=PUSHJ PP,
RET= POPJ PP,

DEFINE	POINT	A,B,C
B+<A!._30>+<44-IRPS X,,C
<X!.+1>TERMIN >_36 TERMIN
;BIT DEFINITIONS FOR FLAGS IN ACCUMULATOR "IO"
IOLST==	000001	;IF 1, SUPPRESS PROGRAM LISTING
IONCRF==000002	;1 IF COMMAND STRING SEARCH LIMITS BEING USED
IOPAGE==000004	;IF 1, DO A FORM FEED
IOFAIL==000010	;1 IF "NEW STYLE" CREF DATA HAS BBEN SEEN
IODEF==	000020	;1 IF SYMBOL IS A DEFINING OCCURRANCE
IOENDL==000040
IORPG==	000100	;1 IF RPG SYSTEM IN USE (SET BY STARTING AT (JOBSA)+1)
IOTABS==000200	;"RUBOUT A" SEEN AT AND OF CREF DATA (INSERT TAB IN LISTING)
IOEOF==	000400	;END OF FILE SEEN
IOCONC==001000	;CREF ALL INPUT FILES TOGETHER.
IOTB2==	002000	;FOR F4
IOTTY==	004000	;1 IF LISTING DEVICE IS TTY
IOERR==	010000	;IMPROPER INPUT DATA SEEN
IODF2==	020000	;DEFINING OCCURRANCE OF A SYMBOL
IOSYM==	040000	;SYMBOL DEFINED WITH = OR :
IOMAC==	100000	;MACRO NAME
IOOP==	200000	;OPDEF, OP CODE, OR PSEUDO INSTRUCTM OCCURRANCE
IOPROT==400000	;1 IF INPUT 'CRF' OR 'LST' FILE IS PROTECTED
		;BY /P SWITCH

;DEFINITIONS FOR "OLD STYLE" CODES FROM VARIOUS PROCESSORS
%OP==33
%EOF==37	;MULTIPLE-PROGRAM BREAK CHARACTER

TTI==1		;CONTROL DEVICE NUMBER (INPUT)
INC==2		;INPUT DEVICE NUMBER
LST==3		;LISTING DEVICE NUMBER
TTO==4		;TTY OUTPUT.
ERRC==5

LOC 43
JOBREL:	JOBFFJ
MSNAME:	0		;SAVE INITIAL SNAME.

STCLR:		;START BLT CLEAR HERE

INCNT:	0
INPNT:	0
INBUF:	BLOCK	INBSZ

LSTCNT:	0
LSTPNT:	0
LSTBUF:	BLOCK	LSTBSZ

TTICNT:	0		;NUM CMD CHARS UNREAD.
TTIPNT:	0
TTIBUF:	BLOCK	TTIBSZ	;COMMAND BUFFER.

LSTDEV:	0		;LST DEVICE.
LSTFN1:	0
LSTFN2:	0
LSTSNM:	0

INDEV:	0		;RFILN PUTS NAMES IN HERE.
INFN1:	0
INFN2:	0
INSNM:	0

IODFLT:	0		;DEFAULT SWITCHES.
LOWLIS:	0		;DEFAULT LOWER LIM.
UPPLIS:	0		;DEFAULT UPPEER LIM.

CTLCF:	0		;IF SET, KILL SELF WHEN FINISH CMD.
SRCTTY:	0
RFILC:	0
INFNUM:	0		;SET IF NAME REALLY WAS INPUT FILE'S.

PPSAV:	BLOCK	1	;SAVE PP FOR RESTORING IN CASE OF "IMPROPER INPUT DATA"
PPSET:	BLOCK	PDL
CMDSAV:	BLOCK	20	;SAVE AC'S DURING COMMAND SCANNING
LPP:	BLOCK	1

PPTEMP:	BLOCK	1
FIRSTL:	BLOCK 1	;LINE # AFTER WHICH TO PRINT LISTING

SRCMSB:	BLOCK	1	;MOST SIGNIFICANT BIT (USED BY SRCH)
SRCMID:	BLOCK	1	;ADR IN MIDDLE OF SYM TABLE (USED BY SRCH)

LOWLIM:	BLOCK	1
UPPLIM:	BLOCK	1
LEVEL:	BLOCK 1
SVLAB:	BLOCK 1
BLKST:	BLOCK 1
BLKND:	BLOCK 1

ENDCLR=	.-1

PAT:	PATCH:	BLOCK	100
CREF:	SETZ	IO,
	.OPEN	TTI,[SIXBIT/   TTY/]
	.VALUE
	.OPEN	TTO,[SIXBIT/  !TTY/]
	.VALUE
	MOVE	PP,[-PDL,,1+PPSET]
	SKIPN 	MSNAME
	.SUSET	[.RSNAM,,MSNAME]	;GET INITIAL SNAME.
	.BREAK	12,[5,,TTIBUF]
	SKIPE	TTIBUF		;UNLESS HAVE :JCL STRING,
	JRST	RESTRT
	MOVE	0,[SIXBIT/CREF/]
	CALL	TTOSIX		;IDENTIFY SELF.
	.IOT	TTO,[" ]
	MOVE	0,[.FNAM2]
	CALL	TTOSIX

RESTRT:	.LOGOUT			;DISOWNED, NO MORE CMDS, SUICIDE.
	SKIPE	CTLCF		;IF USER TYPED ^C, DELETE SELF.
	.BREAK	16,140000
	MOVSI	IO,IOPAGE+IOSYM+IOMAC	;INITIALIZE FLAGS.
	SETZM	STCLR
	MOVE	0,[STCLR,,STCLR+1]
	BLT	0,ENDCLR		;CLEAR OUT VARIABLE AREA

	MOVE	PP,[-PDL,,1+PPSET]	;INIT PUSH DOWN LIST POINTER
	HLLOS	UPPLIM

	SETZ	TEMP,
	.BREAK	12,[5,,TTIBUF]
	SKIPN	TTIBUF		;IF HAVE :JCL STRING,
	JRST	RESTR0
	MOVE	CS,[440700,,TTIBUF]
	MOVEM	CS,TTIPNT	;READ FROM IT.
	ILDB	C,CS
	CAIE	C,^M
	AOJA	TEMP,.-2	;COUNT THE CHARS.
	MOVEM	TEMP,TTICNT
	SETOM	CTLCF		;EXIT AFTER CMD.
	CAIA
RESTR0:	CALL	TTILIN		;READ COMMAND.
;READ IN THE 1ST FILSPEC.
;IF FOLLOWED BY ARROW, SET LST SPEC FROM IT,
;ELSE REMEMBER IT AS 1ST INPUT FILE.
;IF LST FILSPEC GIVEN, SET DEFAULT FLAGS FROM IT.

LSTSET:	CALL	LSTSE1		;SET UP DEFAULT DEFAULTS.
	PUSHJ	PP,RFILE	;READ 1ST NAME.
	SETZM	LSTDEV		;ZERO OUT LST FILE SO DEFAULTS WILL WORK.
î	MOVE	CS,[LSTDEV,,LSTFN1]
	CAIN	C,"_		;IF NAME WAS LISTING'S,
	SKIPA	CS,[INDEV,,LSTDEV]	;USE IT.
	SETOM	INFNUM		;ELSE 1ST INPUT NAME ALREADY READ.
	BLT	CS,LSTSNM
	MOVEI	CS,(SIXBIT/TPL/)	;DEFAULT DEV IS TPL IF NO NAMES,
	SKIPN	LSTFN1		;BUT IF FILENAMES GIVEN,
	SKIPE	LSTFN2
	MOVEI	CS,(SIXBIT/DSK/)	;DEFAULT IS DSK.
	SKIPN	LSTDEV
	MOVEM	CS,LSTDEV
	MOVE	CS,MSNAME	;DEFAULT SNAME.
	SKIPN	LSTSNM
	MOVEM	CS,LSTSNM
	MOVE	CS,[SIXBIT/LIST/]
	SKIPN	LSTFN2		;DEFAULT FN2 IS LIST.
	MOVEM	CS,LSTFN2
	MOVEI	CS,7		;SET UP MODE FOR OPEN.
	HRLM	CS,LSTDEV
	SETOM	LSTCNT		;CAUSE INSET TO OPEN LST.
	SKIPE	INFNUM		;IF LST SPEC GIVEN,
	JRST	INSET
	CALL	LSTSE1		;SET DEFAULT SWITCHES FROM LST'S.
	SETZM	INDEV		;RE-DEFAULT 1ST INPUT FILE'S
	SETZM	INSNM		;DEV, SNAME.
	JRST	INSET

LSTSE1:	HLRZ	CS,IO		;SAVE SWITCHES IN IT AS DEFAULT.
	ANDI	CS,IOMAC+IOLST+IOOP+IOSYM+IOPROT
	MOVEM	CS,IODFLT
	MOVE	CS,LOWLIM	;USE ITS LOWLIM, UPPLIM
	MOVEM	CS,LOWLIS	;AS DEFAULTS.
	MOVE	CS,UPPLIM
	MOVEM	CS,UPPLIS
	RET
;READ IN NEXT INPUT SPEC UNLESS WAS READ ALREADY.
;OPEN INPUT, THEN OPEN LST UNLESS STILL OPEN.
;COME BACK HERE FOR EACH INPUT FILE IF CREFFING SEPARATELY.

INSET:	AOSN	INFNUM
	JRST	INSET1		;SKIP THESE IF NAME ALREADY READ.
	TLZ	IO,IOMAC+IOSYM+IOOP+IOLST+IOPROT
	TLO	IO,@IODFLT	;SET UP DEFAULT SWITCHES.
	CALL	RFILE		;READ FILE NAME, INDIVIDUAL SWITCHES.

INSET1:	CALL	INFILE		;OPEN THIS INPUT FILE.

	SKIPL	LSTCNT		;IF LST NOT OPEN, OPEN IT.
	JRST	LSTSE7
	SAVE	LSTFN1		;IF NO FN1 SPECIFIED,
	MOVE	CS,INFN1	;USE SAME AS INPUT.
	SKIPN	LSTFN1
	MOVEM	CS,LSTFN1
	.SUSET	[.SSNAM,,LSTSNM]
	.OPEN	LST,LSTDEV
	CALL	OPENLL
	.STATUS	LST,CS
	ANDI	CS,77		;SEE IF LST IS A TTY.
	TLZ	IO,IOTTY
	CAIGE	CS,3
	TLO	IO,IOTTY
	REST	LSTFN1		;IN CASE WAS 0.
	MOVEI	CS,1+5*LSTBSZ
	MOVEM	CS,LSTCNT	;SET UP BUFFERING.
	MOVE	CS,[POINT 7,LSTBUF,,]
	MOVEM	CS,LSTPNT

LSTSE7:
	MOVEI FREE,BLKST-1	;SET UP THINGS FOR COMBG
	MOVEM FREE,BLKND

RECYCL:	TLO	IO,IOENDL	;FORCE TAB ON 1ST LINE.
	HRRZI	FREE,JOBFFI	;RETURN FOR MULTIPLE F4 PROGS
	ADDI	FREE,1
	TRZ	FREE,1		;SET UP BYTE TABLE ON EVEN ADR

	.CORE	1+JOBFFJ_-10.	;SHRINK CORE TO DEFAULT.
	.VALUE
	MOVEI	C,JOBFFJ
	MOVEM	C,JOBREL
	SOS	TOP,C		;ALLOW 1 WORD SLOP
	SUBI	C,LENGTH	;MOVE AN INITIAL VESTIGIAL SYMBOL TABLE TO HIGH MEMORY
	MOVE	SYMBOL,C
	HRLI	C,SYMNUM
	BLT	C,0(TOP)	;MOVE THE 5 WORDS STARTING AT SYMNUM BELOW
	PUSHJ	PP,SRCHI

	MOVEM	PP,PPSAV	;SAVE PP IN ORDER TO RECOVER FROM
				;IMPROPER INPUT DATA

	MOVEI	LINE,1	;INITIALIZE LINE COUNTER
	PUSHJ PP,READ	;TEST FIRST CHARACTER
	CAIE C,%EOF	;PROGRAM BREAK?
	JRST M2A	;NO, PROCESS
	JRST M2		;YES, BYPASS

;THIS IS AN INITIAL VESTIGIAL SYMBOL TABLE - IT MAKES INITIALIZATION
;OF THE SYMBOL TABLE SEARCH EASY

SYMNUM:	LENGTH/2	;COUNT OF INITIAL ENTRIES IN SYMBOL TABLE
	400000,,		;MOST NEGATIVE POSSIBLE SYMBOL
	-1			;GARBAGE VALUE FOR MOST NEG. SYMBOL
	377777,,-1		;MOST POSITIVE POSSIBLE SYMBOL
	-1			;GARBAGE VALUE FOR MOST POS. SYMBOL
LENGTH=	.-SYMNUM
îM1:	TLNN	IO,IOLST	;IS PROGRAM LISTING SUPPRESSED?
	PUSHJ	PP,WRITE	;NO, OUTPUT CHARACTER
M2:	PUSHJ	PP,READ		;GET NEXT CHARACTER
M2A:	CAIN C,177		;RUBOUT?
	JRST FAILM		;ALL "NEW STYLE" CREF DATA BEGINS WITH RUBOUT
	CAIE C,^L
	CAIN C,^J		;LF, FF NEVER FORCE TABS OUT.
	JRST M1			;CR MAKES NEXT NON-CRLFFF FORCE TAB
	CAIN C,^M		;UNLESS LINE-NUM PRINTED BEFORE IT.
	JRST FCKLF
	CAIG C,%EOF		;IS CHAR IN RANGE OF "OLD STYLE" CREF CONTROL CHARS.?
	CAIGE C,%OP
	SKIPA			;NO
	JRST M2C		;YES
	TLZE IO,IOENDL
	TLNE IO,IOLST
	JRST M1
	PUSH PP,C
	MOVEI C,11
	PUSHJ PP,WRITE
	POP PP,C
	JRST M1

M2C:	TLNE IO,IOFAIL		;IF "NEW STYLE" DATA SEEN (IOFAIL=1),IGNORE OLD
	JRST M1			;IGNORE "OLD STYLE" CREF DATA
	XCT	MTAB-%OP(C)	;DO SOMETHING (USUALLY SET BITS) WITH CONTROL CHAR
	JRST	M3		;BITS WERE SET (EITHER IOOP,IOMAC, OR IOSYM)

	TLZ IO,IOENDL
	TLO IO,IOTB2

M2B:	TLNN	IO,IOLST
	PUSHJ	PP,CNVRT	;IF MAKING LISTING, CONVERT (LINE) TO TEXT
	TLNN IO,IOTABS
	JRST M2B1
	MOVEI C,11
	TLNN IO,IOLST
	PUSHJ PP,WRITE
M2B1:	AOJA	LINE,M2		;INDEX LINE NUMBER AND START ON NEXT LINE

M3:	MOVEI	AC0,0	;INIT RADIX 50 SYMBOL
M4:	PUSHJ	PP,READ	;GET NEXT CHAR FOR SYMBOL
	CAIL	C,"$
	CAILE	C,"Z
	JRST	M5A		;CHAR NOT IN RADIX 50 SET
	HLRZ	C,CSTAT-" (C)	;GET RADIX 50 CODE FOR CHAR
	JUMPE	C,M5A		;CHAR NOT IN RADIX 50 SET
	IMULI	AC0,50		;BUILD SYMBOL AND LOOP
	ADD	AC0,C
	JRST	M4

M5A:	CAIN	C,"		;SYMBOL FOLLOWED BY ALT. BEING DEFINED.
	TLO	IO,IODEF
	PUSHJ PP,M5		;LEFT JUSTIFY SYMBOL AND STORE IN DATA TABLES
	JRST M2

	IMULI	AC0,50
M5:	CAMG	AC0,[<SQUOZE 0,%%%%%>/50 ]
	JUMPN	AC0,.-2		;MULTIPLY BY 50 UNTIL LEFT JUSTIFIED
	JUMPN	AC0,M6		;SYMBOL GOOD IF NOT ZERO, SAVE IN TABLES
ERROR:	MOVE	PP,PPSAV	;RESTORE PP
	TLOE	IO,IOERR	;SET FLAG, SKIP MESSAGE IF DONE BEFORE
	JRST	M2		;TRY TO CONTINUE
	MOVEI	RC,[SIXBIT /IMPROPER INPUT DATA, CONTINUING@/]
	PUSHJ	PP,PNTMSG	;PRINT MESSAGE
	PUSHJ	PP,CRLF		;CARRIAGE RETURN-LINE FEED
	JRST	M2		;ATTEMPT TO RESTART LISTING

M6:	TDNE	IO,SX		;IS THIS TYPE OF SYMBOL BEING CROSS REFERENCED?
	TLNE	IO,IONCRF
CPOPJ:	RET
	IOR	AC0,SX		;PUT SYMBOL TYPE BITS INTO SYMBOL

	CAML	LINE,LOWLIM	;IS THIS LINE INSIDE THE COMMAND STRING RANGE REQUEST?
	CAMLE	LINE,UPPLIM
	TDZA	FLAG,FLAG	;NO
	MOVSI	FLAG,400000	;YES, SET FLAG TO STORE IN DATA TABLES
	JRST	SRCH		;STORE SYMBOL, SYM TYPE, AND RANGE FLAG IN TABLES

;THIS TABLE'S ENTRIES ARE EXECUTED FROM M2C+4

MTAB:	MOVSI	SX,IOOP		;CODE TYPE IS OP CODE, OPDEF,PSEUDO INSTRUCTION 
	MOVSI	SX,IOMAC	;MACRO NAME
	SKIPA	C,LINE
	MOVSI	SX,IOSYM	;NORMAL SYMBOL (DEFINED WITH = OR :)
	JRST R0			;BREAK BETWEEN PROGRAMS

FCKLF:	TLO IO,IOENDL
	JRST M1
îR0:	TLO IO,IOPAGE
	SETZM FIRSTL		;FOR TABLES, EVERYTHING GETS LISTED
	PUSH PP,SYMBOL
	SKIPE BYTEX,BLKST	;CHECK FOR FAIL BLOCK STRUCTURE
	PUSHJ PP,BLKPRN
	SOS	SX,0(SYMBOL)
	MOVSI	FLAG,IOSYM
R1:	PUSHJ	PP,LINOUT
R1B:	SOJE	SX,FINIS
	ADDI	SYMBOL,2
	SKIPL	2(SYMBOL)
	JRST	R1B
	MOVE	C,1(SYMBOL)
	HRRZ	BYTEX,2(SYMBOL)
	ADDI BYTEX,1
	HRLI	BYTEX,(POINT 6,0,5,)
	MOVE	BYTEM,-1(BYTEX)

R1A:	TDZE	C,FLAG
	JRST	R2
	TLO	IO,IOPAGE
	LSH	FLAG,1
	JUMPN	FLAG,R1A

R2:	PUSHJ	PP,R50ASC
	MOVEI	LINE,0

R3:	PUSHJ	PP,GETVAL
	JRST	R1
	PUSHJ	PP,CNVRT
	JRST	R3

;SUBROUTINE TO CONVERT LINE NUMBERS TO ASCII TEXT
CNVRT:	MOVEI	TEMP,6	;OUTPUT SPACES FOR LEADING ZEROS
CNVR1:	MOVEI C+1," -"0
	SKIPE C
	IDIVI C,12
	HRLM C+1,(PP)
	SOSG TEMP
	SKIPE C
	PUSHJ PP,CNVR1
	HLRZ C,(PP)
	MOVEI C,"0(C)
	JRST WRITE

R50ASC:	IDIVI	C,50
	PUSH	PP,CS
	SKIPE	C
	PUSHJ	PP,R50ASC
	POP	PP,C
	HRRZ	C,CSTAT(C)
	JRST	WRITE0
îFREAD:	PUSHJ PP,READ	;GET CHARACTER COUNT
	MOVE TEMP1,C	;1ST CHAR IS COUNT OF CHARS IN FOLLOWING SYMBOL
	MOVEI AC0,0
FM4:	PUSHJ PP,READ
	CAIL C,"$
	CAILE C,"Z	;CHECK RANGE
	JRST ERROR
	HLRZ C,CSTAT-" (C)
	JUMPE C,ERROR	;ILLEGAL SQUOZE
	IMULI AC0,50
	ADD AC0,C
	SOJG TEMP1,FM4	;MORE CHARS TO GO?
	POPJ PP,

FAILM:	PUSHJ PP,READ	;IS THIS REALLY THE START?
	CAIE C,102	;RUBOUT B BEGINS ALL "NEW STYLE" CREF DATA
	JRST NOTINF
	TLZ IO,IOENDL	;INFORMATION WAS SEEN
	TLO IO,IOFAIL	;THIS IS FAIL
FM2:	PUSHJ PP,READ
	CAIN C,177	;POSSIBLE END?
	JRST TEND	;CHECK
	CAILE C,16	;IN RANGE?
	JRST ERROR
	XCT DTAB-1(C)
	TLZE SX,IODF2	;DO WE WANT TO DEFINE IT?
	TLO IO,IODEF	;YES, SET FLAG
	PUSHJ PP,FREAD	;GET THE SYMBOL
FM6:	PUSHJ PP,M5	;GO ENTER SYYMBOL
	JRST FM2

NOTINF:	PUSH PP,C	;PUT IT OUT AS IT WAS READ
	MOVEI C,177
	TLNN IO,IOLST
	PUSHJ PP,WRITE
	POP PP,C
	JRST M1	;BACK INTO MAIN STREAM

TEND:	MOVE AC0,SVLAB	;IS THERE A LABEL TO PUT IN
	SETZM SVLAB
	MOVSI SX,IOSYM
	SKIPE AC0
	PUSHJ PP,M5
	PUSHJ PP,READ	;CHECK FOR END CHARACTER
	CAIN C,101
	TLO IO,IOTABS	;CREF DATA TERMINATED WITH "RUBOUT A" MEANS
			;INSERT TAB IN LISTING
	CAIE C,103	;ALL NEW STYLE CREF DATA ENDS WITH "RUBOUT A" OR "RUBOUT C"
	CAIN C,101
	SKIPA
	JRST ERROR	;BAD CREF DATA
	MOVE C,LINE	;SET UP TO ENTER
	JRST M2B
;TABLE FOR NEW STYLE CREF CONTROL CHARACTERS
;THE TABLE ENTRIES ARE EXECUTED FROM FM2+5

DTAB:	JRST SETLAB		;FOLLOWING SYM DEFINED WITH = OR :
	JRST DLAB		;THE DEFINING OCCURANCE OF THE ABOVE  SYMBOL
	MOVSI SX,IOOP		;FOLLOWING SYM IS OP CODE, OPDEF, OR PSEUDO INSTRUCTION
	MOVSI SX,IOOP+IODF2	;DEFINING OCCURANCE OF THE ABOVE (I. E. OPDEF)
	MOVSI SX,IOMAC		;MACRO NAME
	MOVSI SX,IOMAC+IODF2	;MACRO DEFINITION
	REPEAT 6,<JRST ERROR>
	JRST BBEG	;BEGINNING OF A BLOCK FOR THE STANFORD "FAIL" ASSEMBLER
	JRST BBEND	;END OF THE ABOVE BLOCK
îSETLAB:	PUSHJ PP,FREAD		;GET LABEL
	EXCH AC0,SVLAB		;CHANGE FOR OLD
	JUMPE AC0,FM2		;NO OLD, GO GET MORE
	MOVSI SX,IOSYM		;SET TO DEFINE
	JRST FM6

DLAB:	MOVE AC0,SVLAB		;USE LAST LABEL
	SETZM SVLAB
	JUMPE AC0,ERROR		;ERROR IF NONE THERE
	MOVSI SX,IOSYM
	TLO IO,IODEF
	JRST FM6

BBEG:	AOS TEMP,LEVEL		;GET CURRENT LEVEL
	MOVSI SX,0
	PUSHJ PP,COMBG		;GO INSER
	JRST FM2

BBEND:	MOVE TEMP,LEVEL		;CURRENT LEVEL
	MOVEI SX,1
	PUSHJ PP,COMBG
	SOS LEVEL		;RESET
	JRST FM2

COMBG:	PUSHJ PP,FREAD		;GET NAME
	SKIPA
	IMULI AC0,50
	CAMG AC0,[<SQUOZE 0,%%%%%>/50 ]
	JRST .-2
	MOVE TEMP1,FREE
	ADDI FREE,4		;RESERVE 4 WORDS
	CAML FREE,SYMBOL
	PUSHJ PP,XCEED		;OVERLAP
	MOVEM AC0,(TEMP1)	;SAVE NAME
	HRLZM TEMP,1(TEMP1)	;AND LEVEL
	MOVEM LINE,2(TEMP1)	;AND CURRENT LINE
	HRLM SX,2(TEMP1)
	MOVE TEMP,BLKND		;SAVE CURRENT POINTER
	HRRM TEMP1,1(TEMP)	;SET UP LINK
	MOVEM TEMP1,BLKND
	POPJ PP,

BLKPRN:	PUSHJ PP,LINOUT
	MOVE C,@BLKND
	PUSHJ PP,R50ASC
	MOVEI C,11
	PUSHJ PP,WRITE
	MOVE C,[SQUOZE 0,PROGRA]
	PUSHJ PP,R50ASC
	MOVEI C,"M
	PUSHJ PP,WRITE
BLKP3:	PUSHJ PP,LINOUT
	HLRZ BYTEM,1(BYTEX)
	LSH BYTEM,-1
	JUMPE BYTEM,BLKP1
	PUSHJ PP,TABOUT
	SOJG BYTEM,.-1
BLKP1:	HLRZ BYTEM,1(BYTEX)
	HLRZ SX,2(BYTEX)
	TRNE BYTEM,1
	ADDI SX,4
	JUMPE SX,BLKP2
	MOVEI C," 
	PUSHJ PP,WRITE
	SOJG SX,.-1
BLKP2:	MOVE C,(BYTEX)
	PUSHJ PP,R50ASC
	HLRZ SX,2(BYTEX)
	MOVNS SX
	ADDI SX,5
	MOVEI C," 
	PUSHJ PP,WRITE
	SOJG SX,.-1
	HRRZ C,2(BYTEX)
	PUSHJ PP,CNVRT
	HRRZ BYTEX,1(BYTEX)
	JUMPN BYTEX,BLKP3
	TLO IO,IOPAGE
	POPJ PP,
î;THE LEFT HALF OF THIS TABLE IS USED TO CONVERT FROM ASCII TEXT
	;TO RADIX 50 CODE- THE FIRST LOCATION STARTS AT 40 (SPACE)
	;ZERO ENTRIES IN LEFT HALF INDICATE INVALID RADIX 50 CHAR
;THE RIGHT HALF IS USED TO CONVERT FROM RADIX 50 TO ASCII

CSTAT:
	XWD	00," 
	XWD	00,"0
	XWD	00,"1
	XWD	00,"2
	XWD	46,"3
	XWD	47,"4
	XWD	00,"5
	XWD	00,"6

	XWD	00,"7
	XWD	00,"8
	XWD	00,"9
	XWD	00,"A
	XWD	00,"B
	XWD	00,"C
	XWD	45,"D
	XWD	00,"E

	XWD	01,"F
	XWD	02,"G
	XWD	03,"H
	XWD	04,"I
	XWD	05,"J
	XWD	06,"K
	XWD	07,"L
	XWD	10,"M

	XWD	11,"N
	XWD	12,"O
	XWD	00,"P
	XWD	00,"Q
	XWD	00,"R
	XWD	00,"S
	XWD	00,"T
	XWD	00,"U
î	XWD	00,"V
	XWD	13,"W
	XWD	14,"X
	XWD	15,"Y
	XWD	16,"Z
	XWD	17,".
	XWD	20,"$
	XWD	21,"%

	XWD	22,0
	XWD	23,0
	XWD	24,0
	XWD	25,0
	XWD	26,0
	XWD	27,0
	XWD	30,0
	XWD	31,0

	XWD	32,0
	XWD	33,0
	XWD	34,0
	XWD	35,0
	XWD	36,0
	XWD	37,0
	XWD	40,0
	XWD	41,0

	XWD	42,0
	XWD	43,0
	XWD	44,0
î;SEARCH THE SYMBOL TABLE AND STORE STUFF IN IT
SRCH:	HRRZ	SX,SRCMID	;GET POINTER TO SYM IN MIDDLE OF TABLE
SRCH01:	HRRZ	TX,SRCMSB	;GET "MOST SIGNIFICANT BIT"
				; OF TABLE ENTRY COUNT

;START LOGORITHMIC SEARCH
SRCH10:	CAML	AC0,-1(SX)	;IS SYMBOL HIGHER THAN THIS?
	JRST	SRCH30		;YES
SRCH12:	SUB	SX,TX		;NO,MOVE DOWN BY DELTA INCREMENT
SRCH13:	LSH	TX,-1		;DIVIDE DELTA INCREMENT BY 2
	CAMG	SX,TOP		;OVER THE TOP OF THE TABLE?
	JUMPN	TX,SRCH10	;NO,GO LOOK SOME MORE (SEARCH IS OVER WHEN DELTA=0)
	JUMPN	TX,SRCH12	;YES,MOVE DOWN INTO TABLE (SEARCH IS OVER WHEN DELTA=0)
	CAMLE	LINE,UPPLIM	;SYMBOL NOT FOUND, SAVE SYMBOL IF IT MIGHT BE 
			;IN RANGE (SPECIFIED IN COMMAND STRING) OR IF NO RANGE GIVEN
	POPJ	PP,
	SUBI	SX,1		;MAKE SX POINT TO 1ST SYM TO BE MOVED
	MOVEI	TX,-2(SYMBOL)
	CAILE	TX,2(FREE)	;IS THERE ROOM LEFT BETWEEN THE TWO TABLES?
	JRST	SRCH20		;YES
	PUSHJ	PP,XCEED	;NO, GET MORE CORE AND MOVE SYM TABLE UP
	ADDI	SX,2000		;UPDATE SY TABLE POINTERS BY AMOUNT OF NEW CORE
	ADDI	TX,2000

SRCH20:	MOVE	SYMBOL,TX
	HRLI	TX,2(TX)
	BLT	TX,-2(SX)	;MOVE SYM TABLE TO MAKE HOLE
	AOS	0(SYMBOL)	;INDEX SYM TAB ENTRY COUNT TO ACCOUNT FOR NEW ENTRY
	MOVE	TX,FREE		;GET 1ST ADR OF A WORD PAIR FOR STORING INCREMENTS
	MOVEI BYTEX,1(FREE)	;GET ADR OF 2ND BYTE FOR 1ST WORD PAIR
	HRLI	BYTEX,(POINT 6,,5,)	;SET UP POINTER FOR 2ND BYTE OF 1ST WORD PAIR
	ADDI	FREE,2		;UPDATE FREE WORD POINTER
	MOVEM	AC0,-1(SX)	;SAVE SYMBOL IN SYMBOL TABLE
	SETZM 1(TX)		;ZERO BYTES AND POINTER TO 2ND WORD PAIR
	MOVEI C,1		;ASSUME NON-DEF OCCURANCE OF SYMBOL
	TLNE IO,IODEF		;CORRECT ASSUMPTION?
	TRC C,3			;NO, 2 INDICATES A DEF OCCURANCE (1 IS NON-DEF)
	DPB C,[POINT 6,1(TX),5,]	;SAVE REASON (DEF OR NOT) OF 
				;LAST OCCURANCE OF SYM IN 1ST BYTE
	MOVE C,LINE
	LSH C,1		;LINE # IS STORED SHIFTED LEFT 1 TO LEAVE ROOM FOR A 1 BIT
				;FOR A DEF OCCR OF THE SYMBOL
	TLZN IO,IODEF
	IORI C,1		;IT WAS DEF OCCURANCE, TURN ON BIT
	HRLM	LINE,0(SX)	;SAVE LINE # AND DEFINE BIT IN LEFT HALF OF SYM VALUE
	HRRM	TX,0(SX)	;SAVE POINTER TO BYTE WORD PAIRS
				; IN RIGHT HALF OF SYM VALUE
	PUSHJ	PP,SRCHI	;CALCULATE NEW MIDDLE ADR OF SYM TABLE AND 
				;A NEW STARTING DELTA
	JRST	STV12

SRCH30:	CAMN	AC0,-1(SX)	;HAS THE SYMBOL BEEN FOUND?
	JRST	STV10		;YES
	ADD	SX,TX		;NO, LOOK HIGHER IN TABLE
	JRST	SRCH13

;SYMBOL FOUND IN TABLE
STV10:	LDB	C,[POINT 17,0(SX),17,]	;GET LAST LINE # WHERE SYMBOL WAS SEEN
	HRRZ TX,0(SX)		;GET ADR OF 1ST WORD OF 1ST WORD PAIR
				;WHERE INCREMENTS ARE STORED
	CAME C,LINE		;IS THIS OCCR ON SAME LINE AS LAST OCCR?
	JRST STV10A		;NO
	LDB TEMP,[POINT 6,1(TX),5,];YES, GET REASON (DEF OR NOT) FOR STORING LAST TIME
	TLNN IO,IODEF	;IS THIS OCCR A DEF ONE?
	JRST STV10B	;NO
	TROE TEMP,2	;YES, WAS THE PREVIOUS ONE DEF? (A LINE MAY HAVE BOTH
			;DEF AND NON-DEF OCCRS)
	POPJ PP,	;YES, DO NOTHING (2 DEFG OCCURANCES ON SAME LINE)
	JRST STV10C	;NO,DEF+NON-DEF OCCRS ON SAME LINE
STV10B:	TROE TEMP,1	;WAS PREVIOUS OCCR NON-DEF?
	POPJ PP,	;YES, DO NOTHING (2 NON-DEF OCCRS ON SAME LINE)
	JRST STV10C	;STORE INDICATING DEF+NON-DEF ON SAME LINE

;THIS SYMBOL IS A NEW SYMBOL NEVER BEFORE SEEN
STV10A:	MOVEI TEMP,1		;ASSUME THIS IS A NON-DEF OCCR
	TLNE IO,IODEF		;CORRECT ASSUMPTION?
	TRC TEMP,3		;NO, CHANGE 1 TO A 2 TO SHOW DEFING OCCR
STV10C:	DPB TEMP,[POINT 6,1(TX),5,];SAVE TYPE (DEF OR NOT) OF OCCR IN 1ST BYTE
STV10D:
	DPB LINE,[POINT 17,0(SX),17,]	;SAVE NEW LINE # IN BITS 0-17 OF SYM VALUE
	LSH LINE,1
	TLZN IO,IODEF
	IORI LINE,1		;MAKE DEFINE BIT BE LOW ORDER BIT OF 2*LINE#
	LSH C,1
	SUBM	LINE,C		;CALCULATE DELTA LINE#
	LSH LINE,-1		;NOW ELIMINATE DEFINE BIT
	MOVE	BYTEX,0(TX)	;GET BYTE POINTER TO LAST BYTE FOR LAST SYM OCCURRANCE

STV12:	ORM	FLAG,0(SX)	;SAVE SYMBOL TYPE (MACRO, SYMBOL,OP CODE)
	CAIGE	C,32.		;IS DELTA LINE# (OR LINE# THE 1ST TIME)
				; BIGGER THAN 1 BYTE?
	JRST	STV20		;NO, IT FITS
	MOVEM	PP,PPTEMP	;2 (OR MORE) BYTES NEEDED

;DIVIDE 2*LINE#+DEFINE BIT  INTO 5 BIT BYTES, TURN ON
;BIT 30 WHENEVER THERE ARE MORE BYTES LEFT. CALL
;STV20 TO STORE THE BYTES AWAY. FOR THE LAST BYTE DO NOT TURN ON BIT 30,
;THUS INDICATING NO MORE BYTES
STV14:	IDIVI	C,32.
	PUSH	PP,CS
	CAIL	C,32.
	JRST	STV14
STV16:	TRO	C,40
	PUSHJ	PP,STV20
	POP	PP,C
	CAME	PP,PPTEMP
	JRST	STV16

STV20:	TRNE	BYTEX,1		;IS BYTE POINTER IN 1ST WORD OF WORD PAIR? OR
	CAML	BYTEX,[POINT 6,,16,]	;IN LEFT HALF OR 2ND WORD OF PAIR?
	JRST	STV22		;YES, CONTINUE USING THIS WORD PAIR
	HRRM	FREE,0(BYTEX)	;NO,MAKE RH OF 2ND WORD OF PAIR POINT TO NEW WORD PAIR
	MOVE	BYTEX,FREE	;INIT ADREESS OF BYTE POINTER IN NEW WORD PAIR
	HRLI	BYTEX,440600	;INIT BYTE POINTER PARTS TO LEFT BYTE OF
				; 1ST WORD OF NEW PAIR
	ADDI	FREE,2		;UPDATE FREE END OF TABLE
	CAML	FREE,SYMBOL	;ROOM AVAILABLE?
	PUSHJ	PP,XCEED	;NO, GET MORE CORE AND MOVE SYMBOL TABLE UP

STV22:	IDPB	C,BYTEX		;STORE INCREMENT BYTE AWAY
	MOVEM	BYTEX,0(TX)	;SAVE BYTE POINTER IN 1ST WORD OF 1ST WORD PAIR
	POPJ	PP,
îGETVAL:	TLZN IO,IODEF
	JRST GETV20
	MOVEI C,"#
	PUSHJ PP,WRITE
GETV20:	CAMN	BYTEX,BYTEM
	POPJ	PP,
	AOS	0(PP)
	PUSHJ	PP,TABOUT
	MOVEI	C,0
GETV10:	TRNE	BYTEX,1
	CAML	BYTEX,[POINT 6,,16,]
	JRST	GETV12
	MOVE	BYTEX,0(BYTEX)
	HRLI	BYTEX,(POINT 6,,,)

GETV12:	ILDB	CS,BYTEX
	ROT	CS,-5
	LSHC	C,5
	JUMPN	CS,GETV10
	TRNN C,1	;SET DEFINED FLAG
	TLO IO,IODEF
	LSH C,-1
	ADDB	LINE,C
	POPJ	PP,
îTABOUT:	MOVEI	C,11
	SOJGE	WPL,WRITE0
	PUSHJ	PP,LINOUT
	JRST	TABOUT

LINOUT:	SOSG	LPP
	TLO	IO,IOPAGE
	MOVEI	C,15
	PUSHJ	PP,WRITE
	MOVEI	C,12
	PUSHJ	PP,WRITE
	MOVEI	WPL,WPLLPT		;ASSUME LINES FOR LPT
	TLNE IO,IOTTY			;CORRECT ASSUMPTION?
	MOVEI WPL,WPLTTY		;NO, SET UP LINES TO TTY

	POPJ	PP,

WRITE0:	TLZN	IO,IOPAGE
	JRST	WRITE
	PUSH	PP,C
	MOVEI	C,14
	PUSHJ	PP,WRITE
	MOVEI	C,.LPP
	MOVEM	C,LPP
	POP	PP,C

WRITE:	CAMGE LINE,FIRSTL	;HAVE WE REACHED REQUESTED LINE?
	POPJ PP,
	SOSG	LSTCNT
	PUSHJ	PP,LSTDMP
	IDPB	C,LSTPNT
	POPJ	PP,
î
LSTDMP:	SAVE	C
	MOVE	C,[-LSTBSZ,,LSTBUF]
	.IOT	LST,C		;WRITE OUT THE BUFFER.
	MOVEI	C,5*LSTBSZ	;INIT. FILLING BUFFER.
	MOVEM	C,LSTCNT
	MOVE	C,[POINT 7,LSTBUF,,]
	MOVEM	C,LSTPNT
	REST	C
	RET

LSTCLS:	SOSGE	C,LSTCNT	;GET NUM. UNFILLED CHAR POSN'S.
	RET			;DO NOTHING IF LST NOT OPEN.
	IDIVI	C,5
	MOVEI	SX,^C		;FILL LAST WD. WITH ^C'S.
LSTCL0:	SOJL	CS,LSTCL1
	IDPB	CS,LSTPNT
	JRST	LSTCL0
LSTCL1:	HRLZI	C,-LSTBSZ(C)
	HRRI	C,LSTBUF
	.IOT	LST,C		;OUTPUT LAST BUFFERFULL.
	MOVE	0,[ASCIC//]
	.CLOSE	LST,		;FILL BLOCK WITH ^C'S.
	SETOM	LSTCNT		;INDICATE CLOSED.
	RET
;GET 1K MORE CORE AND MOVE THE SYMBOL TABLE (BOTH DDT'S AND CREF'S)
;UP INTO THE NEW SPACE

XCEED:	PUSH	PP,0
	PUSH	PP,1
	HRRZ	1,JOBREL	;GET CURRENT TOP
	LSH	1,-10.		;NUM. K. NOW HAVE.
	.CORE	1(1)		;GET 1 MORE.
	.VALUE			;OUT OF CORE? ON ITS?
	HRRO	1,JOBREL
	MOVEI	0,(1)		;COMPUTE NUM. WDS. TO MOVE.
	SUB	0,SYMBOL
	SOJ	1,
	POP	1,2000(1)	;MOVE WDS UP 1K, FROM TOP
	SOJG	0,.-1		;DOWN TO SYMBOL.
	MOVEI	1,2000
	ADDM	1,SYMBOL
	ADDM	1,JOBREL
	ADDM	1,TOP
	POP	PP,1
	POP	PP,0

;FIND LEFT MOST BIT OF NUMBER OF ENTRIES IN SYMBOL TABLE AND
;STORE IT IN SRCMSB. FIND MIDDLE ADR OF SYMBOL TABLE AND STORE
;THE ADR IN SRCMID

SRCHI:	PUSH	PP,0
	PUSH	PP,1
	MOVEI	1,0
	FAD	1,0(SYMBOL)
	LSH	1,-27.
	MOVEI	0,1000
	LSH	0,-357(1)
	HRRZM	0,SRCMSB
	LSH	0,1
	ADD	0,SYMBOL
	HRRZM	0,SRCMID
	POP	PP,1
	POP	PP,0
	POPJ	PP,
î;COME HERE ON END OF UNIT OF CREFFING.
FINIS:	POP PP,SYMBOL
	TLZN	IO,IOEOF	;IF DUE TO END CHAR WITHIN FILE,
	JRST	RECYCL		;GO HANDLE REST OF FILE.
	TLNE	IO,IOCONC	;IF CREFFING ALL INPUTS TOGETHER,
	JRST	FINIS2		;JUST CLOSE LST (ALL FILES DONE).

;HANDLING FILES SEPARATELY, COME AT END OF EACH FILE.
	MOVE	C,INFN2		;HANDLING SEPARATELY: IF FN2='CREF'
	CAMN	C,[SIXBIT/CREF/]
	TLNE	IO,IOPROT	;AND /P WASN'T GIVEN,
	JRST	FINIS1
	SAVE	INDEV		;DELETE THE INPUT FILE.
	SAVE	INSNM		;(THESE WDS USED BY .FDELE).
	.SUSET	[.SSNAM,,INSNM]
	SETZM	INSNM		;NEW FN1=0 MEANS DELETE.
	HRRZS	INDEV
	REST	INSNM
	REST	INDEV


FINIS1:	SKIPG	TTICNT		;IF MORE FILES TO CREF,
	JRST	FINIS2
	HRRZ	C,LSTDEV	;UNLESS LST ON LPT
	CAIE	C,(SIXBIT/LPT/)
	SKIPE	LSTFN1		;OR FIXED FN1 WAS SPECIFIED,
	CAIA
FINIS2:	CALL	LSTCLS		;CLOSE THE LST FILE
	SKIPG	TTICNT		;GET NEW CMD IF ALL FILES DONE.
	JRST	RESTRT
	JRST	INSET		;ELSE OPEN NEXT INPUT, REOPEN LST IF WAS CLOSED.
;OPEN THE INPUT FILE WHOSE NAME WAS READ IN.
INFILE:	MOVEI	CS,(SIXBIT/DSK/)
	SKIPN	INDEV
	MOVEM	CS,INDEV	;DEFAULT DEVICE.
	MOVE	CS,MSNAME
	SKIPN	INSNM
	MOVEM	CS,INSNM	;DEFAULT SNAME.
	.SUSET	[.SSNAM,,INSNM]
	MOVEI	CS,6
	HRLM	CS,INDEV	;SET UP MODE FOR INPUT.
	MOVE	CS,[SIXBIT/CREF/]
	SKIPN	INFN2		;DEFAULT FN2 IS 'CREF'.
	MOVEM	CS,INFN2
	.OPEN	INC,INDEV	;ELSE USE SPECIFIED ONE.
INFIL2:	CALL	OPENL
INFIL0:	SETZM	INCNT		;INIT. BUFFER FILLING.
	RET

;READ 1 CHAR INTO C.
READ:	SOSG	INCNT		;BUFFER EMPTY?
	JRST	READ3		;YES
READ1:	ILDB	C,INPNT		;PLACE CHARACTER IN C
	CAIN	C,^C
	JRST	READ4		;^C MEANS EOF.
	RET

READ3:	MOVE	C,[-INBSZ,,INBUF]
	.IOT	INC,C		;TRY TO READ BUFFERFULL.
	HLRZ	C,C
	ADDI	C,INBSZ		;NUM. WDS. READ.
	JUMPE	C,READ4		;NONE => AT EOF.
	IMULI	C,5
	MOVEM	C,INCNT		;ELSE SAVE NUM CHARS READ.
	MOVE	C,[POINT 7,INBUF,,]
	MOVEM	C,INPNT
	JRST	READ1

;COME HERE ON EOF.
READ4:	TLNE	IO,IOCONC	;IF NOT CREFFING TOGETHER
	SKIPN	TTICNT		;OR NO MORE FILES
	JRST	READ5		;WRITE OUT TABLES.
	MOVEM	16,CMDSAV+16	;ELSE CONTINUE WITH NEXT FILE.
	MOVEI	16,CMDSAV
	BLT	16,CMDSAV+15	;SAVE AC'S SO COMMAND SCANNER CAN RUN
	CALL	RFILE		;SCAN NEXT INPUT FILE
	CALL	INFILE		;SET UP THE INPUT FILE
	MOVSI	16,CMDSAV	;RESTORE THE AC'S
	BLT	16,16
	JRST	READ		; AND TRY TO READ THIS FILES INPUT

;COME HERE WHEN EOF MEANS WRITE OUT TABLES.
READ5:	TLO	IO,IOEOF	;TELL FINIS WHAT TO DO.
	JRST	R0
;READ IN A COMMAND, PROCESSING RUBOUTS, PROMPTING WITH "*".
TTILIN:	CALL	CRLF

;COME HERE AFTER NULL LINE.
TTILI2:	SETZM	TTICNT		;NO CHARS READ YET.
	SKIPN	SRCTTY
	.IOT	TTO,["*]
	MOVE	C ,[440700,,TTIBUF]
	SKIPE	SRCTTY
	HRRI	C ,INBUF
	MOVEM	C ,TTIPNT
TTILUP:	.IOT	TTI,C 		;READ A CHAR.
	CAIN	C ,^M
	JRST	TTICR		;^M MEANS ALL READ.
	CAIN	C,^U
	JRST	TTILIN		;^U CANCELS CMD.
	CAIN	C ,177
	JRST	TTIRUB
	CAIN	C,^C
	JRST	TTICTC		;^C MEANS DO CMD, THEN VALRET :KILL.
	IDPB	C ,TTIPNT	;NORMAL CHAR.
	AOS	TTICNT
	JRST	TTILUP

TTICTC:	.IOT	TTO,[^M]	;INDICATE TERMINATING RUBOUT PROC.
	SETOM	CTLCF		;REMEMBER TO VALRET WHEN CMD DONE.

TTICR:	SKIPE	SRCTTY
	RET			;SPECIAL STUFF IF READING SRC.
	SKIPN	TTICNT		;ON NULL LINE, RETRY.
	JRST	TTILI3
	MOVE	C ,[440700,,TTIBUF]
	MOVEM	C ,TTIPNT	;SET UP FOR REMOVAL OF CHARS.
	RET

TTILI3:	SKIPE	CTLCF		;NULL LINE:
	.BREAK	16,140000	;...IF ^C ENDED LINE.
	JRST	TTILI2

TTIRUB:	SOSGE	TTICNT		;IF NO CHAR TO RUB, RETRY.
	JRST	TTILIN
	LDB	C ,TTIPNT
	.IOT	TTO,C 		;PRINT RUBBED CHAR.
	MOVSI	C ,070000
	ADD	C ,TTIPNT
	JUMPGE	C ,TTIRU1	;IF STILL IN SAME WD.
	MOVEI	C ,-1(C )	;ELSE, MOVE TO END OF PREV. WD.
	HRLI	C ,010700
TTIRU1:	MOVEM	C ,TTIPNT
	JRST	TTILUP
BP==SX

RFILE:	SETZM	INFN2		;DEFAULT FN2 UP TO CALLER.
	SETZ	CS,
RFNAME:	MOVE	BP,[440600,,0]
	MOVEI	0,6		;SET UP TO READ IN A FILENAME.
	MOVEM	0,RFILC
	SETZ	0,
RFLOOP:	CALL	TTICHR		;READ A CHAR.
	CAIN	C,^Q
	JRST	RFCTQ		;^Q QUOTES NEXT CHAR.
	CAIE	C,",
	CAIN	C,^M
	JRST	RFSPAC		;", , ^M TERMINATE SPEC.
	CAIE	C,"_
	CAIN	C," 
	JRST	RFSPAC		;THESE ALSO.
	CAIN	C,":
	JRST	RFCOL		;COLON SETS DEV.
	CAIN	C,";
	JRST	RFSEM		;SEMI SETS SNAME.
	CAIN	C,"/
	JRST	RFSPAC		;SLASH ENDS NAME.
	JRST	RFNORM		;ALL OTHER CHARS.

RFCTQ:	CALL	TTICHR
RFNORM:	MOVEI	C,-40(C)	;CONV. TO SIXBIT.
	SOSL	RFILC		;PUT IN NAME IF ROOM LEFT.
	IDPB	C,BP
	JRST	RFLOOP

RFXCTB:	MOVEM	0,INFN1
	MOVEM	0,INFN2
	HLRM	0,INDEV
	MOVEM	0,INSNM
	SKIPA
;FOR SWITCH "A, SET OR CLEAR BIT D ACCORDING TO B.
DEFINE	SWITCH	A,B,D
	CAIN	C,"A
	HRR!B!I	BP,D
TERMIN

RFCOL:	SKIPE	0
	HLRM	0,INDEV		;SET DEVICE FIELD.
	JRST	RFNAME

RFSEM:	SKIPE	0
	MOVEM	0,INSNM
	JRST	RFNAME

RFSPAC:	JUMPE	0,RFSPA0	;IF NAME WAS READ,
	XCT	RFXCTB(CS)	;STORE IT,
	AOJ	CS,		;INCR. STORING POS.
RFSPA0:	CAIN	C ,40
	JRST	RFNAME		;SPACE -- GET ANOTHER NAME.
	CAIE	C ,"/
	RET			;NOT SLASH, RETURN.
	CALL	TTICHR		;ELSE READ A SWITCH.
	SAVE	C		;REMEMBER IF "-".
	CAIN	C,"-
	CALL	TTICHR		;IF SO, PASS IT.
	SETZ	BP,
	CAIN	C,"(		;/( - LIMITS FOR RANGE FOLLOW.
	JRST	RFSWB
	SWITCH	C,O,IOCONC	;/C - CONCAT ALL INPUT FILES.
	CAIN	C,"D
	JRST	RFSWD		;/D - DISOWN SELF.
	SWITCH	L,O,IOLST	;/S - DON'T LIST SOURCE.
	SWITCH	S,Z,IOSYM	;/S - DON'T LIST NORMAL SYM. CREF.
	SWITCH	M,Z,IOMAC	;/M - DON'T LIST MACRO CREF.
	SWITCH	O,O,IOOP	;/O - LIST OPERATOR CREF.
	SWITCH	P,O,IOPROT	;/P - PROTECT INPUT FILE W/ 2ND NAME 'CREF'.
	JUMPE	BP,ERRSW	;ERROR UNLESS ONE OF ABOVE SWITCHES.
	REST	C		;GET BACK 1ST CHAR.
	CAIN	C,"-		;IF WAS "-",
	TLC	BP,-1		;CVOMPLEMENT SENSE OF SWITCH.
	SKIPL	BP		;NEG. MEANS SET,
	TLZA	IO,(BP)		;POS. MEANS CLEAR.
	TLO	IO,(BP)
	JRST	RFNAME		;SWITCH DONE, READ ANOTHER NAME.
RFSWD:	REST	C
	.OPEN	TTI,[SIXBIT/   NUL/]
	.VALUE
	.OPEN	TTO,[SIXBIT/  !NUL/]
	.VALUE
	.VALUE	[ASCIZ/:DISOWN :V /]	;GIVE BACK TTY.
	JRST	RFNAME

RFSWB:	CALL	TTINUM		;READ IN LOWER LIMIT.
	MOVEM	0,LOWLIM
	CALL	TTIPSP		;PASS SPACES.
	CAIE	C,",
	JRST	ERRCM		;COMMA MUST FOLLOW.
	CALL	TTINUM		;READ UPPER LIMIT.
	MOVEM	0,UPPLIM
	CALL	TTIPSP
	REST	0		;FLUSH SAVED CHAR.
	CAIN	C,")
	JRST	RFNAME		;CLOSEPAREN MUST FOLLOW.
	JRST	ERRCM

TTINUM:	CALL	TTICHR
	CALL	TTIPSP		;PASS SPACES.
	TDZA	0,0
TTINU1:	CALL	TTICHR
	CAIL	C,"0		;IF CHAR NOT DIGIT, RETURN.
	CAILE	C,"9
	RET
	IMULI	0,10.		;ELSE ACCUMULATE DIGIT
	ADDI	0,-"0(C)
	JRST	TTINU1		;AND TRY AGAIN.

;PASS SPACES.
TTIPSP:	CAIE	C," 
	RET
	CALL	TTICHR
	JRST	TTIPSP

TTICHR:	SOSGE	TTICNT		;IF NO CHARS LEFT,
	SKIPA	C,[^M]		;SAY EOL.
	ILDB	C,TTIPNT	;ELSE GET NEXT CHAR FROM BUFFER.
	RET
;OUTPUT 6BIT WD IN 0 TO TTY.
TTOSIX:	MOVE	C,0
TTOSI0:	SETZ	CS,
	ROTC	C,6		;GET NEXT CHAR.
	JUMPE	CS,CPOPJ
	MOVEI	CS," (CS)	;CONV. 6BIT TO ASCII.
	.IOT	TTO,CS
	JRST	TTOSI0

TYO:	.IOT	TTO,C
	RET

CRLF:	.IOT	TTO,[^M]
	.IOT	TTO,[^J]
	RET

ERRSW:	JSP	RC,ERRMSG
	SIXBIT /ILLEGAL SWITCH@/

ERRCM:	JSP	RC,ERRMSG
	SIXBIT /COMMAND ERROR@/


ERRMSG:	PUSHJ PP,PNTMSG		;FOR SIMPLE ERROR MESSAGES

ERRFIN:	SETZM	CTLCF
	CALL	CRLF
	JRST	RESTRT		;START CREF OVER

PNTMSG:	PUSHJ PP,CRLF		;PRINT SIXBIT MESSAGE
	HRLI RC,(POINT 6,0,,)
PNTM1:	ILDB C,RC
	CAIN C,40		;STOP AT @
	POPJ PP,
	ADDI C,40		;CONVERT TO ASCII
	PUSHJ PP,TYO
	JRST PNTM1
;COME HERE ON FAILING LST FILE OPEN.
OPENLL:	MOVE	C,[LSTDEV,,INDEV]
	BLT	C,INSNM		;MOVE LST FILE NAMES FOR OPENL.

;COME HERE AFTER FAILING INPUT OPEN.
OPENL:	SETZM	CTLCF		;DON'T KILL SELF.
	CALL	LSTFIL		;PRINT NAME OF LOSING FILE.
	.IOT	TTO,[^I]
	.OPEN	ERRC,ERRFIL
	.VALUE
OPENL0:	.IOT	ERRC,C
	CAIN	C,^L
	JRST	RESTRT
	.IOT	TTO,C
	JRST	OPENL0

ERRFIL:	SIXBIT/   ERR/
	1?0

;PRINT NAME OF CURRENT FILE ON LST IOR TTY.
LSTFIL:	HRLZ	0,INDEV
	CAMN	0,[SIXBIT/DSK/]
	JRST	LSTFI1
	CALL	TTOSIX		;PRINT DEV IF NOT DSK.
	.IOT	TTO,[":]
	JRST	LSTFI2

LSTFI1:	MOVE	0,INSNM		;IS DSK - PRINT SNAME
	CAMN	0,MSNAME	;IF DIFFERENT FROM USER'S.
	JRST	LSTFI2
	CALL	TTOSIX
	.IOT	TTO,[";]

LSTFI2:	MOVE	0,INFN1
	CALL	TTOSIX		;PRINT 1ST NAME.
	.IOT	TTO,[" ]
	MOVE	0,INFN2
	JRST	TTOSIX		;, 2ND NAME.

CONSTA

JOBFFI:	BLOCK	500	;MAKE SURE AT LEAST THAT MUCH FREE CORE.
JOBFFJ=	2000+<.&-2000>	;JOBFFJ IS NEXT K BNDRY.

	END	CREF
